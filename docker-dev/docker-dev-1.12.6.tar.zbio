$self->{sign} = $sign;
  ($self->{_a},$self->{_p}) = @_;		# take over requested rounding
  $self;
  }

sub bzero
  {
  # create a bigint '+0', if given a BigInt, set it to 0
  my $self = shift;
  $self = __PACKAGE__ if !defined $self;
 
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('bzero');
  
  if ($self->can('_bzero'))
    {
    # use subclass to initialize
    $self->_bzero();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $self->{sign} = '+';
  if (@_ > 0)
    {
    if (@_ > 3)
      {
      # call like: $x->bzero($a,$p,$r,$y);
      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@_);
      }
    else
      {
      $self->{_a} = $_[0]
       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));
      $self->{_p} = $_[1]
       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));
      }
    }
  $self;
  }

sub bone
  {
  # create a bigint '+1' (or -1 if given sign '-'),
  # if given a BigInt, set it to +1 or -1, respectively
  my $self = shift;
  my $sign = shift; $sign = '+' if !defined $sign || $sign ne '-';
  $self = $class if !defined $self;

  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('bone');

  if ($self->can('_bone'))
    {
    # use subclass to initialize
    $self->_bone();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_one();
    }
  $self->{sign} = $sign;
  if (@_ > 0)
    {
    if (@_ > 3)
      {
      # call like: $x->bone($sign,$a,$p,$r,$y);
      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@_);
      }
    else
      {
      # call like: $x->bone($sign,$a,$p,$r);
      $self->{_a} = $_[0]
       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));
      $self->{_p} = $_[1]
       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));
      }
    }
  $self;
  }

##############################################################################
# string conversion

sub bsstr
  {
  # (ref to BFLOAT or num_str ) return num_str
  # Convert number from internal format to scientific string format.
  # internal format is always normalized (no leading zeros, "-0E0" => "+0E0")
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_); 

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';	# -inf, NaN
    return 'inf';					# +inf
    }
  my ($m,$e) = $x->parts();
  #$m->bstr() . 'e+' . $e->bstr(); 	# e can only be positive in BigInt
  # 'e+' because E can only be positive in BigInt
  $m->bstr() . 'e+' . $CALC->_str($e->{value}); 
  }

sub bstr 
  {
  # make a string from bigint object
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_); 

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';	# -inf, NaN
    return 'inf';					# +inf
    }
  my $es = ''; $es = $x->{sign} if $x->{sign} eq '-';
  $es.$CALC->_str($x->{value});
  }

sub numify 
  {
  # Make a "normal" scalar from a BigInt object
  my $x = shift; $x = $class->new($x) unless ref $x;

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;
  my $num = $CALC->_num($x->{value});
  return -$num if $x->{sign} eq '-';
  $num;
  }

##############################################################################
# public stuff (usually prefixed with "b")

sub sign
  {
  # return the sign of the number: +/-/-inf/+inf/NaN
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_); 
  
  $x->{sign};
  }

sub _find_round_parameters
  {
  # After any operation or when calling round(), the result is rounded by
  # regarding the A & P from arguments, local parameters, or globals.

  # !!!!!!! If you change this, remember to change round(), too! !!!!!!!!!!

  # This procedure finds the round parameters, but it is for speed reasons
  # duplicated in round. Otherwise, it is tested by the testsuite and used
  # by fdiv().
 
  # returns ($self) or ($self,$a,$p,$r) - sets $self to NaN of both A and P
  # were requested/defined (locally or globally or both)
  
  my ($self,$a,$p,$r,@args) = @_;
  # $a accuracy, if given by caller
  # $p precision, if given by caller
  # $r round_mode, if given by caller
  # @args all 'other' arguments (0 for unary, 1 for binary ops)

  my $c = ref($self);				# find out class of argument(s)
  no strict 'refs';

  # convert to normal scalar for speed and correctness in inner parts
  $a = $a->can('numify') ? $a->numify() : "$a" if defined $a && ref($a);
  $p = $p->can('numify') ? $p->numify() : "$p" if defined $p && ref($p);

  # now pick $a or $p, but only if we have got "arguments"
  if (!defined $a)
    {
    foreach ($self,@args)
      {
      # take the defined one, or if both defined, the one that is smaller
      $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
      }
    }
  if (!defined $p)
    {
    # even if $a is defined, take $p, to signal error for both defined
    foreach ($self,@args)
      {
      # take the defined one, or if both defined, the one that is bigger
      # -2 > -3, and 3 > 2
      $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
      }
    }
  # if still none defined, use globals (#2)
  $a = ${"$c\::accuracy"} unless defined $a;
  $p = ${"$c\::precision"} unless defined $p;

  # A == 0 is useless, so undef it to signal no rounding
  $a = undef if defined $a && $a == 0;
 
  # no rounding today? 
  return ($self) unless defined $a || defined $p;		# early out

  # set A and set P is an fatal error
  return ($self->bnan()) if defined $a && defined $p;		# error

  $r = ${"$c\::round_mode"} unless defined $r;
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
    {
    require Carp; Carp::croak ("Unknown round mode '$r'");
    }

  $a = int($a) if defined $a;
  $p = int($p) if defined $p;

  ($self,$a,$p,$r);
  }

sub round
  {
  # Round $self according to given parameters, or given second argument's
  # parameters or global defaults 

  # for speed reasons, _find_round_parameters is embedded here:

  my ($self,$a,$p,$r,@args) = @_;
  # $a accuracy, if given by caller
  # $p precision, if given by caller
  # $r round_mode, if given by caller
  # @args all 'other' arguments (0 for unary, 1 for binary ops)

  my $c = ref($self);				# find out class of argument(s)
  no strict 'refs';

  # now pick $a or $p, but only if we have got "arguments"
  if (!defined $a)
    {
    foreach ($self,@args)
      {
      # take the defined one, or if both defined, the one that is smaller
      $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
      }
    }
  if (!defined $p)
    {
    # even if $a is defined, take $p, to signal error for both defined
    foreach ($self,@args)
      {
      # take the defined one, or if both defined, the one that is bigger
      # -2 > -3, and 3 > 2
      $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
      }
    }
  # if still none defined, use globals (#2)
  $a = ${"$c\::accuracy"} unless defined $a;
  $p = ${"$c\::precision"} unless defined $p;
 
  # A == 0 is useless, so undef it to signal no rounding
  $a = undef if defined $a && $a == 0;
  
  # no rounding today? 
  return $self unless defined $a || defined $p;		# early out

  # set A and set P is an fatal error
  return $self->bnan() if defined $a && defined $p;

  $r = ${"$c\::round_mode"} unless defined $r;
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
    {
    require Carp; Carp::croak ("Unknown round mode '$r'");
    }

  # now round, by calling either fround or ffround:
  if (defined $a)
    {
    $self->bround(int($a),$r) if !defined $self->{_a} || $self->{_a} >= $a;
    }
  else # both can't be undefined due to early out
    {
    $self->bfround(int($p),$r) if !defined $self->{_p} || $self->{_p} <= $p;
    }
  # bround() or bfround() already called bnorm() if nec.
  $self;
  }

sub bnorm
  { 
  # (numstr or BINT) return BINT
  # Normalize number -- no-op here
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);
  $x;
  }

sub babs 
  {
  # (BINT or num_str) return BINT
  # make number absolute, or return absolute BINT from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x if $x->modify('babs');
  # post-normalized abs for internal use (does nothing for NaN)
  $x->{sign} =~ s/^-/+/;
  $x;
  }

sub bsgn {
    # Signum function.

    my $self = shift;

    return $self if $self->modify('bsgn');

    return $self -> bone("+") if $self -> is_pos();
    return $self -> bone("-") if $self -> is_neg();
    return $self;               # zero or NaN
}

sub bneg 
  { 
  # (BINT or num_str) return BINT
  # negate number or make a negated number from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);
  
  return $x if $x->modify('bneg');

  # for +0 do not negate (to have always normalized +0). Does nothing for 'NaN'
  $x->{sign} =~ tr/+-/-+/ unless ($x->{sign} eq '+' && $CALC->_is_zero($x->{value}));
  $x;
  }

sub bcmp 
  {
  # Compares 2 values.  Returns one of undef, <0, =0, >0. (suitable for sort)
  # (BINT or num_str, BINT or num_str) return cond_code
  
  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);

  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@_);
    }

  return $upgrade->bcmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;
    return +1 if $x->{sign} eq '+inf';
    return -1 if $x->{sign} eq '-inf';
    return -1 if $y->{sign} eq '+inf';
    return +1;
    }
  # check sign for speed first
  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';	# does also 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0 

  # have same sign, so compare absolute values. Don't make tests for zero here
  # because it's actually slower than testing in Calc (especially w/ Pari et al)

  # post-normalized compare for internal use (honors signs)
  if ($x->{sign} eq '+') 
    {
    # $x and $y both > 0
    return $CALC->_acmp($x->{value},$y->{value});
    }

  # $x && $y both < 0
  $CALC->_acmp($y->{value},$x->{value});	# swapped acmp (lib returns 0,1,-1)
  }

sub bacmp 
  {
  # Compares 2 values, ignoring their signs. 
  # Returns one of undef, <0, =0, >0. (suitable for sort)
  # (BINT, BINT) return cond_code
  
  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@_);
    }

  return $upgrade->bacmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} =~ /^[+-]inf$/;
    return 1 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} !~ /^[+-]inf$/;
    return -1;
    }
  $CALC->_acmp($x->{value},$y->{value});	# lib does only 0,1,-1
  }

sub badd 
  {
  # add second arg (BINT or string) to first (BINT) (modifies first)
  # return result as BINT

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('badd');
  return $upgrade->badd($upgrade->new($x),$upgrade->new($y),@r) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  $r[3] = $y;				# no push!
  # inf and NaN handling
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # NaN first
    return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    # inf handling
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +inf++inf or -inf+-inf => same, rest is NaN
      return $x if $x->{sign} eq $y->{sign};
      return $x->bnan();
      }
    # +-inf + something => +inf
    # something +-inf => +-inf
    $x->{sign} = $y->{sign}, return $x if $y->{sign} =~ /^[+-]inf$/;
    return $x;
    }
    
  my ($sx, $sy) = ( $x->{sign}, $y->{sign} ); 		# get signs

  if ($sx eq $sy)  
    {
    $x->{value} = $CALC->_add($x->{value},$y->{value});	# same sign, abs add
    }
  else 
    {
    my $a = $CALC->_acmp ($y->{value},$x->{value});	# absolute compare
    if ($a > 0)                           
      {
      $x->{value} = $CALC->_sub($y->{value},$x->{value},1); # abs sub w/ swap
      $x->{sign} = $sy;
      } 
    elsif ($a == 0)
      {
      # speedup, if equal, set result to 0
      $x->{value} = $CALC->_zero();
      $x->{sign} = '+';
      }
    else # a < 0
      {
      $x->{value} = $CALC->_sub($x->{value}, $y->{value}); # abs sub
      }
    }
  $x->round(@r);
  }

sub bsub 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # subtract second arg from first, modify first
  
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bsub');

  return $upgrade->new($x)->bsub($upgrade->new($y),@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));

  return $x->round(@r) if $y->is_zero();

  # To correctly handle the lone special case $x->bsub($x), we note the sign
  # of $x, then flip the sign from $y, and if the sign of $x did change, too,
  # then we caught the special case:
  my $xsign = $x->{sign};
  $y->{sign} =~ tr/+\-/-+/; 	# does nothing for NaN
  if ($xsign ne $x->{sign})
    {
    # special case of $x->bsub($x) results in 0
    return $x->bzero(@r) if $xsign =~ /^[+-]$/;
    return $x->bnan();          # NaN, -inf, +inf
    }
  $x->badd($y,@r); 		# badd does not leave internal zeros
  $y->{sign} =~ tr/+\-/-+/; 	# refix $y (does nothing for NaN)
  $x;				# already rounded by badd() or no round nec.
  }

sub binc
  {
  # increment arg by one
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);
  return $x if $x->modify('binc');

  if ($x->{sign} eq '+')
    {
    $x->{value} = $CALC->_inc($x->{value});
    return $x->round($a,$p,$r);
    }
  elsif ($x->{sign} eq '-')
    {
    $x->{value} = $CALC->_dec($x->{value});
    $x->{sign} = '+' if $CALC->_is_zero($x->{value}); # -1 +1 => -0 => +0
    return $x->round($a,$p,$r);
    }
  # inf, nan handling etc
  $x->badd($self->bone(),$a,$p,$r);		# badd does round
  }

sub bdec
  {
  # decrement arg by one
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);
  return $x if $x->modify('bdec');
  
  if ($x->{sign} eq '-')
    {
    # x already < 0
    $x->{value} = $CALC->_inc($x->{value});
    } 
  else
    {
    return $x->badd($self->bone('-'),@r) unless $x->{sign} eq '+'; 	# inf or NaN
    # >= 0
    if ($CALC->_is_zero($x->{value}))
      {
      # == 0
      $x->{value} = $CALC->_one(); $x->{sign} = '-';		# 0 => -1
      }
    else
      {
      # > 0
      $x->{value} = $CALC->_dec($x->{value});
      }
    }
  $x->round(@r);
  }

sub blog
  {
  # calculate $x = $a ** $base + $b and return $a (e.g. the log() to base
  # $base of $x)

  # set up parameters
  my ($self,$x,$base,@r) = (undef,@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$base,@r) = objectify(2,@_);
    }

  return $x if $x->modify('blog');

  $base = $self->new($base) if defined $base && !ref $base;

  # inf, -inf, NaN, <0 => NaN
  return $x->bnan()
   if $x->{sign} ne '+' || (defined $base && $base->{sign} ne '+');

  return $upgrade->blog($upgrade->new($x),$base,@r) if 
    defined $upgrade;

  # fix for bug #24969:
  # the default base is e (Euler's number) which is not an integer
  if (!defined $base)
    {
    require Math::BigFloat;
    my $u = Math::BigFloat->blog(Math::BigFloat->new($x))->as_int();
    # modify $x in place
    $x->{value} = $u->{value};
    $x->{sign} = $u->{sign};
    return $x;
    }
  
  my ($rc,$exact) = $CALC->_log_int($x->{value},$base->{value});
  return $x->bnan() unless defined $rc;		# not possible to take log?
  $x->{value} = $rc;
  $x->round(@r);
  }

sub bnok
  {
  # Calculate n over k (binomial coefficient or "choose" function) as integer.
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bnok');
  return $x->bnan() if $x->{sign} eq 'NaN' || $y->{sign} eq 'NaN';
  return $x->binf() if $x->{sign} eq '+inf';

  # k > n or k < 0 => 0
  my $cmp = $x->bacmp($y);
  return $x->bzero() if $cmp < 0 || $y->{sign} =~ /^-/;
  # k == n => 1
  return $x->bone(@r) if $cmp == 0;

  if ($CALC->can('_nok'))
    {
    $x->{value} = $CALC->_nok($x->{value},$y->{value});
    }
  else
    {
    # ( 7 )       7!       1*2*3*4 * 5*6*7   5 * 6 * 7       6   7
    # ( - ) = --------- =  --------------- = --------- = 5 * - * -
    # ( 3 )   (7-3)! 3!    1*2*3*4 * 1*2*3   1 * 2 * 3       2   3

    if (!$y->is_zero())
      {
      my $z = $x - $y;
      $z->binc();
      my $r = $z->copy(); $z->binc();
      my $d = $self->new(2);
      while ($z->bacmp($x) <= 0)		# f <= x ?
        {
        $r->bmul($z); $r->bdiv($d);
        $z->binc(); $d->binc();
        }
      $x->{value} = $r->{value}; $x->{sign} = '+';
      }
    else { $x->bone(); }
    }
  $x->round(@r);
  }

sub bexp
  {
  # Calculate e ** $x (Euler's number to the power of X), truncated to
  # an integer value.
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);
  return $x if $x->modify('bexp');

  # inf, -inf, NaN, <0 => NaN
  return $x->bnan() if $x->{sign} eq 'NaN';
  return $x->bone() if $x->is_zero();
  return $x if $x->{sign} eq '+inf';
  return $x->bzero() if $x->{sign} eq '-inf';

  my $u;
  {
    # run through Math::BigFloat unless told otherwise
    require Math::BigFloat unless defined $upgrade;
    local $upgrade = 'Math::BigFloat' unless defined $upgrade;
    # calculate result, truncate it to integer
    $u = $upgrade->bexp($upgrade->new($x),@r);
  }

  if (!defined $upgrade)
    {
    $u = $u->as_int();
    # modify $x in place
    $x->{value} = $u->{value};
    $x->round(@r);
    }
  else { $x = $u; }
  }

sub blcm
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object
  # Lowest Common Multiple

  my $y = shift; my ($x);
  if (ref($y))
    {
    $x = $y->copy();
    }
  else
    {
    $x = $class->new($y);
    }
  my $self = ref($x);
  while (@_) 
    {
    my $y = shift; $y = $self->new($y) if !ref ($y);
    $x = __lcm($x,$y);
    } 
  $x;
  }

sub bgcd 
  { 
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object
  # GCD -- Euclid's algorithm, variant C (Knuth Vol 3, pg 341 ff)

  my $y = shift;
  $y = $class->new($y) if !ref($y);
  my $self = ref($y);
  my $x = $y->copy()->babs();			# keep arguments
  return $x->bnan() if $x->{sign} !~ /^[+-]$/;	# x NaN?

  while (@_)
    {
    $y = shift; $y = $self->new($y) if !ref($y);
    return $x->bnan() if $y->{sign} !~ /^[+-]$/;	# y NaN?
    $x->{value} = $CALC->_gcd($x->{value},$y->{value});
    last if $CALC->_is_one($x->{value});
    }
  $x;
  }

sub bnot 
  {
  # (num_str or BINT) return BINT
  # represent ~x as twos-complement number
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);
 
  return $x if $x->modify('bnot');
  $x->binc()->bneg();			# binc already does round
  }

##############################################################################
# is_foo test routines
# we don't need $self, so undef instead of ref($_[0]) make it slightly faster

sub is_zero
  {
  # return true if arg (BINT or num_str) is zero (array '+', '0')
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);
  
  return 0 if $x->{sign} !~ /^\+$/;			# -, NaN & +-inf aren't
  $CALC->_is_zero($x->{value});
  }

sub is_nan
  {
  # return true if arg (BINT or num_str) is NaN
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  $x->{sign} eq $nan ? 1 : 0;
  }

sub is_inf
  {
  # return true if arg (BINT or num_str) is +-inf
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  if (defined $sign)
    {
    $sign = '[+-]inf' if $sign eq '';	# +- doesn't matter, only that's inf
    $sign = "[$1]inf" if $sign =~ /^([+-])(inf)?$/;	# extract '+' or '-'
    return $x->{sign} =~ /^$sign$/ ? 1 : 0;
    }
  $x->{sign} =~ /^[+-]inf$/ ? 1 : 0;		# only +-inf is infinity
  }

sub is_one
  {
  # return true if arg (BINT or num_str) is +1, or -1 if sign is given
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@_) : objectify(1,@_);
    
  $sign = '+' if !defined $sign || $sign ne '-';
 
  return 0 if $x->{sign} ne $sign; 	# -1 != +1, NaN, +-inf aren't either
  $CALC->_is_one($x->{value});
  }

sub is_odd
  {
  # return true when arg (BINT or num_str) is odd, false for even
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
  $CALC->_is_odd($x->{value});
  }

sub is_even
  {
  # return true when arg (BINT or num_str) is even, false for odd
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
  $CALC->_is_even($x->{value});
  }

sub is_positive
  {
  # return true when arg (BINT or num_str) is positive (> 0)
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 1 if $x->{sign} eq '+inf';			# +inf is positive

  # 0+ is neither positive nor negative
  ($x->{sign} eq '+' && !$x->is_zero()) ? 1 : 0;
  }

sub is_negative
  {
  # return true when arg (BINT or num_str) is negative (< 0)
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);
  
  $x->{sign} =~ /^-/ ? 1 : 0; 		# -inf is negative, but NaN is not
  }

sub is_int
  {
  # return true when arg (BINT or num_str) is an integer
  # always true for BigInt, but different for BigFloats
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);
  
  $x->{sign} =~ /^[+-]$/ ? 1 : 0;		# inf/-inf/NaN aren't
  }

###############################################################################

sub bmul 
  { 
  # multiply the first number by the second number
  # (BINT or num_str, BINT or num_str) return BINT

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bmul');

  return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/); 
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/); 
    return $x->binf('-');
    }

  return $upgrade->bmul($x,$upgrade->new($y),@r)
   if defined $upgrade && !$y->isa($self);
  
  $r[3] = $y;				# no push here

  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +

  $x->{value} = $CALC->_mul($x->{value},$y->{value});	# do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value}); 	# no -0

  $x->round(@r);
  }

sub bmuladd
  { 
  # multiply two numbers and then add the third to the result
  # (BINT or num_str, BINT or num_str, BINT or num_str) return BINT

  # set up parameters
  my ($self,$x,$y,$z,@r) = objectify(3,@_);

  return $x if $x->modify('bmuladd');

  return $x->bnan() if  ($x->{sign} eq $nan) ||
			($y->{sign} eq $nan) ||
			($z->{sign} eq $nan);

  # inf handling of x and y
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/); 
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/); 
    return $x->binf('-');
    }
  # inf handling x*y and z
  if (($z->{sign} =~ /^[+-]inf$/))
    {
    # something +-inf => +-inf
    $x->{sign} = $z->{sign}, return $x if $z->{sign} =~ /^[+-]inf$/;
    }

  return $upgrade->bmuladd($x,$upgrade->new($y),$upgrade->new($z),@r)
   if defined $upgrade && (!$y->isa($self) || !$z->isa($self) || !$x->isa($self));
 
  # TODO: what if $y and $z have A or P set?
  $r[3] = $z;				# no push here

  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +

  $x->{value} = $CALC->_mul($x->{value},$y->{value});	# do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value}); 	# no -0

  my ($sx, $sz) = ( $x->{sign}, $z->{sign} ); 		# get signs

  if ($sx eq $sz)  
    {
    $x->{value} = $CALC->_add($x->{value},$z->{value});	# same sign, abs add
    }
  else 
    {
    my $a = $CALC->_acmp ($z->{value},$x->{value});	# absolute compare
    if ($a > 0)                           
      {
      $x->{value} = $CALC->_sub($z->{value},$x->{value},1); # abs sub w/ swap
      $x->{sign} = $sz;
      } 
    elsif ($a == 0)
      {
      # speedup, if equal, set result to 0
      $x->{value} = $CALC->_zero();
      $x->{sign} = '+';
      }
    else # a < 0
      {
      $x->{value} = $CALC->_sub($x->{value}, $z->{value}); # abs sub
      }
    }
  $x->round(@r);
  }

sub _div_inf
  {
  # helper function that handles +-inf cases for bdiv()/bmod() to reuse code
  my ($self,$x,$y) = @_;

  # NaN if x == NaN or y == NaN or x==y==0
  return wantarray ? ($x->bnan(),$self->bnan()) : $x->bnan()
   if (($x->is_nan() || $y->is_nan())   ||
       ($x->is_zero() && $y->is_zero()));
 
  # +-inf / +-inf == NaN, remainder also NaN
  if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
    {
    return wantarray ? ($x->bnan(),$self->bnan()) : $x->bnan();
    }
  # x / +-inf => 0, remainder x (works even if x == 0)
  if ($y->{sign} =~ /^[+-]inf$/)
    {
    my $t = $x->copy();		# bzero clobbers up $x
    return wantarray ? ($x->bzero(),$t) : $x->bzero()
    }
  
  # 5 / 0 => +inf, -6 / 0 => -inf
  # +inf / 0 = inf, inf,  and -inf / 0 => -inf, -inf 
  # exception:   -8 / 0 has remainder -8, not 8
  # exception: -inf / 0 has remainder -inf, not inf
  if ($y->is_zero())
    {
    # +-inf / 0 => special case for -inf
    return wantarray ?  ($x,$x->copy()) : $x if $x->is_inf();
    if (!$x->is_zero() && !$x->is_inf())
      {
      my $t = $x->copy();		# binf clobbers up $x
      return wantarray ?
       ($x->binf($x->{sign}),$t) : $x->binf($x->{sign})
      }
    }
  
  # last case: +-inf / ordinary number
  my $sign = '+inf';
  $sign = '-inf' if substr($x->{sign},0,1) ne $y->{sign};
  $x->{sign} = $sign;
  return wantarray ? ($x,$self->bzero()) : $x;
  }

sub bdiv 
  {
  # (dividend: BINT or num_str, divisor: BINT or num_str) return 
  # (BINT,BINT) (quo,rem) or BINT (only rem)
  
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    } 

  return $x if $x->modify('bdiv');

  return $self->_div_inf($x,$y)
   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());

  return $upgrade->bdiv($upgrade->new($x),$upgrade->new($y),@r)
   if defined $upgrade;
   
  $r[3] = $y;					# no push!

  # calc new sign and in case $y == +/- 1, return $x
  my $xsign = $x->{sign};				# keep
  $x->{sign} = ($x->{sign} ne $y->{sign} ? '-' : '+'); 

  if (wantarray)
    {
    my $rem = $self->bzero(); 
    ($x->{value},$rem->{value}) = $CALC->_div($x->{value},$y->{value});
    $x->{sign} = '+' if $CALC->_is_zero($x->{value});
    $rem->{_a} = $x->{_a};
    $rem->{_p} = $x->{_p};
    $x->round(@r);
    if (! $CALC->_is_zero($rem->{value}))
      {
      $rem->{sign} = $y->{sign};
      $rem = $y->copy()->bsub($rem) if $xsign ne $y->{sign}; # one of them '-'
      }
    else
      {
      $rem->{sign} = '+';			# do not leave -0
      }
    $rem->round(@r);
    return ($x,$rem);
    }

  $x->{value} = $CALC->_div($x->{value},$y->{value});
  $x->{sign} = '+' if $CALC->_is_zero($x->{value});

  $x->round(@r);
  }

###############################################################################
# modulus functions

sub bmod 
  {
  # modulus (or remainder)
  # (BINT or num_str, BINT or num_str) return BINT
  
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bmod');
  $r[3] = $y;					# no push!
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero())
    {
    my ($d,$r) = $self->_div_inf($x,$y);
    $x->{sign} = $r->{sign};
    $x->{value} = $r->{value};
    return $x->round(@r);
    }

  # calc new sign and in case $y == +/- 1, return $x
  $x->{value} = $CALC->_mod($x->{value},$y->{value});
  if (!$CALC->_is_zero($x->{value}))
    {
    $x->{value} = $CALC->_sub($y->{value},$x->{value},1) 	# $y-$x
      if ($x->{sign} ne $y->{sign});
    $x->{sign} = $y->{sign};
    }
   else
    {
    $x->{sign} = '+';				# do not leave -0
    }
  $x->round(@r);
  }

sub bmodinv
  {
  # Return modular multiplicative inverse: z is the modular inverse of x (mod
  # y) if and only if x*z (mod y) = 1 (mod y). If the modulus y is larger than
  # one, x and z are relative primes (i.e., their greatest common divisor is
  # one).
  #
  # If no modular multiplicative inverse exists, NaN is returned.

  # set up parameters
  my ($self,$x,$y,@r) = (undef,@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bmodinv');

  # Return NaN if one or both arguments is +inf, -inf, or nan.

  return $x->bnan() if ($y->{sign} !~ /^[+-]$/ ||
                        $x->{sign} !~ /^[+-]$/);

  # Return NaN if $y is zero; 1 % 0 makes no sense.

  return $x->bnan() if $y->is_zero();

  # Return 0 in the trivial case. $x % 1 or $x % -1 is zero for all finite
  # integers $x.

  return $x->bzero() if ($y->is_one() ||
                         $y->is_one('-'));

  # Return NaN if $x = 0, or $x modulo $y is zero. The only valid case when
  # $x = 0 is when $y = 1 or $y = -1, but that was covered above.
  #
  # Note that computing $x modulo $y here affects the value we'll feed to
  # $CALC->_modinv() below when $x and $y have opposite signs. E.g., if $x =
  # 5 and $y = 7, those two values are fed to _modinv(), but if $x = -5 and
  # $y = 7, the values fed to _modinv() are $x = 2 (= -5 % 7) and $y = 7.
  # The value if $x is affected only when $x and $y have opposite signs.

  $x->bmod($y);
  return $x->bnan() if $x->is_zero();

  # Compute the modular multiplicative inverse of the absolute values. We'll
  # correct for the signs of $x and $y later. Return NaN if no GCD is found.

  ($x->{value}, $x->{sign}) = $CALC->_modinv($x->{value}, $y->{value});
  return $x->bnan() if !defined $x->{value};

  # Library inconsistency workaround: _modinv() in Math::BigInt::GMP versions
  # <= 1.32 return undef rather than a "+" for the sign.

  $x->{sign} = '+' unless defined $x->{sign};

  # When one or both arguments are negative, we have the following
  # relations.  If x and y are positive:
  #
  #   modinv(-x, -y) = -modinv(x, y)
  #   modinv(-x,  y) = y - modinv(x, y)  = -modinv(x, y) (mod y)
  #   modinv( x, -y) = modinv(x, y) - y  =  modinv(x, y) (mod -y)

  # We must swap the sign of the result if the original $x is negative.
  # However, we must compensate for ignoring the signs when computing the
  # inverse modulo. The net effect is that we must swap the sign of the
  # result if $y is negative.

  $x -> bneg() if $y->{sign} eq '-';

  # Compute $x modulo $y again after correcting the sign.

  $x -> bmod($y) if $x->{sign} ne $y->{sign};

  return $x;
  }

sub bmodpow
  {
  # Modular exponentiation. Raises a very large number to a very large exponent
  # in a given very large modulus quickly, thanks to binary exponentiation.
  # Supports negative exponents.
  my ($self,$num,$exp,$mod,@r) = objectify(3,@_);

  return $num if $num->modify('bmodpow');

  # When the exponent 'e' is negative, use the following relation, which is
  # based on finding the multiplicative inverse 'd' of 'b' modulo 'm':
  #
  #    b^(-e) (mod m) = d^e (mod m) where b*d = 1 (mod m)

  $num->bmodinv($mod) if ($exp->{sign} eq '-');

  # Check for valid input. All operands must be finite, and the modulus must be
  # non-zero.

  return $num->bnan() if ($num->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf
                          $exp->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf
                          $mod->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf
                          $mod->is_zero());

  # Compute 'a (mod m)', ignoring the signs on 'a' and 'm'. If the resulting
  # value is zero, the output is also zero, regardless of the signs on 'a' and
  # 'm'.

  my $value = $CALC->_modpow($num->{value}, $exp->{value}, $mod->{value});
  my $sign  = '+';

  # If the resulting value is non-zero, we have four special cases, depending
  # on the signs on 'a' and 'm'.

  unless ($CALC->_is_zero($value)) {

      # There is a negative sign on 'a' (= $num**$exp) only if the number we
      # are exponentiating ($num) is negative and the exponent ($exp) is odd.

      if ($num->{sign} eq '-' && $exp->is_odd()) {

          # When both the number 'a' and the modulus 'm' have a negative sign,
          # use this relation:
          #
          #    -a (mod -m) = -(a (mod m))

          if ($mod->{sign} eq '-') {
              $sign = '-';
          }

          # When only the number 'a' has a negative sign, use this relation:
          #
          #    -a (mod m) = m - (a (mod m))

          else {
              # Use copy of $mod since _sub() modifies the first argument.
              my $mod = $CALC->_copy($mod->{value});
              $value = $CALC->_sub($mod, $value);
              $sign  = '+';
          }

      } else {

          # When only the modulus 'm' has a negative sign, use this relation:
          #
          #    a (mod -m) = (a (mod m)) - m
          #               = -(m - (a (mod m)))

          if ($mod->{sign} eq '-') {
              # Use copy of $mod since _sub() modifies the first argument.
              my $mod = $CALC->_copy($mod->{value});
              $value = $CALC->_sub($mod, $value);
              $sign  = '-';
          }

          # When neither the number 'a' nor the modulus 'm' have a negative
          # sign, directly return the already computed value.
          #
          #    (a (mod m))

      }

  }

  $num->{value} = $value;
  $num->{sign}  = $sign;

  return $num;
  }

###############################################################################

sub bfac
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute factorial number from $x, modify $x in place
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('bfac') || $x->{sign} eq '+inf';	# inf => inf
  return $x->bnan() if $x->{sign} ne '+';			# NaN, <0 etc => NaN

  $x->{value} = $CALC->_fac($x->{value});
  $x->round(@r);
  }
 
sub bpow 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute power of two numbers -- stolen from Knuth Vol 2 pg 233
  # modifies first argument

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bpow');

  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +-inf ** +-inf
      return $x->bnan();
      }
    # +-inf ** Y
    if ($x->{sign} =~ /^[+-]inf/)
      {
      # +inf ** 0 => NaN
      return $x->bnan() if $y->is_zero();
      # -inf ** -1 => 1/inf => 0
      return $x->bzero() if $y->is_one('-') && $x->is_negative();

      # +inf ** Y => inf
      return $x if $x->{sign} eq '+inf';

      # -inf ** Y => -inf if Y is odd
      return $x if $y->is_odd();
      return $x->babs();
      }
    # X ** +-inf

    # 1 ** +inf => 1
    return $x if $x->is_one();
    
    # 0 ** inf => 0
    return $x if $x->is_zero() && $y->{sign} =~ /^[+]/;

    # 0 ** -inf => inf
    return $x->binf() if $x->is_zero();

    # -1 ** -inf => NaN
    return $x->bnan() if $x->is_one('-') && $y->{sign} =~ /^[-]/;

    # -X ** -inf => 0
    return $x->bzero() if $x->{sign} eq '-' && $y->{sign} =~ /^[-]/;

    # -1 ** inf => NaN
    return $x->bnan() if $x->{sign} eq '-';

    # X ** inf => inf
    return $x->binf() if $y->{sign} =~ /^[+]/;
    # X ** -inf => 0
    return $x->bzero();
    }

  return $upgrade->bpow($upgrade->new($x),$y,@r)
   if defined $upgrade && (!$y->isa($self) || $y->{sign} eq '-');

  $r[3] = $y;					# no push!

  # cases 0 ** Y, X ** 0, X ** 1, 1 ** Y are handled by Calc or Emu

  my $new_sign = '+';
  $new_sign = $y->is_odd() ? '-' : '+' if ($x->{sign} ne '+'); 

  # 0 ** -7 => ( 1 / (0 ** 7)) => 1 / 0 => +inf 
  return $x->binf() 
    if $y->{sign} eq '-' && $x->{sign} eq '+' && $CALC->_is_zero($x->{value});
  # 1 ** -y => 1 / (1 ** |y|)
  # so do test for negative $y after above's clause
  return $x->bnan() if $y->{sign} eq '-' && !$CALC->_is_one($x->{value});

  $x->{value} = $CALC->_pow($x->{value},$y->{value});
  $x->{sign} = $new_sign;
  $x->{sign} = '+' if $CALC->_is_zero($y->{value});
  $x->round(@r);
  }

sub blsft 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute x << y, base n, y >= 0
 
  # set up parameters
  my ($self,$x,$y,$n,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,@r) = objectify(2,@_);
    }

  return $x if $x->modify('blsft');
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@r) if $y->is_zero();

  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';

  $x->{value} = $CALC->_lsft($x->{value},$y->{value},$n);
  $x->round(@r);
  }

sub brsft 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute x >> y, base n, y >= 0
  
  # set up parameters
  my ($self,$x,$y,$n,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,@r) = objectify(2,@_);
    }

  return $x if $x->modify('brsft');
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@r) if $y->is_zero();
  return $x->bzero(@r) if $x->is_zero();		# 0 => 0

  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';

   # this only works for negative numbers when shifting in base 2
  if (($x->{sign} eq '-') && ($n == 2))
    {
    return $x->round(@r) if $x->is_one('-');	# -1 => -1
    if (!$y->is_one())
      {
      # although this is O(N*N) in calc (as_bin!) it is O(N) in Pari et al
      # but perhaps there is a better emulation for two's complement shift...
      # if $y != 1, we must simulate it by doing:
      # convert to bin, flip all bits, shift, and be done
      $x->binc();			# -3 => -2
      my $bin = $x->as_bin();
      $bin =~ s/^-0b//;			# strip '-0b' prefix
      $bin =~ tr/10/01/;		# flip bits
      # now shift
      if ($y >= CORE::length($bin))
        {
	$bin = '0'; 			# shifting to far right creates -1
					# 0, because later increment makes 
					# that 1, attached '-' makes it '-1'
					# because -1 >> x == -1 !
        } 
      else
	{
	$bin =~ s/.{$y}$//;		# cut off at the right side
        $bin = '1' . $bin;		# extend left side by one dummy '1'
        $bin =~ tr/10/01/;		# flip bits back
	}
      my $res = $self->new('0b'.$bin);	# add prefix and convert back
      $res->binc();			# remember to increment
      $x->{value} = $res->{value};	# take over value
      return $x->round(@r);		# we are done now, magic, isn't?
      }
    # x < 0, n == 2, y == 1
    $x->bdec();				# n == 2, but $y == 1: this fixes it
    }

  $x->{value} = $CALC->_rsft($x->{value},$y->{value},$n);
  $x->round(@r);
  }

sub band 
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x & y
 
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }
  
  return $x if $x->modify('band');

  $r[3] = $y;				# no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;
  
  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_and($x->{value},$y->{value});
    return $x->round(@r);
    }
  
  if ($CAN{signed_and})
    {
    $x->{value} = $CALC->_signed_and($x->{value},$y->{value},$sx,$sy);
    return $x->round(@r);
    }
 
  require $EMU_LIB;
  __emu_band($self,$x,$y,$sx,$sy,@r);
  }

sub bior 
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x | y
  
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bior');
  $r[3] = $y;				# no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;

  # the sign of X follows the sign of X, e.g. sign of Y irrelevant for bior()
  
  # don't use lib for negative values
  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_or($x->{value},$y->{value});
    return $x->round(@r);
    }

  # if lib can do negative values, let it handle this
  if ($CAN{signed_or})
    {
    $x->{value} = $CALC->_signed_or($x->{value},$y->{value},$sx,$sy);
    return $x->round(@r);
    }

  require $EMU_LIB;
  __emu_bior($self,$x,$y,$sx,$sy,@r);
  }

sub bxor 
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x ^ y
  
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bxor');
  $r[3] = $y;				# no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  
  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;

  # don't use lib for negative values
  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_xor($x->{value},$y->{value});
    return $x->round(@r);
    }
  
  # if lib can do negative values, let it handle this
  if ($CAN{signed_xor})
    {
    $x->{value} = $CALC->_signed_xor($x->{value},$y->{value},$sx,$sy);
    return $x->round(@r);
    }

  require $EMU_LIB;
  __emu_bxor($self,$x,$y,$sx,$sy,@r);
  }

sub length
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  my $e = $CALC->_len($x->{value}); 
  wantarray ? ($e,0) : $e;
  }

sub digit
  {
  # return the nth decimal digit, negative values count backward, 0 is right
  my ($self,$x,$n) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  $n = $n->numify() if ref($n);
  $CALC->_digit($x->{value},$n||0);
  }

sub _trailing_zeros
  {
  # return the amount of trailing zeros in $x (as scalar)
  my $x = shift;
  $x = $class->new($x) unless ref $x;

  return 0 if $x->{sign} !~ /^[+-]$/;	# NaN, inf, -inf etc

  $CALC->_zeros($x->{value});		# must handle odd values, 0 etc
  }

sub bsqrt
  {
  # calculate square root of $x
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('bsqrt');

  return $x->bnan() if $x->{sign} !~ /^\+/;	# -x or -inf or NaN => NaN
  return $x if $x->{sign} eq '+inf';		# sqrt(+inf) == inf

  return $upgrade->bsqrt($x,@r) if defined $upgrade;

  $x->{value} = $CALC->_sqrt($x->{value});
  $x->round(@r);
  }

sub broot
  {
  # calculate $y'th root of $x
 
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  $y = $self->new(2) unless defined $y;

  # objectify is costly, so avoid it
  if ((!ref($x)) || (ref($x) ne ref($y)))
    {
    ($self,$x,$y,@r) = objectify(2,$self || $class,@_);
    }

  return $x if $x->modify('broot');

  # NaN handling: $x ** 1/0, x or y NaN, or y inf/-inf or y == 0
  return $x->bnan() if $x->{sign} !~ /^\+/ || $y->is_zero() ||
         $y->{sign} !~ /^\+$/;

  return $x->round(@r)
    if $x->is_zero() || $x->is_one() || $x->is_inf() || $y->is_one();

  return $upgrade->new($x)->broot($upgrade->new($y),@r) if defined $upgrade;

  $x->{value} = $CALC->_root($x->{value},$y->{value});
  $x->round(@r);
  }

sub exponent
  {
  # return a copy of the exponent (here always 0, NaN or 1 for $m == 0)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);
 
  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+-]//;  # NaN, -inf,+inf => NaN or inf
    return $self->new($s);
    }
  return $self->bone() if $x->is_zero();

  # 12300 => 2 trailing zeros => exponent is 2
  $self->new( $CALC->_zeros($x->{value}) );
  }

sub mantissa
  {
  # return the mantissa (compatible to Math::BigFloat, e.g. reduced)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    # for NaN, +inf, -inf: keep the sign
    return $self->new($x->{sign});
    }
  my $m = $x->copy(); delete $m->{_p}; delete $m->{_a};

  # that's a bit inefficient:
  my $zeros = $CALC->_zeros($m->{value});
  $m->brsft($zeros,10) if $zeros != 0;
  $m;
  }

sub parts
  {
  # return a copy of both the exponent and the mantissa
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  ($x->mantissa(),$x->exponent());
  }
   
##############################################################################
# rounding functions

sub bfround
  {
  # precision: round to the $Nth digit left (+$n) or right (-$n) from the '.'
  # $n == 0 || $n == 1 => round to integer
  my $x = shift; my $self = ref($x) || $x; $x = $self->new($x) unless ref $x;

  my ($scale,$mode) = $x->_scale_p(@_);

  return $x if !defined $scale || $x->modify('bfround');	# no-op

  # no-op for BigInts if $n <= 0
  $x->bround( $x->length()-$scale, $mode) if $scale > 0;

  delete $x->{_a};	# delete to save memory
  $x->{_p} = $scale;	# store new _p
  $x;
  }

sub _scan_for_nonzero
  {
  # internal, used by bround() to scan for non-zeros after a '5'
  my ($x,$pad,$xs,$len) = @_;
 
  return 0 if $len == 1;		# "5" is trailed by invisible zeros
  my $follow = $pad - 1;
  return 0 if $follow > $len || $follow < 1;

  # use the string form to check whether only '0's follow or not
  substr ($xs,-$follow) =~ /[^0]/ ? 1 : 0;
  }

sub fround
  {
  # Exists to make life easier for switch between MBF and MBI (should we
  # autoload fxxx() like MBF does for bxxx()?)
  my $x = shift; $x = $class->new($x) unless ref $x;
  $x->bround(@_);
  }

sub bround
  {
  # accuracy: +$n preserve $n digits from left,
  #           -$n preserve $n digits from right (f.i. for 0.1234 style in MBF)
  # no-op for $n == 0
  # and overwrite the rest with 0's, return normalized number
  # do not return $x->bnorm(), but $x

  my $x = shift; $x = $class->new($x) unless ref $x;
  my ($scale,$mode) = $x->_scale_a(@_);
  return $x if !defined $scale || $x->modify('bround');	# no-op
  
  if ($x->is_zero() || $scale == 0)
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2
    return $x;
    }
  return $x if $x->{sign} !~ /^[+-]$/;		# inf, NaN

  # we have fewer digits than we want to scale to
  my $len = $x->length();
  # convert $scale to a scalar in case it is an object (put's a limit on the
  # number length, but this would already limited by memory constraints), makes
  # it faster
  $scale = $scale->numify() if ref ($scale);

  # scale < 0, but > -len (not >=!)
  if (($scale < 0 && $scale < -$len-1) || ($scale >= $len))
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2
    return $x; 
    }
   
  # count of 0's to pad, from left (+) or right (-): 9 - +6 => 3, or |-6| => 6
  my ($pad,$digit_round,$digit_after);
  $pad = $len - $scale;
  $pad = abs($scale-1) if $scale < 0;

  # do not use digit(), it is very costly for binary => decimal
  # getting the entire string is also costly, but we need to do it only once
  my $xs = $CALC->_str($x->{value});
  my $pl = -$pad-1;

  # pad:   123: 0 => -1, at 1 => -2, at 2 => -3, at 3 => -4
  # pad+1: 123: 0 => 0,  at 1 => -1, at 2 => -2, at 3 => -3
  $digit_round = '0'; $digit_round = substr($xs,$pl,1) if $pad <= $len;
  $pl++; $pl ++ if $pad >= $len;
  $digit_after = '0'; $digit_after = substr($xs,$pl,1) if $pad > 0;

  # in case of 01234 we round down, for 6789 up, and only in case 5 we look
  # closer at the remaining digits of the original $x, remember decision
  my $round_up = 1;					# default round up
  $round_up -- if
    ($mode eq 'trunc')				||	# trunc by round down
    ($digit_after =~ /[01234]/)			|| 	# round down anyway,
							# 6789 => round up
    ($digit_after eq '5')			&&	# not 5000...0000
    ($x->_scan_for_nonzero($pad,$xs,$len) == 0)		&&
    (
     ($mode eq 'even') && ($digit_round =~ /[24680]/) ||
     ($mode eq 'odd')  && ($digit_round =~ /[13579]/) ||
     ($mode eq '+inf') && ($x->{sign} eq '-')   ||
     ($mode eq '-inf') && ($x->{sign} eq '+')   ||
     ($mode eq 'zero')		# round down if zero, sign adjusted below
    );
  my $put_back = 0;					# not yet modified
	
  if (($pad > 0) && ($pad <= $len))
    {
    substr($xs,-$pad,$pad) = '0' x $pad;		# replace with '00...'
    $put_back = 1;					# need to put back
    }
  elsif ($pad > $len)
    {
    $x->bzero();					# round to '0'
    }

  if ($round_up)					# what gave test above?
    {
    $put_back = 1;					# need to put back
    $pad = $len, $xs = '0' x $pad if $scale < 0;	# tlr: whack 0.51=>1.0	

    # we modify directly the string variant instead of creating a number and
    # adding it, since that is faster (we already have the string)
    my $c = 0; $pad ++;				# for $pad == $len case
    while ($pad <= $len)
      {
      $c = substr($xs,-$pad,1) + 1; $c = '0' if $c eq '10';
      substr($xs,-$pad,1) = $c; $pad++;
      last if $c != 0;				# no overflow => early out
      }
    $xs = '1'.$xs if $c == 0;

    }
  $x->{value} = $CALC->_new($xs) if $put_back == 1;	# put back, if needed

  $x->{_a} = $scale if $scale >= 0;
  if ($scale < 0)
    {
    $x->{_a} = $len+$scale;
    $x->{_a} = 0 if $scale < -$len;
    }
  $x;
  }

sub bfloor
  {
  # round towards minus infinity; no-op since it's already integer
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  $x->round(@r);
  }

sub bceil
  {
  # round towards plus infinity; no-op since it's already int
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  $x->round(@r);
  }

sub bint {
    # round towards zero; no-op since it's already integer
    my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

    $x->round(@r);
}

sub as_number
  {
  # An object might be asked to return itself as bigint on certain overloaded
  # operations. This does exactly this, so that sub classes can simple inherit
  # it or override with their own integer conversion routine.
  $_[0]->copy();
  }

sub as_hex
  {
  # return as hex string, with prefixed 0x
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $s = '';
  $s = $x->{sign} if $x->{sign} eq '-';
  $s . $CALC->_as_hex($x->{value});
  }

sub as_bin
  {
  # return as binary string, with prefixed 0b
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';
  return $s . $CALC->_as_bin($x->{value});
  }

sub as_oct
  {
  # return as octal string, with prefixed 0
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';
  return $s . $CALC->_as_oct($x->{value});
  }

##############################################################################
# private stuff (internal use only)

sub objectify {
    # Convert strings and "foreign objects" to the objects we want.

    # The first argument, $count, is the number of following arguments that
    # objectify() looks at and converts to objects. The first is a classname.
    # If the given count is 0, all arguments will be used.

    # After the count is read, objectify obtains the name of the class to which
    # the following arguments are converted. If the second argument is a
    # reference, use the reference type as the class name. Otherwise, if it is
    # a string that looks like a class name, use that. Otherwise, use $class.

    # Caller:                        Gives us:
    #
    # $x->badd(1);                => ref x, scalar y
    # Class->badd(1,2);           => classname x (scalar), scalar x, scalar y
    # Class->badd(Class->(1),2);  => classname x (scalar), ref x, scalar y
    # Math::BigInt::badd(1,2);    => scalar x, scalar y

    # A shortcut for the common case $x->unary_op():

    return (ref($_[1]), $_[1]) if (@_ == 2) && ($_[0]||0 == 1) && ref($_[1]);

    # Check the context.

    unless (wantarray) {
        require Carp;
        Carp::croak ("${class}::objectify() needs list context");
    }

    # Get the number of arguments to objectify.

    my $count = shift;
    $count ||= @_;

    # Initialize the output array.

    my @a = @_;

    # If the first argument is a reference, use that reference type as our
    # class name. Otherwise, if the first argument looks like a class name,
    # then use that as our class name. Otherwise, use the default class name.

    {
        if (ref($a[0])) {               # reference?
            unshift @a, ref($a[0]);
            last;
        }
        if ($a[0] =~ /^[A-Z].*::/) {    # string with class name?
            last;
        }
        unshift @a, $class;             # default class name
    }

    no strict 'refs';

    # What we upgrade to, if anything.

    my $up = ${"$a[0]::upgrade"};

    # Disable downgrading, because Math::BigFloat -> foo('1.0','2.0') needs
    # floats.

    my $down;
    if (defined ${"$a[0]::downgrade"}) {
        $down = ${"$a[0]::downgrade"};
        ${"$a[0]::downgrade"} = undef;
    }

    for my $i (1 .. $count) {
        my $ref = ref $a[$i];

        # If it is an object of the right class, all is fine.

        if ($ref eq $a[0]) {
            next;
        }

        # Don't do anything with undefs.

        unless (defined($a[$i])) {
            next;
        }

        # Perl scalars are fed to the appropriate constructor.

        unless ($ref) {
            $a[$i] = $a[0] -> new($a[$i]);
            next;
        }

        # Upgrading is OK, so skip further tests if the argument is upgraded.

        if (defined $up && $ref eq $up) {
            next;
        }

        # If we want a Math::BigInt, see if the object can become one.
        # Support the old misnomer as_number().

        if ($a[0] eq 'Math::BigInt') {
            if ($a[$i] -> can('as_int')) {
                $a[$i] = $a[$i] -> as_int();
                next;
            }
            if ($a[$i] -> can('as_number')) {
                $a[$i] = $a[$i] -> as_number();
                next;
            }
        }

        # If we want a Math::BigFloat, see if the object can become one.

        if ($a[0] eq 'Math::BigFloat') {
            if ($a[$i] -> can('as_float')) {
                $a[$i] = $a[$i] -> as_float();
                next;
            }
        }

        # Last resort.

        $a[$i] = $a[0] -> new($a[$i]);
    }

    # Reset the downgrading.

    ${"$a[0]::downgrade"} = $down;

    return @a;
}

sub _register_callback
  {
  my ($class,$callback) = @_;

  if (ref($callback) ne 'CODE')
    { 
    require Carp;
    Carp::croak ("$callback is not a coderef");
    }
  $CALLBACKS{$class} = $callback;
  }

sub import 
  {
  my $self = shift;

  $IMPORT++;				# remember we did import()
  my @a; my $l = scalar @_;
  my $warn_or_die = 0;			# 0 - no warn, 1 - warn, 2 - die
  for ( my $i = 0; $i < $l ; $i++ )
    {
    if ($_[$i] eq ':constant')
      {
      # this causes overlord er load to step in
      overload::constant 
	integer => sub { $self->new(shift) },
      	binary => sub { $self->new(shift) };
      }
    elsif ($_[$i] eq 'upgrade')
      {
      # this causes upgrading
      $upgrade = $_[$i+1];		# or undef to disable
      $i++;
      }
    elsif ($_[$i] =~ /^(lib|try|only)\z/)
      {
      # this causes a different low lib to take care...
      $CALC = $_[$i+1] || '';
      # lib => 1 (warn on fallback), try => 0 (no warn), only => 2 (die on fallback)
      $warn_or_die = 1 if $_[$i] eq 'lib';
      $warn_or_die = 2 if $_[$i] eq 'only';
      $i++;
      }
    else
      {
      push @a, $_[$i];
      }
    }
  # any non :constant stuff is handled by our parent, Exporter
  if (@a > 0)
    {
    require Exporter;
 
    $self->SUPER::import(@a);			# need it for subclasses
    $self->export_to_level(1,$self,@a);		# need it for MBF
    }

  # try to load core math lib
  my @c = split /\s*,\s*/,$CALC;
  foreach (@c)
    {
    $_ =~ tr/a-zA-Z0-9://cd;			# limit to sane characters
    }
  push @c, \'Calc'				# if all fail, try these
    if $warn_or_die < 2;			# but not for "only"
  $CALC = '';					# signal error
  foreach my $l (@c)
    {
    # fallback libraries are "marked" as \'string', extract string if nec.
    my $lib = $l; $lib = $$l if ref($l);

    next if ($lib || '') eq '';
    $lib = 'Math::BigInt::'.$lib if $lib !~ /^Math::BigInt/i;
    $lib =~ s/\.pm$//;
    if ($] < 5.006)
      {
      # Perl < 5.6.0 dies with "out of memory!" when eval("") and ':constant' is
      # used in the same script, or eval("") inside import().
      my @parts = split /::/, $lib;             # Math::BigInt => Math BigInt
      my $file = pop @parts; $file .= '.pm';    # BigInt => BigInt.pm
      require File::Spec;
      $file = File::Spec->catfile (@parts, $file);
      eval { require "$file"; $lib->import( @c ); }
      }
    else
      {
      eval "use $lib qw/@c/;";
      }
    if ($@ eq '')
      {
      my $ok = 1;
      # loaded it ok, see if the api_version() is high enough
      if ($lib->can('api_version') && $lib->api_version() >= 1.0)
	{
	$ok = 0;
	# api_version matches, check if it really provides anything we need
        for my $method (qw/
		one two ten
		str num
		add mul div sub dec inc
		acmp len digit is_one is_zero is_even is_odd
		is_two is_ten
		zeros new copy check
		from_hex from_oct from_bin as_hex as_bin as_oct
		rsft lsft xor and or
		mod sqrt root fac pow modinv modpow log_int gcd
	 /)
          {
	  if (!$lib->can("_$method"))
	    {
	    if (($WARN{$lib}||0) < 2)
	      {
	      require Carp;
	      Carp::carp ("$lib is missing method '_$method'");
	      $WARN{$lib} = 1;		# still warn about the lib
	      }
            $ok++; last; 
	    }
          }
	}
      if ($ok == 0)
	{
	$CALC = $lib;
	if ($warn_or_die > 0 && ref($l))
	  {
	  require Carp;
	  my $msg = "Math::BigInt: couldn't load specified math lib(s), fallback to $lib";
          Carp::carp ($msg) if $warn_or_die == 1;
          Carp::croak ($msg) if $warn_or_die == 2;
	  }
        last;			# found a usable one, break
	}
      else
	{
	if (($WARN{$lib}||0) < 2)
	  {
	  my $ver = eval "\$$lib\::VERSION" || 'unknown';
	  require Carp;
	  Carp::carp ("Cannot load outdated $lib v$ver, please upgrade");
	  $WARN{$lib} = 2;		# never warn again
	  }
        }
      }
    }
  if ($CALC eq '')
    {
    require Carp;
    if ($warn_or_die == 2)
      {
      Carp::croak ("Couldn't load specified math lib(s) and fallback disallowed");
      }
    else
      {
      Carp::croak ("Couldn't load any math lib(s), not even fallback to Calc.pm");
      }
    }

  # notify callbacks
  foreach my $class (keys %CALLBACKS)
    {
    &{$CALLBACKS{$class}}($CALC);
    }

  # Fill $CAN with the results of $CALC->can(...) for emulating lower math lib
  # functions

  %CAN = ();
  for my $method (qw/ signed_and signed_or signed_xor /)
    {
    $CAN{$method} = $CALC->can("_$method") ? 1 : 0;
    }

  # import done
  }

sub from_hex {
    # Create a bigint from a hexadecimal string.

    my ($self, $str) = @_;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (0?x)?
                     (
                         [0-9a-fA-F]*
                         ( _ [0-9a-fA-F]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $3;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # Initialize output.

        my $x = Math::BigInt->bzero();

        # The library method requires a prefix.

        $x->{value} = $CALC->_from_hex('0x' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($x->{value})) {
            $x->{sign} = '-';
        }

        return $x;
    }

    # CORE::hex() parses as much as it can, and ignores any trailing garbage.
    # For backwards compatibility, we return NaN.

    return $self->bnan();
}

sub from_oct {
    # Create a bigint from an octal string.

    my ($self, $str) = @_;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (
                         [0-7]*
                         ( _ [0-7]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $2;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # Initialize output.

        my $x = Math::BigInt->bzero();

        # The library method requires a prefix.

        $x->{value} = $CALC->_from_oct('0' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($x->{value})) {
            $x->{sign} = '-';
        }

        return $x;
    }

    # CORE::oct() parses as much as it can, and ignores any trailing garbage.
    # For backwards compatibility, we return NaN.

    return $self->bnan();
}

sub from_bin {
    # Create a bigint from a binary string.

    my ($self, $str) = @_;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (0?b)?
                     (
                         [01]*
                         ( _ [01]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $3;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # Initialize output.

        my $x = Math::BigInt->bzero();

        # The library method requires a prefix.

        $x->{value} = $CALC->_from_bin('0b' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($x->{value})) {
            $x->{sign} = '-';
        }

        return $x;
    }

    # For consistency with from_hex() and from_oct(), we return NaN when the
    # input is invalid.

    return $self->bnan();
}

sub _split
  {
  # input: num_str; output: undef for invalid or
  # (\$mantissa_sign,\$mantissa_value,\$mantissa_fraction,\$exp_sign,\$exp_value)
  # Internal, take apart a string and return the pieces.
  # Strip leading/trailing whitespace, leading zeros, underscore and reject
  # invalid input.
  my $x = shift;

  # strip white space at front, also extraneous leading zeros
  $x =~ s/^\s*([-]?)0*([0-9])/$1$2/g;   # will not strip '  .2'
  $x =~ s/^\s+//;                       # but this will
  $x =~ s/\s+$//g;                      # strip white space at end

  # shortcut, if nothing to split, return early
  if ($x =~ /^[+-]?[0-9]+\z/)
    {
    $x =~ s/^([+-])0*([0-9])/$2/; my $sign = $1 || '+';
    return (\$sign, \$x, \'', \'', \0);
    }

  # invalid starting char?
  return if $x !~ /^[+-]?(\.?[0-9]|0b[0-1]|0x[0-9a-fA-F])/;

  return Math::BigInt->from_hex($x) if $x =~ /^[+-]?0x/;        # hex string
  return Math::BigInt->from_bin($x) if $x =~ /^[+-]?0b/;        # binary string

  # strip underscores between digits
  $x =~ s/([0-9])_([0-9])/$1$2/g;
  $x =~ s/([0-9])_([0-9])/$1$2/g;		# do twice for 1_2_3

  # some possible inputs: 
  # 2.1234 # 0.12        # 1 	      # 1E1 # 2.134E1 # 434E-10 # 1.02009E-2 
  # .2 	   # 1_2_3.4_5_6 # 1.4E1_2_3  # 1e3 # +.2     # 0e999	

  my ($m,$e,$last) = split /[Ee]/,$x;
  return if defined $last;		# last defined => 1e2E3 or others
  $e = '0' if !defined $e || $e eq "";

  # sign,value for exponent,mantint,mantfrac
  my ($es,$ev,$mis,$miv,$mfv);
  # valid exponent?
  if ($e =~ /^([+-]?)0*([0-9]+)$/)	# strip leading zeros
    {
    $es = $1; $ev = $2;
    # valid mantissa?
    return if $m eq '.' || $m eq '';
    my ($mi,$mf,$lastf) = split /\./,$m;
    return if defined $lastf;		# lastf defined => 1.2.3 or others
    $mi = '0' if !defined $mi;
    $mi .= '0' if $mi =~ /^[\-\+]?$/;
    $mf = '0' if !defined $mf || $mf eq '';
    if ($mi =~ /^([+-]?)0*([0-9]+)$/)		# strip leading zeros
      {
      $mis = $1||'+'; $miv = $2;
      return unless ($mf =~ /^([0-9]*?)0*$/);	# strip trailing zeros
      $mfv = $1;
      # handle the 0e999 case here
      $ev = 0 if $miv eq '0' && $mfv eq '';
      return (\$mis,\$miv,\$mfv,\$es,\$ev);
      }
    }
  return; # NaN, not a number
  }

##############################################################################
# internal calculation routines (others are in Math::BigInt::Calc etc)

sub __lcm 
  { 
  # (BINT or num_str, BINT or num_str) return BINT
  # does modify first argument
  # LCM
 
  my ($x,$ty) = @_;
  return $x->bnan() if ($x->{sign} eq $nan) || ($ty->{sign} eq $nan);
  my $method = ref($x) . '::bgcd';
  no strict 'refs';
  $x * $ty / &$method($x,$ty);
  }

###############################################################################
# trigonometric functions

sub bpi
  {
  # Calculate PI to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer, that is, always returns '3'.
  my ($self,$n) = @_;
  if (@_ == 1)
    {
    # called like Math::BigInt::bpi(10);
    $n = $self; $self = $class;
    }
  $self = ref($self) if ref($self);

  return $upgrade->new($n) if defined $upgrade;

  # hard-wired to "3"
  $self->new(3);
  }

sub bcos
  {
  # Calculate cosinus(x) to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('bcos');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN

  return $upgrade->new($x)->bcos(@r) if defined $upgrade;

  require Math::BigFloat;
  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->bcos(@r)->as_int();

  $x->bone() if $t->is_one();
  $x->bzero() if $t->is_zero();
  $x->round(@r);
  }

sub bsin
  {
  # Calculate sinus(x) to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('bsin');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN

  return $upgrade->new($x)->bsin(@r) if defined $upgrade;

  require Math::BigFloat;
  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->bsin(@r)->as_int();

  $x->bone() if $t->is_one();
  $x->bzero() if $t->is_zero();
  $x->round(@r);
  }

sub batan2
  { 
  # calculate arcus tangens of ($y/$x)
 
  # set up parameters
  my ($self,$y,$x,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$y,$x,@r) = objectify(2,@_);
    }

  return $y if $y->modify('batan2');

  return $y->bnan() if ($y->{sign} eq $nan) || ($x->{sign} eq $nan);

  # Y    X
  # != 0 -inf result is +- pi
  if ($x->is_inf() || $y->is_inf())
    {
    # upgrade to BigFloat etc.
    return $upgrade->new($y)->batan2($upgrade->new($x),@r) if defined $upgrade;
    if ($y->is_inf())
      {
      if ($x->{sign} eq '-inf')
        {
        # calculate 3 pi/4 => 2.3.. => 2
        $y->bone( substr($y->{sign},0,1) );
        $y->bmul($self->new(2));
        }
      elsif ($x->{sign} eq '+inf')
        {
        # calculate pi/4 => 0.7 => 0
        $y->bzero();
        }
      else
        {
        # calculate pi/2 => 1.5 => 1
        $y->bone( substr($y->{sign},0,1) );
        }
      }
    else
      {
      if ($x->{sign} eq '+inf')
        {
        # calculate pi/4 => 0.7 => 0
        $y->bzero();
        }
      else
        {
        # PI => 3.1415.. => 3
        $y->bone( substr($y->{sign},0,1) );
        $y->bmul($self->new(3));
        }
      }
    return $y;
    }

  return $upgrade->new($y)->batan2($upgrade->new($x),@r) if defined $upgrade;

  require Math::BigFloat;
  my $r = Math::BigFloat->new($y)->batan2(Math::BigFloat->new($x),@r)->as_int();

  $x->{value} = $r->{value};
  $x->{sign} = $r->{sign};

  $x;
  }

sub batan
  {
  # Calculate arcus tangens of x to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('batan');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN

  return $upgrade->new($x)->batan(@r) if defined $upgrade;

  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->batan(@r);

  $x->{value} = $CALC->_new( $x->as_int()->bstr() );
  $x->round(@r);
  }

###############################################################################
# this method returns 0 if the object can be modified, or 1 if not.
# We use a fast constant sub() here, to avoid costly calls. Subclasses
# may override it with special code (f.i. Math::BigInt::Constant does so)

sub modify () { 0; }

1;
__END__

=pod

=head1 NAME

Math::BigInt - Arbitrary size integer/float math package

=head1 SYNOPSIS

  use Math::BigInt;

  # or make it faster with huge numbers: install (optional)
  # Math::BigInt::GMP and always use (it will fall back to
  # pure Perl if the GMP library is not installed):
  # (See also the L<MATH LIBRARY> section!)

  # will warn if Math::BigInt::GMP cannot be found
  use Math::BigInt lib => 'GMP';

  # to suppress the warning use this:
  # use Math::BigInt try => 'GMP';

  # dies if GMP cannot be loaded:
  # use Math::BigInt only => 'GMP';

  my $str = '1234567890';
  my @values = (64,74,18);
  my $n = 1; my $sign = '-';

  # Number creation	
  my $x = Math::BigInt->new($str);	# defaults to 0
  my $y = $x->copy();			# make a true copy
  my $nan  = Math::BigInt->bnan(); 	# create a NotANumber
  my $zero = Math::BigInt->bzero();	# create a +0
  my $inf = Math::BigInt->binf();	# create a +inf
  my $inf = Math::BigInt->binf('-');	# create a -inf
  my $one = Math::BigInt->bone();	# create a +1
  my $mone = Math::BigInt->bone('-');	# create a -1

  my $pi = Math::BigInt->bpi();		# returns '3'
					# see Math::BigFloat::bpi()

  $h = Math::BigInt->new('0x123');	# from hexadecimal
  $b = Math::BigInt->new('0b101');	# from binary
  $o = Math::BigInt->from_oct('0101');	# from octal

  # Testing (don't modify their arguments)
  # (return true if the condition is met, otherwise false)

  $x->is_zero();	# if $x is +0
  $x->is_nan();		# if $x is NaN
  $x->is_one();		# if $x is +1
  $x->is_one('-');	# if $x is -1
  $x->is_odd();		# if $x is odd
  $x->is_even();	# if $x is even
  $x->is_pos();		# if $x > 0
  $x->is_neg();		# if $x < 0
  $x->is_inf($sign);	# if $x is +inf, or -inf (sign is default '+')
  $x->is_int();		# if $x is an integer (not a float)

  # comparing and digit/sign extraction
  $x->bcmp($y);		# compare numbers (undef,<0,=0,>0)
  $x->bacmp($y);	# compare absolutely (undef,<0,=0,>0)
  $x->sign();		# return the sign, either +,- or NaN
  $x->digit($n);	# return the nth digit, counting from right
  $x->digit(-$n);	# return the nth digit, counting from left

  # The following all modify their first argument. If you want to pre-
  # serve $x, use $z = $x->copy()->bXXX($y); See under L<CAVEATS> for
  # why this is necessary when mixing $a = $b assignments with non-over-
  # loaded math.

  $x->bzero();		# set $x to 0
  $x->bnan();		# set $x to NaN
  $x->bone();		# set $x to +1
  $x->bone('-');	# set $x to -1
  $x->binf();		# set $x to inf
  $x->binf('-');	# set $x to -inf

  $x->bneg();		# negation
  $x->babs();		# absolute value
  $x->bsgn();		# sign function (-1, 0, 1, or NaN)
  $x->bnorm();		# normalize (no-op in BigInt)
  $x->bnot();		# two's complement (bit wise not)
  $x->binc();		# increment $x by 1
  $x->bdec();		# decrement $x by 1

  $x->badd($y);		# addition (add $y to $x)
  $x->bsub($y);		# subtraction (subtract $y from $x)
  $x->bmul($y);		# multiplication (multiply $x by $y)
  $x->bdiv($y);		# divide, set $x to quotient
			# return (quo,rem) or quo if scalar

  $x->bmuladd($y,$z);	# $x = $x * $y + $z

  $x->bmod($y);		# modulus (x % y)
  $x->bmodpow($y,$mod); # modular exponentiation (($x ** $y) % $mod)
  $x->bmodinv($mod);    # modular multiplicative inverse
  $x->bpow($y);		# power of arguments (x ** y)
  $x->blsft($y);	# left shift in base 2
  $x->brsft($y);	# right shift in base 2
			# returns (quo,rem) or quo if in sca-
			# lar context
  $x->blsft($y,$n);	# left shift by $y places in base $n
  $x->brsft($y,$n);	# right shift by $y places in base $n
			# returns (quo,rem) or quo if in sca-
			# lar context

  $x->band($y);		# bitwise and
  $x->bior($y);		# bitwise inclusive or
  $x->bxor($y);		# bitwise exclusive or
  $x->bnot();		# bitwise not (two's complement)

  $x->bsqrt();		# calculate square-root
  $x->broot($y);	# $y'th root of $x (e.g. $y == 3 => cubic root)
  $x->bfac();		# factorial of $x (1*2*3*4*..$x)

  $x->bnok($y);		# x over y (binomial coefficient n over k)

  $x->blog();		# logarithm of $x to base e (Euler's number)
  $x->blog($base);	# logarithm of $x to base $base (f.i. 2)
  $x->bexp();		# calculate e ** $x where e is Euler's number

  $x->round($A,$P,$mode);  # round to accuracy or precision using
			   # mode $mode
  $x->bround($n);	   # accuracy: preserve $n digits
  $x->bfround($n);	   # $n > 0: round $nth digits,
			   # $n < 0: round to the $nth digit after the
			   # dot, no-op for BigInts

  # The following do not modify their arguments in BigInt (are no-ops),
  # but do so in BigFloat:

  $x->bfloor();            # round towards minus infinity
  $x->bceil();             # round towards plus infinity
  $x->bint();              # round towards zero

  # The following do not modify their arguments:

  # greatest common divisor (no OO style)
  my $gcd = Math::BigInt::bgcd(@values);
  # lowest common multiple (no OO style)
  my $lcm = Math::BigInt::blcm(@values);

  $x->length();		   # return number of digits in number
  ($xl,$f) = $x->length(); # length of number and length of fraction
			   # part, latter is always 0 digits long
			   # for BigInts

  $x->exponent();	  # return exponent as BigInt
  $x->mantissa();	  # return (signed) mantissa as BigInt
  $x->parts();		  # return (mantissa,exponent) as BigInt
  $x->copy();		  # make a true copy of $x (unlike $y = $x;)
  $x->as_int();		  # return as BigInt (in BigInt: same as copy())
  $x->numify();		  # return as scalar (might overflow!)

  # conversion to string (do not modify their argument)
  $x->bstr();	      # normalized string (e.g. '3')
  $x->bsstr();	      # norm. string in scientific notation (e.g. '3E0')
  $x->as_hex();	      # as signed hexadecimal string with prefixed 0x
  $x->as_bin();	      # as signed binary string with prefixed 0b
  $x->as_oct();	      # as signed octal string with prefixed 0


  # precision and accuracy (see section about rounding for more)
  $x->precision();	 # return P of $x (or global, if P of $x undef)
  $x->precision($n);	 # set P of $x to $n
  $x->accuracy();	 # return A of $x (or global, if A of $x undef)
  $x->accuracy($n);	 # set A $x to $n

  # Global methods
  Math::BigInt->precision();   # get/set global P for all BigInt objects
  Math::BigInt->accuracy();    # get/set global A for all BigInt objects
  Math::BigInt->round_mode();  # get/set global round mode, one of
			       # 'even', 'odd', '+inf', '-inf', 'zero',
			       # 'trunc' or 'common'
  Math::BigInt->config();      # return hash containing configuration

=head1 DESCRIPTION

All operators (including basic math operations) are overloaded if you
declare your big integers as

  $i = new Math::BigInt '123_456_789_123_456_789';

Operations with overloaded operators preserve the arguments which is
exactly what you expect.

=head2 Input

Input values to these routines may be any string, that looks like a number
and results in an integer, including hexadecimal and binary numbers.

Scalars holding numbers may also be passed, but note that non-integer numbers
may already have lost precision due to the conversion to float. Quote
your input if you want BigInt to see all the digits:

	$x = Math::BigInt->new(12345678890123456789);	# bad
	$x = Math::BigInt->new('12345678901234567890');	# good

You can include one underscore between any two digits.

This means integer values like 1.01E2 or even 1000E-2 are also accepted.
Non-integer values result in NaN.

Hexadecimal (prefixed with "0x") and binary numbers (prefixed with "0b")
are accepted, too. Please note that octal numbers are not recognized
by new(), so the following will print "123":

	perl -MMath::BigInt -le 'print Math::BigInt->new("0123")'

To convert an octal number, use from_oct();

	perl -MMath::BigInt -le 'print Math::BigInt->from_oct("0123")'

Currently, Math::BigInt::new() defaults to 0, while Math::BigInt::new('')
results in 'NaN'. This might change in the future, so use always the following
explicit forms to get a zero or NaN:

	$zero = Math::BigInt->bzero();
	$nan = Math::BigInt->bnan();

C<bnorm()> on a BigInt object is now effectively a no-op, since the numbers 
are always stored in normalized form. If passed a string, creates a BigInt 
object from the input.

=head2 Output

Output values are BigInt objects (normalized), except for the methods which
return a string (see L</SYNOPSIS>).

Some routines (C<is_odd()>, C<is_even()>, C<is_zero()>, C<is_one()>,
C<is_nan()>, etc.) return true or false, while others (C<bcmp()>, C<bacmp()>)
return either undef (if NaN is involved), <0, 0 or >0 and are suited for sort.

=head1 METHODS

Each of the methods below (except config(), accuracy() and precision())
accepts three additional parameters. These arguments C<$A>, C<$P> and C<$R>
are C<accuracy>, C<precision> and C<round_mode>. Please see the section about
L</ACCURACY and PRECISION> for more information.

=over

=item config()

    use Data::Dumper;

    print Dumper ( Math::BigInt->config() );
    print Math::BigInt->config()->{lib},"\n";

Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.

    key		  Description
		  Example
    ============================================================
    lib		  Name of the low-level math library
		  Math::BigInt::Calc
    lib_version   Version of low-level math library (see 'lib')
		  0.30
    class	  The class name of config() you just called
		  Math::BigInt
    upgrade	  To which class math operations might be
		  upgraded Math::BigFloat
    downgrade     To which class math operations might be
		  downgraded undef
    precision     Global precision
		  undef
    accuracy      Global accuracy
		  undef
    round_mode    Global round mode
		  even
    version	  version number of the class you used
		  1.61
    div_scale     Fallback accuracy for div
		  40
    trap_nan      If true, traps creation of NaN via croak()
		  1
    trap_inf      If true, traps creation of +inf/-inf via croak()
		  1

The following values can be set by passing C<config()> a reference to a hash:

	trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale

Example:

	$new_cfg = Math::BigInt->config(
	    { trap_inf => 1, precision => 5 }
	);

=item accuracy()

    $x->accuracy(5);	     # local for $x
    CLASS->accuracy(5);	     # global for all members of CLASS
    			     # Note: This also applies to new()!

    $A = $x->accuracy();     # read out accuracy that affects $x
    $A = CLASS->accuracy();  # read out global accuracy

Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to new()!

Warning! The accuracy I<sticks>, e.g. once you created a number under the
influence of C<< CLASS->accuracy($A) >>, all results from math operations with
that number will also be rounded.

In most cases, you should probably round the results explicitly using one of
L</round()>, L</bround()> or L</bfround()> or by passing the desired accuracy
to the math operation as additional parameter:

    my $x = Math::BigInt->new(30000);
    my $y = Math::BigInt->new(7);
    print scalar $x->copy()->bdiv($y, 2);		# print 4300
    print scalar $x->copy()->bdiv($y)->bround(2);	# print 4300

Please see the section about L</ACCURACY and PRECISION> for further details.

Value must be greater than zero. Pass an undef value to disable it:

    $x->accuracy(undef);
    Math::BigInt->accuracy(undef);

Returns the current accuracy. For C<< $x->accuracy() >> it will return either
the local accuracy, or if not defined, the global. This means the return value
represents the accuracy that will be in effect for $x:

    $y = Math::BigInt->new(1234567);	   # unrounded
    print Math::BigInt->accuracy(4),"\n";  # set 4, print 4
    $x = Math::BigInt->new(123456);	   # $x will be automatic-
					   # ally rounded!
    print "$x $y\n";			   # '123500 1234567'
    print $x->accuracy(),"\n";		   # will be 4
    print $y->accuracy(),"\n";		   # also 4, since
					   # global is 4
    print Math::BigInt->accuracy(5),"\n";  # set to 5, print 5
    print $x->accuracy(),"\n";		   # still 4
    print $y->accuracy(),"\n";		   # 5, since global is 5

Note: Works also for subclasses like Math::BigFloat. Each class has it's own
globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.

=item precision()

    $x->precision(-2);          # local for $x, round at the second
                                # digit right of the dot
    $x->precision(2);           # ditto, round at the second digit
                                # left of the dot

    CLASS->precision(5);        # Global for all members of CLASS
                                # This also applies to new()!
    CLASS->precision(-5);       # ditto

    $P = CLASS->precision();    # read out global precision
    $P = $x->precision();       # read out precision that affects $x

Note: You probably want to use L</accuracy()> instead. With L</accuracy()> you
set the number of digits each result should have, with L</precision()> you
set the place where to round!

C<precision()> sets or gets the global or local precision, aka at which digit
before or after the dot to round all results. A set global precision also
applies to all newly created numbers!

In Math::BigInt, passing a negative number precision has no effect since no
numbers have digits after the dot. In L<Math::BigFloat>, it will round all
results to P digits after the dot.

Please see the section about L</ACCURACY and PRECISION> for further details.

Pass an undef value to disable it:

    $x->precision(undef);
    Math::BigInt->precision(undef);

Returns the current precision. For C<< $x->precision() >> it will return either
the local precision of $x, or if not defined, the global. This means the return
value represents the prevision that will be in effect for $x:

    $y = Math::BigInt->new(1234567);	    # unrounded
    print Math::BigInt->precision(4),"\n";  # set 4, print 4
    $x = Math::BigInt->new(123456);  # will be automatically rounded
    print $x;				    # print "120000"!

Note: Works also for subclasses like L<Math::BigFloat>. Each class has its
own globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.

=item brsft()

    $x->brsft($y,$n);

Shifts $x right by $y in base $n. Default is base 2, used are usually 10 and
2, but others work, too.

Right shifting usually amounts to dividing $x by $n ** $y and truncating the
result:


    $x = Math::BigInt->new(10);
    $x->brsft(1);			# same as $x >> 1: 5
    $x = Math::BigInt->new(1234);
    $x->brsft(2,10);			# result 12

There is one exception, and that is base 2 with negative $x:


    $x = Math::BigInt->new(-5);
    print $x->brsft(1);

This will print -3, not -2 (as it would if you divide -5 by 2 and truncate the
result).

=item new()

    $x = Math::BigInt->new($str,$A,$P,$R);

Creates a new BigInt object from a scalar or another BigInt object. The
input is accepted as decimal, hex (with leading '0x') or binary (with leading
'0b').

See L</Input> for more info on accepted input formats.

=item from_oct()

    $x = Math::BigInt->from_oct("0775");      # input is octal

Interpret the input as an octal string and return the corresponding value. A
"0" (zero) prefix is optional. A single underscore character may be placed
right after the prefix, if present, or between any two digits. If the input is
invalid, a NaN is returned.

=item from_hex()

    $x = Math::BigInt->from_hex("0xcafe");    # input is hexadecimal

Interpret input as a hexadecimal string. A "0x" or "x" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.

=item from_bin()

    $x = Math::BigInt->from_bin("0b10011");   # input is binary

Interpret the input as a binary string. A "0b" or "b" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.

=item bnan()

    $x = Math::BigInt->bnan();

Creates a new BigInt object representing NaN (Not A Number).
If used on an object, it will set it to NaN:

    $x->bnan();

=item bzero()

    $x = Math::BigInt->bzero();

Creates a new BigInt object representing zero.
If used on an object, it will set it to zero:

    $x->bzero();

=item binf()

    $x = Math::BigInt->binf($sign);

Creates a new BigInt object representing infinity. The optional argument is
either '-' or '+', indicating whether you want infinity or minus infinity.
If used on an object, it will set it to infinity:

    $x->binf();
    $x->binf('-');

=item bone()

    $x = Math::BigInt->binf($sign);

Creates a new BigInt object representing one. The optional argument is
either '-' or '+', indicating whether you want one or minus one.
If used on an object, it will set it to one:

    $x->bone();		# +1
    $x->bone('-');		# -1

=item is_one()/is_zero()/is_nan()/is_inf()

    $x->is_zero();		# true if arg is +0
    $x->is_nan();		# true if arg is NaN
    $x->is_one();		# true if arg is +1
    $x->is_one('-');		# true if arg is -1
    $x->is_inf();		# true if +inf
    $x->is_inf('-');		# true if -inf (sign is default '+')

These methods all test the BigInt for being one specific value and return
true or false depending on the input. These are faster than doing something
like:

    if ($x == 0)

=item is_pos()/is_neg()/is_positive()/is_negative()

    $x->is_pos();			# true if > 0
    $x->is_neg();			# true if < 0

The methods return true if the argument is positive or negative, respectively.
C<NaN> is neither positive nor negative, while C<+inf> counts as positive, and
C<-inf> is negative. A C<zero> is neither positive nor negative.

These methods are only testing the sign, and not the value.

C<is_positive()> and C<is_negative()> are aliases to C<is_pos()> and
C<is_neg()>, respectively. C<is_positive()> and C<is_negative()> were
introduced in v1.36, while C<is_pos()> and C<is_neg()> were only introduced
in v1.68.

=item is_odd()/is_even()/is_int()

    $x->is_odd();		# true if odd, false for even
    $x->is_even();		# true if even, false for odd
    $x->is_int();		# true if $x is an integer

The return true when the argument satisfies the condition. C<NaN>, C<+inf>,
C<-inf> are not integers and are neither odd nor even.

In BigInt, all numbers except C<NaN>, C<+inf> and C<-inf> are integers.

=item bcmp()

    $x->bcmp($y);

Compares $x with $y and takes the sign into account.
Returns -1, 0, 1 or undef.

=item bacmp()

    $x->bacmp($y);

Compares $x with $y while ignoring their sign. Returns -1, 0, 1 or undef.

=item sign()

    $x->sign();

Return the sign, of $x, meaning either C<+>, C<->, C<-inf>, C<+inf> or NaN.

If you want $x to have a certain sign, use one of the following methods:

    $x->babs();			# '+'
    $x->babs()->bneg();		# '-'
    $x->bnan();			# 'NaN'
    $x->binf();			# '+inf'
    $x->binf('-');		# '-inf'

=item digit()

    $x->digit($n);	 # return the nth digit, counting from right

If C<$n> is negative, returns the digit counting from left.

=item bneg()

    $x->bneg();

Negate the number, e.g. change the sign between '+' and '-', or between '+inf'
and '-inf', respectively. Does nothing for NaN or zero.

=item babs()

    $x->babs();

Set the number to its absolute value, e.g. change the sign from '-' to '+'
and from '-inf' to '+inf', respectively. Does nothing for NaN or positive
numbers.

=item bsgn()

    $x->bsgn();

Signum function. Set the number to -1, 0, or 1, depending on whether the
number is negative, zero, or positive, respectively. Does not modify NaNs.

=item bnorm()

    $x->bnorm();			# normalize (no-op)

=item bnot()

    $x->bnot();

Two's complement (bitwise not). This is equivalent to

    $x->binc()->bneg();

but faster.

=item binc()

    $x->binc();			# increment x by 1

=item bdec()

    $x->bdec();			# decrement x by 1

=item badd()

    $x->badd($y);		# addition (add $y to $x)

=item bsub()

    $x->bsub($y);		# subtraction (subtract $y from $x)

=item bmul()

    $x->bmul($y);		# multiplication (multiply $x by $y)

=item bmuladd()

    $x->bmuladd($y,$z);

Multiply $x by $y, and then add $z to the result,

This method was added in v1.87 of Math::BigInt (June 2007).

=item bdiv()

    $x->bdiv($y);		# divide, set $x to quotient
				# return (quo,rem) or quo if scalar

=item bmod()

    $x->bmod($y);		# modulus (x % y)

=item bmodinv()

    $x->bmodinv($mod);		# modular multiplicative inverse

Returns the multiplicative inverse of C<$x> modulo C<$mod>. If

    $y = $x -> copy() -> bmodinv($mod)

then C<$y> is the number closest to zero, and with the same sign as C<$mod>,
satisfying

    ($x * $y) % $mod = 1 % $mod

If C<$x> and C<$y> are non-zero, they must be relative primes, i.e.,
C<bgcd($y, $mod)==1>. 'C<NaN>' is returned when no modular multiplicative
inverse exists.

=item bmodpow()

    $num->bmodpow($exp,$mod);		# modular exponentiation
					# ($num**$exp % $mod)

Returns the value of C<$num> taken to the power C<$exp> in the modulus
C<$mod> using binary exponentiation.  C<bmodpow> is far superior to
writing

    $num ** $exp % $mod

because it is much faster - it reduces internal variables into
the modulus whenever possible, so it operates on smaller numbers.

C<bmodpow> also supports negative exponents.

    bmodpow($num, -1, $mod)

is exactly equivalent to

    bmodinv($num, $mod)

=item bpow()

    $x->bpow($y);		      # power of arguments (x ** y)

=item blog()

    $x->blog($base, $accuracy);   # logarithm of x to the base $base

If C<$base> is not defined, Euler's number (e) is used:

    print $x->blog(undef, 100);       # log(x) to 100 digits

=item bexp()

    $x->bexp($accuracy);	      # calculate e ** X

Calculates the expression C<e ** $x> where C<e> is Euler's number.

This method was added in v1.82 of Math::BigInt (April 2007).

See also L</blog()>.

=item bnok()

    $x->bnok($y);	  # x over y (binomial coefficient n over k)

Calculates the binomial coefficient n over k, also called the "choose"
function. The result is equivalent to:

	( n )      n!
	| - |  = -------
	( k )    k!(n-k)!

This method was added in v1.84 of Math::BigInt (April 2007).

=item bpi()

    print Math::BigInt->bpi(100), "\n";		# 3

Returns PI truncated to an integer, with the argument being ignored. This means
under BigInt this always returns C<3>.

If upgrading is in effect, returns PI, rounded to N digits with the
current rounding mode:

    use Math::BigFloat;
    use Math::BigInt upgrade => Math::BigFloat;
    print Math::BigInt->bpi(3), "\n";		# 3.14
    print Math::BigInt->bpi(100), "\n";		# 3.1415....

This method was added in v1.87 of Math::BigInt (June 2007).

=item bcos()

    my $x = Math::BigInt->new(1);
    print $x->bcos(100), "\n";

Calculate the cosinus of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item bsin()

    my $x = Math::BigInt->new(1);
    print $x->bsin(100), "\n";

Calculate the sinus of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item batan2()

    my $x = Math::BigInt->new(1);
    my $y = Math::BigInt->new(1);
    print $y->batan2($x), "\n";

Calculate the arcus tangens of C<$y> divided by C<$x>, modifying $y in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item batan()

    my $x = Math::BigFloat->new(0.5);
    print $x->batan(100), "\n";

Calculate the arcus tangens of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item blsft()

    $x->blsft($y);		# left shift in base 2
    $x->blsft($y,$n);		# left shift, in base $n (like 10)

=item brsft()

    $x->brsft($y);		# right shift in base 2
    $x->brsft($y,$n);		# right shift, in base $n (like 10)

=item band()

    $x->band($y);		# bitwise and

=item bior()

    $x->bior($y);		# bitwise inclusive or

=item bxor()

    $x->bxor($y);		# bitwise exclusive or

=item bnot()

    $x->bnot();			# bitwise not (two's complement)

=item bsqrt()

    $x->bsqrt();		# calculate square-root

=item broot()

    $x->broot($N);

Calculates the N'th root of C<$x>.

=item bfac()

    $x->bfac();		        # factorial of $x (1*2*3*4*..$x)

=item round()

    $x->round($A,$P,$round_mode);

Round $x to accuracy C<$A> or precision C<$P> using the round mode
C<$round_mode>.

=item bround()

    $x->bround($N);               # accuracy: preserve $N digits

=item bfround()

    $x->bfround($N);

If N is > 0, rounds to the Nth digit from the left. If N < 0, rounds to
the Nth digit after the dot. Since BigInts are integers, the case N < 0
is a no-op for them.

Examples:

	Input		N		Result
	===================================================
	123456.123456	3		123500
	123456.123456	2		123450
	123456.123456	-2		123456.12
	123456.123456	-3		123456.123

=item bfloor()

    $x->bfloor();

Round $x towards minus infinity (i.e., set $x to the largest integer less than
or equal to $x). This is a no-op in BigInt, but changes $x in BigFloat, if $x
is not an integer.

=item bceil()

    $x->bceil();

Round $x towards plus infinity (i.e., set $x to the smallest integer greater
than or equal to $x). This is a no-op in BigInt, but changes $x in BigFloat, if
$x is not an integer.

=item bint()

    $x->bint();

Round $x towards zero. This is a no-op in BigInt, but changes $x in BigFloat,
if $x is not an integer.

=item bgcd()

    bgcd(@values);	     # greatest common divisor (no OO style)

=item blcm()

    blcm(@values);	     # lowest common multiple (no OO style)

=item length()

    $x->length();
    ($xl,$fl) = $x->length();

Returns the number of digits in the decimal representation of the number.
In list context, returns the length of the integer and fraction part. For
BigInt's, the length of the fraction part will always be 0.

=item exponent()

    $x->exponent();

Return the exponent of $x as BigInt.

=item mantissa()

    $x->mantissa();

Return the signed mantissa of $x as BigInt.

=item parts()

    $x->parts();	# return (mantissa,exponent) as BigInt

=item copy()

    $x->copy();		# make a true copy of $x (unlike $y = $x;)

=item as_int()/as_number()

    $x->as_int();

Returns $x as a BigInt (truncated towards zero). In BigInt this is the same as
C<copy()>.

C<as_number()> is an alias to this method. C<as_number> was introduced in
v1.22, while C<as_int()> was only introduced in v1.68.

=item bstr()

    $x->bstr();

Returns a normalized string representation of C<$x>.

=item bsstr()

    $x->bsstr();     # normalized string in scientific notation

=item as_hex()

    $x->as_hex();    # as signed hexadecimal string with prefixed 0x

=item as_bin()

    $x->as_bin();    # as signed binary string with prefixed 0b

=item as_oct()

    $x->as_oct();    # as signed octal string with prefixed 0

=item numify()

	print $x->numify();

This returns a normal Perl scalar from $x. It is used automatically
whenever a scalar is needed, for instance in array index operations.

This loses precision, to avoid this use L<as_int()|/"as_int()/as_number()"> instead.

=item modify()

    $x->modify('bpowd');

This method returns 0 if the object can be modified with the given
operation, or 1 if not.

This is used for instance by L<Math::BigInt::Constant>.

=item upgrade()/downgrade()

Set/get the class for downgrade/upgrade operations. Thuis is used
for instance by L<bignum>. The defaults are '', thus the following
operation will create a BigInt, not a BigFloat:

	my $i = Math::BigInt->new(123);
	my $f = Math::BigFloat->new('123.1');

	print $i + $f,"\n";			# print 246

=item div_scale()

Set/get the number of digits for the default precision in divide
operations.

=item round_mode()

Set/get the current round mode.

=back

=head1 ACCURACY and PRECISION

Since version v1.33, Math::BigInt and Math::BigFloat have full support for
accuracy and precision based rounding, both automatically after every
operation, as well as manually.

This section describes the accuracy/precision handling in Math::Big* as it
used to be and as it is now, complete with an explanation of all terms and
abbreviations.

Not yet implemented things (but with correct description) are marked with '!',
things that need to be answered are marked with '?'.

In the next paragraph follows a short description of terms used here (because
these may differ from terms used by others people or documentation).

During the rest of this document, the shortcuts A (for accuracy), P (for
precision), F (fallback) and R (rounding mode) will be used.

=head2 Precision P

A fixed number of digits before (positive) or after (negative)
the decimal point. For example, 123.45 has a precision of -2. 0 means an
integer like 123 (or 120). A precision of 2 means two digits to the left
of the decimal point are zero, so 123 with P = 1 becomes 120. Note that
numbers with zeros before the decimal point may have different precisions,
because 1200 can have p = 0, 1 or 2 (depending on what the initial value
was). It could also have p < 0, when the digits after the decimal point
are zero.

The string output (of floating point numbers) will be padded with zeros:

	Initial value   P       A	Result          String
	------------------------------------------------------------
	1234.01         -3      	1000            1000
	1234            -2      	1200            1200
	1234.5          -1      	1230            1230
	1234.001        1       	1234            1234.0
	1234.01         0       	1234            1234
	1234.01         2       	1234.01		1234.01
	1234.01         5       	1234.01		1234.01000

For BigInts, no padding occurs.

=head2 Accuracy A

Number of significant digits. Leading zeros are not counted. A
number may have an accuracy greater than the non-zero digits
when there are zeros in it or trailing zeros. For example, 123.456 has
A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.

The string output (of floating point numbers) will be padded with zeros:

	Initial value   P       A	Result          String
	------------------------------------------------------------
	1234.01			3	1230		1230
	1234.01			6	1234.01		1234.01
	1234.1			8	1234.1		1234.1000

For BigInts, no padding occurs.

=head2 Fallback F

When both A and P are undefined, this is used as a fallback accuracy when
dividing numbers.

=head2 Rounding mode R

When rounding a number, different 'styles' or 'kinds'
of rounding are possible. (Note that random rounding, as in
Math::Round, is not implemented.)

=over

=item 'trunc'

truncation invariably removes all digits following the
rounding place, replacing them with zeros. Thus, 987.65 rounded
to tens (P=1) becomes 980, and rounded to the fourth sigdig
becomes 987.6 (A=4). 123.456 rounded to the second place after the
decimal point (P=-2) becomes 123.46.

All other implemented styles of rounding attempt to round to the
"nearest digit." If the digit D immediately to the right of the
rounding place (skipping the decimal point) is greater than 5, the
number is incremented at the rounding place (possibly causing a
cascade of incrementation): e.g. when rounding to units, 0.9 rounds
to 1, and -19.9 rounds to -20. If D < 5, the number is similarly
truncated at the rounding place: e.g. when rounding to units, 0.4
rounds to 0, and -19.4 rounds to -19.

However the results of other styles of rounding differ if the
digit immediately to the right of the rounding place (skipping the
decimal point) is 5 and if there are no digits, or no digits other
than 0, after that 5. In such cases:

=item 'even'

rounds the digit at the rounding place to 0, 2, 4, 6, or 8
if it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.4, -0.55 becomes -0.6, but 0.4501 becomes 0.5.

=item 'odd'

rounds the digit at the rounding place to 1, 3, 5, 7, or 9 if
it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.5, -0.55 becomes -0.5, but 0.5501 becomes 0.6.

=item '+inf'

round to plus infinity, i.e. always round up. E.g., when
rounding to the first sigdig, 0.45 becomes 0.5, -0.55 becomes -0.5,
and 0.4501 also becomes 0.5.

=item '-inf'

round to minus infinity, i.e. always round down. E.g., when
rounding to the first sigdig, 0.45 becomes 0.4, -0.55 becomes -0.6,
but 0.4501 becomes 0.5.

=item 'zero'

round to zero, i.e. positive numbers down, negative ones up.
E.g., when rounding to the first sigdig, 0.45 becomes 0.4, -0.55
becomes -0.5, but 0.4501 becomes 0.5.

=item 'common'

round up if the digit immediately to the right of the rounding place
is 5 or greater, otherwise round down. E.g., 0.15 becomes 0.2 and
0.149 becomes 0.1.

=back

The handling of A & P in MBI/MBF (the old core code shipped with Perl
versions <= 5.7.2) is like this:

=over

=item Precision

  * ffround($p) is able to round to $p number of digits after the decimal
    point
  * otherwise P is unused

=item Accuracy (significant digits)

  * fround($a) rounds to $a significant digits
  * only fdiv() and fsqrt() take A as (optional) parameter
    + other operations simply create the same number (fneg etc), or
      more (fmul) of digits
    + rounding/truncating is only done when explicitly calling one
      of fround or ffround, and never for BigInt (not implemented)
  * fsqrt() simply hands its accuracy argument over to fdiv.
  * the documentation and the comment in the code indicate two
    different ways on how fdiv() determines the maximum number
    of digits it should calculate, and the actual code does yet
    another thing
    POD:
      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
    Comment:
      result has at most max(scale, length(dividend), length(divisor)) digits
    Actual code:
      scale = max(scale, length(dividend)-1,length(divisor)-1);
      scale += length(divisor) - length(dividend);
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16
    (10+9-3). Actually, the 'difference' added to the scale is cal-
    culated from the number of "significant digits" in dividend and
    divisor, which is derived by looking at the length of the man-
    tissa. Which is wrong, since it includes the + sign (oops) and
    actually gets 2 for '+100' and 4 for '+101'. Oops again. Thus
    124/3 with div_scale=1 will get you '41.3' based on the strange
    assumption that 124 has 3 significant digits, while 120/7 will
    get you '17', not '17.1' since 120 is thought to have 2 signif-
    icant digits. The rounding after the division then uses the
    remainder and $y to determine whether it must round up or down.
 ?  I have no idea which is the right way. That's why I used a slightly more
 ?  simple scheme and tweaked the few failing testcases to match it.

=back

This is how it works now:

=over

=item Setting/Accessing

  * You can set the A global via Math::BigInt->accuracy() or
    Math::BigFloat->accuracy() or whatever class you are using.
  * You can also set P globally by using Math::SomeClass->precision()
    likewise.
  * Globals are classwide, and not inherited by subclasses.
  * to undefine A, use Math::SomeCLass->accuracy(undef);
  * to undefine P, use Math::SomeClass->precision(undef);
  * Setting Math::SomeClass->accuracy() clears automatically
    Math::SomeClass->precision(), and vice versa.
  * To be valid, A must be > 0, P can have any value.
  * If P is negative, this means round to the P'th place to the right of the
    decimal point; positive values mean to the left of the decimal point.
    P of 0 means round to integer.
  * to find out the current global A, use Math::SomeClass->accuracy()
  * to find out the current global P, use Math::SomeClass->precision()
  * use $x->accuracy() respective $x->precision() for the local
    setting of $x.
  * Please note that $x->accuracy() respective $x->precision()
    return eventually defined global A or P, when $x's A or P is not
    set.

=item Creating numbers

  * When you create a number, you can give the desired A or P via:
    $x = Math::BigInt->new($number,$A,$P);
  * Only one of A or P can be defined, otherwise the result is NaN
  * If no A or P is give ($x = Math::BigInt->new($number) form), then the
    globals (if set) will be used. Thus changing the global defaults later on
    will not change the A or P of previously created numbers (i.e., A and P of
    $x will be what was in effect when $x was created)
  * If given undef for A and P, NO rounding will occur, and the globals will
    NOT be used. This is used by subclasses to create numbers without
    suffering rounding in the parent. Thus a subclass is able to have its own
    globals enforced upon creation of a number by using
    $x = Math::BigInt->new($number,undef,undef):

	use Math::BigInt::SomeSubclass;
	use Math::BigInt;

	Math::BigInt->accuracy(2);
	Math::BigInt::SomeSubClass->accuracy(3);
	$x = Math::BigInt::SomeSubClass->new(1234);

    $x is now 1230, and not 1200. A subclass might choose to implement
    this otherwise, e.g. falling back to the parent's A and P.

=item Usage

  * If A or P are enabled/defined, they are used to round the result of each
    operation according to the rules below
  * Negative P is ignored in Math::BigInt, since BigInts never have digits
    after the decimal point
  * Math::BigFloat uses Math::BigInt internally, but setting A or P inside
    Math::BigInt as globals does not tamper with the parts of a BigFloat.
    A flag is used to mark all Math::BigFloat numbers as 'never round'.

=item Precedence

  * It only makes sense that a number has only one of A or P at a time.
    If you set either A or P on one object, or globally, the other one will
    be automatically cleared.
  * If two objects are involved in an operation, and one of them has A in
    effect, and the other P, this results in an error (NaN).
  * A takes precedence over P (Hint: A comes before P).
    If neither of them is defined, nothing is used, i.e. the result will have
    as many digits as it can (with an exception for fdiv/fsqrt) and will not
    be rounded.
  * There is another setting for fdiv() (and thus for fsqrt()). If neither of
    A or P is defined, fdiv() will use a fallback (F) of $div_scale digits.
    If either the dividend's or the divisor's mantissa has more digits than
    the value of F, the higher value will be used instead of F.
    This is to limit the digits (A) of the result (just consider what would
    happen with unlimited A and P in the case of 1/3 :-)
  * fdiv will calculate (at least) 4 more digits than required (determined by
    A, P or F), and, if F is not used, round the result
    (this will still fail in the case of a result like 0.12345000000001 with A
    or P of 5, but this can not be helped - or can it?)
  * Thus you can have the math done by on Math::Big* class in two modi:
    + never round (this is the default):
      This is done by setting A and P to undef. No math operation
      will round the result, with fdiv() and fsqrt() as exceptions to guard
      against overflows. You must explicitly call bround(), bfround() or
      round() (the latter with parameters).
      Note: Once you have rounded a number, the settings will 'stick' on it
      and 'infect' all other numbers engaged in math operations with it, since
      local settings have the highest precedence. So, to get SaferRound[tm],
      use a copy() before rounding like this:

        $x = Math::BigFloat->new(12.34);
        $y = Math::BigFloat->new(98.76);
        $z = $x * $y;                           # 1218.6984
        print $x->copy()->fround(3);            # 12.3 (but A is now 3!)
        $z = $x * $y;                           # still 1218.6984, without
                                                # copy would have been 1210!

    + round after each op:
      After each single operation (except for testing like is_zero()), the
      method round() is called and the result is rounded appropriately. By
      setting proper values for A and P, you can have all-the-same-A or
      all-the-same-P modes. For example, Math::Currency might set A to undef,
      and P to -2, globally.

 ?Maybe an extra option that forbids local A & P settings would be in order,
 ?so that intermediate rounding does not 'poison' further math?

=item Overriding globals

  * you will be able to give A, P and R as an argument to all the calculation
    routines; the second parameter is A, the third one is P, and the fourth is
    R (shift right by one for binary operations like badd). P is used only if
    the first parameter (A) is undefined. These three parameters override the
    globals in the order detailed as follows, i.e. the first defined value
    wins:
    (local: per object, global: global default, parameter: argument to sub)
      + parameter A
      + parameter P
      + local A (if defined on both of the operands: smaller one is taken)
      + local P (if defined on both of the operands: bigger one is taken)
      + global A
      + global P
      + global F
  * fsqrt() will hand its arguments to fdiv(), as it used to, only now for two
    arguments (A and P) instead of one

=item Local settings

  * You can set A or P locally by using $x->accuracy() or
    $x->precision()
    and thus force different A and P for different objects/numbers.
  * Setting A or P this way immediately rounds $x to the new value.
  * $x->accuracy() clears $x->precision(), and vice versa.

=item Rounding

  * the rounding routines will use the respective global or local settings.
    fround()/bround() is for accuracy rounding, while ffround()/bfround()
    is for precision
  * the two rounding functions take as the second parameter one of the
    following rounding modes (R):
    'even', 'odd', '+inf', '-inf', 'zero', 'trunc', 'common'
  * you can set/get the global R by using Math::SomeClass->round_mode()
    or by setting $Math::SomeClass::round_mode
  * after each operation, $result->round() is called, and the result may
    eventually be rounded (that is, if A or P were set either locally,
    globally or as parameter to the operation)
  * to manually round a number, call $x->round($A,$P,$round_mode);
    this will round the number by using the appropriate rounding function
    and then normalize it.
  * rounding modifies the local settings of the number:

        $x = Math::BigFloat->new(123.456);
        $x->accuracy(5);
        $x->bround(4);

    Here 4 takes precedence over 5, so 123.5 is the result and $x->accuracy()
    will be 4 from now on.

=item Default values

  * R: 'even'
  * F: 40
  * A: undef
  * P: undef

=item Remarks

  * The defaults are set up so that the new code gives the same results as
    the old code (except in a few cases on fdiv):
    + Both A and P are undefined and thus will not be used for rounding
      after each operation.
    + round() is thus a no-op, unless given extra parameters A and P

=back

=head1 Infinity and Not a Number

While BigInt has extensive handling of inf and NaN, certain quirks remain.

=over

=item oct()/hex()

These perl routines currently (as of Perl v.5.8.6) cannot handle passed
inf.

	te@linux:~> perl -wle 'print 2 ** 3333'
	inf
	te@linux:~> perl -wle 'print 2 ** 3333 == 2 ** 3333'
	1
	te@linux:~> perl -wle 'print oct(2 ** 3333)'
	0
	te@linux:~> perl -wle 'print hex(2 ** 3333)'
	Illegal hexadecimal digit 'i' ignored at -e line 1.
	0

The same problems occur if you pass them Math::BigInt->binf() objects. Since
overloading these routines is not possible, this cannot be fixed from BigInt.

=item ==, !=, <, >, <=, >= with NaNs

BigInt's bcmp() routine currently returns undef to signal that a NaN was
involved in a comparison. However, the overload code turns that into
either 1 or '' and thus operations like C<< NaN != NaN >> might return
wrong values.

=item log(-inf)

C<< log(-inf) >> is highly weird. Since log(-x)=pi*i+log(x), then
log(-inf)=pi*i+inf. However, since the imaginary part is finite, the real
infinity "overshadows" it, so the number might as well just be infinity.
However, the result is a complex number, and since BigInt/BigFloat can only
have real numbers as results, the result is NaN.

=item exp(), cos(), sin(), atan2()

These all might have problems handling infinity right.

=back

=head1 INTERNALS

The actual numbers are stored as unsigned big integers (with separate sign).

You should neither care about nor depend on the internal representation; it
might change without notice. Use B<ONLY> method calls like C<< $x->sign(); >>
instead relying on the internal representation.

=head2 MATH LIBRARY

Math with the numbers is done (by default) by a module called
C<Math::BigInt::Calc>. This is equivalent to saying:

	use Math::BigInt try => 'Calc';

You can change this backend library by using:

	use Math::BigInt try => 'GMP';

B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:

	use Math::BigInt only => 'GMP,Pari';

The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:

	use Math::BigInt try => 'Foo,Math::BigInt::Bar';

The library that is loaded last will be used. Note that this can be
overwritten at any time by loading a different library, and numbers
constructed with different libraries cannot be used in math operations
together.

=head3 What library to use?

B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

L<Math::BigInt::GMP> and L<Math::BigInt::Pari> are in cases involving big
numbers much faster than Calc, however it is slower when dealing with very
small numbers (less than about 20 digits) and when converting very large
numbers to decimal (for instance for printing, rounding, calculating their
length in decimal etc).

So please select carefully what library you want to use.

Different low-level libraries use different formats to store the numbers.
However, you should B<NOT> depend on the number having a specific format
internally.

See the respective math library module documentation for further details.

=head2 SIGN

The sign is either '+', '-', 'NaN', '+inf' or '-inf'.

A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
'-inf' when dividing any negative number by 0.

=head2 mantissa(), exponent() and parts()

C<mantissa()> and C<exponent()> return the said parts of the BigInt such
that:

        $m = $x->mantissa();
        $e = $x->exponent();
        $y = $m * ( 10 ** $e );
        print "ok\n" if $x == $y;

C<< ($m,$e) = $x->parts() >> is just a shortcut that gives you both of them
in one go. Both the returned mantissa and exponent have a sign.

Currently, for BigInts C<$e> is always 0, except +inf and -inf, where it is
C<+inf>; and for NaN, where it is C<NaN>; and for C<$x == 0>, where it is C<1>
(to be compatible with Math::BigFloat's internal representation of a zero as
C<0E1>).

C<$m> is currently just a copy of the original number. The relation between
C<$e> and C<$m> will stay always the same, though their real values might
change.

=head1 EXAMPLES

  use Math::BigInt;

  sub bigint { Math::BigInt->new(shift); }

  $x = Math::BigInt->bstr("1234")      	# string "1234"
  $x = "$x";                         	# same as bstr()
  $x = Math::BigInt->bneg("1234");   	# BigInt "-1234"
  $x = Math::BigInt->babs("-12345"); 	# BigInt "12345"
  $x = Math::BigInt->bnorm("-0.00"); 	# BigInt "0"
  $x = bigint(1) + bigint(2);           # BigInt "3"
  $x = bigint(1) + "2";                 # ditto (auto-BigIntify of "2")
  $x = bigint(1);                       # BigInt "1"
  $x = $x + 5 / 2;                   	# BigInt "3"
  $x = $x ** 3;                      	# BigInt "27"
  $x *= 2;                           	# BigInt "54"
  $x = Math::BigInt->new(0);       	# BigInt "0"
  $x--;                              	# BigInt "-1"
  $x = Math::BigInt->badd(4,5)		# BigInt "9"
  print $x->bsstr();			# 9e+0

Examples for rounding:

  use Math::BigFloat;
  use Test;

  $x = Math::BigFloat->new(123.4567);
  $y = Math::BigFloat->new(123.456789);
  Math::BigFloat->accuracy(4);		# no more A than 4

  ok ($x->copy()->fround(),123.4);	# even rounding
  print $x->copy()->fround(),"\n";	# 123.4
  Math::BigFloat->round_mode('odd');	# round to odd
  print $x->copy()->fround(),"\n";	# 123.5
  Math::BigFloat->accuracy(5);		# no more A than 5
  Math::BigFloat->round_mode('odd');	# round to odd
  print $x->copy()->fround(),"\n";	# 123.46
  $y = $x->copy()->fround(4),"\n";	# A = 4: 123.4
  print "$y, ",$y->accuracy(),"\n";	# 123.4, 4

  Math::BigFloat->accuracy(undef);	# A not important now
  Math::BigFloat->precision(2); 	# P important
  print $x->copy()->bnorm(),"\n";	# 123.46
  print $x->copy()->fround(),"\n";	# 123.46

Examples for converting:

  my $x = Math::BigInt->new('0b1'.'01' x 123);
  print "bin: ",$x->as_bin()," hex:",$x->as_hex()," dec: ",$x,"\n";

=head1 Autocreating constants

After C<use Math::BigInt ':constant'> all the B<integer> decimal, hexadecimal
and binary constants in the given scope are converted to C<Math::BigInt>.
This conversion happens at compile time. 

In particular,

  perl -MMath::BigInt=:constant -e 'print 2**100,"\n"'

prints the integer value of C<2**100>. Note that without conversion of 
constants the expression 2**100 will be calculated as perl scalar.

Please note that strings and floating point constants are not affected,
so that

  	use Math::BigInt qw/:constant/;

	$x = 1234567890123456789012345678901234567890
		+ 123456789123456789;
	$y = '1234567890123456789012345678901234567890'
		+ '123456789123456789';

do not work. You need an explicit Math::BigInt->new() around one of the
operands. You should also quote large constants to protect loss of precision:

	use Math::BigInt;

	$x = Math::BigInt->new('1234567889123456789123456789123456789');

Without the quotes Perl would convert the large number to a floating point
constant at compile time and then hand the result to BigInt, which results in
an truncated result or a NaN.

This also applies to integers that look like floating point constants:

	use Math::BigInt ':constant';

	print ref(123e2),"\n";
	print ref(123.2e2),"\n";

will print nothing but newlines. Use either L<bignum> or L<Math::BigFloat>
to get this to work.

=head1 PERFORMANCE

Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x
must be made in the second case. For long numbers, the copy can eat up to 20%
of the work (in the case of addition/subtraction, less for
multiplication/division). If $y is very small compared to $x, the form
$x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes
more time then the actual addition.

With a technique called copy-on-write, the cost of copying with overload could
be minimized or even completely avoided. A test implementation of COW did show
performance gains for overloaded math, but introduced a performance loss due
to a constant overhead for all other operations. So Math::BigInt does currently
not COW.

The rewritten version of this module (vs. v0.01) is slower on certain
operations, like C<new()>, C<bstr()> and C<numify()>. The reason are that it
does now more work and handles much more cases. The time spent in these
operations is usually gained in the other math operations so that code on
the average should get (much) faster. If they don't, please contact the author.

Some operations may be slower for small numbers, but are significantly faster
for big numbers. Other operations are now constant (O(1), like C<bneg()>,
C<babs()> etc), instead of O(N) and thus nearly always take much less time.
These optimizations were done on purpose.

If you find the Calc module to slow, try to install any of the replacement
modules and see if they help you. 

=head2 Alternative math libraries

You can use an alternative library to drive Math::BigInt. See the section
L</MATH LIBRARY> for more information.

For more benchmark results see L<http://bloodgate.com/perl/benchmarks.html>.

=head1 SUBCLASSING

=head2 Subclassing Math::BigInt

The basic design of Math::BigInt allows simple subclasses with very little
work, as long as a few simple rules are followed:

=over

=item *

The public API must remain consistent, i.e. if a sub-class is overloading
addition, the sub-class must use the same name, in this case badd(). The
reason for this is that Math::BigInt is optimized to call the object methods
directly.

=item *

The private object hash keys like C<< $x->{sign} >> may not be changed, but
additional keys can be added, like C<< $x->{_custom} >>.

=item *

Accessor functions are available for all existing object hash keys and should
be used instead of directly accessing the internal hash keys. The reason for
this is that Math::BigInt itself has a pluggable interface which permits it
to support different storage methods.

=back

More complex sub-classes may have to replicate more of the logic internal of
Math::BigInt if they need to change more basic behaviors. A subclass that
needs to merely change the output only needs to overload C<bstr()>. 

All other object methods and overloaded functions can be directly inherited
from the parent class.

At the very minimum, any subclass will need to provide its own C<new()> and can
store additional hash keys in the object. There are also some package globals
that must be defined, e.g.:

  # Globals
  $accuracy = undef;
  $precision = -2;       # round to 2 decimal places
  $round_mode = 'even';
  $div_scale = 40;

Additionally, you might want to provide the following two globals to allow
auto-upgrading and auto-downgrading to work correctly:

  $upgrade = undef;
  $downgrade = undef;

This allows Math::BigInt to correctly retrieve package globals from the 
subclass, like C<$SubClass::precision>.  See t/Math/BigInt/Subclass.pm or
t/Math/BigFloat/SubClass.pm completely functional subclass examples.

Don't forget to 

	use overload;

in your subclass to automatically inherit the overloading from the parent. If
you like, you can change part of the overloading, look at Math::String for an
example.

=head1 UPGRADING

When used like this:

	use Math::BigInt upgrade => 'Foo::Bar';

certain operations will 'upgrade' their calculation and thus the result to
the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:

	use Math::BigInt upgrade => 'Math::BigFloat';

As a shortcut, you can use the module L<bignum>:

	use bignum;

Also good for one-liners:

	perl -Mbignum -le 'print 2 ** 255'

This makes it possible to mix arguments of different classes (as in 2.5 + 2)
as well es preserve accuracy (as in sqrt(3)).

Beware: This feature is not fully implemented yet.

=head2 Auto-upgrade

The following methods upgrade themselves unconditionally; that is if upgrade
is in effect, they will always hand up their work:

=over

=item bsqrt()

=item div()

=item blog()

=item bexp()

=back

Beware: This list is not complete.

All other methods upgrade themselves only when one (or all) of their
arguments are of the class mentioned in $upgrade (This might change in later
versions to a more sophisticated scheme):

=head1 EXPORTS

C<Math::BigInt> exports nothing by default, but can export the following methods:

	bgcd
	blcm

=head1 CAVEATS

Some things might not work as you expect them. Below is documented what is
known to be troublesome:

=over

=item bstr(), bsstr() and 'cmp'

Both C<bstr()> and C<bsstr()> as well as automated stringify via overload now
drop the leading '+'. The old code would return '+3', the new returns '3'.
This is to be consistent with Perl and to make C<cmp> (especially with
overloading) to work as you expect. It also solves problems with C<Test.pm>,
because its C<ok()> uses 'eq' internally. 

Mark Biggar said, when asked about to drop the '+' altogether, or make only
C<cmp> work:

	I agree (with the first alternative), don't add the '+' on positive
	numbers.  It's not as important anymore with the new internal 
	form for numbers.  It made doing things like abs and neg easier,
	but those have to be done differently now anyway.

So, the following examples will now work all as expected:

	use Test;
        BEGIN { plan tests => 1 }
	use Math::BigInt;

	my $x = new Math::BigInt 3*3;
	my $y = new Math::BigInt 3*3;

	ok ($x,3*3);
	print "$x eq 9" if $x eq $y;
	print "$x eq 9" if $x eq '9';
	print "$x eq 9" if $x eq 3*3;

Additionally, the following still works:

	print "$x == 9" if $x == $y;
	print "$x == 9" if $x == 9;
	print "$x == 9" if $x == 3*3;

There is now a C<bsstr()> method to get the string in scientific notation aka
C<1e+2> instead of C<100>. Be advised that overloaded 'eq' always uses bstr()
for comparison, but Perl will represent some numbers as 100 and others
as 1e+308. If in doubt, convert both arguments to Math::BigInt before 
comparing them as strings:

	use Test;
        BEGIN { plan tests => 3 }
	use Math::BigInt;

	$x = Math::BigInt->new('1e56'); $y = 1e56;
	ok ($x,$y);			# will fail
	ok ($x->bsstr(),$y);		# okay
	$y = Math::BigInt->new($y);
	ok ($x,$y);			# okay

Alternatively, simply use C<< <=> >> for comparisons, this will get it
always right. There is not yet a way to get a number automatically represented
as a string that matches exactly the way Perl represents it.

See also the section about L<Infinity and Not a Number> for problems in
comparing NaNs.

=item int()

C<int()> will return (at least for Perl v5.7.1 and up) another BigInt, not a 
Perl scalar:

	$x = Math::BigInt->new(123);
	$y = int($x);				# BigInt 123
	$x = Math::BigFloat->new(123.45);
	$y = int($x);				# BigInt 123

In all Perl versions you can use C<as_number()> or C<as_int> for the same
effect:

	$x = Math::BigFloat->new(123.45);
	$y = $x->as_number();			# BigInt 123
	$y = $x->as_int();			# ditto

This also works for other subclasses, like Math::String.

If you want a real Perl scalar, use C<numify()>:

	$y = $x->numify();			# 123 as scalar

This is seldom necessary, though, because this is done automatically, like
when you access an array:

	$z = $array[$x];			# does work automatically

=item length()

The following will probably not do what you expect:

	$c = Math::BigInt->new(123);
	print $c->length(),"\n";		# prints 30

It prints both the number of digits in the number and in the fraction part
since print calls C<length()> in list context. Use something like: 

	print scalar $c->length(),"\n";		# prints 3

=item bdiv()

The following will probably not do what you expect:

	print $c->bdiv(10000),"\n";

It prints both quotient and remainder since print calls C<bdiv()> in list
context. Also, C<bdiv()> will modify $c, so be careful. You probably want
to use

	print $c / 10000,"\n";

or, if you want to  modify $c instead,

	print scalar $c->bdiv(10000),"\n";

The quotient is always the greatest integer less than or equal to the
real-valued quotient of the two operands, and the remainder (when it is
non-zero) always has the same sign as the second operand; so, for
example,

	  1 / 4  => ( 0, 1)
	  1 / -4 => (-1,-3)
	 -3 / 4  => (-1, 1)
	 -3 / -4 => ( 0,-3)
	-11 / 2  => (-5,1)
	 11 /-2  => (-5,-1)

As a consequence, the behavior of the operator % agrees with the
behavior of Perl's built-in % operator (as documented in the perlop
manpage), and the equation

	$x == ($x / $y) * $y + ($x % $y)

holds true for any $x and $y, which justifies calling the two return
values of bdiv() the quotient and remainder. The only exception to this rule
are when $y == 0 and $x is negative, then the remainder will also be
negative. See below under "infinity handling" for the reasoning behind this.

Perl's 'use integer;' changes the behaviour of % and / for scalars, but will
not change BigInt's way to do things. This is because under 'use integer' Perl
will do what the underlying C thinks is right and this is different for each
system. If you need BigInt's behaving exactly like Perl's 'use integer', bug
the author to implement it ;)

=item infinity handling

Here are some examples that explain the reasons why certain results occur while
handling infinity:

The following table shows the result of the division and the remainder, so that
the equation above holds true. Some "ordinary" cases are strewn in to show more
clearly the reasoning:

	A /  B  =   C,     R so that C *    B +    R =    A
     =========================================================
	5 /   8 =   0,     5 	     0 *    8 +    5 =    5
	0 /   8 =   0,     0	     0 *    8 +    0 =    0
	0 / inf =   0,     0	     0 *  inf +    0 =    0
	0 /-inf =   0,     0	     0 * -inf +    0 =    0
	5 / inf =   0,     5	     0 *  inf +    5 =    5
	5 /-inf =   0,     5	     0 * -inf +    5 =    5
	-5/ inf =   0,    -5	     0 *  inf +   -5 =   -5
	-5/-inf =   0,    -5	     0 * -inf +   -5 =   -5
       inf/   5 =  inf,    0	   inf *    5 +    0 =  inf
      -inf/   5 = -inf,    0      -inf *    5 +    0 = -inf
       inf/  -5 = -inf,    0	  -inf *   -5 +    0 =  inf
      -inf/  -5 =  inf,    0       inf *   -5 +    0 = -inf
	 5/   5 =    1,    0         1 *    5 +    0 =    5
	-5/  -5 =    1,    0         1 *   -5 +    0 =   -5
       inf/ inf =    1,    0         1 *  inf +    0 =  inf
      -inf/-inf =    1,    0         1 * -inf +    0 = -inf
       inf/-inf =   -1,    0        -1 * -inf +    0 =  inf
      -inf/ inf =   -1,    0         1 * -inf +    0 = -inf
	 8/   0 =  inf,    8       inf *    0 +    8 =    8
       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf
         0/   0 =  NaN

These cases below violate the "remainder has the sign of the second of the two
arguments", since they wouldn't match up otherwise.

	A /  B  =   C,     R so that C *    B +    R =    A
     ========================================================
      -inf/   0 = -inf, -inf      -inf *    0 +  inf = -inf
	-8/   0 = -inf,   -8      -inf *    0 +    8 = -8

=item Modifying and =

Beware of:

        $x = Math::BigFloat->new(5);
        $y = $x;

It will not do what you think, e.g. making a copy of $x. Instead it just makes
a second reference to the B<same> object and stores it in $y. Thus anything
that modifies $x (except overloaded operators) will modify $y, and vice versa.
Or in other words, C<=> is only safe if you modify your BigInts only via
overloaded math. As soon as you use a method call it breaks:

        $x->bmul(2);
        print "$x, $y\n";       # prints '10, 10'

If you want a true copy of $x, use:

        $y = $x->copy();

You can also chain the calls like this, this will make first a copy and then
multiply it by 2:

        $y = $x->copy()->bmul(2);

See also the documentation for overload.pm regarding C<=>.

=item bpow

C<bpow()> (and the rounding functions) now modifies the first argument and
returns it, unlike the old code which left it alone and only returned the
result. This is to be consistent with C<badd()> etc. The first three will
modify $x, the last one won't:

	print bpow($x,$i),"\n"; 	# modify $x
	print $x->bpow($i),"\n"; 	# ditto
	print $x **= $i,"\n";		# the same
	print $x ** $i,"\n";		# leave $x alone

The form C<$x **= $y> is faster than C<$x = $x ** $y;>, though.

=item Overloading -$x

The following:

	$x = -$x;

is slower than

	$x->bneg();

since overload calls C<sub($x,0,1);> instead of C<neg($x)>. The first variant
needs to preserve $x since it does not know that it later will get overwritten.
This makes a copy of $x and takes O(N), but $x->bneg() is O(1).

=item Mixing different object types

In Perl you will get a floating point value if you do one of the following:

	$float = 5.0 + 2;
	$float = 2 + 5.0;
	$float = 5 / 2;

With overloaded math, only the first two variants will result in a BigFloat:

	use Math::BigInt;
	use Math::BigFloat;

	$mbf = Math::BigFloat->new(5);
	$mbi2 = Math::BigInteger->new(5);
	$mbi = Math::BigInteger->new(2);

					# what actually gets called:
	$float = $mbf + $mbi;		# $mbf->badd()
	$float = $mbf / $mbi;		# $mbf->bdiv()
	$integer = $mbi + $mbf;		# $mbi->badd()
	$integer = $mbi2 / $mbi;	# $mbi2->bdiv()
	$integer = $mbi2 / $mbf;	# $mbi2->bdiv()

This is because math with overloaded operators follows the first (dominating)
operand, and the operation of that is called and returns thus the result. So,
Math::BigInt::bdiv() will always return a Math::BigInt, regardless whether
the result should be a Math::BigFloat or the second operant is one.

To get a Math::BigFloat you either need to call the operation manually,
make sure the operands are already of the proper type or casted to that type
via Math::BigFloat->new():

	$float = Math::BigFloat->new($mbi2) / $mbi;	# = 2.5

Beware of simple "casting" the entire expression, this would only convert
the already computed result:

	$float = Math::BigFloat->new($mbi2 / $mbi);	# = 2.0 thus wrong!

Beware also of the order of more complicated expressions like:

	$integer = ($mbi2 + $mbi) / $mbf;		# int / float => int
	$integer = $mbi2 / Math::BigFloat->new($mbi);	# ditto

If in doubt, break the expression into simpler terms, or cast all operands
to the desired resulting type.

Scalar values are a bit different, since:

	$float = 2 + $mbf;
	$float = $mbf + 2;

will both result in the proper type due to the way the overloaded math works.

This section also applies to other overloaded math packages, like Math::String.

One solution to you problem might be autoupgrading|upgrading. See the
pragmas L<bignum>, L<bigint> and L<bigrat> for an easy way to do this.

=item bsqrt()

C<bsqrt()> works only good if the result is a big integer, e.g. the square
root of 144 is 12, but from 12 the square root is 3, regardless of rounding
mode. The reason is that the result is always truncated to an integer.

If you want a better approximation of the square root, then use:

	$x = Math::BigFloat->new(12);
	Math::BigFloat->precision(0);
	Math::BigFloat->round_mode('even');
	print $x->copy->bsqrt(),"\n";		# 4

	Math::BigFloat->precision(2);
	print $x->bsqrt(),"\n";			# 3.46
	print $x->bsqrt(3),"\n";		# 3.464

=item brsft()

For negative numbers in base see also L<brsft|/brsft()>.

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

L<Math::BigFloat>, L<Math::BigRat> and L<Math::Big> as well as
L<Math::BigInt::Pari> and  L<Math::BigInt::GMP>.

The pragmas L<bignum>, L<bigint> and L<bigrat> also might be of interest
because they solve the autoupgrading/downgrading issue, at least partly.

The package at
L<http://search.cpan.org/search?mode=module&query=Math%3A%3ABigInt> contains
more documentation including a full version history, testcases, empty
subclass files and benchmarks.

=head1 AUTHORS

Original code by Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 - 2006
and still at it in 2007.

Many people contributed in one or more ways to the final beast, see the file
CREDITS for an (incomplete) list. If you miss your name, please drop me a
mail. Thank you!

=cut
                                                                                                                                                                                                                                                                                                                                                                                               usr/share/perl/5.20.2/Math/BigRat.pm                                                                0100644 0000000 0000000 00000147044 12744441327 015267  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#
# "Tax the rat farms." - Lord Vetinari
#

# The following hash values are used:
#   sign : +,-,NaN,+inf,-inf
#   _d   : denominator
#   _n   : numerator (value = _n/_d)
#   _a   : accuracy
#   _p   : precision
# You should not look at the innards of a BigRat - use the methods for this.

package Math::BigRat;

# anything older is untested, and unlikely to work
use 5.006;
use strict;
use Carp ();

use Math::BigFloat;
use vars qw($VERSION @ISA $upgrade $downgrade
            $accuracy $precision $round_mode $div_scale $_trap_nan $_trap_inf);

@ISA = qw(Math::BigFloat);

$VERSION = '0.2606';
$VERSION = eval $VERSION;

# inherit overload from Math::BigFloat, but disable the bitwise ops that don't
# make much sense for rationals unless they're truncated or something first

use overload
    map {
	my $op = $_;
	($op => sub {
	    Carp::croak("bitwise operation $op not supported in Math::BigRat");
	});
    } qw(& | ^ ~ << >> &= |= ^= <<= >>=);

BEGIN
  {
  *objectify = \&Math::BigInt::objectify; 	# inherit this from BigInt
  *AUTOLOAD = \&Math::BigFloat::AUTOLOAD;	# can't inherit AUTOLOAD
  # we inherit these from BigFloat because currently it is not possible
  # that MBF has a different $MBI variable than we, because MBF also uses
  # Math::BigInt::config->('lib'); (there is always only one library loaded)
  *_e_add = \&Math::BigFloat::_e_add;
  *_e_sub = \&Math::BigFloat::_e_sub;
  *as_int = \&as_number;
  *is_pos = \&is_positive;
  *is_neg = \&is_negative;
  }

##############################################################################
# Global constants and flags. Access these only via the accessor methods!

$accuracy = $precision = undef;
$round_mode = 'even';
$div_scale = 40;
$upgrade = undef;
$downgrade = undef;

# These are internally, and not to be used from the outside at all!

$_trap_nan = 0;                         # are NaNs ok? set w/ config()
$_trap_inf = 0;                         # are infs ok? set w/ config()

# the package we are using for our private parts, defaults to:
# Math::BigInt->config()->{lib}
my $MBI = 'Math::BigInt::Calc';

my $nan = 'NaN';
my $class = 'Math::BigRat';

sub isa
  {
  return 0 if $_[1] =~ /^Math::Big(Int|Float)/;		# we aren't
  UNIVERSAL::isa(@_);
  }

##############################################################################

sub _new_from_float
  {
  # turn a single float input into a rational number (like '0.1')
  my ($self,$f) = @_;

  return $self->bnan() if $f->is_nan();
  return $self->binf($f->{sign}) if $f->{sign} =~ /^[+-]inf$/;

  $self->{_n} = $MBI->_copy( $f->{_m} );	# mantissa
  $self->{_d} = $MBI->_one();
  $self->{sign} = $f->{sign} || '+';
  if ($f->{_es} eq '-')
    {
    # something like Math::BigRat->new('0.1');
    # 1 / 1 => 1/10
    $MBI->_lsft ( $self->{_d}, $f->{_e} ,10);
    }
  else
    {
    # something like Math::BigRat->new('10');
    # 1 / 1 => 10/1
    $MBI->_lsft ( $self->{_n}, $f->{_e} ,10) unless
      $MBI->_is_zero($f->{_e});
    }
  $self;
  }

sub new
  {
  # create a Math::BigRat
  my $class = shift;

  my ($n,$d) = @_;

  my $self = { }; bless $self,$class;

  # input like (BigInt) or (BigFloat):
  if ((!defined $d) && (ref $n) && (!$n->isa('Math::BigRat')))
    {
    if ($n->isa('Math::BigFloat'))
      {
      $self->_new_from_float($n);
      }
    if ($n->isa('Math::BigInt'))
      {
      # TODO: trap NaN, inf
      $self->{_n} = $MBI->_copy($n->{value});		# "mantissa" = N
      $self->{_d} = $MBI->_one();			# d => 1
      $self->{sign} = $n->{sign};
      }
    if ($n->isa('Math::BigInt::Lite'))
      {
      # TODO: trap NaN, inf
      $self->{sign} = '+'; $self->{sign} = '-' if $$n < 0;
      $self->{_n} = $MBI->_new(abs($$n));		# "mantissa" = N
      $self->{_d} = $MBI->_one();			# d => 1
      }
    return $self->bnorm();				# normalize (120/1 => 12/10)
    }

  # input like (BigInt,BigInt) or (BigLite,BigLite):
  if (ref($d) && ref($n))
    {
    # do N first (for $self->{sign}):
    if ($n->isa('Math::BigInt'))
      {
      # TODO: trap NaN, inf
      $self->{_n} = $MBI->_copy($n->{value});		# "mantissa" = N
      $self->{sign} = $n->{sign};
      }
    elsif ($n->isa('Math::BigInt::Lite'))
      {
      # TODO: trap NaN, inf
      $self->{sign} = '+'; $self->{sign} = '-' if $$n < 0;
      $self->{_n} = $MBI->_new(abs($$n));		# "mantissa" = $n
      }
    else
      {
      require Carp;
      Carp::croak(ref($n) . " is not a recognized object format for Math::BigRat->new");
      }
    # now D:
    if ($d->isa('Math::BigInt'))
      {
      # TODO: trap NaN, inf
      $self->{_d} = $MBI->_copy($d->{value});		# "mantissa" = D
      # +/+ or -/- => +, +/- or -/+ => -
      $self->{sign} = $d->{sign} ne $self->{sign} ? '-' : '+';
      }
    elsif ($d->isa('Math::BigInt::Lite'))
      {
      # TODO: trap NaN, inf
      $self->{_d} = $MBI->_new(abs($$d));		# "mantissa" = D
      my $ds = '+'; $ds = '-' if $$d < 0;
      # +/+ or -/- => +, +/- or -/+ => -
      $self->{sign} = $ds ne $self->{sign} ? '-' : '+';
      }
    else
      {
      require Carp;
      Carp::croak(ref($d) . " is not a recognized object format for Math::BigRat->new");
      }
    return $self->bnorm();				# normalize (120/1 => 12/10)
    }
  return $n->copy() if ref $n;				# already a BigRat

  if (!defined $n)
    {
    $self->{_n} = $MBI->_zero();			# undef => 0
    $self->{_d} = $MBI->_one();
    $self->{sign} = '+';
    return $self;
    }

  # string input with / delimiter
  if ($n =~ /\s*\/\s*/)
    {
    return $class->bnan() if $n =~ /\/.*\//;	# 1/2/3 isn't valid
    return $class->bnan() if $n =~ /\/\s*$/;	# 1/ isn't valid
    ($n,$d) = split (/\//,$n);
    # try as BigFloats first
    if (($n =~ /[\.eE]/) || ($d =~ /[\.eE]/))
      {
      local $Math::BigFloat::accuracy = undef;
      local $Math::BigFloat::precision = undef;

      # one of them looks like a float
      my $nf = Math::BigFloat->new($n,undef,undef);
      $self->{sign} = '+';
      return $self->bnan() if $nf->is_nan();

      $self->{_n} = $MBI->_copy( $nf->{_m} );	# get mantissa

      # now correct $self->{_n} due to $n
      my $f = Math::BigFloat->new($d,undef,undef);
      return $self->bnan() if $f->is_nan();
      $self->{_d} = $MBI->_copy( $f->{_m} );

      # calculate the difference between nE and dE
      my $diff_e = $nf->exponent()->bsub( $f->exponent);
      if ($diff_e->is_negative())
	{
        # < 0: mul d with it
        $MBI->_lsft( $self->{_d}, $MBI->_new( $diff_e->babs()), 10);
	}
      elsif (!$diff_e->is_zero())
        {
        # > 0: mul n with it
        $MBI->_lsft( $self->{_n}, $MBI->_new( $diff_e), 10);
        }
      }
    else
      {
      # both d and n look like (big)ints

      $self->{sign} = '+';					# no sign => '+'
      $self->{_n} = undef;
      $self->{_d} = undef;
      if ($n =~ /^([+-]?)0*([0-9]+)\z/)				# first part ok?
	{
	$self->{sign} = $1 || '+';				# no sign => '+'
	$self->{_n} = $MBI->_new($2 || 0);
        }

      if ($d =~ /^([+-]?)0*([0-9]+)\z/)				# second part ok?
	{
	$self->{sign} =~ tr/+-/-+/ if ($1 || '') eq '-';	# negate if second part neg.
	$self->{_d} = $MBI->_new($2 || 0);
        }

      if (!defined $self->{_n} || !defined $self->{_d})
	{
        $d = Math::BigInt->new($d,undef,undef) unless ref $d;
        $n = Math::BigInt->new($n,undef,undef) unless ref $n;

        if ($n->{sign} =~ /^[+-]$/ && $d->{sign} =~ /^[+-]$/)
	  {
	  # both parts are ok as integers (weird things like ' 1e0'
          $self->{_n} = $MBI->_copy($n->{value});
          $self->{_d} = $MBI->_copy($d->{value});
          $self->{sign} = $n->{sign};
          $self->{sign} =~ tr/+-/-+/ if $d->{sign} eq '-';	# -1/-2 => 1/2
          return $self->bnorm();
	  }

        $self->{sign} = '+';					# a default sign
        return $self->bnan() if $n->is_nan() || $d->is_nan();

	# handle inf cases:
        if ($n->is_inf() || $d->is_inf())
	  {
	  if ($n->is_inf())
	    {
	    return $self->bnan() if $d->is_inf();		# both are inf => NaN
	    my $s = '+'; 		# '+inf/+123' or '-inf/-123'
	    $s = '-' if substr($n->{sign},0,1) ne $d->{sign};
	    # +-inf/123 => +-inf
	    return $self->binf($s);
	    }
          # 123/inf => 0
          return $self->bzero();
	  }
	}
      }

    return $self->bnorm();
    }

  # simple string input
  if (($n =~ /[\.eE]/) && $n !~ /^0x/)
    {
    # looks like a float, quacks like a float, so probably is a float
    $self->{sign} = 'NaN';
    local $Math::BigFloat::accuracy = undef;
    local $Math::BigFloat::precision = undef;
    $self->_new_from_float(Math::BigFloat->new($n,undef,undef));
    }
  else
    {
    # for simple forms, use $MBI directly
    if ($n =~ /^([+-]?)0*([0-9]+)\z/)
      {
      $self->{sign} = $1 || '+';
      $self->{_n} = $MBI->_new($2 || 0);
      $self->{_d} = $MBI->_one();
      }
    else
      {
      my $n = Math::BigInt->new($n,undef,undef);
      $self->{_n} = $MBI->_copy($n->{value});
      $self->{_d} = $MBI->_one();
      $self->{sign} = $n->{sign};
      return $self->bnan() if $self->{sign} eq 'NaN';
      return $self->binf($self->{sign}) if $self->{sign} =~ /^[+-]inf$/;
      }
    }
  $self->bnorm();
  }

sub copy
  {
  # if two arguments, the first one is the class to "swallow" subclasses
  my ($c,$x) = @_;

  if (scalar @_ == 1)
    {
    $x = $_[0];
    $c = ref($x);
    }
  return unless ref($x); # only for objects

  my $self = bless {}, $c;

  $self->{sign} = $x->{sign};
  $self->{_d} = $MBI->_copy($x->{_d});
  $self->{_n} = $MBI->_copy($x->{_n});
  $self->{_a} = $x->{_a} if defined $x->{_a};
  $self->{_p} = $x->{_p} if defined $x->{_p};
  $self;
  }

##############################################################################

sub config
  {
  # return (later set?) configuration data as hash ref
  my $class = shift || 'Math::BigRat';

  if (@_ == 1 && ref($_[0]) ne 'HASH')
    {
    my $cfg = $class->SUPER::config();
    return $cfg->{$_[0]};
    }

  my $cfg = $class->SUPER::config(@_);

  # now we need only to override the ones that are different from our parent
  $cfg->{class} = $class;
  $cfg->{with} = $MBI;
  $cfg;
  }

##############################################################################

sub bstr
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)		# inf, NaN etc
    {
    my $s = $x->{sign}; $s =~ s/^\+//; 	# +inf => inf
    return $s;
    }

  my $s = ''; $s = $x->{sign} if $x->{sign} ne '+';	# '+3/2' => '3/2'

  return $s . $MBI->_str($x->{_n}) if $MBI->_is_one($x->{_d});
  $s . $MBI->_str($x->{_n}) . '/' . $MBI->_str($x->{_d});
  }

sub bsstr
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)		# inf, NaN etc
    {
    my $s = $x->{sign}; $s =~ s/^\+//; 	# +inf => inf
    return $s;
    }

  my $s = ''; $s = $x->{sign} if $x->{sign} ne '+';	# +3 vs 3
  $s . $MBI->_str($x->{_n}) . '/' . $MBI->_str($x->{_d});
  }

sub bnorm
  {
  # reduce the number to the shortest form
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  # Both parts must be objects of whatever we are using today.
  if ( my $c = $MBI->_check($x->{_n}) )
    {
    require Carp; Carp::croak ("n did not pass the self-check ($c) in bnorm()");
    }
  if ( my $c = $MBI->_check($x->{_d}) )
    {
    require Carp; Carp::croak ("d did not pass the self-check ($c) in bnorm()");
    }

  # no normalize for NaN, inf etc.
  return $x if $x->{sign} !~ /^[+-]$/;

  # normalize zeros to 0/1
  if ($MBI->_is_zero($x->{_n}))
    {
    $x->{sign} = '+';					# never leave a -0
    $x->{_d} = $MBI->_one() unless $MBI->_is_one($x->{_d});
    return $x;
    }

  return $x if $MBI->_is_one($x->{_d});			# no need to reduce

  # reduce other numbers
  my $gcd = $MBI->_copy($x->{_n});
  $gcd = $MBI->_gcd($gcd,$x->{_d});

  if (!$MBI->_is_one($gcd))
    {
    $x->{_n} = $MBI->_div($x->{_n},$gcd);
    $x->{_d} = $MBI->_div($x->{_d},$gcd);
    }
  $x;
  }

##############################################################################
# sign manipulation

sub bneg
  {
  # (BRAT or num_str) return BRAT
  # negate number or make a negated number from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x if $x->modify('bneg');

  # for +0 do not negate (to have always normalized +0). Does nothing for 'NaN'
  $x->{sign} =~ tr/+-/-+/ unless ($x->{sign} eq '+' && $MBI->_is_zero($x->{_n}));
  $x;
  }

##############################################################################
# special values

sub _bnan
  {
  # used by parent class bnan() to initialize number to NaN
  my $self = shift;

  if ($_trap_nan)
    {
    require Carp;
    my $class = ref($self);
    # "$self" below will stringify the object, this blows up if $self is a
    # partial object (happens under trap_nan), so fix it beforehand
    $self->{_d} = $MBI->_zero() unless defined $self->{_d};
    $self->{_n} = $MBI->_zero() unless defined $self->{_n};
    Carp::croak ("Tried to set $self to NaN in $class\::_bnan()");
    }
  $self->{_n} = $MBI->_zero();
  $self->{_d} = $MBI->_zero();
  }

sub _binf
  {
  # used by parent class bone() to initialize number to +inf/-inf
  my $self = shift;

  if ($_trap_inf)
    {
    require Carp;
    my $class = ref($self);
    # "$self" below will stringify the object, this blows up if $self is a
    # partial object (happens under trap_nan), so fix it beforehand
    $self->{_d} = $MBI->_zero() unless defined $self->{_d};
    $self->{_n} = $MBI->_zero() unless defined $self->{_n};
    Carp::croak ("Tried to set $self to inf in $class\::_binf()");
    }
  $self->{_n} = $MBI->_zero();
  $self->{_d} = $MBI->_zero();
  }

sub _bone
  {
  # used by parent class bone() to initialize number to +1/-1
  my $self = shift;
  $self->{_n} = $MBI->_one();
  $self->{_d} = $MBI->_one();
  }

sub _bzero
  {
  # used by parent class bzero() to initialize number to 0
  my $self = shift;
  $self->{_n} = $MBI->_zero();
  $self->{_d} = $MBI->_one();
  }

##############################################################################
# mul/add/div etc

sub badd
  {
  # add two rational numbers

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  # +inf + +inf => +inf,  -inf + -inf => -inf
  return $x->binf(substr($x->{sign},0,1))
    if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;

  # +inf + -inf or -inf + +inf => NaN
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  #  1   1    gcd(3,4) = 1    1*3 + 1*4    7
  #  - + -                  = --------- = --
  #  4   3                      4*3       12

  # we do not compute the gcd() here, but simple do:
  #  5   7    5*3 + 7*4   43
  #  - + -  = --------- = --
  #  4   3       4*3      12

  # and bnorm() will then take care of the rest

  # 5 * 3
  $x->{_n} = $MBI->_mul( $x->{_n}, $y->{_d});

  # 7 * 4
  my $m = $MBI->_mul( $MBI->_copy( $y->{_n} ), $x->{_d} );

  # 5 * 3 + 7 * 4
  ($x->{_n}, $x->{sign}) = _e_add( $x->{_n}, $m, $x->{sign}, $y->{sign});

  # 4 * 3
  $x->{_d} = $MBI->_mul( $x->{_d}, $y->{_d});

  # normalize result, and possible round
  $x->bnorm()->round(@r);
  }

sub bsub
  {
  # subtract two rational numbers

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  # flip sign of $x, call badd(), then flip sign of result
  $x->{sign} =~ tr/+-/-+/
    unless $x->{sign} eq '+' && $MBI->_is_zero($x->{_n});	# not -0
  $x->badd($y,@r);				# does norm and round
  $x->{sign} =~ tr/+-/-+/
    unless $x->{sign} eq '+' && $MBI->_is_zero($x->{_n});	# not -0
  $x;
  }

sub bmul
  {
  # multiply two rational numbers

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x->bnan() if ($x->{sign} eq 'NaN' || $y->{sign} eq 'NaN');

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }

  # x== 0 # also: or y == 1 or y == -1
  return wantarray ? ($x,$self->bzero()) : $x if $x->is_zero();

  # XXX TODO:
  # According to Knuth, this can be optimized by doing gcd twice (for d and n)
  # and reducing in one step. This would save us the bnorm() at the end.

  #  1   2    1 * 2    2    1
  #  - * - =  -----  = -  = -
  #  4   3    4 * 3    12   6

  $x->{_n} = $MBI->_mul( $x->{_n}, $y->{_n});
  $x->{_d} = $MBI->_mul( $x->{_d}, $y->{_d});

  # compute new sign
  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-';

  $x->bnorm()->round(@r);
  }

sub bdiv
  {
  # (dividend: BRAT or num_str, divisor: BRAT or num_str) return
  # (BRAT,BRAT) (quo,rem) or BRAT (only rem)

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $self->_div_inf($x,$y)
   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());

  # x== 0 # also: or y == 1 or y == -1
  return wantarray ? ($x,$self->bzero()) : $x if $x->is_zero();

  # XXX TODO: list context, upgrade
  # According to Knuth, this can be optimized by doing gcd twice (for d and n)
  # and reducing in one step. This would save us the bnorm() at the end.

  # 1     1    1   3
  # -  /  - == - * -
  # 4     3    4   1

  $x->{_n} = $MBI->_mul( $x->{_n}, $y->{_d});
  $x->{_d} = $MBI->_mul( $x->{_d}, $y->{_n});

  # compute new sign
  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-';

  $x->bnorm()->round(@r);
  $x;
  }

sub bmod
  {
  # compute "remainder" (in Perl way) of $x / $y

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $self->_div_inf($x,$y)
   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());

  return $x if $x->is_zero();           # 0 / 7 = 0, mod 0

  # compute $x - $y * floor($x/$y), keeping the sign of $x

  # copy x to u, make it positive and then do a normal division ($u/$y)
  my $u = bless { sign => '+' }, $self;
  $u->{_n} = $MBI->_mul( $MBI->_copy($x->{_n}), $y->{_d} );
  $u->{_d} = $MBI->_mul( $MBI->_copy($x->{_d}), $y->{_n} );

  # compute floor(u)
  if (! $MBI->_is_one($u->{_d}))
    {
    $u->{_n} = $MBI->_div($u->{_n},$u->{_d});	# 22/7 => 3/1 w/ truncate
    # no need to set $u->{_d} to 1, since below we set it to $y->{_d} anyway
    }

  # now compute $y * $u
  $u->{_d} = $MBI->_copy($y->{_d});		# 1 * $y->{_d}, see floor above
  $u->{_n} = $MBI->_mul($u->{_n},$y->{_n});

  my $xsign = $x->{sign}; $x->{sign} = '+';	# remember sign and make x positive
  # compute $x - $u
  $x->bsub($u);
  $x->{sign} = $xsign;				# put sign back

  $x->bnorm()->round(@r);
  }

##############################################################################
# bdec/binc

sub bdec
  {
  # decrement value (subtract 1)
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->{sign} !~ /^[+-]$/;	# NaN, inf, -inf

  if ($x->{sign} eq '-')
    {
    $x->{_n} = $MBI->_add( $x->{_n}, $x->{_d});		# -5/2 => -7/2
    }
  else
    {
    if ($MBI->_acmp($x->{_n},$x->{_d}) < 0)		# n < d?
      {
      # 1/3 -- => -2/3
      $x->{_n} = $MBI->_sub( $MBI->_copy($x->{_d}), $x->{_n});
      $x->{sign} = '-';
      }
    else
      {
      $x->{_n} = $MBI->_sub($x->{_n}, $x->{_d}); 	# 5/2 => 3/2
      }
    }
  $x->bnorm()->round(@r);
  }

sub binc
  {
  # increment value (add 1)
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->{sign} !~ /^[+-]$/;	# NaN, inf, -inf

  if ($x->{sign} eq '-')
    {
    if ($MBI->_acmp($x->{_n},$x->{_d}) < 0)
      {
      # -1/3 ++ => 2/3 (overflow at 0)
      $x->{_n} = $MBI->_sub( $MBI->_copy($x->{_d}), $x->{_n});
      $x->{sign} = '+';
      }
    else
      {
      $x->{_n} = $MBI->_sub($x->{_n}, $x->{_d}); 	# -5/2 => -3/2
      }
    }
  else
    {
    $x->{_n} = $MBI->_add($x->{_n},$x->{_d});		# 5/2 => 7/2
    }
  $x->bnorm()->round(@r);
  }

##############################################################################
# is_foo methods (the rest is inherited)

sub is_int
  {
  # return true if arg (BRAT or num_str) is an integer
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 1 if ($x->{sign} =~ /^[+-]$/) &&	# NaN and +-inf aren't
    $MBI->_is_one($x->{_d});			# x/y && y != 1 => no integer
  0;
  }

sub is_zero
  {
  # return true if arg (BRAT or num_str) is zero
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 1 if $x->{sign} eq '+' && $MBI->_is_zero($x->{_n});
  0;
  }

sub is_one
  {
  # return true if arg (BRAT or num_str) is +1 or -1 if signis given
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  my $sign = $_[2] || ''; $sign = '+' if $sign ne '-';
  return 1
   if ($x->{sign} eq $sign && $MBI->_is_one($x->{_n}) && $MBI->_is_one($x->{_d}));
  0;
  }

sub is_odd
  {
  # return true if arg (BFLOAT or num_str) is odd or false if even
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 1 if ($x->{sign} =~ /^[+-]$/) &&		# NaN & +-inf aren't
    ($MBI->_is_one($x->{_d}) && $MBI->_is_odd($x->{_n})); # x/2 is not, but 3/1
  0;
  }

sub is_even
  {
  # return true if arg (BINT or num_str) is even or false if odd
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
  return 1 if ($MBI->_is_one($x->{_d})			# x/3 is never
     && $MBI->_is_even($x->{_n}));			# but 4/1 is
  0;
  }

##############################################################################
# parts() and friends

sub numerator
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  # NaN, inf, -inf
  return Math::BigInt->new($x->{sign}) if ($x->{sign} !~ /^[+-]$/);

  my $n = Math::BigInt->new($MBI->_str($x->{_n})); $n->{sign} = $x->{sign};
  $n;
  }

sub denominator
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  # NaN
  return Math::BigInt->new($x->{sign}) if $x->{sign} eq 'NaN';
  # inf, -inf
  return Math::BigInt->bone() if $x->{sign} !~ /^[+-]$/;

  Math::BigInt->new($MBI->_str($x->{_d}));
  }

sub parts
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  my $c = 'Math::BigInt';

  return ($c->bnan(),$c->bnan()) if $x->{sign} eq 'NaN';
  return ($c->binf(),$c->binf()) if $x->{sign} eq '+inf';
  return ($c->binf('-'),$c->binf()) if $x->{sign} eq '-inf';

  my $n = $c->new( $MBI->_str($x->{_n}));
  $n->{sign} = $x->{sign};
  my $d = $c->new( $MBI->_str($x->{_d}));
  ($n,$d);
  }

sub length
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $nan unless $x->is_int();
  $MBI->_len($x->{_n});				# length(-123/1) => length(123)
  }

sub digit
  {
  my ($self,$x,$n) = ref($_[0]) ? (undef,$_[0],$_[1]) : objectify(1,@_);

  return $nan unless $x->is_int();
  $MBI->_digit($x->{_n},$n || 0);		# digit(-123/1,2) => digit(123,2)
  }

##############################################################################
# special calc routines

sub bceil
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x if $x->{sign} !~ /^[+-]$/ ||	# not for NaN, inf
            $MBI->_is_one($x->{_d});		# 22/1 => 22, 0/1 => 0

  $x->{_n} = $MBI->_div($x->{_n},$x->{_d});	# 22/7 => 3/1 w/ truncate
  $x->{_d} = $MBI->_one();			# d => 1
  $x->{_n} = $MBI->_inc($x->{_n})
    if $x->{sign} eq '+';			# +22/7 => 4/1
  $x->{sign} = '+' if $MBI->_is_zero($x->{_n});	# -0 => 0
  $x;
  }

sub bfloor
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x if $x->{sign} !~ /^[+-]$/ ||	# not for NaN, inf
            $MBI->_is_one($x->{_d});		# 22/1 => 22, 0/1 => 0

  $x->{_n} = $MBI->_div($x->{_n},$x->{_d});	# 22/7 => 3/1 w/ truncate
  $x->{_d} = $MBI->_one();			# d => 1
  $x->{_n} = $MBI->_inc($x->{_n})
    if $x->{sign} eq '-';			# -22/7 => -4/1
  $x;
  }

sub bfac
  {
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  # if $x is not an integer
  if (($x->{sign} ne '+') || (!$MBI->_is_one($x->{_d})))
    {
    return $x->bnan();
    }

  $x->{_n} = $MBI->_fac($x->{_n});
  # since _d is 1, we don't need to reduce/norm the result
  $x->round(@r);
  }

sub bpow
  {
  # power ($x ** $y)

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->{sign} =~ /^[+-]inf$/;       # -inf/+inf ** x
  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;
  return $x->bone(@r) if $y->is_zero();
  return $x->round(@r) if $x->is_one() || $y->is_one();

  if ($x->{sign} eq '-' && $MBI->_is_one($x->{_n}) && $MBI->_is_one($x->{_d}))
    {
    # if $x == -1 and odd/even y => +1/-1
    return $y->is_odd() ? $x->round(@r) : $x->babs()->round(@r);
    # my Casio FX-5500L has a bug here: -1 ** 2 is -1, but -1 * -1 is 1;
    }
  # 1 ** -y => 1 / (1 ** |y|)
  # so do test for negative $y after above's clause

  return $x->round(@r) if $x->is_zero();  # 0**y => 0 (if not y <= 0)

  # shortcut if y == 1/N (is then sqrt() respective broot())
  if ($MBI->_is_one($y->{_n}))
    {
    return $x->bsqrt(@r) if $MBI->_is_two($y->{_d});	# 1/2 => sqrt
    return $x->broot($MBI->_str($y->{_d}),@r);		# 1/N => root(N)
    }

  # shortcut y/1 (and/or x/1)
  if ($MBI->_is_one($y->{_d}))
    {
    # shortcut for x/1 and y/1
    if ($MBI->_is_one($x->{_d}))
      {
      $x->{_n} = $MBI->_pow($x->{_n},$y->{_n});		# x/1 ** y/1 => (x ** y)/1
      if ($y->{sign} eq '-')
        {
        # 0.2 ** -3 => 1/(0.2 ** 3)
        ($x->{_n},$x->{_d}) = ($x->{_d},$x->{_n});	# swap
        }
      # correct sign; + ** + => +
      if ($x->{sign} eq '-')
        {
        # - * - => +, - * - * - => -
        $x->{sign} = '+' if $MBI->_is_even($y->{_n});
        }
      return $x->round(@r);
      }
    # x/z ** y/1
    $x->{_n} = $MBI->_pow($x->{_n},$y->{_n});		# 5/2 ** y/1 => 5 ** y / 2 ** y
    $x->{_d} = $MBI->_pow($x->{_d},$y->{_n});
    if ($y->{sign} eq '-')
      {
      # 0.2 ** -3 => 1/(0.2 ** 3)
      ($x->{_n},$x->{_d}) = ($x->{_d},$x->{_n});	# swap
      }
    # correct sign; + ** + => +
    if ($x->{sign} eq '-')
      {
      # - * - => +, - * - * - => -
      $x->{sign} = '+' if $MBI->_is_even($y->{_n});
      }
    return $x->round(@r);
    }

#  print STDERR "# $x $y\n";

  # otherwise:

  #      n/d     n  ______________
  # a/b       =  -\/  (a/b) ** d

  # (a/b) ** n == (a ** n) / (b ** n)
  $MBI->_pow($x->{_n}, $y->{_n} );
  $MBI->_pow($x->{_d}, $y->{_n} );

  return $x->broot($MBI->_str($y->{_d}),@r);		# n/d => root(n)
  }

sub blog
  {
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,$class,@_);
    }

  # blog(1,Y) => 0
  return $x->bzero() if $x->is_one() && $y->{sign} eq '+';

  # $x <= 0 => NaN
  return $x->bnan() if $x->is_zero() || $x->{sign} ne '+' || $y->{sign} ne '+';

  if ($x->is_int() && $y->is_int())
    {
    return $self->new($x->as_number()->blog($y->as_number(),@r));
    }

  # do it with floats
  $x->_new_from_float( $x->_as_float()->blog(Math::BigFloat->new("$y"),@r) );
  }

sub bexp
  {
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,$class,@_);
    }

  return $x->binf(@r) if $x->{sign} eq '+inf';
  return $x->bzero(@r) if $x->{sign} eq '-inf';

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters(@r);

  # also takes care of the "error in _find_round_parameters?" case
  return $x if $x->{sign} eq 'NaN';

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# P = undef
    $scale = $params[0]+4;		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it's not enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  return $x->bone(@params) if $x->is_zero();

  # See the comments in Math::BigFloat on how this algorithm works.
  # Basically we calculate A and B (where B is faculty(N)) so that A/B = e

  my $x_org = $x->copy();
  if ($scale <= 75)
    {
    # set $x directly from a cached string form
    $x->{_n} = $MBI->_new("90933395208605785401971970164779391644753259799242");
    $x->{_d} = $MBI->_new("33452526613163807108170062053440751665152000000000");
    $x->{sign} = '+';
    }
  else
    {
    # compute A and B so that e = A / B.

    # After some terms we end up with this, so we use it as a starting point:
    my $A = $MBI->_new("90933395208605785401971970164779391644753259799242");
    my $F = $MBI->_new(42); my $step = 42;

    # Compute how many steps we need to take to get $A and $B sufficiently big
    my $steps = Math::BigFloat::_len_to_steps($scale - 4);
#    print STDERR "# Doing $steps steps for ", $scale-4, " digits\n";
    while ($step++ <= $steps)
      {
      # calculate $a * $f + 1
      $A = $MBI->_mul($A, $F);
      $A = $MBI->_inc($A);
      # increment f
      $F = $MBI->_inc($F);
      }
    # compute $B as factorial of $steps (this is faster than doing it manually)
    my $B = $MBI->_fac($MBI->_new($steps));

#  print "A ", $MBI->_str($A), "\nB ", $MBI->_str($B), "\n";

    $x->{_n} = $A;
    $x->{_d} = $B;
    $x->{sign} = '+';
    }

  # $x contains now an estimate of e, with some surplus digits, so we can round
  if (!$x_org->is_one())
    {
    # raise $x to the wanted power and round it in one step:
    $x->bpow($x_org, @params);
    }
  else
    {
    # else just round the already computed result
    delete $x->{_a}; delete $x->{_p};
    # shortcut to not run through _find_round_parameters again
    if (defined $params[0])
      {
      $x->bround($params[0],$params[2]);                # then round accordingly
      }
    else
      {
      $x->bfround($params[1],$params[2]);               # then round accordingly
      }
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }

  $x;
  }

sub bnok
  {
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,$class,@_);
    }

  # do it with floats
  $x->_new_from_float( $x->_as_float()->bnok(Math::BigFloat->new("$y"),@r) );
  }

sub _float_from_part
  {
  my $x = shift;

  my $f = Math::BigFloat->bzero();
  $f->{_m} = $MBI->_copy($x);
  $f->{_e} = $MBI->_zero();

  $f;
  }

sub _as_float
  {
  my $x = shift;

  local $Math::BigFloat::upgrade = undef;
  local $Math::BigFloat::accuracy = undef;
  local $Math::BigFloat::precision = undef;
  # 22/7 => 3.142857143..

  my $a = $x->accuracy() || 0;
  if ($a != 0 || !$MBI->_is_one($x->{_d}))
    {
    # n/d
    return scalar Math::BigFloat->new($x->{sign} . $MBI->_str($x->{_n}))->bdiv( $MBI->_str($x->{_d}), $x->accuracy());
    }
  # just n
  Math::BigFloat->new($x->{sign} . $MBI->_str($x->{_n}));
  }

sub broot
  {
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  if ($x->is_int() && $y->is_int())
    {
    return $self->new($x->as_number()->broot($y->as_number(),@r));
    }

  # do it with floats
  $x->_new_from_float( $x->_as_float()->broot($y->_as_float(),@r) )->bnorm()->bround(@r);
  }

sub bmodpow
  {
  # set up parameters
  my ($self,$x,$y,$m,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$m,@r) = objectify(3,@_);
    }

  # $x or $y or $m are NaN or +-inf => NaN
  return $x->bnan()
   if $x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/ ||
   $m->{sign} !~ /^[+-]$/;

  if ($x->is_int() && $y->is_int() && $m->is_int())
    {
    return $self->new($x->as_number()->bmodpow($y->as_number(),$m,@r));
    }

  warn ("bmodpow() not fully implemented");
  $x->bnan();
  }

sub bmodinv
  {
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  # $x or $y are NaN or +-inf => NaN
  return $x->bnan()
   if $x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/;

  if ($x->is_int() && $y->is_int())
    {
    return $self->new($x->as_number()->bmodinv($y->as_number(),@r));
    }

  warn ("bmodinv() not fully implemented");
  $x->bnan();
  }

sub bsqrt
  {
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x->bnan() if $x->{sign} !~ /^[+]/;    # NaN, -inf or < 0
  return $x if $x->{sign} eq '+inf';            # sqrt(inf) == inf
  return $x->round(@r) if $x->is_zero() || $x->is_one();

  local $Math::BigFloat::upgrade = undef;
  local $Math::BigFloat::downgrade = undef;
  local $Math::BigFloat::precision = undef;
  local $Math::BigFloat::accuracy = undef;
  local $Math::BigInt::upgrade = undef;
  local $Math::BigInt::precision = undef;
  local $Math::BigInt::accuracy = undef;

  $x->{_n} = _float_from_part( $x->{_n} )->bsqrt();
  $x->{_d} = _float_from_part( $x->{_d} )->bsqrt();

  # XXX TODO: we probably can optimize this:

  # if sqrt(D) was not integer
  if ($x->{_d}->{_es} ne '+')
    {
    $x->{_n}->blsft($x->{_d}->exponent()->babs(),10);	# 7.1/4.51 => 7.1/45.1
    $x->{_d} = $MBI->_copy( $x->{_d}->{_m} );		# 7.1/45.1 => 71/45.1
    }
  # if sqrt(N) was not integer
  if ($x->{_n}->{_es} ne '+')
    {
    $x->{_d}->blsft($x->{_n}->exponent()->babs(),10);	# 71/45.1 => 710/45.1
    $x->{_n} = $MBI->_copy( $x->{_n}->{_m} );		# 710/45.1 => 710/451
    }

  # convert parts to $MBI again
  $x->{_n} = $MBI->_lsft( $MBI->_copy( $x->{_n}->{_m} ), $x->{_n}->{_e}, 10)
    if ref($x->{_n}) ne $MBI && ref($x->{_n}) ne 'ARRAY';
  $x->{_d} = $MBI->_lsft( $MBI->_copy( $x->{_d}->{_m} ), $x->{_d}->{_e}, 10)
    if ref($x->{_d}) ne $MBI && ref($x->{_d}) ne 'ARRAY';

  $x->bnorm()->round(@r);
  }

sub blsft
  {
  my ($self,$x,$y,$b,@r) = objectify(3,@_);

  $b = 2 unless defined $b;
  $b = $self->new($b) unless ref ($b);
  $x->bmul( $b->copy()->bpow($y), @r);
  $x;
  }

sub brsft
  {
  my ($self,$x,$y,$b,@r) = objectify(3,@_);

  $b = 2 unless defined $b;
  $b = $self->new($b) unless ref ($b);
  $x->bdiv( $b->copy()->bpow($y), @r);
  $x;
  }

##############################################################################
# round

sub round
  {
  $_[0];
  }

sub bround
  {
  $_[0];
  }

sub bfround
  {
  $_[0];
  }

##############################################################################
# comparing

sub bcmp
  {
  # compare two signed numbers

  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@_);
    }

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;
    return +1 if $x->{sign} eq '+inf';
    return -1 if $x->{sign} eq '-inf';
    return -1 if $y->{sign} eq '+inf';
    return +1;
    }
  # check sign for speed first
  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';   # does also 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0

  # shortcut
  my $xz = $MBI->_is_zero($x->{_n});
  my $yz = $MBI->_is_zero($y->{_n});
  return 0 if $xz && $yz;                               # 0 <=> 0
  return -1 if $xz && $y->{sign} eq '+';                # 0 <=> +y
  return 1 if $yz && $x->{sign} eq '+';                 # +x <=> 0

  my $t = $MBI->_mul( $MBI->_copy($x->{_n}), $y->{_d});
  my $u = $MBI->_mul( $MBI->_copy($y->{_n}), $x->{_d});

  my $cmp = $MBI->_acmp($t,$u);				# signs are equal
  $cmp = -$cmp if $x->{sign} eq '-';			# both are '-' => reverse
  $cmp;
  }

sub bacmp
  {
  # compare two numbers (as unsigned)

  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,$class,@_);
    }

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} =~ /^[+-]inf$/;
    return 1 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} !~ /^[+-]inf$/;
    return -1;
    }

  my $t = $MBI->_mul( $MBI->_copy($x->{_n}), $y->{_d});
  my $u = $MBI->_mul( $MBI->_copy($y->{_n}), $x->{_d});
  $MBI->_acmp($t,$u);					# ignore signs
  }

##############################################################################
# output conversation

sub numify
  {
  # convert 17/8 => float (aka 2.125)
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, NaN, etc

  # N/1 => N
  my $neg = ''; $neg = '-' if $x->{sign} eq '-';
  return $neg . $MBI->_num($x->{_n}) if $MBI->_is_one($x->{_d});

  $x->_as_float()->numify() + 0.0;
  }

sub as_number
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  # NaN, inf etc
  return Math::BigInt->new($x->{sign}) if $x->{sign} !~ /^[+-]$/;

  my $u = Math::BigInt->bzero();
  $u->{value} = $MBI->_div( $MBI->_copy($x->{_n}), $x->{_d});	# 22/7 => 3
  $u->bneg if $x->{sign} eq '-'; # no negative zero
  $u;
  }

sub as_float
  {
  # return N/D as Math::BigFloat

  # set up parameters
  my ($self,$x,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  ($self,$x,@r) = objectify(1,$class,@_) unless ref $_[0];

  # NaN, inf etc
  return Math::BigFloat->new($x->{sign}) if $x->{sign} !~ /^[+-]$/;

  my $u = Math::BigFloat->bzero();
  $u->{sign} = $x->{sign};
  # n
  $u->{_m} = $MBI->_copy($x->{_n});
  $u->{_e} = $MBI->_zero();
  $u->bdiv( $MBI->_str($x->{_d}), @r);
  # return $u
  $u;
  }

sub as_bin
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x unless $x->is_int();

  my $s = $x->{sign}; $s = '' if $s eq '+';
  $s . $MBI->_as_bin($x->{_n});
  }

sub as_hex
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x unless $x->is_int();

  my $s = $x->{sign}; $s = '' if $s eq '+';
  $s . $MBI->_as_hex($x->{_n});
  }

sub as_oct
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x unless $x->is_int();

  my $s = $x->{sign}; $s = '' if $s eq '+';
  $s . $MBI->_as_oct($x->{_n});
  }

##############################################################################

sub from_hex
  {
  my $class = shift;

  $class->new(@_);
  }

sub from_bin
  {
  my $class = shift;

  $class->new(@_);
  }

sub from_oct
  {
  my $class = shift;

  my @parts;
  for my $c (@_)
    {
    push @parts, Math::BigInt->from_oct($c);
    }
  $class->new ( @parts );
  }

##############################################################################
# import

sub import
  {
  my $self = shift;
  my $l = scalar @_;
  my $lib = ''; my @a;
  my $try = 'try';

  for ( my $i = 0; $i < $l ; $i++)
    {
    if ( $_[$i] eq ':constant' )
      {
      # this rest causes overlord er load to step in
      overload::constant float => sub { $self->new(shift); };
      }
#    elsif ($_[$i] eq 'upgrade')
#      {
#     # this causes upgrading
#      $upgrade = $_[$i+1];		# or undef to disable
#      $i++;
#      }
    elsif ($_[$i] eq 'downgrade')
      {
      # this causes downgrading
      $downgrade = $_[$i+1];		# or undef to disable
      $i++;
      }
    elsif ($_[$i] =~ /^(lib|try|only)\z/)
      {
      $lib = $_[$i+1] || '';		# default Calc
      $try = $1;			# lib, try or only
      $i++;
      }
    elsif ($_[$i] eq 'with')
      {
      # this argument is no longer used
      #$MBI = $_[$i+1] || 'Math::BigInt::Calc';	# default Math::BigInt::Calc
      $i++;
      }
    else
      {
      push @a, $_[$i];
      }
    }
  require Math::BigInt;

  # let use Math::BigInt lib => 'GMP'; use Math::BigRat; still have GMP
  if ($lib ne '')
    {
    my @c = split /\s*,\s*/, $lib;
    foreach (@c)
      {
      $_ =~ tr/a-zA-Z0-9://cd;                    # limit to sane characters
      }
    $lib = join(",", @c);
    }
  my @import = ('objectify');
  push @import, $try => $lib if $lib ne '';

  # MBI already loaded, so feed it our lib arguments
  Math::BigInt->import( @import );

  $MBI = Math::BigFloat->config()->{lib};

  # register us with MBI to get notified of future lib changes
  Math::BigInt::_register_callback( $self, sub { $MBI = $_[0]; } );

  # any non :constant stuff is handled by our parent, Exporter (loaded
  # by Math::BigFloat, even if @_ is empty, to give it a chance
  $self->SUPER::import(@a);             # for subclasses
  $self->export_to_level(1,$self,@a);   # need this, too
  }

1;

__END__

=head1 NAME

Math::BigRat - Arbitrary big rational numbers

=head1 SYNOPSIS

	use Math::BigRat;

	my $x = Math::BigRat->new('3/7'); $x += '5/9';

	print $x->bstr(),"\n";
	print $x ** 2,"\n";

	my $y = Math::BigRat->new('inf');
	print "$y ", ($y->is_inf ? 'is' : 'is not') , " infinity\n";

	my $z = Math::BigRat->new(144); $z->bsqrt();

=head1 DESCRIPTION

Math::BigRat complements Math::BigInt and Math::BigFloat by providing support
for arbitrary big rational numbers.

=head2 MATH LIBRARY

You can change the underlying module that does the low-level
math operations by using:

	use Math::BigRat try => 'GMP';

Note: This needs Math::BigInt::GMP installed.

The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:

	use Math::BigRat try => 'Foo,Math::BigInt::Bar';

If you want to get warned when the fallback occurs, replace "try" with
"lib":

	use Math::BigRat lib => 'Foo,Math::BigInt::Bar';

If you want the code to die instead, replace "try" with
"only":

	use Math::BigRat only => 'Foo,Math::BigInt::Bar';

=head1 METHODS

Any methods not listed here are derived from Math::BigFloat (or
Math::BigInt), so make sure you check these two modules for further
information.

=head2 new()

	$x = Math::BigRat->new('1/3');

Create a new Math::BigRat object. Input can come in various forms:

	$x = Math::BigRat->new(123);				# scalars
	$x = Math::BigRat->new('inf');				# infinity
	$x = Math::BigRat->new('123.3');			# float
	$x = Math::BigRat->new('1/3');				# simple string
	$x = Math::BigRat->new('1 / 3');			# spaced
	$x = Math::BigRat->new('1 / 0.1');			# w/ floats
	$x = Math::BigRat->new(Math::BigInt->new(3));		# BigInt
	$x = Math::BigRat->new(Math::BigFloat->new('3.1'));	# BigFloat
	$x = Math::BigRat->new(Math::BigInt::Lite->new('2'));	# BigLite

	# You can also give D and N as different objects:
	$x = Math::BigRat->new(
		Math::BigInt->new(-123),
		Math::BigInt->new(7),
		);			# => -123/7

=head2 numerator()

	$n = $x->numerator();

Returns a copy of the numerator (the part above the line) as signed BigInt.

=head2 denominator()

	$d = $x->denominator();

Returns a copy of the denominator (the part under the line) as positive BigInt.

=head2 parts()

	($n,$d) = $x->parts();

Return a list consisting of (signed) numerator and (unsigned) denominator as
BigInts.

=head2 numify()

	my $y = $x->numify();

Returns the object as a scalar. This will lose some data if the object
cannot be represented by a normal Perl scalar (integer or float), so
use L<as_int()|/as_int()E<sol>as_number()> or L</as_float()> instead.

This routine is automatically used whenever a scalar is required:

	my $x = Math::BigRat->new('3/1');
	@array = (0,1,2,3);
	$y = $array[$x];		# set $y to 3

=head2 as_int()/as_number()

	$x = Math::BigRat->new('13/7');
	print $x->as_int(),"\n";		# '1'

Returns a copy of the object as BigInt, truncated to an integer.

C<as_number()> is an alias for C<as_int()>.

=head2 as_float()

	$x = Math::BigRat->new('13/7');
	print $x->as_float(),"\n";		# '1'

	$x = Math::BigRat->new('2/3');
	print $x->as_float(5),"\n";		# '0.66667'

Returns a copy of the object as BigFloat, preserving the
accuracy as wanted, or the default of 40 digits.

This method was added in v0.22 of Math::BigRat (April 2008).

=head2 as_hex()

	$x = Math::BigRat->new('13');
	print $x->as_hex(),"\n";		# '0xd'

Returns the BigRat as hexadecimal string. Works only for integers.

=head2 as_bin()

	$x = Math::BigRat->new('13');
	print $x->as_bin(),"\n";		# '0x1101'

Returns the BigRat as binary string. Works only for integers.

=head2 as_oct()

	$x = Math::BigRat->new('13');
	print $x->as_oct(),"\n";		# '015'

Returns the BigRat as octal string. Works only for integers.

=head2 from_hex()/from_bin()/from_oct()

	my $h = Math::BigRat->from_hex('0x10');
	my $b = Math::BigRat->from_bin('0b10000000');
	my $o = Math::BigRat->from_oct('020');

Create a BigRat from an hexadecimal, binary or octal number
in string form.

=head2 length()

	$len = $x->length();

Return the length of $x in digits for integer values.

=head2 digit()

	print Math::BigRat->new('123/1')->digit(1);	# 1
	print Math::BigRat->new('123/1')->digit(-1);	# 3

Return the N'ths digit from X when X is an integer value.

=head2 bnorm()

	$x->bnorm();

Reduce the number to the shortest form. This routine is called
automatically whenever it is needed.

=head2 bfac()

	$x->bfac();

Calculates the factorial of $x. For instance:

	print Math::BigRat->new('3/1')->bfac(),"\n";	# 1*2*3
	print Math::BigRat->new('5/1')->bfac(),"\n";	# 1*2*3*4*5

Works currently only for integers.

=head2 bround()/round()/bfround()

Are not yet implemented.

=head2 bmod()

	use Math::BigRat;
	my $x = Math::BigRat->new('7/4');
	my $y = Math::BigRat->new('4/3');
	print $x->bmod($y);

Set $x to the remainder of the division of $x by $y.

=head2 bneg()

	$x->bneg();

Used to negate the object in-place.

=head2 is_one()

	print "$x is 1\n" if $x->is_one();

Return true if $x is exactly one, otherwise false.

=head2 is_zero()

	print "$x is 0\n" if $x->is_zero();

Return true if $x is exactly zero, otherwise false.

=head2 is_pos()/is_positive()

	print "$x is >= 0\n" if $x->is_positive();

Return true if $x is positive (greater than or equal to zero), otherwise
false. Please note that '+inf' is also positive, while 'NaN' and '-inf' aren't.

C<is_positive()> is an alias for C<is_pos()>.

=head2 is_neg()/is_negative()

	print "$x is < 0\n" if $x->is_negative();

Return true if $x is negative (smaller than zero), otherwise false. Please
note that '-inf' is also negative, while 'NaN' and '+inf' aren't.

C<is_negative()> is an alias for C<is_neg()>.

=head2 is_int()

	print "$x is an integer\n" if $x->is_int();

Return true if $x has a denominator of 1 (e.g. no fraction parts), otherwise
false. Please note that '-inf', 'inf' and 'NaN' aren't integer.

=head2 is_odd()

	print "$x is odd\n" if $x->is_odd();

Return true if $x is odd, otherwise false.

=head2 is_even()

	print "$x is even\n" if $x->is_even();

Return true if $x is even, otherwise false.

=head2 bceil()

	$x->bceil();

Set $x to the next bigger integer value (e.g. truncate the number to integer
and then increment it by one).

=head2 bfloor()

	$x->bfloor();

Truncate $x to an integer value.

=head2 bsqrt()

	$x->bsqrt();

Calculate the square root of $x.

=head2 broot()

	$x->broot($n);

Calculate the N'th root of $x.

=head2 badd()/bmul()/bsub()/bdiv()/bdec()/binc()

Please see the documentation in L<Math::BigInt>.

=head2 copy()

	my $z = $x->copy();

Makes a deep copy of the object.

Please see the documentation in L<Math::BigInt> for further details.

=head2 bstr()/bsstr()

	my $x = Math::BigInt->new('8/4');
	print $x->bstr(),"\n";			# prints 1/2
	print $x->bsstr(),"\n";			# prints 1/2

Return a string representing this object.

=head2 bacmp()/bcmp()

Used to compare numbers.

Please see the documentation in L<Math::BigInt> for further details.

=head2 blsft()/brsft()

Used to shift numbers left/right.

Please see the documentation in L<Math::BigInt> for further details.

=head2 bpow()

	$x->bpow($y);

Compute $x ** $y.

Please see the documentation in L<Math::BigInt> for further details.

=head2 bexp()

	$x->bexp($accuracy);		# calculate e ** X

Calculates two integers A and B so that A/B is equal to C<e ** $x>, where C<e> is
Euler's number.

This method was added in v0.20 of Math::BigRat (May 2007).

See also C<blog()>.

=head2 bnok()

	$x->bnok($y);		   # x over y (binomial coefficient n over k)

Calculates the binomial coefficient n over k, also called the "choose"
function. The result is equivalent to:

	( n )      n!
	| - |  = -------
	( k )    k!(n-k)!

This method was added in v0.20 of Math::BigRat (May 2007).

=head2 config()

        use Data::Dumper;

        print Dumper ( Math::BigRat->config() );
        print Math::BigRat->config()->{lib},"\n";

Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.

        key             RO/RW   Description
                                Example
        ============================================================
        lib             RO      Name of the Math library
                                Math::BigInt::Calc
        lib_version     RO      Version of 'lib'
                                0.30
        class           RO      The class of config you just called
                                Math::BigRat
        version         RO      version number of the class you used
                                0.10
        upgrade         RW      To which class numbers are upgraded
                                undef
        downgrade       RW      To which class numbers are downgraded
                                undef
        precision       RW      Global precision
                                undef
        accuracy        RW      Global accuracy
                                undef
        round_mode      RW      Global round mode
                                even
        div_scale       RW      Fallback accuracy for div
                                40
        trap_nan        RW      Trap creation of NaN (undef = no)
                                undef
        trap_inf        RW      Trap creation of +inf/-inf (undef = no)
                                undef

By passing a reference to a hash you may set the configuration values. This
works only for values that a marked with a C<RW> above, anything else is
read-only.

=head2 objectify()

This is an internal routine that turns scalars into objects.

=head1 BUGS

Some things are not yet implemented, or only implemented half-way:

=over 2

=item inf handling (partial)

=item NaN handling (partial)

=item rounding (not implemented except for bceil/bfloor)

=item $x ** $y where $y is not an integer

=item bmod(), blog(), bmodinv() and bmodpow() (partial)

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

L<Math::BigFloat> and L<Math::Big> as well as
L<Math::BigInt::Pari> and  L<Math::BigInt::GMP>.

See L<http://search.cpan.org/search?dist=bignum> for a way to use
Math::BigRat.

The package at L<http://search.cpan.org/search?dist=Math%3A%3ABigRat>
may contain more documentation and examples as well as testcases.

=head1 AUTHORS

(C) by Tels L<http://bloodgate.com/> 2001 - 2009.

Currently maintained by Jonathan "Duke" Leto <jonathan@leto.net> L<http://leto.net>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/share/perl/5.20.2/Math/Complex.pm                                                               0100644 0000000 0000000 00000140437 12744441327 015525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# Complex numbers and associated mathematical functions
# -- Raphael Manfredi	Since Sep 1996
# -- Jarkko Hietaniemi	Since Mar 1997
# -- Daniel S. Lewart	Since Sep 1997
#

package Math::Complex;

{ use 5.006; }
use strict;

our $VERSION = 1.59;

use Config;

our($Inf, $ExpInf);
BEGIN {
    my %DBL_MAX =
	(
	  4  => '1.70141183460469229e+38',
	  8  => '1.7976931348623157e+308',
	 # AFAICT the 10, 12, and 16-byte long doubles
	 # all have the same maximum.
	 10 => '1.1897314953572317650857593266280070162E+4932',
	 12 => '1.1897314953572317650857593266280070162E+4932',
	 16 => '1.1897314953572317650857593266280070162E+4932',
	);
    my $nvsize = $Config{nvsize} ||
	        ($Config{uselongdouble} && $Config{longdblsize}) ||
                 $Config{doublesize};
    die "Math::Complex: Could not figure out nvsize\n"
	unless defined $nvsize;
    die "Math::Complex: Cannot not figure out max nv (nvsize = $nvsize)\n"
	unless defined $DBL_MAX{$nvsize};
    my $DBL_MAX = eval $DBL_MAX{$nvsize};
    die "Math::Complex: Could not figure out max nv (nvsize = $nvsize)\n"
	unless defined $DBL_MAX;
    my $BIGGER_THAN_THIS = 1e30;  # Must find something bigger than this.
    if ($^O eq 'unicosmk') {
	$Inf = $DBL_MAX;
    } else {
	local $SIG{FPE} = { };
        local $!;
	# We do want an arithmetic overflow, Inf INF inf Infinity.
	for my $t (
	    'exp(99999)',  # Enough even with 128-bit long doubles.
	    'inf',
	    'Inf',
	    'INF',
	    'infinity',
	    'Infinity',
	    'INFINITY',
	    '1e99999',
	    ) {
	    local $^W = 0;
	    my $i = eval "$t+1.0";
	    if (defined $i && $i > $BIGGER_THAN_THIS) {
		$Inf = $i;
		last;
	    }
	}
	$Inf = $DBL_MAX unless defined $Inf;  # Oh well, close enough.
	die "Math::Complex: Could not get Infinity"
	    unless $Inf > $BIGGER_THAN_THIS;
	$ExpInf = exp(99999);
    }
    # print "# On this machine, Inf = '$Inf'\n";
}

use Scalar::Util qw(set_prototype);

use warnings;
no warnings 'syntax';  # To avoid the (_) warnings.

BEGIN {
    # For certain functions that we override, in 5.10 or better
    # we can set a smarter prototype that will handle the lexical $_
    # (also a 5.10+ feature).
    if ($] >= 5.010000) {
        set_prototype \&abs, '_';
        set_prototype \&cos, '_';
        set_prototype \&exp, '_';
        set_prototype \&log, '_';
        set_prototype \&sin, '_';
        set_prototype \&sqrt, '_';
    }
}

my $i;
my %LOGN;

# Regular expression for floating point numbers.
# These days we could use Scalar::Util::lln(), I guess.
my $gre = qr'\s*([\+\-]?(?:(?:(?:\d+(?:_\d+)*(?:\.\d*(?:_\d+)*)?|\.\d+(?:_\d+)*)(?:[eE][\+\-]?\d+(?:_\d+)*)?))|inf)'i;

require Exporter;

our @ISA = qw(Exporter);

my @trig = qw(
	      pi
	      tan
	      csc cosec sec cot cotan
	      asin acos atan
	      acsc acosec asec acot acotan
	      sinh cosh tanh
	      csch cosech sech coth cotanh
	      asinh acosh atanh
	      acsch acosech asech acoth acotanh
	     );

our @EXPORT = (qw(
	     i Re Im rho theta arg
	     sqrt log ln
	     log10 logn cbrt root
	     cplx cplxe
	     atan2
	     ),
	   @trig);

my @pi = qw(pi pi2 pi4 pip2 pip4 Inf);

our @EXPORT_OK = @pi;

our %EXPORT_TAGS = (
    'trig' => [@trig],
    'pi' => [@pi],
);

use overload
	'='	=> \&_copy,
	'+='	=> \&_plus,
	'+'	=> \&_plus,
	'-='	=> \&_minus,
	'-'	=> \&_minus,
	'*='	=> \&_multiply,
	'*'	=> \&_multiply,
	'/='	=> \&_divide,
	'/'	=> \&_divide,
	'**='	=> \&_power,
	'**'	=> \&_power,
	'=='	=> \&_numeq,
	'<=>'	=> \&_spaceship,
	'neg'	=> \&_negate,
	'~'	=> \&_conjugate,
	'abs'	=> \&abs,
	'sqrt'	=> \&sqrt,
	'exp'	=> \&exp,
	'log'	=> \&log,
	'sin'	=> \&sin,
	'cos'	=> \&cos,
	'atan2'	=> \&atan2,
        '""'    => \&_stringify;

#
# Package "privates"
#

my %DISPLAY_FORMAT = ('style' => 'cartesian',
		      'polar_pretty_print' => 1);
my $eps            = 1e-14;		# Epsilon

#
# Object attributes (internal):
#	cartesian	[real, imaginary] -- cartesian form
#	polar		[rho, theta] -- polar form
#	c_dirty		cartesian form not up-to-date
#	p_dirty		polar form not up-to-date
#	display		display format (package's global when not set)
#

# Die on bad *make() arguments.

sub _cannot_make {
    die "@{[(caller(1))[3]]}: Cannot take $_[0] of '$_[1]'.\n";
}

sub _make {
    my $arg = shift;
    my ($p, $q);

    if ($arg =~ /^$gre$/) {
	($p, $q) = ($1, 0);
    } elsif ($arg =~ /^(?:$gre)?$gre\s*i\s*$/) {
	($p, $q) = ($1 || 0, $2);
    } elsif ($arg =~ /^\s*\(\s*$gre\s*(?:,\s*$gre\s*)?\)\s*$/) {
	($p, $q) = ($1, $2 || 0);
    }

    if (defined $p) {
	$p =~ s/^\+//;
	$p =~ s/^(-?)inf$/"${1}9**9**9"/e;
	$q =~ s/^\+//;
	$q =~ s/^(-?)inf$/"${1}9**9**9"/e;
    }

    return ($p, $q);
}

sub _emake {
    my $arg = shift;
    my ($p, $q);

    if ($arg =~ /^\s*\[\s*$gre\s*(?:,\s*$gre\s*)?\]\s*$/) {
	($p, $q) = ($1, $2 || 0);
    } elsif ($arg =~ m!^\s*\[\s*$gre\s*(?:,\s*([-+]?\d*\s*)?pi(?:/\s*(\d+))?\s*)?\]\s*$!) {
	($p, $q) = ($1, ($2 eq '-' ? -1 : ($2 || 1)) * pi() / ($3 || 1));
    } elsif ($arg =~ /^\s*\[\s*$gre\s*\]\s*$/) {
	($p, $q) = ($1, 0);
    } elsif ($arg =~ /^\s*$gre\s*$/) {
	($p, $q) = ($1, 0);
    }

    if (defined $p) {
	$p =~ s/^\+//;
	$q =~ s/^\+//;
	$p =~ s/^(-?)inf$/"${1}9**9**9"/e;
	$q =~ s/^(-?)inf$/"${1}9**9**9"/e;
    }

    return ($p, $q);
}

sub _copy {
    my $self = shift;
    my $clone = {%$self};
    if ($self->{'cartesian'}) {
	$clone->{'cartesian'} = [@{$self->{'cartesian'}}];
    }
    if ($self->{'polar'}) {
	$clone->{'polar'} = [@{$self->{'polar'}}];
    }
    bless $clone,__PACKAGE__;
    return $clone;
}

#
# ->make
#
# Create a new complex number (cartesian form)
#
sub make {
    my $self = bless {}, shift;
    my ($re, $im);
    if (@_ == 0) {
	($re, $im) = (0, 0);
    } elsif (@_ == 1) {
	return (ref $self)->emake($_[0])
	    if ($_[0] =~ /^\s*\[/);
	($re, $im) = _make($_[0]);
    } elsif (@_ == 2) {
	($re, $im) = @_;
    }
    if (defined $re) {
	_cannot_make("real part",      $re) unless $re =~ /^$gre$/;
    }
    $im ||= 0;
    _cannot_make("imaginary part", $im) unless $im =~ /^$gre$/;
    $self->_set_cartesian([$re, $im ]);
    $self->display_format('cartesian');

    return $self;
}

#
# ->emake
#
# Create a new complex number (exponential form)
#
sub emake {
    my $self = bless {}, shift;
    my ($rho, $theta);
    if (@_ == 0) {
	($rho, $theta) = (0, 0);
    } elsif (@_ == 1) {
	return (ref $self)->make($_[0])
	    if ($_[0] =~ /^\s*\(/ || $_[0] =~ /i\s*$/);
	($rho, $theta) = _emake($_[0]);
    } elsif (@_ == 2) {
	($rho, $theta) = @_;
    }
    if (defined $rho && defined $theta) {
	if ($rho < 0) {
	    $rho   = -$rho;
	    $theta = ($theta <= 0) ? $theta + pi() : $theta - pi();
	}
    }
    if (defined $rho) {
	_cannot_make("rho",   $rho)   unless $rho   =~ /^$gre$/;
    }
    $theta ||= 0;
    _cannot_make("theta", $theta) unless $theta =~ /^$gre$/;
    $self->_set_polar([$rho, $theta]);
    $self->display_format('polar');

    return $self;
}

sub new { &make }		# For backward compatibility only.

#
# cplx
#
# Creates a complex number from a (re, im) tuple.
# This avoids the burden of writing Math::Complex->make(re, im).
#
sub cplx {
	return __PACKAGE__->make(@_);
}

#
# cplxe
#
# Creates a complex number from a (rho, theta) tuple.
# This avoids the burden of writing Math::Complex->emake(rho, theta).
#
sub cplxe {
	return __PACKAGE__->emake(@_);
}

#
# pi
#
# The number defined as pi = 180 degrees
#
sub pi () { 4 * CORE::atan2(1, 1) }

#
# pi2
#
# The full circle
#
sub pi2 () { 2 * pi }

#
# pi4
#
# The full circle twice.
#
sub pi4 () { 4 * pi }

#
# pip2
#
# The quarter circle
#
sub pip2 () { pi / 2 }

#
# pip4
#
# The eighth circle.
#
sub pip4 () { pi / 4 }

#
# _uplog10
#
# Used in log10().
#
sub _uplog10 () { 1 / CORE::log(10) }

#
# i
#
# The number defined as i*i = -1;
#
sub i () {
        return $i if ($i);
	$i = bless {};
	$i->{'cartesian'} = [0, 1];
	$i->{'polar'}     = [1, pip2];
	$i->{c_dirty} = 0;
	$i->{p_dirty} = 0;
	return $i;
}

#
# _ip2
#
# Half of i.
#
sub _ip2 () { i / 2 }

#
# Attribute access/set routines
#

sub _cartesian {$_[0]->{c_dirty} ?
		   $_[0]->_update_cartesian : $_[0]->{'cartesian'}}
sub _polar     {$_[0]->{p_dirty} ?
		   $_[0]->_update_polar : $_[0]->{'polar'}}

sub _set_cartesian { $_[0]->{p_dirty}++; $_[0]->{c_dirty} = 0;
		     $_[0]->{'cartesian'} = $_[1] }
sub _set_polar     { $_[0]->{c_dirty}++; $_[0]->{p_dirty} = 0;
		     $_[0]->{'polar'} = $_[1] }

#
# ->_update_cartesian
#
# Recompute and return the cartesian form, given accurate polar form.
#
sub _update_cartesian {
	my $self = shift;
	my ($r, $t) = @{$self->{'polar'}};
	$self->{c_dirty} = 0;
	return $self->{'cartesian'} = [$r * CORE::cos($t), $r * CORE::sin($t)];
}

#
#
# ->_update_polar
#
# Recompute and return the polar form, given accurate cartesian form.
#
sub _update_polar {
	my $self = shift;
	my ($x, $y) = @{$self->{'cartesian'}};
	$self->{p_dirty} = 0;
	return $self->{'polar'} = [0, 0] if $x == 0 && $y == 0;
	return $self->{'polar'} = [CORE::sqrt($x*$x + $y*$y),
				   CORE::atan2($y, $x)];
}

#
# (_plus)
#
# Computes z1+z2.
#
sub _plus {
	my ($z1, $z2, $regular) = @_;
	my ($re1, $im1) = @{$z1->_cartesian};
	$z2 = cplx($z2) unless ref $z2;
	my ($re2, $im2) = ref $z2 ? @{$z2->_cartesian} : ($z2, 0);
	unless (defined $regular) {
		$z1->_set_cartesian([$re1 + $re2, $im1 + $im2]);
		return $z1;
	}
	return (ref $z1)->make($re1 + $re2, $im1 + $im2);
}

#
# (_minus)
#
# Computes z1-z2.
#
sub _minus {
	my ($z1, $z2, $inverted) = @_;
	my ($re1, $im1) = @{$z1->_cartesian};
	$z2 = cplx($z2) unless ref $z2;
	my ($re2, $im2) = @{$z2->_cartesian};
	unless (defined $inverted) {
		$z1->_set_cartesian([$re1 - $re2, $im1 - $im2]);
		return $z1;
	}
	return $inverted ?
		(ref $z1)->make($re2 - $re1, $im2 - $im1) :
		(ref $z1)->make($re1 - $re2, $im1 - $im2);

}

#
# (_multiply)
#
# Computes z1*z2.
#
sub _multiply {
        my ($z1, $z2, $regular) = @_;
	if ($z1->{p_dirty} == 0 and ref $z2 and $z2->{p_dirty} == 0) {
	    # if both polar better use polar to avoid rounding errors
	    my ($r1, $t1) = @{$z1->_polar};
	    my ($r2, $t2) = @{$z2->_polar};
	    my $t = $t1 + $t2;
	    if    ($t >   pi()) { $t -= pi2 }
	    elsif ($t <= -pi()) { $t += pi2 }
	    unless (defined $regular) {
		$z1->_set_polar([$r1 * $r2, $t]);
		return $z1;
	    }
	    return (ref $z1)->emake($r1 * $r2, $t);
	} else {
	    my ($x1, $y1) = @{$z1->_cartesian};
	    if (ref $z2) {
		my ($x2, $y2) = @{$z2->_cartesian};
		return (ref $z1)->make($x1*$x2-$y1*$y2, $x1*$y2+$y1*$x2);
	    } else {
		return (ref $z1)->make($x1*$z2, $y1*$z2);
	    }
	}
}

#
# _divbyzero
#
# Die on division by zero.
#
sub _divbyzero {
    my $mess = "$_[0]: Division by zero.\n";

    if (defined $_[1]) {
	$mess .= "(Because in the definition of $_[0], the divisor ";
	$mess .= "$_[1] " unless ("$_[1]" eq '0');
	$mess .= "is 0)\n";
    }

    my @up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# (_divide)
#
# Computes z1/z2.
#
sub _divide {
	my ($z1, $z2, $inverted) = @_;
	if ($z1->{p_dirty} == 0 and ref $z2 and $z2->{p_dirty} == 0) {
	    # if both polar better use polar to avoid rounding errors
	    my ($r1, $t1) = @{$z1->_polar};
	    my ($r2, $t2) = @{$z2->_polar};
	    my $t;
	    if ($inverted) {
		_divbyzero "$z2/0" if ($r1 == 0);
		$t = $t2 - $t1;
		if    ($t >   pi()) { $t -= pi2 }
		elsif ($t <= -pi()) { $t += pi2 }
		return (ref $z1)->emake($r2 / $r1, $t);
	    } else {
		_divbyzero "$z1/0" if ($r2 == 0);
		$t = $t1 - $t2;
		if    ($t >   pi()) { $t -= pi2 }
		elsif ($t <= -pi()) { $t += pi2 }
		return (ref $z1)->emake($r1 / $r2, $t);
	    }
	} else {
	    my ($d, $x2, $y2);
	    if ($inverted) {
		($x2, $y2) = @{$z1->_cartesian};
		$d = $x2*$x2 + $y2*$y2;
		_divbyzero "$z2/0" if $d == 0;
		return (ref $z1)->make(($x2*$z2)/$d, -($y2*$z2)/$d);
	    } else {
		my ($x1, $y1) = @{$z1->_cartesian};
		if (ref $z2) {
		    ($x2, $y2) = @{$z2->_cartesian};
		    $d = $x2*$x2 + $y2*$y2;
		    _divbyzero "$z1/0" if $d == 0;
		    my $u = ($x1*$x2 + $y1*$y2)/$d;
		    my $v = ($y1*$x2 - $x1*$y2)/$d;
		    return (ref $z1)->make($u, $v);
		} else {
		    _divbyzero "$z1/0" if $z2 == 0;
		    return (ref $z1)->make($x1/$z2, $y1/$z2);
		}
	    }
	}
}

#
# (_power)
#
# Computes z1**z2 = exp(z2 * log z1)).
#
sub _power {
	my ($z1, $z2, $inverted) = @_;
	if ($inverted) {
	    return 1 if $z1 == 0 || $z2 == 1;
	    return 0 if $z2 == 0 && Re($z1) > 0;
	} else {
	    return 1 if $z2 == 0 || $z1 == 1;
	    return 0 if $z1 == 0 && Re($z2) > 0;
	}
	my $w = $inverted ? &exp($z1 * &log($z2))
	                  : &exp($z2 * &log($z1));
	# If both arguments cartesian, return cartesian, else polar.
	return $z1->{c_dirty} == 0 &&
	       (not ref $z2 or $z2->{c_dirty} == 0) ?
	       cplx(@{$w->_cartesian}) : $w;
}

#
# (_spaceship)
#
# Computes z1 <=> z2.
# Sorts on the real part first, then on the imaginary part. Thus 2-4i < 3+8i.
#
sub _spaceship {
	my ($z1, $z2, $inverted) = @_;
	my ($re1, $im1) = ref $z1 ? @{$z1->_cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @{$z2->_cartesian} : ($z2, 0);
	my $sgn = $inverted ? -1 : 1;
	return $sgn * ($re1 <=> $re2) if $re1 != $re2;
	return $sgn * ($im1 <=> $im2);
}

#
# (_numeq)
#
# Computes z1 == z2.
#
# (Required in addition to _spaceship() because of NaNs.)
sub _numeq {
	my ($z1, $z2, $inverted) = @_;
	my ($re1, $im1) = ref $z1 ? @{$z1->_cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @{$z2->_cartesian} : ($z2, 0);
	return $re1 == $re2 && $im1 == $im2 ? 1 : 0;
}

#
# (_negate)
#
# Computes -z.
#
sub _negate {
	my ($z) = @_;
	if ($z->{c_dirty}) {
		my ($r, $t) = @{$z->_polar};
		$t = ($t <= 0) ? $t + pi : $t - pi;
		return (ref $z)->emake($r, $t);
	}
	my ($re, $im) = @{$z->_cartesian};
	return (ref $z)->make(-$re, -$im);
}

#
# (_conjugate)
#
# Compute complex's _conjugate.
#
sub _conjugate {
	my ($z) = @_;
	if ($z->{c_dirty}) {
		my ($r, $t) = @{$z->_polar};
		return (ref $z)->emake($r, -$t);
	}
	my ($re, $im) = @{$z->_cartesian};
	return (ref $z)->make($re, -$im);
}

#
# (abs)
#
# Compute or set complex's norm (rho).
#
sub abs {
	my ($z, $rho) = @_ ? @_ : $_;
	unless (ref $z) {
	    if (@_ == 2) {
		$_[0] = $_[1];
	    } else {
		return CORE::abs($z);
	    }
	}
	if (defined $rho) {
	    $z->{'polar'} = [ $rho, ${$z->_polar}[1] ];
	    $z->{p_dirty} = 0;
	    $z->{c_dirty} = 1;
	    return $rho;
	} else {
	    return ${$z->_polar}[0];
	}
}

sub _theta {
    my $theta = $_[0];

    if    ($$theta >   pi()) { $$theta -= pi2 }
    elsif ($$theta <= -pi()) { $$theta += pi2 }
}

#
# arg
#
# Compute or set complex's argument (theta).
#
sub arg {
	my ($z, $theta) = @_;
	return $z unless ref $z;
	if (defined $theta) {
	    _theta(\$theta);
	    $z->{'polar'} = [ ${$z->_polar}[0], $theta ];
	    $z->{p_dirty} = 0;
	    $z->{c_dirty} = 1;
	} else {
	    $theta = ${$z->_polar}[1];
	    _theta(\$theta);
	}
	return $theta;
}

#
# (sqrt)
#
# Compute sqrt(z).
#
# It is quite tempting to use wantarray here so that in list context
# sqrt() would return the two solutions.  This, however, would
# break things like
#
#	print "sqrt(z) = ", sqrt($z), "\n";
#
# The two values would be printed side by side without no intervening
# whitespace, quite confusing.
# Therefore if you want the two solutions use the root().
#
sub sqrt {
	my ($z) = @_ ? $_[0] : $_;
	my ($re, $im) = ref $z ? @{$z->_cartesian} : ($z, 0);
	return $re < 0 ? cplx(0, CORE::sqrt(-$re)) : CORE::sqrt($re)
	    if $im == 0;
	my ($r, $t) = @{$z->_polar};
	return (ref $z)->emake(CORE::sqrt($r), $t/2);
}

#
# cbrt
#
# Compute cbrt(z) (cubic root).
#
# Why are we not returning three values?  The same answer as for sqrt().
#
sub cbrt {
	my ($z) = @_;
	return $z < 0 ?
	    -CORE::exp(CORE::log(-$z)/3) :
		($z > 0 ? CORE::exp(CORE::log($z)/3): 0)
	    unless ref $z;
	my ($r, $t) = @{$z->_polar};
	return 0 if $r == 0;
	return (ref $z)->emake(CORE::exp(CORE::log($r)/3), $t/3);
}

#
# _rootbad
#
# Die on bad root.
#
sub _rootbad {
    my $mess = "Root '$_[0]' illegal, root rank must be positive integer.\n";

    my @up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# root
#
# Computes all nth root for z, returning an array whose size is n.
# `n' must be a positive integer.
#
# The roots are given by (for k = 0..n-1):
#
# z^(1/n) = r^(1/n) (cos ((t+2 k pi)/n) + i sin ((t+2 k pi)/n))
#
sub root {
	my ($z, $n, $k) = @_;
	_rootbad($n) if ($n < 1 or int($n) != $n);
	my ($r, $t) = ref $z ?
	    @{$z->_polar} : (CORE::abs($z), $z >= 0 ? 0 : pi);
	my $theta_inc = pi2 / $n;
	my $rho = $r ** (1/$n);
	my $cartesian = ref $z && $z->{c_dirty} == 0;
	if (@_ == 2) {
	    my @root;
	    for (my $i = 0, my $theta = $t / $n;
		 $i < $n;
		 $i++, $theta += $theta_inc) {
		my $w = cplxe($rho, $theta);
		# Yes, $cartesian is loop invariant.
		push @root, $cartesian ? cplx(@{$w->_cartesian}) : $w;
	    }
	    return @root;
	} elsif (@_ == 3) {
	    my $w = cplxe($rho, $t / $n + $k * $theta_inc);
	    return $cartesian ? cplx(@{$w->_cartesian}) : $w;
	}
}

#
# Re
#
# Return or set Re(z).
#
sub Re {
	my ($z, $Re) = @_;
	return $z unless ref $z;
	if (defined $Re) {
	    $z->{'cartesian'} = [ $Re, ${$z->_cartesian}[1] ];
	    $z->{c_dirty} = 0;
	    $z->{p_dirty} = 1;
	} else {
	    return ${$z->_cartesian}[0];
	}
}

#
# Im
#
# Return or set Im(z).
#
sub Im {
	my ($z, $Im) = @_;
	return 0 unless ref $z;
	if (defined $Im) {
	    $z->{'cartesian'} = [ ${$z->_cartesian}[0], $Im ];
	    $z->{c_dirty} = 0;
	    $z->{p_dirty} = 1;
	} else {
	    return ${$z->_cartesian}[1];
	}
}

#
# rho
#
# Return or set rho(w).
#
sub rho {
    Math::Complex::abs(@_);
}

#
# theta
#
# Return or set theta(w).
#
sub theta {
    Math::Complex::arg(@_);
}

#
# (exp)
#
# Computes exp(z).
#
sub exp {
    my ($z) = @_ ? @_ : $_;
    return CORE::exp($z) unless ref $z;
    my ($x, $y) = @{$z->_cartesian};
    return (ref $z)->emake(CORE::exp($x), $y);
}

#
# _logofzero
#
# Die on logarithm of zero.
#
sub _logofzero {
    my $mess = "$_[0]: Logarithm of zero.\n";

    if (defined $_[1]) {
	$mess .= "(Because in the definition of $_[0], the argument ";
	$mess .= "$_[1] " unless ($_[1] eq '0');
	$mess .= "is 0)\n";
    }

    my @up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# (log)
#
# Compute log(z).
#
sub log {
	my ($z) = @_ ? @_ : $_;
	unless (ref $z) {
	    _logofzero("log") if $z == 0;
	    return $z > 0 ? CORE::log($z) : cplx(CORE::log(-$z), pi);
	}
	my ($r, $t) = @{$z->_polar};
	_logofzero("log") if $r == 0;
	if    ($t >   pi()) { $t -= pi2 }
	elsif ($t <= -pi()) { $t += pi2 }
	return (ref $z)->make(CORE::log($r), $t);
}

#
# ln
#
# Alias for log().
#
sub ln { Math::Complex::log(@_) }

#
# log10
#
# Compute log10(z).
#

sub log10 {
	return Math::Complex::log($_[0]) * _uplog10;
}

#
# logn
#
# Compute logn(z,n) = log(z) / log(n)
#
sub logn {
	my ($z, $n) = @_;
	$z = cplx($z, 0) unless ref $z;
	my $logn = $LOGN{$n};
	$logn = $LOGN{$n} = CORE::log($n) unless defined $logn;	# Cache log(n)
	return &log($z) / $logn;
}

#
# (cos)
#
# Compute cos(z) = (exp(iz) + exp(-iz))/2.
#
sub cos {
	my ($z) = @_ ? @_ : $_;
	return CORE::cos($z) unless ref $z;
	my ($x, $y) = @{$z->_cartesian};
	my $ey = CORE::exp($y);
	my $sx = CORE::sin($x);
	my $cx = CORE::cos($x);
	my $ey_1 = $ey ? 1 / $ey : Inf();
	return (ref $z)->make($cx * ($ey + $ey_1)/2,
			      $sx * ($ey_1 - $ey)/2);
}

#
# (sin)
#
# Compute sin(z) = (exp(iz) - exp(-iz))/2.
#
sub sin {
	my ($z) = @_ ? @_ : $_;
	return CORE::sin($z) unless ref $z;
	my ($x, $y) = @{$z->_cartesian};
	my $ey = CORE::exp($y);
	my $sx = CORE::sin($x);
	my $cx = CORE::cos($x);
	my $ey_1 = $ey ? 1 / $ey : Inf();
	return (ref $z)->make($sx * ($ey + $ey_1)/2,
			      $cx * ($ey - $ey_1)/2);
}

#
# tan
#
# Compute tan(z) = sin(z) / cos(z).
#
sub tan {
	my ($z) = @_;
	my $cz = &cos($z);
	_divbyzero "tan($z)", "cos($z)" if $cz == 0;
	return &sin($z) / $cz;
}

#
# sec
#
# Computes the secant sec(z) = 1 / cos(z).
#
sub sec {
	my ($z) = @_;
	my $cz = &cos($z);
	_divbyzero "sec($z)", "cos($z)" if ($cz == 0);
	return 1 / $cz;
}

#
# csc
#
# Computes the cosecant csc(z) = 1 / sin(z).
#
sub csc {
	my ($z) = @_;
	my $sz = &sin($z);
	_divbyzero "csc($z)", "sin($z)" if ($sz == 0);
	return 1 / $sz;
}

#
# cosec
#
# Alias for csc().
#
sub cosec { Math::Complex::csc(@_) }

#
# cot
#
# Computes cot(z) = cos(z) / sin(z).
#
sub cot {
	my ($z) = @_;
	my $sz = &sin($z);
	_divbyzero "cot($z)", "sin($z)" if ($sz == 0);
	return &cos($z) / $sz;
}

#
# cotan
#
# Alias for cot().
#
sub cotan { Math::Complex::cot(@_) }

#
# acos
#
# Computes the arc cosine acos(z) = -i log(z + sqrt(z*z-1)).
#
sub acos {
	my $z = $_[0];
	return CORE::atan2(CORE::sqrt(1-$z*$z), $z)
	    if (! ref $z) && CORE::abs($z) <= 1;
	$z = cplx($z, 0) unless ref $z;
	my ($x, $y) = @{$z->_cartesian};
	return 0 if $x == 1 && $y == 0;
	my $t1 = CORE::sqrt(($x+1)*($x+1) + $y*$y);
	my $t2 = CORE::sqrt(($x-1)*($x-1) + $y*$y);
	my $alpha = ($t1 + $t2)/2;
	my $beta  = ($t1 - $t2)/2;
	$alpha = 1 if $alpha < 1;
	if    ($beta >  1) { $beta =  1 }
	elsif ($beta < -1) { $beta = -1 }
	my $u = CORE::atan2(CORE::sqrt(1-$beta*$beta), $beta);
	my $v = CORE::log($alpha + CORE::sqrt($alpha*$alpha-1));
	$v = -$v if $y > 0 || ($y == 0 && $x < -1);
	return (ref $z)->make($u, $v);
}

#
# asin
#
# Computes the arc sine asin(z) = -i log(iz + sqrt(1-z*z)).
#
sub asin {
	my $z = $_[0];
	return CORE::atan2($z, CORE::sqrt(1-$z*$z))
	    if (! ref $z) && CORE::abs($z) <= 1;
	$z = cplx($z, 0) unless ref $z;
	my ($x, $y) = @{$z->_cartesian};
	return 0 if $x == 0 && $y == 0;
	my $t1 = CORE::sqrt(($x+1)*($x+1) + $y*$y);
	my $t2 = CORE::sqrt(($x-1)*($x-1) + $y*$y);
	my $alpha = ($t1 + $t2)/2;
	my $beta  = ($t1 - $t2)/2;
	$alpha = 1 if $alpha < 1;
	if    ($beta >  1) { $beta =  1 }
	elsif ($beta < -1) { $beta = -1 }
	my $u =  CORE::atan2($beta, CORE::sqrt(1-$beta*$beta));
	my $v = -CORE::log($alpha + CORE::sqrt($alpha*$alpha-1));
	$v = -$v if $y > 0 || ($y == 0 && $x < -1);
	return (ref $z)->make($u, $v);
}

#
# atan
#
# Computes the arc tangent atan(z) = i/2 log((i+z) / (i-z)).
#
sub atan {
	my ($z) = @_;
	return CORE::atan2($z, 1) unless ref $z;
	my ($x, $y) = ref $z ? @{$z->_cartesian} : ($z, 0);
	return 0 if $x == 0 && $y == 0;
	_divbyzero "atan(i)"  if ( $z == i);
	_logofzero "atan(-i)" if (-$z == i); # -i is a bad file test...
	my $log = &log((i + $z) / (i - $z));
	return _ip2 * $log;
}

#
# asec
#
# Computes the arc secant asec(z) = acos(1 / z).
#
sub asec {
	my ($z) = @_;
	_divbyzero "asec($z)", $z if ($z == 0);
	return acos(1 / $z);
}

#
# acsc
#
# Computes the arc cosecant acsc(z) = asin(1 / z).
#
sub acsc {
	my ($z) = @_;
	_divbyzero "acsc($z)", $z if ($z == 0);
	return asin(1 / $z);
}

#
# acosec
#
# Alias for acsc().
#
sub acosec { Math::Complex::acsc(@_) }

#
# acot
#
# Computes the arc cotangent acot(z) = atan(1 / z)
#
sub acot {
	my ($z) = @_;
	_divbyzero "acot(0)"  if $z == 0;
	return ($z >= 0) ? CORE::atan2(1, $z) : CORE::atan2(-1, -$z)
	    unless ref $z;
	_divbyzero "acot(i)"  if ($z - i == 0);
	_logofzero "acot(-i)" if ($z + i == 0);
	return atan(1 / $z);
}

#
# acotan
#
# Alias for acot().
#
sub acotan { Math::Complex::acot(@_) }

#
# cosh
#
# Computes the hyperbolic cosine cosh(z) = (exp(z) + exp(-z))/2.
#
sub cosh {
	my ($z) = @_;
	my $ex;
	unless (ref $z) {
	    $ex = CORE::exp($z);
            return $ex ? ($ex == $ExpInf ? Inf() : ($ex + 1/$ex)/2) : Inf();
	}
	my ($x, $y) = @{$z->_cartesian};
	$ex = CORE::exp($x);
	my $ex_1 = $ex ? 1 / $ex : Inf();
	return (ref $z)->make(CORE::cos($y) * ($ex + $ex_1)/2,
			      CORE::sin($y) * ($ex - $ex_1)/2);
}

#
# sinh
#
# Computes the hyperbolic sine sinh(z) = (exp(z) - exp(-z))/2.
#
sub sinh {
	my ($z) = @_;
	my $ex;
	unless (ref $z) {
	    return 0 if $z == 0;
	    $ex = CORE::exp($z);
            return $ex ? ($ex == $ExpInf ? Inf() : ($ex - 1/$ex)/2) : -Inf();
	}
	my ($x, $y) = @{$z->_cartesian};
	my $cy = CORE::cos($y);
	my $sy = CORE::sin($y);
	$ex = CORE::exp($x);
	my $ex_1 = $ex ? 1 / $ex : Inf();
	return (ref $z)->make(CORE::cos($y) * ($ex - $ex_1)/2,
			      CORE::sin($y) * ($ex + $ex_1)/2);
}

#
# tanh
#
# Computes the hyperbolic tangent tanh(z) = sinh(z) / cosh(z).
#
sub tanh {
	my ($z) = @_;
	my $cz = cosh($z);
	_divbyzero "tanh($z)", "cosh($z)" if ($cz == 0);
	my $sz = sinh($z);
	return  1 if $cz ==  $sz;
	return -1 if $cz == -$sz;
	return $sz / $cz;
}

#
# sech
#
# Computes the hyperbolic secant sech(z) = 1 / cosh(z).
#
sub sech {
	my ($z) = @_;
	my $cz = cosh($z);
	_divbyzero "sech($z)", "cosh($z)" if ($cz == 0);
	return 1 / $cz;
}

#
# csch
#
# Computes the hyperbolic cosecant csch(z) = 1 / sinh(z).
#
sub csch {
	my ($z) = @_;
	my $sz = sinh($z);
	_divbyzero "csch($z)", "sinh($z)" if ($sz == 0);
	return 1 / $sz;
}

#
# cosech
#
# Alias for csch().
#
sub cosech { Math::Complex::csch(@_) }

#
# coth
#
# Computes the hyperbolic cotangent coth(z) = cosh(z) / sinh(z).
#
sub coth {
	my ($z) = @_;
	my $sz = sinh($z);
	_divbyzero "coth($z)", "sinh($z)" if $sz == 0;
	my $cz = cosh($z);
	return  1 if $cz ==  $sz;
	return -1 if $cz == -$sz;
	return $cz / $sz;
}

#
# cotanh
#
# Alias for coth().
#
sub cotanh { Math::Complex::coth(@_) }

#
# acosh
#
# Computes the area/inverse hyperbolic cosine acosh(z) = log(z + sqrt(z*z-1)).
#
sub acosh {
	my ($z) = @_;
	unless (ref $z) {
	    $z = cplx($z, 0);
	}
	my ($re, $im) = @{$z->_cartesian};
	if ($im == 0) {
	    return CORE::log($re + CORE::sqrt($re*$re - 1))
		if $re >= 1;
	    return cplx(0, CORE::atan2(CORE::sqrt(1 - $re*$re), $re))
		if CORE::abs($re) < 1;
	}
	my $t = &sqrt($z * $z - 1) + $z;
	# Try Taylor if looking bad (this usually means that
	# $z was large negative, therefore the sqrt is really
	# close to abs(z), summing that with z...)
	$t = 1/(2 * $z) - 1/(8 * $z**3) + 1/(16 * $z**5) - 5/(128 * $z**7)
	    if $t == 0;
	my $u = &log($t);
	$u->Im(-$u->Im) if $re < 0 && $im == 0;
	return $re < 0 ? -$u : $u;
}

#
# asinh
#
# Computes the area/inverse hyperbolic sine asinh(z) = log(z + sqrt(z*z+1))
#
sub asinh {
	my ($z) = @_;
	unless (ref $z) {
	    my $t = $z + CORE::sqrt($z*$z + 1);
	    return CORE::log($t) if $t;
	}
	my $t = &sqrt($z * $z + 1) + $z;
	# Try Taylor if looking bad (this usually means that
	# $z was large negative, therefore the sqrt is really
	# close to abs(z), summing that with z...)
	$t = 1/(2 * $z) - 1/(8 * $z**3) + 1/(16 * $z**5) - 5/(128 * $z**7)
	    if $t == 0;
	return &log($t);
}

#
# atanh
#
# Computes the area/inverse hyperbolic tangent atanh(z) = 1/2 log((1+z) / (1-z)).
#
sub atanh {
	my ($z) = @_;
	unless (ref $z) {
	    return CORE::log((1 + $z)/(1 - $z))/2 if CORE::abs($z) < 1;
	    $z = cplx($z, 0);
	}
	_divbyzero 'atanh(1)',  "1 - $z" if (1 - $z == 0);
	_logofzero 'atanh(-1)'           if (1 + $z == 0);
	return 0.5 * &log((1 + $z) / (1 - $z));
}

#
# asech
#
# Computes the area/inverse hyperbolic secant asech(z) = acosh(1 / z).
#
sub asech {
	my ($z) = @_;
	_divbyzero 'asech(0)', "$z" if ($z == 0);
	return acosh(1 / $z);
}

#
# acsch
#
# Computes the area/inverse hyperbolic cosecant acsch(z) = asinh(1 / z).
#
sub acsch {
	my ($z) = @_;
	_divbyzero 'acsch(0)', $z if ($z == 0);
	return asinh(1 / $z);
}

#
# acosech
#
# Alias for acosh().
#
sub acosech { Math::Complex::acsch(@_) }

#
# acoth
#
# Computes the area/inverse hyperbolic cotangent acoth(z) = 1/2 log((1+z) / (z-1)).
#
sub acoth {
	my ($z) = @_;
	_divbyzero 'acoth(0)'            if ($z == 0);
	unless (ref $z) {
	    return CORE::log(($z + 1)/($z - 1))/2 if CORE::abs($z) > 1;
	    $z = cplx($z, 0);
	}
	_divbyzero 'acoth(1)',  "$z - 1" if ($z - 1 == 0);
	_logofzero 'acoth(-1)', "1 + $z" if (1 + $z == 0);
	return &log((1 + $z) / ($z - 1)) / 2;
}

#
# acotanh
#
# Alias for acot().
#
sub acotanh { Math::Complex::acoth(@_) }

#
# (atan2)
#
# Compute atan(z1/z2), minding the right quadrant.
#
sub atan2 {
	my ($z1, $z2, $inverted) = @_;
	my ($re1, $im1, $re2, $im2);
	if ($inverted) {
	    ($re1, $im1) = ref $z2 ? @{$z2->_cartesian} : ($z2, 0);
	    ($re2, $im2) = ref $z1 ? @{$z1->_cartesian} : ($z1, 0);
	} else {
	    ($re1, $im1) = ref $z1 ? @{$z1->_cartesian} : ($z1, 0);
	    ($re2, $im2) = ref $z2 ? @{$z2->_cartesian} : ($z2, 0);
	}
	if ($im1 || $im2) {
	    # In MATLAB the imaginary parts are ignored.
	    # warn "atan2: Imaginary parts ignored";
	    # http://documents.wolfram.com/mathematica/functions/ArcTan
	    # NOTE: Mathematica ArcTan[x,y] while atan2(y,x)
	    my $s = $z1 * $z1 + $z2 * $z2;
	    _divbyzero("atan2") if $s == 0;
	    my $i = &i;
	    my $r = $z2 + $z1 * $i;
	    return -$i * &log($r / &sqrt( $s ));
	}
	return CORE::atan2($re1, $re2);
}

#
# display_format
# ->display_format
#
# Set (get if no argument) the display format for all complex numbers that
# don't happen to have overridden it via ->display_format
#
# When called as an object method, this actually sets the display format for
# the current object.
#
# Valid object formats are 'c' and 'p' for cartesian and polar. The first
# letter is used actually, so the type can be fully spelled out for clarity.
#
sub display_format {
	my $self  = shift;
	my %display_format = %DISPLAY_FORMAT;

	if (ref $self) {			# Called as an object method
	    if (exists $self->{display_format}) {
		my %obj = %{$self->{display_format}};
		@display_format{keys %obj} = values %obj;
	    }
	}
	if (@_ == 1) {
	    $display_format{style} = shift;
	} else {
	    my %new = @_;
	    @display_format{keys %new} = values %new;
	}

	if (ref $self) { # Called as an object method
	    $self->{display_format} = { %display_format };
	    return
		wantarray ?
		    %{$self->{display_format}} :
		    $self->{display_format}->{style};
	}

        # Called as a class method
	%DISPLAY_FORMAT = %display_format;
	return
	    wantarray ?
		%DISPLAY_FORMAT :
		    $DISPLAY_FORMAT{style};
}

#
# (_stringify)
#
# Show nicely formatted complex number under its cartesian or polar form,
# depending on the current display format:
#
# . If a specific display format has been recorded for this object, use it.
# . Otherwise, use the generic current default for all complex numbers,
#   which is a package global variable.
#
sub _stringify {
	my ($z) = shift;

	my $style = $z->display_format;

	$style = $DISPLAY_FORMAT{style} unless defined $style;

	return $z->_stringify_polar if $style =~ /^p/i;
	return $z->_stringify_cartesian;
}

#
# ->_stringify_cartesian
#
# Stringify as a cartesian representation 'a+bi'.
#
sub _stringify_cartesian {
	my $z  = shift;
	my ($x, $y) = @{$z->_cartesian};
	my ($re, $im);

	my %format = $z->display_format;
	my $format = $format{format};

	if ($x) {
	    if ($x =~ /^NaN[QS]?$/i) {
		$re = $x;
	    } else {
		if ($x =~ /^-?\Q$Inf\E$/oi) {
		    $re = $x;
		} else {
		    $re = defined $format ? sprintf($format, $x) : $x;
		}
	    }
	} else {
	    undef $re;
	}

	if ($y) {
	    if ($y =~ /^(NaN[QS]?)$/i) {
		$im = $y;
	    } else {
		if ($y =~ /^-?\Q$Inf\E$/oi) {
		    $im = $y;
		} else {
		    $im =
			defined $format ?
			    sprintf($format, $y) :
			    ($y == 1 ? "" : ($y == -1 ? "-" : $y));
		}
	    }
	    $im .= "i";
	} else {
	    undef $im;
	}

	my $str = $re;

	if (defined $im) {
	    if ($y < 0) {
		$str .= $im;
	    } elsif ($y > 0 || $im =~ /^NaN[QS]?i$/i)  {
		$str .= "+" if defined $re;
		$str .= $im;
	    }
	} elsif (!defined $re) {
	    $str = "0";
	}

	return $str;
}


#
# ->_stringify_polar
#
# Stringify as a polar representation '[r,t]'.
#
sub _stringify_polar {
	my $z  = shift;
	my ($r, $t) = @{$z->_polar};
	my $theta;

	my %format = $z->display_format;
	my $format = $format{format};

	if ($t =~ /^NaN[QS]?$/i || $t =~ /^-?\Q$Inf\E$/oi) {
	    $theta = $t; 
	} elsif ($t == pi) {
	    $theta = "pi";
	} elsif ($r == 0 || $t == 0) {
	    $theta = defined $format ? sprintf($format, $t) : $t;
	}

	return "[$r,$theta]" if defined $theta;

	#
	# Try to identify pi/n and friends.
	#

	$t -= int(CORE::abs($t) / pi2) * pi2;

	if ($format{polar_pretty_print} && $t) {
	    my ($a, $b);
	    for $a (2..9) {
		$b = $t * $a / pi;
		if ($b =~ /^-?\d+$/) {
		    $b = $b < 0 ? "-" : "" if CORE::abs($b) == 1;
		    $theta = "${b}pi/$a";
		    last;
		}
	    }
	}

        if (defined $format) {
	    $r     = sprintf($format, $r);
	    $theta = sprintf($format, $t) unless defined $theta;
	} else {
	    $theta = $t unless defined $theta;
	}

	return "[$r,$theta]";
}

sub Inf {
    return $Inf;
}

1;
__END__

=pod

=head1 NAME

Math::Complex - complex numbers and associated mathematical functions

=head1 SYNOPSIS

	use Math::Complex;

	$z = Math::Complex->make(5, 6);
	$t = 4 - 3*i + $z;
	$j = cplxe(1, 2*pi/3);

=head1 DESCRIPTION

This package lets you create and manipulate complex numbers. By default,
I<Perl> limits itself to real numbers, but an extra C<use> statement brings
full complex support, along with a full set of mathematical functions
typically associated with and/or extended to complex numbers.

If you wonder what complex numbers are, they were invented to be able to solve
the following equation:

	x*x = -1

and by definition, the solution is noted I<i> (engineers use I<j> instead since
I<i> usually denotes an intensity, but the name does not matter). The number
I<i> is a pure I<imaginary> number.

The arithmetics with pure imaginary numbers works just like you would expect
it with real numbers... you just have to remember that

	i*i = -1

so you have:

	5i + 7i = i * (5 + 7) = 12i
	4i - 3i = i * (4 - 3) = i
	4i * 2i = -8
	6i / 2i = 3
	1 / i = -i

Complex numbers are numbers that have both a real part and an imaginary
part, and are usually noted:

	a + bi

where C<a> is the I<real> part and C<b> is the I<imaginary> part. The
arithmetic with complex numbers is straightforward. You have to
keep track of the real and the imaginary parts, but otherwise the
rules used for real numbers just apply:

	(4 + 3i) + (5 - 2i) = (4 + 5) + i(3 - 2) = 9 + i
	(2 + i) * (4 - i) = 2*4 + 4i -2i -i*i = 8 + 2i + 1 = 9 + 2i

A graphical representation of complex numbers is possible in a plane
(also called the I<complex plane>, but it's really a 2D plane).
The number

	z = a + bi

is the point whose coordinates are (a, b). Actually, it would
be the vector originating from (0, 0) to (a, b). It follows that the addition
of two complex numbers is a vectorial addition.

Since there is a bijection between a point in the 2D plane and a complex
number (i.e. the mapping is unique and reciprocal), a complex number
can also be uniquely identified with polar coordinates:

	[rho, theta]

where C<rho> is the distance to the origin, and C<theta> the angle between
the vector and the I<x> axis. There is a notation for this using the
exponential form, which is:

	rho * exp(i * theta)

where I<i> is the famous imaginary number introduced above. Conversion
between this form and the cartesian form C<a + bi> is immediate:

	a = rho * cos(theta)
	b = rho * sin(theta)

which is also expressed by this formula:

	z = rho * exp(i * theta) = rho * (cos theta + i * sin theta)

In other words, it's the projection of the vector onto the I<x> and I<y>
axes. Mathematicians call I<rho> the I<norm> or I<modulus> and I<theta>
the I<argument> of the complex number. The I<norm> of C<z> is
marked here as C<abs(z)>.

The polar notation (also known as the trigonometric representation) is
much more handy for performing multiplications and divisions of
complex numbers, whilst the cartesian notation is better suited for
additions and subtractions. Real numbers are on the I<x> axis, and
therefore I<y> or I<theta> is zero or I<pi>.

All the common operations that can be performed on a real number have
been defined to work on complex numbers as well, and are merely
I<extensions> of the operations defined on real numbers. This means
they keep their natural meaning when there is no imaginary part, provided
the number is within their definition set.

For instance, the C<sqrt> routine which computes the square root of
its argument is only defined for non-negative real numbers and yields a
non-negative real number (it is an application from B<R+> to B<R+>).
If we allow it to return a complex number, then it can be extended to
negative real numbers to become an application from B<R> to B<C> (the
set of complex numbers):

	sqrt(x) = x >= 0 ? sqrt(x) : sqrt(-x)*i

It can also be extended to be an application from B<C> to B<C>,
whilst its restriction to B<R> behaves as defined above by using
the following definition:

	sqrt(z = [r,t]) = sqrt(r) * exp(i * t/2)

Indeed, a negative real number can be noted C<[x,pi]> (the modulus
I<x> is always non-negative, so C<[x,pi]> is really C<-x>, a negative
number) and the above definition states that

	sqrt([x,pi]) = sqrt(x) * exp(i*pi/2) = [sqrt(x),pi/2] = sqrt(x)*i

which is exactly what we had defined for negative real numbers above.
The C<sqrt> returns only one of the solutions: if you want the both,
use the C<root> function.

All the common mathematical functions defined on real numbers that
are extended to complex numbers share that same property of working
I<as usual> when the imaginary part is zero (otherwise, it would not
be called an extension, would it?).

A I<new> operation possible on a complex number that is
the identity for real numbers is called the I<conjugate>, and is noted
with a horizontal bar above the number, or C<~z> here.

	 z = a + bi
	~z = a - bi

Simple... Now look:

	z * ~z = (a + bi) * (a - bi) = a*a + b*b

We saw that the norm of C<z> was noted C<abs(z)> and was defined as the
distance to the origin, also known as:

	rho = abs(z) = sqrt(a*a + b*b)

so

	z * ~z = abs(z) ** 2

If z is a pure real number (i.e. C<b == 0>), then the above yields:

	a * a = abs(a) ** 2

which is true (C<abs> has the regular meaning for real number, i.e. stands
for the absolute value). This example explains why the norm of C<z> is
noted C<abs(z)>: it extends the C<abs> function to complex numbers, yet
is the regular C<abs> we know when the complex number actually has no
imaginary part... This justifies I<a posteriori> our use of the C<abs>
notation for the norm.

=head1 OPERATIONS

Given the following notations:

	z1 = a + bi = r1 * exp(i * t1)
	z2 = c + di = r2 * exp(i * t2)
	z = <any complex or real number>

the following (overloaded) operations are supported on complex numbers:

	z1 + z2 = (a + c) + i(b + d)
	z1 - z2 = (a - c) + i(b - d)
	z1 * z2 = (r1 * r2) * exp(i * (t1 + t2))
	z1 / z2 = (r1 / r2) * exp(i * (t1 - t2))
	z1 ** z2 = exp(z2 * log z1)
	~z = a - bi
	abs(z) = r1 = sqrt(a*a + b*b)
	sqrt(z) = sqrt(r1) * exp(i * t/2)
	exp(z) = exp(a) * exp(i * b)
	log(z) = log(r1) + i*t
	sin(z) = 1/2i (exp(i * z1) - exp(-i * z))
	cos(z) = 1/2 (exp(i * z1) + exp(-i * z))
	atan2(y, x) = atan(y / x) # Minding the right quadrant, note the order.

The definition used for complex arguments of atan2() is

       -i log((x + iy)/sqrt(x*x+y*y))

Note that atan2(0, 0) is not well-defined.

The following extra operations are supported on both real and complex
numbers:

	Re(z) = a
	Im(z) = b
	arg(z) = t
	abs(z) = r

	cbrt(z) = z ** (1/3)
	log10(z) = log(z) / log(10)
	logn(z, n) = log(z) / log(n)

	tan(z) = sin(z) / cos(z)

	csc(z) = 1 / sin(z)
	sec(z) = 1 / cos(z)
	cot(z) = 1 / tan(z)

	asin(z) = -i * log(i*z + sqrt(1-z*z))
	acos(z) = -i * log(z + i*sqrt(1-z*z))
	atan(z) = i/2 * log((i+z) / (i-z))

	acsc(z) = asin(1 / z)
	asec(z) = acos(1 / z)
	acot(z) = atan(1 / z) = -i/2 * log((i+z) / (z-i))

	sinh(z) = 1/2 (exp(z) - exp(-z))
	cosh(z) = 1/2 (exp(z) + exp(-z))
	tanh(z) = sinh(z) / cosh(z) = (exp(z) - exp(-z)) / (exp(z) + exp(-z))

	csch(z) = 1 / sinh(z)
	sech(z) = 1 / cosh(z)
	coth(z) = 1 / tanh(z)

	asinh(z) = log(z + sqrt(z*z+1))
	acosh(z) = log(z + sqrt(z*z-1))
	atanh(z) = 1/2 * log((1+z) / (1-z))

	acsch(z) = asinh(1 / z)
	asech(z) = acosh(1 / z)
	acoth(z) = atanh(1 / z) = 1/2 * log((1+z) / (z-1))

I<arg>, I<abs>, I<log>, I<csc>, I<cot>, I<acsc>, I<acot>, I<csch>,
I<coth>, I<acosech>, I<acotanh>, have aliases I<rho>, I<theta>, I<ln>,
I<cosec>, I<cotan>, I<acosec>, I<acotan>, I<cosech>, I<cotanh>,
I<acosech>, I<acotanh>, respectively.  C<Re>, C<Im>, C<arg>, C<abs>,
C<rho>, and C<theta> can be used also as mutators.  The C<cbrt>
returns only one of the solutions: if you want all three, use the
C<root> function.

The I<root> function is available to compute all the I<n>
roots of some complex, where I<n> is a strictly positive integer.
There are exactly I<n> such roots, returned as a list. Getting the
number mathematicians call C<j> such that:

	1 + j + j*j = 0;

is a simple matter of writing:

	$j = ((root(1, 3))[1];

The I<k>th root for C<z = [r,t]> is given by:

	(root(z, n))[k] = r**(1/n) * exp(i * (t + 2*k*pi)/n)

You can return the I<k>th root directly by C<root(z, n, k)>,
indexing starting from I<zero> and ending at I<n - 1>.

The I<spaceship> numeric comparison operator, E<lt>=E<gt>, is also
defined. In order to ensure its restriction to real numbers is conform
to what you would expect, the comparison is run on the real part of
the complex number first, and imaginary parts are compared only when
the real parts match.

=head1 CREATION

To create a complex number, use either:

	$z = Math::Complex->make(3, 4);
	$z = cplx(3, 4);

if you know the cartesian form of the number, or

	$z = 3 + 4*i;

if you like. To create a number using the polar form, use either:

	$z = Math::Complex->emake(5, pi/3);
	$x = cplxe(5, pi/3);

instead. The first argument is the modulus, the second is the angle
(in radians, the full circle is 2*pi).  (Mnemonic: C<e> is used as a
notation for complex numbers in the polar form).

It is possible to write:

	$x = cplxe(-3, pi/4);

but that will be silently converted into C<[3,-3pi/4]>, since the
modulus must be non-negative (it represents the distance to the origin
in the complex plane).

It is also possible to have a complex number as either argument of the
C<make>, C<emake>, C<cplx>, and C<cplxe>: the appropriate component of
the argument will be used.

	$z1 = cplx(-2,  1);
	$z2 = cplx($z1, 4);

The C<new>, C<make>, C<emake>, C<cplx>, and C<cplxe> will also
understand a single (string) argument of the forms

    	2-3i
    	-3i
	[2,3]
	[2,-3pi/4]
	[2]

in which case the appropriate cartesian and exponential components
will be parsed from the string and used to create new complex numbers.
The imaginary component and the theta, respectively, will default to zero.

The C<new>, C<make>, C<emake>, C<cplx>, and C<cplxe> will also
understand the case of no arguments: this means plain zero or (0, 0).

=head1 DISPLAYING

When printed, a complex number is usually shown under its cartesian
style I<a+bi>, but there are legitimate cases where the polar style
I<[r,t]> is more appropriate.  The process of converting the complex
number into a string that can be displayed is known as I<stringification>.

By calling the class method C<Math::Complex::display_format> and
supplying either C<"polar"> or C<"cartesian"> as an argument, you
override the default display style, which is C<"cartesian">. Not
supplying any argument returns the current settings.

This default can be overridden on a per-number basis by calling the
C<display_format> method instead. As before, not supplying any argument
returns the current display style for this number. Otherwise whatever you
specify will be the new display style for I<this> particular number.

For instance:

	use Math::Complex;

	Math::Complex::display_format('polar');
	$j = (root(1, 3))[1];
	print "j = $j\n";		# Prints "j = [1,2pi/3]"
	$j->display_format('cartesian');
	print "j = $j\n";		# Prints "j = -0.5+0.866025403784439i"

The polar style attempts to emphasize arguments like I<k*pi/n>
(where I<n> is a positive integer and I<k> an integer within [-9, +9]),
this is called I<polar pretty-printing>.

For the reverse of stringifying, see the C<make> and C<emake>.

=head2 CHANGED IN PERL 5.6

The C<display_format> class method and the corresponding
C<display_format> object method can now be called using
a parameter hash instead of just a one parameter.

The old display format style, which can have values C<"cartesian"> or
C<"polar">, can be changed using the C<"style"> parameter.

	$j->display_format(style => "polar");

The one parameter calling convention also still works.

	$j->display_format("polar");

There are two new display parameters.

The first one is C<"format">, which is a sprintf()-style format string
to be used for both numeric parts of the complex number(s).  The is
somewhat system-dependent but most often it corresponds to C<"%.15g">.
You can revert to the default by setting the C<format> to C<undef>.

	# the $j from the above example

	$j->display_format('format' => '%.5f');
	print "j = $j\n";		# Prints "j = -0.50000+0.86603i"
	$j->display_format('format' => undef);
	print "j = $j\n";		# Prints "j = -0.5+0.86603i"

Notice that this affects also the return values of the
C<display_format> methods: in list context the whole parameter hash
will be returned, as opposed to only the style parameter value.
This is a potential incompatibility with earlier versions if you
have been calling the C<display_format> method in list context.

The second new display parameter is C<"polar_pretty_print">, which can
be set to true or false, the default being true.  See the previous
section for what this means.

=head1 USAGE

Thanks to overloading, the handling of arithmetics with complex numbers
is simple and almost transparent.

Here are some examples:

	use Math::Complex;

	$j = cplxe(1, 2*pi/3);	# $j ** 3 == 1
	print "j = $j, j**3 = ", $j ** 3, "\n";
	print "1 + j + j**2 = ", 1 + $j + $j**2, "\n";

	$z = -16 + 0*i;			# Force it to be a complex
	print "sqrt($z) = ", sqrt($z), "\n";

	$k = exp(i * 2*pi/3);
	print "$j - $k = ", $j - $k, "\n";

	$z->Re(3);			# Re, Im, arg, abs,
	$j->arg(2);			# (the last two aka rho, theta)
					# can be used also as mutators.

=head1 CONSTANTS

=head2 PI

The constant C<pi> and some handy multiples of it (pi2, pi4,
and pip2 (pi/2) and pip4 (pi/4)) are also available if separately
exported:

    use Math::Complex ':pi'; 
    $third_of_circle = pi2 / 3;

=head2 Inf

The floating point infinity can be exported as a subroutine Inf():

    use Math::Complex qw(Inf sinh);
    my $AlsoInf = Inf() + 42;
    my $AnotherInf = sinh(1e42);
    print "$AlsoInf is $AnotherInf\n" if $AlsoInf == $AnotherInf;

Note that the stringified form of infinity varies between platforms:
it can be for example any of

   inf
   infinity
   INF
   1.#INF

or it can be something else. 

Also note that in some platforms trying to use the infinity in
arithmetic operations may result in Perl crashing because using
an infinity causes SIGFPE or its moral equivalent to be sent.
The way to ignore this is

  local $SIG{FPE} = sub { };

=head1 ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO

The division (/) and the following functions

	log	ln	log10	logn
	tan	sec	csc	cot
	atan	asec	acsc	acot
	tanh	sech	csch	coth
	atanh	asech	acsch	acoth

cannot be computed for all arguments because that would mean dividing
by zero or taking logarithm of zero. These situations cause fatal
runtime errors looking like this

	cot(0): Division by zero.
	(Because in the definition of cot(0), the divisor sin(0) is 0)
	Died at ...

or

	atanh(-1): Logarithm of zero.
	Died at...

For the C<csc>, C<cot>, C<asec>, C<acsc>, C<acot>, C<csch>, C<coth>,
C<asech>, C<acsch>, the argument cannot be C<0> (zero).  For the
logarithmic functions and the C<atanh>, C<acoth>, the argument cannot
be C<1> (one).  For the C<atanh>, C<acoth>, the argument cannot be
C<-1> (minus one).  For the C<atan>, C<acot>, the argument cannot be
C<i> (the imaginary unit).  For the C<atan>, C<acoth>, the argument
cannot be C<-i> (the negative imaginary unit).  For the C<tan>,
C<sec>, C<tanh>, the argument cannot be I<pi/2 + k * pi>, where I<k>
is any integer.  atan2(0, 0) is undefined, and if the complex arguments
are used for atan2(), a division by zero will happen if z1**2+z2**2 == 0.

Note that because we are operating on approximations of real numbers,
these errors can happen when merely `too close' to the singularities
listed above.

=head1 ERRORS DUE TO INDIGESTIBLE ARGUMENTS

The C<make> and C<emake> accept both real and complex arguments.
When they cannot recognize the arguments they will die with error
messages like the following

    Math::Complex::make: Cannot take real part of ...
    Math::Complex::make: Cannot take real part of ...
    Math::Complex::emake: Cannot take rho of ...
    Math::Complex::emake: Cannot take theta of ...

=head1 BUGS

Saying C<use Math::Complex;> exports many mathematical routines in the
caller environment and even overrides some (C<sqrt>, C<log>, C<atan2>).
This is construed as a feature by the Authors, actually... ;-)

All routines expect to be given real or complex numbers. Don't attempt to
use BigFloat, since Perl has currently no rule to disambiguate a '+'
operation (for instance) between two overloaded entities.

In Cray UNICOS there is some strange numerical instability that results
in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast.  Beware.
The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex.
Whatever it is, it does not manifest itself anywhere else where Perl runs.

=head1 SEE ALSO

L<Math::Trig>

=head1 AUTHORS

Daniel S. Lewart <F<lewart!at!uiuc.edu>>,
Jarkko Hietaniemi <F<jhi!at!iki.fi>>,
Raphael Manfredi <F<Raphael_Manfredi!at!pobox.com>>,
Zefram <zefram@fysh.org>

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut

1;

# eof
                                                                                                                                                                                                                                 usr/share/perl/5.20.2/Math/Trig.pm                                                                  0100644 0000000 0000000 00000051576 12744441327 015030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# Trigonometric functions, mostly inherited from Math::Complex.
# -- Jarkko Hietaniemi, since April 1997
# -- Raphael Manfredi, September 1996 (indirectly: because of Math::Complex)
#

package Math::Trig;

{ use 5.006; }
use strict;

use Math::Complex 1.59;
use Math::Complex qw(:trig :pi);
require Exporter;

our @ISA = qw(Exporter);

our $VERSION = 1.23;

my @angcnv = qw(rad2deg rad2grad
		deg2rad deg2grad
		grad2rad grad2deg);

my @areal = qw(asin_real acos_real);

our @EXPORT = (@{$Math::Complex::EXPORT_TAGS{'trig'}},
	   @angcnv, @areal);

my @rdlcnv = qw(cartesian_to_cylindrical
		cartesian_to_spherical
		cylindrical_to_cartesian
		cylindrical_to_spherical
		spherical_to_cartesian
		spherical_to_cylindrical);

my @greatcircle = qw(
		     great_circle_distance
		     great_circle_direction
		     great_circle_bearing
		     great_circle_waypoint
		     great_circle_midpoint
		     great_circle_destination
		    );

my @pi = qw(pi pi2 pi4 pip2 pip4);

our @EXPORT_OK = (@rdlcnv, @greatcircle, @pi, 'Inf');

# See e.g. the following pages:
# http://www.movable-type.co.uk/scripts/LatLong.html
# http://williams.best.vwh.net/avform.htm

our %EXPORT_TAGS = ('radial' => [ @rdlcnv ],
	        'great_circle' => [ @greatcircle ],
	        'pi'     => [ @pi ]);

sub _DR  () { pi2/360 }
sub _RD  () { 360/pi2 }
sub _DG  () { 400/360 }
sub _GD  () { 360/400 }
sub _RG  () { 400/pi2 }
sub _GR  () { pi2/400 }

#
# Truncating remainder.
#

sub _remt ($$) {
    # Oh yes, POSIX::fmod() would be faster. Possibly. If it is available.
    $_[0] - $_[1] * int($_[0] / $_[1]);
}

#
# Angle conversions.
#

sub rad2rad($)     { _remt($_[0], pi2) }

sub deg2deg($)     { _remt($_[0], 360) }

sub grad2grad($)   { _remt($_[0], 400) }

sub rad2deg ($;$)  { my $d = _RD * $_[0]; $_[1] ? $d : deg2deg($d) }

sub deg2rad ($;$)  { my $d = _DR * $_[0]; $_[1] ? $d : rad2rad($d) }

sub grad2deg ($;$) { my $d = _GD * $_[0]; $_[1] ? $d : deg2deg($d) }

sub deg2grad ($;$) { my $d = _DG * $_[0]; $_[1] ? $d : grad2grad($d) }

sub rad2grad ($;$) { my $d = _RG * $_[0]; $_[1] ? $d : grad2grad($d) }

sub grad2rad ($;$) { my $d = _GR * $_[0]; $_[1] ? $d : rad2rad($d) }

#
# acos and asin functions which always return a real number
#

sub acos_real {
    return 0  if $_[0] >=  1;
    return pi if $_[0] <= -1;
    return acos($_[0]);
}

sub asin_real {
    return  &pip2 if $_[0] >=  1;
    return -&pip2 if $_[0] <= -1;
    return asin($_[0]);
}

sub cartesian_to_spherical {
    my ( $x, $y, $z ) = @_;

    my $rho = sqrt( $x * $x + $y * $y + $z * $z );

    return ( $rho,
             atan2( $y, $x ),
             $rho ? acos_real( $z / $rho ) : 0 );
}

sub spherical_to_cartesian {
    my ( $rho, $theta, $phi ) = @_;

    return ( $rho * cos( $theta ) * sin( $phi ),
             $rho * sin( $theta ) * sin( $phi ),
             $rho * cos( $phi   ) );
}

sub spherical_to_cylindrical {
    my ( $x, $y, $z ) = spherical_to_cartesian( @_ );

    return ( sqrt( $x * $x + $y * $y ), $_[1], $z );
}

sub cartesian_to_cylindrical {
    my ( $x, $y, $z ) = @_;

    return ( sqrt( $x * $x + $y * $y ), atan2( $y, $x ), $z );
}

sub cylindrical_to_cartesian {
    my ( $rho, $theta, $z ) = @_;

    return ( $rho * cos( $theta ), $rho * sin( $theta ), $z );
}

sub cylindrical_to_spherical {
    return ( cartesian_to_spherical( cylindrical_to_cartesian( @_ ) ) );
}

sub great_circle_distance {
    my ( $theta0, $phi0, $theta1, $phi1, $rho ) = @_;

    $rho = 1 unless defined $rho; # Default to the unit sphere.

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    return $rho *
	acos_real( cos( $lat0 ) * cos( $lat1 ) * cos( $theta0 - $theta1 ) +
		   sin( $lat0 ) * sin( $lat1 ) );
}

sub great_circle_direction {
    my ( $theta0, $phi0, $theta1, $phi1 ) = @_;

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    return rad2rad(pi2 -
	atan2(sin($theta0-$theta1) * cos($lat1),
		cos($lat0) * sin($lat1) -
		    sin($lat0) * cos($lat1) * cos($theta0-$theta1)));
}

*great_circle_bearing         = \&great_circle_direction;

sub great_circle_waypoint {
    my ( $theta0, $phi0, $theta1, $phi1, $point ) = @_;

    $point = 0.5 unless defined $point;

    my $d = great_circle_distance( $theta0, $phi0, $theta1, $phi1 );

    return undef if $d == pi;

    my $sd = sin($d);

    return ($theta0, $phi0) if $sd == 0;

    my $A = sin((1 - $point) * $d) / $sd;
    my $B = sin(     $point  * $d) / $sd;

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    my $x = $A * cos($lat0) * cos($theta0) + $B * cos($lat1) * cos($theta1);
    my $y = $A * cos($lat0) * sin($theta0) + $B * cos($lat1) * sin($theta1);
    my $z = $A * sin($lat0)                + $B * sin($lat1);

    my $theta = atan2($y, $x);
    my $phi   = acos_real($z);

    return ($theta, $phi);
}

sub great_circle_midpoint {
    great_circle_waypoint(@_[0..3], 0.5);
}

sub great_circle_destination {
    my ( $theta0, $phi0, $dir0, $dst ) = @_;

    my $lat0 = pip2 - $phi0;

    my $phi1   = asin_real(sin($lat0)*cos($dst) +
			   cos($lat0)*sin($dst)*cos($dir0));

    my $theta1 = $theta0 + atan2(sin($dir0)*sin($dst)*cos($lat0),
				 cos($dst)-sin($lat0)*sin($phi1));

    my $dir1 = great_circle_bearing($theta1, $phi1, $theta0, $phi0) + pi;

    $dir1 -= pi2 if $dir1 > pi2;

    return ($theta1, $phi1, $dir1);
}

1;

__END__
=pod

=head1 NAME

Math::Trig - trigonometric functions

=head1 SYNOPSIS

    use Math::Trig;

    $x = tan(0.9);
    $y = acos(3.7);
    $z = asin(2.4);

    $halfpi = pi/2;

    $rad = deg2rad(120);

    # Import constants pi2, pip2, pip4 (2*pi, pi/2, pi/4).
    use Math::Trig ':pi';

    # Import the conversions between cartesian/spherical/cylindrical.
    use Math::Trig ':radial';

        # Import the great circle formulas.
    use Math::Trig ':great_circle';

=head1 DESCRIPTION

C<Math::Trig> defines many trigonometric functions not defined by the
core Perl which defines only the C<sin()> and C<cos()>.  The constant
B<pi> is also defined as are a few convenience functions for angle
conversions, and I<great circle formulas> for spherical movement.

=head1 TRIGONOMETRIC FUNCTIONS

The tangent

=over 4

=item B<tan>

=back

The cofunctions of the sine, cosine, and tangent (cosec/csc and cotan/cot
are aliases)

B<csc>, B<cosec>, B<sec>, B<sec>, B<cot>, B<cotan>

The arcus (also known as the inverse) functions of the sine, cosine,
and tangent

B<asin>, B<acos>, B<atan>

The principal value of the arc tangent of y/x

B<atan2>(y, x)

The arcus cofunctions of the sine, cosine, and tangent (acosec/acsc
and acotan/acot are aliases).  Note that atan2(0, 0) is not well-defined.

B<acsc>, B<acosec>, B<asec>, B<acot>, B<acotan>

The hyperbolic sine, cosine, and tangent

B<sinh>, B<cosh>, B<tanh>

The cofunctions of the hyperbolic sine, cosine, and tangent (cosech/csch
and cotanh/coth are aliases)

B<csch>, B<cosech>, B<sech>, B<coth>, B<cotanh>

The area (also known as the inverse) functions of the hyperbolic
sine, cosine, and tangent

B<asinh>, B<acosh>, B<atanh>

The area cofunctions of the hyperbolic sine, cosine, and tangent
(acsch/acosech and acoth/acotanh are aliases)

B<acsch>, B<acosech>, B<asech>, B<acoth>, B<acotanh>

The trigonometric constant B<pi> and some of handy multiples
of it are also defined.

B<pi, pi2, pi4, pip2, pip4>

=head2 ERRORS DUE TO DIVISION BY ZERO

The following functions

    acoth
    acsc
    acsch
    asec
    asech
    atanh
    cot
    coth
    csc
    csch
    sec
    sech
    tan
    tanh

cannot be computed for all arguments because that would mean dividing
by zero or taking logarithm of zero. These situations cause fatal
runtime errors looking like this

    cot(0): Division by zero.
    (Because in the definition of cot(0), the divisor sin(0) is 0)
    Died at ...

or

    atanh(-1): Logarithm of zero.
    Died at...

For the C<csc>, C<cot>, C<asec>, C<acsc>, C<acot>, C<csch>, C<coth>,
C<asech>, C<acsch>, the argument cannot be C<0> (zero).  For the
C<atanh>, C<acoth>, the argument cannot be C<1> (one).  For the
C<atanh>, C<acoth>, the argument cannot be C<-1> (minus one).  For the
C<tan>, C<sec>, C<tanh>, C<sech>, the argument cannot be I<pi/2 + k *
pi>, where I<k> is any integer.

Note that atan2(0, 0) is not well-defined.

=head2 SIMPLE (REAL) ARGUMENTS, COMPLEX RESULTS

Please note that some of the trigonometric functions can break out
from the B<real axis> into the B<complex plane>. For example
C<asin(2)> has no definition for plain real numbers but it has
definition for complex numbers.

In Perl terms this means that supplying the usual Perl numbers (also
known as scalars, please see L<perldata>) as input for the
trigonometric functions might produce as output results that no more
are simple real numbers: instead they are complex numbers.

The C<Math::Trig> handles this by using the C<Math::Complex> package
which knows how to handle complex numbers, please see L<Math::Complex>
for more information. In practice you need not to worry about getting
complex numbers as results because the C<Math::Complex> takes care of
details like for example how to display complex numbers. For example:

    print asin(2), "\n";

should produce something like this (take or leave few last decimals):

    1.5707963267949-1.31695789692482i

That is, a complex number with the real part of approximately C<1.571>
and the imaginary part of approximately C<-1.317>.

=head1 PLANE ANGLE CONVERSIONS

(Plane, 2-dimensional) angles may be converted with the following functions.

=over

=item deg2rad

    $radians  = deg2rad($degrees);

=item grad2rad

    $radians  = grad2rad($gradians);

=item rad2deg

    $degrees  = rad2deg($radians);

=item grad2deg

    $degrees  = grad2deg($gradians);

=item deg2grad

    $gradians = deg2grad($degrees);

=item rad2grad

    $gradians = rad2grad($radians);

=back

The full circle is 2 I<pi> radians or I<360> degrees or I<400> gradians.
The result is by default wrapped to be inside the [0, {2pi,360,400}[ circle.
If you don't want this, supply a true second argument:

    $zillions_of_radians  = deg2rad($zillions_of_degrees, 1);
    $negative_degrees     = rad2deg($negative_radians, 1);

You can also do the wrapping explicitly by rad2rad(), deg2deg(), and
grad2grad().

=over 4

=item rad2rad

    $radians_wrapped_by_2pi = rad2rad($radians);

=item deg2deg

    $degrees_wrapped_by_360 = deg2deg($degrees);

=item grad2grad

    $gradians_wrapped_by_400 = grad2grad($gradians);

=back

=head1 RADIAL COORDINATE CONVERSIONS

B<Radial coordinate systems> are the B<spherical> and the B<cylindrical>
systems, explained shortly in more detail.

You can import radial coordinate conversion functions by using the
C<:radial> tag:

    use Math::Trig ':radial';

    ($rho, $theta, $z)     = cartesian_to_cylindrical($x, $y, $z);
    ($rho, $theta, $phi)   = cartesian_to_spherical($x, $y, $z);
    ($x, $y, $z)           = cylindrical_to_cartesian($rho, $theta, $z);
    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
    ($x, $y, $z)           = spherical_to_cartesian($rho, $theta, $phi);
    ($rho_c, $theta, $z)   = spherical_to_cylindrical($rho_s, $theta, $phi);

B<All angles are in radians>.

=head2 COORDINATE SYSTEMS

B<Cartesian> coordinates are the usual rectangular I<(x, y, z)>-coordinates.

Spherical coordinates, I<(rho, theta, pi)>, are three-dimensional
coordinates which define a point in three-dimensional space.  They are
based on a sphere surface.  The radius of the sphere is B<rho>, also
known as the I<radial> coordinate.  The angle in the I<xy>-plane
(around the I<z>-axis) is B<theta>, also known as the I<azimuthal>
coordinate.  The angle from the I<z>-axis is B<phi>, also known as the
I<polar> coordinate.  The North Pole is therefore I<0, 0, rho>, and
the Gulf of Guinea (think of the missing big chunk of Africa) I<0,
pi/2, rho>.  In geographical terms I<phi> is latitude (northward
positive, southward negative) and I<theta> is longitude (eastward
positive, westward negative).

B<BEWARE>: some texts define I<theta> and I<phi> the other way round,
some texts define the I<phi> to start from the horizontal plane, some
texts use I<r> in place of I<rho>.

Cylindrical coordinates, I<(rho, theta, z)>, are three-dimensional
coordinates which define a point in three-dimensional space.  They are
based on a cylinder surface.  The radius of the cylinder is B<rho>,
also known as the I<radial> coordinate.  The angle in the I<xy>-plane
(around the I<z>-axis) is B<theta>, also known as the I<azimuthal>
coordinate.  The third coordinate is the I<z>, pointing up from the
B<theta>-plane.

=head2 3-D ANGLE CONVERSIONS

Conversions to and from spherical and cylindrical coordinates are
available.  Please notice that the conversions are not necessarily
reversible because of the equalities like I<pi> angles being equal to
I<-pi> angles.

=over 4

=item cartesian_to_cylindrical

    ($rho, $theta, $z) = cartesian_to_cylindrical($x, $y, $z);

=item cartesian_to_spherical

    ($rho, $theta, $phi) = cartesian_to_spherical($x, $y, $z);

=item cylindrical_to_cartesian

    ($x, $y, $z) = cylindrical_to_cartesian($rho, $theta, $z);

=item cylindrical_to_spherical

    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);

Notice that when C<$z> is not 0 C<$rho_s> is not equal to C<$rho_c>.

=item spherical_to_cartesian

    ($x, $y, $z) = spherical_to_cartesian($rho, $theta, $phi);

=item spherical_to_cylindrical

    ($rho_c, $theta, $z) = spherical_to_cylindrical($rho_s, $theta, $phi);

Notice that when C<$z> is not 0 C<$rho_c> is not equal to C<$rho_s>.

=back

=head1 GREAT CIRCLE DISTANCES AND DIRECTIONS

A great circle is section of a circle that contains the circle
diameter: the shortest distance between two (non-antipodal) points on
the spherical surface goes along the great circle connecting those two
points.

=head2 great_circle_distance

You can compute spherical distances, called B<great circle distances>,
by importing the great_circle_distance() function:

  use Math::Trig 'great_circle_distance';

  $distance = great_circle_distance($theta0, $phi0, $theta1, $phi1, [, $rho]);

The I<great circle distance> is the shortest distance between two
points on a sphere.  The distance is in C<$rho> units.  The C<$rho> is
optional, it defaults to 1 (the unit sphere), therefore the distance
defaults to radians.

If you think geographically the I<theta> are longitudes: zero at the
Greenwhich meridian, eastward positive, westward negative -- and the
I<phi> are latitudes: zero at the North Pole, northward positive,
southward negative.  B<NOTE>: this formula thinks in mathematics, not
geographically: the I<phi> zero is at the North Pole, not at the
Equator on the west coast of Africa (Bay of Guinea).  You need to
subtract your geographical coordinates from I<pi/2> (also known as 90
degrees).

  $distance = great_circle_distance($lon0, pi/2 - $lat0,
                                    $lon1, pi/2 - $lat1, $rho);

=head2 great_circle_direction

The direction you must follow the great circle (also known as I<bearing>)
can be computed by the great_circle_direction() function:

  use Math::Trig 'great_circle_direction';

  $direction = great_circle_direction($theta0, $phi0, $theta1, $phi1);

=head2 great_circle_bearing

Alias 'great_circle_bearing' for 'great_circle_direction' is also available.

  use Math::Trig 'great_circle_bearing';

  $direction = great_circle_bearing($theta0, $phi0, $theta1, $phi1);

The result of great_circle_direction is in radians, zero indicating
straight north, pi or -pi straight south, pi/2 straight west, and
-pi/2 straight east.

=head2 great_circle_destination

You can inversely compute the destination if you know the
starting point, direction, and distance:

  use Math::Trig 'great_circle_destination';

  # $diro is the original direction,
  # for example from great_circle_bearing().
  # $distance is the angular distance in radians,
  # for example from great_circle_distance().
  # $thetad and $phid are the destination coordinates,
  # $dird is the final direction at the destination.

  ($thetad, $phid, $dird) =
    great_circle_destination($theta, $phi, $diro, $distance);

or the midpoint if you know the end points:

=head2 great_circle_midpoint

  use Math::Trig 'great_circle_midpoint';

  ($thetam, $phim) =
    great_circle_midpoint($theta0, $phi0, $theta1, $phi1);

The great_circle_midpoint() is just a special case of

=head2 great_circle_waypoint

  use Math::Trig 'great_circle_waypoint';

  ($thetai, $phii) =
    great_circle_waypoint($theta0, $phi0, $theta1, $phi1, $way);

Where the $way is a value from zero ($theta0, $phi0) to one ($theta1,
$phi1).  Note that antipodal points (where their distance is I<pi>
radians) do not have waypoints between them (they would have an an
"equator" between them), and therefore C<undef> is returned for
antipodal points.  If the points are the same and the distance
therefore zero and all waypoints therefore identical, the first point
(either point) is returned.

The thetas, phis, direction, and distance in the above are all in radians.

You can import all the great circle formulas by

  use Math::Trig ':great_circle';

Notice that the resulting directions might be somewhat surprising if
you are looking at a flat worldmap: in such map projections the great
circles quite often do not look like the shortest routes --  but for
example the shortest possible routes from Europe or North America to
Asia do often cross the polar regions.  (The common Mercator projection
does B<not> show great circles as straight lines: straight lines in the
Mercator projection are lines of constant bearing.)

=head1 EXAMPLES

To calculate the distance between London (51.3N 0.5W) and Tokyo
(35.7N 139.8E) in kilometers:

    use Math::Trig qw(great_circle_distance deg2rad);

    # Notice the 90 - latitude: phi zero is at the North Pole.
    sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }
    my @L = NESW( -0.5, 51.3);
    my @T = NESW(139.8, 35.7);
    my $km = great_circle_distance(@L, @T, 6378); # About 9600 km.

The direction you would have to go from London to Tokyo (in radians,
straight north being zero, straight east being pi/2).

    use Math::Trig qw(great_circle_direction);

    my $rad = great_circle_direction(@L, @T); # About 0.547 or 0.174 pi.

The midpoint between London and Tokyo being

    use Math::Trig qw(great_circle_midpoint);

    my @M = great_circle_midpoint(@L, @T);

or about 69 N 89 E, in the frozen wastes of Siberia.

B<NOTE>: you B<cannot> get from A to B like this:

   Dist = great_circle_distance(A, B)
   Dir  = great_circle_direction(A, B)
   C    = great_circle_destination(A, Dist, Dir)

and expect C to be B, because the bearing constantly changes when
going from A to B (except in some special case like the meridians or
the circles of latitudes) and in great_circle_destination() one gives
a B<constant> bearing to follow.

=head2 CAVEAT FOR GREAT CIRCLE FORMULAS

The answers may be off by few percentages because of the irregular
(slightly aspherical) form of the Earth.  The errors are at worst
about 0.55%, but generally below 0.3%.

=head2 Real-valued asin and acos

For small inputs asin() and acos() may return complex numbers even
when real numbers would be enough and correct, this happens because of
floating-point inaccuracies.  You can see these inaccuracies for
example by trying theses:

  print cos(1e-6)**2+sin(1e-6)**2 - 1,"\n";
  printf "%.20f", cos(1e-6)**2+sin(1e-6)**2,"\n";

which will print something like this

  -1.11022302462516e-16
  0.99999999999999988898

even though the expected results are of course exactly zero and one.
The formulas used to compute asin() and acos() are quite sensitive to
this, and therefore they might accidentally slip into the complex
plane even when they should not.  To counter this there are two
interfaces that are guaranteed to return a real-valued output.

=over 4

=item asin_real

    use Math::Trig qw(asin_real);

    $real_angle = asin_real($input_sin);

Return a real-valued arcus sine if the input is between [-1, 1],
B<inclusive> the endpoints.  For inputs greater than one, pi/2
is returned.  For inputs less than minus one, -pi/2 is returned.

=item acos_real

    use Math::Trig qw(acos_real);

    $real_angle = acos_real($input_cos);

Return a real-valued arcus cosine if the input is between [-1, 1],
B<inclusive> the endpoints.  For inputs greater than one, zero
is returned.  For inputs less than minus one, pi is returned.

=back

=head1 BUGS

Saying C<use Math::Trig;> exports many mathematical routines in the
caller environment and even overrides some (C<sin>, C<cos>).  This is
construed as a feature by the Authors, actually... ;-)

The code is not optimized for speed, especially because we use
C<Math::Complex> and thus go quite near complex numbers while doing
the computations even when the arguments are not. This, however,
cannot be completely avoided if we want things like C<asin(2)> to give
an answer instead of giving a fatal runtime error.

Do not attempt navigation using these formulas.

L<Math::Complex>

=head1 AUTHORS

Jarkko Hietaniemi <F<jhi!at!iki.fi>>,
Raphael Manfredi <F<Raphael_Manfredi!at!pobox.com>>,
Zefram <zefram@fysh.org>

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut

# eof
                                                                                                                                  usr/share/perl/5.20.2/Memoize/                                                                      0040755 0000000 0000000 00000000000 13077704254 014267  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Memoize/AnyDBM_File.pm                                                        0100644 0000000 0000000 00000001242 12744441327 016631  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Memoize::AnyDBM_File;

=head1 NAME

Memoize::AnyDBM_File - glue to provide EXISTS for AnyDBM_File for Storable use

=head1 DESCRIPTION

See L<Memoize>.

=cut

use vars qw(@ISA $VERSION);
$VERSION = '1.03';
@ISA = qw(DB_File GDBM_File Memoize::NDBM_File Memoize::SDBM_File ODBM_File) unless @ISA;

my $verbose = 1;

my $mod;
for $mod (@ISA) {
#  (my $truemod = $mod) =~ s/^Memoize:://;
#  my $file = "$mod.pm";
#  $file =~ s{::}{/}g;
  if (eval "require $mod") {
    print STDERR "AnyDBM_File => Selected $mod.\n" if $Verbose;
    @ISA = ($mod);	# if we leave @ISA alone, warnings abound
    return 1;
  }
}

die "No DBM package was successfully found or installed";
                                                                                                                                                                                                                                                                                                                                                              usr/share/perl/5.20.2/Memoize/Expire.pm                                                             0100644 0000000 0000000 00000026670 12744441327 016070  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
package Memoize::Expire;
# require 5.00556;
use Carp;
$DEBUG = 0;
$VERSION = '1.03';

# This package will implement expiration by prepending a fixed-length header
# to the font of the cached data.  The format of the header will be:
# (4-byte number of last-access-time)  (For LRU when I implement it)
# (4-byte expiration time: unsigned seconds-since-unix-epoch)
# (2-byte number-of-uses-before-expire)

sub _header_fmt () { "N N n" }
sub _header_size () { length(_header_fmt) }

# Usage:  memoize func 
#         TIE => [Memoize::Expire, LIFETIME => sec, NUM_USES => n,
#                 TIE => [...] ]

BEGIN {
  eval {require Time::HiRes};
  unless ($@) {
    Time::HiRes->import('time');
  }
}

sub TIEHASH {
  my ($package, %args) = @_;
  my %cache;
  if ($args{TIE}) {
    my ($module, @opts) = @{$args{TIE}};
    my $modulefile = $module . '.pm';
    $modulefile =~ s{::}{/}g;
    eval { require $modulefile };
    if ($@) {
      croak "Memoize::Expire: Couldn't load hash tie module `$module': $@; aborting";
    }
    my $rc = (tie %cache => $module, @opts);
    unless ($rc) {
      croak "Memoize::Expire: Couldn't tie hash to `$module': $@; aborting";
    }
  }
  $args{LIFETIME} ||= 0;
  $args{NUM_USES} ||= 0;
  $args{C} = \%cache;
  bless \%args => $package;
}

sub STORE {
  $DEBUG and print STDERR " >> Store $_[1] $_[2]\n";
  my ($self, $key, $value) = @_;
  my $expire_time = $self->{LIFETIME} > 0 ? $self->{LIFETIME} + time : 0;
  # The call that results in a value to store into the cache is the
  # first of the NUM_USES allowed calls.
  my $header = _make_header(time, $expire_time, $self->{NUM_USES}-1);
  $self->{C}{$key} = $header . $value;
  $value;
}

sub FETCH {
  $DEBUG and print STDERR " >> Fetch cached value for $_[1]\n";
  my ($data, $last_access, $expire_time, $num_uses_left) = _get_item($_[0]{C}{$_[1]});
  $DEBUG and print STDERR " >>   (ttl: ", ($expire_time-time()), ", nuses: $num_uses_left)\n";
  $num_uses_left--;
  $last_access = time;
  _set_header(@_, $data, $last_access, $expire_time, $num_uses_left);
  $data;
}

sub EXISTS {
  $DEBUG and print STDERR " >> Exists $_[1]\n";
  unless (exists $_[0]{C}{$_[1]}) {
    $DEBUG and print STDERR "    Not in underlying hash at all.\n";
    return 0;
  }
  my $item = $_[0]{C}{$_[1]};
  my ($last_access, $expire_time, $num_uses_left) = _get_header($item);
  my $ttl = $expire_time - time;
  if ($DEBUG) {
    $_[0]{LIFETIME} and print STDERR "    Time to live for this item: $ttl\n";
    $_[0]{NUM_USES} and print STDERR "    Uses remaining: $num_uses_left\n";
  }
  if (   (! $_[0]{LIFETIME} || $expire_time > time)
      && (! $_[0]{NUM_USES} || $num_uses_left > 0 )) {
	    $DEBUG and print STDERR "    (Still good)\n";
    return 1;
  } else {
    $DEBUG and print STDERR "    (Expired)\n";
    return 0;
  }
}

# Arguments: last access time, expire time, number of uses remaining
sub _make_header {
  pack "N N n", @_;
}

sub _strip_header {
  substr($_[0], 10);
}

# Arguments: last access time, expire time, number of uses remaining
sub _set_header {
  my ($self, $key, $data, @header) = @_;
  $self->{C}{$key} = _make_header(@header) . $data;
}

sub _get_item {
  my $data = substr($_[0], 10);
  my @header = unpack "N N n", substr($_[0], 0, 10);
#  print STDERR " >> _get_item: $data => $data @header\n";
  ($data, @header);
}

# Return last access time, expire time, number of uses remaining
sub _get_header  {
  unpack "N N n", substr($_[0], 0, 10);
}

1;

=head1 NAME 

Memoize::Expire - Plug-in module for automatic expiration of memoized values

=head1 SYNOPSIS

  use Memoize;
  use Memoize::Expire;
  tie my %cache => 'Memoize::Expire',
	  	     LIFETIME => $lifetime,    # In seconds
		     NUM_USES => $n_uses;

  memoize 'function', SCALAR_CACHE => [HASH => \%cache ];

=head1 DESCRIPTION

Memoize::Expire is a plug-in module for Memoize.  It allows the cached
values for memoized functions to expire automatically.  This manual
assumes you are already familiar with the Memoize module.  If not, you
should study that manual carefully first, paying particular attention
to the HASH feature.

Memoize::Expire is a layer of software that you can insert in between
Memoize itself and whatever underlying package implements the cache.
The layer presents a hash variable whose values expire whenever they
get too old, have been used too often, or both. You tell C<Memoize> to
use this forgetful hash as its cache instead of the default, which is
an ordinary hash.

To specify a real-time timeout, supply the C<LIFETIME> option with a
numeric value.  Cached data will expire after this many seconds, and
will be looked up afresh when it expires.  When a data item is looked
up afresh, its lifetime is reset.

If you specify C<NUM_USES> with an argument of I<n>, then each cached
data item will be discarded and looked up afresh after the I<n>th time
you access it.  When a data item is looked up afresh, its number of
uses is reset.

If you specify both arguments, data will be discarded from the cache
when either expiration condition holds.

Memoize::Expire uses a real hash internally to store the cached data.
You can use the C<HASH> option to Memoize::Expire to supply a tied
hash in place of the ordinary hash that Memoize::Expire will normally
use.  You can use this feature to add Memoize::Expire as a layer in
between a persistent disk hash and Memoize.  If you do this, you get a
persistent disk cache whose entries expire automatically.  For
example:

  #   Memoize
  #      |
  #   Memoize::Expire  enforces data expiration policy
  #      |
  #   DB_File  implements persistence of data in a disk file
  #      |
  #   Disk file

  use Memoize;
  use Memoize::Expire;
  use DB_File;

  # Set up persistence
  tie my %disk_cache => 'DB_File', $filename, O_CREAT|O_RDWR, 0666];

  # Set up expiration policy, supplying persistent hash as a target
  tie my %cache => 'Memoize::Expire', 
	  	     LIFETIME => $lifetime,    # In seconds
		     NUM_USES => $n_uses,
                     HASH => \%disk_cache; 

  # Set up memoization, supplying expiring persistent hash for cache
  memoize 'function', SCALAR_CACHE => [ HASH => \%cache ];

=head1 INTERFACE

There is nothing special about Memoize::Expire.  It is just an
example.  If you don't like the policy that it implements, you are
free to write your own expiration policy module that implements
whatever policy you desire.  Here is how to do that.  Let us suppose
that your module will be named MyExpirePolicy.

Short summary: You need to create a package that defines four methods:

=over 4

=item 
TIEHASH

Construct and return cache object.

=item 
EXISTS

Given a function argument, is the corresponding function value in the
cache, and if so, is it fresh enough to use?

=item
FETCH

Given a function argument, look up the corresponding function value in
the cache and return it.

=item 
STORE

Given a function argument and the corresponding function value, store
them into the cache.

=item
CLEAR

(Optional.)  Flush the cache completely.

=back

The user who wants the memoization cache to be expired according to
your policy will say so by writing

  tie my %cache => 'MyExpirePolicy', args...;
  memoize 'function', SCALAR_CACHE => [HASH => \%cache];

This will invoke C<< MyExpirePolicy->TIEHASH(args) >>.
MyExpirePolicy::TIEHASH should do whatever is appropriate to set up
the cache, and it should return the cache object to the caller.

For example, MyExpirePolicy::TIEHASH might create an object that
contains a regular Perl hash (which it will to store the cached
values) and some extra information about the arguments and how old the
data is and things like that.  Let us call this object `C'.

When Memoize needs to check to see if an entry is in the cache
already, it will invoke C<< C->EXISTS(key) >>.  C<key> is the normalized
function argument.  MyExpirePolicy::EXISTS should return 0 if the key
is not in the cache, or if it has expired, and 1 if an unexpired value
is in the cache.  It should I<not> return C<undef>, because there is a
bug in some versions of Perl that will cause a spurious FETCH if the
EXISTS method returns C<undef>.

If your EXISTS function returns true, Memoize will try to fetch the
cached value by invoking C<< C->FETCH(key) >>.  MyExpirePolicy::FETCH should
return the cached value.  Otherwise, Memoize will call the memoized
function to compute the appropriate value, and will store it into the
cache by calling C<< C->STORE(key, value) >>.

Here is a very brief example of a policy module that expires each
cache item after ten seconds.

	package Memoize::TenSecondExpire;

	sub TIEHASH {
	  my ($package, %args) = @_;
          my $cache = $args{HASH} || {};
	  bless $cache => $package;
	}

	sub EXISTS {
	  my ($cache, $key) = @_;
	  if (exists $cache->{$key} && 
              $cache->{$key}{EXPIRE_TIME} > time) {
	    return 1
	  } else {
	    return 0;  # Do NOT return `undef' here.
	  }
	}

	sub FETCH {
	  my ($cache, $key) = @_;
	  return $cache->{$key}{VALUE};
	}

	sub STORE {
	  my ($cache, $key, $newvalue) = @_;
	  $cache->{$key}{VALUE} = $newvalue;
	  $cache->{$key}{EXPIRE_TIME} = time + 10;
	}

To use this expiration policy, the user would say

	use Memoize;
        tie my %cache10sec => 'Memoize::TenSecondExpire';
	memoize 'function', SCALAR_CACHE => [HASH => \%cache10sec];

Memoize would then call C<function> whenever a cached value was
entirely absent or was older than ten seconds.

You should always support a C<HASH> argument to C<TIEHASH> that ties
the underlying cache so that the user can specify that the cache is
also persistent or that it has some other interesting semantics.  The
example above demonstrates how to do this, as does C<Memoize::Expire>.

Another sample module, L<Memoize::Saves>, is available in a separate
distribution on CPAN.  It implements a policy that allows you to
specify that certain function values would always be looked up afresh.
See the documentation for details.

=head1 ALTERNATIVES

Brent Powers has a C<Memoize::ExpireLRU> module that was designed to
work with Memoize and provides expiration of least-recently-used data.
The cache is held at a fixed number of entries, and when new data
comes in, the least-recently used data is expired.  See
L<http://search.cpan.org/search?mode=module&query=ExpireLRU>.

Joshua Chamas's Tie::Cache module may be useful as an expiration
manager.  (If you try this, let me know how it works out.)

If you develop any useful expiration managers that you think should be
distributed with Memoize, please let me know.

=head1 CAVEATS

This module is experimental, and may contain bugs.  Please report bugs
to the address below.

Number-of-uses is stored as a 16-bit unsigned integer, so can't exceed
65535.

Because of clock granularity, expiration times may occur up to one
second sooner than you expect.  For example, suppose you store a value
with a lifetime of ten seconds, and you store it at 12:00:00.998 on a
certain day.  Memoize will look at the clock and see 12:00:00.  Then
9.01 seconds later, at 12:00:10.008 you try to read it back.  Memoize
will look at the clock and see 12:00:10 and conclude that the value
has expired.  This will probably not occur if you have
C<Time::HiRes> installed.

=head1 AUTHOR

Mark-Jason Dominus (mjd-perl-memoize+@plover.com)

Mike Cariaso provided valuable insight into the best way to solve this
problem.

=head1 SEE ALSO

perl(1)

The Memoize man page.

http://www.plover.com/~mjd/perl/Memoize/  (for news and updates)

I maintain a mailing list on which I occasionally announce new
versions of Memoize.  The list is for announcements only, not
discussion.  To join, send an empty message to
mjd-perl-memoize-request@Plover.com.

=cut
                                                                        usr/share/perl/5.20.2/Memoize/ExpireFile.pm                                                         0100644 0000000 0000000 00000002032 12744441327 016652  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Memoize::ExpireFile;

=head1 NAME

Memoize::ExpireFile - test for Memoize expiration semantics

=head1 DESCRIPTION

See L<Memoize::Expire>.

=cut

$VERSION = '1.03';
use Carp;

my $Zero = pack("N", 0);

sub TIEHASH {
  my ($package, %args) = @_;
  my $cache = $args{HASH} || {};
  bless {ARGS => \%args, C => $cache} => $package;
}


sub STORE {
#  print "Expiry manager STORE handler\n";
  my ($self, $key, $data) = @_;
  my $cache = $self->{C};
  my $cur_date = pack("N", (stat($key))[9]);
  $cache->{"C$key"} = $data;
  $cache->{"T$key"} = $cur_date;
}

sub FETCH {
  my ($self, $key) = @_;
  $self->{C}{"C$key"};
}

sub EXISTS {
#  print "Expiry manager EXISTS handler\n";
  my ($self, $key) = @_;
  my $cache_date = $self->{C}{"T$key"} || $Zero;
  my $file_date = pack("N", (stat($key))[9]);#
#  if ($self->{ARGS}{CHECK_DATE} && $old_date gt $cur_date) {
#    return $self->{ARGS}{CHECK_DATE}->($key, $old_date, $cur_date);
#  } 
  my $res = $cache_date ge $file_date;
#  print $res ? "... still good\n" : "... expired\n";
  $res;
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/share/perl/5.20.2/Memoize/ExpireTest.pm                                                         0100644 0000000 0000000 00000001563 12744441327 016722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Memoize::ExpireTest;

=head1 NAME

Memoize::ExpireTest - test for Memoize expiration semantics

=head1 DESCRIPTION

This module is just for testing expiration semantics.  It's not a very
good example of how to write an expiration module.

If you are looking for an example, I recommend that you look at the
simple example in the Memoize::Expire documentation, or at the code
for Memoize::Expire itself.

If you have questions, I will be happy to answer them if you send them
to mjd-perl-memoize+@plover.com.

=cut

$VERSION = '1.03';
my %cache;

sub TIEHASH {	
  my ($pack) = @_;
  bless \%cache => $pack;
}

sub EXISTS {
  my ($cache, $key) = @_;
  exists $cache->{$key} ? 1 : 0;
}

sub FETCH {
  my ($cache, $key) = @_;
  $cache->{$key};
}

sub STORE {
  my ($cache, $key, $val) = @_;
  $cache->{$key} = $val;
}

sub expire {
  my ($key) = @_;
  delete $cache{$key};
}

1;
                                                                                                                                             usr/share/perl/5.20.2/Memoize/NDBM_File.pm                                                          0100644 0000000 0000000 00000002720 12744441327 016301  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Memoize::NDBM_File;

=head1 NAME

Memoize::NDBM_File - glue to provide EXISTS for NDBM_File for Storable use

=head1 DESCRIPTION

See L<Memoize>.

=cut

use NDBM_File;
@ISA = qw(NDBM_File);
$VERSION = '1.03';

$Verbose = 0;

sub AUTOLOAD {
  warn "Nonexistent function $AUTOLOAD invoked in Memoize::NDBM_File\n";
}

sub import {
  warn "Importing Memoize::NDBM_File\n" if $Verbose;
}


my %keylist;

# This is so ridiculous...
sub _backhash {
  my $self = shift;
  my %fakehash;
  my $k; 
  for ($k = $self->FIRSTKEY(); defined $k; $k = $self->NEXTKEY($k)) {
    $fakehash{$k} = undef;
  }
  $keylist{$self} = \%fakehash;
}

sub EXISTS {
  warn "Memoize::NDBM_File EXISTS (@_)\n" if $Verbose;
  my $self = shift;
  _backhash($self)  unless exists $keylist{$self};
  my $r = exists $keylist{$self}{$_[0]};
  warn "Memoize::NDBM_File EXISTS (@_) ==> $r\n" if $Verbose;
  $r;
}

sub DEFINED {
  warn "Memoize::NDBM_File DEFINED (@_)\n" if $Verbose;
  my $self = shift;
  _backhash($self)  unless exists $keylist{$self};
  defined $keylist{$self}{$_[0]};
}

sub DESTROY {
  warn "Memoize::NDBM_File DESTROY (@_)\n" if $Verbose;
  my $self = shift;
  delete $keylist{$self};   # So much for reference counting...
  $self->SUPER::DESTROY(@_);
}

# Maybe establish the keylist at TIEHASH time instead?

sub STORE {
  warn "Memoize::NDBM_File STORE (@_)\n" if $VERBOSE;
  my $self = shift;
  $keylist{$self}{$_[0]} = undef;
  $self->SUPER::STORE(@_);
}



# Inherit FETCH and TIEHASH

1;
                                                usr/share/perl/5.20.2/Memoize/SDBM_File.pm                                                          0100644 0000000 0000000 00000002716 12744441327 016313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Memoize::SDBM_File;

=head1 NAME

Memoize::SDBM_File - glue to provide EXISTS for SDBM_File for Storable use

=head1 DESCRIPTION

See L<Memoize>.

=cut

use SDBM_File;
@ISA = qw(SDBM_File);
$VERSION = '1.03';

$Verbose = 0;

sub AUTOLOAD {
  warn "Nonexistent function $AUTOLOAD invoked in Memoize::SDBM_File\n";
}

sub import {
  warn "Importing Memoize::SDBM_File\n" if $Verbose;
}


my %keylist;

# This is so ridiculous...
sub _backhash {
  my $self = shift;
  my %fakehash;
  my $k; 
  for ($k = $self->FIRSTKEY(); defined $k; $k = $self->NEXTKEY($k)) {
    $fakehash{$k} = undef;
  }
  $keylist{$self} = \%fakehash;
}

sub EXISTS {
  warn "Memoize::SDBM_File EXISTS (@_)\n" if $Verbose;
  my $self = shift;
  _backhash($self)  unless exists $keylist{$self};
  my $r = exists $keylist{$self}{$_[0]};
  warn "Memoize::SDBM_File EXISTS (@_) ==> $r\n" if $Verbose;
  $r;
}

sub DEFINED {
  warn "Memoize::SDBM_File DEFINED (@_)\n" if $Verbose;
  my $self = shift;
  _backhash($self)  unless exists $keylist{$self};
  defined $keylist{$self}{$_[0]};
}

sub DESTROY {
  warn "Memoize::SDBM_File DESTROY (@_)\n" if $Verbose;
  my $self = shift;
  delete $keylist{$self};   # So much for reference counting...
  $self->SUPER::DESTROY(@_);
}

# Maybe establish the keylist at TIEHASH time instead?

sub STORE {
  warn "Memoize::SDBM_File STORE (@_)\n" if $VERBOSE;
  my $self = shift;
  $keylist{$self}{$_[0]} = undef;
  $self->SUPER::STORE(@_);
}

# Inherit FETCH and TIEHASH

1;
                                                  usr/share/perl/5.20.2/Memoize/Storable.pm                                                           0100644 0000000 0000000 00000002614 12744441327 016377  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Memoize::Storable;

=head1 NAME

Memoize::Storable - store Memoized data in Storable database

=head1 DESCRIPTION

See L<Memoize>.

=cut

use Storable ();
$VERSION = '1.03';
$Verbose = 0;

sub TIEHASH {
  require Carp if $Verbose;
  my $package = shift;
  my $filename = shift;
  my $truehash = (-e $filename) ? Storable::retrieve($filename) : {};
  my %options;
  print STDERR "Memoize::Storable::TIEHASH($filename, @_)\n" if $Verbose;
  @options{@_} = ();
  my $self = 
    {FILENAME => $filename, 
     H => $truehash, 
     OPTIONS => \%options
    };
  bless $self => $package;
}

sub STORE {
  require Carp if $Verbose;
  my $self = shift;
  print STDERR "Memoize::Storable::STORE(@_)\n" if $Verbose;
  $self->{H}{$_[0]} = $_[1];
}

sub FETCH {
  require Carp if $Verbose;
  my $self = shift;
  print STDERR "Memoize::Storable::FETCH(@_)\n" if $Verbose;
  $self->{H}{$_[0]};
}

sub EXISTS {
  require Carp if $Verbose;
  my $self = shift;
  print STDERR "Memoize::Storable::EXISTS(@_)\n" if $Verbose;
  exists $self->{H}{$_[0]};
}

sub DESTROY {
  require Carp if $Verbose;
  my $self= shift;
  print STDERR "Memoize::Storable::DESTROY(@_)\n" if $Verbose;
  if (exists $self->{OPTIONS}{'nstore'}) {
    Storable::nstore($self->{H}, $self->{FILENAME});
  } else {
    Storable::store($self->{H}, $self->{FILENAME});
  }
}

sub FIRSTKEY {
  'Fake hash from Memoize::Storable';
}

sub NEXTKEY {
  undef;
}
1;
                                                                                                                    usr/share/perl/5.20.2/Memoize.pm                                                                    0100644 0000000 0000000 00000106535 12744441327 014633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- mode: perl; perl-indent-level: 2; -*-
# Memoize.pm
#
# Transparent memoization of idempotent functions
#
# Copyright 1998, 1999, 2000, 2001, 2012 M. J. Dominus.
# You may copy and distribute this program under the
# same terms as Perl itself.  If in doubt, 
# write to mjd-perl-memoize+@plover.com for a license.

package Memoize;
$VERSION = '1.03';

# Compile-time constants
sub SCALAR () { 0 } 
sub LIST () { 1 } 


#
# Usage memoize(functionname/ref,
#               { NORMALIZER => coderef, INSTALL => name,
#                 LIST_CACHE => descriptor, SCALAR_CACHE => descriptor }
#

use Carp;
use Exporter;
use vars qw($DEBUG);
use Config;                     # Dammit.
@ISA = qw(Exporter);
@EXPORT = qw(memoize);
@EXPORT_OK = qw(unmemoize flush_cache);
use strict;

my %memotable;
my %revmemotable;
my @CONTEXT_TAGS = qw(MERGE TIE MEMORY FAULT HASH);
my %IS_CACHE_TAG = map {($_ => 1)} @CONTEXT_TAGS;

# Raise an error if the user tries to specify one of thesepackage as a
# tie for LIST_CACHE

my %scalar_only = map {($_ => 1)} qw(DB_File GDBM_File SDBM_File ODBM_File NDBM_File);

sub memoize {
  my $fn = shift;
  my %options = @_;
  my $options = \%options;
  
  unless (defined($fn) && 
	  (ref $fn eq 'CODE' || ref $fn eq '')) {
    croak "Usage: memoize 'functionname'|coderef {OPTIONS}";
  }

  my $uppack = caller;		# TCL me Elmo!
  my $cref;			# Code reference to original function
  my $name = (ref $fn ? undef : $fn);

  # Convert function names to code references
  $cref = &_make_cref($fn, $uppack);

  # Locate function prototype, if any
  my $proto = prototype $cref;
  if (defined $proto) { $proto = "($proto)" }
  else { $proto = "" }

  # I would like to get rid of the eval, but there seems not to be any
  # other way to set the prototype properly.  The switch here for
  # 'usethreads' works around a bug in threadperl having to do with
  # magic goto.  It would be better to fix the bug and use the magic
  # goto version everywhere.
  my $wrapper = 
      $Config{usethreads} 
        ? eval "sub $proto { &_memoizer(\$cref, \@_); }" 
        : eval "sub $proto { unshift \@_, \$cref; goto &_memoizer; }";

  my $normalizer = $options{NORMALIZER};
  if (defined $normalizer  && ! ref $normalizer) {
    $normalizer = _make_cref($normalizer, $uppack);
  }
  
  my $install_name;
  if (defined $options->{INSTALL}) {
    # INSTALL => name
    $install_name = $options->{INSTALL};
  } elsif (! exists $options->{INSTALL}) {
    # No INSTALL option provided; use original name if possible
    $install_name = $name;
  } else {
    # INSTALL => undef  means don't install
  }

  if (defined $install_name) {
    $install_name = $uppack . '::' . $install_name
	unless $install_name =~ /::/;
    no strict;
    local($^W) = 0;	       # ``Subroutine $install_name redefined at ...''
    *{$install_name} = $wrapper; # Install memoized version
  }

  $revmemotable{$wrapper} = "" . $cref; # Turn code ref into hash key

  # These will be the caches
  my %caches;
  for my $context (qw(SCALAR LIST)) {
    # suppress subsequent 'uninitialized value' warnings
    $options{"${context}_CACHE"} ||= ''; 

    my $cache_opt = $options{"${context}_CACHE"};
    my @cache_opt_args;
    if (ref $cache_opt) {
      @cache_opt_args = @$cache_opt;
      $cache_opt = shift @cache_opt_args;
    }
    if ($cache_opt eq 'FAULT') { # no cache
      $caches{$context} = undef;
    } elsif ($cache_opt eq 'HASH') { # user-supplied hash
      my $cache = $cache_opt_args[0];
      my $package = ref(tied %$cache);
      if ($context eq 'LIST' && $scalar_only{$package}) {
        croak("You can't use $package for LIST_CACHE because it can only store scalars");
      }
      $caches{$context} = $cache;
    } elsif ($cache_opt eq '' ||  $IS_CACHE_TAG{$cache_opt}) {
      # default is that we make up an in-memory hash
      $caches{$context} = {};
      # (this might get tied later, or MERGEd away)
    } else {
      croak "Unrecognized option to `${context}_CACHE': `$cache_opt' should be one of (@CONTEXT_TAGS); aborting";
    }
  }

  # Perhaps I should check here that you didn't supply *both* merge
  # options.  But if you did, it does do something reasonable: They
  # both get merged to the same in-memory hash.
  if ($options{SCALAR_CACHE} eq 'MERGE' || $options{LIST_CACHE} eq 'MERGE') {
    $options{MERGED} = 1;
    $caches{SCALAR} = $caches{LIST};
  }

  # Now deal with the TIE options
  {
    my $context;
    foreach $context (qw(SCALAR LIST)) {
      # If the relevant option wasn't `TIE', this call does nothing.
      _my_tie($context, $caches{$context}, $options);  # Croaks on failure
    }
  }
  
  # We should put some more stuff in here eventually.
  # We've been saying that for serveral versions now.
  # And you know what?  More stuff keeps going in!
  $memotable{$cref} = 
  {
    O => $options,  # Short keys here for things we need to access frequently
    N => $normalizer,
    U => $cref,
    MEMOIZED => $wrapper,
    PACKAGE => $uppack,
    NAME => $install_name,
    S => $caches{SCALAR},
    L => $caches{LIST},
  };

  $wrapper			# Return just memoized version
}

# This function tries to load a tied hash class and tie the hash to it.
sub _my_tie {
  my ($context, $hash, $options) = @_;
  my $fullopt = $options->{"${context}_CACHE"};

  # We already checked to make sure that this works.
  my $shortopt = (ref $fullopt) ? $fullopt->[0] : $fullopt;
  
  return unless defined $shortopt && $shortopt eq 'TIE';
  carp("TIE option to memoize() is deprecated; use HASH instead")
      if $^W;

  my @args = ref $fullopt ? @$fullopt : ();
  shift @args;
  my $module = shift @args;
  if ($context eq 'LIST' && $scalar_only{$module}) {
    croak("You can't use $module for LIST_CACHE because it can only store scalars");
  }
  my $modulefile = $module . '.pm';
  $modulefile =~ s{::}{/}g;
  eval {
    local @INC = @INC;
    pop @INC if $INC[-1] eq '.';
    require $modulefile
  };
  if ($@) {
    croak "Memoize: Couldn't load hash tie module `$module': $@; aborting";
  }
  my $rc = (tie %$hash => $module, @args);
  unless ($rc) {
    croak "Memoize: Couldn't tie hash to `$module': $!; aborting";
  }
  1;
}

sub flush_cache {
  my $func = _make_cref($_[0], scalar caller);
  my $info = $memotable{$revmemotable{$func}};
  die "$func not memoized" unless defined $info;
  for my $context (qw(S L)) {
    my $cache = $info->{$context};
    if (tied %$cache && ! (tied %$cache)->can('CLEAR')) {
      my $funcname = defined($info->{NAME}) ? 
          "function $info->{NAME}" : "anonymous function $func";
      my $context = {S => 'scalar', L => 'list'}->{$context};
      croak "Tied cache hash for $context-context $funcname does not support flushing";
    } else {
      %$cache = ();
    }
  }
}

# This is the function that manages the memo tables.
sub _memoizer {
  my $orig = shift;		# stringized version of ref to original func.
  my $info = $memotable{$orig};
  my $normalizer = $info->{N};
  
  my $argstr;
  my $context = (wantarray() ? LIST : SCALAR);

  if (defined $normalizer) { 
    no strict;
    if ($context == SCALAR) {
      $argstr = &{$normalizer}(@_);
    } elsif ($context == LIST) {
      ($argstr) = &{$normalizer}(@_);
    } else {
      croak "Internal error \#41; context was neither LIST nor SCALAR\n";
    }
  } else {                      # Default normalizer
    local $^W = 0;
    $argstr = join chr(28),@_;  
  }

  if ($context == SCALAR) {
    my $cache = $info->{S};
    _crap_out($info->{NAME}, 'scalar') unless $cache;
    if (exists $cache->{$argstr}) { 
      return $info->{O}{MERGED}
        ? $cache->{$argstr}[0] : $cache->{$argstr};
    } else {
      my $val = &{$info->{U}}(@_);
      # Scalars are considered to be lists; store appropriately
      if ($info->{O}{MERGED}) {
	$cache->{$argstr} = [$val];
      } else {
	$cache->{$argstr} = $val;
      }
      $val;
    }
  } elsif ($context == LIST) {
    my $cache = $info->{L};
    _crap_out($info->{NAME}, 'list') unless $cache;
    if (exists $cache->{$argstr}) {
      return @{$cache->{$argstr}};
    } else {
      my @q = &{$info->{U}}(@_);
      $cache->{$argstr} = \@q;
      @q;
    }
  } else {
    croak "Internal error \#42; context was neither LIST nor SCALAR\n";
  }
}

sub unmemoize {
  my $f = shift;
  my $uppack = caller;
  my $cref = _make_cref($f, $uppack);

  unless (exists $revmemotable{$cref}) {
    croak "Could not unmemoize function `$f', because it was not memoized to begin with";
  }
  
  my $tabent = $memotable{$revmemotable{$cref}};
  unless (defined $tabent) {
    croak "Could not figure out how to unmemoize function `$f'";
  }
  my $name = $tabent->{NAME};
  if (defined $name) {
    no strict;
    local($^W) = 0;	       # ``Subroutine $install_name redefined at ...''
    *{$name} = $tabent->{U}; # Replace with original function
  }
  undef $memotable{$revmemotable{$cref}};
  undef $revmemotable{$cref};

  # This removes the last reference to the (possibly tied) memo tables
  # my ($old_function, $memotabs) = @{$tabent}{'U','S','L'};
  # undef $tabent; 

#  # Untie the memo tables if they were tied.
#  my $i;
#  for $i (0,1) {
#    if (tied %{$memotabs->[$i]}) {
#      warn "Untying hash #$i\n";
#      untie %{$memotabs->[$i]};
#    }
#  }

  $tabent->{U};
}

sub _make_cref {
  my $fn = shift;
  my $uppack = shift;
  my $cref;
  my $name;

  if (ref $fn eq 'CODE') {
    $cref = $fn;
  } elsif (! ref $fn) {
    if ($fn =~ /::/) {
      $name = $fn;
    } else {
      $name = $uppack . '::' . $fn;
    }
    no strict;
    if (defined $name and !defined(&$name)) {
      croak "Cannot operate on nonexistent function `$fn'";
    }
#    $cref = \&$name;
    $cref = *{$name}{CODE};
  } else {
    my $parent = (caller(1))[3]; # Function that called _make_cref
    croak "Usage: argument 1 to `$parent' must be a function name or reference.\n";
  }
  $DEBUG and warn "${name}($fn) => $cref in _make_cref\n";
  $cref;
}

sub _crap_out {
  my ($funcname, $context) = @_;
  if (defined $funcname) {
    croak "Function `$funcname' called in forbidden $context context; faulting";
  } else {
    croak "Anonymous function called in forbidden $context context; faulting";
  }
}

1;





=head1 NAME

Memoize - Make functions faster by trading space for time

=head1 SYNOPSIS

        # This is the documentation for Memoize 1.03
	use Memoize;
	memoize('slow_function');
	slow_function(arguments);    # Is faster than it was before


This is normally all you need to know.  However, many options are available:

	memoize(function, options...);

Options include:

	NORMALIZER => function
	INSTALL => new_name

	SCALAR_CACHE => 'MEMORY'
        SCALAR_CACHE => ['HASH', \%cache_hash ]
	SCALAR_CACHE => 'FAULT'
	SCALAR_CACHE => 'MERGE'

	LIST_CACHE => 'MEMORY'
        LIST_CACHE => ['HASH', \%cache_hash ]
	LIST_CACHE => 'FAULT'
	LIST_CACHE => 'MERGE'

=head1 DESCRIPTION

`Memoizing' a function makes it faster by trading space for time.  It
does this by caching the return values of the function in a table.
If you call the function again with the same arguments, C<memoize>
jumps in and gives you the value out of the table, instead of letting
the function compute the value all over again.

Here is an extreme example.  Consider the Fibonacci sequence, defined
by the following function:

	# Compute Fibonacci numbers
	sub fib {
	  my $n = shift;
	  return $n if $n < 2;
	  fib($n-1) + fib($n-2);
	}

This function is very slow.  Why?  To compute fib(14), it first wants
to compute fib(13) and fib(12), and add the results.  But to compute
fib(13), it first has to compute fib(12) and fib(11), and then it
comes back and computes fib(12) all over again even though the answer
is the same.  And both of the times that it wants to compute fib(12),
it has to compute fib(11) from scratch, and then it has to do it
again each time it wants to compute fib(13).  This function does so
much recomputing of old results that it takes a really long time to
run---fib(14) makes 1,200 extra recursive calls to itself, to compute
and recompute things that it already computed.

This function is a good candidate for memoization.  If you memoize the
`fib' function above, it will compute fib(14) exactly once, the first
time it needs to, and then save the result in a table.  Then if you
ask for fib(14) again, it gives you the result out of the table.
While computing fib(14), instead of computing fib(12) twice, it does
it once; the second time it needs the value it gets it from the table.
It doesn't compute fib(11) four times; it computes it once, getting it
from the table the next three times.  Instead of making 1,200
recursive calls to `fib', it makes 15.  This makes the function about
150 times faster.

You could do the memoization yourself, by rewriting the function, like
this:

	# Compute Fibonacci numbers, memoized version
	{ my @fib;
  	  sub fib {
	    my $n = shift;
	    return $fib[$n] if defined $fib[$n];
	    return $fib[$n] = $n if $n < 2;
	    $fib[$n] = fib($n-1) + fib($n-2);
	  }
        }

Or you could use this module, like this:

	use Memoize;
	memoize('fib');

	# Rest of the fib function just like the original version.

This makes it easy to turn memoizing on and off.

Here's an even simpler example: I wrote a simple ray tracer; the
program would look in a certain direction, figure out what it was
looking at, and then convert the `color' value (typically a string
like `red') of that object to a red, green, and blue pixel value, like
this:

    for ($direction = 0; $direction < 300; $direction++) {
      # Figure out which object is in direction $direction
      $color = $object->{color};
      ($r, $g, $b) = @{&ColorToRGB($color)};
      ...
    }

Since there are relatively few objects in a picture, there are only a
few colors, which get looked up over and over again.  Memoizing
C<ColorToRGB> sped up the program by several percent.

=head1 DETAILS

This module exports exactly one function, C<memoize>.  The rest of the
functions in this package are None of Your Business.

You should say

	memoize(function)

where C<function> is the name of the function you want to memoize, or
a reference to it.  C<memoize> returns a reference to the new,
memoized version of the function, or C<undef> on a non-fatal error.
At present, there are no non-fatal errors, but there might be some in
the future.

If C<function> was the name of a function, then C<memoize> hides the
old version and installs the new memoized version under the old name,
so that C<&function(...)> actually invokes the memoized version.

=head1 OPTIONS

There are some optional options you can pass to C<memoize> to change
the way it behaves a little.  To supply options, invoke C<memoize>
like this:

	memoize(function, NORMALIZER => function,
			  INSTALL => newname,
                          SCALAR_CACHE => option,
	                  LIST_CACHE => option
			 );

Each of these options is optional; you can include some, all, or none
of them.

=head2 INSTALL

If you supply a function name with C<INSTALL>, memoize will install
the new, memoized version of the function under the name you give.
For example, 

	memoize('fib', INSTALL => 'fastfib')

installs the memoized version of C<fib> as C<fastfib>; without the
C<INSTALL> option it would have replaced the old C<fib> with the
memoized version.  

To prevent C<memoize> from installing the memoized version anywhere, use
C<INSTALL =E<gt> undef>.

=head2 NORMALIZER

Suppose your function looks like this:

	# Typical call: f('aha!', A => 11, B => 12);
	sub f {
	  my $a = shift;
	  my %hash = @_;
	  $hash{B} ||= 2;  # B defaults to 2
	  $hash{C} ||= 7;  # C defaults to 7

	  # Do something with $a, %hash
	}

Now, the following calls to your function are all completely equivalent:

	f(OUCH);
	f(OUCH, B => 2);
	f(OUCH, C => 7);
	f(OUCH, B => 2, C => 7);
	f(OUCH, C => 7, B => 2);
	(etc.)

However, unless you tell C<Memoize> that these calls are equivalent,
it will not know that, and it will compute the values for these
invocations of your function separately, and store them separately.

To prevent this, supply a C<NORMALIZER> function that turns the
program arguments into a string in a way that equivalent arguments
turn into the same string.  A C<NORMALIZER> function for C<f> above
might look like this:

	sub normalize_f {
	  my $a = shift;
	  my %hash = @_;
	  $hash{B} ||= 2;
	  $hash{C} ||= 7;

	  join(',', $a, map ($_ => $hash{$_}) sort keys %hash);
	}

Each of the argument lists above comes out of the C<normalize_f>
function looking exactly the same, like this:

	OUCH,B,2,C,7

You would tell C<Memoize> to use this normalizer this way:

	memoize('f', NORMALIZER => 'normalize_f');

C<memoize> knows that if the normalized version of the arguments is
the same for two argument lists, then it can safely look up the value
that it computed for one argument list and return it as the result of
calling the function with the other argument list, even if the
argument lists look different.

The default normalizer just concatenates the arguments with character
28 in between.  (In ASCII, this is called FS or control-\.)  This
always works correctly for functions with only one string argument,
and also when the arguments never contain character 28.  However, it
can confuse certain argument lists:

	normalizer("a\034", "b")
	normalizer("a", "\034b")
	normalizer("a\034\034b")

for example.

Since hash keys are strings, the default normalizer will not
distinguish between C<undef> and the empty string.  It also won't work
when the function's arguments are references.  For example, consider a
function C<g> which gets two arguments: A number, and a reference to
an array of numbers:

	g(13, [1,2,3,4,5,6,7]);

The default normalizer will turn this into something like
C<"13\034ARRAY(0x436c1f)">.  That would be all right, except that a
subsequent array of numbers might be stored at a different location
even though it contains the same data.  If this happens, C<Memoize>
will think that the arguments are different, even though they are
equivalent.  In this case, a normalizer like this is appropriate:

	sub normalize { join ' ', $_[0], @{$_[1]} }

For the example above, this produces the key "13 1 2 3 4 5 6 7".

Another use for normalizers is when the function depends on data other
than those in its arguments.  Suppose you have a function which
returns a value which depends on the current hour of the day:

	sub on_duty {
          my ($problem_type) = @_;
	  my $hour = (localtime)[2];
          open my $fh, "$DIR/$problem_type" or die...;
          my $line;
          while ($hour-- > 0)
            $line = <$fh>;
          } 
	  return $line;
	}

At 10:23, this function generates the 10th line of a data file; at
3:45 PM it generates the 15th line instead.  By default, C<Memoize>
will only see the $problem_type argument.  To fix this, include the
current hour in the normalizer:

        sub normalize { join ' ', (localtime)[2], @_ }

The calling context of the function (scalar or list context) is
propagated to the normalizer.  This means that if the memoized
function will treat its arguments differently in list context than it
would in scalar context, you can have the normalizer function select
its behavior based on the results of C<wantarray>.  Even if called in
a list context, a normalizer should still return a single string.

=head2 C<SCALAR_CACHE>, C<LIST_CACHE>

Normally, C<Memoize> caches your function's return values into an
ordinary Perl hash variable.  However, you might like to have the
values cached on the disk, so that they persist from one run of your
program to the next, or you might like to associate some other
interesting semantics with the cached values.

There's a slight complication under the hood of C<Memoize>: There are
actually I<two> caches, one for scalar values and one for list values.
When your function is called in scalar context, its return value is
cached in one hash, and when your function is called in list context,
its value is cached in the other hash.  You can control the caching
behavior of both contexts independently with these options.

The argument to C<LIST_CACHE> or C<SCALAR_CACHE> must either be one of
the following four strings:

	MEMORY
	FAULT
	MERGE
        HASH

or else it must be a reference to an array whose first element is one of
these four strings, such as C<[HASH, arguments...]>.

=over 4

=item C<MEMORY>

C<MEMORY> means that return values from the function will be cached in
an ordinary Perl hash variable.  The hash variable will not persist
after the program exits.  This is the default.

=item C<HASH>

C<HASH> allows you to specify that a particular hash that you supply
will be used as the cache.  You can tie this hash beforehand to give
it any behavior you want.

A tied hash can have any semantics at all.  It is typically tied to an
on-disk database, so that cached values are stored in the database and
retrieved from it again when needed, and the disk file typically
persists after your program has exited.  See C<perltie> for more
complete details about C<tie>.

A typical example is:

        use DB_File;
        tie my %cache => 'DB_File', $filename, O_RDWR|O_CREAT, 0666;
        memoize 'function', SCALAR_CACHE => [HASH => \%cache];

This has the effect of storing the cache in a C<DB_File> database
whose name is in C<$filename>.  The cache will persist after the
program has exited.  Next time the program runs, it will find the
cache already populated from the previous run of the program.  Or you
can forcibly populate the cache by constructing a batch program that
runs in the background and populates the cache file.  Then when you
come to run your real program the memoized function will be fast
because all its results have been precomputed.

Another reason to use C<HASH> is to provide your own hash variable.
You can then inspect or modify the contents of the hash to gain finer
control over the cache management.

=item C<TIE>

This option is no longer supported.  It is still documented only to
aid in the debugging of old programs that use it.  Old programs should
be converted to use the C<HASH> option instead.

        memoize ... ['TIE', PACKAGE, ARGS...]

is merely a shortcut for

        require PACKAGE;
	{ tie my %cache, PACKAGE, ARGS...;
          memoize ... [HASH => \%cache];
        }

=item C<FAULT>

C<FAULT> means that you never expect to call the function in scalar
(or list) context, and that if C<Memoize> detects such a call, it
should abort the program.  The error message is one of

	`foo' function called in forbidden list context at line ...
	`foo' function called in forbidden scalar context at line ...

=item C<MERGE>

C<MERGE> normally means that the memoized function does not
distinguish between list and sclar context, and that return values in
both contexts should be stored together.  Both C<LIST_CACHE =E<gt>
MERGE> and C<SCALAR_CACHE =E<gt> MERGE> mean the same thing.

Consider this function:

	sub complicated {
          # ... time-consuming calculation of $result
          return $result;
        }

The C<complicated> function will return the same numeric C<$result>
regardless of whether it is called in list or in scalar context.

Normally, the following code will result in two calls to C<complicated>, even
if C<complicated> is memoized:

    $x = complicated(142);
    ($y) = complicated(142);
    $z = complicated(142);

The first call will cache the result, say 37, in the scalar cache; the
second will cach the list C<(37)> in the list cache.  The third call
doesn't call the real C<complicated> function; it gets the value 37
from the scalar cache.

Obviously, the second call to C<complicated> is a waste of time, and
storing its return value is a waste of space.  Specifying C<LIST_CACHE
=E<gt> MERGE> will make C<memoize> use the same cache for scalar and
list context return values, so that the second call uses the scalar
cache that was populated by the first call.  C<complicated> ends up
being called only once, and both subsequent calls return C<3> from the
cache, regardless of the calling context.

=head3 List values in scalar context

Consider this function:

    sub iota { return reverse (1..$_[0]) }

This function normally returns a list.  Suppose you memoize it and
merge the caches:

    memoize 'iota', SCALAR_CACHE => 'MERGE';

    @i7 = iota(7);
    $i7 = iota(7);

Here the first call caches the list (1,2,3,4,5,6,7).  The second call
does not really make sense. C<Memoize> cannot guess what behavior
C<iota> should have in scalar context without actually calling it in
scalar context.  Normally C<Memoize> I<would> call C<iota> in scalar
context and cache the result, but the C<SCALAR_CACHE =E<gt> 'MERGE'>
option says not to do that, but to use the cache list-context value
instead. But it cannot return a list of seven elements in a scalar
context. In this case C<$i7> will receive the B<first element> of the
cached list value, namely 7.

=head3 Merged disk caches

Another use for C<MERGE> is when you want both kinds of return values
stored in the same disk file; this saves you from having to deal with
two disk files instead of one.  You can use a normalizer function to
keep the two sets of return values separate.  For example:

        tie my %cache => 'MLDBM', 'DB_File', $filename, ...;

	memoize 'myfunc',
	  NORMALIZER => 'n',
	  SCALAR_CACHE => [HASH => \%cache],
	  LIST_CACHE => 'MERGE',
	;

	sub n {
	  my $context = wantarray() ? 'L' : 'S';
	  # ... now compute the hash key from the arguments ...
	  $hashkey = "$context:$hashkey";
	}

This normalizer function will store scalar context return values in
the disk file under keys that begin with C<S:>, and list context
return values under keys that begin with C<L:>.

=back

=head1 OTHER FACILITIES

=head2 C<unmemoize>

There's an C<unmemoize> function that you can import if you want to.
Why would you want to?  Here's an example: Suppose you have your cache
tied to a DBM file, and you want to make sure that the cache is
written out to disk if someone interrupts the program.  If the program
exits normally, this will happen anyway, but if someone types
control-C or something then the program will terminate immediately
without synchronizing the database.  So what you can do instead is

    $SIG{INT} = sub { unmemoize 'function' };

C<unmemoize> accepts a reference to, or the name of a previously
memoized function, and undoes whatever it did to provide the memoized
version in the first place, including making the name refer to the
unmemoized version if appropriate.  It returns a reference to the
unmemoized version of the function.

If you ask it to unmemoize a function that was never memoized, it
croaks.

=head2 C<flush_cache>

C<flush_cache(function)> will flush out the caches, discarding I<all>
the cached data.  The argument may be a function name or a reference
to a function.  For finer control over when data is discarded or
expired, see the documentation for C<Memoize::Expire>, included in
this package.

Note that if the cache is a tied hash, C<flush_cache> will attempt to
invoke the C<CLEAR> method on the hash.  If there is no C<CLEAR>
method, this will cause a run-time error.

An alternative approach to cache flushing is to use the C<HASH> option
(see above) to request that C<Memoize> use a particular hash variable
as its cache.  Then you can examine or modify the hash at any time in
any way you desire.  You may flush the cache by using C<%hash = ()>. 

=head1 CAVEATS

Memoization is not a cure-all:

=over 4

=item *

Do not memoize a function whose behavior depends on program
state other than its own arguments, such as global variables, the time
of day, or file input.  These functions will not produce correct
results when memoized.  For a particularly easy example:

	sub f {
	  time;
	}

This function takes no arguments, and as far as C<Memoize> is
concerned, it always returns the same result.  C<Memoize> is wrong, of
course, and the memoized version of this function will call C<time> once
to get the current time, and it will return that same time
every time you call it after that.

=item *

Do not memoize a function with side effects.

	sub f {
	  my ($a, $b) = @_;
          my $s = $a + $b;
	  print "$a + $b = $s.\n";
	}

This function accepts two arguments, adds them, and prints their sum.
Its return value is the numuber of characters it printed, but you
probably didn't care about that.  But C<Memoize> doesn't understand
that.  If you memoize this function, you will get the result you
expect the first time you ask it to print the sum of 2 and 3, but
subsequent calls will return 1 (the return value of
C<print>) without actually printing anything.

=item *

Do not memoize a function that returns a data structure that is
modified by its caller.

Consider these functions:  C<getusers> returns a list of users somehow,
and then C<main> throws away the first user on the list and prints the
rest:

	sub main {
	  my $userlist = getusers();
	  shift @$userlist;
	  foreach $u (@$userlist) {
	    print "User $u\n";
	  }
	}

	sub getusers {
	  my @users;
	  # Do something to get a list of users;
	  \@users;  # Return reference to list.
	}

If you memoize C<getusers> here, it will work right exactly once.  The
reference to the users list will be stored in the memo table.  C<main>
will discard the first element from the referenced list.  The next
time you invoke C<main>, C<Memoize> will not call C<getusers>; it will
just return the same reference to the same list it got last time.  But
this time the list has already had its head removed; C<main> will
erroneously remove another element from it.  The list will get shorter
and shorter every time you call C<main>.

Similarly, this:

	$u1 = getusers();    
	$u2 = getusers();    
	pop @$u1;

will modify $u2 as well as $u1, because both variables are references
to the same array.  Had C<getusers> not been memoized, $u1 and $u2
would have referred to different arrays.

=item * 

Do not memoize a very simple function.

Recently someone mentioned to me that the Memoize module made his
program run slower instead of faster.  It turned out that he was
memoizing the following function:

    sub square {
      $_[0] * $_[0];
    }

I pointed out that C<Memoize> uses a hash, and that looking up a
number in the hash is necessarily going to take a lot longer than a
single multiplication.  There really is no way to speed up the
C<square> function.

Memoization is not magical.

=back

=head1 PERSISTENT CACHE SUPPORT

You can tie the cache tables to any sort of tied hash that you want
to, as long as it supports C<TIEHASH>, C<FETCH>, C<STORE>, and
C<EXISTS>.  For example,

        tie my %cache => 'GDBM_File', $filename, O_RDWR|O_CREAT, 0666;
        memoize 'function', SCALAR_CACHE => [HASH => \%cache];

works just fine.  For some storage methods, you need a little glue.

C<SDBM_File> doesn't supply an C<EXISTS> method, so included in this
package is a glue module called C<Memoize::SDBM_File> which does
provide one.  Use this instead of plain C<SDBM_File> to store your
cache table on disk in an C<SDBM_File> database:

        tie my %cache => 'Memoize::SDBM_File', $filename, O_RDWR|O_CREAT, 0666;
        memoize 'function', SCALAR_CACHE => [HASH => \%cache];

C<NDBM_File> has the same problem and the same solution.  (Use
C<Memoize::NDBM_File instead of plain NDBM_File.>)

C<Storable> isn't a tied hash class at all.  You can use it to store a
hash to disk and retrieve it again, but you can't modify the hash while
it's on the disk.  So if you want to store your cache table in a
C<Storable> database, use C<Memoize::Storable>, which puts a hashlike
front-end onto C<Storable>.  The hash table is actually kept in
memory, and is loaded from your C<Storable> file at the time you
memoize the function, and stored back at the time you unmemoize the
function (or when your program exits):

        tie my %cache => 'Memoize::Storable', $filename;
	memoize 'function', SCALAR_CACHE => [HASH => \%cache];

        tie my %cache => 'Memoize::Storable', $filename, 'nstore';
	memoize 'function', SCALAR_CACHE => [HASH => \%cache];

Include the `nstore' option to have the C<Storable> database written
in `network order'.  (See L<Storable> for more details about this.)

The C<flush_cache()> function will raise a run-time error unless the
tied package provides a C<CLEAR> method.

=head1 EXPIRATION SUPPORT

See Memoize::Expire, which is a plug-in module that adds expiration
functionality to Memoize.  If you don't like the kinds of policies
that Memoize::Expire implements, it is easy to write your own plug-in
module to implement whatever policy you desire.  Memoize comes with
several examples.  An expiration manager that implements a LRU policy
is available on CPAN as Memoize::ExpireLRU.

=head1 BUGS

The test suite is much better, but always needs improvement.

There is some problem with the way C<goto &f> works under threaded
Perl, perhaps because of the lexical scoping of C<@_>.  This is a bug
in Perl, and until it is resolved, memoized functions will see a
slightly different C<caller()> and will perform a little more slowly
on threaded perls than unthreaded perls.

Some versions of C<DB_File> won't let you store data under a key of
length 0.  That means that if you have a function C<f> which you
memoized and the cache is in a C<DB_File> database, then the value of
C<f()> (C<f> called with no arguments) will not be memoized.  If this
is a big problem, you can supply a normalizer function that prepends
C<"x"> to every key.

=head1 MAILING LIST

To join a very low-traffic mailing list for announcements about
C<Memoize>, send an empty note to C<mjd-perl-memoize-request@plover.com>.

=head1 AUTHOR

Mark-Jason Dominus (C<mjd-perl-memoize+@plover.com>), Plover Systems co.

See the C<Memoize.pm> Page at http://perl.plover.com/Memoize/
for news and upgrades.  Near this page, at
http://perl.plover.com/MiniMemoize/ there is an article about
memoization and about the internals of Memoize that appeared in The
Perl Journal, issue #13.  (This article is also included in the
Memoize distribution as `article.html'.)

The author's book I<Higher-Order Perl> (2005, ISBN 1558607013, published
by Morgan Kaufmann) discusses memoization (and many other 
topics) in tremendous detail. It is available on-line for free.
For more information, visit http://hop.perl.plover.com/ .

To join a mailing list for announcements about C<Memoize>, send an
empty message to C<mjd-perl-memoize-request@plover.com>.  This mailing
list is for announcements only and has extremely low traffic---fewer than
two messages per year.

=head1 COPYRIGHT AND LICENSE

Copyright 1998, 1999, 2000, 2001, 2012  by Mark Jason Dominus

This library is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.

=head1 THANK YOU

Many thanks to Florian Ragwitz for administration and packaging
assistance, to John Tromp for bug reports, to Jonathan Roy for bug reports
and suggestions, to Michael Schwern for other bug reports and patches,
to Mike Cariaso for helping me to figure out the Right Thing to Do
About Expiration, to Joshua Gerth, Joshua Chamas, Jonathan Roy
(again), Mark D. Anderson, and Andrew Johnson for more suggestions
about expiration, to Brent Powers for the Memoize::ExpireLRU module,
to Ariel Scolnicov for delightful messages about the Fibonacci
function, to Dion Almaer for thought-provoking suggestions about the
default normalizer, to Walt Mankowski and Kurt Starsinic for much help
investigating problems under threaded Perl, to Alex Dudkevich for
reporting the bug in prototyped functions and for checking my patch,
to Tony Bass for many helpful suggestions, to Jonathan Roy (again) for
finding a use for C<unmemoize()>, to Philippe Verdret for enlightening
discussion of C<Hook::PrePostCall>, to Nat Torkington for advice I
ignored, to Chris Nandor for portability advice, to Randal Schwartz
for suggesting the 'C<flush_cache> function, and to Jenda Krynicky for
being a light in the world.

Special thanks to Jarkko Hietaniemi, the 5.8.0 pumpking, for including
this module in the core and for his patient and helpful guidance
during the integration process.

=cut
                                                                                                                                                                   usr/share/perl/5.20.2/Module/                                                                       0040755 0000000 0000000 00000000000 13077704254 014107  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Module/Build/                                                                 0040755 0000000 0000000 00000000000 13077704254 015146  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Module/Build/API.pod                                                          0100644 0000000 0000000 00000206123 12744441327 016263  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

Module::Build::API - API Reference for Module Authors

=for :stopwords apache bsd distdir distsign gpl installdirs lgpl mit mozilla packlists

=head1 DESCRIPTION

I list here some of the most important methods in C<Module::Build>.
Normally you won't need to deal with these methods unless you want to
subclass C<Module::Build>.  But since one of the reasons I created
this module in the first place was so that subclassing is possible
(and easy), I will certainly write more docs as the interface
stabilizes.


=head2 CONSTRUCTORS

=over 4

=item current()

[version 0.20]

This method returns a reasonable facsimile of the currently-executing
C<Module::Build> object representing the current build.  You can use
this object to query its L</notes()> method, inquire about installed
modules, and so on.  This is a great way to share information between
different parts of your build process.  For instance, you can ask
the user a question during C<perl Build.PL>, then use their answer
during a regression test:

  # In Build.PL:
  my $color = $build->prompt("What is your favorite color?");
  $build->notes(color => $color);

  # In t/colortest.t:
  use Module::Build;
  my $build = Module::Build->current;
  my $color = $build->notes('color');
  ...

The way the C<current()> method is currently implemented, there may be
slight differences between the C<$build> object in Build.PL and the
one in C<t/colortest.t>.  It is our goal to minimize these differences
in future releases of Module::Build, so please report any anomalies
you find.

One important caveat: in its current implementation, C<current()> will
B<NOT> work correctly if you have changed out of the directory that
C<Module::Build> was invoked from.

=item new()

[version 0.03]

Creates a new Module::Build object.  Arguments to the new() method are
listed below.  Most arguments are optional, but you must provide
either the L</module_name> argument, or L</dist_name> and one of
L</dist_version> or L</dist_version_from>.  In other words, you must
provide enough information to determine both a distribution name and
version.


=over 4

=item add_to_cleanup

[version 0.19]

An array reference of files to be cleaned up when the C<clean> action
is performed. See also the L<add_to_cleanup()|/"add_to_cleanup(@files)">
method.

=item allow_pureperl

[version 0.4005]

A bool indicating the module is still functional without its xs parts.
When an XS module is build with --pureperl_only, it will otherwise fail.

=item auto_configure_requires

[version 0.34]

This parameter determines whether Module::Build will add itself
automatically to configure_requires (and build_requires) if Module::Build
is not already there.  The required version will be the last 'major' release,
as defined by the decimal version truncated to two decimal places (e.g. 0.34,
instead of 0.3402).  The default value is true.

=item auto_features

[version 0.26]

This parameter supports the setting of features (see
L</feature($name)>) automatically based on a set of prerequisites.  For
instance, for a module that could optionally use either MySQL or
PostgreSQL databases, you might use C<auto_features> like this:

  my $build = Module::Build->new
    (
     ...other stuff here...
     auto_features => {
       pg_support    => {
                         description => "Interface with Postgres databases",
                         requires    => { 'DBD::Pg' => 23.3,
                                          'DateTime::Format::Pg' => 0 },
                        },
       mysql_support => {
                         description => "Interface with MySQL databases",
                         requires    => { 'DBD::mysql' => 17.9,
                                          'DateTime::Format::MySQL' => 0 },
                        },
     }
    );

For each feature named, the required prerequisites will be checked, and
if there are no failures, the feature will be enabled (set to C<1>).
Otherwise the failures will be displayed to the user and the feature
will be disabled (set to C<0>).

See the documentation for L</requires> for the details of how
requirements can be specified.

=item autosplit

[version 0.04]

An optional C<autosplit> argument specifies a file which should be run
through the L<AutoSplit::autosplit()|AutoSplit/autosplit> function.
If multiple files should be split, the argument may be given as an
array of the files to split.

In general I don't consider autosplitting a great idea, because it's
not always clear that autosplitting achieves its intended performance
benefits.  It may even harm performance in environments like mod_perl,
where as much as possible of a module's code should be loaded during
startup.

=item build_class

[version 0.28]

The Module::Build class or subclass to use in the build script.
Defaults to "Module::Build" or the class name passed to or created by
a call to L</subclass()>.  This property is useful if you're
writing a custom Module::Build subclass and have a bootstrapping
problem--that is, your subclass requires modules that may not be
installed when C<perl Build.PL> is executed, but you've listed in
L</build_requires> so that they should be available when C<./Build> is
executed.

=item build_requires

[version 0.07]

Modules listed in this section are necessary to build and install the
given module, but are not necessary for regular usage of it.  This is
actually an important distinction - it allows for tighter control over
the body of installed modules, and facilitates correct dependency
checking on binary/packaged distributions of the module.

See the documentation for L<Module::Build::Authoring/"PREREQUISITES">
for the details of how requirements can be specified.

=item configure_requires

[version 0.30]

Modules listed in this section must be installed I<before> configuring
this distribution (i.e. before running the F<Build.PL> script).
This might be a specific minimum version of C<Module::Build> or any
other module the F<Build.PL> needs in order to do its stuff.  Clients
like C<CPAN.pm> or C<CPANPLUS> will be expected to pick
C<configure_requires> out of the F<META.yml> file and install these
items before running the C<Build.PL>.

Module::Build may automatically add itself to configure_requires.
See L</auto_configure_requires> for details.

See the documentation for L<Module::Build::Authoring/"PREREQUISITES">
for the details of how requirements can be specified.

=item test_requires

[version 0.4004]

Modules listed in this section must be installed before testing the distribution.

See the documentation for L<Module::Build::Authoring/"PREREQUISITES">
for the details of how requirements can be specified.

=item create_packlist

[version 0.28]

If true, this parameter tells Module::Build to create a F<.packlist>
file during the C<install> action, just like C<ExtUtils::MakeMaker> does.
The file is created in a subdirectory of the C<arch> installation
location.  It is used by some other tools (CPAN, CPANPLUS, etc.) for
determining what files are part of an install.

The default value is true.  This parameter was introduced in
Module::Build version 0.2609; previously no packlists were ever
created by Module::Build.

=item c_source

[version 0.04]

An optional C<c_source> argument specifies a directory which contains
C source files that the rest of the build may depend on.  Any C<.c>
files in the directory will be compiled to object files.  The
directory will be added to the search path during the compilation and
linking phases of any C or XS files.

[version 0.3604]

A list of directories can be supplied using an anonymous array
reference of strings.

=item conflicts

[version 0.07]

Modules listed in this section conflict in some serious way with the
given module.  C<Module::Build> (or some higher-level tool) will
refuse to install the given module if the given module/version is also
installed.

See the documentation for L<Module::Build::Authoring/"PREREQUISITES">
for the details of how requirements can be specified.

=item create_license

[version 0.31]

This parameter tells Module::Build to automatically create a
F<LICENSE> file at the top level of your distribution, containing the
full text of the author's chosen license.  This requires
C<Software::License> on the author's machine, and further requires
that the C<license> parameter specifies a license that it knows about.

=item create_makefile_pl

[version 0.19]

This parameter lets you use C<Module::Build::Compat> during the
C<distdir> (or C<dist>) action to automatically create a Makefile.PL
for compatibility with C<ExtUtils::MakeMaker>.  The parameter's value
should be one of the styles named in the L<Module::Build::Compat>
documentation.

=item create_readme

[version 0.22]

This parameter tells Module::Build to automatically create a F<README>
file at the top level of your distribution.  Currently it will simply
use C<Pod::Text> (or C<Pod::Readme> if it's installed) on the file
indicated by C<dist_version_from> and put the result in the F<README>
file.  This is by no means the only recommended style for writing a
F<README>, but it seems to be one common one used on the CPAN.

If you generate a F<README> in this way, it's probably a good idea to
create a separate F<INSTALL> file if that information isn't in the
generated F<README>.

=item dist_abstract

[version 0.20]

This should be a short description of the distribution.  This is used when
generating metadata for F<META.yml> and PPD files.  If it is not given
then C<Module::Build> looks in the POD of the module from which it gets
the distribution's version.  If it finds a POD section marked "=head1
NAME", then it looks for the first line matching C<\s+-\s+(.+)>,
and uses the captured text as the abstract.

=item dist_author

[version 0.20]

This should be something like "John Doe <jdoe@example.com>", or if
there are multiple authors, an anonymous array of strings may be
specified.  This is used when generating metadata for F<META.yml> and
PPD files.  If this is not specified, then C<Module::Build> looks at
the module from which it gets the distribution's version.  If it finds
a POD section marked "=head1 AUTHOR", then it uses the contents of
this section.

=item dist_name

[version 0.11]

Specifies the name for this distribution.  Most authors won't need to
set this directly, they can use C<module_name> to set C<dist_name> to
a reasonable default.  However, some agglomerative distributions like
C<libwww-perl> or C<bioperl> have names that don't correspond directly
to a module name, so C<dist_name> can be set independently.

=item dist_suffix

[version 0.37]

Specifies an optional suffix to include after the version number
in the distribution directory (and tarball) name.  The only suffix
currently recognized by PAUSE is 'TRIAL', which indicates that the
distribution should not be indexed.  For example:

  Foo-Bar-1.23-TRIAL.tar.gz

This will automatically do the "right thing" depending on C<dist_version> and
C<release_status>.  When C<dist_version> does not have an underscore and
C<release_status> is not 'stable', then C<dist_suffix> will default to 'TRIAL'.
Otherwise it will default to the empty string, disabling the suffix.  

In general, authors should only set this if they B<must> override the default
behavior for some particular purpose.

=item dist_version

[version 0.11]

Specifies a version number for the distribution.  See L</module_name>
or L</dist_version_from> for ways to have this set automatically from a
C<$VERSION> variable in a module.  One way or another, a version
number needs to be set.

=item dist_version_from

[version 0.11]

Specifies a file to look for the distribution version in.  Most
authors won't need to set this directly, they can use L</module_name>
to set it to a reasonable default.

The version is extracted from the specified file according to the same
rules as L<ExtUtils::MakeMaker> and C<CPAN.pm>.  It involves finding
the first line that matches the regular expression

   /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/

eval()-ing that line, then checking the value of the C<$VERSION>
variable.  Quite ugly, really, but all the modules on CPAN depend on
this process, so there's no real opportunity to change to something
better.

If the target file of L</dist_version_from> contains more than one package
declaration, the version returned will be the one matching the configured
L</module_name>.

=item dynamic_config

[version 0.07]

A boolean flag indicating whether the F<Build.PL> file must be
executed, or whether this module can be built, tested and installed
solely from consulting its metadata file.  The main reason to set this
to a true value is that your module performs some dynamic
configuration as part of its build/install process.  If the flag is
omitted, the F<META.yml> spec says that installation tools should
treat it as 1 (true), because this is a safer way to behave.

Currently C<Module::Build> doesn't actually do anything with this flag
- it's up to higher-level tools like C<CPAN.pm> to do something useful
with it.  It can potentially bring lots of security, packaging, and
convenience improvements.

=item extra_compiler_flags

=item extra_linker_flags

[version 0.19]

These parameters can contain array references (or strings, in which
case they will be split into arrays) to pass through to the compiler
and linker phases when compiling/linking C code.  For example, to tell
the compiler that your code is C++, you might do:

  my $build = Module::Build->new
    (
     module_name          => 'Foo::Bar',
     extra_compiler_flags => ['-x', 'c++'],
    );

To link your XS code against glib you might write something like:

  my $build = Module::Build->new
    (
     module_name          => 'Foo::Bar',
     dynamic_config       => 1,
     extra_compiler_flags => scalar `glib-config --cflags`,
     extra_linker_flags   => scalar `glib-config --libs`,
    );

=item extra_manify_args

[version 0.4006]

Any extra arguments to pass to C<< Pod::Man->new() >> when building
man pages.  One common choice might be C<< utf8 => 1 >> to get Unicode
support.

=item get_options

[version 0.26]

You can pass arbitrary command line options to F<Build.PL> or
F<Build>, and they will be stored in the Module::Build object and can
be accessed via the L</args()> method.  However, sometimes you want
more flexibility out of your argument processing than this allows.  In
such cases, use the C<get_options> parameter to pass in a hash
reference of argument specifications, and the list of arguments to
F<Build.PL> or F<Build> will be processed according to those
specifications before they're passed on to C<Module::Build>'s own
argument processing.

The supported option specification hash keys are:


=over 4

=item type

The type of option.  The types are those supported by Getopt::Long; consult
its documentation for a complete list.  Typical types are C<=s> for strings,
C<+> for additive options, and C<!> for negatable options.  If the
type is not specified, it will be considered a boolean, i.e. no
argument is taken and a value of 1 will be assigned when the option is
encountered.

=item store

A reference to a scalar in which to store the value passed to the option.
If not specified, the value will be stored under the option name in the
hash returned by the C<args()> method.

=item default

A default value for the option.  If no default value is specified and no option
is passed, then the option key will not exist in the hash returned by
C<args()>.

=back


You can combine references to your own variables or subroutines with
unreferenced specifications, for which the result will also be stored in the
hash returned by C<args()>.  For example:

  my $loud = 0;
  my $build = Module::Build->new
    (
     module_name => 'Foo::Bar',
     get_options => {
                     Loud =>     { store => \$loud },
                     Dbd  =>     { type  => '=s'   },
                     Quantity => { type  => '+'    },
                    }
    );

  print STDERR "HEY, ARE YOU LISTENING??\n" if $loud;
  print "We'll use the ", $build->args('Dbd'), " DBI driver\n";
  print "Are you sure you want that many?\n"
    if $build->args('Quantity') > 2;

The arguments for such a specification can be called like so:

  perl Build.PL --Loud --Dbd=DBD::pg --Quantity --Quantity --Quantity

B<WARNING:> Any option specifications that conflict with Module::Build's own
options (defined by its properties) will throw an exception.  Use capitalized
option names to avoid unintended conflicts with future Module::Build options.

Consult the Getopt::Long documentation for details on its usage.

=item include_dirs

[version 0.24]

Specifies any additional directories in which to search for C header
files.  May be given as a string indicating a single directory, or as
a list reference indicating multiple directories.

=item install_path

[version 0.19]

You can set paths for individual installable elements by using the
C<install_path> parameter:

  my $build = Module::Build->new
    (
     ...other stuff here...
     install_path => {
                      lib  => '/foo/lib',
                      arch => '/foo/lib/arch',
                     }
    );

=item installdirs

[version 0.19]

Determines where files are installed within the normal perl hierarchy
as determined by F<Config.pm>.  Valid values are: C<core>, C<site>,
C<vendor>.  The default is C<site>.  See
L<Module::Build/"INSTALL PATHS">

=item license

[version 0.07]

Specifies the licensing terms of your distribution.

As of Module::Build version 0.36_14, you may use a L<Software::License>
subclass name (e.g. 'Apache_2_0') instead of one of the keys below.

The legacy list of valid license values include:

=over 4

=item apache

The distribution is licensed under the Apache License, Version 2.0
(L<http://apache.org/licenses/LICENSE-2.0>).

=item apache_1_1

The distribution is licensed under the Apache Software License, Version 1.1
(L<http://apache.org/licenses/LICENSE-1.1>).

=item artistic

The distribution is licensed under the Artistic License, as specified
by the F<Artistic> file in the standard Perl distribution.

=item artistic_2

The distribution is licensed under the Artistic 2.0 License
(L<http://opensource.org/licenses/artistic-license-2.0.php>.)

=item bsd

The distribution is licensed under the BSD License
(L<http://www.opensource.org/licenses/bsd-license.php>).

=item gpl

The distribution is licensed under the terms of the GNU General
Public License (L<http://www.opensource.org/licenses/gpl-license.php>).

=item lgpl

The distribution is licensed under the terms of the GNU Lesser
General Public License
(L<http://www.opensource.org/licenses/lgpl-license.php>).

=item mit

The distribution is licensed under the MIT License
(L<http://opensource.org/licenses/mit-license.php>).

=item mozilla

The distribution is licensed under the Mozilla Public
License.  (L<http://opensource.org/licenses/mozilla1.0.php> or
L<http://opensource.org/licenses/mozilla1.1.php>)

=item open_source

The distribution is licensed under some other Open Source
Initiative-approved license listed at
L<http://www.opensource.org/licenses/>.

=item perl

The distribution may be copied and redistributed under the same terms
as Perl itself (this is by far the most common licensing option for
modules on CPAN).  This is a dual license, in which the user may
choose between either the GPL or the Artistic license.

=item restrictive

The distribution may not be redistributed without special permission
from the author and/or copyright holder.

=item unrestricted

The distribution is licensed under a license that is B<not> approved
by www.opensource.org but that allows distribution without
restrictions.

=back

Note that you must still include the terms of your license in your
code and documentation - this field only sets the information that is included
in distribution metadata to let automated tools figure out your
licensing restrictions.  Humans still need something to read.  If you
choose to provide this field, you should make sure that you keep it in
sync with your written documentation if you ever change your licensing
terms.

You may also use a license type of C<unknown> if you don't wish to
specify your terms in the metadata.

Also see the C<create_license> parameter.

=item meta_add

[version 0.28]

A hash of key/value pairs that should be added to the F<META.yml> file
during the C<distmeta> action.  Any existing entries with the same
names will be overridden.

See the L</"MODULE METADATA"> section for details.

=item meta_merge

[version 0.28]

A hash of key/value pairs that should be merged into the F<META.yml>
file during the C<distmeta> action.  Any existing entries with the
same names will be overridden.

The only difference between C<meta_add> and C<meta_merge> is their
behavior on hash-valued and array-valued entries: C<meta_add> will
completely blow away the existing hash or array value, but
C<meta_merge> will merge the supplied data into the existing hash or
array value.

See the L</"MODULE METADATA"> section for details.

=item module_name

[version 0.03]

The C<module_name> is a shortcut for setting default values of
C<dist_name> and C<dist_version_from>, reflecting the fact that the
majority of CPAN distributions are centered around one "main" module.
For instance, if you set C<module_name> to C<Foo::Bar>, then
C<dist_name> will default to C<Foo-Bar> and C<dist_version_from> will
default to C<lib/Foo/Bar.pm>.  C<dist_version_from> will in turn be
used to set C<dist_version>.

Setting C<module_name> won't override a C<dist_*> parameter you
specify explicitly.

=item needs_compiler

[version 0.36]

The C<needs_compiler> parameter indicates whether a compiler is required to
build the distribution.  The default is false, unless XS files are found or
the C<c_source> parameter is set, in which case it is true.  If true,
L<ExtUtils::CBuilder> is automatically added to C<build_requires> if needed.

For a distribution where a compiler is I<optional>, e.g. a dual XS/pure-Perl
distribution, C<needs_compiler> should explicitly be set to a false value.

=item PL_files

[version 0.06]

An optional parameter specifying a set of C<.PL> files in your
distribution.  These will be run as Perl scripts prior to processing
the rest of the files in your distribution with the name of the file
they're generating as an argument.  They are usually used as templates
for creating other files dynamically, so that a file like
C<lib/Foo/Bar.pm.PL> might create the file C<lib/Foo/Bar.pm>.

The files are specified with the C<.PL> files as hash keys, and the
file(s) they generate as hash values, like so:

  my $build = Module::Build->new
    (
     module_name => 'Foo::Bar',
     ...
     PL_files => { 'lib/Foo/Bar.pm.PL' => 'lib/Foo/Bar.pm' },
    );

Note that the path specifications are I<always> given in Unix-like
format, not in the style of the local system.

If your C<.PL> scripts don't create any files, or if they create files
with unexpected names, or even if they create multiple files, you can
indicate that so that Module::Build can properly handle these created
files:

  PL_files => {
               'lib/Foo/Bar.pm.PL' => 'lib/Foo/Bar.pm',
               'lib/something.PL'  => ['/lib/something', '/lib/else'],
               'lib/funny.PL'      => [],
              }

Here's an example of a simple PL file.

    my $output_file = shift;
    open my $fh, ">", $output_file or die "Can't open $output_file: $!";

    print $fh <<'END';
    #!/usr/bin/perl

    print "Hello, world!\n";
    END

PL files are not installed by default, so its safe to put them in
F<lib/> and F<bin/>.


=item pm_files

[version 0.19]

An optional parameter specifying the set of C<.pm> files in this
distribution, specified as a hash reference whose keys are the files'
locations in the distributions, and whose values are their logical
locations based on their package name, i.e. where they would be found
in a "normal" Module::Build-style distribution.  This parameter is
mainly intended to support alternative layouts of files.

For instance, if you have an old-style C<MakeMaker> distribution for a
module called C<Foo::Bar> and a F<Bar.pm> file at the top level of the
distribution, you could specify your layout in your C<Build.PL> like
this:

  my $build = Module::Build->new
    (
     module_name => 'Foo::Bar',
     ...
     pm_files => { 'Bar.pm' => 'lib/Foo/Bar.pm' },
    );

Note that the values should include C<lib/>, because this is where
they would be found in a "normal" Module::Build-style distribution.

Note also that the path specifications are I<always> given in
Unix-like format, not in the style of the local system.

=item pod_files

[version 0.19]

Just like C<pm_files>, but used for specifying the set of C<.pod>
files in your distribution.

=item recommends

[version 0.08]

This is just like the L</requires> argument, except that modules listed
in this section aren't essential, just a good idea.  We'll just print
a friendly warning if one of these modules aren't found, but we'll
continue running.

If a module is recommended but not required, all tests should still
pass if the module isn't installed.  This may mean that some tests
may be skipped if recommended dependencies aren't present.

Automated tools like CPAN.pm should inform the user when recommended
modules aren't installed, and it should offer to install them if it
wants to be helpful.

See the documentation for L<Module::Build::Authoring/"PREREQUISITES">
for the details of how requirements can be specified.

=item recursive_test_files

[version 0.28]

Normally, C<Module::Build> does not search subdirectories when looking
for tests to run. When this options is set it will search recursively
in all subdirectories of the standard 't' test directory.

=item release_status

[version 0.37]

The CPAN Meta Spec version 2 adds C<release_status> to allow authors
to specify how a distribution should be indexed.  Consistent with the
spec, this parameter can only have one three values: 'stable',
'testing' or 'unstable'.

Unless explicitly set by the author, C<release_status> will default
to 'stable' unless C<dist_version> contains an underscore, in which
case it will default to 'testing'.

It is an error to specify a C<release_status> of 'stable' when
C<dist_version> contains an underscore character.

=item requires

[version 0.07]

An optional C<requires> argument specifies any module prerequisites
that the current module depends on.

One note: currently C<Module::Build> doesn't actually I<require> the
user to have dependencies installed, it just strongly urges.  In the
future we may require it.  There's also a L</recommends> section for
things that aren't absolutely required.

Automated tools like CPAN.pm should refuse to install a module if one
of its dependencies isn't satisfied, unless a "force" command is given
by the user.  If the tools are helpful, they should also offer to
install the dependencies.

A synonym for C<requires> is C<prereq>, to help succour people
transitioning from C<ExtUtils::MakeMaker>.  The C<requires> term is
preferred, but the C<prereq> term will remain valid in future
distributions.

See the documentation for L<Module::Build::Authoring/"PREREQUISITES">
for the details of how requirements can be specified.

=item script_files

[version 0.18]

An optional parameter specifying a set of files that should be
installed as executable Perl scripts when the module is installed.
May be given as an array reference of the files, as a hash reference
whose keys are the files (and whose values will currently be ignored),
as a string giving the name of a directory in which to find scripts,
or as a string giving the name of a single script file.

The default is to install any scripts found in a F<bin> directory at
the top level of the distribution, minus any keys of L<PL_files>.

For backward compatibility, you may use the parameter C<scripts>
instead of C<script_files>.  Please consider this usage deprecated,
though it will continue to exist for several version releases.

=item share_dir

[version 0.36]

An optional parameter specifying directories of static data files to
be installed as read-only files for use with L<File::ShareDir>.  The
C<share_dir> property supports both distribution-level and
module-level share files.

The simplest use of C<share_dir> is to set it to a directory name or an
arrayref of directory names containing files to be installed in the
distribution-level share directory.

  share_dir => 'share'

Alternatively, if C<share_dir> is a hashref, it may have C<dist> or
C<module> keys providing full flexibility in defining how share
directories should be installed.

  share_dir => {
    dist => [ 'examples', 'more_examples' ],
    module => {
      Foo::Templates => ['share/html', 'share/text'],
      Foo::Config    => 'share/config',
    }
  }

If C<share_dir> is set, then File::ShareDir will automatically be added
to the C<requires> hash.

=item sign

[version 0.16]

If a true value is specified for this parameter, L<Module::Signature>
will be used (via the 'distsign' action) to create a SIGNATURE file
for your distribution during the 'distdir' action, and to add the
SIGNATURE file to the MANIFEST (therefore, don't add it yourself).

The default value is false.  In the future, the default may change to
true if you have C<Module::Signature> installed on your system.

=item tap_harness_args

[version 0.2808_03]

An optional parameter specifying parameters to be passed to TAP::Harness when
running tests. Must be given as a hash reference of parameters; see the
L<TAP::Harness|TAP::Harness> documentation for details. Note that specifying
this parameter will implicitly set C<use_tap_harness> to a true value. You
must therefore be sure to add TAP::Harness as a requirement for your module in
L</build_requires>.

=item test_files

[version 0.23]

An optional parameter specifying a set of files that should be used as
C<Test::Harness>-style regression tests to be run during the C<test>
action.  May be given as an array reference of the files, or as a hash
reference whose keys are the files (and whose values will currently be
ignored).  If the argument is given as a single string (not in an
array reference), that string will be treated as a C<glob()> pattern
specifying the files to use.

The default is to look for a F<test.pl> script in the top-level
directory of the distribution, and any files matching the glob pattern
C<*.t> in the F<t/> subdirectory.  If the C<recursive_test_files>
property is true, then the C<t/> directory will be scanned recursively
for C<*.t> files.

=item use_tap_harness

[version 0.2808_03]

An optional parameter indicating whether or not to use TAP::Harness for
testing rather than Test::Harness. Defaults to false. If set to true, you must
therefore be sure to add TAP::Harness as a requirement for your module in
L</build_requires>. Implicitly set to a true value if C<tap_harness_args> is
specified.

=item xs_files

[version 0.19]

Just like C<pm_files>, but used for specifying the set of C<.xs>
files in your distribution.

=back


=item new_from_context(%args)

[version 0.28]

When called from a directory containing a F<Build.PL> script (in other words,
the base directory of a distribution), this method will run the F<Build.PL> and
call C<resume()> to return the resulting C<Module::Build> object to the caller.
Any key-value arguments given to C<new_from_context()> are essentially like
command line arguments given to the F<Build.PL> script, so for example you
could pass C<< verbose => 1 >> to this method to turn on verbosity.

=item resume()

[version 0.03]

You'll probably never call this method directly, it's only called from the
auto-generated C<Build> script (and the C<new_from_context> method).  The
C<new()> method is only called once, when the user runs C<perl Build.PL>.
Thereafter, when the user runs C<Build test> or another action, the
C<Module::Build> object is created using the C<resume()> method to
re-instantiate with the settings given earlier to C<new()>.

=item subclass()

[version 0.06]

This creates a new C<Module::Build> subclass on the fly, as described
in the L<Module::Build::Authoring/"SUBCLASSING"> section.  The caller
must provide either a C<class> or C<code> parameter, or both.  The
C<class> parameter indicates the name to use for the new subclass, and
defaults to C<MyModuleBuilder>.  The C<code> parameter specifies Perl
code to use as the body of the subclass.

=item add_property

[version 0.31]

  package 'My::Build';
  use base 'Module::Build';
  __PACKAGE__->add_property( 'pedantic' );
  __PACKAGE__->add_property( answer => 42 );
  __PACKAGE__->add_property(
     'epoch',
      default => sub { time },
      check   => sub {
          return 1 if /^\d+$/;
          shift->property_error( "'$_' is not an epoch time" );
          return 0;
      },
  );

Adds a property to a Module::Build class. Properties are those attributes of a
Module::Build object which can be passed to the constructor and which have
accessors to get and set them. All of the core properties, such as
C<module_name> and C<license>, are defined using this class method.

The first argument to C<add_property()> is always the name of the property.
The second argument can be either a default value for the property, or a list
of key/value pairs. The supported keys are:

=over

=item C<default>

The default value. May optionally be specified as a code reference, in which
case the return value from the execution of the code reference will be used.
If you need the default to be a code reference, just use a code reference to
return it, e.g.:

      default => sub { sub { ... } },

=item C<check>

A code reference that checks that a value specified for the property is valid.
During the execution of the code reference, the new value will be included in
the C<$_> variable. If the value is correct, the C<check> code reference
should return true. If the value is not correct, it sends an error message to
C<property_error()> and returns false.

=back

When this method is called, a new property will be installed in the
Module::Build class, and an accessor will be built to allow the property to be
get or set on the build object.

  print $build->pedantic, $/;
  $build->pedantic(0);

If the default value is a hash reference, this generates a special-case
accessor method, wherein individual key/value pairs may be set or fetched:

  print "stuff{foo} is: ", $build->stuff( 'foo' ), $/;
  $build->stuff( foo => 'bar' );
  print $build->stuff( 'foo' ), $/; # Outputs "bar"

Of course, you can still set the entire hash reference at once, as well:

  $build->stuff( { foo => 'bar', baz => 'yo' } );

In either case, if a C<check> has been specified for the property, it will be
applied to the entire hash. So the check code reference should look something
like:

      check => sub {
            return 1 if defined $_ && exists $_->{foo};
            shift->property_error(qq{Property "stuff" needs "foo"});
            return 0;
      },

=item property_error

[version 0.31]

=back


=head2 METHODS

=over 4

=item add_build_element($type)

[version 0.26]

Adds a new type of entry to the build process.  Accepts a single
string specifying its type-name.  There must also be a method defined
to process things of that type, e.g. if you add a build element called
C<'foo'>, then you must also define a method called
C<process_foo_files()>.

See also
L<Module::Build::Cookbook/"Adding new file types to the build process">.

=item add_to_cleanup(@files)

[version 0.03]

You may call C<< $self->add_to_cleanup(@patterns) >> to tell
C<Module::Build> that certain files should be removed when the user
performs the C<Build clean> action.  The arguments to the method are
patterns suitable for passing to Perl's C<glob()> function, specified
in either Unix format or the current machine's native format.  It's
usually convenient to use Unix format when you hard-code the filenames
(e.g. in F<Build.PL>) and the native format when the names are
programmatically generated (e.g. in a testing script).

I decided to provide a dynamic method of the C<$build> object, rather
than just use a static list of files named in the F<Build.PL>, because
these static lists can get difficult to manage.  I usually prefer to
keep the responsibility for registering temporary files close to the
code that creates them.

=item args()

[version 0.26]

  my $args_href = $build->args;
  my %args = $build->args;
  my $arg_value = $build->args($key);
  $build->args($key, $value);

This method is the preferred interface for retrieving the arguments passed via
command line options to F<Build.PL> or F<Build>, minus the Module-Build
specific options.

When called in a scalar context with no arguments, this method returns a
reference to the hash storing all of the arguments; in an array context, it
returns the hash itself.  When passed a single argument, it returns the value
stored in the args hash for that option key.  When called with two arguments,
the second argument is assigned to the args hash under the key passed as the
first argument.

=item autosplit_file($from, $to)

[version 0.28]

Invokes the L<AutoSplit> module on the C<$from> file, sending the
output to the C<lib/auto> directory inside C<$to>.  C<$to> is
typically the C<blib/> directory.

=item base_dir()

[version 0.14]

Returns a string containing the root-level directory of this build,
i.e. where the C<Build.PL> script and the C<lib> directory can be
found.  This is usually the same as the current working directory,
because the C<Build> script will C<chdir()> into this directory as
soon as it begins execution.

=item build_requires()

[version 0.21]

Returns a hash reference indicating the C<build_requires>
prerequisites that were passed to the C<new()> method.

=item can_action( $action )

Returns a reference to the method that defines C<$action>, or false
otherwise. This is handy for actions defined (or maybe not!) in subclasses.

[version 0.32_xx]

=item cbuilder()

[version 0.2809]

Returns the internal ExtUtils::CBuilder object that can be used for
compiling & linking C code.  If no such object is available (e.g. if
the system has no compiler installed) an exception will be thrown.

=item check_installed_status($module, $version)

[version 0.11]

This method returns a hash reference indicating whether a version
dependency on a certain module is satisfied.  The C<$module> argument
is given as a string like C<"Data::Dumper"> or C<"perl">, and the
C<$version> argument can take any of the forms described in L</requires>
above.  This allows very fine-grained version checking.

The returned hash reference has the following structure:

  {
   ok => $whether_the_dependency_is_satisfied,
   have => $version_already_installed,
   need => $version_requested, # Same as incoming $version argument
   message => $informative_error_message,
  }

If no version of C<$module> is currently installed, the C<have> value
will be the string C<< "<none>" >>.  Otherwise the C<have> value will
simply be the version of the installed module.  Note that this means
that if C<$module> is installed but doesn't define a version number,
the C<have> value will be C<undef> - this is why we don't use C<undef>
for the case when C<$module> isn't installed at all.

This method may be called either as an object method
(C<< $build->check_installed_status($module, $version) >>)
or as a class method
(C<< Module::Build->check_installed_status($module, $version) >>).

=item check_installed_version($module, $version)

[version 0.05]

Like L<check_installed_status()|/"check_installed_status($module, $version)">,
but simply returns true or false depending on whether module
C<$module> satisfies the dependency C<$version>.

If the check succeeds, the return value is the actual version of
C<$module> installed on the system.  This allows you to do the
following:

  my $installed = $build->check_installed_version('DBI', '1.15');
  if ($installed) {
    print "Congratulations, version $installed of DBI is installed.\n";
  } else {
    die "Sorry, you must install DBI.\n";
  }

If the check fails, we return false and set C<$@> to an informative
error message.

If C<$version> is any non-true value (notably zero) and any version of
C<$module> is installed, we return true.  In this case, if C<$module>
doesn't define a version, or if its version is zero, we return the
special value "0 but true", which is numerically zero, but logically
true.

In general you might prefer to use C<check_installed_status> if you
need detailed information, or this method if you just need a yes/no
answer.

=item compare_versions($v1, $op, $v2)

[version 0.28]

Compares two module versions C<$v1> and C<$v2> using the operator
C<$op>, which should be one of Perl's numeric operators like C<!=> or
C<< >= >> or the like.  We do at least a halfway-decent job of
handling versions that aren't strictly numeric, like C<0.27_02>, but
exotic stuff will likely cause problems.

In the future, the guts of this method might be replaced with a call
out to C<version.pm>.

=item config($key)

=item config($key, $value)

=item config() [deprecated]

[version 0.22]

With a single argument C<$key>, returns the value associated with that
key in the C<Config.pm> hash, including any changes the author or user
has specified.

With C<$key> and C<$value> arguments, sets the value for future
callers of C<config($key)>.

With no arguments, returns a hash reference containing all such
key-value pairs.  This usage is deprecated, though, because it's a
resource hog and violates encapsulation.

=item config_data($name)

=item config_data($name => $value)

[version 0.26]

With a single argument, returns the value of the configuration
variable C<$name>.  With two arguments, sets the given configuration
variable to the given value.  The value may be any Perl scalar that's
serializable with C<Data::Dumper>.  For instance, if you write a
module that can use a MySQL or PostgreSQL back-end, you might create
configuration variables called C<mysql_connect> and
C<postgres_connect>, and set each to an array of connection parameters
for C<< DBI->connect() >>.

Configuration values set in this way using the Module::Build object
will be available for querying during the build/test process and after
installation via the generated C<...::ConfigData> module, as
C<< ...::ConfigData->config($name) >>.

The L<feature()|/"feature($name)"> and C<config_data()> methods represent
Module::Build's main support for configuration of installed modules.
See also L<Module::Build::Authoring/"SAVING CONFIGURATION INFORMATION">.

=item conflicts()

[version 0.21]

Returns a hash reference indicating the C<conflicts> prerequisites
that were passed to the C<new()> method.

=item contains_pod($file) [deprecated]

[version 0.20]

[Deprecated] Please see L<Module::Build::ModuleInfo> instead.

Returns true if the given file appears to contain POD documentation.
Currently this checks whether the file has a line beginning with
'=pod', '=head', or '=item', but the exact semantics may change in the
future.

=item copy_if_modified(%parameters)

[version 0.19]

Takes the file in the C<from> parameter and copies it to the file in
the C<to> parameter, or the directory in the C<to_dir> parameter, if
the file has changed since it was last copied (or if it doesn't exist
in the new location).  By default the entire directory structure of
C<from> will be copied into C<to_dir>; an optional C<flatten>
parameter will copy into C<to_dir> without doing so.

Returns the path to the destination file, or C<undef> if nothing
needed to be copied.

Any directories that need to be created in order to perform the
copying will be automatically created.

The destination file is set to read-only. If the source file has the
executable bit set, then the destination file will be made executable.

=item create_build_script()

[version 0.05]

Creates an executable script called C<Build> in the current directory
that will be used to execute further user actions.  This script is
roughly analogous (in function, not in form) to the Makefile created
by C<ExtUtils::MakeMaker>.  This method also creates some temporary
data in a directory called C<_build/>.  Both of these will be removed
when the C<realclean> action is performed.

Among the files created in C<_build/> is a F<_build/prereqs> file
containing the set of prerequisites for this distribution, as a hash
of hashes.  This file may be C<eval()>-ed to obtain the authoritative
set of prerequisites, which might be different from the contents of
F<META.yml> (because F<Build.PL> might have set them dynamically).
But fancy developers take heed: do not put any fancy custom runtime
code in the F<_build/prereqs> file, leave it as a static declaration
containing only strings and numbers.  Similarly, do not alter the
structure of the internal C<< $self->{properties}{requires} >> (etc.)
data members, because that's where this data comes from.

=item current_action()

[version 0.28]

Returns the name of the currently-running action, such as "build" or
"test".  This action is not necessarily the action that was originally
invoked by the user.  For example, if the user invoked the "test"
action, current_action() would initially return "test".  However,
action "test" depends on action "code", so current_action() will
return "code" while that dependency is being executed.  Once that
action has completed, current_action() will again return "test".

If you need to know the name of the original action invoked by the
user, see L</invoked_action()> below.

=item depends_on(@actions)

[version 0.28]

Invokes the named action or list of actions in sequence.  Using this
method is preferred to calling the action explicitly because it
performs some internal record-keeping, and it ensures that the same
action is not invoked multiple times (note: in future versions of
Module::Build it's conceivable that this run-only-once mechanism will
be changed to something more intelligent).

Note that the name of this method is something of a misnomer; it
should really be called something like
C<invoke_actions_unless_already_invoked()> or something, but for
better or worse (perhaps better!) we were still thinking in
C<make>-like dependency terms when we created this method.

See also L<dispatch()|/"dispatch($action, %args)">.  The main
distinction between the two is that C<depends_on()> is meant to call
an action from inside another action, whereas C<dispatch()> is meant
to set the very top action in motion.

=item dir_contains($first_dir, $second_dir)

[version 0.28]

Returns true if the first directory logically contains the second
directory.  This is just a convenience function because C<File::Spec>
doesn't really provide an easy way to figure this out (but
C<Path::Class> does...).

=item dispatch($action, %args)

[version 0.03]

Invokes the build action C<$action>.  Optionally, a list of options
and their values can be passed in.  This is equivalent to invoking an
action at the command line, passing in a list of options.

Custom options that have not been registered must be passed in as a
hash reference in a key named "args":

  $build->dispatch('foo', verbose => 1, args => { my_option => 'value' });

This method is intended to be used to programmatically invoke build
actions, e.g. by applications controlling Module::Build-based builds
rather than by subclasses.

See also L<depends_on()|/"depends_on(@actions)">.  The main
distinction between the two is that C<depends_on()> is meant to call
an action from inside another action, whereas C<dispatch()> is meant
to set the very top action in motion.

=item dist_dir()

[version 0.28]

Returns the name of the directory that will be created during the
C<dist> action.  The name is derived from the C<dist_name> and
C<dist_version> properties.

=item dist_name()

[version 0.21]

Returns the name of the current distribution, as passed to the
C<new()> method in a C<dist_name> or modified C<module_name>
parameter.

=item dist_version()

[version 0.21]

Returns the version of the current distribution, as determined by the
C<new()> method from a C<dist_version>, C<dist_version_from>, or
C<module_name> parameter.

=item do_system($cmd, @args)

[version 0.21]

This is a fairly simple wrapper around Perl's C<system()> built-in
command.  Given a command and an array of optional arguments, this
method will print the command to C<STDOUT>, and then execute it using
Perl's C<system()>.  It returns true or false to indicate success or
failure (the opposite of how C<system()> works, but more intuitive).

Note that if you supply a single argument to C<do_system()>, it
will/may be processed by the system's shell, and any special
characters will do their special things.  If you supply multiple
arguments, no shell will get involved and the command will be executed
directly.

=item extra_compiler_flags()

=item extra_compiler_flags(@flags)

[version 0.25]

Set or retrieve the extra compiler flags. Returns an arrayref of flags.

=item extra_linker_flags()

=item extra_linker_flags(@flags)

[version 0.25]

Set or retrieve the extra linker flags. Returns an arrayref of flags.

=item feature($name)

=item feature($name => $value)

[version 0.26]

With a single argument, returns true if the given feature is set.
With two arguments, sets the given feature to the given boolean value.
In this context, a "feature" is any optional functionality of an
installed module.  For instance, if you write a module that could
optionally support a MySQL or PostgreSQL backend, you might create
features called C<mysql_support> and C<postgres_support>, and set them
to true/false depending on whether the user has the proper databases
installed and configured.

Features set in this way using the Module::Build object will be
available for querying during the build/test process and after
installation via the generated C<...::ConfigData> module, as
C<< ...::ConfigData->feature($name) >>.

The C<feature()> and C<config_data()> methods represent
Module::Build's main support for configuration of installed modules.
See also L<Module::Build::Authoring/"SAVING CONFIGURATION INFORMATION">.

=item fix_shebang_line(@files)

[version 0.??]

Modify any "shebang" line in the specified files to use the path to the
perl executable being used for the current build.  Files are modified
in-place.  The existing shebang line must have a command that contains
"C<perl>"; arguments to the command do not count.  In particular, this
means that the use of C<#!/usr/bin/env perl> will not be changed.

For an explanation of shebang lines, see
L<http://en.wikipedia.org/wiki/Shebang_%28Unix%29>.

=item have_c_compiler()

[version 0.21]

Returns true if the current system seems to have a working C compiler.
We currently determine this by attempting to compile a simple C source
file and reporting whether the attempt was successful.

=item install_base_relpaths()

=item install_base_relpaths($type)

=item install_base_relpaths($type => $path)

[version 0.28]

Set or retrieve the relative paths that are appended to
C<install_base> for any installable element. This is useful if you
want to set the relative install path for custom build elements.

With no argument, it returns a reference to a hash containing all
elements and their respective values. This hash should not be modified
directly; use the multiple argument below form to change values.

The single argument form returns the value associated with the
element C<$type>.

The multiple argument form allows you to set the paths for element types.
C<$value> must be a relative path using Unix-like paths.  (A series of
directories separated by slashes, e.g. C<foo/bar>.)  The return value is a
localized path based on C<$value>.

Assigning the value C<undef> to an element causes it to be removed.

=item install_destination($type)

[version 0.28]

Returns the directory in which items of type C<$type> (e.g. C<lib>,
C<arch>, C<bin>, or anything else returned by the L</install_types()>
method) will be installed during the C<install> action.  Any settings
for C<install_path>, C<install_base>, and C<prefix> are taken into
account when determining the return value.

=item install_path()

=item install_path($type)

=item install_path($type => $path)

[version 0.28]

Set or retrieve paths for specific installable elements. This is
useful when you want to examine any explicit install paths specified
by the user on the command line, or if you want to set the install
path for a specific installable element based on another attribute
like C<install_base()>.

With no argument, it returns a reference to a hash containing all
elements and their respective values. This hash should not be modified
directly; use the multiple argument below form to change values.

The single argument form returns the value associated with the
element C<$type>.

The multiple argument form allows you to set the paths for element types.
The supplied C<$path> should be an absolute path to install elements
of C<$type>.  The return value is C<$path>.

Assigning the value C<undef> to an element causes it to be removed.

=item install_types()

[version 0.28]

Returns a list of installable types that this build knows about.
These types each correspond to the name of a directory in F<blib/>,
and the list usually includes items such as C<lib>, C<arch>, C<bin>,
C<script>, C<libdoc>, C<bindoc>, and if HTML documentation is to be
built, C<libhtml> and C<binhtml>.  Other user-defined types may also
exist.

=item invoked_action()

[version 0.28]

This is the name of the original action invoked by the user.  This
value is set when the user invokes F<Build.PL>, the F<Build> script,
or programmatically through the L<dispatch()|/"dispatch($action, %args)">
method.  It does not change as sub-actions are executed as
dependencies are evaluated.

To get the name of the currently executing dependency, see
L</current_action()> above.

=item notes()

=item notes($key)

=item notes($key => $value)

[version 0.20]

The C<notes()> value allows you to store your own persistent
information about the build, and to share that information among
different entities involved in the build.  See the example in the
C<current()> method.

The C<notes()> method is essentially a glorified hash access.  With no
arguments, C<notes()> returns the entire hash of notes.  With one argument,
C<notes($key)> returns the value associated with the given key.  With two
arguments, C<notes($key, $value)> sets the value associated with the given key
to C<$value> and returns the new value.

The lifetime of the C<notes> data is for "a build" - that is, the
C<notes> hash is created when C<perl Build.PL> is run (or when the
C<new()> method is run, if the Module::Build Perl API is being used
instead of called from a shell), and lasts until C<perl Build.PL> is
run again or the C<clean> action is run.

=item orig_dir()

[version 0.28]

Returns a string containing the working directory that was in effect
before the F<Build> script chdir()-ed into the C<base_dir>.  This
might be useful for writing wrapper tools that might need to chdir()
back out.

=item os_type()

[version 0.04]

If you're subclassing Module::Build and some code needs to alter its
behavior based on the current platform, you may only need to know
whether you're running on Windows, Unix, MacOS, VMS, etc., and not the
fine-grained value of Perl's C<$^O> variable.  The C<os_type()> method
will return a string like C<Windows>, C<Unix>, C<MacOS>, C<VMS>, or
whatever is appropriate.  If you're running on an unknown platform, it
will return C<undef> - there shouldn't be many unknown platforms
though.

=item is_vmsish()

=item is_windowsish()

=item is_unixish()

Convenience functions that return a boolean value indicating whether
this platform behaves respectively like VMS, Windows, or Unix.  For
arbitrary reasons other platforms don't get their own such functions,
at least not yet.


=item prefix_relpaths()

=item prefix_relpaths($installdirs)

=item prefix_relpaths($installdirs, $type)

=item prefix_relpaths($installdirs, $type => $path)

[version 0.28]

Set or retrieve the relative paths that are appended to C<prefix> for
any installable element.  This is useful if you want to set the
relative install path for custom build elements.

With no argument, it returns a reference to a hash containing all
elements and their respective values as defined by the current
C<installdirs> setting.

With a single argument, it returns a reference to a hash containing
all elements and their respective values as defined by
C<$installdirs>.

The hash returned by the above calls should not be modified directly;
use the three-argument below form to change values.

The two argument form returns the value associated with the
element C<$type>.

The multiple argument form allows you to set the paths for element types.
C<$value> must be a relative path using Unix-like paths.  (A series of
directories separated by slashes, e.g. C<foo/bar>.)  The return value is a
localized path based on C<$value>.

Assigning the value C<undef> to an element causes it to be removed.

=item get_metadata()

[version 0.36]

This method returns a hash reference of metadata that can be used to create a
YAML datastream. It is provided for authors to override or customize the fields
of F<META.yml>.   E.g.

  package My::Builder;
  use base 'Module::Build';

  sub get_metadata {
    my $self, @args = @_;
    my $data = $self->SUPER::get_metadata(@args);
    $data->{custom_field} = 'foo';
    return $data;
  }

Valid arguments include:

=over

=item *

C<fatal> -- indicates whether missing required
metadata fields should be a fatal error or not.  For META creation, it
generally should, but for MYMETA creation for end-users, it should not be
fatal.

=item *

C<auto> -- indicates whether any necessary configure_requires should be
automatically added.  This is used in META creation.

=back

This method is a wrapper around the old prepare_metadata API now that we
no longer use YAML::Node to hold metadata.

=item prepare_metadata() [deprecated]

[version 0.36]

[Deprecated] As of 0.36, authors should use C<get_metadata> instead.  This
method is preserved for backwards compatibility only.

It takes three positional arguments: a hashref (to which metadata will be
added), an optional arrayref (to which metadata keys will be added in order if
the arrayref exists), and a hashref of arguments (as provided to get_metadata).
The latter argument is new as of 0.36.  Earlier versions are always fatal on
errors.

Prior to version 0.36, this method took a YAML::Node as an argument to hold
assembled metadata.

=item prereq_failures()

[version 0.11]

Returns a data structure containing information about any failed
prerequisites (of any of the types described above), or C<undef> if
all prerequisites are met.

The data structure returned is a hash reference.  The top level keys
are the type of prerequisite failed, one of "requires",
"build_requires", "conflicts", or "recommends".  The associated values
are hash references whose keys are the names of required (or
conflicting) modules.  The associated values of those are hash
references indicating some information about the failure.  For example:

  {
   have => '0.42',
   need => '0.59',
   message => 'Version 0.42 is installed, but we need version 0.59',
  }

or

  {
   have => '<none>',
   need => '0.59',
   message => 'Prerequisite Foo isn't installed',
  }

This hash has the same structure as the hash returned by the
C<check_installed_status()> method, except that in the case of
"conflicts" dependencies we change the "need" key to "conflicts" and
construct a proper message.

Examples:

  # Check a required dependency on Foo::Bar
  if ( $build->prereq_failures->{requires}{Foo::Bar} ) { ...

  # Check whether there were any failures
  if ( $build->prereq_failures ) { ...

  # Show messages for all failures
  my $failures = $build->prereq_failures;
  while (my ($type, $list) = each %$failures) {
    while (my ($name, $hash) = each %$list) {
      print "Failure for $name: $hash->{message}\n";
    }
  }

=item prereq_data()

[version 0.32]

Returns a reference to a hash describing all prerequisites.  The keys of the
hash will be the various prerequisite types ('requires', 'build_requires',
'test_requires', 'configure_requires', 'recommends', or 'conflicts') and the values will be
references to hashes of module names and version numbers.  Only prerequisites
types that are defined will be included.  The C<prereq_data> action is just a
thin wrapper around the C<prereq_data()> method and dumps the hash as a string
that can be loaded using C<eval()>.

=item prereq_report()

[version 0.28]

Returns a human-readable (table-form) string showing all
prerequisites, the versions required, and the versions actually
installed.  This can be useful for reviewing the configuration of your
system prior to a build, or when compiling data to send for a bug
report.  The C<prereq_report> action is just a thin wrapper around the
C<prereq_report()> method.

=item prompt($message, $default)

[version 0.12]

Asks the user a question and returns their response as a string.  The
first argument specifies the message to display to the user (for
example, C<"Where do you keep your money?">).  The second argument,
which is optional, specifies a default answer (for example,
C<"wallet">).  The user will be asked the question once.

If C<prompt()> detects that it is not running interactively and there
is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable
is set to true, the $default will be used without prompting.

To prevent automated processes from blocking, the user must either set
PERL_MM_USE_DEFAULT or attach something to STDIN (this can be a
pipe/file containing a scripted set of answers or /dev/null.)

If no $default is provided an empty string will be used instead.  In
non-interactive mode, the absence of $default is an error (though
explicitly passing C<undef()> as the default is valid as of 0.27.)

This method may be called as a class or object method.

=item recommends()

[version 0.21]

Returns a hash reference indicating the C<recommends> prerequisites
that were passed to the C<new()> method.

=item requires()

[version 0.21]

Returns a hash reference indicating the C<requires> prerequisites that
were passed to the C<new()> method.

=item rscan_dir($dir, $pattern)

[version 0.28]

Uses C<File::Find> to traverse the directory C<$dir>, returning a
reference to an array of entries matching C<$pattern>.  C<$pattern>
may either be a regular expression (using C<qr//> or just a plain
string), or a reference to a subroutine that will return true for
wanted entries.  If C<$pattern> is not given, all entries will be
returned.

Examples:

 # All the *.pm files in lib/
 $m->rscan_dir('lib', qr/\.pm$/)

 # All the files in blib/ that aren't *.html files
 $m->rscan_dir('blib', sub {-f $_ and not /\.html$/});

 # All the files in t/
 $m->rscan_dir('t');

=item runtime_params()

=item runtime_params($key)

[version 0.28]

The C<runtime_params()> method stores the values passed on the command line
for valid properties (that is, any command line options for which
C<valid_property()> returns a true value).  The value on the command line may
override the default value for a property, as well as any value specified in a
call to C<new()>.  This allows you to programmatically tell if C<perl Build.PL>
or any execution of C<./Build> had command line options specified that
override valid properties.

The C<runtime_params()> method is essentially a glorified read-only hash.  With
no arguments, C<runtime_params()> returns the entire hash of properties
specified on the command line.  With one argument, C<runtime_params($key)>
returns the value associated with the given key.

The lifetime of the C<runtime_params> data is for "a build" - that is, the
C<runtime_params> hash is created when C<perl Build.PL> is run (or when the
C<new()> method is called, if the Module::Build Perl API is being used instead
of called from a shell), and lasts until C<perl Build.PL> is run again or the
C<clean> action is run.

=item script_files()

[version 0.18]

Returns a hash reference whose keys are the perl script files to be
installed, if any.  This corresponds to the C<script_files> parameter to the
C<new()> method.  With an optional argument, this parameter may be set
dynamically.

For backward compatibility, the C<scripts()> method does exactly the
same thing as C<script_files()>.  C<scripts()> is deprecated, but it
will stay around for several versions to give people time to
transition.

=item up_to_date($source_file, $derived_file)

=item up_to_date(\@source_files, \@derived_files)

[version 0.20]

This method can be used to compare a set of source files to a set of
derived files.  If any of the source files are newer than any of the
derived files, it returns false.  Additionally, if any of the derived
files do not exist, it returns false.  Otherwise it returns true.

The arguments may be either a scalar or an array reference of file
names.

=item y_n($message, $default)

[version 0.12]

Asks the user a yes/no question using C<prompt()> and returns true or
false accordingly.  The user will be asked the question repeatedly
until they give an answer that looks like "yes" or "no".

The first argument specifies the message to display to the user (for
example, C<"Shall I invest your money for you?">), and the second
argument specifies the default answer (for example, C<"y">).

Note that the default is specified as a string like C<"y"> or C<"n">,
and the return value is a Perl boolean value like 1 or 0.  I thought
about this for a while and this seemed like the most useful way to do
it.

This method may be called as a class or object method.

=back


=head2 Autogenerated Accessors

In addition to the aforementioned methods, there are also some get/set
accessor methods for the following properties:

=over 4

=item PL_files()

=item allow_mb_mismatch()

=item allow_pureperl()

=item auto_configure_requires()

=item autosplit()

=item base_dir()

=item bindoc_dirs()

=item blib()

=item build_bat()

=item build_class()

=item build_elements()

=item build_requires()

=item build_script()

=item bundle_inc()

=item bundle_inc_preload()

=item c_source()

=item config_dir()

=item configure_requires()

=item conflicts()

=item cpan_client()

=item create_license()

=item create_makefile_pl()

=item create_packlist()

=item create_readme()

=item debug()

=item debugger()

=item destdir()

=item dynamic_config()

=item extra_manify_args()

=item get_options()

=item html_css()

=item include_dirs()

=item install_base()

=item installdirs()

=item libdoc_dirs()

=item license()

=item magic_number()

=item mb_version()

=item meta_add()

=item meta_merge()

=item metafile()

=item metafile2()

=item module_name()

=item mymetafile()

=item mymetafile2()

=item needs_compiler()

=item orig_dir()

=item perl()

=item pm_files()

=item pod_files()

=item pollute()

=item prefix()

=item prereq_action_types()

=item program_name()

=item pureperl_only()

=item quiet()

=item recommends()

=item recurse_into()

=item recursive_test_files()

=item requires()

=item scripts()

=item sign()

=item tap_harness_args()

=item test_file_exts()

=item test_requires()

=item use_rcfile()

=item use_tap_harness()

=item verbose()

=item xs_files()

=back

=head1 MODULE METADATA

If you would like to add other useful metadata, C<Module::Build>
supports this with the C<meta_add> and C<meta_merge> arguments to
L</new()>. The authoritative list of supported metadata can be found at
L<CPAN::Meta::Spec> but for convenience - here are a few of the more useful ones:

=over 4

=item keywords

For describing the distribution using keyword (or "tags") in order to
make CPAN.org indexing and search more efficient and useful.

=item resources

A list of additional resources available for users of the
distribution. This can include links to a homepage on the web, a
bug tracker, the repository location, and even a subscription page for the
distribution mailing list.

=back


=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>


=head1 COPYRIGHT

Copyright (c) 2001-2006 Ken Williams.  All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.


=head1 SEE ALSO

perl(1), L<Module::Build>(3), L<Module::Build::Authoring>(3),
L<Module::Build::Cookbook>(3), L<ExtUtils::MakeMaker>(3)

F<META.yml> Specification:
L<CPAN::Meta::Spec>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/share/perl/5.20.2/Module/Build/Authoring.pod                                                    0100644 0000000 0000000 00000025374 12744441327 017621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

Module::Build::Authoring - Authoring Module::Build modules

=head1 DESCRIPTION

When creating a C<Build.PL> script for a module, something like the
following code will typically be used:

  use Module::Build;
  my $build = Module::Build->new
    (
     module_name => 'Foo::Bar',
     license  => 'perl',
     requires => {
                  'perl'          => '5.6.1',
                  'Some::Module'  => '1.23',
                  'Other::Module' => '>= 1.2, != 1.5, < 2.0',
                 },
    );
  $build->create_build_script;

A simple module could get away with something as short as this for its
C<Build.PL> script:

  use Module::Build;
  Module::Build->new(
    module_name => 'Foo::Bar',
    license     => 'perl',
  )->create_build_script;

The model used by C<Module::Build> is a lot like the C<MakeMaker>
metaphor, with the following correspondences:

   In Module::Build                 In ExtUtils::MakeMaker
  ---------------------------      ------------------------
   Build.PL (initial script)        Makefile.PL (initial script)
   Build (a short perl script)      Makefile (a long Makefile)
   _build/ (saved state info)       various config text in the Makefile

Any customization can be done simply by subclassing C<Module::Build>
and adding a method called (for example) C<ACTION_test>, overriding
the default 'test' action.  You could also add a method called
C<ACTION_whatever>, and then you could perform the action C<Build
whatever>.

For information on providing compatibility with
C<ExtUtils::MakeMaker>, see L<Module::Build::Compat> and
L<http://www.makemaker.org/wiki/index.cgi?ModuleBuildConversionGuide>.


=head1 STRUCTURE

Module::Build creates a class hierarchy conducive to customization.
Here is the parent-child class hierarchy in classy ASCII art:

   /--------------------\
   |   Your::Parent     |  (If you subclass Module::Build)
   \--------------------/
            |
            |
   /--------------------\  (Doesn't define any functionality
   |   Module::Build    |   of its own - just figures out what
   \--------------------/   other modules to load.)
            |
            |
   /-----------------------------------\  (Some values of $^O may
   |   Module::Build::Platform::$^O    |   define specialized functionality.
   \-----------------------------------/   Otherwise it's ...::Default, a
            |                              pass-through class.)
            |
   /--------------------------\
   |   Module::Build::Base    |  (Most of the functionality of 
   \--------------------------/   Module::Build is defined here.)


=head1 SUBCLASSING

Right now, there are two ways to subclass Module::Build.  The first
way is to create a regular module (in a C<.pm> file) that inherits
from Module::Build, and use that module's class instead of using
Module::Build directly:

  ------ in Build.PL: ----------
  #!/usr/bin/perl

  use lib q(/nonstandard/library/path);
  use My::Builder;  # Or whatever you want to call it

  my $build = My::Builder->new
    (
     module_name => 'Foo::Bar',  # All the regular args...
     license     => 'perl',
     dist_author => 'A N Other <me@here.net.au>',
     requires    => { Carp => 0 }
    );
  $build->create_build_script;

This is relatively straightforward, and is the best way to do things
if your My::Builder class contains lots of code.  The
C<create_build_script()> method will ensure that the current value of
C<@INC> (including the C</nonstandard/library/path>) is propagated to
the Build script, so that My::Builder can be found when running build
actions.  If you find that you need to C<chdir> into a different directories
in your subclass methods or actions, be sure to always return to the original
directory (available via the C<base_dir()> method) before returning control
to the parent class.  This is important to avoid data serialization problems.

For very small additions, Module::Build provides a C<subclass()>
method that lets you subclass Module::Build more conveniently, without
creating a separate file for your module:

  ------ in Build.PL: ----------
  #!/usr/bin/perl

  use Module::Build;
  my $class = Module::Build->subclass
    (
     class => 'My::Builder',
     code => q{
       sub ACTION_foo {
         print "I'm fooing to death!\n";
       }
     },
    );

  my $build = $class->new
    (
     module_name => 'Foo::Bar',  # All the regular args...
     license     => 'perl',
     dist_author => 'A N Other <me@here.net.au>',
     requires    => { Carp => 0 }
    );
  $build->create_build_script;

Behind the scenes, this actually does create a C<.pm> file, since the
code you provide must persist after Build.PL is run if it is to be
very useful.

See also the documentation for the L<Module::Build::API/"subclass()">
method.


=head1 PREREQUISITES

=head2 Types of prerequisites

To specify what versions of other modules are used by this
distribution, several types of prerequisites can be defined with the
following parameters:

=over 3

=item configure_requires

Items that must be installed I<before> configuring this distribution
(i.e. before running the F<Build.PL> script).  This might be a
specific minimum version of C<Module::Build> or any other module the
F<Build.PL> needs in order to do its stuff.  Clients like C<CPAN.pm>
or C<CPANPLUS> will be expected to pick C<configure_requires> out of the
F<META.yml> file and install these items before running the
C<Build.PL>.

If no configure_requires is specified, the current version of Module::Build
is automatically added to configure_requires.

=item build_requires

Items that are necessary for building and testing this distribution,
but aren't necessary after installation.  This can help users who only
want to install these items temporarily.  It also helps reduce the
size of the CPAN dependency graph if everything isn't smooshed into
C<requires>.

=item requires

Items that are necessary for basic functioning.

=item recommends

Items that are recommended for enhanced functionality, but there are
ways to use this distribution without having them installed.  You
might also think of this as "can use" or "is aware of" or "changes
behavior in the presence of".

=item test_requires

Items that are necessary for testing.

=item conflicts

Items that can cause problems with this distribution when installed.
This is pretty rare.

=back

=head2 Format of prerequisites

The prerequisites are given in a hash reference, where the keys are
the module names and the values are version specifiers:

  requires => {
               Foo::Module => '2.4',
               Bar::Module => 0,
               Ken::Module => '>= 1.2, != 1.5, < 2.0',
               perl => '5.6.0'
              },

The above four version specifiers have different effects.  The value
C<'2.4'> means that B<at least> version 2.4 of C<Foo::Module> must be
installed.  The value C<0> means that B<any> version of C<Bar::Module>
is acceptable, even if C<Bar::Module> doesn't define a version.  The
more verbose value C<'E<gt>= 1.2, != 1.5, E<lt> 2.0'> means that
C<Ken::Module>'s version must be B<at least> 1.2, B<less than> 2.0,
and B<not equal to> 1.5.  The list of criteria is separated by commas,
and all criteria must be satisfied.

A special C<perl> entry lets you specify the versions of the Perl
interpreter that are supported by your module.  The same version
dependency-checking semantics are available, except that we also
understand perl's new double-dotted version numbers.

=head2 XS Extensions

Modules which need to compile XS code should list C<ExtUtils::CBuilder>
as a C<build_requires> element.


=head1 SAVING CONFIGURATION INFORMATION

Module::Build provides a very convenient way to save configuration
information that your installed modules (or your regression tests) can
access.  If your Build process calls the C<feature()> or
C<config_data()> methods, then a C<Foo::Bar::ConfigData> module will
automatically be created for you, where C<Foo::Bar> is the
C<module_name> parameter as passed to C<new()>.  This module provides
access to the data saved by these methods, and a way to update the
values.  There is also a utility script called C<config_data>
distributed with Module::Build that provides a command line interface
to this same functionality.  See also the generated
C<Foo::Bar::ConfigData> documentation, and the C<config_data>
script's documentation, for more information.


=head1 STARTING MODULE DEVELOPMENT

When starting development on a new module, it's rarely worth your time
to create a tree of all the files by hand.  Some automatic
module-creators are available: the oldest is C<h2xs>, which has
shipped with perl itself for a long time.  Its name reflects the fact
that modules were originally conceived of as a way to wrap up a C
library (thus the C<h> part) into perl extensions (thus the C<xs>
part).

These days, C<h2xs> has largely been superseded by modules like
C<ExtUtils::ModuleMaker>, and C<Module::Starter>.  They have varying
degrees of support for C<Module::Build>.


=head1 AUTOMATION

One advantage of Module::Build is that since it's implemented as Perl
methods, you can invoke these methods directly if you want to install
a module non-interactively.  For instance, the following Perl script
will invoke the entire build/install procedure:

  my $build = Module::Build->new(module_name => 'MyModule');
  $build->dispatch('build');
  $build->dispatch('test');
  $build->dispatch('install');

If any of these steps encounters an error, it will throw a fatal
exception.

You can also pass arguments as part of the build process:

  my $build = Module::Build->new(module_name => 'MyModule');
  $build->dispatch('build');
  $build->dispatch('test', verbose => 1);
  $build->dispatch('install', sitelib => '/my/secret/place/');

Building and installing modules in this way skips creating the
C<Build> script.


=head1 MIGRATION

Note that if you want to provide both a F<Makefile.PL> and a
F<Build.PL> for your distribution, you probably want to add the
following to C<WriteMakefile> in your F<Makefile.PL> so that C<MakeMaker>
doesn't try to run your F<Build.PL> as a normal F<.PL> file:

  PL_FILES => {},

You may also be interested in looking at the C<Module::Build::Compat>
module, which can automatically create various kinds of F<Makefile.PL>
compatibility layers.


=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>

Development questions, bug reports, and patches should be sent to the
Module-Build mailing list at <module-build@perl.org>.

Bug reports are also welcome at
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Module-Build>.

The latest development version is available from the Git
repository at <https://github.com/Perl-Toolchain-Gang/Module-Build>


=head1 SEE ALSO

perl(1), L<Module::Build>(3), L<Module::Build::API>(3),
L<Module::Build::Cookbook>(3), L<ExtUtils::MakeMaker>(3), L<YAML>(3)

F<META.yml> Specification:
L<CPAN::Meta::Spec>

L<http://www.dsmit.com/cons/>

L<http://search.cpan.org/dist/PerlBuildSystem/>

=cut
                                                                                                                                                                                                                                                                    usr/share/perl/5.20.2/Module/Build/Base.pm                                                          0100644 0000000 0000000 00000505726 12744441327 016371  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
# vim:ts=8:sw=2:et:sta:sts=2
package Module::Build::Base;

use strict;
use vars qw($VERSION);
use warnings;

$VERSION = '0.4205';
$VERSION = eval $VERSION;
BEGIN { require 5.006001 }

use Carp;
use Cwd ();
use File::Copy ();
use File::Find ();
use File::Path ();
use File::Basename ();
use File::Spec 0.82 ();
use File::Compare ();
use Module::Build::Dumper ();
use Text::ParseWords ();

use Module::Build::ModuleInfo;
use Module::Build::Notes;
use Module::Build::Config;
use Module::Build::Version;


#################### Constructors ###########################
sub new {
  my $self = shift()->_construct(@_);

  $self->{invoked_action} = $self->{action} ||= 'Build_PL';
  $self->cull_args(@ARGV);

  die "Too early to specify a build action '$self->{action}'.  Do 'Build $self->{action}' instead.\n"
    if $self->{action} && $self->{action} ne 'Build_PL';

  $self->check_manifest;
  $self->auto_require;

  # All checks must run regardless if one fails, so no short circuiting!
  if( grep { !$_ } $self->check_prereq, $self->check_autofeatures ) {
    $self->log_warn(<<EOF);

ERRORS/WARNINGS FOUND IN PREREQUISITES.  You may wish to install the versions
of the modules indicated above before proceeding with this installation

EOF
    unless (
      $self->dist_name eq 'Module-Build' ||
      $ENV{PERL5_CPANPLUS_IS_RUNNING} || $ENV{PERL5_CPAN_IS_RUNNING}
    ) {
      $self->log_warn(
        "Run 'Build installdeps' to install missing prerequisites.\n\n"
      );
    }
  }

  # record for later use in resume;
  $self->{properties}{_added_to_INC} = [ $self->_added_to_INC ];

  $self->set_bundle_inc;

  $self->dist_name;
  $self->dist_version;
  $self->release_status;
  $self->_guess_module_name unless $self->module_name;

  $self->_find_nested_builds;

  return $self;
}

sub resume {
  my $package = shift;
  my $self = $package->_construct(@_);
  $self->read_config;

  my @added_earlier = @{ $self->{properties}{_added_to_INC} || [] };

  @INC = ($self->_added_to_INC, @added_earlier, $self->_default_INC);

  # If someone called Module::Build->current() or
  # Module::Build->new_from_context() and the correct class to use is
  # actually a *subclass* of Module::Build, we may need to load that
  # subclass here and re-delegate the resume() method to it.
  unless ( UNIVERSAL::isa($package, $self->build_class) ) {
    my $build_class = $self->build_class;
    my $config_dir = $self->config_dir || '_build';
    my $build_lib = File::Spec->catdir( $config_dir, 'lib' );
    unshift( @INC, $build_lib );
    unless ( $build_class->can('new') ) {
      eval "require $build_class; 1" or die "Failed to re-load '$build_class': $@";
    }
    return $build_class->resume(@_);
  }

  unless ($self->_perl_is_same($self->{properties}{perl})) {
    my $perl = $self->find_perl_interpreter;
    die(<<"DIEFATAL");
* FATAL ERROR: Perl interpreter mismatch. Configuration was initially
  created with '$self->{properties}{perl}'
  but we are now using '$perl'.  You must
  run 'Build realclean' or 'make realclean' and re-configure.
DIEFATAL
  }

  $self->cull_args(@ARGV);

  unless ($self->allow_mb_mismatch) {
    my $mb_version = $Module::Build::VERSION;
    if ( $mb_version ne $self->{properties}{mb_version} ) {
      $self->log_warn(<<"MISMATCH");
* WARNING: Configuration was initially created with Module::Build
  version '$self->{properties}{mb_version}' but we are now using version '$mb_version'.
  If errors occur, you must re-run the Build.PL or Makefile.PL script.
MISMATCH
    }
  }

  $self->{invoked_action} = $self->{action} ||= 'build';

  return $self;
}

sub new_from_context {
  my ($package, %args) = @_;

  $package->run_perl_script('Build.PL',[],[$package->unparse_args(\%args)]);
  return $package->resume;
}

sub current {
  # hmm, wonder what the right thing to do here is
  local @ARGV;
  return shift()->resume;
}

sub _construct {
  my ($package, %input) = @_;

  my $args   = delete $input{args}   || {};
  my $config = delete $input{config} || {};

  my $self = bless {
      args => {%$args},
      config => Module::Build::Config->new(values => $config),
      properties => {
          base_dir        => $package->cwd,
          mb_version      => $Module::Build::VERSION,
          %input,
      },
      phash => {},
      stash => {}, # temporary caching, not stored in _build
  }, $package;

  $self->_set_defaults;
  my ($p, $ph) = ($self->{properties}, $self->{phash});

  foreach (qw(notes config_data features runtime_params cleanup auto_features)) {
    my $file = File::Spec->catfile($self->config_dir, $_);
    $ph->{$_} = Module::Build::Notes->new(file => $file);
    $ph->{$_}->restore if -e $file;
    if (exists $p->{$_}) {
      my $vals = delete $p->{$_};
      while (my ($k, $v) = each %$vals) {
        $self->$_($k, $v);
      }
    }
  }

  # The following warning could be unnecessary if the user is running
  # an embedded perl, but there aren't too many of those around, and
  # embedded perls aren't usually used to install modules, and the
  # installation process sometimes needs to run external scripts
  # (e.g. to run tests).
  $p->{perl} = $self->find_perl_interpreter
    or $self->log_warn("Warning: Can't locate your perl binary");

  my $blibdir = sub { File::Spec->catdir($p->{blib}, @_) };
  $p->{bindoc_dirs} ||= [ $blibdir->("script") ];
  $p->{libdoc_dirs} ||= [ $blibdir->("lib"), $blibdir->("arch") ];

  $p->{dist_author} = [ $p->{dist_author} ] if defined $p->{dist_author} and not ref $p->{dist_author};

  # Synonyms
  $p->{requires} = delete $p->{prereq} if defined $p->{prereq};
  $p->{script_files} = delete $p->{scripts} if defined $p->{scripts};

  # Convert to from shell strings to arrays
  for ('extra_compiler_flags', 'extra_linker_flags') {
    $p->{$_} = [ $self->split_like_shell($p->{$_}) ] if exists $p->{$_};
  }

  # Convert to arrays
  for ('include_dirs') {
    $p->{$_} = [ $p->{$_} ] if exists $p->{$_} && !ref $p->{$_}
  }

  $self->add_to_cleanup( @{delete $p->{add_to_cleanup}} )
    if $p->{add_to_cleanup};

  return $self;
}

################## End constructors #########################

sub log_info {
  my $self = shift;
  print @_ if ref($self) && ( $self->verbose || ! $self->quiet );
}
sub log_verbose {
  my $self = shift;
  print @_ if ref($self) && $self->verbose;
}
sub log_debug {
  my $self = shift;
  print @_ if ref($self) && $self->debug;
}

sub log_warn {
  # Try to make our call stack invisible
  shift;
  if (@_ and $_[-1] !~ /\n$/) {
    my (undef, $file, $line) = caller();
    warn @_, " at $file line $line.\n";
  } else {
    warn @_;
  }
}


# install paths must be generated when requested to be sure all changes
# to config (from various sources) are included
sub _default_install_paths {
  my $self = shift;
  my $c = $self->{config};
  my $p = {};

  my @libstyle = $c->get('installstyle') ?
      File::Spec->splitdir($c->get('installstyle')) : qw(lib perl5);
  my $arch     = $c->get('archname');
  my $version  = $c->get('version');

  my $bindoc  = $c->get('installman1dir') || undef;
  my $libdoc  = $c->get('installman3dir') || undef;

  my $binhtml = $c->get('installhtml1dir') || $c->get('installhtmldir') || undef;
  my $libhtml = $c->get('installhtml3dir') || $c->get('installhtmldir') || undef;

  $p->{install_sets} =
    {
     core   => {
       lib     => $c->get('installprivlib'),
       arch    => $c->get('installarchlib'),
       bin     => $c->get('installbin'),
       script  => $c->get('installscript'),
       bindoc  => $bindoc,
       libdoc  => $libdoc,
       binhtml => $binhtml,
       libhtml => $libhtml,
     },
     site   => {
       lib     => $c->get('installsitelib'),
       arch    => $c->get('installsitearch'),
       bin     => $c->get('installsitebin')      || $c->get('installbin'),
       script  => $c->get('installsitescript')   ||
         $c->get('installsitebin') || $c->get('installscript'),
       bindoc  => $c->get('installsiteman1dir')  || $bindoc,
       libdoc  => $c->get('installsiteman3dir')  || $libdoc,
       binhtml => $c->get('installsitehtml1dir') || $binhtml,
       libhtml => $c->get('installsitehtml3dir') || $libhtml,
     },
     vendor => {
       lib     => $c->get('installvendorlib'),
       arch    => $c->get('installvendorarch'),
       bin     => $c->get('installvendorbin')      || $c->get('installbin'),
       script  => $c->get('installvendorscript')   ||
         $c->get('installvendorbin') || $c->get('installscript'),
       bindoc  => $c->get('installvendorman1dir')  || $bindoc,
       libdoc  => $c->get('installvendorman3dir')  || $libdoc,
       binhtml => $c->get('installvendorhtml1dir') || $binhtml,
       libhtml => $c->get('installvendorhtml3dir') || $libhtml,
     },
    };

  $p->{original_prefix} =
    {
     core   => $c->get('installprefixexp') || $c->get('installprefix') ||
               $c->get('prefixexp')        || $c->get('prefix') || '',
     site   => $c->get('siteprefixexp'),
     vendor => $c->get('usevendorprefix') ? $c->get('vendorprefixexp') : '',
    };
  $p->{original_prefix}{site} ||= $p->{original_prefix}{core};

  # Note: you might be tempted to use $Config{installstyle} here
  # instead of hard-coding lib/perl5, but that's been considered and
  # (at least for now) rejected.  `perldoc Config` has some wisdom
  # about it.
  $p->{install_base_relpaths} =
    {
     lib     => ['lib', 'perl5'],
     arch    => ['lib', 'perl5', $arch],
     bin     => ['bin'],
     script  => ['bin'],
     bindoc  => ['man', 'man1'],
     libdoc  => ['man', 'man3'],
     binhtml => ['html'],
     libhtml => ['html'],
    };

  $p->{prefix_relpaths} =
    {
     core => {
       lib        => [@libstyle],
       arch       => [@libstyle, $version, $arch],
       bin        => ['bin'],
       script     => ['bin'],
       bindoc     => ['man', 'man1'],
       libdoc     => ['man', 'man3'],
       binhtml    => ['html'],
       libhtml    => ['html'],
     },
     vendor => {
       lib        => [@libstyle],
       arch       => [@libstyle, $version, $arch],
       bin        => ['bin'],
       script     => ['bin'],
       bindoc     => ['man', 'man1'],
       libdoc     => ['man', 'man3'],
       binhtml    => ['html'],
       libhtml    => ['html'],
     },
     site => {
       lib        => [@libstyle, 'site_perl'],
       arch       => [@libstyle, 'site_perl', $version, $arch],
       bin        => ['bin'],
       script     => ['bin'],
       bindoc     => ['man', 'man1'],
       libdoc     => ['man', 'man3'],
       binhtml    => ['html'],
       libhtml    => ['html'],
     },
    };
    return $p
}

sub _find_nested_builds {
  my $self = shift;
  my $r = $self->recurse_into or return;

  my ($file, @r);
  if (!ref($r) && $r eq 'auto') {
    local *DH;
    opendir DH, $self->base_dir
      or die "Can't scan directory " . $self->base_dir . " for nested builds: $!";
    while (defined($file = readdir DH)) {
      my $subdir = File::Spec->catdir( $self->base_dir, $file );
      next unless -d $subdir;
      push @r, $subdir if -e File::Spec->catfile( $subdir, 'Build.PL' );
    }
  }

  $self->recurse_into(\@r);
}

sub cwd {
  return Cwd::cwd();
}

sub _quote_args {
  # Returns a string that can become [part of] a command line with
  # proper quoting so that the subprocess sees this same list of args.
  my ($self, @args) = @_;

  my @quoted;

  for (@args) {
    if ( /^[^\s*?!\$<>;\\|'"\[\]\{\}]+$/ ) {
      # Looks pretty safe
      push @quoted, $_;
    } else {
      # XXX this will obviously have to improve - is there already a
      # core module lying around that does proper quoting?
      s/('+)/'"$1"'/g;
      push @quoted, qq('$_');
    }
  }

  return join " ", @quoted;
}

sub _backticks {
  my ($self, @cmd) = @_;
  if ($self->have_forkpipe) {
    local *FH;
    my $pid = open *FH, "-|";
    if ($pid) {
      return wantarray ? <FH> : join '', <FH>;
    } else {
      die "Can't execute @cmd: $!\n" unless defined $pid;
      exec { $cmd[0] } @cmd;
    }
  } else {
    my $cmd = $self->_quote_args(@cmd);
    return `$cmd`;
  }
}

# Tells us whether the construct open($fh, '-|', @command) is
# supported.  It would probably be better to dynamically sense this.
sub have_forkpipe { 1 }

# Determine whether a given binary is the same as the perl
# (configuration) that started this process.
sub _perl_is_same {
  my ($self, $perl) = @_;

  my @cmd = ($perl);

  # When run from the perl core, @INC will include the directories
  # where perl is yet to be installed. We need to reference the
  # absolute path within the source distribution where it can find
  # it's Config.pm This also prevents us from picking up a Config.pm
  # from a different configuration that happens to be already
  # installed in @INC.
  if ($ENV{PERL_CORE}) {
    push @cmd, '-I' . File::Spec->catdir(File::Basename::dirname($perl), 'lib');
  }

  push @cmd, qw(-MConfig=myconfig -e print -e myconfig);
  return $self->_backticks(@cmd) eq Config->myconfig;
}

# cache _discover_perl_interpreter() results
{
  my $known_perl;
  sub find_perl_interpreter {
    my $self = shift;

    return $known_perl if defined($known_perl);
    return $known_perl = $self->_discover_perl_interpreter;
  }
}

# Returns the absolute path of the perl interpreter used to invoke
# this process. The path is derived from $^X or $Config{perlpath}. On
# some platforms $^X contains the complete absolute path of the
# interpreter, on other it may contain a relative path, or simply
# 'perl'. This can also vary depending on whether a path was supplied
# when perl was invoked. Additionally, the value in $^X may omit the
# executable extension on platforms that use one. It's a fatal error
# if the interpreter can't be found because it can result in undefined
# behavior by routines that depend on it (generating errors or
# invoking the wrong perl.)
sub _discover_perl_interpreter {
  my $proto = shift;
  my $c     = ref($proto) ? $proto->{config} : 'Module::Build::Config';

  my $perl  = $^X;
  my $perl_basename = File::Basename::basename($perl);

  my @potential_perls;

  # Try 1, Check $^X for absolute path
  push( @potential_perls, $perl )
      if File::Spec->file_name_is_absolute($perl);

  # Try 2, Check $^X for a valid relative path
  my $abs_perl = File::Spec->rel2abs($perl);
  push( @potential_perls, $abs_perl );

  # Try 3, Last ditch effort: These two option use hackery to try to locate
  # a suitable perl. The hack varies depending on whether we are running
  # from an installed perl or an uninstalled perl in the perl source dist.
  if ($ENV{PERL_CORE}) {

    # Try 3.A, If we are in a perl source tree, running an uninstalled
    # perl, we can keep moving up the directory tree until we find our
    # binary. We wouldn't do this under any other circumstances.

    # CBuilder is also in the core, so it should be available here
    require ExtUtils::CBuilder;
    my $perl_src = Cwd::realpath( ExtUtils::CBuilder->perl_src );
    if ( defined($perl_src) && length($perl_src) ) {
      my $uninstperl =
        File::Spec->rel2abs(File::Spec->catfile( $perl_src, $perl_basename ));
      push( @potential_perls, $uninstperl );
    }

  } else {

    # Try 3.B, First look in $Config{perlpath}, then search the user's
    # PATH. We do not want to do either if we are running from an
    # uninstalled perl in a perl source tree.

    push( @potential_perls, $c->get('perlpath') );

    push( @potential_perls,
          map File::Spec->catfile($_, $perl_basename), File::Spec->path() );
  }

  # Now that we've enumerated the potential perls, it's time to test
  # them to see if any of them match our configuration, returning the
  # absolute path of the first successful match.
  my $exe = $c->get('exe_ext');
  foreach my $thisperl ( @potential_perls ) {

    if (defined $exe) {
      $thisperl .= $exe unless $thisperl =~ m/$exe$/i;
    }

    if ( -f $thisperl && $proto->_perl_is_same($thisperl) ) {
      return $thisperl;
    }
  }

  # We've tried all alternatives, and didn't find a perl that matches
  # our configuration. Throw an exception, and list alternatives we tried.
  my @paths = map File::Basename::dirname($_), @potential_perls;
  die "Can't locate the perl binary used to run this script " .
      "in (@paths)\n";
}

# Adapted from IPC::Cmd::can_run()
sub find_command {
  my ($self, $command) = @_;

  if( File::Spec->file_name_is_absolute($command) ) {
    return $self->_maybe_command($command);

  } else {
    for my $dir ( File::Spec->path ) {
      my $abs = File::Spec->catfile($dir, $command);
      return $abs if $abs = $self->_maybe_command($abs);
    }
  }
}

# Copied from ExtUtils::MM_Unix::maybe_command
sub _maybe_command {
  my($self,$file) = @_;
  return $file if -x $file && ! -d $file;
  return;
}

sub _is_interactive {
  return -t STDIN && (-t STDOUT || !(-f STDOUT || -c STDOUT)) ;   # Pipe?
}

# NOTE this is a blocking operation if(-t STDIN)
sub _is_unattended {
  my $self = shift;
  return $ENV{PERL_MM_USE_DEFAULT} ||
    ( !$self->_is_interactive && eof STDIN );
}

sub _readline {
  my $self = shift;
  return undef if $self->_is_unattended;

  my $answer = <STDIN>;
  chomp $answer if defined $answer;
  return $answer;
}

sub prompt {
  my $self = shift;
  my $mess = shift
    or die "prompt() called without a prompt message";

  # use a list to distinguish a default of undef() from no default
  my @def;
  @def = (shift) if @_;
  # use dispdef for output
  my @dispdef = scalar(@def) ?
    ('[', (defined($def[0]) ? $def[0] . ' ' : ''), ']') :
    (' ', '');

  local $|=1;
  print "$mess ", @dispdef;

  if ( $self->_is_unattended && !@def ) {
    die <<EOF;
ERROR: This build seems to be unattended, but there is no default value
for this question.  Aborting.
EOF
  }

  my $ans = $self->_readline();

  if ( !defined($ans)        # Ctrl-D or unattended
       or !length($ans) ) {  # User hit return
    print "$dispdef[1]\n";
    $ans = scalar(@def) ? $def[0] : '';
  }

  return $ans;
}

sub y_n {
  my $self = shift;
  my ($mess, $def)  = @_;

  die "y_n() called without a prompt message" unless $mess;
  die "Invalid default value: y_n() default must be 'y' or 'n'"
    if $def && $def !~ /^[yn]/i;

  my $answer;
  while (1) { # XXX Infinite or a large number followed by an exception ?
    $answer = $self->prompt(@_);
    return 1 if $answer =~ /^y/i;
    return 0 if $answer =~ /^n/i;
    local $|=1;
    print "Please answer 'y' or 'n'.\n";
  }
}

sub current_action { shift->{action} }
sub invoked_action { shift->{invoked_action} }

sub notes        { shift()->{phash}{notes}->access(@_) }
sub config_data  { shift()->{phash}{config_data}->access(@_) }
sub runtime_params { shift->{phash}{runtime_params}->read( @_ ? shift : () ) }  # Read-only
sub auto_features  { shift()->{phash}{auto_features}->access(@_) }

sub features     {
  my $self = shift;
  my $ph = $self->{phash};

  if (@_) {
    my $key = shift;
    if ($ph->{features}->exists($key)) {
      return $ph->{features}->access($key, @_);
    }

    if (my $info = $ph->{auto_features}->access($key)) {
      my $disabled;
      for my $type ( @{$self->prereq_action_types} ) {
        next if $type eq 'description' || $type eq 'recommends' || ! exists $info->{$type};
        my $prereqs = $info->{$type};
        for my $modname ( sort keys %$prereqs ) {
          my $spec = $prereqs->{$modname};
          my $status = $self->check_installed_status($modname, $spec);
          if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
          if ( ! eval "require $modname; 1" ) { return 0; }
        }
      }
      return 1;
    }

    return $ph->{features}->access($key, @_);
  }

  # No args - get the auto_features & overlay the regular features
  my %features;
  my %auto_features = $ph->{auto_features}->access();
  while (my ($name, $info) = each %auto_features) {
    my $failures = $self->prereq_failures($info);
    my $disabled = grep( /^(?:\w+_)?(?:requires|conflicts)$/,
                        keys %$failures ) ? 1 : 0;
    $features{$name} = $disabled ? 0 : 1;
  }
  %features = (%features, $ph->{features}->access());

  return wantarray ? %features : \%features;
}
BEGIN { *feature = \&features } # Alias

sub _mb_feature {
  my $self = shift;

  if (($self->module_name || '') eq 'Module::Build') {
    # We're building Module::Build itself, so ...::ConfigData isn't
    # valid, but $self->features() should be.
    return $self->feature(@_);
  } else {
    require Module::Build::ConfigData;
    return Module::Build::ConfigData->feature(@_);
  }
}

sub _warn_mb_feature_deps {
  my $self = shift;
  my $name = shift;
  $self->log_warn(
    "The '$name' feature is not available.  Please install missing\n" .
    "feature dependencies and try again.\n".
    $self->_feature_deps_msg($name) . "\n"
  );
}

sub add_build_element {
    my ($self, $elem) = @_;
    my $elems = $self->build_elements;
    push @$elems, $elem unless grep { $_ eq $elem } @$elems;
}

sub ACTION_config_data {
  my $self = shift;
  return unless $self->has_config_data;

  my $module_name = $self->module_name
    or die "The config_data feature requires that 'module_name' be set";
  my $notes_name = $module_name . '::ConfigData'; # TODO: Customize name ???
  my $notes_pm = File::Spec->catfile($self->blib, 'lib', split /::/, "$notes_name.pm");

  return if $self->up_to_date(['Build.PL',
                               $self->config_file('config_data'),
                               $self->config_file('features')
                              ], $notes_pm);

  $self->log_verbose("Writing config notes to $notes_pm\n");
  File::Path::mkpath(File::Basename::dirname($notes_pm));

  Module::Build::Notes->write_config_data
    (
     file => $notes_pm,
     module => $module_name,
     config_module => $notes_name,
     config_data => scalar $self->config_data,
     feature => scalar $self->{phash}{features}->access(),
     auto_features => scalar $self->auto_features,
    );
}

########################################################################
{ # enclosing these lexicals -- TODO
  my %valid_properties = ( __PACKAGE__,  {} );
  my %additive_properties;

  sub _mb_classes {
    my $class = ref($_[0]) || $_[0];
    return ($class, $class->mb_parents);
  }

  sub valid_property {
    my ($class, $prop) = @_;
    return grep exists( $valid_properties{$_}{$prop} ), $class->_mb_classes;
  }

  sub valid_properties {
    return keys %{ shift->valid_properties_defaults() };
  }

  sub valid_properties_defaults {
    my %out;
    for my $class (reverse shift->_mb_classes) {
      @out{ keys %{ $valid_properties{$class} } } = map {
        $_->()
      } values %{ $valid_properties{$class} };
    }
    return \%out;
  }

  sub array_properties {
    map { exists $additive_properties{$_}->{ARRAY} ? @{$additive_properties{$_}->{ARRAY}} : () } shift->_mb_classes;
  }

  sub hash_properties {
    map { exists $additive_properties{$_}->{HASH} ? @{$additive_properties{$_}->{HASH}} : () } shift->_mb_classes;
  }

  sub add_property {
    my ($class, $property) = (shift, shift);
    die "Property '$property' already exists"
      if $class->valid_property($property);
    my %p = @_ == 1 ? ( default => shift ) : @_;

    my $type = ref $p{default};
    $valid_properties{$class}{$property} =
      $type eq 'CODE' ? $p{default}                           :
      $type eq 'HASH' ? sub { return { %{ $p{default} } }   } :
      $type eq 'ARRAY'? sub { return [ @{ $p{default} } ]   } :
                        sub { return $p{default}            } ;

    push @{$additive_properties{$class}->{$type}}, $property
      if $type;

    unless ($class->can($property)) {
      # TODO probably should put these in a util package
      my $sub = $type eq 'HASH'
        ? _make_hash_accessor($property, \%p)
        : _make_accessor($property, \%p);
      no strict 'refs';
      *{"$class\::$property"} = $sub;
    }

    return $class;
  }

  sub property_error {
    my $self = shift;
    die 'ERROR: ', @_;
  }

  sub _set_defaults {
    my $self = shift;

    # Set the build class.
    $self->{properties}{build_class} ||= ref $self;

    # If there was no orig_dir, set to the same as base_dir
    $self->{properties}{orig_dir} ||= $self->{properties}{base_dir};

    my $defaults = $self->valid_properties_defaults;

    foreach my $prop (keys %$defaults) {
      $self->{properties}{$prop} = $defaults->{$prop}
        unless exists $self->{properties}{$prop};
    }

    # Copy defaults for arrays any arrays.
    for my $prop ($self->array_properties) {
      $self->{properties}{$prop} = [@{$defaults->{$prop}}]
        unless exists $self->{properties}{$prop};
    }
    # Copy defaults for arrays any hashes.
    for my $prop ($self->hash_properties) {
      $self->{properties}{$prop} = {%{$defaults->{$prop}}}
        unless exists $self->{properties}{$prop};
    }
  }

} # end enclosure
########################################################################
sub _make_hash_accessor {
  my ($property, $p) = @_;
  my $check = $p->{check} || sub { 1 };

  return sub {
    my $self = shift;

    # This is only here to deprecate the historic accident of calling
    # properties as class methods - I suspect it only happens in our
    # test suite.
    unless(ref($self)) {
      carp("\n$property not a class method (@_)");
      return;
    }

    my $x = $self->{properties};
    return $x->{$property} unless @_;

    my $prop = $x->{$property};
    if ( defined $_[0] && !ref $_[0] ) {
      if ( @_ == 1 ) {
        return exists $prop->{$_[0]} ? $prop->{$_[0]} : undef;
      } elsif ( @_ % 2 == 0 ) {
        my %new = (%{ $prop }, @_);
        local $_ = \%new;
        $x->{$property} = \%new if $check->($self);
        return $x->{$property};
      } else {
        die "Unexpected arguments for property '$property'\n";
      }
    } else {
      die "Unexpected arguments for property '$property'\n"
          if defined $_[0] && ref $_[0] ne 'HASH';
      local $_ = $_[0];
      $x->{$property} = shift if $check->($self);
    }
  };
}
########################################################################
sub _make_accessor {
  my ($property, $p) = @_;
  my $check = $p->{check} || sub { 1 };

  return sub {
    my $self = shift;

    # This is only here to deprecate the historic accident of calling
    # properties as class methods - I suspect it only happens in our
    # test suite.
    unless(ref($self)) {
      carp("\n$property not a class method (@_)");
      return;
    }

    my $x = $self->{properties};
    return $x->{$property} unless @_;
    local $_ = $_[0];
    $x->{$property} = shift if $check->($self);
    return $x->{$property};
  };
}
########################################################################

# Add the default properties.
__PACKAGE__->add_property(auto_configure_requires => 1);
__PACKAGE__->add_property(blib => 'blib');
__PACKAGE__->add_property(build_class => 'Module::Build');
__PACKAGE__->add_property(build_elements => [qw(PL support pm xs share_dir pod script)]);
__PACKAGE__->add_property(build_script => 'Build');
__PACKAGE__->add_property(build_bat => 0);
__PACKAGE__->add_property(bundle_inc => []);
__PACKAGE__->add_property(bundle_inc_preload => []);
__PACKAGE__->add_property(config_dir => '_build');
__PACKAGE__->add_property(dynamic_config => 1);
__PACKAGE__->add_property(include_dirs => []);
__PACKAGE__->add_property(license => 'unknown');
__PACKAGE__->add_property(metafile => 'META.yml');
__PACKAGE__->add_property(mymetafile => 'MYMETA.yml');
__PACKAGE__->add_property(metafile2 => 'META.json');
__PACKAGE__->add_property(mymetafile2 => 'MYMETA.json');
__PACKAGE__->add_property(recurse_into => []);
__PACKAGE__->add_property(use_rcfile => 1);
__PACKAGE__->add_property(create_packlist => 1);
__PACKAGE__->add_property(allow_mb_mismatch => 0);
__PACKAGE__->add_property(config => undef);
__PACKAGE__->add_property(test_file_exts => ['.t']);
__PACKAGE__->add_property(use_tap_harness => 0);
__PACKAGE__->add_property(cpan_client => 'cpan');
__PACKAGE__->add_property(tap_harness_args => {});
__PACKAGE__->add_property(pureperl_only => 0);
__PACKAGE__->add_property(allow_pureperl => 0);
__PACKAGE__->add_property(
  'installdirs',
  default => 'site',
  check   => sub {
    return 1 if /^(core|site|vendor)$/;
    return shift->property_error(
      $_ eq 'perl'
      ? 'Perhaps you meant installdirs to be "core" rather than "perl"?'
      : 'installdirs must be one of "core", "site", or "vendor"'
    );
    return shift->property_error("Perhaps you meant 'core'?") if $_ eq 'perl';
    return 0;
  },
);

{
  __PACKAGE__->add_property(html_css => '');
}

{
  my @prereq_action_types = qw(requires build_requires test_requires conflicts recommends);
  foreach my $type (@prereq_action_types) {
    __PACKAGE__->add_property($type => {});
  }
  __PACKAGE__->add_property(prereq_action_types => \@prereq_action_types);
}

__PACKAGE__->add_property($_ => {}) for qw(
  get_options
  install_base_relpaths
  install_path
  install_sets
  meta_add
  meta_merge
  original_prefix
  prefix_relpaths
  configure_requires
);

__PACKAGE__->add_property($_) for qw(
  PL_files
  autosplit
  base_dir
  bindoc_dirs
  c_source
  create_license
  create_makefile_pl
  create_readme
  debugger
  destdir
  dist_abstract
  dist_author
  dist_name
  dist_suffix
  dist_version
  dist_version_from
  extra_compiler_flags
  extra_linker_flags
  has_config_data
  install_base
  libdoc_dirs
  magic_number
  mb_version
  module_name
  needs_compiler
  orig_dir
  perl
  pm_files
  pod_files
  pollute
  prefix
  program_name
  quiet
  recursive_test_files
  release_status
  script_files
  scripts
  share_dir
  sign
  test_files
  verbose
  debug
  xs_files
  extra_manify_args
);

sub config {
  my $self = shift;
  my $c = ref($self) ? $self->{config} : 'Module::Build::Config';
  return $c->all_config unless @_;

  my $key = shift;
  return $c->get($key) unless @_;

  my $val = shift;
  return $c->set($key => $val);
}

sub mb_parents {
    # Code borrowed from Class::ISA.
    my @in_stack = (shift);
    my %seen = ($in_stack[0] => 1);

    my ($current, @out);
    while (@in_stack) {
        next unless defined($current = shift @in_stack)
          && $current->isa('Module::Build::Base');
        push @out, $current;
        next if $current eq 'Module::Build::Base';
        no strict 'refs';
        unshift @in_stack,
          map {
              my $c = $_; # copy, to avoid being destructive
              substr($c,0,2) = "main::" if substr($c,0,2) eq '::';
              # Canonize the :: -> main::, ::foo -> main::foo thing.
              # Should I ever canonize the Foo'Bar = Foo::Bar thing?
              $seen{$c}++ ? () : $c;
          } @{"$current\::ISA"};

        # I.e., if this class has any parents (at least, ones I've never seen
        # before), push them, in order, onto the stack of classes I need to
        # explore.
    }
    shift @out;
    return @out;
}

sub extra_linker_flags   { shift->_list_accessor('extra_linker_flags',   @_) }
sub extra_compiler_flags { shift->_list_accessor('extra_compiler_flags', @_) }

sub _list_accessor {
  (my $self, local $_) = (shift, shift);
  my $p = $self->{properties};
  $p->{$_} = [@_] if @_;
  $p->{$_} = [] unless exists $p->{$_};
  return ref($p->{$_}) ? $p->{$_} : [$p->{$_}];
}

# XXX Problem - if Module::Build is loaded from a different directory,
# it'll look for (and perhaps destroy/create) a _build directory.
sub subclass {
  my ($pack, %opts) = @_;

  my $build_dir = '_build'; # XXX The _build directory is ostensibly settable by the user.  Shouldn't hard-code here.
  $pack->delete_filetree($build_dir) if -e $build_dir;

  die "Must provide 'code' or 'class' option to subclass()\n"
    unless $opts{code} or $opts{class};

  $opts{code}  ||= '';
  $opts{class} ||= 'MyModuleBuilder';

  my $filename = File::Spec->catfile($build_dir, 'lib', split '::', $opts{class}) . '.pm';
  my $filedir  = File::Basename::dirname($filename);
  $pack->log_verbose("Creating custom builder $filename in $filedir\n");

  File::Path::mkpath($filedir);
  die "Can't create directory $filedir: $!" unless -d $filedir;

  open(my $fh, '>', $filename) or die "Can't create $filename: $!";
  print $fh <<EOF;
package $opts{class};
use $pack;
\@ISA = qw($pack);
$opts{code}
1;
EOF
  close $fh;

  unshift @INC, File::Spec->catdir(File::Spec->rel2abs($build_dir), 'lib');
  eval "use $opts{class}";
  die $@ if $@;

  return $opts{class};
}

sub _guess_module_name {
  my $self = shift;
  my $p = $self->{properties};
  return if $p->{module_name};
  if ( $p->{dist_version_from} && -e $p->{dist_version_from} ) {
    my $mi = Module::Build::ModuleInfo->new_from_file($self->dist_version_from);
    $p->{module_name} = $mi->name;
  }
  else {
    my $mod_path = my $mod_name = $p->{dist_name};
    $mod_name =~ s{-}{::}g;
    $mod_path =~ s{-}{/}g;
    $mod_path .= ".pm";
    if ( -e $mod_path || -e "lib/$mod_path" ) {
      $p->{module_name} = $mod_name;
    }
    else {
      $self->log_warn( << 'END_WARN' );
No 'module_name' was provided and it could not be inferred
from other properties.  This will prevent a packlist from
being written for this file.  Please set either 'module_name'
or 'dist_version_from' in Build.PL.
END_WARN
    }
  }
}

sub dist_name {
  my $self = shift;
  my $p = $self->{properties};
  my $me = 'dist_name';
  return $p->{$me} if defined $p->{$me};

  die "Can't determine distribution name, must supply either 'dist_name' or 'module_name' parameter"
    unless $self->module_name;

  ($p->{$me} = $self->module_name) =~ s/::/-/g;

  return $p->{$me};
}

sub release_status {
  my ($self) = @_;
  my $me = 'release_status';
  my $p = $self->{properties};

  if ( ! defined $p->{$me} ) {
    $p->{$me} = $self->_is_dev_version ? 'testing' : 'stable';
  }

  unless ( $p->{$me} =~ qr/\A(?:stable|testing|unstable)\z/ ) {
    die "Illegal value '$p->{$me}' for $me\n";
  }

  if ( $p->{$me} eq 'stable' && $self->_is_dev_version ) {
    my $version = $self->dist_version;
    die "Illegal value '$p->{$me}' with version '$version'\n";
  }
  return $p->{$me};
}

sub dist_suffix {
  my ($self) = @_;
  my $p = $self->{properties};
  my $me = 'dist_suffix';

  return $p->{$me} if defined $p->{$me};

  if ( $self->release_status eq 'stable' ) {
    $p->{$me} = "";
  }
  else {
    # non-stable release but non-dev version number needs '-TRIAL' appended
    $p->{$me} = $self->_is_dev_version ? "" : "TRIAL" ;
  }

  return $p->{$me};
}

sub dist_version_from {
  my ($self) = @_;
  my $p = $self->{properties};
  my $me = 'dist_version_from';

  if ($self->module_name) {
    $p->{$me} ||=
      join( '/', 'lib', split(/::/, $self->module_name) ) . '.pm';
  }
  return $p->{$me} || undef;
}

sub dist_version {
  my ($self) = @_;
  my $p = $self->{properties};
  my $me = 'dist_version';

  return $p->{$me} if defined $p->{$me};

  if ( my $dist_version_from = $self->dist_version_from ) {
    my $version_from = File::Spec->catfile( split( qr{/}, $dist_version_from ) );
    my $pm_info = Module::Build::ModuleInfo->new_from_file( $version_from )
      or die "Can't find file $version_from to determine version";
    #$p->{$me} is undef here
    $p->{$me} = $self->normalize_version( $pm_info->version() );
    unless (defined $p->{$me}) {
      die "Can't determine distribution version from $version_from";
    }
  }

  die ("Can't determine distribution version, must supply either 'dist_version',\n".
       "'dist_version_from', or 'module_name' parameter")
    unless defined $p->{$me};

  return $p->{$me};
}

sub _is_dev_version {
  my ($self) = @_;
  my $dist_version = $self->dist_version;
  my $version_obj = eval { Module::Build::Version->new( $dist_version ) };
  # assume it's normal if the version string is fatal -- in this case
  # the author might be doing something weird so should play along and
  # assume they'll specify all necessary behavior
  return $@ ? 0 : $version_obj->is_alpha;
}

sub dist_author   { shift->_pod_parse('author')   }
sub dist_abstract { shift->_pod_parse('abstract') }

sub _pod_parse {
  my ($self, $part) = @_;
  my $p = $self->{properties};
  my $member = "dist_$part";
  return $p->{$member} if defined $p->{$member};

  my $docfile = $self->_main_docfile
    or return;
  open(my $fh, '<', $docfile)
    or return;

  require Module::Build::PodParser;
  my $parser = Module::Build::PodParser->new(fh => $fh);
  my $method = "get_$part";
  return $p->{$member} = $parser->$method();
}

sub version_from_file { # Method provided for backwards compatibility
  return Module::Build::ModuleInfo->new_from_file($_[1])->version();
}

sub find_module_by_name { # Method provided for backwards compatibility
  return Module::Build::ModuleInfo->find_module_by_name(@_[1,2]);
}

{
  # $unlink_list_for_pid{$$} = [ ... ]
  my %unlink_list_for_pid;

  sub _unlink_on_exit {
    my $self = shift;
    for my $f ( @_ ) {
      push @{$unlink_list_for_pid{$$}}, $f if -f $f;
    }
    return 1;
  }

  END {
    for my $f ( map glob($_), @{ $unlink_list_for_pid{$$} || [] } ) {
      next unless -e $f;
      File::Path::rmtree($f, 0, 0);
    }
  }
}

sub add_to_cleanup {
  my $self = shift;
  my %files = map {$self->localize_file_path($_), 1} @_;
  $self->{phash}{cleanup}->write(\%files);
}

sub cleanup {
  my $self = shift;
  my $all = $self->{phash}{cleanup}->read;
  return keys %$all;
}

sub config_file {
  my $self = shift;
  return unless -d $self->config_dir;
  return File::Spec->catfile($self->config_dir, @_);
}

sub read_config {
  my ($self) = @_;

  my $file = $self->config_file('build_params')
    or die "Can't find 'build_params' in " . $self->config_dir;
  open(my $fh, '<', $file) or die "Can't read '$file': $!";
  my $ref = eval do {local $/; <$fh>};
  die if $@;
  close $fh;
  my $c;
  ($self->{args}, $c, $self->{properties}) = @$ref;
  $self->{config} = Module::Build::Config->new(values => $c);
}

sub has_config_data {
  my $self = shift;
  return scalar grep $self->{phash}{$_}->has_data(), qw(config_data features auto_features);
}

sub _write_data {
  my ($self, $filename, $data) = @_;

  my $file = $self->config_file($filename);
  open(my $fh, '>', $file) or die "Can't create '$file': $!";
  unless (ref($data)) {  # e.g. magicnum
    print $fh $data;
    return;
  }

  print {$fh} Module::Build::Dumper->_data_dump($data);
  close $fh;
}

sub write_config {
  my ($self) = @_;

  File::Path::mkpath($self->{properties}{config_dir});
  -d $self->{properties}{config_dir} or die "Can't mkdir $self->{properties}{config_dir}: $!";

  my @items = @{ $self->prereq_action_types };
  $self->_write_data('prereqs', { map { $_, $self->$_() } @items });
  $self->_write_data('build_params', [$self->{args}, $self->{config}->values_set, $self->{properties}]);

  # Set a new magic number and write it to a file
  $self->_write_data('magicnum', $self->magic_number(int rand 1_000_000));

  $self->{phash}{$_}->write() foreach qw(notes cleanup features auto_features config_data runtime_params);
}

{
  # packfile map -- keys are guts of regular expressions;  If they match,
  # values are module names corresponding to the packlist
  my %packlist_map = (
    '^File::Spec'         => 'Cwd',
    '^Devel::AssertOS'    => 'Devel::CheckOS',
  );

  sub _find_packlist {
    my ($self, $inst, $mod) = @_;
    my $lookup = $mod;
    my $packlist = eval { $inst->packlist($lookup) };
    if ( ! $packlist ) {
      # try from packlist_map
      while ( my ($re, $new_mod) = each %packlist_map ) {
        if ( $mod =~ qr/$re/ ) {
          $lookup = $new_mod;
          $packlist = eval { $inst->packlist($lookup) };
          last;
        }
      }
    }
    return $packlist ? $lookup : undef;
  }

  sub set_bundle_inc {
    my $self = shift;

    my $bundle_inc = $self->{properties}{bundle_inc};
    my $bundle_inc_preload = $self->{properties}{bundle_inc_preload};
    # We're in author mode if inc::latest is loaded, but not from cwd
    return unless inc::latest->can('loaded_modules');
    require ExtUtils::Installed;
    # ExtUtils::Installed is buggy about finding additions to default @INC
    my $inst = eval { ExtUtils::Installed->new(extra_libs => [@INC]) };
    if ($@) {
      $self->log_warn( << "EUI_ERROR" );
Bundling in inc/ is disabled because ExtUtils::Installed could not
create a list of your installed modules.  Here is the error:
$@
EUI_ERROR
      return;
    }
    my @bundle_list = map { [ $_, 0 ] } inc::latest->loaded_modules;

    # XXX TODO: Need to get ordering of prerequisites correct so they are
    # are loaded in the right order. Use an actual tree?!

    while( @bundle_list ) {
      my ($mod, $prereq) = @{ shift @bundle_list };

      # XXX TODO: Append prereqs to list
      # skip if core or already in bundle or preload lists
      # push @bundle_list, [$_, 1] for prereqs()

      # Locate packlist for bundling
      my $lookup = $self->_find_packlist($inst,$mod);
      if ( ! $lookup ) {
        # XXX Really needs a more helpful error message here
        die << "NO_PACKLIST";
Could not find a packlist for '$mod'.  If it's a core module, try
force installing it from CPAN.
NO_PACKLIST
      }
      else {
        push @{ $prereq ? $bundle_inc_preload : $bundle_inc }, $lookup;
      }
    }
  } # sub check_bundling
}

sub check_autofeatures {
  my ($self) = @_;
  my $features = $self->auto_features;

  return 1 unless %$features;

  # TODO refactor into ::Util
  my $longest = sub {
    my @str = @_ or croak("no strings given");

    my @len = map({length($_)} @str);
    my $max = 0;
    my $longest;
    for my $i (0..$#len) {
      ($max, $longest) = ($len[$i], $str[$i]) if($len[$i] > $max);
    }
    return($longest);
  };
  my $max_name_len = length($longest->(keys %$features));

  my ($num_disabled, $log_text) = (0, "\nChecking optional features...\n");
  for my $name ( sort keys %$features ) {
    $log_text .= $self->_feature_deps_msg($name, $max_name_len);
  }

  $num_disabled = () = $log_text =~ /disabled/g;

  # warn user if features disabled
  if ( $num_disabled ) {
    $self->log_warn( $log_text );
    return 0;
  }
  else {
    $self->log_verbose( $log_text );
    return 1;
  }
}

sub _feature_deps_msg {
  my ($self, $name, $max_name_len) = @_;
    $max_name_len ||= length $name;
    my $features = $self->auto_features;
    my $info = $features->{$name};
    my $feature_text = "$name" . '.' x ($max_name_len - length($name) + 4);

    my ($log_text, $disabled) = ('','');
    if ( my $failures = $self->prereq_failures($info) ) {
      $disabled = grep( /^(?:\w+_)?(?:requires|conflicts)$/,
                  keys %$failures ) ? 1 : 0;
      $feature_text .= $disabled ? "disabled\n" : "enabled\n";

      for my $type ( @{ $self->prereq_action_types } ) {
        next unless exists $failures->{$type};
        $feature_text .= "  $type:\n";
        my $prereqs = $failures->{$type};
        for my $module ( sort keys %$prereqs ) {
          my $status = $prereqs->{$module};
          my $required =
            ($type =~ /^(?:\w+_)?(?:requires|conflicts)$/) ? 1 : 0;
          my $prefix = ($required) ? '!' : '*';
          $feature_text .= "    $prefix $status->{message}\n";
        }
      }
    } else {
      $feature_text .= "enabled\n";
    }
    $log_text .= $feature_text if $disabled || $self->verbose;
    return $log_text;
}

# Automatically detect configure_requires prereqs
sub auto_config_requires {
  my ($self) = @_;
  my $p = $self->{properties};

  # add current Module::Build to configure_requires if there
  # isn't one already specified (but not ourself, so we're not circular)
  if ( $self->dist_name ne 'Module-Build'
    && $self->auto_configure_requires
    && ! exists $p->{configure_requires}{'Module::Build'}
  ) {
    (my $ver = $VERSION) =~ s/^(\d+\.\d\d).*$/$1/; # last major release only
    $self->log_warn(<<EOM);
Module::Build was not found in configure_requires! Adding it now
automatically as: configure_requires => { 'Module::Build' => $ver }
EOM
    $self->_add_prereq('configure_requires', 'Module::Build', $ver);
  }

  # if we're in author mode, add inc::latest modules to
  # configure_requires if not already set.  If we're not in author mode
  # then configure_requires will have been satisfied, or we'll just
  # live with what we've bundled
  if ( inc::latest->can('loaded_module') ) {
    for my $mod ( inc::latest->loaded_modules ) {
      next if exists $p->{configure_requires}{$mod};
      $self->_add_prereq('configure_requires', $mod, $mod->VERSION);
    }
  }

  return;
}

# Automatically detect and add prerequisites based on configuration
sub auto_require {
  my ($self) = @_;
  my $p = $self->{properties};

  # If needs_compiler is not explicitly set, automatically set it
  # If set, we need ExtUtils::CBuilder (and a compiler)
  my $xs_files = $self->find_xs_files;
  if ( ! defined $p->{needs_compiler} ) {
    $self->needs_compiler( keys %$xs_files || defined $self->c_source );
  }
  if ($self->needs_compiler) {
    $self->_add_prereq('build_requires', 'ExtUtils::CBuilder', 0);
    if ( ! $self->have_c_compiler ) {
      $self->log_warn(<<'EOM');
Warning: ExtUtils::CBuilder not installed or no compiler detected
Proceeding with configuration, but compilation may fail during Build

EOM
    }
  }

  # If using share_dir, require File::ShareDir
  if ( $self->share_dir ) {
    $self->_add_prereq( 'requires', 'File::ShareDir', '1.00' );
  }

  return;
}

sub _add_prereq {
  my ($self, $type, $module, $version) = @_;
  my $p = $self->{properties};
  $version = 0 unless defined $version;
  if ( exists $p->{$type}{$module} ) {
    return if $self->compare_versions( $version, '<=', $p->{$type}{$module} );
  }
  $self->log_verbose("Adding to $type\: $module => $version\n");
  $p->{$type}{$module} = $version;
  return 1;
}

sub prereq_failures {
  my ($self, $info) = @_;

  my @types = @{ $self->prereq_action_types };
  $info ||= {map {$_, $self->$_()} @types};

  my $out;

  foreach my $type (@types) {
    my $prereqs = $info->{$type};
    for my $modname ( keys %$prereqs ) {
      my $spec = $prereqs->{$modname};
      my $status = $self->check_installed_status($modname, $spec);

      if ($type =~ /^(?:\w+_)?conflicts$/) {
        next if !$status->{ok};
        $status->{conflicts} = delete $status->{need};
        $status->{message} = "$modname ($status->{have}) conflicts with this distribution";

      } elsif ($type =~ /^(?:\w+_)?recommends$/) {
        next if $status->{ok};
        $status->{message} = (!ref($status->{have}) && $status->{have} eq '<none>'
                              ? "$modname is not installed"
                              : "$modname ($status->{have}) is installed, but we prefer to have $spec");
      } else {
        next if $status->{ok};
      }

      $out->{$type}{$modname} = $status;
    }
  }

  return $out;
}

# returns a hash of defined prerequisites; i.e. only prereq types with values
sub _enum_prereqs {
  my $self = shift;
  my %prereqs;
  foreach my $type ( @{ $self->prereq_action_types } ) {
    if ( $self->can( $type ) ) {
      my $prereq = $self->$type() || {};
      $prereqs{$type} = $prereq if %$prereq;
    }
  }
  return \%prereqs;
}

sub check_prereq {
  my $self = shift;

  # Check to see if there are any prereqs to check
  my $info = $self->_enum_prereqs;
  return 1 unless $info;

  my $log_text = "Checking prerequisites...\n";

  my $failures = $self->prereq_failures($info);

  if ( $failures ) {
    $self->log_warn($log_text);
    for my $type ( @{ $self->prereq_action_types } ) {
      my $prereqs = $failures->{$type};
      $self->log_warn("  ${type}:\n") if keys %$prereqs;
      for my $module ( sort keys %$prereqs ) {
        my $status = $prereqs->{$module};
        my $prefix = ($type =~ /^(?:\w+_)?recommends$/) ? "* " : "! ";
        $self->log_warn("    $prefix $status->{message}\n");
      }
    }
    return 0;
  } else {
    $self->log_verbose($log_text . "Looks good\n\n");
    return 1;
  }
}

sub perl_version {
  my ($self) = @_;
  # Check the current perl interpreter
  # It's much more convenient to use $] here than $^V, but 'man
  # perlvar' says I'm not supposed to.  Bloody tyrant.
  return $^V ? $self->perl_version_to_float(sprintf "%vd", $^V) : $];
}

sub perl_version_to_float {
  my ($self, $version) = @_;
  return $version if grep( /\./, $version ) < 2;
  $version =~ s/\./../;
  $version =~ s/\.(\d+)/sprintf '%03d', $1/eg;
  return $version;
}

sub _parse_conditions {
  my ($self, $spec) = @_;

  return ">= 0" if not defined $spec;
  if ($spec =~ /^\s*([\w.]+)\s*$/) { # A plain number, maybe with dots, letters, and underscores
    return (">= $spec");
  } else {
    return split /\s*,\s*/, $spec;
  }
}

sub try_require {
  my ($self, $modname, $spec) = @_;
  my $status = $self->check_installed_status($modname, defined($spec) ? $spec : 0);
  return unless $status->{ok};
  my $path = $modname;
  $path =~ s{::}{/}g;
  $path .= ".pm";
  if ( defined $INC{$path} ) {
    return 1;
  }
  elsif ( exists $INC{$path} ) { # failed before, don't try again
    return;
  }
  else {
    return eval "require $modname";
  }
}

sub check_installed_status {
  my ($self, $modname, $spec) = @_;
  my %status = (need => $spec);

  if ($modname eq 'perl') {
    $status{have} = $self->perl_version;

  } elsif (eval { no strict; $status{have} = ${"${modname}::VERSION"} }) {
    # Don't try to load if it's already loaded

  } else {
    my $pm_info = Module::Build::ModuleInfo->new_from_module( $modname );
    unless (defined( $pm_info )) {
      @status{ qw(have message) } = ('<none>', "$modname is not installed");
      return \%status;
    }

    $status{have} = eval { $pm_info->version() };
    if ($spec and !defined($status{have})) {
      @status{ qw(have message) } = (undef, "Couldn't find a \$VERSION in prerequisite $modname");
      return \%status;
    }
  }

  my @conditions = $self->_parse_conditions($spec);

  foreach (@conditions) {
    my ($op, $version) = /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x
      or die "Invalid prerequisite condition '$_' for $modname";

    $version = $self->perl_version_to_float($version)
      if $modname eq 'perl';

    next if $op eq '>=' and !$version;  # Module doesn't have to actually define a $VERSION

    unless ($self->compare_versions( $status{have}, $op, $version )) {
      $status{message} = "$modname ($status{have}) is installed, but we need version $op $version";
      return \%status;
    }
  }

  $status{ok} = 1;
  return \%status;
}

sub compare_versions {
  my $self = shift;
  my ($v1, $op, $v2) = @_;
  $v1 = Module::Build::Version->new($v1)
    unless UNIVERSAL::isa($v1,'Module::Build::Version');

  my $eval_str = "\$v1 $op \$v2";
  my $result   = eval $eval_str;
  $self->log_warn("error comparing versions: '$eval_str' $@") if $@;

  return $result;
}

# I wish I could set $! to a string, but I can't, so I use $@
sub check_installed_version {
  my ($self, $modname, $spec) = @_;

  my $status = $self->check_installed_status($modname, $spec);

  if ($status->{ok}) {
    return $status->{have} if $status->{have} and "$status->{have}" ne '<none>';
    return '0 but true';
  }

  $@ = $status->{message};
  return 0;
}

sub make_executable {
  # Perl's chmod() is mapped to useful things on various non-Unix
  # platforms, so we use it in the base class even though it looks
  # Unixish.

  my $self = shift;
  foreach (@_) {
    my $current_mode = (stat $_)[2];
    chmod $current_mode | oct(111), $_;
  }
}

sub is_executable {
  # We assume this does the right thing on generic platforms, though
  # we do some other more specific stuff on Unixish platforms.
  my ($self, $file) = @_;
  return -x $file;
}

sub _startperl { shift()->config('startperl') }

# Return any directories in @INC which are not in the default @INC for
# this perl.  For example, stuff passed in with -I or loaded with "use lib".
sub _added_to_INC {
  my $self = shift;

  my %seen;
  $seen{$_}++ foreach $self->_default_INC;
  return grep !$seen{$_}++, @INC;
}

# Determine the default @INC for this Perl
{
  my @default_inc; # Memoize
  sub _default_INC {
    my $self = shift;
    return @default_inc if @default_inc;

    local $ENV{PERL5LIB};  # this is not considered part of the default.

    my $perl = ref($self) ? $self->perl : $self->find_perl_interpreter;

    my @inc = $self->_backticks($perl, '-le', 'print for @INC');
    chomp @inc;

    return @default_inc = @inc;
  }
}

sub print_build_script {
  my ($self, $fh) = @_;

  my $build_package = $self->build_class;

  my $closedata="";

  my $config_requires;
  if ( -f $self->metafile ) {
    my $meta = eval { $self->read_metafile( $self->metafile ) };
    $config_requires = $meta && $meta->{configure_requires}{'Module::Build'};
  }
  $config_requires ||= 0;

  my %q = map {$_, $self->$_()} qw(config_dir base_dir);

  $q{base_dir} = Win32::GetShortPathName($q{base_dir}) if $self->is_windowsish;

  $q{magic_numfile} = $self->config_file('magicnum');

  my @myINC = $self->_added_to_INC;
  for (@myINC, values %q) {
    $_ = File::Spec->canonpath( $_ ) unless $self->is_vmsish;
    s/([\\\'])/\\$1/g;
  }

  my $quoted_INC = join ",\n", map "     '$_'", @myINC;
  my $shebang = $self->_startperl;
  my $magic_number = $self->magic_number;

  print $fh <<EOF;
$shebang

use strict;
use Cwd;
use File::Basename;
use File::Spec;

sub magic_number_matches {
  return 0 unless -e '$q{magic_numfile}';
  my \$FH;
  open \$FH, '<','$q{magic_numfile}' or return 0;
  my \$filenum = <\$FH>;
  close \$FH;
  return \$filenum == $magic_number;
}

my \$progname;
my \$orig_dir;
BEGIN {
  \$^W = 1;  # Use warnings
  \$progname = basename(\$0);
  \$orig_dir = Cwd::cwd();
  my \$base_dir = '$q{base_dir}';
  if (!magic_number_matches()) {
    unless (chdir(\$base_dir)) {
      die ("Couldn't chdir(\$base_dir), aborting\\n");
    }
    unless (magic_number_matches()) {
      die ("Configuration seems to be out of date, please re-run 'perl Build.PL' again.\\n");
    }
  }
  unshift \@INC,
    (
$quoted_INC
    );
  push \@INC, "." unless grep { \$_ eq "." } \@INC; # Force my process to include . in \@INC.
  \$ENV{"PERL_USE_UNSAFE_INC"} = 1; # Force all child processes to include . in \@INC.
}

close(*DATA) unless eof(*DATA); # ensure no open handles to this script

use $build_package;
Module::Build->VERSION(q{$config_requires});

# Some platforms have problems setting \$^X in shebang contexts, fix it up here
\$^X = Module::Build->find_perl_interpreter;

if (-e 'Build.PL' and not $build_package->up_to_date('Build.PL', \$progname)) {
   warn "Warning: Build.PL has been altered.  You may need to run 'perl Build.PL' again.\\n";
}

# This should have just enough arguments to be able to bootstrap the rest.
my \$build = $build_package->resume (
  properties => {
    config_dir => '$q{config_dir}',
    orig_dir => \$orig_dir,
  },
);

\$build->dispatch;
EOF
}

sub create_mymeta {
  my ($self) = @_;

  my ($meta_obj, $mymeta);
  my @metafiles = ( $self->metafile2, $self->metafile,  );
  my @mymetafiles = ( $self->mymetafile2, $self->mymetafile, );

  # cleanup old MYMETA
  for my $f ( @mymetafiles ) {
    if ( $self->delete_filetree($f) ) {
      $self->log_verbose("Removed previous '$f'\n");
    }
  }

  # Try loading META.json or META.yml
  if ( $self->try_require("CPAN::Meta", "2.110420") ) {
    for my $file ( @metafiles ) {
      next unless -f $file;
      $meta_obj = eval { CPAN::Meta->load_file($file, { lazy_validation => 0 }) };
      last if $meta_obj;
    }
  }

  # maybe get a copy in spec v2 format (regardless of original source)

  my $mymeta_obj;
  if ($meta_obj) {
    # if we have metadata, just update it
    my %updated = (
      %{ $meta_obj->as_struct({ version => 2.0 }) },
      prereqs => $self->_normalize_prereqs,
      dynamic_config => 0,
      generated_by => "Module::Build version $Module::Build::VERSION",
    );
    $mymeta_obj = CPAN::Meta->new( \%updated, { lazy_validation => 0 } );
  }
  else {
    $mymeta_obj = $self->_get_meta_object(quiet => 0, dynamic => 0, fatal => 1, auto => 0);
  }

  my @created = $self->_write_meta_files( $mymeta_obj, 'MYMETA' );

  $self->log_warn("Could not create MYMETA files\n")
    unless @created;

  return 1;
}

sub create_build_script {
  my ($self) = @_;

  $self->write_config;
  $self->create_mymeta;

  # Create Build
  my ($build_script, $dist_name, $dist_version)
    = map $self->$_(), qw(build_script dist_name dist_version);

  if ( $self->delete_filetree($build_script) ) {
    $self->log_verbose("Removed previous script '$build_script'\n");
  }

  $self->log_info("Creating new '$build_script' script for ",
                  "'$dist_name' version '$dist_version'\n");
  open(my $fh, '>', $build_script) or die "Can't create '$build_script': $!";
  $self->print_build_script($fh);
  close $fh;

  $self->make_executable($build_script);

  return 1;
}

sub check_manifest {
  my $self = shift;
  return unless -e 'MANIFEST';

  # Stolen nearly verbatim from MakeMaker.  But ExtUtils::Manifest
  # could easily be re-written into a modern Perl dialect.

  require ExtUtils::Manifest;  # ExtUtils::Manifest is not warnings clean.
  local ($^W, $ExtUtils::Manifest::Quiet) = (0,1);

  $self->log_verbose("Checking whether your kit is complete...\n");
  if (my @missed = ExtUtils::Manifest::manicheck()) {
    $self->log_warn("WARNING: the following files are missing in your kit:\n",
                    "\t", join("\n\t", @missed), "\n",
                    "Please inform the author.\n\n");
  } else {
    $self->log_verbose("Looks good\n\n");
  }
}

sub dispatch {
  my $self = shift;
  local $self->{_completed_actions} = {};

  if (@_) {
    my ($action, %p) = @_;
    my $args = $p{args} ? delete($p{args}) : {};

    local $self->{invoked_action} = $action;
    local $self->{args} = {%{$self->{args}}, %$args};
    local $self->{properties} = {%{$self->{properties}}, %p};
    return $self->_call_action($action);
  }

  die "No build action specified" unless $self->{action};
  local $self->{invoked_action} = $self->{action};
  $self->_call_action($self->{action});
}

sub _call_action {
  my ($self, $action) = @_;

  return if $self->{_completed_actions}{$action}++;

  local $self->{action} = $action;
  my $method = $self->can_action( $action );
  die "No action '$action' defined, try running the 'help' action.\n" unless $method;
  $self->log_debug("Starting ACTION_$action\n");
  my $rc = $self->$method();
  $self->log_debug("Finished ACTION_$action\n");
  return $rc;
}

sub can_action {
  my ($self, $action) = @_;
  return $self->can( "ACTION_$action" );
}

# cuts the user-specified options out of the command-line args
sub cull_options {
    my $self = shift;
    my (@argv) = @_;

    # XXX is it even valid to call this as a class method?
    return({}, @argv) unless(ref($self)); # no object

    my $specs = $self->get_options;
    return({}, @argv) unless($specs and %$specs); # no user options

    require Getopt::Long;
    # XXX Should we let Getopt::Long handle M::B's options? That would
    # be easy-ish to add to @specs right here, but wouldn't handle options
    # passed without "--" as M::B currently allows. We might be able to
    # get around this by setting the "prefix_pattern" Configure option.
    my @specs;
    my $args = {};
    # Construct the specifications for GetOptions.
    while (my ($k, $v) = each %$specs) {
        # Throw an error if specs conflict with our own.
        die "Option specification '$k' conflicts with a " . ref $self
          . " option of the same name"
          if $self->valid_property($k);
        push @specs, $k . (defined $v->{type} ? $v->{type} : '');
        push @specs, $v->{store} if exists $v->{store};
        $args->{$k} = $v->{default} if exists $v->{default};
    }

    local @ARGV = @argv; # No other way to dupe Getopt::Long

    # Get the options values and return them.
    # XXX Add option to allow users to set options?
    if ( @specs ) {
      Getopt::Long::Configure('pass_through');
      Getopt::Long::GetOptions($args, @specs);
    }

    return $args, @ARGV;
}

sub unparse_args {
  my ($self, $args) = @_;
  my @out;
  while (my ($k, $v) = each %$args) {
    push @out, (UNIVERSAL::isa($v, 'HASH')  ? map {+"--$k", "$_=$v->{$_}"} keys %$v :
                UNIVERSAL::isa($v, 'ARRAY') ? map {+"--$k", $_} @$v :
                ("--$k", $v));
  }
  return @out;
}

sub args {
    my $self = shift;
    return wantarray ? %{ $self->{args} } : $self->{args} unless @_;
    my $key = shift;
    $self->{args}{$key} = shift if @_;
    return $self->{args}{$key};
}

# allows select parameters (with underscores) to be spoken with dashes
# when used as command-line options
sub _translate_option {
  my $self = shift;
  my $opt  = shift;

  (my $tr_opt = $opt) =~ tr/-/_/;

  return $tr_opt if grep $tr_opt =~ /^(?:no_?)?$_$/, qw(
    create_license
    create_makefile_pl
    create_readme
    extra_compiler_flags
    extra_linker_flags
    install_base
    install_path
    meta_add
    meta_merge
    test_files
    use_rcfile
    use_tap_harness
    tap_harness_args
    cpan_client
    pureperl_only
    allow_pureperl
  ); # normalize only selected option names

  return $opt;
}

my %singular_argument = map { ($_ => 1) } qw/install_base prefix destdir installdir verbose quiet uninst debug sign/;

sub _read_arg {
  my ($self, $args, $key, $val) = @_;

  $key = $self->_translate_option($key);

  if ( exists $args->{$key} and not $singular_argument{$key} ) {
    $args->{$key} = [ $args->{$key} ] unless ref $args->{$key};
    push @{$args->{$key}}, $val;
  } else {
    $args->{$key} = $val;
  }
}

# decide whether or not an option requires/has an operand
sub _optional_arg {
  my $self = shift;
  my $opt  = shift;
  my $argv = shift;

  $opt = $self->_translate_option($opt);

  my @bool_opts = qw(
    build_bat
    create_license
    create_readme
    pollute
    quiet
    uninst
    use_rcfile
    verbose
    debug
    sign
    use_tap_harness
    pureperl_only
    allow_pureperl
  );

  # inverted boolean options; eg --noverbose or --no-verbose
  # converted to proper name & returned with false value (verbose, 0)
  if ( grep $opt =~ /^no[-_]?$_$/, @bool_opts ) {
    $opt =~ s/^no-?//;
    return ($opt, 0);
  }

  # non-boolean option; return option unchanged along with its argument
  return ($opt, shift(@$argv)) unless grep $_ eq $opt, @bool_opts;

  # we're punting a bit here, if an option appears followed by a digit
  # we take the digit as the argument for the option. If there is
  # nothing that looks like a digit, we pretend the option is a flag
  # that is being set and has no argument.
  my $arg = 1;
  $arg = shift(@$argv) if @$argv && $argv->[0] =~ /^\d+$/;

  return ($opt, $arg);
}

sub read_args {
  my $self = shift;

  (my $args, @_) = $self->cull_options(@_);
  my %args = %$args;

  my $opt_re = qr/[\w\-]+/;

  my ($action, @argv);
  while (@_) {
    local $_ = shift;
    if ( /^(?:--)?($opt_re)=(.*)$/ ) {
      $self->_read_arg(\%args, $1, $2);
    } elsif ( /^--($opt_re)$/ ) {
      my($opt, $arg) = $self->_optional_arg($1, \@_);
      $self->_read_arg(\%args, $opt, $arg);
    } elsif ( /^($opt_re)$/ and !defined($action)) {
      $action = $1;
    } else {
      push @argv, $_;
    }
  }
  $args{ARGV} = \@argv;

  for ('extra_compiler_flags', 'extra_linker_flags') {
    $args{$_} = [ $self->split_like_shell($args{$_}) ] if exists $args{$_};
  }

  # Convert to arrays
  for ('include_dirs') {
    $args{$_} = [ $args{$_} ] if exists $args{$_} && !ref $args{$_}
  }

  # Hashify these parameters
  for ($self->hash_properties, 'config') {
    next unless exists $args{$_};
    my %hash;
    $args{$_} ||= [];
    $args{$_} = [ $args{$_} ] unless ref $args{$_};
    foreach my $arg ( @{$args{$_}} ) {
      $arg =~ /($opt_re)=(.*)/
        or die "Malformed '$_' argument: '$arg' should be something like 'foo=bar'";
      $hash{$1} = $2;
    }
    $args{$_} = \%hash;
  }

  # De-tilde-ify any path parameters
  for my $key (qw(prefix install_base destdir)) {
    next if !defined $args{$key};
    $args{$key} = $self->_detildefy($args{$key});
  }

  for my $key (qw(install_path)) {
    next if !defined $args{$key};

    for my $subkey (keys %{$args{$key}}) {
      next if !defined $args{$key}{$subkey};
      my $subkey_ext = $self->_detildefy($args{$key}{$subkey});
      if ( $subkey eq 'html' ) { # translate for compatibility
        $args{$key}{binhtml} = $subkey_ext;
        $args{$key}{libhtml} = $subkey_ext;
      } else {
        $args{$key}{$subkey} = $subkey_ext;
      }
    }
  }

  if ($args{makefile_env_macros}) {
    require Module::Build::Compat;
    %args = (%args, Module::Build::Compat->makefile_to_build_macros);
  }

  return \%args, $action;
}

# Default: do nothing.  Overridden for Unix & Windows.
sub _detildefy {}


# merge Module::Build argument lists that have already been parsed
# by read_args(). Takes two references to option hashes and merges
# the contents, giving priority to the first.
sub _merge_arglist {
  my( $self, $opts1, $opts2 ) = @_;

  $opts1 ||= {};
  $opts2 ||= {};
  my %new_opts = %$opts1;
  while (my ($key, $val) = each %$opts2) {
    if ( exists( $opts1->{$key} ) ) {
      if ( ref( $val ) eq 'HASH' ) {
        while (my ($k, $v) = each %$val) {
          $new_opts{$key}{$k} = $v unless exists( $opts1->{$key}{$k} );
        }
      }
    } else {
      $new_opts{$key} = $val
    }
  }

  return %new_opts;
}

# Look for a home directory on various systems.
sub _home_dir {
  my @home_dirs;
  push( @home_dirs, $ENV{HOME} ) if $ENV{HOME};

  push( @home_dirs, File::Spec->catpath($ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '') )
      if $ENV{HOMEDRIVE} && $ENV{HOMEPATH};

  my @other_home_envs = qw( USERPROFILE APPDATA WINDIR SYS$LOGIN );
  push( @home_dirs, map $ENV{$_}, grep $ENV{$_}, @other_home_envs );

  my @real_home_dirs = grep -d, @home_dirs;

  return wantarray ? @real_home_dirs : shift( @real_home_dirs );
}

sub _find_user_config {
  my $self = shift;
  my $file = shift;
  foreach my $dir ( $self->_home_dir ) {
    my $path = File::Spec->catfile( $dir, $file );
    return $path if -e $path;
  }
  return undef;
}

# read ~/.modulebuildrc returning global options '*' and
# options specific to the currently executing $action.
sub read_modulebuildrc {
  my( $self, $action ) = @_;

  return () unless $self->use_rcfile;

  my $modulebuildrc;
  if ( exists($ENV{MODULEBUILDRC}) && $ENV{MODULEBUILDRC} eq 'NONE' ) {
    return ();
  } elsif ( exists($ENV{MODULEBUILDRC}) && -e $ENV{MODULEBUILDRC} ) {
    $modulebuildrc = $ENV{MODULEBUILDRC};
  } elsif ( exists($ENV{MODULEBUILDRC}) ) {
    $self->log_warn("WARNING: Can't find resource file " .
                    "'$ENV{MODULEBUILDRC}' defined in environment.\n" .
                    "No options loaded\n");
    return ();
  } else {
    $modulebuildrc = $self->_find_user_config( '.modulebuildrc' );
    return () unless $modulebuildrc;
  }

  open(my $fh, '<', $modulebuildrc )
      or die "Can't open $modulebuildrc: $!";

  my %options; my $buffer = '';
  while (defined( my $line = <$fh> )) {
    chomp( $line );
    $line =~ s/#.*$//;
    next unless length( $line );

    if ( $line =~ /^\S/ ) {
      if ( $buffer ) {
        my( $action, $options ) = split( /\s+/, $buffer, 2 );
        $options{$action} .= $options . ' ';
        $buffer = '';
      }
      $buffer = $line;
    } else {
      $buffer .= $line;
    }
  }

  if ( $buffer ) { # anything left in $buffer ?
    my( $action, $options ) = split( /\s+/, $buffer, 2 );
    $options{$action} .= $options . ' '; # merge if more than one line
  }

  my ($global_opts) =
    $self->read_args( $self->split_like_shell( $options{'*'} || '' ) );

  # let fakeinstall act like install if not provided
  if ( $action eq 'fakeinstall' && ! exists $options{fakeinstall} ) {
    $action = 'install';
  }
  my ($action_opts) =
    $self->read_args( $self->split_like_shell( $options{$action} || '' ) );

  # specific $action options take priority over global options '*'
  return $self->_merge_arglist( $action_opts, $global_opts );
}

# merge the relevant options in ~/.modulebuildrc into Module::Build's
# option list where they do not conflict with commandline options.
sub merge_modulebuildrc {
  my( $self, $action, %cmdline_opts ) = @_;
  my %rc_opts = $self->read_modulebuildrc( $action || $self->{action} || 'build' );
  my %new_opts = $self->_merge_arglist( \%cmdline_opts, \%rc_opts );
  $self->merge_args( $action, %new_opts );
}

sub merge_args {
  my ($self, $action, %args) = @_;
  $self->{action} = $action if defined $action;

  my %additive = map { $_ => 1 } $self->hash_properties;

  # Extract our 'properties' from $cmd_args, the rest are put in 'args'.
  while (my ($key, $val) = each %args) {
    $self->{phash}{runtime_params}->access( $key => $val )
      if $self->valid_property($key);

    if ($key eq 'config') {
      $self->config($_ => $val->{$_}) foreach keys %$val;
    } else {
      my $add_to = $additive{$key}             ? $self->{properties}{$key} :
                   $self->valid_property($key) ? $self->{properties}       :
                   $self->{args}               ;

      if ($additive{$key}) {
        $add_to->{$_} = $val->{$_} foreach keys %$val;
      } else {
        $add_to->{$key} = $val;
      }
    }
  }
}

sub cull_args {
  my $self = shift;
  my @arg_list = @_;
  unshift @arg_list, $self->split_like_shell($ENV{PERL_MB_OPT})
    if $ENV{PERL_MB_OPT};
  my ($args, $action) = $self->read_args(@arg_list);
  $self->merge_args($action, %$args);
  $self->merge_modulebuildrc( $action, %$args );
}

sub super_classes {
  my ($self, $class, $seen) = @_;
  $class ||= ref($self) || $self;
  $seen  ||= {};

  no strict 'refs';
  my @super = grep {not $seen->{$_}++} $class, @{ $class . '::ISA' };
  return @super, map {$self->super_classes($_,$seen)} @super;
}

sub known_actions {
  my ($self) = @_;

  my %actions;
  no strict 'refs';

  foreach my $class ($self->super_classes) {
    foreach ( keys %{ $class . '::' } ) {
      $actions{$1}++ if /^ACTION_(\w+)/;
    }
  }

  return wantarray ? sort keys %actions : \%actions;
}

sub get_action_docs {
  my ($self, $action) = @_;
  my $actions = $self->known_actions;
  die "No known action '$action'" unless $actions->{$action};

  my ($files_found, @docs) = (0);
  foreach my $class ($self->super_classes) {
    (my $file = $class) =~ s{::}{/}g;
    # NOTE: silently skipping relative paths if any chdir() happened
    $file = $INC{$file . '.pm'} or next;
    open(my $fh, '<', $file) or next;
    $files_found++;

    # Code below modified from /usr/bin/perldoc

    # Skip to ACTIONS section
    local $_;
    while (<$fh>) {
      last if /^=head1 ACTIONS\s/;
    }

    # Look for our action and determine the style
    my $style;
    while (<$fh>) {
      last if /^=head1 /;

      # only item and head2 are allowed (3&4 are not in 5.005)
      if(/^=(item|head2)\s+\Q$action\E\b/) {
        $style = $1;
        push @docs, $_;
        last;
      }
    }
    $style or next; # not here

    # and the content
    if($style eq 'item') {
      my ($found, $inlist) = (0, 0);
      while (<$fh>) {
        if (/^=(item|back)/) {
          last unless $inlist;
        }
        push @docs, $_;
        ++$inlist if /^=over/;
        --$inlist if /^=back/;
      }
    }
    else { # head2 style
      # stop at anything equal or greater than the found level
      while (<$fh>) {
        last if(/^=(?:head[12]|cut)/);
        push @docs, $_;
      }
    }
    # TODO maybe disallow overriding just pod for an action
    # TODO and possibly: @docs and last;
  }

  unless ($files_found) {
    $@ = "Couldn't find any documentation to search";
    return;
  }
  unless (@docs) {
    $@ = "Couldn't find any docs for action '$action'";
    return;
  }

  return join '', @docs;
}

sub ACTION_prereq_report {
  my $self = shift;
  $self->log_info( $self->prereq_report );
}

sub ACTION_prereq_data {
  my $self = shift;
  $self->log_info( Module::Build::Dumper->_data_dump( $self->prereq_data ) );
}

sub prereq_data {
  my $self = shift;
  my @types = ('configure_requires', @{ $self->prereq_action_types } );
  my $info = { map { $_ => $self->$_() } grep { %{$self->$_()} } @types };
  return $info;
}

sub prereq_report {
  my $self = shift;
  my $info = $self->prereq_data;

  my $output = '';
  foreach my $type (keys %$info) {
    my $prereqs = $info->{$type};
    $output .= "\n$type:\n";
    my $mod_len = 2;
    my $ver_len = 4;
    my %mods;
    while ( my ($modname, $spec) = each %$prereqs ) {
      my $len  = length $modname;
      $mod_len = $len if $len > $mod_len;
      $spec    ||= '0';
      $len     = length $spec;
      $ver_len = $len if $len > $ver_len;

      my $mod = $self->check_installed_status($modname, $spec);
      $mod->{name} = $modname;
      $mod->{ok} ||= 0;
      $mod->{ok} = ! $mod->{ok} if $type =~ /^(\w+_)?conflicts$/;

      $mods{lc $modname} = $mod;
    }

    my $space  = q{ } x ($mod_len - 3);
    my $vspace = q{ } x ($ver_len - 3);
    my $sline  = q{-} x ($mod_len - 3);
    my $vline  = q{-} x ($ver_len - 3);
    my $disposition = ($type =~ /^(\w+_)?conflicts$/) ?
                        'Clash' : 'Need';
    $output .=
      "    Module $space  $disposition $vspace  Have\n".
      "    ------$sline+------$vline-+----------\n";


    for my $k (sort keys %mods) {
      my $mod = $mods{$k};
      my $space  = q{ } x ($mod_len - length $k);
      my $vspace = q{ } x ($ver_len - length $mod->{need});
      my $f = $mod->{ok} ? ' ' : '!';
      $output .=
        "  $f $mod->{name} $space     $mod->{need}  $vspace   ".
        (defined($mod->{have}) ? $mod->{have} : "")."\n";
    }
  }
  return $output;
}

sub ACTION_help {
  my ($self) = @_;
  my $actions = $self->known_actions;

  if (@{$self->{args}{ARGV}}) {
    my $msg = eval {$self->get_action_docs($self->{args}{ARGV}[0], $actions)};
    print $@ ? "$@\n" : $msg;
    return;
  }

  print <<EOF;

 Usage: $0 <action> --arg1=value --arg2=value ...
 Example: $0 test --verbose=1

 Actions defined:
EOF

  print $self->_action_listing($actions);

  print "\nRun `Build help <action>` for details on an individual action.\n";
  print "See `perldoc Module::Build` for complete documentation.\n";
}

sub _action_listing {
  my ($self, $actions) = @_;

  # Flow down columns, not across rows
  my @actions = sort keys %$actions;
  @actions = map $actions[($_ + ($_ % 2) * @actions) / 2],  0..$#actions;

  my $out = '';
  while (my ($one, $two) = splice @actions, 0, 2) {
    $out .= sprintf("  %-12s                   %-12s\n", $one, $two||'');
  }
  $out =~ s{\s*$}{}mg; # remove trailing spaces
  return $out;
}

sub ACTION_retest {
  my ($self) = @_;

  # Protect others against our @INC changes
  local @INC = @INC;

  # Filter out nonsensical @INC entries - some versions of
  # Test::Harness will really explode the number of entries here
  @INC = grep {ref() || -d} @INC if @INC > 100;

  $self->do_tests;
}

sub ACTION_testall {
  my ($self) = @_;

  my @types;
  for my $action (grep { $_ ne 'all' } $self->get_test_types) {
    # XXX We can't just dispatch because we get multiple summaries but
    # we'll need to dispatch to support custom setup/teardown in the
    # action.  To support that, we'll need to call something besides
    # Harness::runtests() because we'll need to collect the results in
    # parts, then run the summary.
    push(@types, $action);
    #$self->_call_action( "test$action" );
  }
  $self->generic_test(types => ['default', @types]);
}

sub get_test_types {
  my ($self) = @_;

  my $t = $self->{properties}->{test_types};
  return ( defined $t ? ( keys %$t ) : () );
}


sub ACTION_test {
  my ($self) = @_;
  $self->generic_test(type => 'default');
}

sub generic_test {
  my $self = shift;
  (@_ % 2) and croak('Odd number of elements in argument hash');
  my %args = @_;

  my $p = $self->{properties};

  my @types = (
    (exists($args{type})  ? $args{type} : ()),
    (exists($args{types}) ? @{$args{types}} : ()),
  );
  @types or croak "need some types of tests to check";

  my %test_types = (
    default => $p->{test_file_exts},
    (defined($p->{test_types}) ? %{$p->{test_types}} : ()),
  );

  for my $type (@types) {
    croak "$type not defined in test_types!"
      unless defined $test_types{ $type };
  }

  # we use local here because it ends up two method calls deep
  local $p->{test_file_exts} = [ map { ref $_ ? @$_ : $_ } @test_types{@types} ];
  $self->depends_on('code');

  # Protect others against our @INC changes
  local @INC = @INC;

  # Make sure we test the module in blib/
  unshift @INC, (File::Spec->catdir($p->{base_dir}, $self->blib, 'lib'),
                 File::Spec->catdir($p->{base_dir}, $self->blib, 'arch'));

  # Filter out nonsensical @INC entries - some versions of
  # Test::Harness will really explode the number of entries here
  @INC = grep {ref() || -d} @INC if @INC > 100;

  $self->do_tests;
}

# Test::Harness dies on failure but TAP::Harness does not, so we must
# die if running under TAP::Harness
sub do_tests {
  my $self = shift;

  my $tests = $self->find_test_files;

  local $ENV{PERL_DL_NONLAZY} = 1;

  if(@$tests) {
    my $args = $self->tap_harness_args;
    if($self->use_tap_harness or ($args and %$args)) {
      my $aggregate = $self->run_tap_harness($tests);
      if ( $aggregate->has_errors ) {
        die "Errors in testing.  Cannot continue.\n";
      }
    }
    else {
      $self->run_test_harness($tests);
    }
  }
  else {
    $self->log_info("No tests defined.\n");
  }

  $self->run_visual_script;
}

sub run_tap_harness {
  my ($self, $tests) = @_;

  require TAP::Harness;

  # TODO allow the test @INC to be set via our API?

  my $aggregate = TAP::Harness->new({
    lib => [@INC],
    verbosity => $self->{properties}{verbose},
    switches  => [ $self->harness_switches ],
    %{ $self->tap_harness_args },
  })->runtests(@$tests);

  return $aggregate;
}

sub run_test_harness {
    my ($self, $tests) = @_;
    require Test::Harness;

    local $Test::Harness::verbose = $self->verbose || 0;
    local $Test::Harness::switches = join ' ', $self->harness_switches;

    Test::Harness::runtests(@$tests);
}

sub run_visual_script {
    my $self = shift;
    # This will get run and the user will see the output.  It doesn't
    # emit Test::Harness-style output.
    $self->run_perl_script('visual.pl', '-Mblib='.$self->blib)
        if -e 'visual.pl';
}

sub harness_switches {
    shift->{properties}{debugger} ? qw(-w -d) : ();
}

sub test_files {
  my $self = shift;
  my $p = $self->{properties};
  if (@_) {
    return $p->{test_files} = (@_ == 1 ? shift : [@_]);
  }
  return $self->find_test_files;
}

sub expand_test_dir {
  my ($self, $dir) = @_;
  my $exts = $self->{properties}{test_file_exts};

  return sort map { @{$self->rscan_dir($dir, qr{^[^.].*\Q$_\E$})} } @$exts
    if $self->recursive_test_files;

  return sort map { glob File::Spec->catfile($dir, "*$_") } @$exts;
}

sub ACTION_testdb {
  my ($self) = @_;
  local $self->{properties}{debugger} = 1;
  $self->depends_on('test');
}

sub ACTION_testcover {
  my ($self) = @_;

  unless (Module::Build::ModuleInfo->find_module_by_name('Devel::Cover')) {
    warn("Cannot run testcover action unless Devel::Cover is installed.\n");
    return;
  }

  $self->add_to_cleanup('coverage', 'cover_db');
  $self->depends_on('code');

  # See whether any of the *.pm files have changed since last time
  # testcover was run.  If so, start over.
  if (-e 'cover_db') {
    my $pm_files = $self->rscan_dir
        (File::Spec->catdir($self->blib, 'lib'), $self->file_qr('\.pm$') );
    my $cover_files = $self->rscan_dir('cover_db', sub {-f $_ and not /\.html$/});

    $self->do_system(qw(cover -delete))
      unless $self->up_to_date($pm_files,         $cover_files)
          && $self->up_to_date($self->test_files, $cover_files);
  }

  local $Test::Harness::switches    =
  local $Test::Harness::Switches    =
  local $ENV{HARNESS_PERL_SWITCHES} = "-MDevel::Cover";

  $self->depends_on('test');
  $self->do_system('cover');
}

sub ACTION_code {
  my ($self) = @_;

  # All installable stuff gets created in blib/ .
  # Create blib/arch to keep blib.pm happy
  my $blib = $self->blib;
  $self->add_to_cleanup($blib);
  File::Path::mkpath( File::Spec->catdir($blib, 'arch') );

  if (my $split = $self->autosplit) {
    $self->autosplit_file($_, $blib) for ref($split) ? @$split : ($split);
  }

  foreach my $element (@{$self->build_elements}) {
    my $method = "process_${element}_files";
    $method = "process_files_by_extension" unless $self->can($method);
    $self->$method($element);
  }

  $self->depends_on('config_data');
}

sub ACTION_build {
  my $self = shift;
  $self->log_info("Building " . $self->dist_name . "\n");
  $self->depends_on('code');
  $self->depends_on('docs');
}

sub process_files_by_extension {
  my ($self, $ext) = @_;

  my $method = "find_${ext}_files";
  my $files = $self->can($method) ? $self->$method() : $self->_find_file_by_type($ext,  'lib');

  while (my ($file, $dest) = each %$files) {
    $self->copy_if_modified(from => $file, to => File::Spec->catfile($self->blib, $dest) );
  }
}

sub process_support_files {
  my $self = shift;
  my $p = $self->{properties};
  return unless $p->{c_source};

  my $files;
  if (ref($p->{c_source}) eq "ARRAY") {
      push @{$p->{include_dirs}}, @{$p->{c_source}};
      for my $path (@{$p->{c_source}}) {
          push @$files, @{ $self->rscan_dir($path, $self->file_qr('\.c(c|p|pp|xx|\+\+)?$')) };
      }
  } else {
      push @{$p->{include_dirs}}, $p->{c_source};
      $files = $self->rscan_dir($p->{c_source}, $self->file_qr('\.c(c|p|pp|xx|\+\+)?$'));
  }

  foreach my $file (@$files) {
      push @{$p->{objects}}, $self->compile_c($file);
  }
}

sub process_share_dir_files {
  my $self = shift;
  my $files = $self->_find_share_dir_files;
  return unless $files;

  # root for all File::ShareDir paths
  my $share_prefix = File::Spec->catdir($self->blib, qw/lib auto share/);

  # copy all share files to blib
  while (my ($file, $dest) = each %$files) {
    $self->copy_if_modified(
      from => $file, to => File::Spec->catfile( $share_prefix, $dest )
    );
  }
}

sub _find_share_dir_files {
  my $self = shift;
  my $share_dir = $self->share_dir;
  return unless $share_dir;

  my @file_map;
  if ( $share_dir->{dist} ) {
    my $prefix = "dist/".$self->dist_name;
    push @file_map, $self->_share_dir_map( $prefix, $share_dir->{dist} );
  }

  if ( $share_dir->{module} ) {
    for my $mod ( keys %{ $share_dir->{module} } ) {
      (my $altmod = $mod) =~ s{::}{-}g;
      my $prefix = "module/$altmod";
      push @file_map, $self->_share_dir_map($prefix, $share_dir->{module}{$mod});
    }
  }

  return { @file_map };
}

sub _share_dir_map {
  my ($self, $prefix, $list) = @_;
  my %files;
  for my $dir ( @$list ) {
    for my $f ( @{ $self->rscan_dir( $dir, sub {-f} )} ) {
      $f =~ s{\A.*?\Q$dir\E/}{};
      $files{"$dir/$f"} = "$prefix/$f";
    }
  }
  return %files;
}

sub process_PL_files {
  my ($self) = @_;
  my $files = $self->find_PL_files;

  while (my ($file, $to) = each %$files) {
    unless ($self->up_to_date( $file, $to )) {
      $self->run_perl_script($file, [], [@$to]) or die "$file failed";
      $self->add_to_cleanup(@$to);
    }
  }
}

sub process_xs_files {
  my $self = shift;
  return if $self->pureperl_only && $self->allow_pureperl;
  my $files = $self->find_xs_files;
  croak 'Can\'t build xs files under --pureperl-only' if %$files && $self->pureperl_only;
  while (my ($from, $to) = each %$files) {
    unless ($from eq $to) {
      $self->add_to_cleanup($to);
      $self->copy_if_modified( from => $from, to => $to );
    }
    $self->process_xs($to);
  }
}

sub process_pod_files { shift()->process_files_by_extension(shift()) }
sub process_pm_files  { shift()->process_files_by_extension(shift()) }

sub process_script_files {
  my $self = shift;
  my $files = $self->find_script_files;
  return unless keys %$files;

  my $script_dir = File::Spec->catdir($self->blib, 'script');
  File::Path::mkpath( $script_dir );

  foreach my $file (keys %$files) {
    my $result = $self->copy_if_modified($file, $script_dir, 'flatten') or next;
    $self->fix_shebang_line($result) unless $self->is_vmsish;
    $self->make_executable($result);
  }
}

sub find_PL_files {
  my $self = shift;
  if (my $files = $self->{properties}{PL_files}) {
    # 'PL_files' is given as a Unix file spec, so we localize_file_path().

    if (UNIVERSAL::isa($files, 'ARRAY')) {
      return { map {$_, [/^(.*)\.PL$/]}
               map $self->localize_file_path($_),
               @$files };

    } elsif (UNIVERSAL::isa($files, 'HASH')) {
      my %out;
      while (my ($file, $to) = each %$files) {
        $out{ $self->localize_file_path($file) } = [ map $self->localize_file_path($_),
                                                     ref $to ? @$to : ($to) ];
      }
      return \%out;

    } else {
      die "'PL_files' must be a hash reference or array reference";
    }
  }

  return unless -d 'lib';
  return {
    map {$_, [/^(.*)\.PL$/i ]}
    @{ $self->rscan_dir('lib', $self->file_qr('\.PL$')) }
  };
}

sub find_pm_files  { shift->_find_file_by_type('pm',  'lib') }
sub find_pod_files { shift->_find_file_by_type('pod', 'lib') }
sub find_xs_files  { shift->_find_file_by_type('xs',  'lib') }

sub find_script_files {
  my $self = shift;
  if (my $files = $self->script_files) {
    # Always given as a Unix file spec.  Values in the hash are
    # meaningless, but we preserve if present.
    return { map {$self->localize_file_path($_), $files->{$_}} keys %$files };
  }

  # No default location for script files
  return {};
}

sub find_test_files {
  my $self = shift;
  my $p = $self->{properties};

  if (my $files = $p->{test_files}) {
    $files = [keys %$files] if UNIVERSAL::isa($files, 'HASH');
    $files = [map { -d $_ ? $self->expand_test_dir($_) : $_ }
              map glob,
              $self->split_like_shell($files)];

    # Always given as a Unix file spec.
    return [ map $self->localize_file_path($_), @$files ];

  } else {
    # Find all possible tests in t/ or test.pl
    my @tests;
    push @tests, 'test.pl'                          if -e 'test.pl';
    push @tests, $self->expand_test_dir('t')        if -e 't' and -d _;
    return \@tests;
  }
}

sub _find_file_by_type {
  my ($self, $type, $dir) = @_;

  if (my $files = $self->{properties}{"${type}_files"}) {
    # Always given as a Unix file spec
    return { map $self->localize_file_path($_), %$files };
  }

  return {} unless -d $dir;
  return { map {$_, $_}
           map $self->localize_file_path($_),
           grep !/\.\#/,
           @{ $self->rscan_dir($dir, $self->file_qr("\\.$type\$")) } };
}

sub localize_file_path {
  my ($self, $path) = @_;
  return File::Spec->catfile( split m{/}, $path );
}

sub localize_dir_path {
  my ($self, $path) = @_;
  return File::Spec->catdir( split m{/}, $path );
}

sub fix_shebang_line { # Adapted from fixin() in ExtUtils::MM_Unix 1.35
  my ($self, @files) = @_;
  my $c = ref($self) ? $self->{config} : 'Module::Build::Config';

  my ($does_shbang) = $c->get('sharpbang') =~ /^\s*\#\!/;
  for my $file (@files) {
    open(my $FIXIN, '<', $file) or die "Can't process '$file': $!";
    local $/ = "\n";
    chomp(my $line = <$FIXIN>);
    next unless $line =~ s/^\s*\#!\s*//;     # Not a shebang file.

    my ($cmd, $arg) = (split(' ', $line, 2), '');
    next unless $cmd =~ /perl/i;
    my $interpreter = $self->{properties}{perl};

    $self->log_verbose("Changing sharpbang in $file to $interpreter\n");
    my $shb = '';
    $shb .= $c->get('sharpbang')."$interpreter $arg\n" if $does_shbang;

    # I'm not smart enough to know the ramifications of changing the
    # embedded newlines here to \n, so I leave 'em in.
    $shb .= qq{
eval 'exec $interpreter $arg -S \$0 \${1+"\$\@"}'
    if 0; # not running under some shell
} unless $self->is_windowsish; # this won't work on win32, so don't

    open(my $FIXOUT, '>', "$file.new")
      or die "Can't create new $file: $!\n";

    # Print out the new #! line (or equivalent).
    local $\;
    undef $/; # Was localized above
    print $FIXOUT $shb, <$FIXIN>;
    close $FIXIN;
    close $FIXOUT;

    rename($file, "$file.bak")
      or die "Can't rename $file to $file.bak: $!";

    rename("$file.new", $file)
      or die "Can't rename $file.new to $file: $!";

    $self->delete_filetree("$file.bak")
      or $self->log_warn("Couldn't clean up $file.bak, leaving it there");

    $self->do_system($c->get('eunicefix'), $file) if $c->get('eunicefix') ne ':';
  }
}


sub ACTION_testpod {
  my $self = shift;
  $self->depends_on('docs');

  eval q{use Test::Pod 0.95; 1}
    or die "The 'testpod' action requires Test::Pod version 0.95";

  my @files = sort keys %{$self->_find_pods($self->libdoc_dirs)},
                   keys %{$self->_find_pods
                             ($self->bindoc_dirs,
                              exclude => [ $self->file_qr('\.bat$') ])}
    or die "Couldn't find any POD files to test\n";

  { package # hide from PAUSE
      Module::Build::PodTester;  # Don't want to pollute the main namespace
    Test::Pod->import( tests => scalar @files );
    pod_file_ok($_) foreach @files;
  }
}

sub ACTION_testpodcoverage {
  my $self = shift;

  $self->depends_on('docs');

  eval q{use Test::Pod::Coverage 1.00; 1}
    or die "The 'testpodcoverage' action requires ",
           "Test::Pod::Coverage version 1.00";

  # TODO this needs test coverage!

  # XXX work-around a bug in Test::Pod::Coverage previous to v1.09
  # Make sure we test the module in blib/
  local @INC = @INC;
  my $p = $self->{properties};
  unshift(@INC,
    # XXX any reason to include arch?
    File::Spec->catdir($p->{base_dir}, $self->blib, 'lib'),
    #File::Spec->catdir($p->{base_dir}, $self->blib, 'arch')
  );

  all_pod_coverage_ok();
}

sub ACTION_docs {
  my $self = shift;

  $self->depends_on('code');
  $self->depends_on('manpages', 'html');
}

# Given a file type, will return true if the file type would normally
# be installed when neither install-base nor prefix has been set.
# I.e. it will be true only if the path is set from Config.pm or
# set explicitly by the user via install-path.
sub _is_default_installable {
  my $self = shift;
  my $type = shift;
  return ( $self->install_destination($type) &&
           ( $self->install_path($type) ||
             $self->install_sets($self->installdirs)->{$type} )
         ) ? 1 : 0;
}

sub _is_ActivePerl {
#  return 0;
  my $self = shift;
  unless (exists($self->{_is_ActivePerl})) {
    $self->{_is_ActivePerl} = (eval { require ActivePerl::DocTools; } || 0);
  }
  return $self->{_is_ActivePerl};
}

sub _is_ActivePPM {
#  return 0;
  my $self = shift;
  unless (exists($self->{_is_ActivePPM})) {
    $self->{_is_ActivePPM} = (eval { require ActivePerl::PPM; } || 0);
  }
  return $self->{_is_ActivePPM};
}

sub ACTION_manpages {
  my $self = shift;

  return unless $self->_mb_feature('manpage_support');

  $self->depends_on('code');

  my %extra_manify_args = $self->{properties}{'extra_manify_args'} ? %{ $self->{properties}{'extra_manify_args'} } : ();

  foreach my $type ( qw(bin lib) ) {
    next unless ( $self->invoked_action eq 'manpages' || $self->_is_default_installable("${type}doc"));
    my $files = $self->_find_pods( $self->{properties}{"${type}doc_dirs"},
                                   exclude => [ $self->file_qr('\.bat$') ] );
    next unless %$files;

    my $sub = $self->can("manify_${type}_pods");
    $self->$sub( %extra_manify_args ) if defined( $sub );
  }
}

sub manify_bin_pods {
  my $self    = shift;
  my %podman_args = (section =>  1, @_); # binaries go in section 1

  my $files   = $self->_find_pods( $self->{properties}{bindoc_dirs},
                                   exclude => [ $self->file_qr('\.bat$') ] );
  return unless keys %$files;

  my $mandir = File::Spec->catdir( $self->blib, 'bindoc' );
  File::Path::mkpath( $mandir, 0, oct(777) );

  require Pod::Man;
  foreach my $file (keys %$files) {
    # Pod::Simple based parsers only support one document per instance.
    # This is expected to change in a future version (Pod::Simple > 3.03).
    my $parser  = Pod::Man->new( %podman_args, section => '1p' ); # binaries go in section 1p
    my $manpage = $self->man1page_name( $file ) . '.' .
                  $self->config( 'man1ext' );
    my $outfile = File::Spec->catfile($mandir, $manpage);
    next if $self->up_to_date( $file, $outfile );
    $self->log_verbose("Manifying $file -> $outfile\n");
    eval { $parser->parse_from_file( $file, $outfile ); 1 }
      or $self->log_warn("Error creating '$outfile': $@\n");
    $files->{$file} = $outfile;
  }
}

sub manify_lib_pods {
  my $self    = shift;
  my %podman_args = (section => 3, @_); # libraries go in section 3

  my $files   = $self->_find_pods($self->{properties}{libdoc_dirs});
  return unless keys %$files;

  my $mandir = File::Spec->catdir( $self->blib, 'libdoc' );
  File::Path::mkpath( $mandir, 0, oct(777) );

  require Pod::Man;
  while (my ($file, $relfile) = each %$files) {
    # Pod::Simple based parsers only support one document per instance.
    # This is expected to change in a future version (Pod::Simple > 3.03).
    my $parser  = Pod::Man->new( %podman_args, section => '3pm' ); # libraries go in section 3pm
    my $manpage = $self->man3page_name( $relfile ) . '.' .
                  $self->config( 'man3ext' );
    my $outfile = File::Spec->catfile( $mandir, $manpage);
    next if $self->up_to_date( $file, $outfile );
    $self->log_verbose("Manifying $file -> $outfile\n");
    eval { $parser->parse_from_file( $file, $outfile ); 1 }
      or $self->log_warn("Error creating '$outfile': $@\n");
    $files->{$file} = $outfile;
  }
}

sub _find_pods {
  my ($self, $dirs, %args) = @_;
  my %files;
  foreach my $spec (@$dirs) {
    my $dir = $self->localize_dir_path($spec);
    next unless -e $dir;

    FILE: foreach my $file ( @{ $self->rscan_dir( $dir ) } ) {
      foreach my $regexp ( @{ $args{exclude} } ) {
        next FILE if $file =~ $regexp;
      }
      $file = $self->localize_file_path($file);
      $files{$file} = File::Spec->abs2rel($file, $dir) if $self->contains_pod( $file )
    }
  }
  return \%files;
}

sub contains_pod {
  my ($self, $file) = @_;
  return '' unless -T $file;  # Only look at text files

  open(my $fh, '<', $file ) or die "Can't open $file: $!";
  while (my $line = <$fh>) {
    return 1 if $line =~ /^\=(?:head|pod|item)/;
  }

  return '';
}

sub ACTION_html {
  my $self = shift;

  return unless $self->_mb_feature('HTML_support');

  $self->depends_on('code');

  foreach my $type ( qw(bin lib) ) {
    next unless ( $self->invoked_action eq 'html' || $self->_is_default_installable("${type}html"));
    $self->htmlify_pods( $type );
  }
}

# 1) If it's an ActiveState perl install, we need to run
#    ActivePerl::DocTools->UpdateTOC;
# 2) Links to other modules are not being generated
sub htmlify_pods {
  my $self = shift;
  my $type = shift;
  my $htmldir = shift || File::Spec->catdir($self->blib, "${type}html");

  $self->add_to_cleanup('pod2htm*');

  my $pods = $self->_find_pods( $self->{properties}{"${type}doc_dirs"},
                                exclude => [ $self->file_qr('\.(?:bat|com|html)$') ] );
  return unless %$pods;  # nothing to do

  unless ( -d $htmldir ) {
    File::Path::mkpath($htmldir, 0, oct(755))
      or die "Couldn't mkdir $htmldir: $!";
  }

  my @rootdirs = ($type eq 'bin') ? qw(bin) :
      $self->installdirs eq 'core' ? qw(lib) : qw(site lib);
  my $podroot = $ENV{PERL_CORE}
              ? File::Basename::dirname($ENV{PERL_CORE})
              : $self->original_prefix('core');

  my $htmlroot = $self->install_sets('core')->{libhtml};
  my $podpath;
  unless (defined $self->args('html_links') and !$self->args('html_links')) {
    my @podpath = ( (map { File::Spec->abs2rel($_ ,$podroot) } grep { -d  }
                     ( $self->install_sets('core', 'lib'), # lib
                       $self->install_sets('core', 'bin'), # bin
                       $self->install_sets('site', 'lib'), # site/lib
                     ) ), File::Spec->rel2abs($self->blib) );

    $podpath = $ENV{PERL_CORE}
      ? File::Spec->catdir($podroot, 'lib')
        : join(":", map { tr,:\\,|/,; $_ } @podpath);
  }

  my $blibdir = join('/', File::Spec->splitdir(
    (File::Spec->splitpath(File::Spec->rel2abs($htmldir),1))[1]),''
  );

  my ($with_ActiveState, $htmltool);

  if ( $with_ActiveState = $self->_is_ActivePerl
    && eval { require ActivePerl::DocTools::Pod; 1 }
  ) {
    my $tool_v = ActiveState::DocTools::Pod->VERSION;
    $htmltool = "ActiveState::DocTools::Pod";
    $htmltool .= " $tool_v" if $tool_v && length $tool_v;
  }
  else {
      require Module::Build::PodParser;
      require Pod::Html;
    $htmltool = "Pod::Html " .  Pod::Html->VERSION;
  }
  $self->log_verbose("Converting Pod to HTML with $htmltool\n");

  my $errors = 0;

  POD:
  foreach my $pod ( keys %$pods ) {

    my ($name, $path) = File::Basename::fileparse($pods->{$pod},
      $self->file_qr('\.(?:pm|plx?|pod)$')
    );
    my @dirs = File::Spec->splitdir( File::Spec->canonpath( $path ) );
    pop( @dirs ) if scalar(@dirs) && $dirs[-1] eq File::Spec->curdir;

    my $fulldir = File::Spec->catdir($htmldir, @rootdirs, @dirs);
    my $tmpfile = File::Spec->catfile($fulldir, "${name}.tmp");
    my $outfile = File::Spec->catfile($fulldir, "${name}.html");
    my $infile  = File::Spec->abs2rel($pod);

    next if $self->up_to_date($infile, $outfile);

    unless ( -d $fulldir ){
      File::Path::mkpath($fulldir, 0, oct(755))
        or die "Couldn't mkdir $fulldir: $!";
    }

    $self->log_verbose("HTMLifying $infile -> $outfile\n");
    if ( $with_ActiveState ) {
      my $depth = @rootdirs + @dirs;
      my %opts = ( infile => $infile,
        outfile => $tmpfile,
        ( defined($podpath) ? (podpath => $podpath) : ()),
        podroot => $podroot,
        index => 1,
        depth => $depth,
      );
      eval {
        ActivePerl::DocTools::Pod::pod2html(%opts);
        1;
      } or $self->log_warn("[$htmltool] pod2html (" .
        join(", ", map { "q{$_} => q{$opts{$_}}" } (keys %opts)) . ") failed: $@");
    } else {
      my $path2root = File::Spec->catdir((File::Spec->updir) x @dirs);
      open(my $fh, '<', $infile) or die "Can't read $infile: $!";
      my $abstract = Module::Build::PodParser->new(fh => $fh)->get_abstract();

      my $title = join( '::', (@dirs, $name) );
      $title .= " - $abstract" if $abstract;

      my @opts = (
        "--title=$title",
        ( defined($podpath) ? "--podpath=$podpath" : ()),
        "--infile=$infile",
        "--outfile=$tmpfile",
        "--podroot=$podroot",
        ($path2root ? "--htmlroot=$path2root" : ()),
      );

      unless ( eval{Pod::Html->VERSION(1.12)} ) {
        push( @opts, ('--flush') ); # caching removed in 1.12
      }

      if ( eval{Pod::Html->VERSION(1.12)} ) {
        push( @opts, ('--header', '--backlink') );
      } elsif ( eval{Pod::Html->VERSION(1.03)} ) {
        push( @opts, ('--header', '--backlink=Back to Top') );
      }

      $self->log_verbose("P::H::pod2html @opts\n");
      {
        my $orig = Cwd::getcwd();
        eval { Pod::Html::pod2html(@opts); 1 }
          or $self->log_warn("[$htmltool] pod2html( " .
          join(", ", map { "q{$_}" } @opts) . ") failed: $@");
        chdir($orig);
      }
    }
    # We now have to cleanup the resulting html file
    if ( ! -r $tmpfile ) {
      $errors++;
      next POD;
    }
    open(my $fh, '<', $tmpfile) or die "Can't read $tmpfile: $!";
    my $html = join('',<$fh>);
    close $fh;
    if (!$self->_is_ActivePerl) {
      # These fixups are already done by AP::DT:P:pod2html
      # The output from pod2html is NOT XHTML!
      # IE6+ will display content that is not valid for DOCTYPE
      $html =~ s#^<!DOCTYPE .*?>#<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">#im;
      $html =~ s#<html xmlns="http://www.w3.org/1999/xhtml">#<html>#i;

      # IE6+ will not display local HTML files with strict
      # security without this comment
      $html =~ s#<head>#<head>\n<!-- saved from url=(0017)http://localhost/ -->#i;
    }
    # Fixup links that point to our temp blib
    $html =~ s/\Q$blibdir\E//g;

    open($fh, '>', $outfile) or die "Can't write $outfile: $!";
    print $fh $html;
    close $fh;
    unlink($tmpfile);
  }

  return ! $errors;

}

# Adapted from ExtUtils::MM_Unix
sub man1page_name {
  my $self = shift;
  return File::Basename::basename( shift );
}

# Adapted from ExtUtils::MM_Unix and Pod::Man
# Depending on M::B's dependency policy, it might make more sense to refactor
# Pod::Man::begin_pod() to extract a name() methods, and use them...
#    -spurkis
sub man3page_name {
  my $self = shift;
  my ($vol, $dirs, $file) = File::Spec->splitpath( shift );
  my @dirs = File::Spec->splitdir( File::Spec->canonpath($dirs) );

  # Remove known exts from the base name
  $file =~ s/\.p(?:od|m|l)\z//i;

  return join( $self->manpage_separator, @dirs, $file );
}

sub manpage_separator {
  return '::';
}

# For systems that don't have 'diff' executable, should use Algorithm::Diff
sub ACTION_diff {
  my $self = shift;
  $self->depends_on('build');
  my $local_lib = File::Spec->rel2abs('lib');
  my @myINC = grep {$_ ne $local_lib} @INC;

  # The actual install destination might not be in @INC, so check there too.
  push @myINC, map $self->install_destination($_), qw(lib arch);

  my @flags = @{$self->{args}{ARGV}};
  @flags = $self->split_like_shell($self->{args}{flags} || '') unless @flags;

  my $installmap = $self->install_map;
  delete $installmap->{read};
  delete $installmap->{write};

  my $text_suffix = $self->file_qr('\.(pm|pod)$');

  while (my $localdir = each %$installmap) {
    my @localparts = File::Spec->splitdir($localdir);
    my $files = $self->rscan_dir($localdir, sub {-f});

    foreach my $file (@$files) {
      my @parts = File::Spec->splitdir($file);
      @parts = @parts[@localparts .. $#parts]; # Get rid of blib/lib or similar

      my $installed = Module::Build::ModuleInfo->find_module_by_name(
                        join('::', @parts), \@myINC );
      if (not $installed) {
        print "Only in lib: $file\n";
        next;
      }

      my $status = File::Compare::compare($installed, $file);
      next if $status == 0;  # Files are the same
      die "Can't compare $installed and $file: $!" if $status == -1;

      if ($file =~ $text_suffix) {
        $self->do_system('diff', @flags, $installed, $file);
      } else {
        print "Binary files $file and $installed differ\n";
      }
    }
  }
}

sub ACTION_pure_install {
  shift()->depends_on('install');
}

sub ACTION_install {
  my ($self) = @_;
  require ExtUtils::Install;
  $self->depends_on('build');
  # RT#63003 suggest that odd circumstances that we might wind up
  # in a different directory than we started, so wrap with _do_in_dir to
  # ensure we get back to where we started; hope this fixes it!
  $self->_do_in_dir( ".", sub {
    ExtUtils::Install::install(
      $self->install_map, $self->verbose, 0, $self->{args}{uninst}||0
    );
  });
  if ($self->_is_ActivePerl && $self->{_completed_actions}{html}) {
    $self->log_info("Building ActivePerl Table of Contents\n");
    eval { ActivePerl::DocTools::WriteTOC(verbose => $self->verbose ? 1 : 0); 1; }
      or $self->log_warn("AP::DT:: WriteTOC() failed: $@");
  }
  if ($self->_is_ActivePPM) {
    # We touch 'lib/perllocal.pod'. There is an existing logic in subroutine _init_db()
    # of 'ActivePerl/PPM/InstallArea.pm' that says that if 'lib/perllocal.pod' has a 'date-last-touched'
    # greater than that of the PPM SQLite databases ('etc/ppm-perl-area.db' and/or
    # 'site/etc/ppm-site-area.db') then the PPM SQLite databases are rebuilt from scratch.

    # in the following line, 'perllocal.pod' this is *always* 'lib/perllocal.pod', never 'site/lib/perllocal.pod'
    my $F_perllocal = File::Spec->catfile($self->install_sets('core', 'lib'), 'perllocal.pod');
    my $dt_stamp = time;

    $self->log_info("For ActivePerl's PPM: touch '$F_perllocal'\n");

    open my $perllocal, ">>", $F_perllocal;
    close $perllocal;
    utime($dt_stamp, $dt_stamp, $F_perllocal);
  }
}

sub ACTION_fakeinstall {
  my ($self) = @_;
  require ExtUtils::Install;
  my $eui_version = ExtUtils::Install->VERSION;
  if ( $eui_version < 1.32 ) {
    $self->log_warn(
      "The 'fakeinstall' action requires Extutils::Install 1.32 or later.\n"
      . "(You only have version $eui_version)."
    );
    return;
  }
  $self->depends_on('build');
  ExtUtils::Install::install($self->install_map, !$self->quiet, 1, $self->{args}{uninst}||0);
}

sub ACTION_versioninstall {
  my ($self) = @_;

  die "You must have only.pm 0.25 or greater installed for this operation: $@\n"
    unless eval { require only; 'only'->VERSION(0.25); 1 };

  $self->depends_on('build');

  my %onlyargs = map {exists($self->{args}{$_}) ? ($_ => $self->{args}{$_}) : ()}
    qw(version versionlib);
  only::install::install(%onlyargs);
}

sub ACTION_installdeps {
  my ($self) = @_;

  # XXX include feature prerequisites as optional prereqs?

  my $info = $self->_enum_prereqs;
  if (! $info ) {
    $self->log_info( "No prerequisites detected\n" );
    return;
  }

  my $failures = $self->prereq_failures($info);
  if ( ! $failures ) {
    $self->log_info( "All prerequisites satisfied\n" );
    return;
  }

  my @install;
  while (my ($type, $prereqs) = each %$failures) {
    if($type =~ m/^(?:\w+_)?requires$/) {
      push(@install, keys %$prereqs);
      next;
    }
    $self->log_info("Checking optional dependencies:\n");
    while (my ($module, $status) = each %$prereqs) {
      push(@install, $module) if($self->y_n("Install $module?", 'y'));
    }
  }

  return unless @install;

  my ($command, @opts) = $self->split_like_shell($self->cpan_client);

  # relative command should be relative to our active Perl
  # so we need to locate that command
  if ( ! File::Spec->file_name_is_absolute( $command ) ) {
    # prefer site to vendor to core
    my @loc = ( 'site', 'vendor', '' );
    my @bindirs = File::Basename::dirname($self->perl);
    push @bindirs,
      map {
        ($self->config->{"install${_}bin"}, $self->config->{"install${_}script"})
      } @loc;
    for my $d ( @bindirs ) {
      my $abs_cmd = $self->find_command(File::Spec->catfile( $d, $command ));
      if ( defined $abs_cmd ) {
        $command = $abs_cmd;
        last;
      }
    }
  }

  $self->do_system($command, @opts, @install);
}

sub ACTION_clean {
  my ($self) = @_;
  $self->log_info("Cleaning up build files\n");
  foreach my $item (map glob($_), $self->cleanup) {
    $self->delete_filetree($item);
  }
}

sub ACTION_realclean {
  my ($self) = @_;
  $self->depends_on('clean');
  $self->log_info("Cleaning up configuration files\n");
  $self->delete_filetree(
    $self->config_dir, $self->mymetafile, $self->mymetafile2, $self->build_script
  );
}

sub ACTION_ppd {
  my ($self) = @_;

  require Module::Build::PPMMaker;
  my $ppd = Module::Build::PPMMaker->new();
  my $file = $ppd->make_ppd(%{$self->{args}}, build => $self);
  $self->add_to_cleanup($file);
}

sub ACTION_ppmdist {
  my ($self) = @_;

  $self->depends_on( 'build' );

  my $ppm = $self->ppm_name;
  $self->delete_filetree( $ppm );
  $self->log_info( "Creating $ppm\n" );
  $self->add_to_cleanup( $ppm, "$ppm.tar.gz" );

  my %types = ( # translate types/dirs to those expected by ppm
    lib     => 'lib',
    arch    => 'arch',
    bin     => 'bin',
    script  => 'script',
    bindoc  => 'man1',
    libdoc  => 'man3',
    binhtml => undef,
    libhtml => undef,
  );

  foreach my $type ($self->install_types) {
    next if exists( $types{$type} ) && !defined( $types{$type} );

    my $dir = File::Spec->catdir( $self->blib, $type );
    next unless -e $dir;

    my $files = $self->rscan_dir( $dir );
    foreach my $file ( @$files ) {
      next unless -f $file;
      my $rel_file =
        File::Spec->abs2rel( File::Spec->rel2abs( $file ),
                             File::Spec->rel2abs( $dir  ) );
      my $to_file  =
        File::Spec->catfile( $ppm, 'blib',
                            exists( $types{$type} ) ? $types{$type} : $type,
                            $rel_file );
      $self->copy_if_modified( from => $file, to => $to_file );
    }
  }

  foreach my $type ( qw(bin lib) ) {
    $self->htmlify_pods( $type, File::Spec->catdir($ppm, 'blib', 'html') );
  }

  # create a tarball;
  # the directory tar'ed must be blib so we need to do a chdir first
  my $target = File::Spec->catfile( File::Spec->updir, $ppm );
  $self->_do_in_dir( $ppm, sub { $self->make_tarball( 'blib', $target ) } );

  $self->depends_on( 'ppd' );

  $self->delete_filetree( $ppm );
}

sub ACTION_pardist {
  my ($self) = @_;

  # Need PAR::Dist
  if ( not eval { require PAR::Dist; PAR::Dist->VERSION(0.17) } ) {
    $self->log_warn(
      "In order to create .par distributions, you need to\n"
      . "install PAR::Dist first."
    );
    return();
  }

  $self->depends_on( 'build' );

  return PAR::Dist::blib_to_par(
    name => $self->dist_name,
    version => $self->dist_version,
  );
}

sub ACTION_dist {
  my ($self) = @_;

  # MUST dispatch() and not depends_ok() so we generate a clean distdir
  $self->dispatch('distdir');

  my $dist_dir = $self->dist_dir;

  $self->make_tarball($dist_dir);
  $self->delete_filetree($dist_dir);
}

sub ACTION_distcheck {
  my ($self) = @_;

  $self->_check_manifest_skip unless $self->invoked_action eq 'distclean';

  require ExtUtils::Manifest;
  local $^W; # ExtUtils::Manifest is not warnings clean.
  my ($missing, $extra) = ExtUtils::Manifest::fullcheck();

  return unless @$missing || @$extra;

  my $msg = "MANIFEST appears to be out of sync with the distribution\n";
  if ( $self->invoked_action eq 'distcheck' ) {
    die $msg;
  } else {
    warn $msg;
  }
}

sub _check_mymeta_skip {
  my $self = shift;
  my $maniskip = shift || 'MANIFEST.SKIP';

  require ExtUtils::Manifest;
  local $^W; # ExtUtils::Manifest is not warnings clean.

  # older ExtUtils::Manifest had a private _maniskip
  my $skip_factory = ExtUtils::Manifest->can('maniskip')
                  || ExtUtils::Manifest->can('_maniskip');

  my $mymetafile = $self->mymetafile;
  # we can't check it, just add it anyway to be safe
  for my $file ( $self->mymetafile, $self->mymetafile2 ) {
    unless ( $skip_factory && $skip_factory->($maniskip)->($file) ) {
      $self->log_warn("File '$maniskip' does not include '$file'. Adding it now.\n");
      my $safe = quotemeta($file);
      $self->_append_maniskip("^$safe\$", $maniskip);
    }
  }
}

sub _add_to_manifest {
  my ($self, $manifest, $lines) = @_;
  $lines = [$lines] unless ref $lines;

  my $existing_files = $self->_read_manifest($manifest);
  return unless defined( $existing_files );

  @$lines = grep {!exists $existing_files->{$_}} @$lines
    or return;

  my $mode = (stat $manifest)[2];
  chmod($mode | oct(222), $manifest) or die "Can't make $manifest writable: $!";

  open(my $fh, '<', $manifest) or die "Can't read $manifest: $!";
  my $last_line = (<$fh>)[-1] || "\n";
  my $has_newline = $last_line =~ /\n$/;
  close $fh;

  open($fh, '>>', $manifest) or die "Can't write to $manifest: $!";
  print $fh "\n" unless $has_newline;
  print $fh map "$_\n", @$lines;
  close $fh;
  chmod($mode, $manifest);

  $self->log_verbose(map "Added to $manifest: $_\n", @$lines);
}

sub _sign_dir {
  my ($self, $dir) = @_;

  unless (eval { require Module::Signature; 1 }) {
    $self->log_warn("Couldn't load Module::Signature for 'distsign' action:\n $@\n");
    return;
  }

  # Add SIGNATURE to the MANIFEST
  {
    my $manifest = File::Spec->catfile($dir, 'MANIFEST');
    die "Signing a distribution requires a MANIFEST file" unless -e $manifest;
    $self->_add_to_manifest($manifest, "SIGNATURE    Added here by Module::Build");
  }

  # Would be nice if Module::Signature took a directory argument.

  $self->_do_in_dir($dir, sub {local $Module::Signature::Quiet = 1; Module::Signature::sign()});
}

sub _do_in_dir {
  my ($self, $dir, $do) = @_;

  my $start_dir = File::Spec->rel2abs($self->cwd);
  chdir $dir or die "Can't chdir() to $dir: $!";
  eval {$do->()};
  my @err = $@ ? ($@) : ();
  chdir $start_dir or push @err, "Can't chdir() back to $start_dir: $!";
  die join "\n", @err if @err;
}

sub ACTION_distsign {
  my ($self) = @_;
  {
    local $self->{properties}{sign} = 0;  # We'll sign it ourselves
    $self->depends_on('distdir') unless -d $self->dist_dir;
  }
  $self->_sign_dir($self->dist_dir);
}

sub ACTION_skipcheck {
  my ($self) = @_;

  require ExtUtils::Manifest;
  local $^W; # ExtUtils::Manifest is not warnings clean.
  ExtUtils::Manifest::skipcheck();
}

sub ACTION_distclean {
  my ($self) = @_;

  $self->depends_on('realclean');
  $self->depends_on('distcheck');
}

sub do_create_makefile_pl {
  my $self = shift;
  require Module::Build::Compat;
  $self->log_info("Creating Makefile.PL\n");
  eval { Module::Build::Compat->create_makefile_pl($self->create_makefile_pl, $self, @_) };
  if ( $@ ) {
    1 while unlink 'Makefile.PL';
    die "$@\n";
  }
  $self->_add_to_manifest('MANIFEST', 'Makefile.PL');
}

sub do_create_license {
  my $self = shift;
  $self->log_info("Creating LICENSE file\n");

  if (  ! $self->_mb_feature('license_creation') ) {
    $self->_warn_mb_feature_deps('license_creation');
    die "Aborting.\n";
  }

  my $l = $self->license
    or die "Can't create LICENSE file: No license specified\n";

  my $license = $self->_software_license_object
    or die << "HERE";
Can't create LICENSE file: '$l' is not a valid license key
or Software::License subclass;
HERE

  $self->delete_filetree('LICENSE');

  open(my $fh, '>', 'LICENSE')
    or die "Can't write LICENSE file: $!";
  print $fh $license->fulltext;
  close $fh;

  $self->_add_to_manifest('MANIFEST', 'LICENSE');
}

sub do_create_readme {
  my $self = shift;
  $self->delete_filetree('README');

  my $docfile = $self->_main_docfile;
  unless ( $docfile ) {
    $self->log_warn(<<EOF);
Cannot create README: can't determine which file contains documentation;
Must supply either 'dist_version_from', or 'module_name' parameter.
EOF
    return;
  }

  # work around some odd Pod::Readme->new() failures in test reports by
  # confirming that new() is available
  if ( eval {require Pod::Readme; Pod::Readme->can('new') } ) {
    $self->log_info("Creating README using Pod::Readme\n");

    my $parser = Pod::Readme->new;
    $parser->parse_from_file($docfile, 'README', @_);

  } elsif ( eval {require Pod::Text; 1} ) {
    $self->log_info("Creating README using Pod::Text\n");

    if ( open(my $fh, '>', 'README') ) {
      local $^W = 0;
      no strict "refs";

      # work around bug in Pod::Text 3.01, which expects
      # Pod::Simple::parse_file to take input and output filehandles
      # when it actually only takes an input filehandle

      my $old_parse_file;
      $old_parse_file = \&{"Pod::Simple::parse_file"}
        and
      local *{"Pod::Simple::parse_file"} = sub {
        my $self = shift;
        $self->output_fh($_[1]) if $_[1];
        $self->$old_parse_file($_[0]);
      }
        if $Pod::Text::VERSION
          == 3.01; # Split line to avoid evil version-finder

      Pod::Text::pod2text( $docfile, $fh );

      close $fh;
    } else {
      $self->log_warn(
        "Cannot create 'README' file: Can't open file for writing\n" );
      return;
    }

  } else {
    $self->log_warn("Can't load Pod::Readme or Pod::Text to create README\n");
    return;
  }

  $self->_add_to_manifest('MANIFEST', 'README');
}

sub _main_docfile {
  my $self = shift;
  if ( my $pm_file = $self->dist_version_from ) {
    (my $pod_file = $pm_file) =~ s/.pm$/.pod/;
    return (-e $pod_file ? $pod_file : $pm_file);
  } else {
    return undef;
  }
}

sub do_create_bundle_inc {
  my $self = shift;
  my $dist_inc = File::Spec->catdir( $self->dist_dir, 'inc' );
  require inc::latest;
  inc::latest->write($dist_inc, @{$self->bundle_inc_preload});
  inc::latest->bundle_module($_, $dist_inc) for @{$self->bundle_inc};
  return 1;
}

sub ACTION_distdir {
  my ($self) = @_;

  if ( @{$self->bundle_inc} && ! $self->_mb_feature('inc_bundling_support') ) {
    $self->_warn_mb_feature_deps('inc_bundling_support');
    die "Aborting.\n";
  }

  $self->depends_on('distmeta');

  my $dist_files = $self->_read_manifest('MANIFEST')
    or die "Can't create distdir without a MANIFEST file - run 'manifest' action first.\n";
  delete $dist_files->{SIGNATURE};  # Don't copy, create a fresh one
  die "No files found in MANIFEST - try running 'manifest' action?\n"
    unless ($dist_files and keys %$dist_files);
  my $metafile = $self->metafile;
  $self->log_warn("*** Did you forget to add $metafile to the MANIFEST?\n")
    unless exists $dist_files->{$metafile};

  my $dist_dir = $self->dist_dir;
  $self->delete_filetree($dist_dir);
  $self->log_info("Creating $dist_dir\n");
  $self->add_to_cleanup($dist_dir);

  foreach my $file (keys %$dist_files) {
    next if $file =~ m{^MYMETA\.}; # Double check that we skip MYMETA.*
    my $new = $self->copy_if_modified(from => $file, to_dir => $dist_dir, verbose => 0);
  }

  $self->do_create_bundle_inc if @{$self->bundle_inc};

  $self->_sign_dir($dist_dir) if $self->{properties}{sign};
}

sub ACTION_disttest {
  my ($self) = @_;

  $self->depends_on('distdir');

  $self->_do_in_dir
    ( $self->dist_dir,
      sub {
        # XXX could be different names for scripts

        $self->run_perl_script('Build.PL') # XXX Should this be run w/ --nouse-rcfile
          or die "Error executing 'Build.PL' in dist directory: $!";
        $self->run_perl_script($self->build_script)
          or die "Error executing $self->build_script in dist directory: $!";
        $self->run_perl_script($self->build_script, [], ['test'])
          or die "Error executing 'Build test' in dist directory";
      });
}

sub ACTION_distinstall {
  my ($self, @args) = @_;

  $self->depends_on('distdir');

  $self->_do_in_dir ( $self->dist_dir,
    sub {
      $self->run_perl_script('Build.PL')
        or die "Error executing 'Build.PL' in dist directory: $!";
      $self->run_perl_script($self->build_script)
        or die "Error executing $self->build_script in dist directory: $!";
      $self->run_perl_script($self->build_script, [], ['install'])
        or die "Error executing 'Build install' in dist directory";
    }
  );
}

=begin private

  my $has_include = $build->_eumanifest_has_include;

Returns true if the installed version of ExtUtils::Manifest supports
#include and #include_default directives.  False otherwise.

=end private

=cut

# #!include and #!include_default were added in 1.50
sub _eumanifest_has_include {
    my $self = shift;

    require ExtUtils::Manifest;
    return eval { ExtUtils::Manifest->VERSION(1.50); 1 };
}


=begin private

  my $maniskip_file = $build->_default_maniskip;

Returns the location of the installed MANIFEST.SKIP file used by
default.

=end private

=cut

sub _default_maniskip {
    my $self = shift;

    my $default_maniskip;
    for my $dir (@INC) {
        $default_maniskip = File::Spec->catfile($dir, "ExtUtils", "MANIFEST.SKIP");
        last if -r $default_maniskip;
    }

    return $default_maniskip;
}


=begin private

  my $content = $build->_slurp($file);

Reads $file and returns the $content.

=end private

=cut

sub _slurp {
    my $self = shift;
    my $file = shift;
    my $mode = shift || "";
    open my $fh, "<$mode", $file or croak "Can't open $file for reading: $!";
    local $/;
    return <$fh>;
}

sub _spew {
    my $self = shift;
    my $file = shift;
    my $content = shift || "";
    my $mode = shift || "";
    open my $fh, ">$mode", $file or croak "Can't open $file for writing: $!";
    print {$fh} $content;
    close $fh;
}

sub _case_tolerant {
  my $self = shift;
  if ( ref $self ) {
    $self->{_case_tolerant} = File::Spec->case_tolerant
      unless defined($self->{_case_tolerant});
    return $self->{_case_tolerant};
  }
  else {
    return File::Spec->case_tolerant;
  }
}

sub _append_maniskip {
  my $self = shift;
  my $skip = shift;
  my $file = shift || 'MANIFEST.SKIP';
  return unless defined $skip && length $skip;
  open(my $fh, '>>', $file)
    or die "Can't open $file: $!";

  print $fh "$skip\n";
  close $fh;
}

sub _write_default_maniskip {
  my $self = shift;
  my $file = shift || 'MANIFEST.SKIP';
  open(my $fh, '>', $file)
    or die "Can't open $file: $!";

  my $content = $self->_eumanifest_has_include ? "#!include_default\n"
                                               : $self->_slurp( $self->_default_maniskip );

  $content .= <<'EOF';
# Avoid configuration metadata file
^MYMETA\.

# Avoid Module::Build generated and utility files.
\bBuild$
\bBuild.bat$
\b_build
\bBuild.COM$
\bBUILD.COM$
\bbuild.com$
^MANIFEST\.SKIP

# Avoid archives of this distribution
EOF

  # Skip, for example, 'Module-Build-0.27.tar.gz'
  $content .= '\b'.$self->dist_name.'-[\d\.\_]+'."\n";

  print $fh $content;
  
  close $fh;

  return;
}

sub _check_manifest_skip {
  my ($self) = @_;

  my $maniskip = 'MANIFEST.SKIP';

  if ( ! -e $maniskip ) {
    $self->log_warn("File '$maniskip' does not exist: Creating a temporary '$maniskip'\n");
    $self->_write_default_maniskip($maniskip);
    $self->_unlink_on_exit($maniskip);
  }
  else {
    # MYMETA must not be added to MANIFEST, so always confirm the skip
    $self->_check_mymeta_skip( $maniskip );
  }

  return;
}

sub ACTION_manifest {
  my ($self) = @_;

  $self->_check_manifest_skip;

  require ExtUtils::Manifest;  # ExtUtils::Manifest is not warnings clean.
  local ($^W, $ExtUtils::Manifest::Quiet) = (0,1);
  ExtUtils::Manifest::mkmanifest();
}

sub ACTION_manifest_skip {
  my ($self) = @_;

  if ( -e 'MANIFEST.SKIP' ) {
    $self->log_warn("MANIFEST.SKIP already exists.\n");
    return 0;
  }
  $self->log_info("Creating a new MANIFEST.SKIP file\n");
  return $self->_write_default_maniskip;
  return -e 'MANIFEST.SKIP'
}

# Case insensitive regex for files
sub file_qr {
    return shift->{_case_tolerant} ? qr($_[0])i : qr($_[0]);
}

sub dist_dir {
  my ($self) = @_;
  my $dir = join "-", $self->dist_name, $self->dist_version;
  $dir .= "-" . $self->dist_suffix if $self->dist_suffix;
  return $dir;
}

sub ppm_name {
  my $self = shift;
  return 'PPM-' . $self->dist_dir;
}

sub _files_in {
  my ($self, $dir) = @_;
  return unless -d $dir;

  local *DH;
  opendir DH, $dir or die "Can't read directory $dir: $!";

  my @files;
  while (defined (my $file = readdir DH)) {
    my $full_path = File::Spec->catfile($dir, $file);
    next if -d $full_path;
    push @files, $full_path;
  }
  return @files;
}

sub share_dir {
  my $self = shift;
  my $p = $self->{properties};

  $p->{share_dir} = shift if @_;

  # Always coerce to proper hash form
  if    ( ! defined $p->{share_dir} ) {
    return;
  }
  elsif ( ! ref $p->{share_dir}  ) {
    # scalar -- treat as a single 'dist' directory
    $p->{share_dir} = { dist => [ $p->{share_dir} ] };
  }
  elsif ( ref $p->{share_dir} eq 'ARRAY' ) {
    # array -- treat as a list of 'dist' directories
    $p->{share_dir} = { dist => $p->{share_dir} };
  }
  elsif ( ref $p->{share_dir} eq 'HASH' ) {
    # hash -- check structure
    my $share_dir = $p->{share_dir};
    # check dist key
    if ( defined $share_dir->{dist} ) {
      if ( ! ref $share_dir->{dist} ) {
        # scalar, so upgrade to arrayref
        $share_dir->{dist} = [ $share_dir->{dist} ];
      }
      elsif ( ref $share_dir->{dist} ne 'ARRAY' ) {
        die "'dist' key in 'share_dir' must be scalar or arrayref";
      }
    }
    # check module key
    if ( defined $share_dir->{module} ) {
      my $mod_hash = $share_dir->{module};
      if ( ref $mod_hash eq 'HASH' ) {
        for my $k ( keys %$mod_hash ) {
          if ( ! ref $mod_hash->{$k} ) {
            $mod_hash->{$k} = [ $mod_hash->{$k} ];
          }
          elsif( ref $mod_hash->{$k} ne 'ARRAY' ) {
            die "modules in 'module' key of 'share_dir' must be scalar or arrayref";
          }
        }
      }
      else {
          die "'module' key in 'share_dir' must be hashref";
      }
    }
  }
  else {
    die "'share_dir' must be hashref, arrayref or string";
  }

  return $p->{share_dir};
}

sub script_files {
  my $self = shift;

  for ($self->{properties}{script_files}) {
    $_ = shift if @_;
    next unless $_;

    # Always coerce into a hash
    return $_ if UNIVERSAL::isa($_, 'HASH');
    return $_ = { map {$_,1} @$_ } if UNIVERSAL::isa($_, 'ARRAY');

    die "'script_files' must be a hashref, arrayref, or string" if ref();

    return $_ = { map {$_,1} $self->_files_in( $_ ) } if -d $_;
    return $_ = {$_ => 1};
  }

  my %pl_files = map {
    File::Spec->canonpath( $_ ) => 1
  } keys %{ $self->PL_files || {} };

  my @bin_files = $self->_files_in('bin');

  my %bin_map = map {
    $_ => File::Spec->canonpath( $_ )
  } @bin_files;

  return $_ = { map {$_ => 1} grep !$pl_files{$bin_map{$_}}, @bin_files };
}
BEGIN { *scripts = \&script_files; }

{
  my %licenses = (
    perl         => 'Perl_5',
    apache       => 'Apache_2_0',
    apache_1_1   => 'Apache_1_1',
    artistic     => 'Artistic_1',
    artistic_2   => 'Artistic_2',
    lgpl         => 'LGPL_2_1',
    lgpl2        => 'LGPL_2_1',
    lgpl3        => 'LGPL_3_0',
    bsd          => 'BSD',
    gpl          => 'GPL_1',
    gpl2         => 'GPL_2',
    gpl3         => 'GPL_3',
    mit          => 'MIT',
    mozilla      => 'Mozilla_1_1',
    restrictive  => 'Restricted',
    open_source  => undef,
    unrestricted => undef,
    unknown      => undef,
  );

  # TODO - would be nice to not have these here, since they're more
  # properly stored only in Software::License
  my %license_urls = (
    perl         => 'http://dev.perl.org/licenses/',
    apache       => 'http://apache.org/licenses/LICENSE-2.0',
    apache_1_1   => 'http://apache.org/licenses/LICENSE-1.1',
    artistic     => 'http://opensource.org/licenses/artistic-license.php',
    artistic_2   => 'http://opensource.org/licenses/artistic-license-2.0.php',
    lgpl         => 'http://opensource.org/licenses/lgpl-license.php',
    lgpl2        => 'http://opensource.org/licenses/lgpl-2.1.php',
    lgpl3        => 'http://opensource.org/licenses/lgpl-3.0.html',
    bsd          => 'http://opensource.org/licenses/bsd-license.php',
    gpl          => 'http://opensource.org/licenses/gpl-license.php',
    gpl2         => 'http://opensource.org/licenses/gpl-2.0.php',
    gpl3         => 'http://opensource.org/licenses/gpl-3.0.html',
    mit          => 'http://opensource.org/licenses/mit-license.php',
    mozilla      => 'http://opensource.org/licenses/mozilla1.1.php',
    restrictive  => undef,
    open_source  => undef,
    unrestricted => undef,
    unknown      => undef,
  );
  sub valid_licenses {
    return \%licenses;
  }
  sub _license_url {
    return $license_urls{$_[1]};
  }
}

sub _software_license_class {
  my ($self, $license) = @_;
  if ($self->valid_licenses->{$license} && eval { require Software::LicenseUtils; Software::LicenseUtils->VERSION(0.103009) }) {
    my ($class) = Software::LicenseUtils->guess_license_from_meta_key($license, 1);
	eval "require $class";
	#die $class;
	return $class;
  }
  LICENSE: for my $l ( $self->valid_licenses->{ $license }, $license ) {
    next unless defined $l;
    my $trial = "Software::License::" . $l;
    if ( eval "require Software::License; Software::License->VERSION(0.014); require $trial; 1" ) {
      return $trial;
    }
  }
  return;
}

# use mapping or license name directly
sub _software_license_object {
  my ($self) = @_;
  return unless defined( my $license = $self->license );

  my $class = $self->_software_license_class($license) or return;

  # Software::License requires a 'holder' argument
  my $author = join( " & ", @{ $self->dist_author }) || 'unknown';
  my $sl = eval { $class->new({holder=>$author}) };
  if ( $@ ) {
    $self->log_warn( "Error getting '$class' object: $@" );
  }

  return $sl;
}

sub _hash_merge {
  my ($self, $h, $k, $v) = @_;
  if (ref $h->{$k} eq 'ARRAY') {
    push @{$h->{$k}}, ref $v ? @$v : $v;
  } elsif (ref $h->{$k} eq 'HASH') {
    $h->{$k}{$_} = $v->{$_} foreach keys %$v;
  } else {
    $h->{$k} = $v;
  }
}

sub ACTION_distmeta {
  my ($self) = @_;
  $self->do_create_makefile_pl if $self->create_makefile_pl;
  $self->do_create_readme if $self->create_readme;
  $self->do_create_license if $self->create_license;
  $self->do_create_metafile;
}

sub do_create_metafile {
  my $self = shift;
  return if $self->{wrote_metadata};

  my $p = $self->{properties};

  unless ($p->{license}) {
    $self->log_warn("No license specified, setting license = 'unknown'\n");
    $p->{license} = 'unknown';
  }

  my @metafiles = ( $self->metafile, $self->metafile2 );
  # If we're in the distdir, the metafile may exist and be non-writable.
  $self->delete_filetree($_) for @metafiles;

  # Since we're building ourself, we have to do some special stuff
  # here: the ConfigData module is found in blib/lib.
  local @INC = @INC;
  if (($self->module_name || '') eq 'Module::Build') {
    $self->depends_on('config_data');
    push @INC, File::Spec->catdir($self->blib, 'lib');
  }

  my $meta_obj = $self->_get_meta_object(
    quiet => 1, fatal => 1, auto => 1
  );
  my @created = $self->_write_meta_files( $meta_obj, 'META' );
  if ( @created ) {
    $self->{wrote_metadata} = 1;
    $self->_add_to_manifest('MANIFEST', $_) for @created;
  }
  return 1;
}

sub _write_meta_files {
  my $self = shift;
  my ($meta, $file) = @_;
  $file =~ s{\.(?:yml|json)$}{};

  my @created;
  push @created, "$file\.yml"
    if $meta && $meta->save( "$file\.yml", {version => "1.4"} );
  push @created, "$file\.json"
    if $meta && $meta->save( "$file\.json" );

  if ( @created ) {
    $self->log_info("Created " . join(" and ", @created) . "\n");
  }
  return @created;
}

sub _get_meta_object {
  my $self = shift;
  my %args = @_;
  return unless $self->try_require("CPAN::Meta", "2.110420");

  my $meta;
  eval {
    my $data = $self->get_metadata(
      fatal => $args{fatal},
      auto => $args{auto},
    );
    $data->{dynamic_config} = $args{dynamic} if defined $args{dynamic};
    $meta = CPAN::Meta->create($data);
  };
  if ($@ && ! $args{quiet}) {
    $self->log_warn(
      "Could not get valid metadata. Error is: $@\n"
    );
  }

  return $meta;
}

# We return a version 1.4 structure for backwards compatibility
sub read_metafile {
  my $self = shift;
  my ($metafile) = @_;

  return unless $self->try_require("CPAN::Meta", "2.110420");
  my $meta = CPAN::Meta->load_file($metafile);
  return $meta->as_struct( {version => "1.4"} );
}

# For legacy compatibility, we upconvert a 1.4 data structure, ensuring
# validity, and then downconvert it back to save it.
#
# generally, this code should no longer be used
sub write_metafile {
  my $self = shift;
  my ($metafile, $struct) = @_;

  return unless $self->try_require("CPAN::Meta", "2.110420");

  my $meta = CPAN::Meta->new( $struct );
  return $meta->save( $metafile, { version => "1.4" } );
}

sub normalize_version {
  my ($self, $version) = @_;
  $version = 0 unless defined $version and length $version;

  if ( $version =~ /[=<>!,]/ ) { # logic, not just version
    # take as is without modification
  }
  elsif ( ref $version eq 'version' ||
          ref $version eq 'Module::Build::Version' ) { # version objects
    $version = $version->is_qv ? $version->normal : $version->stringify;
  }
  elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
    # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
    $version = "v$version";
  }
  else {
    # leave alone
  }
  return $version;
}

my %prereq_map = (
  requires => [ qw/runtime requires/],
  configure_requires => [qw/configure requires/],
  build_requires => [ qw/build requires/ ],
  test_requires => [ qw/test requires/ ],
  test_recommends => [ qw/test recommends/ ],
  recommends => [ qw/runtime recommends/ ],
  conflicts => [ qw/runtime conflicts/ ],
);

sub _normalize_prereqs {
  my ($self) = @_;
  my $p = $self->{properties};

  # copy prereq data structures so we can modify them before writing to META
  my %prereq_types;
  for my $type ( 'configure_requires', @{$self->prereq_action_types} ) {
    if (exists $p->{$type} and keys %{ $p->{$type} }) {
      my ($phase, $relation) = @{ $prereq_map{$type} };
      for my $mod ( keys %{ $p->{$type} } ) {
        $prereq_types{$phase}{$relation}{$mod} = $self->normalize_version($p->{$type}{$mod});
      }
    }
  }
  return \%prereq_types;
}

sub _get_license {
  my $self = shift;

  my $license = $self->license;
  my ($meta_license, $meta_license_url);

  my $valid_licenses = $self->valid_licenses();
  if ( my $sl = $self->_software_license_object ) {
    $meta_license = $sl->meta2_name;
    $meta_license_url = $sl->url;
  }
  elsif ( exists $valid_licenses->{$license} ) {
    $meta_license = $valid_licenses->{$license} ? lc $valid_licenses->{$license} : $license;
    $meta_license_url = $self->_license_url( $license );
  }
  else {
    $self->log_warn( "Can not determine license type for '" . $self->license
      . "'\nSetting META license field to 'unknown'.\n");
    $meta_license = 'unknown';
  }
  return ($meta_license, $meta_license_url);
}

my %keep = map { $_ => 1 } qw/keywords dynamic_config provides no_index name version abstract/;
my %ignore = map { $_ => 1 } qw/distribution_type/;
my %reject = map { $_ => 1 } qw/private author license requires recommends build_requires configure_requires conflicts/;

sub _upconvert_resources {
  my ($input) = @_;
  my %output;
  for my $key (keys %{$input}) {
    my $out_key = $key =~ /^\p{Lu}/ ? "x_\l$key" : $key;
    if ($key eq 'repository') {
      my $name = $input->{$key} =~ m{ \A http s? :// .* (<! \.git ) \z }xms ? 'web' : 'url';
      $output{$out_key} = { $name => $input->{$key} };
    }
    elsif ($key eq 'bugtracker') {
      $output{$out_key} = { web => $input->{$key} }
    }
    else {
      $output{$out_key} = $input->{$key};
    }
  }
  return \%output
}
my %custom = (
	resources => \&_upconvert_resources,
);

sub _upconvert_metapiece {
  my ($input, $type) = @_;
  return $input if exists $input->{'meta-spec'} && $input->{'meta-spec'}{version} == 2;

  my %ret;
  for my $key (keys %{$input}) {
    if ($keep{$key}) {
      $ret{$key} = $input->{$key};
    }
    elsif ($ignore{$key}) {
      next;
    }
    elsif ($reject{$key}) {
      croak "Can't $type $key, please use another mechanism";
    }
    elsif (my $converter = $custom{$key}) {
      $ret{$key} = $converter->($input->{$key});
    }
    else {
      my $out_key = $key =~ / \A x_ /xi ? $key : "x_$key";
      $ret{$out_key} = $input->{$key};
    }
  }
  return \%ret;
}

sub get_metadata {
  my ($self, %args) = @_;

  my $fatal = $args{fatal} || 0;
  my $p = $self->{properties};

  $self->auto_config_requires if $args{auto};

  # validate required fields
  foreach my $f (qw(dist_name dist_version dist_author dist_abstract license)) {
    my $field = $self->$f();
    unless ( defined $field and length $field ) {
      my $err = "ERROR: Missing required field '$f' for metafile\n";
      if ( $fatal ) {
        die $err;
      }
      else {
        $self->log_warn($err);
      }
    }
  }

  my %metadata = (
    name => $self->dist_name,
    version => $self->normalize_version($self->dist_version),
    author => $self->dist_author,
    abstract => $self->dist_abstract,
    generated_by => "Module::Build version $Module::Build::VERSION",
    'meta-spec' => {
      version => '2',
      url     => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
    },
    dynamic_config => exists $p->{dynamic_config} ? $p->{dynamic_config} : 1,
    release_status => $self->release_status,
  );

  my ($meta_license, $meta_license_url) = $self->_get_license;
  $metadata{license} = [ $meta_license ];
  $metadata{resources}{license} = [ $meta_license_url ] if defined $meta_license_url;

  $metadata{prereqs} = $self->_normalize_prereqs;

  if (exists $p->{no_index}) {
    $metadata{no_index} = $p->{no_index};
  } elsif (my $pkgs = eval { $self->find_dist_packages }) {
    $metadata{provides} = $pkgs if %$pkgs;
  } else {
    $self->log_warn("$@\nWARNING: Possible missing or corrupt 'MANIFEST' file.\n" .
                    "Nothing to enter for 'provides' field in metafile.\n");
  }

  my $meta_add = _upconvert_metapiece($self->meta_add, 'add');
  while (my($k, $v) = each %{$meta_add} ) {
    $metadata{$k} = $v;
  }

  my $meta_merge = _upconvert_metapiece($self->meta_merge, 'merge');
  while (my($k, $v) = each %{$meta_merge} ) {
    $self->_hash_merge(\%metadata, $k, $v);
  }

  return \%metadata;
}

# To preserve compatibility with old API, $node *must* be a hashref
# passed in to prepare_metadata.  $keys is an arrayref holding a
# list of keys -- it's use is optional and generally no longer needed
# but kept for back compatibility.  $args is an optional parameter to
# support the new 'fatal' toggle

sub prepare_metadata {
  my ($self, $node, $keys, $args) = @_;
  unless ( ref $node eq 'HASH' ) {
    croak "prepare_metadata() requires a hashref argument to hold output\n";
  }
  croak 'Keys argument to prepare_metadata is no longer supported' if $keys;
  %{$node} = %{ $self->get_meta(%{$args}) };
  return $node;
}

sub _read_manifest {
  my ($self, $file) = @_;
  return undef unless -e $file;

  require ExtUtils::Manifest;  # ExtUtils::Manifest is not warnings clean.
  local ($^W, $ExtUtils::Manifest::Quiet) = (0,1);
  return scalar ExtUtils::Manifest::maniread($file);
}

sub find_dist_packages {
  my $self = shift;

  # Only packages in .pm files are candidates for inclusion here.
  # Only include things in the MANIFEST, not things in developer's
  # private stock.

  my $manifest = $self->_read_manifest('MANIFEST')
    or die "Can't find dist packages without a MANIFEST file\nRun 'Build manifest' to generate one\n";

  # Localize
  my %dist_files = map { $self->localize_file_path($_) => $_ }
                       keys %$manifest;

  my @pm_files = grep { $_ !~ m{^t} } # skip things in t/
                   grep {exists $dist_files{$_}}
                     keys %{ $self->find_pm_files };

  return $self->find_packages_in_files(\@pm_files, \%dist_files);
}

# XXX Do not document this function; mst wrote it and now says the API is
# stupid and needs to be fixed and it shouldn't become a public API until then
sub find_packages_in_files {
  my ($self, $file_list, $filename_map) = @_;

  # First, we enumerate all packages & versions,
  # separating into primary & alternative candidates
  my( %prime, %alt );
  foreach my $file (@{$file_list}) {
    my $mapped_filename = $filename_map->{$file};
    my @path = split( /\//, $mapped_filename );
    (my $prime_package = join( '::', @path[1..$#path] )) =~ s/\.pm$//;

    my $pm_info = Module::Build::ModuleInfo->new_from_file( $file );

    foreach my $package ( $pm_info->packages_inside ) {
      next if $package eq 'main';  # main can appear numerous times, ignore
      next if $package eq 'DB';    # special debugging package, ignore
      next if grep /^_/, split( /::/, $package ); # private package, ignore

      my $version = $pm_info->version( $package );

      if ( $package eq $prime_package ) {
        if ( exists( $prime{$package} ) ) {
          # M::B::ModuleInfo will handle this conflict
          die "Unexpected conflict in '$package'; multiple versions found.\n";
        } else {
          $prime{$package}{file} = $mapped_filename;
          $prime{$package}{version} = $version if defined( $version );
        }
      } else {
        push( @{$alt{$package}}, {
                                  file    => $mapped_filename,
                                  version => $version,
                                 } );
      }
    }
  }

  # Then we iterate over all the packages found above, identifying conflicts
  # and selecting the "best" candidate for recording the file & version
  # for each package.
  foreach my $package ( keys( %alt ) ) {
    my $result = $self->_resolve_module_versions( $alt{$package} );

    if ( exists( $prime{$package} ) ) { # primary package selected

      if ( $result->{err} ) {
        # Use the selected primary package, but there are conflicting
        # errors among multiple alternative packages that need to be
        # reported
        $self->log_warn(
          "Found conflicting versions for package '$package'\n" .
          "  $prime{$package}{file} ($prime{$package}{version})\n" .
          $result->{err}
        );

      } elsif ( defined( $result->{version} ) ) {
        # There is a primary package selected, and exactly one
        # alternative package

        if ( exists( $prime{$package}{version} ) &&
             defined( $prime{$package}{version} ) ) {
          # Unless the version of the primary package agrees with the
          # version of the alternative package, report a conflict
          if ( $self->compare_versions( $prime{$package}{version}, '!=',
                                        $result->{version} ) ) {
            $self->log_warn(
              "Found conflicting versions for package '$package'\n" .
              "  $prime{$package}{file} ($prime{$package}{version})\n" .
              "  $result->{file} ($result->{version})\n"
            );
          }

        } else {
          # The prime package selected has no version so, we choose to
          # use any alternative package that does have a version
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version};
        }

      } else {
        # no alt package found with a version, but we have a prime
        # package so we use it whether it has a version or not
      }

    } else { # No primary package was selected, use the best alternative

      if ( $result->{err} ) {
        $self->log_warn(
          "Found conflicting versions for package '$package'\n" .
          $result->{err}
        );
      }

      # Despite possible conflicting versions, we choose to record
      # something rather than nothing
      $prime{$package}{file}    = $result->{file};
      $prime{$package}{version} = $result->{version}
          if defined( $result->{version} );
    }
  }

  # Normalize versions or delete them if undef/0
  for my $provides ( values %prime ) {
    if ( $provides->{version} ) {
      $provides->{version} = $self->normalize_version( $provides->{version} )
    }
    else {
      delete $provides->{version};
    }
  }

  return \%prime;
}

# separate out some of the conflict resolution logic from
# $self->find_dist_packages(), above, into a helper function.
#
sub _resolve_module_versions {
  my $self = shift;

  my $packages = shift;

  my( $file, $version );
  my $err = '';
    foreach my $p ( @$packages ) {
      if ( defined( $p->{version} ) ) {
        if ( defined( $version ) ) {
          if ( $self->compare_versions( $version, '!=', $p->{version} ) ) {
            $err .= "  $p->{file} ($p->{version})\n";
          } else {
            # same version declared multiple times, ignore
          }
        } else {
          $file    = $p->{file};
          $version = $p->{version};
        }
      }
      $file ||= $p->{file} if defined( $p->{file} );
    }

  if ( $err ) {
    $err = "  $file ($version)\n" . $err;
  }

  my %result = (
    file    => $file,
    version => $version,
    err     => $err
  );

  return \%result;
}

sub make_tarball {
  my ($self, $dir, $file) = @_;
  $file ||= $dir;

  $self->log_info("Creating $file.tar.gz\n");

  if ($self->{args}{tar}) {
    my $tar_flags = $self->verbose ? 'cvf' : 'cf';
    $self->do_system($self->split_like_shell($self->{args}{tar}), $tar_flags, "$file.tar", $dir);
    $self->do_system($self->split_like_shell($self->{args}{gzip}), "$file.tar") if $self->{args}{gzip};
  } else {
    eval { require Archive::Tar && Archive::Tar->VERSION(1.09); 1 }
      or die "You must install Archive::Tar 1.09+ to make a distribution tarball\n".
             "or specify a binary tar program with the '--tar' option.\n".
             "See the documentation for the 'dist' action.\n";

    my $files = $self->rscan_dir($dir);

    # Archive::Tar versions >= 1.09 use the following to enable a compatibility
    # hack so that the resulting archive is compatible with older clients.
    # If no file path is 100 chars or longer, we disable the prefix field
    # for maximum compatibility.  If there are any long file paths then we
    # need the prefix field after all.
    $Archive::Tar::DO_NOT_USE_PREFIX =
      (grep { length($_) >= 100 } @$files) ? 0 : 1;

    my $tar   = Archive::Tar->new;
    $tar->add_files(@$files);
    for my $f ($tar->get_files) {
      $f->mode($f->mode & ~022); # chmod go-w
    }
    $tar->write("$file.tar.gz", 1);
  }
}

sub install_path {
  my $self = shift;
  my( $type, $value ) = ( @_, '<empty>' );

  Carp::croak( 'Type argument missing' )
    unless defined( $type );

  my $map = $self->{properties}{install_path};
  return $map unless @_;

  # delete existing value if $value is literal undef()
  unless ( defined( $value ) ) {
    delete( $map->{$type} );
    return undef;
  }

  # return existing value if no new $value is given
  if ( $value eq '<empty>' ) {
    return undef unless exists $map->{$type};
    return $map->{$type};
  }

  # set value if $value is a valid relative path
  return $map->{$type} = $value;
}

sub install_sets {
  # Usage: install_sets('site'), install_sets('site', 'lib'),
  #   or install_sets('site', 'lib' => $value);
  my ($self, $dirs, $key, $value) = @_;
  $dirs = $self->installdirs unless defined $dirs;
  # update property before merging with defaults
  if ( @_ == 4 && defined $dirs && defined $key) {
    # $value can be undef; will mask default
    $self->{properties}{install_sets}{$dirs}{$key} = $value;
  }
  my $map = { $self->_merge_arglist(
    $self->{properties}{install_sets},
    $self->_default_install_paths->{install_sets}
  )};
  if ( defined $dirs && defined $key ) {
    return $map->{$dirs}{$key};
  }
  elsif ( defined $dirs ) {
    return $map->{$dirs};
  }
  else {
    croak "Can't determine installdirs for install_sets()";
  }
}

sub original_prefix {
  # Usage: original_prefix(), original_prefix('lib'),
  #   or original_prefix('lib' => $value);
  my ($self, $key, $value) = @_;
  # update property before merging with defaults
  if ( @_ == 3 && defined $key) {
    # $value can be undef; will mask default
    $self->{properties}{original_prefix}{$key} = $value;
  }
  my $map = { $self->_merge_arglist(
    $self->{properties}{original_prefix},
    $self->_default_install_paths->{original_prefix}
  )};
  return $map unless defined $key;
  return $map->{$key}
}

sub install_base_relpaths {
  # Usage: install_base_relpaths(), install_base_relpaths('lib'),
  #   or install_base_relpaths('lib' => $value);
  my $self = shift;
  if ( @_ > 1 ) { # change values before merge
    $self->_set_relpaths($self->{properties}{install_base_relpaths}, @_);
  }
  my $map = { $self->_merge_arglist(
    $self->{properties}{install_base_relpaths},
    $self->_default_install_paths->{install_base_relpaths}
  )};
  return $map unless @_;
  my $relpath = $map->{$_[0]};
  return defined $relpath ? File::Spec->catdir( @$relpath ) : undef;
}

# Defaults to use in case the config install paths cannot be prefixified.
sub prefix_relpaths {
  # Usage: prefix_relpaths('site'), prefix_relpaths('site', 'lib'),
  #   or prefix_relpaths('site', 'lib' => $value);
  my $self = shift;
  my $installdirs = shift || $self->installdirs
    or croak "Can't determine installdirs for prefix_relpaths()";
  if ( @_ > 1 ) { # change values before merge
    $self->{properties}{prefix_relpaths}{$installdirs} ||= {};
    $self->_set_relpaths($self->{properties}{prefix_relpaths}{$installdirs}, @_);
  }
  my $map = {$self->_merge_arglist(
    $self->{properties}{prefix_relpaths}{$installdirs},
    $self->_default_install_paths->{prefix_relpaths}{$installdirs}
  )};
  return $map unless @_;
  my $relpath = $map->{$_[0]};
  return defined $relpath ? File::Spec->catdir( @$relpath ) : undef;
}

sub _set_relpaths {
  my $self = shift;
  my( $map, $type, $value ) = @_;

  Carp::croak( 'Type argument missing' )
    unless defined( $type );

  # set undef if $value is literal undef()
  if ( ! defined( $value ) ) {
    $map->{$type} = undef;
    return;
  }
  # set value if $value is a valid relative path
  else {
    Carp::croak( "Value must be a relative path" )
      if File::Spec::Unix->file_name_is_absolute($value);

    my @value = split( /\//, $value );
    $map->{$type} = \@value;
  }
}

# Translated from ExtUtils::MM_Any::init_INSTALL_from_PREFIX
sub prefix_relative {
  my ($self, $type) = @_;
  my $installdirs = $self->installdirs;

  my $relpath = $self->install_sets($installdirs)->{$type};

  return $self->_prefixify($relpath,
                           $self->original_prefix($installdirs),
                           $type,
                          );
}

# Translated from ExtUtils::MM_Unix::prefixify()
sub _prefixify {
  my($self, $path, $sprefix, $type) = @_;

  my $rprefix = $self->prefix;
  $rprefix .= '/' if $sprefix =~ m|/$|;

  $self->log_verbose("  prefixify $path from $sprefix to $rprefix\n")
    if defined( $path ) && length( $path );

  if( !defined( $path ) || ( length( $path ) == 0 ) ) {
    $self->log_verbose("  no path to prefixify, falling back to default.\n");
    return $self->_prefixify_default( $type, $rprefix );
  } elsif( !File::Spec->file_name_is_absolute($path) ) {
    $self->log_verbose("    path is relative, not prefixifying.\n");
  } elsif( $path !~ s{^\Q$sprefix\E\b}{}s ) {
    $self->log_verbose("    cannot prefixify, falling back to default.\n");
    return $self->_prefixify_default( $type, $rprefix );
  }

  $self->log_verbose("    now $path in $rprefix\n");

  return $path;
}

sub _prefixify_default {
  my $self = shift;
  my $type = shift;
  my $rprefix = shift;

  my $default = $self->prefix_relpaths($self->installdirs, $type);
  if( !$default ) {
    $self->log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");
    return $rprefix;
  } else {
    return $default;
  }
}

sub install_destination {
  my ($self, $type) = @_;

  return $self->install_path($type) if $self->install_path($type);

  if ( $self->install_base ) {
    my $relpath = $self->install_base_relpaths($type);
    return $relpath ? File::Spec->catdir($self->install_base, $relpath) : undef;
  }

  if ( $self->prefix ) {
    my $relpath = $self->prefix_relative($type);
    return $relpath ? File::Spec->catdir($self->prefix, $relpath) : undef;
  }

  return $self->install_sets($self->installdirs)->{$type};
}

sub install_types {
  my $self = shift;

  my %types;
  if ( $self->install_base ) {
    %types = %{$self->install_base_relpaths};
  } elsif ( $self->prefix ) {
    %types = %{$self->prefix_relpaths};
  } else {
    %types = %{$self->install_sets($self->installdirs)};
  }

  %types = (%types, %{$self->install_path});

  return sort keys %types;
}

sub install_map {
  my ($self, $blib) = @_;
  $blib ||= $self->blib;

  my( %map, @skipping );
  foreach my $type ($self->install_types) {
    my $localdir = File::Spec->catdir( $blib, $type );
    next unless -e $localdir;

    # the line "...next if (($type eq 'bindoc'..." was one of many changes introduced for
    # improving HTML generation on ActivePerl, see https://rt.cpan.org/Public/Bug/Display.html?id=53478
    # Most changes were ok, but this particular line caused test failures in t/manifypods.t on windows,
    # therefore it is commented out.

    # ********* next if (($type eq 'bindoc' || $type eq 'libdoc') && not $self->is_unixish);

    if (my $dest = $self->install_destination($type)) {
      $map{$localdir} = $dest;
    } else {
      push( @skipping, $type );
    }
  }

  $self->log_warn(
    "WARNING: Can't figure out install path for types: @skipping\n" .
    "Files will not be installed.\n"
  ) if @skipping;

  # Write the packlist into the same place as ExtUtils::MakeMaker.
  if ($self->create_packlist and my $module_name = $self->module_name) {
    my $archdir = $self->install_destination('arch');
    my @ext = split /::/, $module_name;
    $map{write} = File::Spec->catfile($archdir, 'auto', @ext, '.packlist');
  }

  # Handle destdir
  if (length(my $destdir = $self->destdir || '')) {
    foreach (keys %map) {
      # Need to remove volume from $map{$_} using splitpath, or else
      # we'll create something crazy like C:\Foo\Bar\E:\Baz\Quux
      # VMS will always have the file separate than the path.
      my ($volume, $path, $file) = File::Spec->splitpath( $map{$_}, 0 );

      # catdir needs a list of directories, or it will create something
      # crazy like volume:[Foo.Bar.volume.Baz.Quux]
      my @dirs = File::Spec->splitdir($path);

      # First merge the directories
      $path = File::Spec->catdir($destdir, @dirs);

      # Then put the file back on if there is one.
      if ($file ne '') {
          $map{$_} = File::Spec->catfile($path, $file)
      } else {
          $map{$_} = $path;
      }
    }
  }

  $map{read} = '';  # To keep ExtUtils::Install quiet

  return \%map;
}

sub depends_on {
  my $self = shift;
  foreach my $action (@_) {
    $self->_call_action($action);
  }
}

sub rscan_dir {
  my ($self, $dir, $pattern) = @_;
  my @result;
  local $_; # find() can overwrite $_, so protect ourselves
  my $subr = !$pattern ? sub {push @result, $File::Find::name} :
             !ref($pattern) || (ref $pattern eq 'Regexp') ? sub {push @result, $File::Find::name if /$pattern/} :
             ref($pattern) eq 'CODE' ? sub {push @result, $File::Find::name if $pattern->()} :
             die "Unknown pattern type";

  File::Find::find({wanted => $subr, no_chdir => 1}, $dir);
  return \@result;
}

sub delete_filetree {
  my $self = shift;
  my $deleted = 0;
  foreach (@_) {
    next unless -e $_;
    $self->log_verbose("Deleting $_\n");
    File::Path::rmtree($_, 0, 0);
    die "Couldn't remove '$_': $!\n" if -e $_;
    $deleted++;
  }
  return $deleted;
}

sub autosplit_file {
  my ($self, $file, $to) = @_;
  require AutoSplit;
  my $dir = File::Spec->catdir($to, 'lib', 'auto');
  AutoSplit::autosplit($file, $dir);
}

sub cbuilder {
  # Returns a CBuilder object

  my $self = shift;
  my $s = $self->{stash};
  return $s->{_cbuilder} if $s->{_cbuilder};

  require ExtUtils::CBuilder;
  return $s->{_cbuilder} = ExtUtils::CBuilder->new(
    config => $self->config,
    ($self->quiet ? (quiet => 1 ) : ()),
  );
}

sub have_c_compiler {
  my ($self) = @_;

  my $p = $self->{properties};
  return $p->{_have_c_compiler} if defined $p->{_have_c_compiler};

  $self->log_verbose("Checking if compiler tools configured... ");
  my $b = $self->cbuilder;
  my $have = $b && eval { $b->have_compiler };
  $self->log_verbose($have ? "ok.\n" : "failed.\n");
  return $p->{_have_c_compiler} = $have;
}

sub compile_c {
  my ($self, $file, %args) = @_;

  if ( ! $self->have_c_compiler ) {
    die "Error: no compiler detected to compile '$file'.  Aborting\n";
  }

  my $b = $self->cbuilder;
  my $obj_file = $b->object_file($file);
  $self->add_to_cleanup($obj_file);
  return $obj_file if $self->up_to_date($file, $obj_file);

  $b->compile(source => $file,
              defines => $args{defines},
              object_file => $obj_file,
              include_dirs => $self->include_dirs,
              extra_compiler_flags => $self->extra_compiler_flags,
             );

  return $obj_file;
}

sub link_c {
  my ($self, $spec) = @_;
  my $p = $self->{properties}; # For convenience

  $self->add_to_cleanup($spec->{lib_file});

  my $objects = $p->{objects} || [];

  return $spec->{lib_file}
    if $self->up_to_date([$spec->{obj_file}, @$objects],
                         $spec->{lib_file});

  my $module_name = $spec->{module_name} || $self->module_name;

  $self->cbuilder->link(
    module_name => $module_name,
    objects     => [$spec->{obj_file}, @$objects],
    lib_file    => $spec->{lib_file},
    extra_linker_flags => $p->{extra_linker_flags} );

  return $spec->{lib_file};
}

sub compile_xs {
  my ($self, $file, %args) = @_;

  $self->log_verbose("$file -> $args{outfile}\n");

  if (eval {require ExtUtils::ParseXS; 1}) {

    ExtUtils::ParseXS::process_file(
                                    filename => $file,
                                    prototypes => 0,
                                    output => $args{outfile},
                                   );
  } else {
    # Ok, I give up.  Just use backticks.

    my $xsubpp = Module::Build::ModuleInfo->find_module_by_name('ExtUtils::xsubpp')
      or die "Can't find ExtUtils::xsubpp in INC (@INC)";

    my @typemaps;
    push @typemaps, Module::Build::ModuleInfo->find_module_by_name(
        'ExtUtils::typemap', \@INC
    );
    my $lib_typemap = Module::Build::ModuleInfo->find_module_by_name(
        'typemap', [File::Basename::dirname($file), File::Spec->rel2abs('.')]
    );
    push @typemaps, $lib_typemap if $lib_typemap;
    @typemaps = map {+'-typemap', $_} @typemaps;

    my $cf = $self->{config};
    my $perl = $self->{properties}{perl};

    my @command = ($perl, "-I".$cf->get('installarchlib'), "-I".$cf->get('installprivlib'), $xsubpp, '-noprototypes',
                   @typemaps, $file);

    $self->log_info("@command\n");
    open(my $fh, '>', $args{outfile}) or die "Couldn't write $args{outfile}: $!";
    print {$fh} $self->_backticks(@command);
    close $fh;
  }
}

sub split_like_shell {
  my ($self, $string) = @_;

  return () unless defined($string);
  return @$string if UNIVERSAL::isa($string, 'ARRAY');
  $string =~ s/^\s+|\s+$//g;
  return () unless length($string);

  return Text::ParseWords::shellwords($string);
}

sub oneliner {
  # Returns a string that the shell can evaluate as a perl command.
  # This should be avoided whenever possible, since "the shell" really
  # means zillions of shells on zillions of platforms and it's really
  # hard to get it right all the time.

  # Some of this code is stolen with permission from ExtUtils::MakeMaker.

  my($self, $cmd, $switches, $args) = @_;
  $switches = [] unless defined $switches;
  $args = [] unless defined $args;

  # Strip leading and trailing newlines
  $cmd =~ s{^\n+}{};
  $cmd =~ s{\n+$}{};

  my $perl = ref($self) ? $self->perl : $self->find_perl_interpreter;
  return $self->_quote_args($perl, @$switches, '-e', $cmd, @$args);
}

sub run_perl_script {
  my ($self, $script, $preargs, $postargs) = @_;
  foreach ($preargs, $postargs) {
    $_ = [ $self->split_like_shell($_) ] unless ref();
  }
  return $self->run_perl_command([@$preargs, $script, @$postargs]);
}

sub run_perl_command {
  # XXX Maybe we should accept @args instead of $args?  Must resolve
  # this before documenting.
  my ($self, $args) = @_;
  $args = [ $self->split_like_shell($args) ] unless ref($args);
  my $perl = ref($self) ? $self->perl : $self->find_perl_interpreter;

  # Make sure our local additions to @INC are propagated to the subprocess
  local $ENV{PERL5LIB} = join $self->config('path_sep'), $self->_added_to_INC;

  return $self->do_system($perl, @$args);
}

# Infer various data from the path of the input filename
# that is needed to create output files.
# The input filename is expected to be of the form:
#   lib/Module/Name.ext or Module/Name.ext
sub _infer_xs_spec {
  my $self = shift;
  my $file = shift;

  my $cf = $self->{config};

  my %spec;

  my( $v, $d, $f ) = File::Spec->splitpath( $file );
  my @d = File::Spec->splitdir( $d );
  (my $file_base = $f) =~ s/\.[^.]+$//i;

  $spec{base_name} = $file_base;

  $spec{src_dir} = File::Spec->catpath( $v, $d, '' );

  # the module name
  shift( @d ) while @d && ($d[0] eq 'lib' || $d[0] eq '');
  pop( @d ) while @d && $d[-1] eq '';
  $spec{module_name} = join( '::', (@d, $file_base) );

  $spec{archdir} = File::Spec->catdir($self->blib, 'arch', 'auto',
                                      @d, $file_base);

  $spec{c_file} = File::Spec->catfile( $spec{src_dir},
                                       "${file_base}.c" );

  $spec{obj_file} = File::Spec->catfile( $spec{src_dir},
                                         "${file_base}".$cf->get('obj_ext') );

  require DynaLoader;
  my $modfname = defined &DynaLoader::mod2fname ? DynaLoader::mod2fname([@d, $file_base]) : $file_base;

  $spec{bs_file} = File::Spec->catfile($spec{archdir}, "$modfname.bs");

  $spec{lib_file} = File::Spec->catfile($spec{archdir}, "$modfname.".$cf->get('dlext'));

  return \%spec;
}

sub process_xs {
  my ($self, $file) = @_;

  my $spec = $self->_infer_xs_spec($file);

  # File name, minus the suffix
  (my $file_base = $file) =~ s/\.[^.]+$//;

  # .xs -> .c
  $self->add_to_cleanup($spec->{c_file});

  unless ($self->up_to_date($file, $spec->{c_file})) {
    $self->compile_xs($file, outfile => $spec->{c_file});
  }

  # .c -> .o
  my $v = $self->dist_version;
  $self->compile_c($spec->{c_file},
                   defines => {VERSION => qq{"$v"}, XS_VERSION => qq{"$v"}});

  # archdir
  File::Path::mkpath($spec->{archdir}, 0, oct(777)) unless -d $spec->{archdir};

  # .xs -> .bs
  $self->add_to_cleanup($spec->{bs_file});
  unless ($self->up_to_date($file, $spec->{bs_file})) {
    require ExtUtils::Mkbootstrap;
    $self->log_info("ExtUtils::Mkbootstrap::Mkbootstrap('$spec->{bs_file}')\n");
    ExtUtils::Mkbootstrap::Mkbootstrap($spec->{bs_file});  # Original had $BSLOADLIBS - what's that?
    open(my $fh, '>>', $spec->{bs_file});  # create
    utime((time)x2, $spec->{bs_file});  # touch
  }

  # .o -> .(a|bundle)
  $self->link_c($spec);
}

sub do_system {
  my ($self, @cmd) = @_;
  $self->log_verbose("@cmd\n");

  # Some systems proliferate huge PERL5LIBs, try to ameliorate:
  my %seen;
  my $sep = $self->config('path_sep');
  local $ENV{PERL5LIB} =
    ( !exists($ENV{PERL5LIB}) ? '' :
      length($ENV{PERL5LIB}) < 500
      ? $ENV{PERL5LIB}
      : join $sep, grep { ! $seen{$_}++ and -d $_ } split($sep, $ENV{PERL5LIB})
    );

  my $status = system(@cmd);
  if ($status and $! =~ /Argument list too long/i) {
    my $env_entries = '';
    foreach (sort keys %ENV) { $env_entries .= "$_=>".length($ENV{$_})."; " }
    warn "'Argument list' was 'too long', env lengths are $env_entries";
  }
  return !$status;
}

sub copy_if_modified {
  my $self = shift;
  my %args = (@_ > 3
              ? ( @_ )
              : ( from => shift, to_dir => shift, flatten => shift )
             );
  $args{verbose} = !$self->quiet
    unless exists $args{verbose};

  my $file = $args{from};
  unless (defined $file and length $file) {
    die "No 'from' parameter given to copy_if_modified";
  }

  # makes no sense to replicate an absolute path, so assume flatten
  $args{flatten} = 1 if File::Spec->file_name_is_absolute( $file );

  my $to_path;
  if (defined $args{to} and length $args{to}) {
    $to_path = $args{to};
  } elsif (defined $args{to_dir} and length $args{to_dir}) {
    $to_path = File::Spec->catfile( $args{to_dir}, $args{flatten}
                                    ? File::Basename::basename($file)
                                    : $file );
  } else {
    die "No 'to' or 'to_dir' parameter given to copy_if_modified";
  }

  return if $self->up_to_date($file, $to_path); # Already fresh

  {
    local $self->{properties}{quiet} = 1;
    $self->delete_filetree($to_path); # delete destination if exists
  }

  # Create parent directories
  File::Path::mkpath(File::Basename::dirname($to_path), 0, oct(777));

  $self->log_verbose("Copying $file -> $to_path\n");

  if ($^O eq 'os2') {# copy will not overwrite; 0x1 = overwrite
    chmod 0666, $to_path;
    File::Copy::syscopy($file, $to_path, 0x1) or die "Can't copy('$file', '$to_path'): $!";
  } else {
    File::Copy::copy($file, $to_path) or die "Can't copy('$file', '$to_path'): $!";
  }

  # mode is read-only + (executable if source is executable)
  my $mode = oct(444) | ( $self->is_executable($file) ? oct(111) : 0 );
  chmod( $mode, $to_path );

  return $to_path;
}

sub up_to_date {
  my ($self, $source, $derived) = @_;
  $source  = [$source]  unless ref $source;
  $derived = [$derived] unless ref $derived;

  # empty $derived means $source should always run
  return 0 if @$source && !@$derived || grep {not -e} @$derived;

  my $most_recent_source = time / (24*60*60);
  foreach my $file (@$source) {
    unless (-e $file) {
      $self->log_warn("Can't find source file $file for up-to-date check");
      next;
    }
    $most_recent_source = -M _ if -M _ < $most_recent_source;
  }

  foreach my $derived (@$derived) {
    return 0 if -M $derived > $most_recent_source;
  }
  return 1;
}

sub dir_contains {
  my ($self, $first, $second) = @_;
  # File::Spec doesn't have an easy way to check whether one directory
  # is inside another, unfortunately.

  ($first, $second) = map File::Spec->canonpath($_), ($first, $second);
  my @first_dirs = File::Spec->splitdir($first);
  my @second_dirs = File::Spec->splitdir($second);

  return 0 if @second_dirs < @first_dirs;

  my $is_same = ( $self->_case_tolerant
                  ? sub {lc(shift()) eq lc(shift())}
                  : sub {shift() eq shift()} );

  while (@first_dirs) {
    return 0 unless $is_same->(shift @first_dirs, shift @second_dirs);
  }

  return 1;
}

1;
__END__


=head1 NAME

Module::Build::Base - Default methods for Module::Build

=head1 SYNOPSIS

  Please see the Module::Build documentation.

=head1 DESCRIPTION

The C<Module::Build::Base> module defines the core functionality of
C<Module::Build>.  Its methods may be overridden by any of the
platform-dependent modules in the C<Module::Build::Platform::>
namespace, but the intention here is to make this base module as
platform-neutral as possible.  Nicely enough, Perl has several core
tools available in the C<File::> namespace for doing this, so the task
isn't very difficult.

Please see the C<Module::Build> documentation for more details.

=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>

=head1 COPYRIGHT

Copyright (c) 2001-2006 Ken Williams.  All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 SEE ALSO

perl(1), Module::Build(3)

=cut
                                          usr/share/perl/5.20.2/Module/Build/Bundling.pod                                                     0100644 0000000 0000000 00000011730 12744441327 017412  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

Module::Build::Bundling - How to bundle Module::Build with a distribution

=head1 SYNOPSIS

  # Build.PL
  use inc::latest 'Module::Build';

  Module::Build->new(
    module_name => 'Foo::Bar',
    license => 'perl',
  )->create_build_script;

=head1 DESCRIPTION

B<WARNING -- THIS IS AN EXPERIMENTAL FEATURE>

In order to install a distribution using Module::Build, users must
have Module::Build available on their systems.  There are two ways
to do this.  The first way is to include Module::Build in the
C<configure_requires> metadata field.  This field is supported by
recent versions L<CPAN> and L<CPANPLUS> and is a standard feature
in the Perl core as of Perl 5.10.1.  Module::Build now adds itself
to C<configure_requires> by default.

The second way supports older Perls that have not upgraded CPAN or
CPANPLUS and involves bundling an entire copy of Module::Build
into the distribution's C<inc/> directory.  This is the same approach
used by L<Module::Install>, a modern wrapper around ExtUtils::MakeMaker
for Makefile.PL based distributions.

The "trick" to making this work for Module::Build is making sure the
highest version Module::Build is used, whether this is in C<inc/> or
already installed on the user's system.  This ensures that all necessary
features are available as well as any new bug fixes.  This is done using
the new L<inc::latest> module.

A "normal" Build.PL looks like this (with only the minimum required
fields):

  use Module::Build;

  Module::Build->new(
    module_name => 'Foo::Bar',
    license     => 'perl',
  )->create_build_script;

A "bundling" Build.PL replaces the initial "use" line with a nearly
transparent replacement:

  use inc::latest 'Module::Build';

  Module::Build->new(
    module_name => 'Foo::Bar',
    license => 'perl',
  )->create_build_script;

For I<authors>, when "Build dist" is run, Module::Build will be
automatically bundled into C<inc> according to the rules for
L<inc::latest>.

For I<users>, inc::latest will load the latest Module::Build, whether
installed or bundled in C<inc/>.

=head1 BUNDLING OTHER CONFIGURATION DEPENDENCIES

The same approach works for other configuration dependencies -- modules
that I<must> be available for Build.PL to run.  All other dependencies can
be specified as usual in the Build.PL and CPAN or CPANPLUS will install
them after Build.PL finishes.

For example, to bundle the L<Devel::AssertOS::Unix> module (which ensures a
"Unix-like" operating system), one could do this:

  use inc::latest 'Devel::AssertOS::Unix';
  use inc::latest 'Module::Build';

  Module::Build->new(
    module_name => 'Foo::Bar',
    license => 'perl',
  )->create_build_script;

The C<inc::latest> module creates bundled directories based on the packlist
file of an installed distribution.  Even though C<inc::latest> takes module
name arguments, it is better to think of it as bundling and making
available entire I<distributions>.  When a module is loaded through
C<inc::latest>, it looks in all bundled distributions in C<inc/> for a
newer module than can be found in the existing C<@INC> array.

Thus, the module-name provided should usually be the "top-level" module
name of a distribution, though this is not strictly required.  For example,
L<Module::Build> has a number of heuristics to map module names to
packlists, allowing users to do things like this:

  use inc::latest 'Devel::AssertOS::Unix';

even though Devel::AssertOS::Unix is contained within the Devel-CheckOS
distribution.

At the current time, packlists are required.  Thus, bundling dual-core
modules, I<including Module::Build>, may require a 'forced install' over
versions in the latest version of perl in order to create the necessary
packlist for bundling.  This limitation will hopefully be addressed in a
future version of Module::Build.

=head2 WARNING -- How to Manage Dependency Chains

Before bundling a distribution you must ensure that all prerequisites are
also bundled and load in the correct order.  For Module::Build itself, this
should not be necessary, but it is necessary for any other distribution.
(A future release of Module::Build will hopefully address this deficiency.)

For example, if you need C<Wibble>, but C<Wibble> depends on C<Wobble>,
your Build.PL might look like this:

  use inc::latest 'Wobble';
  use inc::latest 'Wibble';
  use inc::latest 'Module::Build';

  Module::Build->new(
    module_name => 'Foo::Bar',
    license => 'perl',
  )->create_build_script;

Authors are strongly suggested to limit the bundling of additional
dependencies if at all possible and to carefully test their distribution
tarballs on older versions of Perl before uploading to CPAN.

=head1 AUTHOR

David Golden <dagolden@cpan.org>

Development questions, bug reports, and patches should be sent to the
Module-Build mailing list at <module-build@perl.org>.

Bug reports are also welcome at
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Module-Build>.

=head1 SEE ALSO

perl(1), L<inc::latest>, L<Module::Build>(3), L<Module::Build::API>(3),
L<Module::Build::Cookbook>(3),

=cut

# vim: tw=75
                                        usr/share/perl/5.20.2/Module/Build/Compat.pm                                                        0100644 0000000 0000000 00000043671 12744441327 016736  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Compat;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';

use File::Basename ();
use File::Spec;
use Config;
use Module::Build;
use Module::Build::ModuleInfo;
use Module::Build::Version;
use Data::Dumper;

my %convert_installdirs = (
    PERL        => 'core',
    SITE        => 'site',
    VENDOR      => 'vendor',
);

my %makefile_to_build =
  (
   TEST_VERBOSE => 'verbose',
   VERBINST     => 'verbose',
   INC          => sub { map {(extra_compiler_flags => $_)} Module::Build->split_like_shell(shift) },
   POLLUTE      => sub { (extra_compiler_flags => '-DPERL_POLLUTE') },
   INSTALLDIRS  => sub { (installdirs => $convert_installdirs{uc shift()}) },
   LIB          => sub {
       my $lib = shift;
       my %config = (
           installprivlib  => $lib,
           installsitelib  => $lib,
           installarchlib  => "$lib/$Config{archname}",
           installsitearch => "$lib/$Config{archname}"
       );
       return map { (config => "$_=$config{$_}") } keys %config;
   },

   # Convert INSTALLVENDORLIB and friends.
   (
       map {
           my $name = $_;
           $name => sub {
                 my @ret = (config => lc($name) . "=" . shift );
                 print STDERR "# Converted to @ret\n";

                 return @ret;
           }
       } qw(
         INSTALLARCHLIB  INSTALLSITEARCH     INSTALLVENDORARCH
         INSTALLPRIVLIB  INSTALLSITELIB      INSTALLVENDORLIB
         INSTALLBIN      INSTALLSITEBIN      INSTALLVENDORBIN
         INSTALLSCRIPT   INSTALLSITESCRIPT   INSTALLVENDORSCRIPT
         INSTALLMAN1DIR  INSTALLSITEMAN1DIR  INSTALLVENDORMAN1DIR
         INSTALLMAN3DIR  INSTALLSITEMAN3DIR  INSTALLVENDORMAN3DIR
       )
   ),

   # Some names they have in common
   map {$_, lc($_)} qw(DESTDIR PREFIX INSTALL_BASE UNINST),
  );

my %macro_to_build = %makefile_to_build;
# "LIB=foo make" is not the same as "perl Makefile.PL LIB=foo"
delete $macro_to_build{LIB};

sub _merge_prereq {
  my ($req, $breq) = @_;
  $req ||= {};
  $breq ||= {};

  # validate formats
  for my $p ( $req, $breq ) {
    for my $k (keys %$p) {
      next if $k eq 'perl';

      my $v_obj = eval { Module::Build::Version->new($p->{$k}) };
      if ( ! defined $v_obj ) {
          die "A prereq of the form '$p->{$k}' for '$k' is not supported by Module::Build::Compat ( use a simpler version like '0.05' or 'v1.4.25' )\n";
      }

      # It seems like a lot of people trip over "0.1.2" stuff, so we help them here...
      if ( $v_obj->is_qv ) {
        my $proper_ver = $v_obj->numify;
        warn "Dotted-decimal prereq '$p->{$k}' for '$k' is not portable - converting it to '$proper_ver'\n";
        $p->{$k} = $proper_ver;
      }
    }
  }
  # merge
  my $merge = { %$req };
  for my $k ( keys %$breq ) {
    my $v1 = $merge->{$k} || 0;
    my $v2 = $breq->{$k};
    $merge->{$k} = $v1 > $v2 ? $v1 : $v2;
  }
  return %$merge;
}


sub create_makefile_pl {
  my ($package, $type, $build, %args) = @_;

  die "Don't know how to build Makefile.PL of type '$type'"
    unless $type =~ /^(small|passthrough|traditional)$/;

  if ($type eq 'passthrough') {
    $build->log_warn(<<"HERE");

IMPORTANT NOTE: The '$type' style of Makefile.PL is deprecated and
may be removed in a future version of Module::Build in favor of the
'configure_requires' property.  See Module::Build::Compat
documentation for details.

HERE
  }

  my $fh;
  if ($args{fh}) {
    $fh = $args{fh};
  } else {
    $args{file} ||= 'Makefile.PL';
    local $build->{properties}{quiet} = 1;
    $build->delete_filetree($args{file});
    open($fh, '>', "$args{file}") or die "Can't write $args{file}: $!";
  }

  print {$fh} "# Note: this file was auto-generated by ", __PACKAGE__, " version $VERSION\n";

  # Minimum perl version should be specified as "require 5.XXXXXX" in
  # Makefile.PL
  my $requires = $build->requires;
  if ( my $minimum_perl = $requires->{perl} ) {
    my $min_ver = Module::Build::Version->new($minimum_perl)->numify;
    print {$fh} "require $min_ver;\n";
  }

  # If a *bundled* custom subclass is being used, make sure we add its
  # directory to @INC.  Also, lib.pm always needs paths in Unix format.
  my $subclass_load = '';
  if (ref($build) ne "Module::Build") {
    my $subclass_dir = $package->subclass_dir($build);

    if (File::Spec->file_name_is_absolute($subclass_dir)) {
      my $base_dir = $build->base_dir;

      if ($build->dir_contains($base_dir, $subclass_dir)) {
	$subclass_dir = File::Spec->abs2rel($subclass_dir, $base_dir);
	$subclass_dir = $package->unixify_dir($subclass_dir);
        $subclass_load = "use lib '$subclass_dir';";
      }
      # Otherwise, leave it the empty string

    } else {
      $subclass_dir = $package->unixify_dir($subclass_dir);
      $subclass_load = "use lib '$subclass_dir';";
    }
  }

  if ($type eq 'small') {
    printf {$fh} <<'EOF', $subclass_load, ref($build), ref($build);
    use Module::Build::Compat 0.02;
    %s
    Module::Build::Compat->run_build_pl(args => \@ARGV);
    require %s;
    Module::Build::Compat->write_makefile(build_class => '%s');
EOF

  } elsif ($type eq 'passthrough') {
    printf {$fh} <<'EOF', $subclass_load, ref($build), ref($build);

    unless (eval "use Module::Build::Compat 0.02; 1" ) {
      print "This module requires Module::Build to install itself.\n";

      require ExtUtils::MakeMaker;
      my $yn = ExtUtils::MakeMaker::prompt
	('  Install Module::Build now from CPAN?', 'y');

      unless ($yn =~ /^y/i) {
	die " *** Cannot install without Module::Build.  Exiting ...\n";
      }

      require Cwd;
      require File::Spec;
      require CPAN;

      # Save this 'cause CPAN will chdir all over the place.
      my $cwd = Cwd::cwd();

      CPAN::Shell->install('Module::Build::Compat');
      CPAN::Shell->expand("Module", "Module::Build::Compat")->uptodate
	or die "Couldn't install Module::Build, giving up.\n";

      chdir $cwd or die "Cannot chdir() back to $cwd: $!";
    }
    eval "use Module::Build::Compat 0.02; 1" or die $@;
    %s
    Module::Build::Compat->run_build_pl(args => \@ARGV);
    my $build_script = 'Build';
    $build_script .= '.com' if $^O eq 'VMS';
    exit(0) unless(-e $build_script); # cpantesters convention
    require %s;
    Module::Build::Compat->write_makefile(build_class => '%s');
EOF

  } elsif ($type eq 'traditional') {

    my (%MM_Args, %prereq);
    if (eval "use Tie::IxHash 1.2; 1") {
      tie %MM_Args, 'Tie::IxHash'; # Don't care if it fails here
      tie %prereq,  'Tie::IxHash'; # Don't care if it fails here
    }

    my %name = ($build->module_name
		? (NAME => $build->module_name)
		: (DISTNAME => $build->dist_name));

    my %version = ($build->dist_version_from
		   ? (VERSION_FROM => $build->dist_version_from)
		   : (VERSION      => $build->dist_version)
		  );
    %MM_Args = (%name, %version);

    %prereq = _merge_prereq( $build->requires, $build->build_requires );
    %prereq = map {$_, $prereq{$_}} sort keys %prereq;

     delete $prereq{perl};
    $MM_Args{PREREQ_PM} = \%prereq;

    $MM_Args{INSTALLDIRS} = $build->installdirs eq 'core' ? 'perl' : $build->installdirs;

    $MM_Args{EXE_FILES} = [ sort keys %{$build->script_files} ] if $build->script_files;

    $MM_Args{PL_FILES} = $build->PL_files || {};

    if ($build->recursive_test_files) {
        $MM_Args{test} = { TESTS => join q{ }, $package->_test_globs($build) };
    }

    local $Data::Dumper::Terse = 1;
    my $args = Data::Dumper::Dumper(\%MM_Args);
    $args =~ s/\{(.*)\}/($1)/s;

    print $fh <<"EOF";
use ExtUtils::MakeMaker;
WriteMakefile
$args;
EOF
  }
}

sub _test_globs {
  my ($self, $build) = @_;

  return map { File::Spec->catfile($_, '*.t') }
         @{$build->rscan_dir('t', sub { -d $File::Find::name })};
}

sub subclass_dir {
  my ($self, $build) = @_;

  return (Module::Build::ModuleInfo->find_module_dir_by_name(ref $build)
	  || File::Spec->catdir($build->config_dir, 'lib'));
}

sub unixify_dir {
  my ($self, $path) = @_;
  return join '/', File::Spec->splitdir($path);
}

sub makefile_to_build_args {
  my $class = shift;
  my @out;
  foreach my $arg (@_) {
    next if $arg eq '';

    my ($key, $val) = ($arg =~ /^(\w+)=(.+)/ ? ($1, $2) :
		       die "Malformed argument '$arg'");

    # Do tilde-expansion if it looks like a tilde prefixed path
    ( $val ) = Module::Build->_detildefy( $val ) if $val =~ /^~/;

    if (exists $makefile_to_build{$key}) {
      my $trans = $makefile_to_build{$key};
      push @out, $class->_argvify( ref($trans) ? $trans->($val) : ($trans => $val) );
    } elsif (exists $Config{lc($key)}) {
      push @out, $class->_argvify( config => lc($key) . "=$val" );
    } else {
      # Assume M::B can handle it in lowercase form
      push @out, $class->_argvify("\L$key" => $val);
    }
  }
  return @out;
}

sub _argvify {
  my ($self, @pairs) = @_;
  my @out;
  while (@pairs) {
    my ($k, $v) = splice @pairs, 0, 2;
    push @out, ("--$k", $v);
  }
  return @out;
}

sub makefile_to_build_macros {
  my @out;
  my %config; # must accumulate and return as a hashref
  while (my ($macro, $trans) = each %macro_to_build) {
    # On some platforms (e.g. Cygwin with 'make'), the mere presence
    # of "EXPORT: FOO" in the Makefile will make $ENV{FOO} defined.
    # Therefore we check length() too.
    next unless exists $ENV{$macro} && length $ENV{$macro};
    my $val = $ENV{$macro};
    my @args = ref($trans) ? $trans->($val) : ($trans => $val);
    while (@args) {
      my ($k, $v) = splice(@args, 0, 2);
      if ( $k eq 'config' ) {
        if ( $v =~ /^([^=]+)=(.*)$/ ) {
          $config{$1} = $2;
        }
        else {
          warn "Couldn't parse config '$v'\n";
        }
      }
      else {
        push @out, ($k => $v);
      }
    }
  }
  push @out, (config => \%config) if %config;
  return @out;
}

sub run_build_pl {
  my ($pack, %in) = @_;
  $in{script} ||= 'Build.PL';
  my @args = $in{args} ? $pack->makefile_to_build_args(@{$in{args}}) : ();
  print "# running $in{script} @args\n";
  Module::Build->run_perl_script($in{script}, [], \@args) or die "Couldn't run $in{script}: $!";
}

sub fake_makefile {
  my ($self, %args) = @_;
  unless (exists $args{build_class}) {
    warn "Unknown 'build_class', defaulting to 'Module::Build'\n";
    $args{build_class} = 'Module::Build';
  }
  my $class = $args{build_class};

  my $perl = $class->find_perl_interpreter;

  # VMS MMS/MMK need to use MCR to run the Perl image.
  $perl = 'MCR ' . $perl if $self->_is_vms_mms;

  my $noop = ($class->is_windowsish ? 'rem>nul'  :
	      $self->_is_vms_mms    ? 'Continue' :
	      'true');

  my $filetype = $class->is_vmsish ? '.COM' : '';

  my $Build = 'Build' . $filetype . ' --makefile_env_macros 1';
  my $unlink = $class->oneliner('1 while unlink $ARGV[0]', [], [$args{makefile}]);
  $unlink =~ s/\$/\$\$/g unless $class->is_vmsish;

  my $maketext = ($^O eq 'os2' ? "SHELL = sh\n\n" : '');

  $maketext .= <<"EOF";
all : force_do_it
	$perl $Build
realclean : force_do_it
	$perl $Build realclean
	$unlink
distclean : force_do_it
	$perl $Build distclean
	$unlink


force_do_it :
	@ $noop
EOF

  foreach my $action ($class->known_actions) {
    next if $action =~ /^(all|distclean|realclean|force_do_it)$/;  # Don't double-define
    $maketext .= <<"EOF";
$action : force_do_it
	$perl $Build $action
EOF
  }

  if ($self->_is_vms_mms) {
    # Roll our own .EXPORT as MMS/MMK don't honor that directive.
    $maketext .= "\n.FIRST\n\t\@ $noop\n";
    for my $macro (keys %macro_to_build) {
      $maketext .= ".IFDEF $macro\n\tDEFINE $macro \"\$($macro)\"\n.ENDIF\n";
    }
    $maketext .= "\n";
  }
  else {
    $maketext .= "\n.EXPORT : " . join(' ', keys %macro_to_build) . "\n\n";
  }

  return $maketext;
}

sub fake_prereqs {
  my $file = File::Spec->catfile('_build', 'prereqs');
  open(my $fh, '<', "$file") or die "Can't read $file: $!";
  my $prereqs = eval do {local $/; <$fh>};
  close $fh;

  my %merged = _merge_prereq( $prereqs->{requires}, $prereqs->{build_requires} );
  my @prereq;
  foreach (sort keys %merged) {
    next if $_ eq 'perl';
    push @prereq, "$_=>q[$merged{$_}]";
  }
  return unless @prereq;
  return "#     PREREQ_PM => { " . join(", ", @prereq) . " }\n\n";
}


sub write_makefile {
  my ($pack, %in) = @_;

  unless (exists $in{build_class}) {
    warn "Unknown 'build_class', defaulting to 'Module::Build'\n";
    $in{build_class} = 'Module::Build';
  }
  my $class = $in{build_class};
  $in{makefile} ||= $pack->_is_vms_mms ? 'Descrip.MMS' : 'Makefile';

  open  MAKE, "> $in{makefile}" or die "Cannot write $in{makefile}: $!";
  print MAKE $pack->fake_prereqs;
  print MAKE $pack->fake_makefile(%in);
  close MAKE;
}

sub _is_vms_mms {
  return Module::Build->is_vmsish && ($Config{make} =~ m/MM[SK]/i);
}

1;
__END__

=for :stopwords passthrough

=head1 NAME

Module::Build::Compat - Compatibility with ExtUtils::MakeMaker

=head1 SYNOPSIS

  # In a Build.PL :
  use Module::Build;
  my $build = Module::Build->new
    ( module_name => 'Foo::Bar',
      license     => 'perl',
      create_makefile_pl => 'traditional' );
  ...


=head1 DESCRIPTION

Because C<ExtUtils::MakeMaker> has been the standard way to distribute
modules for a long time, many tools (CPAN.pm, or your system
administrator) may expect to find a working F<Makefile.PL> in every
distribution they download from CPAN.  If you want to throw them a
bone, you can use C<Module::Build::Compat> to automatically generate a
F<Makefile.PL> for you, in one of several different styles.

C<Module::Build::Compat> also provides some code that helps out the
F<Makefile.PL> at runtime.


=head1 METHODS

=over 4

=item create_makefile_pl($style, $build)

Creates a F<Makefile.PL> in the current directory in one of several
styles, based on the supplied C<Module::Build> object C<$build>.  This is
typically controlled by passing the desired style as the
C<create_makefile_pl> parameter to C<Module::Build>'s C<new()> method;
the F<Makefile.PL> will then be automatically created during the
C<distdir> action.

The currently supported styles are:

=over 4

=item traditional

A F<Makefile.PL> will be created in the "traditional" style, i.e. it will
use C<ExtUtils::MakeMaker> and won't rely on C<Module::Build> at all.
In order to create the F<Makefile.PL>, we'll include the C<requires> and
C<build_requires> dependencies as the C<PREREQ_PM> parameter.

You don't want to use this style if during the C<perl Build.PL> stage
you ask the user questions, or do some auto-sensing about the user's
environment, or if you subclass C<Module::Build> to do some
customization, because the vanilla F<Makefile.PL> won't do any of that.

=item small

A small F<Makefile.PL> will be created that passes all functionality
through to the F<Build.PL> script in the same directory.  The user must
already have C<Module::Build> installed in order to use this, or else
they'll get a module-not-found error.

=item passthrough (DEPRECATED)

This is just like the C<small> option above, but if C<Module::Build> is
not already installed on the user's system, the script will offer to
use C<CPAN.pm> to download it and install it before continuing with
the build.

This option has been deprecated and may be removed in a future version
of Module::Build.  Modern CPAN.pm and CPANPLUS will recognize the
C<configure_requires> metadata property and install Module::Build before
running Build.PL if Module::Build is listed and Module::Build now
adds itself to configure_requires by default.

Perl 5.10.1 includes C<configure_requires> support.  In the future, when
C<configure_requires> support is deemed sufficiently widespread, the
C<passthrough> style will be removed.

=back

=item run_build_pl(args => \@ARGV)

This method runs the F<Build.PL> script, passing it any arguments the
user may have supplied to the C<perl Makefile.PL> command.  Because
C<ExtUtils::MakeMaker> and C<Module::Build> accept different arguments, this
method also performs some translation between the two.

C<run_build_pl()> accepts the following named parameters:

=over 4

=item args

The C<args> parameter specifies the parameters that would usually
appear on the command line of the C<perl Makefile.PL> command -
typically you'll just pass a reference to C<@ARGV>.

=item script

This is the filename of the script to run - it defaults to C<Build.PL>.

=back

=item write_makefile()

This method writes a 'dummy' F<Makefile> that will pass all commands
through to the corresponding C<Module::Build> actions.

C<write_makefile()> accepts the following named parameters:

=over 4

=item makefile

The name of the file to write - defaults to the string C<Makefile>.

=back

=back


=head1 SCENARIOS

So, some common scenarios are:

=over 4

=item 1.

Just include a F<Build.PL> script (without a F<Makefile.PL>
script), and give installation directions in a F<README> or F<INSTALL>
document explaining how to install the module.  In particular, explain
that the user must install C<Module::Build> before installing your
module.

Note that if you do this, you may make things easier for yourself, but
harder for people with older versions of CPAN or CPANPLUS on their
system, because those tools generally only understand the
F<Makefile.PL>/C<ExtUtils::MakeMaker> way of doing things.

=item 2.

Include a F<Build.PL> script and a "traditional" F<Makefile.PL>,
created either manually or with C<create_makefile_pl()>.  Users won't
ever have to install C<Module::Build> if they use the F<Makefile.PL>, but
they won't get to take advantage of C<Module::Build>'s extra features
either.

For good measure, of course, test both the F<Makefile.PL> and the
F<Build.PL> before shipping.

=item 3.

Include a F<Build.PL> script and a "pass-through" F<Makefile.PL>
built using C<Module::Build::Compat>.  This will mean that people can
continue to use the "old" installation commands, and they may never
notice that it's actually doing something else behind the scenes.  It
will also mean that your installation process is compatible with older
versions of tools like CPAN and CPANPLUS.

=back


=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>


=head1 COPYRIGHT

Copyright (c) 2001-2006 Ken Williams.  All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.


=head1 SEE ALSO

L<Module::Build>(3), L<ExtUtils::MakeMaker>(3)


=cut
                                                                       usr/share/perl/5.20.2/Module/Build/Config.pm                                                        0100644 0000000 0000000 00000002123 12744441327 016703  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Config;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Config;

sub new {
  my ($pack, %args) = @_;
  return bless {
		stack => {},
		values => $args{values} || {},
	       }, $pack;
}

sub get {
  my ($self, $key) = @_;
  return $self->{values}{$key} if ref($self) && exists $self->{values}{$key};
  return $Config{$key};
}

sub set {
  my ($self, $key, $val) = @_;
  $self->{values}{$key} = $val;
}

sub push {
  my ($self, $key, $val) = @_;
  push @{$self->{stack}{$key}}, $self->{values}{$key}
    if exists $self->{values}{$key};
  $self->{values}{$key} = $val;
}

sub pop {
  my ($self, $key) = @_;

  my $val = delete $self->{values}{$key};
  if ( exists $self->{stack}{$key} ) {
    $self->{values}{$key} = pop @{$self->{stack}{$key}};
    delete $self->{stack}{$key} unless @{$self->{stack}{$key}};
  }

  return $val;
}

sub values_set {
  my $self = shift;
  return undef unless ref($self);
  return $self->{values};
}

sub all_config {
  my $self = shift;
  my $v = ref($self) ? $self->{values} : {};
  return {%Config, %$v};
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/share/perl/5.20.2/Module/Build/ConfigData.pm                                                    0100644 0000000 0000000 00000015441 12744441327 017504  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::ConfigData;
use strict;
my $arrayref = eval do {local $/; <DATA>}
  or die "Couldn't load ConfigData data: $@";
close DATA;
my ($config, $features, $auto_features) = @$arrayref;

sub config { $config->{$_[1]} }

sub set_config { $config->{$_[1]} = $_[2] }
sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0

sub auto_feature_names { grep !exists $features->{$_}, keys %$auto_features }

sub feature_names {
  my @features = (keys %$features, auto_feature_names());
  @features;
}

sub config_names  { keys %$config }

sub write {
  my $me = __FILE__;

  # Can't use Module::Build::Dumper here because M::B is only a
  # build-time prereq of this module
  require Data::Dumper;

  my $mode_orig = (stat $me)[2] & 07777;
  chmod($mode_orig | 0222, $me); # Make it writeable
  open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
  seek($fh, 0, 0);
  while (<$fh>) {
    last if /^__DATA__$/;
  }
  die "Couldn't find __DATA__ token in $me" if eof($fh);

  seek($fh, tell($fh), 0);
  my $data = [$config, $features, $auto_features];
  print($fh 'do{ my '
	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
	      . '$x; }' );
  truncate($fh, tell($fh));
  close $fh;

  chmod($mode_orig, $me)
    or warn "Couldn't restore permissions on $me: $!";
}

sub feature {
  my ($package, $key) = @_;
  return $features->{$key} if exists $features->{$key};

  my $info = $auto_features->{$key} or return 0;

  # Under perl 5.005, each(%$foo) isn't working correctly when $foo
  # was reanimated with Data::Dumper and eval().  Not sure why, but
  # copying to a new hash seems to solve it.
  my %info = %$info;

  require Module::Build;  # XXX should get rid of this
  while (my ($type, $prereqs) = each %info) {
    next if $type eq 'description' || $type eq 'recommends';

    my %p = %$prereqs;  # Ditto here.
    while (my ($modname, $spec) = each %p) {
      my $status = Module::Build->check_installed_status($modname, $spec);
      if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
      if ( ! eval "require $modname; 1" ) { return 0; }
    }
  }
  return 1;
}


=head1 NAME

Module::Build::ConfigData - Configuration for Module::Build

=head1 SYNOPSIS

  use Module::Build::ConfigData;
  $value = Module::Build::ConfigData->config('foo');
  $value = Module::Build::ConfigData->feature('bar');

  @names = Module::Build::ConfigData->config_names;
  @names = Module::Build::ConfigData->feature_names;

  Module::Build::ConfigData->set_config(foo => $new_value);
  Module::Build::ConfigData->set_feature(bar => $new_value);
  Module::Build::ConfigData->write;  # Save changes


=head1 DESCRIPTION

This module holds the configuration data for the C<Module::Build>
module.  It also provides a programmatic interface for getting or
setting that configuration data.  Note that in order to actually make
changes, you'll have to have write access to the C<Module::Build::ConfigData>
module, and you should attempt to understand the repercussions of your
actions.


=head1 METHODS

=over 4

=item config($name)

Given a string argument, returns the value of the configuration item
by that name, or C<undef> if no such item exists.

=item feature($name)

Given a string argument, returns the value of the feature by that
name, or C<undef> if no such feature exists.

=item set_config($name, $value)

Sets the configuration item with the given name to the given value.
The value may be any Perl scalar that will serialize correctly using
C<Data::Dumper>.  This includes references, objects (usually), and
complex data structures.  It probably does not include transient
things like filehandles or sockets.

=item set_feature($name, $value)

Sets the feature with the given name to the given boolean value.  The
value will be converted to 0 or 1 automatically.

=item config_names()

Returns a list of all the names of config items currently defined in
C<Module::Build::ConfigData>, or in scalar context the number of items.

=item feature_names()

Returns a list of all the names of features currently defined in
C<Module::Build::ConfigData>, or in scalar context the number of features.

=item auto_feature_names()

Returns a list of all the names of features whose availability is
dynamically determined, or in scalar context the number of such
features.  Does not include such features that have later been set to
a fixed value.

=item write()

Commits any changes from C<set_config()> and C<set_feature()> to disk.
Requires write access to the C<Module::Build::ConfigData> module.

=back


=head1 AUTHOR

C<Module::Build::ConfigData> was automatically created using C<Module::Build>.
C<Module::Build> was written by Ken Williams, but he holds no
authorship claim or copyright claim to the contents of C<Module::Build::ConfigData>.

=cut


__DATA__
do{ my $x = [
       {},
       {},
       {
         'dist_authoring' => {
                               'requires' => {
                                               'Archive::Tar' => '1.09'
                                             },
                               'description' => 'Create new distributions',
                               'recommends' => {
                                                 'Pod::Readme' => '0.04',
                                                 'Module::Signature' => '0.21'
                                               }
                             },
         'HTML_support' => {
                             'requires' => {
                                             'Pod::Html' => 0
                                           },
                             'description' => 'Create HTML documentation'
                           },
         'manpage_support' => {
                                'requires' => {
                                                'Pod::Man' => 0
                                              },
                                'description' => 'Create Unix man pages'
                              },
         'license_creation' => {
                                 'requires' => {
                                                 'Software::License' => '0.103009'
                                               },
                                 'description' => 'Create licenses automatically in distributions'
                               },
         'PPM_support' => {
                            'description' => 'Generate PPM files for distributions'
                          },
         'inc_bundling_support' => {
                                     'requires' => {
                                                     'ExtUtils::Installed' => '1.999',
                                                     'ExtUtils::Install' => '1.54'
                                                   },
                                     'description' => 'Bundle Module::Build in inc/'
                                   }
       }
     ];
$x; }                                                                                                                                                                                                                               usr/share/perl/5.20.2/Module/Build/Cookbook.pm                                                      0100644 0000000 0000000 00000041675 12744441327 017263  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Cookbook;
use strict;
use vars qw($VERSION);
$VERSION = '0.4205';


=head1 NAME

Module::Build::Cookbook - Examples of Module::Build Usage

=head1 DESCRIPTION

C<Module::Build> isn't conceptually very complicated, but examples are
always helpful.  The following recipes should help developers and/or
installers put together the pieces from the other parts of the
documentation.


=head1 BASIC RECIPES


=head2 Installing modules that use Module::Build

In most cases, you can just issue the following commands:

  perl Build.PL
  ./Build
  ./Build test
  ./Build install

There's nothing complicated here - first you're running a script
called F<Build.PL>, then you're running a (newly-generated) script
called F<Build> and passing it various arguments.

The exact commands may vary a bit depending on how you invoke perl
scripts on your system.  For instance, if you have multiple versions
of perl installed, you can install to one particular perl's library
directories like so:

  /usr/bin/perl5.8.1 Build.PL
  ./Build
  ./Build test
  ./Build install

If you're on Windows where the current directory is always searched
first for scripts, you'll probably do something like this:

  perl Build.PL
  Build
  Build test
  Build install

On the old Mac OS (version 9 or lower) using MacPerl, you can
double-click on the F<Build.PL> script to create the F<Build> script,
then double-click on the F<Build> script to run its C<build>, C<test>,
and C<install> actions.

The F<Build> script knows what perl was used to run F<Build.PL>, so
you don't need to re-invoke the F<Build> script with the complete perl
path each time.  If you invoke it with the I<wrong> perl path, you'll
get a warning or a fatal error.

=head2 Modifying Config.pm values

C<Module::Build> relies heavily on various values from perl's
C<Config.pm> to do its work.  For example, default installation paths
are given by C<installsitelib> and C<installvendorman3dir> and
friends, C linker & compiler settings are given by C<ld>,
C<lddlflags>, C<cc>, C<ccflags>, and so on.  I<If you're pretty sure
you know what you're doing>, you can tell C<Module::Build> to pretend
there are different values in F<Config.pm> than what's really there,
by passing arguments for the C<--config> parameter on the command
line:

  perl Build.PL --config cc=gcc --config ld=gcc

Inside the C<Build.PL> script the same thing can be accomplished by
passing values for the C<config> parameter to C<new()>:

 my $build = Module::Build->new
   (
    ...
    config => { cc => 'gcc', ld => 'gcc' },
    ...
   );

In custom build code, the same thing can be accomplished by calling
the L<Module::Build/config> method:

 $build->config( cc => 'gcc' );     # Set
 $build->config( ld => 'gcc' );     # Set
 ...
 my $linker = $build->config('ld'); # Get


=head2 Installing modules using the programmatic interface

If you need to build, test, and/or install modules from within some
other perl code (as opposed to having the user type installation
commands at the shell), you can use the programmatic interface.
Create a Module::Build object (or an object of a custom Module::Build
subclass) and then invoke its C<dispatch()> method to run various
actions.

  my $build = Module::Build->new
    (
     module_name => 'Foo::Bar',
     license     => 'perl',
     requires    => { 'Some::Module'   => '1.23' },
    );
  $build->dispatch('build');
  $build->dispatch('test', verbose => 1);
  $build->dispatch('install');

The first argument to C<dispatch()> is the name of the action, and any
following arguments are named parameters.

This is the interface we use to test Module::Build itself in the
regression tests.


=head2 Installing to a temporary directory

To create packages for package managers like RedHat's C<rpm> or
Debian's C<deb>, you may need to install to a temporary directory
first and then create the package from that temporary installation.
To do this, specify the C<destdir> parameter to the C<install> action:

  ./Build install --destdir /tmp/my-package-1.003

This essentially just prepends all the installation paths with the
F</tmp/my-package-1.003> directory.


=head2 Installing to a non-standard directory

To install to a non-standard directory (for example, if you don't have
permission to install in the system-wide directories), you can use the
C<install_base> or C<prefix> parameters:

  ./Build install --install_base /foo/bar

See L<Module::Build/"INSTALL PATHS"> for a much more complete
discussion of how installation paths are determined.


=head2 Installing in the same location as ExtUtils::MakeMaker

With the introduction of C<--prefix> in Module::Build 0.28 and
C<INSTALL_BASE> in C<ExtUtils::MakeMaker> 6.31 its easy to get them both
to install to the same locations.

First, ensure you have at least version 0.28 of Module::Build
installed and 6.31 of C<ExtUtils::MakeMaker>.  Prior versions have
differing (and in some cases quite strange) installation behaviors.

The following installation flags are equivalent between
C<ExtUtils::MakeMaker> and C<Module::Build>.

    MakeMaker             Module::Build
    PREFIX=...            --prefix ...
    INSTALL_BASE=...      --install_base ...
    DESTDIR=...           --destdir ...
    LIB=...               --install_path lib=...
    INSTALLDIRS=...       --installdirs ...
    INSTALLDIRS=perl      --installdirs core
    UNINST=...            --uninst ...
    INC=...               --extra_compiler_flags ...
    POLLUTE=1             --extra_compiler_flags -DPERL_POLLUTE

For example, if you are currently installing C<MakeMaker> modules with
this command:

    perl Makefile.PL PREFIX=~
    make test
    make install UNINST=1

You can install into the same location with Module::Build using this:

    perl Build.PL --prefix ~
    ./Build test
    ./Build install --uninst 1

=head3 C<prefix> vs C<install_base>

The behavior of C<prefix> is complicated and depends on
how your Perl is configured.  The resulting installation locations
will vary from machine to machine and even different installations of
Perl on the same machine.  Because of this, it's difficult to document
where C<prefix> will place your modules.

In contrast, C<install_base> has predictable, easy to explain
installation locations.  Now that C<Module::Build> and C<MakeMaker> both
have C<install_base> there is little reason to use C<prefix> other
than to preserve your existing installation locations.  If you are
starting a fresh Perl installation we encourage you to use
C<install_base>.  If you have an existing installation installed via
C<prefix>, consider moving it to an installation structure matching
C<install_base> and using that instead.


=head2 Running a single test file

C<Module::Build> supports running a single test, which enables you to
track down errors more quickly.  Use the following format:

  ./Build test --test_files t/mytest.t

In addition, you may want to run the test in verbose mode to get more
informative output:

  ./Build test --test_files t/mytest.t --verbose 1

I run this so frequently that I define the following shell alias:

  alias t './Build test --verbose 1 --test_files'

So then I can just execute C<t t/mytest.t> to run a single test.


=head1 ADVANCED RECIPES


=head2 Making a CPAN.pm-compatible distribution

New versions of CPAN.pm understand how to use a F<Build.PL> script,
but old versions don't.  If authors want to help users who have old
versions, some form of F<Makefile.PL> should be supplied.  The easiest
way to accomplish this is to use the C<create_makefile_pl> parameter to
C<< Module::Build->new() >> in the C<Build.PL> script, which can
create various flavors of F<Makefile.PL> during the C<dist> action.

As a best practice, we recommend using the "traditional" style of
F<Makefile.PL> unless your distribution has needs that can't be
accomplished that way.

The C<Module::Build::Compat> module, which is part of
C<Module::Build>'s distribution, is responsible for creating these
F<Makefile.PL>s.  Please see L<Module::Build::Compat> for the details.


=head2 Changing the order of the build process

The C<build_elements> property specifies the steps C<Module::Build>
will take when building a distribution.  To change the build order,
change the order of the entries in that property:

  # Process pod files first
  my @e = @{$build->build_elements};
  my ($i) = grep {$e[$_] eq 'pod'} 0..$#e;
  unshift @e, splice @e, $i, 1;

Currently, C<build_elements> has the following default value:

  [qw( PL support pm xs pod script )]

Do take care when altering this property, since there may be
non-obvious (and non-documented!) ordering dependencies in the
C<Module::Build> code.


=head2 Adding new file types to the build process

Sometimes you might have extra types of files that you want to install
alongside the standard types like F<.pm> and F<.pod> files.  For
instance, you might have a F<Bar.dat> file containing some data
related to the C<Foo::Bar> module and you'd like for it to end up as
F<Foo/Bar.dat> somewhere in perl's C<@INC> path so C<Foo::Bar> can
access it easily at runtime.  The following code from a sample
C<Build.PL> file demonstrates how to accomplish this:

  use Module::Build;
  my $build = Module::Build->new
    (
     module_name => 'Foo::Bar',
     ...other stuff here...
    );
  $build->add_build_element('dat');
  $build->create_build_script;

This will find all F<.dat> files in the F<lib/> directory, copy them
to the F<blib/lib/> directory during the C<build> action, and install
them during the C<install> action.

If your extra files aren't located in the C<lib/> directory in your
distribution, you can explicitly say where they are, just as you'd do
with F<.pm> or F<.pod> files:

  use Module::Build;
  my $build = new Module::Build
    (
     module_name => 'Foo::Bar',
     dat_files => {'some/dir/Bar.dat' => 'lib/Foo/Bar.dat'},
     ...other stuff here...
    );
  $build->add_build_element('dat');
  $build->create_build_script;

If your extra files actually need to be created on the user's machine,
or if they need some other kind of special processing, you'll probably
want to subclass C<Module::Build> and create a special method to
process them, named C<process_${kind}_files()>:

  use Module::Build;
  my $class = Module::Build->subclass(code => <<'EOF');
    sub process_dat_files {
      my $self = shift;
      ... locate and process *.dat files,
      ... and create something in blib/lib/
    }
  EOF
  my $build = $class->new
    (
     module_name => 'Foo::Bar',
     ...other stuff here...
    );
  $build->add_build_element('dat');
  $build->create_build_script;

If your extra files don't go in F<lib/> but in some other place, see
L<"Adding new elements to the install process"> for how to actually
get them installed.

Please note that these examples use some capabilities of Module::Build
that first appeared in version 0.26.  Before that it could
still be done, but the simple cases took a bit more work.


=head2 Adding new elements to the install process

By default, Module::Build creates seven subdirectories of the F<blib>
directory during the build process: F<lib>, F<arch>, F<bin>,
F<script>, F<bindoc>, F<libdoc>, and F<html> (some of these may be
missing or empty if there's nothing to go in them).  Anything copied
to these directories during the build will eventually be installed
during the C<install> action (see L<Module::Build/"INSTALL PATHS">.

If you need to create a new custom type of installable element, e.g. C<conf>,
then you need to tell Module::Build where things in F<blib/conf/>
should be installed.  To do this, use the C<install_path> parameter to
the C<new()> method:

  my $build = Module::Build->new
    (
     ...other stuff here...
     install_path => { conf => $installation_path }
    );

Or you can call the C<install_path()> method later:

  $build->install_path(conf => $installation_path);

The user may also specify the path on the command line:

  perl Build.PL --install_path conf=/foo/path/etc

The important part, though, is that I<somehow> the install path needs
to be set, or else nothing in the F<blib/conf/> directory will get
installed, and a runtime error during the C<install> action will
result.

See also L<"Adding new file types to the build process"> for how to
create the stuff in F<blib/conf/> in the first place.


=head1 EXAMPLES ON CPAN

Several distributions on CPAN are making good use of various features
of Module::Build.  They can serve as real-world examples for others.


=head2 SVN-Notify-Mirror

L<http://search.cpan.org/~jpeacock/SVN-Notify-Mirror/>

John Peacock, author of the C<SVN-Notify-Mirror> distribution, says:

=over 4

=item 1. Using C<auto_features>, I check to see whether two optional
modules are available - SVN::Notify::Config and Net::SSH;

=item 2. If the S::N::Config module is loaded, I automatically
generate test files for it during Build (using the C<PL_files>
property).

=item 3. If the C<ssh_feature> is available, I ask if the user wishes
to perform the ssh tests (since it requires a little preliminary
setup);

=item 4. Only if the user has C<ssh_feature> and answers yes to the
testing, do I generate a test file.

I'm sure I could not have handled this complexity with EU::MM, but it
was very easy to do with M::B.

=back


=head2 Modifying an action

Sometimes you might need an to have an action, say C<./Build install>,
do something unusual.  For instance, you might need to change the
ownership of a file or do something else peculiar to your application.

You can subclass C<Module::Build> on the fly using the C<subclass()>
method and override the methods that perform the actions.  You may
need to read through C<Module::Build::Authoring> and
C<Module::Build::API> to find the methods you want to override.  All
"action" methods are implemented by a method called "ACTION_" followed
by the action's name, so here's an example of how it would work for
the C<install> action:

  # Build.PL
  use Module::Build;
  my $class = Module::Build->subclass(
      class => "Module::Build::Custom",
      code => <<'SUBCLASS' );

  sub ACTION_install {
      my $self = shift;
      # YOUR CODE HERE
      $self->SUPER::ACTION_install;
  }
  SUBCLASS

  $class->new(
      module_name => 'Your::Module',
      # rest of the usual Module::Build parameters
  )->create_build_script;


=head2 Adding an action

You can add a new C<./Build> action simply by writing the method for
it in your subclass.  Use C<depends_on> to declare that another action
must have been run before your action.

For example, let's say you wanted to be able to write C<./Build
commit> to test your code and commit it to Subversion.

  # Build.PL
  use Module::Build;
  my $class = Module::Build->subclass(
      class => "Module::Build::Custom",
      code => <<'SUBCLASS' );

  sub ACTION_commit {
      my $self = shift;

      $self->depends_on("test");
      $self->do_system(qw(svn commit));
  }
  SUBCLASS


=head2 Bundling Module::Build

Note: This section probably needs an update as the technology improves
(see contrib/bundle.pl in the distribution).

Suppose you want to use some new-ish features of Module::Build,
e.g. newer than the version of Module::Build your users are likely to
already have installed on their systems.  The first thing you should
do is set C<configure_requires> to your minimum version of
Module::Build.  See L<Module::Build::Authoring>.

But not every build system honors C<configure_requires> yet.  Here's
how you can ship a copy of Module::Build, but still use a newer
installed version to take advantage of any bug fixes and upgrades.

First, install Module::Build into F<Your-Project/inc/Module-Build>.
CPAN will not index anything in the F<inc> directory so this copy will
not show up in CPAN searches.

    cd Module-Build
    perl Build.PL --install_base /path/to/Your-Project/inc/Module-Build
    ./Build test
    ./Build install

You should now have all the Module::Build .pm files in
F<Your-Project/inc/Module-Build/lib/perl5>.

Next, add this to the top of your F<Build.PL>.

    my $Bundled_MB = 0.30;  # or whatever version it was.

    # Find out what version of Module::Build is installed or fail quietly.
    # This should be cross-platform.
    my $Installed_MB =
        `$^X -e "eval q{require Module::Build; print Module::Build->VERSION} or exit 1";

    # some operating systems put a newline at the end of every print.
    chomp $Installed_MB;

    $Installed_MB = 0 if $?;

    # Use our bundled copy of Module::Build if it's newer than the installed.
    unshift @INC, "inc/Module-Build/lib/perl5" if $Bundled_MB > $Installed_MB;

    require Module::Build;

And write the rest of your F<Build.PL> normally.  Module::Build will
remember your change to C<@INC> and use it when you run F<./Build>.

In the future, we hope to provide a more automated solution for this
scenario; see C<inc/latest.pm> in the Module::Build distribution for
one indication of the direction we're moving.


=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>


=head1 COPYRIGHT

Copyright (c) 2001-2008 Ken Williams.  All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.


=head1 SEE ALSO

perl(1), L<Module::Build>(3), L<Module::Build::Authoring>(3),
L<Module::Build::API>(3)

=cut
                                                                   usr/share/perl/5.20.2/Module/Build/Dumper.pm                                                        0100644 0000000 0000000 00000000676 12744441327 016745  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Dumper;
use strict;
use vars qw($VERSION);
$VERSION = '0.4205';

# This is just a split-out of a wrapper function to do Data::Dumper
# stuff "the right way".  See:
# http://groups.google.com/group/perl.module.build/browse_thread/thread/c8065052b2e0d741

use Data::Dumper;

sub _data_dump {
  my ($self, $data) = @_;
  return ("do{ my "
	  . Data::Dumper->new([$data],['x'])->Purity(1)->Terse(0)->Dump()
	  . '$x; }')
}

1;
                                                                  usr/share/perl/5.20.2/Module/Build/ModuleInfo.pm                                                    0100644 0000000 0000000 00000001161 12744441327 017540  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
# vim:ts=8:sw=2:et:sta:sts=2
package Module::Build::ModuleInfo;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;

require Module::Metadata;
our @ISA = qw/Module::Metadata/;

1;

__END__

=for :stopwords ModuleInfo

=head1 NAME

Module::Build::ModuleInfo - DEPRECATED

=head1 DESCRIPTION

This module has been extracted into a separate distribution and renamed
L<Module::Metadata>.  This module is kept as a subclass wrapper for
compatibility.

=head1 SEE ALSO

perl(1), L<Module::Build>, L<Module::Metadata>

=cut

                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/perl/5.20.2/Module/Build/Notes.pm                                                         0100644 0000000 0000000 00000020461 12744441327 016573  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Notes;

# A class for persistent hashes

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Data::Dumper;
use Module::Build::Dumper;

sub new {
  my ($class, %args) = @_;
  my $file = delete $args{file} or die "Missing required parameter 'file' to new()";
  my $self = bless {
		    disk => {},
		    new  => {},
		    file => $file,
		    %args,
		   }, $class;
}

sub restore {
  my $self = shift;

  open(my $fh, '<', $self->{file}) or die "Can't read $self->{file}: $!";
  $self->{disk} = eval do {local $/; <$fh>};
  die $@ if $@;
  close $fh;
  $self->{new} = {};
}

sub access {
  my $self = shift;
  return $self->read() unless @_;

  my $key = shift;
  return $self->read($key) unless @_;

  my $value = shift;
  $self->write({ $key => $value });
  return $self->read($key);
}

sub has_data {
  my $self = shift;
  return keys %{$self->read()} > 0;
}

sub exists {
  my ($self, $key) = @_;
  return exists($self->{new}{$key}) || exists($self->{disk}{$key});
}

sub read {
  my $self = shift;

  if (@_) {
    # Return 1 key as a scalar
    my $key = shift;
    return $self->{new}{$key} if exists $self->{new}{$key};
    return $self->{disk}{$key};
  }

  # Return all data
  my $out = (keys %{$self->{new}}
	     ? {%{$self->{disk}}, %{$self->{new}}}
	     : $self->{disk});
  return wantarray ? %$out : $out;
}

sub _same {
  my ($self, $x, $y) = @_;
  return 1 if !defined($x) and !defined($y);
  return 0 if !defined($x) or  !defined($y);
  return $x eq $y;
}

sub write {
  my ($self, $href) = @_;
  $href ||= {};

  @{$self->{new}}{ keys %$href } = values %$href;  # Merge

  # Do some optimization to avoid unnecessary writes
  foreach my $key (keys %{ $self->{new} }) {
    next if ref $self->{new}{$key};
    next if ref $self->{disk}{$key} or !exists $self->{disk}{$key};
    delete $self->{new}{$key} if $self->_same($self->{new}{$key}, $self->{disk}{$key});
  }

  if (my $file = $self->{file}) {
    my ($vol, $dir, $base) = File::Spec->splitpath($file);
    $dir = File::Spec->catpath($vol, $dir, '');
    return unless -e $dir && -d $dir;  # The user needs to arrange for this

    return if -e $file and !keys %{ $self->{new} };  # Nothing to do

    @{$self->{disk}}{ keys %{$self->{new}} } = values %{$self->{new}};  # Merge
    $self->_dump($file, $self->{disk});

    $self->{new} = {};
  }
  return $self->read;
}

sub _dump {
  my ($self, $file, $data) = @_;

  open(my $fh, '>', $file) or die "Can't create '$file': $!";
  print {$fh} Module::Build::Dumper->_data_dump($data);
  close $fh;
}

my $orig_template = do { local $/; <DATA> };
close DATA;

sub write_config_data {
  my ($self, %args) = @_;

  my $template = $orig_template;
  $template =~ s/NOTES_NAME/$args{config_module}/g;
  $template =~ s/MODULE_NAME/$args{module}/g;
  $template =~ s/=begin private\n//;
  $template =~ s/=end private/=cut/;

  # strip out private POD markers we use to keep pod from being
  # recognized for *this* source file
  $template =~ s{$_\n}{} for '=begin private', '=end private';

  open(my $fh, '>', $args{file}) or die "Can't create '$args{file}': $!";
  print {$fh} $template;
  print {$fh} "\n__DATA__\n";
  print {$fh} Module::Build::Dumper->_data_dump([$args{config_data}, $args{feature}, $args{auto_features}]);
  close $fh;
}

1;


=head1 NAME

Module::Build::Notes - Create persistent distribution configuration modules

=head1 DESCRIPTION

This module is used internally by Module::Build to create persistent
configuration files that can be installed with a distribution.  See
L<Module::Build::ConfigData> for an example.

=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>

=head1 COPYRIGHT

Copyright (c) 2001-2006 Ken Williams.  All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 SEE ALSO

perl(1), L<Module::Build>(3)

=cut

__DATA__
package NOTES_NAME;
use strict;
my $arrayref = eval do {local $/; <DATA>}
  or die "Couldn't load ConfigData data: $@";
close DATA;
my ($config, $features, $auto_features) = @$arrayref;

sub config { $config->{$_[1]} }

sub set_config { $config->{$_[1]} = $_[2] }
sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0

sub auto_feature_names { grep !exists $features->{$_}, keys %$auto_features }

sub feature_names {
  my @features = (keys %$features, auto_feature_names());
  @features;
}

sub config_names  { keys %$config }

sub write {
  my $me = __FILE__;

  # Can't use Module::Build::Dumper here because M::B is only a
  # build-time prereq of this module
  require Data::Dumper;

  my $mode_orig = (stat $me)[2] & 07777;
  chmod($mode_orig | 0222, $me); # Make it writeable
  open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
  seek($fh, 0, 0);
  while (<$fh>) {
    last if /^__DATA__$/;
  }
  die "Couldn't find __DATA__ token in $me" if eof($fh);

  seek($fh, tell($fh), 0);
  my $data = [$config, $features, $auto_features];
  print($fh 'do{ my '
	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
	      . '$x; }' );
  truncate($fh, tell($fh));
  close $fh;

  chmod($mode_orig, $me)
    or warn "Couldn't restore permissions on $me: $!";
}

sub feature {
  my ($package, $key) = @_;
  return $features->{$key} if exists $features->{$key};

  my $info = $auto_features->{$key} or return 0;

  # Under perl 5.005, each(%$foo) isn't working correctly when $foo
  # was reanimated with Data::Dumper and eval().  Not sure why, but
  # copying to a new hash seems to solve it.
  my %info = %$info;

  require Module::Build;  # XXX should get rid of this
  while (my ($type, $prereqs) = each %info) {
    next if $type eq 'description' || $type eq 'recommends';

    my %p = %$prereqs;  # Ditto here.
    while (my ($modname, $spec) = each %p) {
      my $status = Module::Build->check_installed_status($modname, $spec);
      if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
      if ( ! eval "require $modname; 1" ) { return 0; }
    }
  }
  return 1;
}

=begin private

=head1 NAME

NOTES_NAME - Configuration for MODULE_NAME

=head1 SYNOPSIS

  use NOTES_NAME;
  $value = NOTES_NAME->config('foo');
  $value = NOTES_NAME->feature('bar');

  @names = NOTES_NAME->config_names;
  @names = NOTES_NAME->feature_names;

  NOTES_NAME->set_config(foo => $new_value);
  NOTES_NAME->set_feature(bar => $new_value);
  NOTES_NAME->write;  # Save changes


=head1 DESCRIPTION

This module holds the configuration data for the C<MODULE_NAME>
module.  It also provides a programmatic interface for getting or
setting that configuration data.  Note that in order to actually make
changes, you'll have to have write access to the C<NOTES_NAME>
module, and you should attempt to understand the repercussions of your
actions.


=head1 METHODS

=over 4

=item config($name)

Given a string argument, returns the value of the configuration item
by that name, or C<undef> if no such item exists.

=item feature($name)

Given a string argument, returns the value of the feature by that
name, or C<undef> if no such feature exists.

=item set_config($name, $value)

Sets the configuration item with the given name to the given value.
The value may be any Perl scalar that will serialize correctly using
C<Data::Dumper>.  This includes references, objects (usually), and
complex data structures.  It probably does not include transient
things like filehandles or sockets.

=item set_feature($name, $value)

Sets the feature with the given name to the given boolean value.  The
value will be converted to 0 or 1 automatically.

=item config_names()

Returns a list of all the names of config items currently defined in
C<NOTES_NAME>, or in scalar context the number of items.

=item feature_names()

Returns a list of all the names of features currently defined in
C<NOTES_NAME>, or in scalar context the number of features.

=item auto_feature_names()

Returns a list of all the names of features whose availability is
dynamically determined, or in scalar context the number of such
features.  Does not include such features that have later been set to
a fixed value.

=item write()

Commits any changes from C<set_config()> and C<set_feature()> to disk.
Requires write access to the C<NOTES_NAME> module.

=back


=head1 AUTHOR

C<NOTES_NAME> was automatically created using C<Module::Build>.
C<Module::Build> was written by Ken Williams, but he holds no
authorship claim or copyright claim to the contents of C<NOTES_NAME>.

=end private

                                                                                                                                                                                                               usr/share/perl/5.20.2/Module/Build/PPMMaker.pm                                                      0100644 0000000 0000000 00000010665 12744441327 017124  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::PPMMaker;

use strict;
use Config;
use vars qw($VERSION);

$VERSION = '0.4205';
$VERSION = eval $VERSION;

# This code is mostly borrowed from ExtUtils::MM_Unix 6.10_03, with a
# few tweaks based on the PPD spec at
# http://www.xav.com/perl/site/lib/XML/PPD.html

# The PPD spec is based on <http://www.w3.org/TR/NOTE-OSD>

sub new {
  my $package = shift;
  return bless {@_}, $package;
}

sub make_ppd {
  my ($self, %args) = @_;
  my $build = delete $args{build};

  my @codebase;
  if (exists $args{codebase}) {
    @codebase = ref $args{codebase} ? @{$args{codebase}} : ($args{codebase});
  } else {
    my $distfile = $build->ppm_name . '.tar.gz';
    print "Using default codebase '$distfile'\n";
    @codebase = ($distfile);
  }

  my %dist;
  foreach my $info (qw(name author abstract version)) {
    my $method = "dist_$info";
    $dist{$info} = $build->$method() or die "Can't determine distribution's $info\n";
  }

  $self->_simple_xml_escape($_) foreach $dist{abstract}, @{$dist{author}};

  # TODO: could add <LICENSE HREF=...> tag if we knew what the URLs were for
  # various licenses
  my $ppd = <<"PPD";
<SOFTPKG NAME=\"$dist{name}\" VERSION=\"$dist{version}\">
    <ABSTRACT>$dist{abstract}</ABSTRACT>
@{[ join "\n", map "    <AUTHOR>$_</AUTHOR>", @{$dist{author}} ]}
    <IMPLEMENTATION>
PPD

  # We don't include recommended dependencies because PPD has no way
  # to distinguish them from normal dependencies.  We don't include
  # build_requires dependencies because the PPM installer doesn't
  # build or test before installing.  And obviously we don't include
  # conflicts either.

  foreach my $type (qw(requires)) {
    my $prereq = $build->$type();
    while (my ($modname, $spec) = each %$prereq) {
      next if $modname eq 'perl';

      my $min_version = '0.0';
      foreach my $c ($build->_parse_conditions($spec)) {
        my ($op, $version) = $c =~ /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x;

        # This is a nasty hack because it fails if there is no >= op
        if ($op eq '>=') {
          $min_version = $version;
          last;
        }
      }

      # PPM4 spec requires a '::' for top level modules
      $modname .= '::' unless $modname =~ /::/;

      $ppd .= qq!        <REQUIRE NAME="$modname" VERSION="$min_version" />\n!;
    }
  }

  # We only include these tags if this module involves XS, on the
  # assumption that pure Perl modules will work on any OS.
  if (keys %{$build->find_xs_files}) {
    my $perl_version = $self->_ppd_version($build->perl_version);
    $ppd .= sprintf(<<'EOF', $self->_varchname($build->config) );
        <ARCHITECTURE NAME="%s" />
EOF
  }

  foreach my $codebase (@codebase) {
    $self->_simple_xml_escape($codebase);
    $ppd .= sprintf(<<'EOF', $codebase);
        <CODEBASE HREF="%s" />
EOF
  }

  $ppd .= <<'EOF';
    </IMPLEMENTATION>
</SOFTPKG>
EOF

  my $ppd_file = "$dist{name}.ppd";
  open(my $fh, '>', $ppd_file)
    or die "Cannot write to $ppd_file: $!";

  binmode($fh, ":utf8")
    if $] >= 5.008 && $Config{useperlio};
  print $fh $ppd;
  close $fh;

  return $ppd_file;
}

sub _ppd_version {
  my ($self, $version) = @_;

  # generates something like "0,18,0,0"
  return join ',', (split(/\./, $version), (0)x4)[0..3];
}

sub _varchname {  # Copied from PPM.pm
  my ($self, $config) = @_;
  my $varchname = $config->{archname};
  # Append "-5.8" to architecture name for Perl 5.8 and later
  if ($] >= 5.008) {
      my $vstring = sprintf "%vd", $^V;
      $vstring =~ s/\.\d+$//;
      $varchname .= "-$vstring";
  }
  return $varchname;
}

{
  my %escapes = (
		 "\n" => "\\n",
		 '"' => '&quot;',
		 '&' => '&amp;',
		 '>' => '&gt;',
		 '<' => '&lt;',
		);
  my $rx = join '|', keys %escapes;

  sub _simple_xml_escape {
    $_[1] =~ s/($rx)/$escapes{$1}/go;
  }
}

1;
__END__


=head1 NAME

Module::Build::PPMMaker - Perl Package Manager file creation

=head1 SYNOPSIS

  On the command line, builds a .ppd file:
  ./Build ppd


=head1 DESCRIPTION

This package contains the code that builds F<.ppd> "Perl Package
Description" files, in support of ActiveState's "Perl Package
Manager".  Details are here:
L<http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/>


=head1 AUTHOR

Dave Rolsky <autarch@urth.org>, Ken Williams <kwilliams@cpan.org>


=head1 COPYRIGHT

Copyright (c) 2001-2006 Ken Williams.  All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.


=head1 SEE ALSO

perl(1), Module::Build(3)

=cut
                                                                           usr/share/perl/5.20.2/Module/Build/Platform/                                                        0040755 0000000 0000000 00000000000 13077704254 016732  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Module/Build/Platform/Default.pm                                              0100644 0000000 0000000 00000001064 12744441327 020651  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Platform::Default;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Module::Build::Base;

use vars qw(@ISA);
@ISA = qw(Module::Build::Base);

1;
__END__


=head1 NAME

Module::Build::Platform::Default - Stub class for unknown platforms

=head1 DESCRIPTION

The sole purpose of this module is to inherit from
C<Module::Build::Base>.  Please see the L<Module::Build> for the docs.

=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>

=head1 SEE ALSO

perl(1), Module::Build(3), ExtUtils::MakeMaker(3)

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/share/perl/5.20.2/Module/Build/Platform/MacOS.pm                                                0100644 0000000 0000000 00000006775 12744441327 020245  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Platform::MacOS;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Module::Build::Base;
use vars qw(@ISA);
@ISA = qw(Module::Build::Base);

use ExtUtils::Install;

sub have_forkpipe { 0 }

sub new {
  my $class = shift;
  my $self = $class->SUPER::new(@_);

  # $Config{sitelib} and $Config{sitearch} are, unfortunately, missing.
  foreach ('sitelib', 'sitearch') {
    $self->config($_ => $self->config("install$_"))
      unless $self->config($_);
  }

  # For some reason $Config{startperl} is filled with a bunch of crap.
  (my $sp = $self->config('startperl')) =~ s/.*Exit \{Status\}\s//;
  $self->config(startperl => $sp);

  return $self;
}

sub make_executable {
  my $self = shift;
  require MacPerl;
  foreach (@_) {
    MacPerl::SetFileInfo('McPL', 'TEXT', $_);
  }
}

sub dispatch {
  my $self = shift;

  if( !@_ and !@ARGV ) {
    require MacPerl;

    # What comes first in the action list.
    my @action_list = qw(build test install);
    my %actions = map {+($_, 1)} $self->known_actions;
    delete @actions{@action_list};
    push @action_list, sort { $a cmp $b } keys %actions;

    my %toolserver = map {+$_ => 1} qw(test disttest diff testdb);
    foreach (@action_list) {
      $_ .= ' *' if $toolserver{$_};
    }

    my $cmd = MacPerl::Pick("What build command? ('*' requires ToolServer)", @action_list);
    return unless defined $cmd;
    $cmd =~ s/ \*$//;
    $ARGV[0] = ($cmd);

    my $args = MacPerl::Ask('Any extra arguments?  (ie. verbose=1)', '');
    return unless defined $args;
    push @ARGV, $self->split_like_shell($args);
  }

  $self->SUPER::dispatch(@_);
}

sub ACTION_realclean {
  my $self = shift;
  chmod 0666, $self->{properties}{build_script};
  $self->SUPER::ACTION_realclean;
}

# ExtUtils::Install has a hard-coded '.' directory in versions less
# than 1.30.  We use a sneaky trick to turn that into ':'.
#
# Note that we do it here in a cross-platform way, so this code could
# actually go in Module::Build::Base.  But we put it here to be less
# intrusive for other platforms.

sub ACTION_install {
  my $self = shift;

  return $self->SUPER::ACTION_install(@_)
    if eval {ExtUtils::Install->VERSION('1.30'); 1};

  local $^W = 0; # Avoid a 'redefine' warning
  local *ExtUtils::Install::find = sub {
    my ($code, @dirs) = @_;

    @dirs = map { $_ eq '.' ? File::Spec->curdir : $_ } @dirs;

    return File::Find::find($code, @dirs);
  };

  return $self->SUPER::ACTION_install(@_);
}

1;
__END__

=head1 NAME

Module::Build::Platform::MacOS - Builder class for MacOS platforms

=head1 DESCRIPTION

The sole purpose of this module is to inherit from
C<Module::Build::Base> and override a few methods.  Please see
L<Module::Build> for the docs.

=head2 Overridden Methods

=over 4

=item new()

MacPerl doesn't define $Config{sitelib} or $Config{sitearch} for some
reason, but $Config{installsitelib} and $Config{installsitearch} are
there.  So we copy the install variables to the other location

=item make_executable()

On MacOS we set the file type and creator to MacPerl so it will run
with a double-click.

=item dispatch()

Because there's no easy way to say "./Build test" on MacOS, if
dispatch is called with no arguments and no @ARGV a dialog box will
pop up asking what action to take and any extra arguments.

Default action is "test".

=item ACTION_realclean()

Need to unlock the Build program before deleting.

=back

=head1 AUTHOR

Michael G Schwern <schwern@pobox.com>


=head1 SEE ALSO

perl(1), Module::Build(3), ExtUtils::MakeMaker(3)

=cut
   usr/share/perl/5.20.2/Module/Build/Platform/Unix.pm                                                 0100644 0000000 0000000 00000003405 12744441327 020211  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Platform::Unix;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Module::Build::Base;

use vars qw(@ISA);
@ISA = qw(Module::Build::Base);

sub is_executable {
  # We consider the owner bit to be authoritative on a file, because
  # -x will always return true if the user is root and *any*
  # executable bit is set.  The -x test seems to try to answer the
  # question "can I execute this file", but I think we want "is this
  # file executable".

  my ($self, $file) = @_;
  return +(stat $file)[2] & 0100;
}

sub _startperl { "#! " . shift()->perl }

sub _construct {
  my $self = shift()->SUPER::_construct(@_);

  # perl 5.8.1-RC[1-3] had some broken %Config entries, and
  # unfortunately Red Hat 9 shipped it like that.  Fix 'em up here.
  my $c = $self->{config};
  for (qw(siteman1 siteman3 vendorman1 vendorman3)) {
    $c->{"install${_}dir"} ||= $c->{"install${_}"};
  }

  return $self;
}

# Open group says username should be portable filename characters,
# but some Unix OS working with ActiveDirectory wind up with user-names
# with back-slashes in the name.  The new code below is very liberal
# in what it accepts.
sub _detildefy {
  my ($self, $value) = @_;
  $value =~ s[^~([^/]+)?(?=/|$)]   # tilde with optional username
    [$1 ?
     (eval{(getpwnam $1)[7]} || "~$1") :
     ($ENV{HOME} || eval{(getpwuid $>)[7]} || glob("~"))
    ]ex;
  return $value;
}

1;
__END__


=head1 NAME

Module::Build::Platform::Unix - Builder class for Unix platforms

=head1 DESCRIPTION

The sole purpose of this module is to inherit from
C<Module::Build::Base>.  Please see the L<Module::Build> for the docs.

=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>

=head1 SEE ALSO

perl(1), Module::Build(3), ExtUtils::MakeMaker(3)

=cut
                                                                                                                                                                                                                                                           usr/share/perl/5.20.2/Module/Build/Platform/VMS.pm                                                  0100644 0000000 0000000 00000027762 12744441327 017747  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Platform::VMS;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Module::Build::Base;
use Config;

use vars qw(@ISA);
@ISA = qw(Module::Build::Base);



=head1 NAME

Module::Build::Platform::VMS - Builder class for VMS platforms

=head1 DESCRIPTION

This module inherits from C<Module::Build::Base> and alters a few
minor details of its functionality.  Please see L<Module::Build> for
the general docs.

=head2 Overridden Methods

=over 4

=item _set_defaults

Change $self->{build_script} to 'Build.com' so @Build works.

=cut

sub _set_defaults {
    my $self = shift;
    $self->SUPER::_set_defaults(@_);

    $self->{properties}{build_script} = 'Build.com';
}


=item cull_args

'@Build foo' on VMS will not preserve the case of 'foo'.  Rather than forcing
people to write '@Build "foo"' we'll dispatch case-insensitively.

=cut

sub cull_args {
    my $self = shift;
    my($action, $args) = $self->SUPER::cull_args(@_);
    my @possible_actions = grep { lc $_ eq lc $action } $self->known_actions;

    die "Ambiguous action '$action'.  Could be one of @possible_actions"
        if @possible_actions > 1;

    return ($possible_actions[0], $args);
}


=item manpage_separator

Use '__' instead of '::'.

=cut

sub manpage_separator {
    return '__';
}


=item prefixify

Prefixify taking into account VMS' filepath syntax.

=cut

# Translated from ExtUtils::MM_VMS::prefixify()

sub _catprefix {
    my($self, $rprefix, $default) = @_;

    my($rvol, $rdirs) = File::Spec->splitpath($rprefix);
    if( $rvol ) {
        return File::Spec->catpath($rvol,
                                   File::Spec->catdir($rdirs, $default),
                                   ''
                                  )
    }
    else {
        return File::Spec->catdir($rdirs, $default);
    }
}


sub _prefixify {
    my($self, $path, $sprefix, $type) = @_;
    my $rprefix = $self->prefix;

    return '' unless defined $path;

    $self->log_verbose("  prefixify $path from $sprefix to $rprefix\n");

    # Translate $(PERLPREFIX) to a real path.
    $rprefix = VMS::Filespec::vmspath($rprefix) if $rprefix;
    $sprefix = VMS::Filespec::vmspath($sprefix) if $sprefix;

    $self->log_verbose("  rprefix translated to $rprefix\n".
                       "  sprefix translated to $sprefix\n");

    if( length($path) == 0 ) {
        $self->log_verbose("  no path to prefixify.\n")
    }
    elsif( !File::Spec->file_name_is_absolute($path) ) {
        $self->log_verbose("    path is relative, not prefixifying.\n");
    }
    elsif( $sprefix eq $rprefix ) {
        $self->log_verbose("  no new prefix.\n");
    }
    else {
        my($path_vol, $path_dirs) = File::Spec->splitpath( $path );
	my $vms_prefix = $self->config('vms_prefix');
        if( $path_vol eq $vms_prefix.':' ) {
            $self->log_verbose("  $vms_prefix: seen\n");

            $path_dirs =~ s{^\[}{\[.} unless $path_dirs =~ m{^\[\.};
            $path = $self->_catprefix($rprefix, $path_dirs);
        }
        else {
            $self->log_verbose("    cannot prefixify.\n");
	    return $self->prefix_relpaths($self->installdirs, $type);
        }
    }

    $self->log_verbose("    now $path\n");

    return $path;
}

=item _quote_args

Command-line arguments (but not the command itself) must be quoted
to ensure case preservation.

=cut

sub _quote_args {
  # Returns a string that can become [part of] a command line with
  # proper quoting so that the subprocess sees this same list of args,
  # or if we get a single arg that is an array reference, quote the
  # elements of it and return the reference.
  my ($self, @args) = @_;
  my $got_arrayref = (scalar(@args) == 1
                      && UNIVERSAL::isa($args[0], 'ARRAY'))
                   ? 1
                   : 0;

  # Do not quote qualifiers that begin with '/'.
  map { if (!/^\//) {
          $_ =~ s/\"/""/g;     # escape C<"> by doubling
          $_ = q(").$_.q(");
        }
  }
    ($got_arrayref ? @{$args[0]}
                   : @args
    );

  return $got_arrayref ? $args[0]
                       : join(' ', @args);
}

=item have_forkpipe

There is no native fork(), so some constructs depending on it are not
available.

=cut

sub have_forkpipe { 0 }

=item _backticks

Override to ensure that we quote the arguments but not the command.

=cut

sub _backticks {
  # The command must not be quoted but the arguments to it must be.
  my ($self, @cmd) = @_;
  my $cmd = shift @cmd;
  my $args = $self->_quote_args(@cmd);
  return `$cmd $args`;
}

=item find_command

Local an executable program

=cut

sub find_command {
    my ($self, $command) = @_;

    # a lot of VMS executables have a symbol defined
    # check those first
    if ( $^O eq 'VMS' ) {
        require VMS::DCLsym;
        my $syms = VMS::DCLsym->new;
        return $command if scalar $syms->getsym( uc $command );
    }

    $self->SUPER::find_command($command);
}

# _maybe_command copied from ExtUtils::MM_VMS::maybe_command

=item _maybe_command (override)

Follows VMS naming conventions for executable files.
If the name passed in doesn't exactly match an executable file,
appends F<.Exe> (or equivalent) to check for executable image, and F<.Com>
to check for DCL procedure.  If this fails, checks directories in DCL$PATH
and finally F<Sys$System:> for an executable file having the name specified,
with or without the F<.Exe>-equivalent suffix.

=cut

sub _maybe_command {
    my($self,$file) = @_;
    return $file if -x $file && ! -d _;
    my(@dirs) = ('');
    my(@exts) = ('',$Config{'exe_ext'},'.exe','.com');

    if ($file !~ m![/:>\]]!) {
        for (my $i = 0; defined $ENV{"DCL\$PATH;$i"}; $i++) {
            my $dir = $ENV{"DCL\$PATH;$i"};
            $dir .= ':' unless $dir =~ m%[\]:]$%;
            push(@dirs,$dir);
        }
        push(@dirs,'Sys$System:');
        foreach my $dir (@dirs) {
            my $sysfile = "$dir$file";
            foreach my $ext (@exts) {
                return $file if -x "$sysfile$ext" && ! -d _;
            }
        }
    }
    return;
}

=item do_system

Override to ensure that we quote the arguments but not the command.

=cut

sub do_system {
  # The command must not be quoted but the arguments to it must be.
  my ($self, @cmd) = @_;
  $self->log_verbose("@cmd\n");
  my $cmd = shift @cmd;
  my $args = $self->_quote_args(@cmd);
  return !system("$cmd $args");
}

=item oneliner

Override to ensure that we do not quote the command.

=cut

sub oneliner {
    my $self = shift;
    my $oneliner = $self->SUPER::oneliner(@_);

    $oneliner =~ s/^\"\S+\"//;

    return "MCR $^X $oneliner";
}

=item rscan_dir

Inherit the standard version but remove dots at end of name.
If the extended character set is in effect, do not remove dots from filenames
with Unix path delimiters.

=cut

sub rscan_dir {
  my ($self, $dir, $pattern) = @_;

  my $result = $self->SUPER::rscan_dir( $dir, $pattern );

  for my $file (@$result) {
      if (!_efs() && ($file =~ m#/#)) {
          $file =~ s/\.$//;
      }
  }
  return $result;
}

=item dist_dir

Inherit the standard version but replace embedded dots with underscores because
a dot is the directory delimiter on VMS.

=cut

sub dist_dir {
  my $self = shift;

  my $dist_dir = $self->SUPER::dist_dir;
  $dist_dir =~ s/\./_/g unless _efs();
  return $dist_dir;
}

=item man3page_name

Inherit the standard version but chop the extra manpage delimiter off the front if
there is one.  The VMS version of splitdir('[.foo]') returns '', 'foo'.

=cut

sub man3page_name {
  my $self = shift;

  my $mpname = $self->SUPER::man3page_name( shift );
  my $sep = $self->manpage_separator;
  $mpname =~ s/^$sep//;
  return $mpname;
}

=item expand_test_dir

Inherit the standard version but relativize the paths as the native glob() doesn't
do that for us.

=cut

sub expand_test_dir {
  my ($self, $dir) = @_;

  my @reldirs = $self->SUPER::expand_test_dir( $dir );

  for my $eachdir (@reldirs) {
    my ($v,$d,$f) = File::Spec->splitpath( $eachdir );
    my $reldir = File::Spec->abs2rel( File::Spec->catpath( $v, $d, '' ) );
    $eachdir = File::Spec->catfile( $reldir, $f );
  }
  return @reldirs;
}

=item _detildefy

The home-grown glob() does not currently handle tildes, so provide limited support
here.  Expect only UNIX format file specifications for now.

=cut

sub _detildefy {
    my ($self, $arg) = @_;

    # Apparently double ~ are not translated.
    return $arg if ($arg =~ /^~~/);

    # Apparently ~ followed by whitespace are not translated.
    return $arg if ($arg =~ /^~ /);

    if ($arg =~ /^~/) {
        my $spec = $arg;

        # Remove the tilde
        $spec =~ s/^~//;

        # Remove any slash following the tilde if present.
        $spec =~ s#^/##;

        # break up the paths for the merge
        my $home = VMS::Filespec::unixify($ENV{HOME});

        # In the default VMS mode, the trailing slash is present.
        # In Unix report mode it is not.  The parsing logic assumes that
        # it is present.
        $home .= '/' unless $home =~ m#/$#;

        # Trivial case of just ~ by it self
        if ($spec eq '') {
            $home =~ s#/$##;
            return $home;
        }

        my ($hvol, $hdir, $hfile) = File::Spec::Unix->splitpath($home);
        if ($hdir eq '') {
             # Someone has tampered with $ENV{HOME}
             # So hfile is probably the directory since this should be
             # a path.
             $hdir = $hfile;
        }

        my ($vol, $dir, $file) = File::Spec::Unix->splitpath($spec);

        my @hdirs = File::Spec::Unix->splitdir($hdir);
        my @dirs = File::Spec::Unix->splitdir($dir);

        unless ($arg =~ m#^~/#) {
            # There is a home directory after the tilde, but it will already
            # be present in in @hdirs so we need to remove it by from @dirs.

            shift @dirs;
        }
        my $newdirs = File::Spec::Unix->catdir(@hdirs, @dirs);

        $arg = File::Spec::Unix->catpath($hvol, $newdirs, $file);
    }
    return $arg;

}

=item find_perl_interpreter

On VMS, $^X returns the fully qualified absolute path including version
number.  It's logically impossible to improve on it for getting the perl
we're currently running, and attempting to manipulate it is usually
lossy.

=cut

sub find_perl_interpreter {
    return VMS::Filespec::vmsify($^X);
}

=item localize_file_path

Convert the file path to the local syntax

=cut

sub localize_file_path {
  my ($self, $path) = @_;
  $path = VMS::Filespec::vmsify($path);
  $path =~ s/\.\z//;
  return $path;
}

=item localize_dir_path

Convert the directory path to the local syntax

=cut

sub localize_dir_path {
  my ($self, $path) = @_;
  return VMS::Filespec::vmspath($path);
}

=item ACTION_clean

The home-grown glob() expands a bit too aggressively when given a bare name,
so default in a zero-length extension.

=cut

sub ACTION_clean {
  my ($self) = @_;
  foreach my $item (map glob(VMS::Filespec::rmsexpand($_, '.;0')), $self->cleanup) {
    $self->delete_filetree($item);
  }
}


# Need to look up the feature settings.  The preferred way is to use the
# VMS::Feature module, but that may not be available to dual life modules.

my $use_feature;
BEGIN {
    if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
        $use_feature = 1;
    }
}

# Need to look up the UNIX report mode.  This may become a dynamic mode
# in the future.
sub _unix_rpt {
    my $unix_rpt;
    if ($use_feature) {
        $unix_rpt = VMS::Feature::current("filename_unix_report");
    } else {
        my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        $unix_rpt = $env_unix_rpt =~ /^[ET1]/i;
    }
    return $unix_rpt;
}

# Need to look up the EFS character set mode.  This may become a dynamic
# mode in the future.
sub _efs {
    my $efs;
    if ($use_feature) {
        $efs = VMS::Feature::current("efs_charset");
    } else {
        my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
        $efs = $env_efs =~ /^[ET1]/i;
    }
    return $efs;
}

=back

=head1 AUTHOR

Michael G Schwern <schwern@pobox.com>
Ken Williams <kwilliams@cpan.org>
Craig A. Berry <craigberry@mac.com>

=head1 SEE ALSO

perl(1), Module::Build(3), ExtUtils::MakeMaker(3)

=cut

1;
__END__
              usr/share/perl/5.20.2/Module/Build/Platform/VOS.pm                                                  0100644 0000000 0000000 00000001054 12744441327 017733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Platform::VOS;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Module::Build::Base;

use vars qw(@ISA);
@ISA = qw(Module::Build::Base);


1;
__END__


=head1 NAME

Module::Build::Platform::VOS - Builder class for VOS platforms

=head1 DESCRIPTION

The sole purpose of this module is to inherit from
C<Module::Build::Base>.  Please see the L<Module::Build> for the docs.

=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>

=head1 SEE ALSO

perl(1), Module::Build(3), ExtUtils::MakeMaker(3)

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/share/perl/5.20.2/Module/Build/Platform/Windows.pm                                              0100644 0000000 0000000 00000020106 12744441327 020715  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Platform::Windows;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;

use Config;
use File::Basename;
use File::Spec;

use Module::Build::Base;

use vars qw(@ISA);
@ISA = qw(Module::Build::Base);


sub manpage_separator {
    return '.';
}

sub have_forkpipe { 0 }

sub _detildefy {
  my ($self, $value) = @_;
  $value =~ s,^~(?= [/\\] | $ ),$ENV{HOME},x
    if $ENV{HOME};
  return $value;
}

sub ACTION_realclean {
  my ($self) = @_;

  $self->SUPER::ACTION_realclean();

  my $basename = basename($0);
  $basename =~ s/(?:\.bat)?$//i;

  if ( lc $basename eq lc $self->build_script ) {
    if ( $self->build_bat ) {
      $self->log_verbose("Deleting $basename.bat\n");
      my $full_progname = $0;
      $full_progname =~ s/(?:\.bat)?$/.bat/i;

      # Voodoo required to have a batch file delete itself without error;
      # Syntax differs between 9x & NT: the later requires a null arg (???)
      require Win32;
      my $null_arg = (Win32::IsWinNT()) ? '""' : '';
      my $cmd = qq(start $null_arg /min "\%comspec\%" /c del "$full_progname");

      open(my $fh, '>>', "$basename.bat")
        or die "Can't create $basename.bat: $!";
      print $fh $cmd;
      close $fh ;
    } else {
      $self->delete_filetree($self->build_script . '.bat');
    }
  }
}

sub make_executable {
  my $self = shift;

  $self->SUPER::make_executable(@_);

  foreach my $script (@_) {

    # Native batch script
    if ( $script =~ /\.(bat|cmd)$/ ) {
      $self->SUPER::make_executable($script);
      next;

    # Perl script that needs to be wrapped in a batch script
    } else {
      my %opts = ();
      if ( $script eq $self->build_script ) {
        $opts{ntargs}    = q(-x -S %0 --build_bat %*);
        $opts{otherargs} = q(-x -S "%0" --build_bat %1 %2 %3 %4 %5 %6 %7 %8 %9);
      }

      my $out = eval {$self->pl2bat(in => $script, update => 1, %opts)};
      if ( $@ ) {
        $self->log_warn("WARNING: Unable to convert file '$script' to an executable script:\n$@");
      } else {
        $self->SUPER::make_executable($out);
      }
    }
  }
}

# This routine was copied almost verbatim from the 'pl2bat' utility
# distributed with perl. It requires too much voodoo with shell quoting
# differences and shortcomings between the various flavors of Windows
# to reliably shell out
sub pl2bat {
  my $self = shift;
  my %opts = @_;

  # NOTE: %0 is already enclosed in doublequotes by cmd.exe, as appropriate
  $opts{ntargs}    = '-x -S %0 %*' unless exists $opts{ntargs};
  $opts{otherargs} = '-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9' unless exists $opts{otherargs};

  $opts{stripsuffix} = '/\\.plx?/' unless exists $opts{stripsuffix};
  $opts{stripsuffix} = ($opts{stripsuffix} =~ m{^/([^/]*[^/\$]|)\$?/?$} ? $1 : "\Q$opts{stripsuffix}\E");

  unless (exists $opts{out}) {
    $opts{out} = $opts{in};
    $opts{out} =~ s/$opts{stripsuffix}$//oi;
    $opts{out} .= '.bat' unless $opts{in} =~ /\.bat$/i or $opts{in} =~ /^-$/;
  }

  my $head = <<EOT;
    \@rem = '--*-Perl-*--
    \@echo off
    if "%OS%" == "Windows_NT" goto WinNT
    perl $opts{otherargs}
    goto endofperl
    :WinNT
    perl $opts{ntargs}
    if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
    if %errorlevel% == 9009 echo You do not have Perl in your PATH.
    if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
    goto endofperl
    \@rem ';
EOT

  $head =~ s/^\s+//gm;
  my $headlines = 2 + ($head =~ tr/\n/\n/);
  my $tail = "\n__END__\n:endofperl\n";

  my $linedone  = 0;
  my $taildone  = 0;
  my $linenum   = 0;
  my $skiplines = 0;

  my $start = $Config{startperl};
  $start = "#!perl" unless $start =~ /^#!.*perl/;

  open(my $in, '<', "$opts{in}") or die "Can't open $opts{in}: $!";
  my @file = <$in>;
  close($in);

  foreach my $line ( @file ) {
    $linenum++;
    if ( $line =~ /^:endofperl\b/ ) {
      if (!exists $opts{update}) {
        warn "$opts{in} has already been converted to a batch file!\n";
        return;
      }
      $taildone++;
    }
    if ( not $linedone and $line =~ /^#!.*perl/ ) {
      if (exists $opts{update}) {
        $skiplines = $linenum - 1;
        $line .= "#line ".(1+$headlines)."\n";
      } else {
	$line .= "#line ".($linenum+$headlines)."\n";
      }
	$linedone++;
    }
    if ( $line =~ /^#\s*line\b/ and $linenum == 2 + $skiplines ) {
      $line = "";
    }
  }

  open(my $out, '>', "$opts{out}") or die "Can't open $opts{out}: $!";
  print $out $head;
  print $out $start, ( $opts{usewarnings} ? " -w" : "" ),
             "\n#line ", ($headlines+1), "\n" unless $linedone;
  print $out @file[$skiplines..$#file];
  print $out $tail unless $taildone;
  close($out);

  return $opts{out};
}


sub _quote_args {
  # Returns a string that can become [part of] a command line with
  # proper quoting so that the subprocess sees this same list of args.
  my ($self, @args) = @_;

  my @quoted;

  for (@args) {
    if ( /^[^\s*?!\$<>;|'"\[\]\{\}]+$/ ) {
      # Looks pretty safe
      push @quoted, $_;
    } else {
      # XXX this will obviously have to improve - is there already a
      # core module lying around that does proper quoting?
      s/"/\\"/g;
      push @quoted, qq("$_");
    }
  }

  return join " ", @quoted;
}


sub split_like_shell {
  # As it turns out, Windows command-parsing is very different from
  # Unix command-parsing.  Double-quotes mean different things,
  # backslashes don't necessarily mean escapes, and so on.  So we
  # can't use Text::ParseWords::shellwords() to break a command string
  # into words.  The algorithm below was bashed out by Randy and Ken
  # (mostly Randy), and there are a lot of regression tests, so we
  # should feel free to adjust if desired.

  (my $self, local $_) = @_;

  return @$_ if defined() && UNIVERSAL::isa($_, 'ARRAY');

  my @argv;
  return @argv unless defined() && length();

  my $arg = '';
  my( $i, $quote_mode ) = ( 0, 0 );

  while ( $i < length() ) {

    my $ch      = substr( $_, $i  , 1 );
    my $next_ch = substr( $_, $i+1, 1 );

    if ( $ch eq '\\' && $next_ch eq '"' ) {
      $arg .= '"';
      $i++;
    } elsif ( $ch eq '\\' && $next_ch eq '\\' ) {
      $arg .= '\\';
      $i++;
    } elsif ( $ch eq '"' && $next_ch eq '"' && $quote_mode ) {
      $quote_mode = !$quote_mode;
      $arg .= '"';
      $i++;
    } elsif ( $ch eq '"' && $next_ch eq '"' && !$quote_mode &&
	      ( $i + 2 == length()  ||
		substr( $_, $i + 2, 1 ) eq ' ' )
	    ) { # for cases like: a"" => [ 'a' ]
      push( @argv, $arg );
      $arg = '';
      $i += 2;
    } elsif ( $ch eq '"' ) {
      $quote_mode = !$quote_mode;
    } elsif ( $ch eq ' ' && !$quote_mode ) {
      push( @argv, $arg ) if $arg;
      $arg = '';
      ++$i while substr( $_, $i + 1, 1 ) eq ' ';
    } else {
      $arg .= $ch;
    }

    $i++;
  }

  push( @argv, $arg ) if defined( $arg ) && length( $arg );
  return @argv;
}


# system(@cmd) does not like having double-quotes in it on Windows.
# So we quote them and run it as a single command.
sub do_system {
  my ($self, @cmd) = @_;

  my $cmd = $self->_quote_args(@cmd);
  my $status = system($cmd);
  if ($status and $! =~ /Argument list too long/i) {
    my $env_entries = '';
    foreach (sort keys %ENV) { $env_entries .= "$_=>".length($ENV{$_})."; " }
    warn "'Argument list' was 'too long', env lengths are $env_entries";
  }
  return !$status;
}

# Copied from ExtUtils::MM_Win32
sub _maybe_command {
    my($self,$file) = @_;
    my @e = exists($ENV{'PATHEXT'})
          ? split(/;/, $ENV{PATHEXT})
	  : qw(.com .exe .bat .cmd);
    my $e = '';
    for (@e) { $e .= "\Q$_\E|" }
    chop $e;
    # see if file ends in one of the known extensions
    if ($file =~ /($e)$/i) {
	return $file if -e $file;
    }
    else {
	for (@e) {
	    return "$file$_" if -e "$file$_";
	}
    }
    return;
}


1;

__END__

=head1 NAME

Module::Build::Platform::Windows - Builder class for Windows platforms

=head1 DESCRIPTION

The sole purpose of this module is to inherit from
C<Module::Build::Base> and override a few methods.  Please see
L<Module::Build> for the docs.

=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>

=head1 SEE ALSO

perl(1), Module::Build(3)

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/share/perl/5.20.2/Module/Build/Platform/aix.pm                                                  0100644 0000000 0000000 00000001476 12744441327 020055  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Platform::aix;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Module::Build::Platform::Unix;

use vars qw(@ISA);
@ISA = qw(Module::Build::Platform::Unix);

# This class isn't necessary anymore, but we can't delete it, because
# some people might still have the old copy in their @INC, containing
# code we don't want to execute, so we have to make sure an upgrade
# will replace it with this empty subclass.

1;
__END__


=head1 NAME

Module::Build::Platform::aix - Builder class for AIX platform

=head1 DESCRIPTION

This module provides some routines very specific to the AIX
platform.

Please see the L<Module::Build> for the general docs.

=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>

=head1 SEE ALSO

perl(1), Module::Build(3), ExtUtils::MakeMaker(3)

=cut
                                                                                                                                                                                                  usr/share/perl/5.20.2/Module/Build/Platform/cygwin.pm                                               0100644 0000000 0000000 00000002156 12744441327 020570  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Platform::cygwin;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Module::Build::Platform::Unix;

use vars qw(@ISA);
@ISA = qw(Module::Build::Platform::Unix);

sub manpage_separator {
   '.'
}

# Copied from ExtUtils::MM_Cygwin::maybe_command()
# If our path begins with F</cygdrive/> then we use the Windows version
# to determine if it may be a command.  Otherwise we use the tests
# from C<ExtUtils::MM_Unix>.

sub _maybe_command {
    my ($self, $file) = @_;

    if ($file =~ m{^/cygdrive/}i) {
        require Module::Build::Platform::Windows;
        return Module::Build::Platform::Windows->_maybe_command($file);
    }

    return $self->SUPER::_maybe_command($file);
}

1;
__END__


=head1 NAME

Module::Build::Platform::cygwin - Builder class for Cygwin platform

=head1 DESCRIPTION

This module provides some routines very specific to the cygwin
platform.

Please see the L<Module::Build> for the general docs.

=head1 AUTHOR

Initial stub by Yitzchak Scott-Thoennes <sthoenna@efn.org>

=head1 SEE ALSO

perl(1), Module::Build(3), ExtUtils::MakeMaker(3)

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                  usr/share/perl/5.20.2/Module/Build/Platform/darwin.pm                                               0100644 0000000 0000000 00000001516 12744441327 020553  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Platform::darwin;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Module::Build::Platform::Unix;

use vars qw(@ISA);
@ISA = qw(Module::Build::Platform::Unix);

# This class isn't necessary anymore, but we can't delete it, because
# some people might still have the old copy in their @INC, containing
# code we don't want to execute, so we have to make sure an upgrade
# will replace it with this empty subclass.

1;
__END__


=head1 NAME

Module::Build::Platform::darwin - Builder class for Mac OS X platform

=head1 DESCRIPTION

This module provides some routines very specific to the Mac OS X
platform.

Please see the L<Module::Build> for the general docs.

=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>

=head1 SEE ALSO

perl(1), Module::Build(3), ExtUtils::MakeMaker(3)

=cut
                                                                                                                                                                                  usr/share/perl/5.20.2/Module/Build/Platform/os2.pm                                                  0100644 0000000 0000000 00000001622 12744441327 017770  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Platform::os2;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use Module::Build::Platform::Unix;

use vars qw(@ISA);
@ISA = qw(Module::Build::Platform::Unix);

sub manpage_separator { '.' }

sub have_forkpipe { 0 }

# Copied from ExtUtils::MM_OS2::maybe_command
sub _maybe_command {
    my($self,$file) = @_;
    $file =~ s,[/\\]+,/,g;
    return $file if -x $file && ! -d _;
    return "$file.exe" if -x "$file.exe" && ! -d _;
    return "$file.cmd" if -x "$file.cmd" && ! -d _;
    return;
}

1;
__END__


=head1 NAME

Module::Build::Platform::os2 - Builder class for OS/2 platform

=head1 DESCRIPTION

This module provides some routines very specific to the OS/2
platform.

Please see the L<Module::Build> for the general docs.

=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>

=head1 SEE ALSO

perl(1), Module::Build(3), ExtUtils::MakeMaker(3)

=cut
                                                                                                              usr/share/perl/5.20.2/Module/Build/PodParser.pm                                                     0100644 0000000 0000000 00000002476 12744441327 017410  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::PodParser;

use strict;
use vars qw($VERSION);
$VERSION = '0.4205';
$VERSION = eval $VERSION;
use vars qw(@ISA);

sub new {
  # Perl is so fun.
  my $package = shift;

  my $self;
  @ISA = ();
  $self = bless {have_pod_parser => 0, @_}, $package;

  unless ($self->{fh}) {
    die "No 'file' or 'fh' parameter given" unless $self->{file};
    open($self->{fh}, '<', $self->{file}) or die "Couldn't open $self->{file}: $!";
  }

  return $self;
}

sub parse_from_filehandle {
  my ($self, $fh) = @_;

  local $_;
  while (<$fh>) {
    next unless /^=(?!cut)/ .. /^=cut/;  # in POD
    # Accept Name - abstract or C<Name> - abstract
    last if ($self->{abstract}) = /^ (?: [a-z_0-9:]+ | [BCIF] < [a-z_0-9:]+ > ) \s+ - \s+ (.*\S) /ix;
  }

  my @author;
  while (<$fh>) {
    next unless /^=head1\s+AUTHORS?/i ... /^=/;
    next if /^=/;
    push @author, $_ if /\@/;
  }
  return unless @author;
  s/^\s+|\s+$//g foreach @author;

  $self->{author} = \@author;

  return;
}

sub get_abstract {
  my $self = shift;
  return $self->{abstract} if defined $self->{abstract};

  $self->parse_from_filehandle($self->{fh});

  return $self->{abstract};
}

sub get_author {
  my $self = shift;
  return $self->{author} if defined $self->{author};

  $self->parse_from_filehandle($self->{fh});

  return $self->{author} || [];
}
                                                                                                                                                                                                  usr/share/perl/5.20.2/Module/Build/Version.pm                                                       0100644 0000000 0000000 00000000551 12744441327 017126  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::Version;
use strict;
use vars qw($VERSION);
$VERSION = '0.87'; ### XXX sync with version of version.pm below

use version 0.87;
our @ISA = qw(version);

1;

=head1 NAME

Module::Build::Version - DEPRECATED

=head1 DESCRIPTION

Module::Build now lists L<version> as a C<configure_requires> dependency
and no longer installs a copy.

=cut

                                                                                                                                                       usr/share/perl/5.20.2/Module/Build/YAML.pm                                                          0100644 0000000 0000000 00000000621 12744441327 016241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build::YAML;
use strict;
use CPAN::Meta::YAML 0.002 ();
our @ISA = qw(CPAN::Meta::YAML);
our $VERSION  = '1.41';
1;

=head1 NAME

Module::Build::YAML - DEPRECATED

=head1 DESCRIPTION

This module was originally an inline copy of L<YAML::Tiny>.  It has been
deprecated in favor of using L<CPAN::Meta::YAML> directly.  This module is kept
as a subclass wrapper for compatibility.

=cut

                                                                                                               usr/share/perl/5.20.2/Module/Build.pm                                                               0100644 0000000 0000000 00000105575 12744441327 015515  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Build;

use if $] >= 5.019, 'deprecate';

# This module doesn't do much of anything itself, it inherits from the
# modules that do the real work.  The only real thing it has to do is
# figure out which OS-specific module to pull in.  Many of the
# OS-specific modules don't do anything either - most of the work is
# done in Module::Build::Base.

use strict;
use File::Spec ();
use File::Path ();
use File::Basename ();
use Perl::OSType ();

use Module::Build::Base;

use vars qw($VERSION @ISA);
@ISA = qw(Module::Build::Base);
$VERSION = '0.4205';
$VERSION = eval $VERSION;

# Inserts the given module into the @ISA hierarchy between
# Module::Build and its immediate parent
sub _interpose_module {
  my ($self, $mod) = @_;
  eval "use $mod";
  die $@ if $@;

  no strict 'refs';
  my $top_class = $mod;
  while (@{"${top_class}::ISA"}) {
    last if ${"${top_class}::ISA"}[0] eq $ISA[0];
    $top_class = ${"${top_class}::ISA"}[0];
  }

  @{"${top_class}::ISA"} = @ISA;
  @ISA = ($mod);
}

if (grep {-e File::Spec->catfile($_, qw(Module Build Platform), $^O) . '.pm'} @INC) {
  __PACKAGE__->_interpose_module("Module::Build::Platform::$^O");

} elsif ( my $ostype = os_type() ) {
  __PACKAGE__->_interpose_module("Module::Build::Platform::$ostype");

} else {
  warn "Unknown OS type '$^O' - using default settings\n";
}

sub os_type { return Perl::OSType::os_type() }

sub is_vmsish { return Perl::OSType::is_os_type('VMS') }
sub is_windowsish { return Perl::OSType::is_os_type('Windows') }
sub is_unixish { return Perl::OSType::is_os_type('Unix') }

1;

__END__

=for :stopwords
bindoc binhtml destdir distcheck distclean distdir distmeta distsign disttest
fakeinstall html installdirs installsitebin installsitescript installvendorbin
installvendorscript libdoc libhtml pardist ppd ppmdist realclean skipcheck
testall testcover testdb testpod testpodcoverage versioninstall

=head1 NAME

Module::Build - Build and install Perl modules

=head1 SYNOPSIS

Standard process for building & installing modules:

  perl Build.PL
  ./Build
  ./Build test
  ./Build install

Or, if you're on a platform (like DOS or Windows) that doesn't require
the "./" notation, you can do this:

  perl Build.PL
  Build
  Build test
  Build install


=head1 DESCRIPTION

C<Module::Build> is a system for building, testing, and installing
Perl modules.  It is meant to be an alternative to
C<ExtUtils::MakeMaker>.  Developers may alter the behavior of the
module through subclassing in a much more straightforward way than
with C<MakeMaker>.  It also does not require a C<make> on your system
- most of the C<Module::Build> code is pure-perl and written in a very
cross-platform way.

See L<"MOTIVATIONS"> for more comparisons between C<ExtUtils::MakeMaker>
and C<Module::Build>.

To install C<Module::Build>, and any other module that uses
C<Module::Build> for its installation process, do the following:

  perl Build.PL       # 'Build.PL' script creates the 'Build' script
  ./Build             # Need ./ to ensure we're using this "Build" script
  ./Build test        # and not another one that happens to be in the PATH
  ./Build install

This illustrates initial configuration and the running of three
'actions'.  In this case the actions run are 'build' (the default
action), 'test', and 'install'.  Other actions defined so far include:

  build                          manifest
  clean                          manifest_skip
  code                           manpages
  config_data                    pardist
  diff                           ppd
  dist                           ppmdist
  distcheck                      prereq_data
  distclean                      prereq_report
  distdir                        pure_install
  distinstall                    realclean
  distmeta                       retest
  distsign                       skipcheck
  disttest                       test
  docs                           testall
  fakeinstall                    testcover
  help                           testdb
  html                           testpod
  install                        testpodcoverage
  installdeps                    versioninstall

You can run the 'help' action for a complete list of actions.


=head1 GUIDE TO DOCUMENTATION

The documentation for C<Module::Build> is broken up into sections:

=over

=item General Usage (L<Module::Build>)

This is the document you are currently reading. It describes basic
usage and background information.  Its main purpose is to assist the
user who wants to learn how to invoke and control C<Module::Build>
scripts at the command line.

=item Authoring Reference (L<Module::Build::Authoring>)

This document describes the structure and organization of
C<Module::Build>, and the relevant concepts needed by authors who are
writing F<Build.PL> scripts for a distribution or controlling
C<Module::Build> processes programmatically.

=item API Reference (L<Module::Build::API>)

This is a reference to the C<Module::Build> API.

=item Cookbook (L<Module::Build::Cookbook>)

This document demonstrates how to accomplish many common tasks.  It
covers general command line usage and authoring of F<Build.PL>
scripts.  Includes working examples.

=back


=head1 ACTIONS

There are some general principles at work here.  First, each task when
building a module is called an "action".  These actions are listed
above; they correspond to the building, testing, installing,
packaging, etc., tasks.

Second, arguments are processed in a very systematic way.  Arguments
are always key=value pairs.  They may be specified at C<perl Build.PL>
time (i.e. C<perl Build.PL destdir=/my/secret/place>), in which case
their values last for the lifetime of the C<Build> script.  They may
also be specified when executing a particular action (i.e.
C<Build test verbose=1>), in which case their values last only for the
lifetime of that command.  Per-action command line parameters take
precedence over parameters specified at C<perl Build.PL> time.

The build process also relies heavily on the C<Config.pm> module.
If the user wishes to override any of the
values in C<Config.pm>, she may specify them like so:

  perl Build.PL --config cc=gcc --config ld=gcc

The following build actions are provided by default.

=over 4

=item build

[version 0.01]

If you run the C<Build> script without any arguments, it runs the
C<build> action, which in turn runs the C<code> and C<docs> actions.

This is analogous to the C<MakeMaker> I<make all> target.

=item clean

[version 0.01]

This action will clean up any files that the build process may have
created, including the C<blib/> directory (but not including the
C<_build/> directory and the C<Build> script itself).

=item code

[version 0.20]

This action builds your code base.

By default it just creates a C<blib/> directory and copies any C<.pm>
and C<.pod> files from your C<lib/> directory into the C<blib/>
directory.  It also compiles any C<.xs> files from C<lib/> and places
them in C<blib/>.  Of course, you need a working C compiler (probably
the same one that built perl itself) for the compilation to work
properly.

The C<code> action also runs any C<.PL> files in your F<lib/>
directory.  Typically these create other files, named the same but
without the C<.PL> ending.  For example, a file F<lib/Foo/Bar.pm.PL>
could create the file F<lib/Foo/Bar.pm>.  The C<.PL> files are
processed first, so any C<.pm> files (or other kinds that we deal
with) will get copied correctly.

=item config_data

[version 0.26]

...

=item diff

[version 0.14]

This action will compare the files about to be installed with their
installed counterparts.  For .pm and .pod files, a diff will be shown
(this currently requires a 'diff' program to be in your PATH).  For
other files like compiled binary files, we simply report whether they
differ.

A C<flags> parameter may be passed to the action, which will be passed
to the 'diff' program.  Consult your 'diff' documentation for the
parameters it will accept - a good one is C<-u>:

  ./Build diff flags=-u

=item dist

[version 0.02]

This action is helpful for module authors who want to package up their
module for source distribution through a medium like CPAN.  It will create a
tarball of the files listed in F<MANIFEST> and compress the tarball using
GZIP compression.

By default, this action will use the C<Archive::Tar> module. However, you can
force it to use binary "tar" and "gzip" executables by supplying an explicit
C<tar> (and optional C<gzip>) parameter:

  ./Build dist --tar C:\path\to\tar.exe --gzip C:\path\to\zip.exe

=item distcheck

[version 0.05]

Reports which files are in the build directory but not in the
F<MANIFEST> file, and vice versa.  (See L<manifest> for details.)

=item distclean

[version 0.05]

Performs the 'realclean' action and then the 'distcheck' action.

=item distdir

[version 0.05]

Creates a "distribution directory" named C<$dist_name-$dist_version>
(if that directory already exists, it will be removed first), then
copies all the files listed in the F<MANIFEST> file to that directory.
This directory is what the distribution tarball is created from.

=item distinstall

[version 0.37]

Performs the 'distdir' action, then switches into that directory and runs a
C<perl Build.PL>, followed by the 'build' and 'install' actions in that
directory.  Use PERL_MB_OPT or F<.modulebuildrc> to set options that should be
applied during subprocesses

=item distmeta

[version 0.21]

Creates the F<META.yml> file that describes the distribution.

F<META.yml> is a file containing various bits of I<metadata> about the
distribution.  The metadata includes the distribution name, version,
abstract, prerequisites, license, and various other data about the
distribution.  This file is created as F<META.yml> in a simplified YAML format.

F<META.yml> file must also be listed in F<MANIFEST> - if it's not, a
warning will be issued.

The current version of the F<META.yml> specification can be found
on CPAN as L<CPAN::Meta::Spec>.

=item distsign

[version 0.16]

Uses C<Module::Signature> to create a SIGNATURE file for your
distribution, and adds the SIGNATURE file to the distribution's
MANIFEST.

=item disttest

[version 0.05]

Performs the 'distdir' action, then switches into that directory and runs a
C<perl Build.PL>, followed by the 'build' and 'test' actions in that directory.
Use PERL_MB_OPT or F<.modulebuildrc> to set options that should be applied
during subprocesses


=item docs

[version 0.20]

This will generate documentation (e.g. Unix man pages and HTML
documents) for any installable items under B<blib/> that
contain POD.  If there are no C<bindoc> or C<libdoc> installation
targets defined (as will be the case on systems that don't support
Unix manpages) no action is taken for manpages.  If there are no
C<binhtml> or C<libhtml> installation targets defined no action is
taken for HTML documents.

=item fakeinstall

[version 0.02]

This is just like the C<install> action, but it won't actually do
anything, it will just report what it I<would> have done if you had
actually run the C<install> action.

=item help

[version 0.03]

This action will simply print out a message that is meant to help you
use the build process.  It will show you a list of available build
actions too.

With an optional argument specifying an action name (e.g. C<Build help
test>), the 'help' action will show you any POD documentation it can
find for that action.

=item html

[version 0.26]

This will generate HTML documentation for any binary or library files
under B<blib/> that contain POD.  The HTML documentation will only be
installed if the install paths can be determined from values in
C<Config.pm>.  You can also supply or override install paths on the
command line by specifying C<install_path> values for the C<binhtml>
and/or C<libhtml> installation targets.

With an optional C<html_links> argument set to a false value, you can
skip the search for other documentation to link to, because that can
waste a lot of time if there aren't any links to generate anyway:

  ./Build html --html_links 0

=item install

[version 0.01]

This action will use C<ExtUtils::Install> to install the files from
C<blib/> into the system.  See L<"INSTALL PATHS">
for details about how Module::Build determines where to install
things, and how to influence this process.

If you want the installation process to look around in C<@INC> for
other versions of the stuff you're installing and try to delete it,
you can use the C<uninst> parameter, which tells C<ExtUtils::Install> to
do so:

  ./Build install uninst=1

This can be a good idea, as it helps prevent multiple versions of a
module from being present on your system, which can be a confusing
situation indeed.

=item installdeps

[version 0.36]

This action will use the C<cpan_client> parameter as a command to install
missing prerequisites.  You will be prompted whether to install
optional dependencies.

The C<cpan_client> option defaults to 'cpan' but can be set as an option or in
F<.modulebuildrc>.  It must be a shell command that takes a list of modules to
install as arguments (e.g. 'cpanp -i' for CPANPLUS).  If the program part is a
relative path (e.g. 'cpan' or 'cpanp'), it will be located relative to the perl
program that executed Build.PL.

  /opt/perl/5.8.9/bin/perl Build.PL
  ./Build installdeps --cpan_client 'cpanp -i'
  # installs to 5.8.9

=item manifest

[version 0.05]

This is an action intended for use by module authors, not people
installing modules.  It will bring the F<MANIFEST> up to date with the
files currently present in the distribution.  You may use a
F<MANIFEST.SKIP> file to exclude certain files or directories from
inclusion in the F<MANIFEST>.  F<MANIFEST.SKIP> should contain a bunch
of regular expressions, one per line.  If a file in the distribution
directory matches any of the regular expressions, it won't be included
in the F<MANIFEST>.

The following is a reasonable F<MANIFEST.SKIP> starting point, you can
add your own stuff to it:

  ^_build
  ^Build$
  ^blib
  ~$
  \.bak$
  ^MANIFEST\.SKIP$
  CVS

See the L<distcheck> and L<skipcheck> actions if you want to find out
what the C<manifest> action would do, without actually doing anything.

=item manifest_skip

[version 0.3608]

This is an action intended for use by module authors, not people
installing modules.  It will generate a boilerplate MANIFEST.SKIP file
if one does not already exist.

=item manpages

[version 0.28]

This will generate man pages for any binary or library files under
B<blib/> that contain POD.  The man pages will only be installed if the
install paths can be determined from values in C<Config.pm>.  You can
also supply or override install paths by specifying there values on
the command line with the C<bindoc> and C<libdoc> installation
targets.

=item pardist

[version 0.2806]

Generates a PAR binary distribution for use with L<PAR> or L<PAR::Dist>.

It requires that the PAR::Dist module (version 0.17 and up) is
installed on your system.

=item ppd

[version 0.20]

Build a PPD file for your distribution.

This action takes an optional argument C<codebase> which is used in
the generated PPD file to specify the (usually relative) URL of the
distribution.  By default, this value is the distribution name without
any path information.

Example:

  ./Build ppd --codebase "MSWin32-x86-multi-thread/Module-Build-0.21.tar.gz"

=item ppmdist

[version 0.23]

Generates a PPM binary distribution and a PPD description file.  This
action also invokes the C<ppd> action, so it can accept the same
C<codebase> argument described under that action.

This uses the same mechanism as the C<dist> action to tar & zip its
output, so you can supply C<tar> and/or C<gzip> parameters to affect
the result.

=item prereq_data

[version 0.32]

This action prints out a Perl data structure of all prerequisites and the versions
required.  The output can be loaded again using C<eval()>.  This can be useful for
external tools that wish to query a Build script for prerequisites.

=item prereq_report

[version 0.28]

This action prints out a list of all prerequisites, the versions required, and
the versions actually installed.  This can be useful for reviewing the
configuration of your system prior to a build, or when compiling data to send
for a bug report.

=item pure_install

[version 0.28]

This action is identical to the C<install> action.  In the future,
though, when C<install> starts writing to the file
F<$(INSTALLARCHLIB)/perllocal.pod>, C<pure_install> won't, and that
will be the only difference between them.

=item realclean

[version 0.01]

This action is just like the C<clean> action, but also removes the
C<_build> directory and the C<Build> script.  If you run the
C<realclean> action, you are essentially starting over, so you will
have to re-create the C<Build> script again.

=item retest

[version 0.2806]

This is just like the C<test> action, but doesn't actually build the
distribution first, and doesn't add F<blib/> to the load path, and
therefore will test against a I<previously> installed version of the
distribution.  This can be used to verify that a certain installed
distribution still works, or to see whether newer versions of a
distribution still pass the old regression tests, and so on.

=item skipcheck

[version 0.05]

Reports which files are skipped due to the entries in the
F<MANIFEST.SKIP> file (See L<manifest> for details)

=item test

[version 0.01]

This will use C<Test::Harness> or C<TAP::Harness> to run any regression
tests and report their results. Tests can be defined in the standard
places: a file called C<test.pl> in the top-level directory, or several
files ending with C<.t> in a C<t/> directory.

If you want tests to be 'verbose', i.e. show details of test execution
rather than just summary information, pass the argument C<verbose=1>.

If you want to run tests under the perl debugger, pass the argument
C<debugger=1>.

If you want to have Module::Build find test files with different file
name extensions, pass the C<test_file_exts> argument with an array
of extensions, such as C<[qw( .t .s .z )]>.

If you want test to be run by C<TAP::Harness>, rather than C<Test::Harness>,
pass the argument C<tap_harness_args> as an array reference of arguments to
pass to the TAP::Harness constructor.

In addition, if a file called C<visual.pl> exists in the top-level
directory, this file will be executed as a Perl script and its output
will be shown to the user.  This is a good place to put speed tests or
other tests that don't use the C<Test::Harness> format for output.

To override the choice of tests to run, you may pass a C<test_files>
argument whose value is a whitespace-separated list of test scripts to
run.  This is especially useful in development, when you only want to
run a single test to see whether you've squashed a certain bug yet:

  ./Build test --test_files t/something_failing.t

You may also pass several C<test_files> arguments separately:

  ./Build test --test_files t/one.t --test_files t/two.t

or use a C<glob()>-style pattern:

  ./Build test --test_files 't/01-*.t'

=item testall

[version 0.2807]

[Note: the 'testall' action and the code snippets below are currently
in alpha stage, see
L<"http://www.nntp.perl.org/group/perl.module.build/2007/03/msg584.html"> ]

Runs the C<test> action plus each of the C<test$type> actions defined by
the keys of the C<test_types> parameter.

Currently, you need to define the ACTION_test$type method yourself and
enumerate them in the test_types parameter.

  my $mb = Module::Build->subclass(
    code => q(
      sub ACTION_testspecial { shift->generic_test(type => 'special'); }
      sub ACTION_testauthor  { shift->generic_test(type => 'author'); }
    )
  )->new(
    ...
    test_types  => {
      special => '.st',
      author  => ['.at', '.pt' ],
    },
    ...

=item testcover

[version 0.26]

Runs the C<test> action using C<Devel::Cover>, generating a
code-coverage report showing which parts of the code were actually
exercised during the tests.

To pass options to C<Devel::Cover>, set the C<$DEVEL_COVER_OPTIONS>
environment variable:

  DEVEL_COVER_OPTIONS=-ignore,Build ./Build testcover

=item testdb

[version 0.05]

This is a synonym for the 'test' action with the C<debugger=1>
argument.

=item testpod

[version 0.25]

This checks all the files described in the C<docs> action and
produces C<Test::Harness>-style output.  If you are a module author,
this is useful to run before creating a new release.

=item testpodcoverage

[version 0.28]

This checks the pod coverage of the distribution and
produces C<Test::Harness>-style output. If you are a module author,
this is useful to run before creating a new release.

=item versioninstall

[version 0.16]

** Note: since C<only.pm> is so new, and since we just recently added
support for it here too, this feature is to be considered
experimental. **

If you have the C<only.pm> module installed on your system, you can
use this action to install a module into the version-specific library
trees.  This means that you can have several versions of the same
module installed and C<use> a specific one like this:

  use only MyModule => 0.55;

To override the default installation libraries in C<only::config>,
specify the C<versionlib> parameter when you run the C<Build.PL> script:

  perl Build.PL --versionlib /my/version/place/

To override which version the module is installed as, specify the
C<version> parameter when you run the C<Build.PL> script:

  perl Build.PL --version 0.50

See the C<only.pm> documentation for more information on
version-specific installs.

=back


=head1 OPTIONS

=head2 Command Line Options

The following options can be used during any invocation of C<Build.PL>
or the Build script, during any action.  For information on other
options specific to an action, see the documentation for the
respective action.

NOTE: There is some preliminary support for options to use the more
familiar long option style.  Most options can be preceded with the
C<--> long option prefix, and the underscores changed to dashes
(e.g. C<--use-rcfile>).  Additionally, the argument to boolean options is
optional, and boolean options can be negated by prefixing them with
C<no> or C<no-> (e.g. C<--noverbose> or C<--no-verbose>).

=over 4

=item quiet

Suppress informative messages on output.

=item verbose

Display extra information about the Build on output.  C<verbose> will
turn off C<quiet>

=item cpan_client

Sets the C<cpan_client> command for use with the C<installdeps> action.
See C<installdeps> for more details.

=item use_rcfile

Load the F<~/.modulebuildrc> option file.  This option can be set to
false to prevent the custom resource file from being loaded.

=item allow_mb_mismatch

Suppresses the check upon startup that the version of Module::Build
we're now running under is the same version that was initially invoked
when building the distribution (i.e. when the C<Build.PL> script was
first run).  As of 0.3601, a mismatch results in a warning instead of
a fatal error, so this option effectively just suppresses the warning.

=item debug

Prints Module::Build debugging information to STDOUT, such as a trace of
executed build actions.

=back

=head2 Default Options File (F<.modulebuildrc>)

[version 0.28]

When Module::Build starts up, it will look first for a file,
F<$ENV{HOME}/.modulebuildrc>.  If it's not found there, it will look
in the F<.modulebuildrc> file in the directories referred to by
the environment variables C<HOMEDRIVE> + C<HOMEDIR>, C<USERPROFILE>,
C<APPDATA>, C<WINDIR>, C<SYS$LOGIN>.  If the file exists, the options
specified there will be used as defaults, as if they were typed on the
command line.  The defaults can be overridden by specifying new values
on the command line.

The action name must come at the beginning of the line, followed by any
amount of whitespace and then the options.  Options are given the same
as they would be on the command line.  They can be separated by any
amount of whitespace, including newlines, as long there is whitespace at
the beginning of each continued line.  Anything following a hash mark (C<#>)
is considered a comment, and is stripped before parsing.  If more than
one line begins with the same action name, those lines are merged into
one set of options.

Besides the regular actions, there are two special pseudo-actions: the
key C<*> (asterisk) denotes any global options that should be applied
to all actions, and the key 'Build_PL' specifies options to be applied
when you invoke C<perl Build.PL>.

  *           verbose=1   # global options
  diff        flags=-u
  install     --install_base /home/ken
              --install_path html=/home/ken/docs/html
  installdeps --cpan_client 'cpanp -i'

If you wish to locate your resource file in a different location, you
can set the environment variable C<MODULEBUILDRC> to the complete
absolute path of the file containing your options.

=head2 Environment variables

=over

=item MODULEBUILDRC

[version 0.28]

Specifies an alternate location for a default options file as described above.

=item PERL_MB_OPT

[version 0.36]

Command line options that are applied to Build.PL or any Build action.  The
string is split as the shell would (e.g. whitespace) and the result is
prepended to any actual command-line arguments.

=back

=head1 INSTALL PATHS

[version 0.19]

When you invoke Module::Build's C<build> action, it needs to figure
out where to install things.  The nutshell version of how this works
is that default installation locations are determined from
F<Config.pm>, and they may be overridden by using the C<install_path>
parameter.  An C<install_base> parameter lets you specify an
alternative installation root like F</home/foo>, and a C<destdir> lets
you specify a temporary installation directory like F</tmp/install> in
case you want to create bundled-up installable packages.

Natively, Module::Build provides default installation locations for
the following types of installable items:

=over 4

=item lib

Usually pure-Perl module files ending in F<.pm>.

=item arch

"Architecture-dependent" module files, usually produced by compiling
XS, L<Inline>, or similar code.

=item script

Programs written in pure Perl.  In order to improve reuse, try to make
these as small as possible - put the code into modules whenever
possible.

=item bin

"Architecture-dependent" executable programs, i.e. compiled C code or
something.  Pretty rare to see this in a perl distribution, but it
happens.

=item bindoc

Documentation for the stuff in C<script> and C<bin>.  Usually
generated from the POD in those files.  Under Unix, these are manual
pages belonging to the 'man1' category.

=item libdoc

Documentation for the stuff in C<lib> and C<arch>.  This is usually
generated from the POD in F<.pm> files.  Under Unix, these are manual
pages belonging to the 'man3' category.

=item binhtml

This is the same as C<bindoc> above, but applies to HTML documents.

=item libhtml

This is the same as C<libdoc> above, but applies to HTML documents.

=back

Four other parameters let you control various aspects of how
installation paths are determined:

=over 4

=item installdirs

The default destinations for these installable things come from
entries in your system's C<Config.pm>.  You can select from three
different sets of default locations by setting the C<installdirs>
parameter as follows:

                          'installdirs' set to:
                   core          site                vendor

              uses the following defaults from Config.pm:

  lib     => installprivlib  installsitelib      installvendorlib
  arch    => installarchlib  installsitearch     installvendorarch
  script  => installscript   installsitescript   installvendorscript
  bin     => installbin      installsitebin      installvendorbin
  bindoc  => installman1dir  installsiteman1dir  installvendorman1dir
  libdoc  => installman3dir  installsiteman3dir  installvendorman3dir
  binhtml => installhtml1dir installsitehtml1dir installvendorhtml1dir [*]
  libhtml => installhtml3dir installsitehtml3dir installvendorhtml3dir [*]

  * Under some OS (eg. MSWin32) the destination for HTML documents is
    determined by the C<Config.pm> entry C<installhtmldir>.

The default value of C<installdirs> is "site".  If you're creating
vendor distributions of module packages, you may want to do something
like this:

  perl Build.PL --installdirs vendor

or

  ./Build install --installdirs vendor

If you're installing an updated version of a module that was included
with perl itself (i.e. a "core module"), then you may set
C<installdirs> to "core" to overwrite the module in its present
location.

(Note that the 'script' line is different from C<MakeMaker> -
unfortunately there's no such thing as "installsitescript" or
"installvendorscript" entry in C<Config.pm>, so we use the
"installsitebin" and "installvendorbin" entries to at least get the
general location right.  In the future, if C<Config.pm> adds some more
appropriate entries, we'll start using those.)

=item install_path

Once the defaults have been set, you can override them.

On the command line, that would look like this:

  perl Build.PL --install_path lib=/foo/lib --install_path arch=/foo/lib/arch

or this:

  ./Build install --install_path lib=/foo/lib --install_path arch=/foo/lib/arch

=item install_base

You can also set the whole bunch of installation paths by supplying the
C<install_base> parameter to point to a directory on your system.  For
instance, if you set C<install_base> to "/home/ken" on a Linux
system, you'll install as follows:

  lib     => /home/ken/lib/perl5
  arch    => /home/ken/lib/perl5/i386-linux
  script  => /home/ken/bin
  bin     => /home/ken/bin
  bindoc  => /home/ken/man/man1
  libdoc  => /home/ken/man/man3
  binhtml => /home/ken/html
  libhtml => /home/ken/html

Note that this is I<different> from how C<MakeMaker>'s C<PREFIX>
parameter works.  C<install_base> just gives you a default layout under the
directory you specify, which may have little to do with the
C<installdirs=site> layout.

The exact layout under the directory you specify may vary by system -
we try to do the "sensible" thing on each platform.

=item destdir

If you want to install everything into a temporary directory first
(for instance, if you want to create a directory tree that a package
manager like C<rpm> or C<dpkg> could create a package from), you can
use the C<destdir> parameter:

  perl Build.PL --destdir /tmp/foo

or

  ./Build install --destdir /tmp/foo

This will effectively install to "/tmp/foo/$sitelib",
"/tmp/foo/$sitearch", and the like, except that it will use
C<File::Spec> to make the pathnames work correctly on whatever
platform you're installing on.

=item prefix

Provided for compatibility with C<ExtUtils::MakeMaker>'s PREFIX argument.
C<prefix> should be used when you want Module::Build to install your
modules, documentation, and scripts in the same place as
C<ExtUtils::MakeMaker>'s PREFIX mechanism.

The following are equivalent.

    perl Build.PL --prefix /tmp/foo
    perl Makefile.PL PREFIX=/tmp/foo

Because of the complex nature of the prefixification logic, the
behavior of PREFIX in C<MakeMaker> has changed subtly over time.
Module::Build's --prefix logic is equivalent to the PREFIX logic found
in C<ExtUtils::MakeMaker> 6.30.

The maintainers of C<MakeMaker> do understand the troubles with the
PREFIX mechanism, and added INSTALL_BASE support in version 6.31 of
C<MakeMaker>, which was released in 2006.

If you don't need to retain compatibility with old versions (pre-6.31) of C<ExtUtils::MakeMaker> or
are starting a fresh Perl installation we recommend you use
C<install_base> instead (and C<INSTALL_BASE> in C<ExtUtils::MakeMaker>).
See L<Module::Build::Cookbook/Installing in the same location as
ExtUtils::MakeMaker> for further information.


=back


=head1 MOTIVATIONS

There are several reasons I wanted to start over, and not just fix
what I didn't like about C<MakeMaker>:

=over 4

=item *

I don't like the core idea of C<MakeMaker>, namely that C<make> should be
involved in the build process.  Here are my reasons:

=over 4

=item +

When a person is installing a Perl module, what can you assume about
their environment?  Can you assume they have C<make>?  No, but you can
assume they have some version of Perl.

=item +

When a person is writing a Perl module for intended distribution, can
you assume that they know how to build a Makefile, so they can
customize their build process?  No, but you can assume they know Perl,
and could customize that way.

=back

For years, these things have been a barrier to people getting the
build/install process to do what they want.

=item *

There are several architectural decisions in C<MakeMaker> that make it
very difficult to customize its behavior.  For instance, when using
C<MakeMaker> you do C<use ExtUtils::MakeMaker>, but the object created in
C<WriteMakefile()> is actually blessed into a package name that's
created on the fly, so you can't simply subclass
C<ExtUtils::MakeMaker>.  There is a workaround C<MY> package that lets
you override certain C<MakeMaker> methods, but only certain explicitly
preselected (by C<MakeMaker>) methods can be overridden.  Also, the method
of customization is very crude: you have to modify a string containing
the Makefile text for the particular target.  Since these strings
aren't documented, and I<can't> be documented (they take on different
values depending on the platform, version of perl, version of
C<MakeMaker>, etc.), you have no guarantee that your modifications will
work on someone else's machine or after an upgrade of C<MakeMaker> or
perl.

=item *

It is risky to make major changes to C<MakeMaker>, since it does so many
things, is so important, and generally works.  C<Module::Build> is an
entirely separate package so that I can work on it all I want, without
worrying about backward compatibility with C<MakeMaker>.

=item *

Finally, Perl is said to be a language for system administration.
Could it really be the case that Perl isn't up to the task of building
and installing software?  Even if that software is a bunch of
C<.pm> files that just need to be copied from one place to
another?  My sense was that we could design a system to accomplish
this in a flexible, extensible, and friendly manner.  Or die trying.

=back


=head1 TO DO

The current method of relying on time stamps to determine whether a
derived file is out of date isn't likely to scale well, since it
requires tracing all dependencies backward, it runs into problems on
NFS, and it's just generally flimsy.  It would be better to use an MD5
signature or the like, if available.  See C<cons> for an example.

 - append to perllocal.pod
 - add a 'plugin' functionality


=head1 AUTHOR

Ken Williams <kwilliams@cpan.org>

Development questions, bug reports, and patches should be sent to the
Module-Build mailing list at <module-build@perl.org>.

Bug reports are also welcome at
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Module-Build>.

The latest development version is available from the Git
repository at <https://github.com/Perl-Toolchain-Gang/Module-Build>


=head1 COPYRIGHT

Copyright (c) 2001-2006 Ken Williams.  All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.


=head1 SEE ALSO

perl(1), L<Module::Build::Cookbook>, L<Module::Build::Authoring>,
L<Module::Build::API>, L<ExtUtils::MakeMaker>

F<META.yml> Specification:
L<CPAN::Meta::Spec>

L<http://www.dsmit.com/cons/>

L<http://search.cpan.org/dist/PerlBuildSystem/>

=cut
                                                                                                                                   usr/share/perl/5.20.2/Module/CoreList/                                                              0040755 0000000 0000000 00000000000 13077704254 015633  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Module/CoreList/TieHashDelta.pm                                               0100644 0000000 0000000 00000003277 12744441327 020475  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # For internal Module::CoreList use only.
package Module::CoreList::TieHashDelta;
use strict;
use vars qw($VERSION);

$VERSION = '5.20150214';

sub TIEHASH {
    my ($class, $changed, $removed, $parent) = @_;

    return bless {
        changed => $changed,
        removed => $removed,
        parent => $parent,
        keys_inflated => 0,
    }, $class;
}

sub FETCH {
    my ($self, $key) = @_;

    if (exists $self->{changed}{$key}) {
        return $self->{changed}{$key};
    } elsif (exists $self->{removed}{$key}) {
        return undef;
    } elsif (defined $self->{parent}) {
        return $self->{parent}{$key};
    }
    return undef;
}

sub EXISTS {
    my ($self, $key) = @_;

    restart:
    if (exists $self->{changed}{$key}) {
        return 1;
    } elsif (exists $self->{removed}{$key}) {
        return '';
    } elsif (defined $self->{parent}) {
        $self = tied %{$self->{parent}}; #avoid extreme magic/tie recursion
        goto restart;
    }
    return '';
}

sub FIRSTKEY {
    my ($self) = @_;

    if (not $self->{keys_inflated}) {
        # This inflates the whole set of hashes... Somewhat expensive, but saves
        # many tied hash calls later.
        my @parent_keys;
        if (defined $self->{parent}) {
            @parent_keys = keys %{$self->{parent}};
        }

        @parent_keys = grep !exists $self->{removed}{$_}, @parent_keys;
        for my $key (@parent_keys) {
            next if exists $self->{changed}->{$key};
            $self->{changed}{$key} = $self->{parent}{$key};
        }

        $self->{keys_inflated} = 1;
    }

    keys %{$self->{changed}}; # reset each
    $self->NEXTKEY;
}

sub NEXTKEY {
    my ($self) = @_;
    each %{$self->{changed}};
}

1;
                                                                                                                                                                                                                                                                                                                                 usr/share/perl/5.20.2/Module/CoreList/Utils.pm                                                      0100644 0000000 0000000 00000053061 12744441327 017272  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::CoreList::Utils;

use strict;
use warnings;
use vars qw[$VERSION %utilities];
use Module::CoreList;
use Module::CoreList::TieHashDelta;

$VERSION = '5.20150214';

sub utilities {
    my $perl = shift;
    $perl = shift if eval { $perl->isa(__PACKAGE__) };
    return unless $perl or exists $utilities{$perl};
    return sort keys %{ $utilities{$perl} };
}

sub first_release_raw {
    my $util = shift;
    $util = shift if eval { $util->isa(__PACKAGE__) };
      #and scalar @_ and $_[0] =~ m#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#;
    my $version = shift;

    my @perls = $version
        ? grep { exists $utilities{$_}{ $util } &&
                        $utilities{$_}{ $util } ge $version } keys %utilities
        : grep { exists $utilities{$_}{ $util }             } keys %utilities;

    return grep { exists $Module::CoreList::released{$_} } @perls;
}

sub first_release_by_date {
    my @perls = &first_release_raw;
    return unless @perls;
    return (sort { $Module::CoreList::released{$a} cmp $Module::CoreList::released{$b} } @perls)[0];
}

sub first_release {
    my @perls = &first_release_raw;
    return unless @perls;
    return (sort { $a cmp $b } @perls)[0];
}

sub removed_from {
  my @perls = &removed_raw;
  return shift @perls;
}

sub removed_from_by_date {
  my @perls = sort { $Module::CoreList::released{$a} cmp $Module::CoreList::released{$b} } &removed_raw;
  return shift @perls;
}

sub removed_raw {
  my $util = shift;
  $util = shift if eval { $util->isa(__PACKAGE__) };
  return unless my @perls = sort { $a cmp $b } first_release_raw($util);
  @perls = grep { exists $Module::CoreList::released{$_} } @perls;
  my $last = pop @perls;
  my @removed = grep { $_ > $last } sort { $a cmp $b } keys %utilities;
  return @removed;
}

my %delta = (
    5 => {
        changed => {
            'a2p'                   => '1',
            'c2ph'                  => '1',
            'cppstdin'              => '1',
            'find2perl'             => '1',
            'pstruct'               => '1',
            's2p'                   => '1',
        },
        removed => {
        }
    },

    5.001 => {
        delta_from => 5,
        changed => {
            'h2xs'                  => '1',
        },
        removed => {
        }
    },

    5.002 => {
        delta_from => 5.001,
        changed => {
            'h2ph'                  => '1',
            'perlbug'               => '1',
            'perldoc'               => '1',
            'pod2html'              => '1',
            'pod2latex'             => '1',
            'pod2man'               => '1',
            'pod2text'              => '1',
        },
        removed => {
        }
    },

    5.00307 => {
        delta_from => 5.002,
        changed => {
            'pl2pm'                 => '1',
        },
        removed => {
           'cppstdin'              => 1,
           'pstruct'               => 1,
        }
    },

    5.004 => {
        delta_from => 5.00307,
        changed => {
            'splain'                => '1',
        },
        removed => {
        }
    },

    5.005 => {
        delta_from => 5.00405,
        changed => {
            'perlcc'                => '1',
        },
        removed => {
        }
    },

    5.00503 => {
        delta_from => 5.005,
        changed => {
        },
        removed => {
        }
    },

    5.00405 => {
        delta_from => 5.004,
        changed => {
        },
        removed => {
        }
    },

    5.006 => {
        delta_from => 5.00504,
        changed => {
            'dprofpp'               => '1',
            'pod2usage'             => '1',
            'podchecker'            => '1',
            'podselect'             => '1',
            'pstruct'               => '1',
        },
        removed => {
        }
    },

    5.006001 => {
        delta_from => 5.006,
        changed => {
        },
        removed => {
        }
    },

    5.007003 => {
        delta_from => 5.006002,
        changed => {
            'libnetcfg'             => '1',
            'perlivp'               => '1',
            'psed'                  => '1',
            'xsubpp'                => '1',
        },
        removed => {
        }
    },

    5.008 => {
        delta_from => 5.007003,
        changed => {
            'enc2xs'                => '1',
            'piconv'                => '1',
        },
        removed => {
        }
    },

    5.008001 => {
        delta_from => 5.008,
        changed => {
            'cpan'                  => '1',
        },
        removed => {
        }
    },

    5.009 => {
        delta_from => 5.008009,
        changed => {
        },
        removed => {
           'corelist'              => 1,
           'instmodsh'             => 1,
           'prove'                 => 1,
        }
    },

    5.008002 => {
        delta_from => 5.008001,
        changed => {
        },
        removed => {
        }
    },

    5.006002 => {
        delta_from => 5.006001,
        changed => {
        },
        removed => {
        }
    },

    5.008003 => {
        delta_from => 5.008002,
        changed => {
            'instmodsh'             => '1',
            'prove'                 => '1',
        },
        removed => {
        }
    },

    5.00504 => {
        delta_from => 5.00503,
        changed => {
        },
        removed => {
        }
    },

    5.009001 => {
        delta_from => 5.009,
        changed => {
            'instmodsh'             => '1',
            'prove'                 => '1',
        },
        removed => {
        }
    },

    5.008004 => {
        delta_from => 5.008003,
        changed => {
        },
        removed => {
        }
    },

    5.008005 => {
        delta_from => 5.008004,
        changed => {
        },
        removed => {
        }
    },

    5.008006 => {
        delta_from => 5.008005,
        changed => {
        },
        removed => {
        }
    },

    5.009002 => {
        delta_from => 5.009001,
        changed => {
            'corelist'              => '1',
        },
        removed => {
        }
    },

    5.008007 => {
        delta_from => 5.008006,
        changed => {
        },
        removed => {
        }
    },

    5.009003 => {
        delta_from => 5.009002,
        changed => {
            'ptar'                  => '1',
            'ptardiff'              => '1',
            'shasum'                => '1',
        },
        removed => {
        }
    },

    5.008008 => {
        delta_from => 5.008007,
        changed => {
        },
        removed => {
        }
    },

    5.009004 => {
        delta_from => 5.009003,
        changed => {
            'config_data'           => '1',
        },
        removed => {
        }
    },

    5.009005 => {
        delta_from => 5.009004,
        changed => {
            'cpan2dist'             => '1',
            'cpanp'                 => '1',
            'cpanp-run-perl'        => '1',
        },
        removed => {
           'perlcc'                => 1,
        }
    },

    5.010000 => {
        delta_from => 5.009005,
        changed => {
        },
        removed => {
        }
    },

    5.008009 => {
        delta_from => 5.008008,
        changed => {
            'corelist'              => '1',
        },
        removed => {
        }
    },

    5.010001 => {
        delta_from => 5.010000,
        changed => {
        },
        removed => {
        }
    },

    5.011 => {
        delta_from => 5.010001,
        changed => {
        },
        removed => {
        }
    },

    5.011001 => {
        delta_from => 5.011,
        changed => {
        },
        removed => {
        }
    },

    5.011002 => {
        delta_from => 5.011001,
        changed => {
            'perlthanks'            => '1',
        },
        removed => {
        }
    },

    5.011003 => {
        delta_from => 5.011002,
        changed => {
        },
        removed => {
        }
    },

    5.011004 => {
        delta_from => 5.011003,
        changed => {
        },
        removed => {
        }
    },

    5.011005 => {
        delta_from => 5.011004,
        changed => {
        },
        removed => {
        }
    },

    5.012 => {
        delta_from => 5.011005,
        changed => {
        },
        removed => {
        }
    },

    5.013 => {
        delta_from => 5.012005,
        changed => {
        },
        removed => {
        }
    },

    5.012001 => {
        delta_from => 5.012,
        changed => {
        },
        removed => {
        }
    },

    5.013001 => {
        delta_from => 5.013,
        changed => {
        },
        removed => {
        }
    },

    5.013002 => {
        delta_from => 5.013001,
        changed => {
        },
        removed => {
        }
    },

    5.013003 => {
        delta_from => 5.013002,
        changed => {
        },
        removed => {
        }
    },

    5.013004 => {
        delta_from => 5.013003,
        changed => {
        },
        removed => {
        }
    },

    5.012002 => {
        delta_from => 5.012001,
        changed => {
        },
        removed => {
        }
    },

    5.013005 => {
        delta_from => 5.013004,
        changed => {
        },
        removed => {
        }
    },

    5.013006 => {
        delta_from => 5.013005,
        changed => {
        },
        removed => {
        }
    },

    5.013007 => {
        delta_from => 5.013006,
        changed => {
            'ptargrep'              => '1',
        },
        removed => {
        }
    },

    5.013008 => {
        delta_from => 5.013007,
        changed => {
        },
        removed => {
        }
    },

    5.013009 => {
        delta_from => 5.013008,
        changed => {
            'json_pp'               => '1',
        },
        removed => {
        }
    },

    5.012003 => {
        delta_from => 5.012002,
        changed => {
        },
        removed => {
        }
    },

    5.013010 => {
        delta_from => 5.013009,
        changed => {
        },
        removed => {
        }
    },

    5.013011 => {
        delta_from => 5.013010,
        changed => {
        },
        removed => {
        }
    },

    5.014 => {
        delta_from => 5.013011,
        changed => {
        },
        removed => {
        }
    },

    5.014001 => {
        delta_from => 5.014,
        changed => {
        },
        removed => {
        }
    },

    5.015 => {
        delta_from => 5.014004,
        changed => {
        },
        removed => {
           'dprofpp'               => 1,
        }
    },

    5.012004 => {
        delta_from => 5.012003,
        changed => {
        },
        removed => {
        }
    },

    5.015001 => {
        delta_from => 5.015,
        changed => {
        },
        removed => {
        }
    },

    5.015002 => {
        delta_from => 5.015001,
        changed => {
        },
        removed => {
        }
    },

    5.015003 => {
        delta_from => 5.015002,
        changed => {
        },
        removed => {
        }
    },

    5.014002 => {
        delta_from => 5.014001,
        changed => {
        },
        removed => {
        }
    },

    5.015004 => {
        delta_from => 5.015003,
        changed => {
        },
        removed => {
        }
    },

    5.015005 => {
        delta_from => 5.015004,
        changed => {
        },
        removed => {
        }
    },

    5.015006 => {
        delta_from => 5.015005,
        changed => {
            'zipdetails'            => '1',
        },
        removed => {
        }
    },

    5.015007 => {
        delta_from => 5.015006,
        changed => {
        },
        removed => {
        }
    },

    5.015008 => {
        delta_from => 5.015007,
        changed => {
        },
        removed => {
        }
    },

    5.015009 => {
        delta_from => 5.015008,
        changed => {
        },
        removed => {
        }
    },

    5.016 => {
        delta_from => 5.015009,
        changed => {
        },
        removed => {
        }
    },

    5.017 => {
        delta_from => 5.016003,
        changed => {
        },
        removed => {
        }
    },

    5.017001 => {
        delta_from => 5.017,
        changed => {
        },
        removed => {
        }
    },

    5.017002 => {
        delta_from => 5.017001,
        changed => {
        },
        removed => {
        }
    },

    5.016001 => {
        delta_from => 5.016,
        changed => {
        },
        removed => {
        }
    },

    5.017003 => {
        delta_from => 5.017002,
        changed => {
        },
        removed => {
        }
    },

    5.017004 => {
        delta_from => 5.017003,
        changed => {
        },
        removed => {
        }
    },

    5.014003 => {
        delta_from => 5.014002,
        changed => {
        },
        removed => {
        }
    },

    5.017005 => {
        delta_from => 5.017004,
        changed => {
        },
        removed => {
        }
    },

    5.016002 => {
        delta_from => 5.016001,
        changed => {
        },
        removed => {
        }
    },

    5.012005 => {
        delta_from => 5.012004,
        changed => {
        },
        removed => {
        }
    },

    5.017006 => {
        delta_from => 5.017005,
        changed => {
        },
        removed => {
        }
    },

    5.017007 => {
        delta_from => 5.017006,
        changed => {
        },
        removed => {
        }
    },

    5.017008 => {
        delta_from => 5.017007,
        changed => {
        },
        removed => {
        }
    },

    5.017009 => {
        delta_from => 5.017008,
        changed => {
        },
        removed => {
        }
    },

    5.014004 => {
        delta_from => 5.014003,
        changed => {
        },
        removed => {
        }
    },

    5.016003 => {
        delta_from => 5.016002,
        changed => {
        },
        removed => {
        }
    },

    5.017010 => {
        delta_from => 5.017009,
        changed => {
        },
        removed => {
        }
    },

    5.017011 => {
        delta_from => 5.017010,
        changed => {
        },
        removed => {
        }
    },
    5.018000 => {
        delta_from => 5.017011,
        changed => {
        },
        removed => {
        }
    },
    5.018001 => {
        delta_from => 5.018000,
        changed => {
        },
        removed => {
        }
    },
    5.018002 => {
        delta_from => 5.018001,
        changed => {
        },
        removed => {
        }
    },
    5.018003 => {
        delta_from => 5.018000,
        changed => {
        },
        removed => {
        }
    },
    5.018004 => {
        delta_from => 5.018000,
        changed => {
        },
        removed => {
        }
    },
    5.019000 => {
        delta_from => 5.018000,
        changed => {
        },
        removed => {
            'cpan2dist'             => '1',
            'cpanp'                 => '1',
            'cpanp-run-perl'        => '1',
            'pod2latex'             => '1',
        }
    },
    5.019001 => {
        delta_from => 5.019000,
        changed => {
        },
        removed => {
        }
    },
    5.019002 => {
        delta_from => 5.019001,
        changed => {
        },
        removed => {
        }
    },
    5.019003 => {
        delta_from => 5.019002,
        changed => {
        },
        removed => {
        }
    },
    5.019004 => {
        delta_from => 5.019003,
        changed => {
        },
        removed => {
        }
    },
    5.019005 => {
        delta_from => 5.019004,
        changed => {
        },
        removed => {
        }
    },
    5.019006 => {
        delta_from => 5.019005,
        changed => {
        },
        removed => {
        }
    },
    5.019007 => {
        delta_from => 5.019006,
        changed => {
        },
        removed => {
        }
    },
    5.019008 => {
        delta_from => 5.019007,
        changed => {
        },
        removed => {
        }
    },
    5.019009 => {
        delta_from => 5.019008,
        changed => {
        },
        removed => {
        }
    },
    5.019010 => {
        delta_from => 5.019009,
        changed => {
        },
        removed => {
        }
    },
    5.019011 => {
        delta_from => 5.019010,
        changed => {
        },
        removed => {
        }
    },
    5.020000 => {
        delta_from => 5.019011,
        changed => {
        },
        removed => {
        }
    },
    5.021000 => {
        delta_from => 5.020000,
        changed => {
        },
        removed => {
        }
    },
    5.021001 => {
        delta_from => 5.021000,
        changed => {
        },
        removed => {
            'a2p'                   => 1,
            'config_data'           => 1,
            'find2perl'             => 1,
            'psed'                  => 1,
            's2p'                   => 1,
        }
    },
    5.021002 => {
        delta_from => 5.021001,
        changed => {
        },
        removed => {
        }
    },
    5.021003 => {
        delta_from => 5.021002,
        changed => {
        },
        removed => {
        }
    },
    5.020001 => {
        delta_from => 5.02,
        changed => {
        },
        removed => {
        }
    },
    5.021004 => {
        delta_from => 5.021003,
        changed => {
        },
        removed => {
        }
    },
    5.021005 => {
        delta_from => 5.021004,
        changed => {
        },
        removed => {
        }
    },
    5.021006 => {
        delta_from => 5.021005,
        changed => {
        },
        removed => {
        }
    },
    5.021007 => {
        delta_from => 5.021006,
        changed => {
        },
        removed => {
        }
    },
    5.021008 => {
        delta_from => 5.021007,
        changed => {
        },
        removed => {
        }
    },
    5.020002 => {
        delta_from => 5.020001,
        changed => {
        },
        removed => {
        }
    },
);

for my $version (sort { $a <=> $b } keys %delta) {
    my $data = $delta{$version};

    tie %{$utilities{$version}}, 'Module::CoreList::TieHashDelta',
        $data->{changed}, $data->{removed},
        $data->{delta_from} ? $utilities{$data->{delta_from}} : undef;
}

# Create aliases with trailing zeros for $] use

$utilities{'5.000'} = $utilities{5};

_create_aliases(\%utilities);

sub _create_aliases {
    my ($hash) = @_;

    for my $version (keys %$hash) {
        next unless $version >= 5.010;

        my $padded = sprintf "%0.6f", $version;

        # If the version in string form isn't the same as the numeric version,
        # alias it.
        if ($padded ne $version && $version == $padded) {
            $hash->{$padded} = $hash->{$version};
        }
    }
}

'foo';

=pod

=head1 NAME

Module::CoreList::Utils - what utilities shipped with versions of perl

=head1 SYNOPSIS

 use Module::CoreList::Utils;

 print $Module::CoreList::Utils::utilities{5.009003}{ptar}; # prints 1

 print Module::CoreList::Utils->first_release('corelist');           # prints 5.008009
 print Module::CoreList::Utils->first_release_by_date('corelist');   # prints 5.009002

=head1 DESCRIPTION

Module::CoreList::Utils provides information on which core and dual-life utilities shipped
with each version of L<perl>.

It provides a number of mechanisms for querying this information.

There is a functional programming API available for programmers to query
information.

Programmers may also query the contained hash structure to find relevant
information.

=head1 FUNCTIONS API

These are the functions that are available, they may either be called as functions or class methods:

  Module::CoreList::Utils::first_release('corelist'); # as a function

  Module::CoreList::Utils->first_release('corelist'); # class method

=over

=item C<utilities>

Requires a perl version as an argument, returns a list of utilities that shipped with
that version of perl, or undef/empty list if that perl doesn't exist.

=item C<first_release( UTILITY )>

Requires a UTILITY name as an argument, returns the perl version when that utility first
appeared in core as ordered by perl version number or undef ( in scalar context )
or an empty list ( in list context ) if that utility is not in core.

=item C<first_release_by_date( UTILITY )>

Requires a UTILITY name as an argument, returns the perl version when that utility first
appeared in core as ordered by release date or undef ( in scalar context )
or an empty list ( in list context ) if that utility is not in core.

=item C<removed_from( UTILITY )>

Takes a UTILITY name as an argument, returns the first perl version where that utility
was removed from core. Returns undef if the given utility was never in core or remains
in core.

=item C<removed_from_by_date( UTILITY )>

Takes a UTILITY name as an argument, returns the first perl version by release date where that
utility was removed from core. Returns undef if the given utility was never in core or remains
in core.

=back

=head1 DATA STRUCTURES

These are the hash data structures that are available:

=over

=item C<%Module::CoreList::Utils::utilities>

A hash of hashes that is keyed on perl version as indicated
in $].  The second level hash is utility / defined pairs.

=back

=head1 AUTHOR

Chris C<BinGOs> Williams <chris@bingosnet.co.uk>

Currently maintained by the perl 5 porters E<lt>perl5-porters@perl.orgE<gt>.

This module is the result of archaeology undertaken during QA Hackathon
in Lancaster, April 2013.

=head1 LICENSE

Copyright (C) 2013 Chris Williams.  All Rights Reserved.

This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=head1 SEE ALSO

L<corelist>, L<Module::CoreList>, L<perl>, L<http://perlpunks.de/corelist>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/perl/5.20.2/Module/CoreList.pm                                                            0100644 0000000 0000000 00002126501 12744441327 016174  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::CoreList;
use strict;
use vars qw/$VERSION %released %version %families %upstream
	    %bug_tracker %deprecated %delta/;
use Module::CoreList::TieHashDelta;
use version;
$VERSION = '5.20150214';

my $dumpinc = 0;
sub import {
    my $self = shift;
    my $what = shift || '';
    if ($what eq 'dumpinc') {
        $dumpinc = 1;
    }
}

END {
    print "---INC---\n", join "\n" => keys %INC
      if $dumpinc;
}


sub first_release_raw {
    my $module = shift;
    $module = shift if eval { $module->isa(__PACKAGE__) }
      and scalar @_ and $_[0] =~ m#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#;
    my $version = shift;

    my @perls = $version
        ? grep { defined $version{$_}{ $module } &&
                        $version{$_}{ $module } ge $version } keys %version
        : grep { exists $version{$_}{ $module }             } keys %version;

    return @perls;
}

sub first_release_by_date {
    my @perls = &first_release_raw;
    return unless @perls;
    return (sort { $released{$a} cmp $released{$b} } @perls)[0];
}

sub first_release {
    my @perls = &first_release_raw;
    return unless @perls;
    return (sort { $a cmp $b } @perls)[0];
}

sub find_modules {
    my $regex = shift;
    $regex = shift if eval { $regex->isa(__PACKAGE__) };
    my @perls = @_;
    @perls = keys %version unless @perls;

    my %mods;
    foreach (@perls) {
        while (my ($k, $v) = each %{$version{$_}}) {
            $mods{$k}++ if $k =~ $regex;
        }
    }
    return sort keys %mods
}

sub find_version {
    my $v = shift;
    $v = shift if eval { $v->isa(__PACKAGE__) };
    return $version{$v} if defined $version{$v};
    return undef;
}

sub is_deprecated {
    my $module = shift;
    $module = shift if eval { $module->isa(__PACKAGE__) }
      and scalar @_ and $_[0] =~ m#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#;
    my $perl_version = shift;
    $perl_version ||= $];
    return unless $module && exists $deprecated{$perl_version}{$module};
    return $deprecated{$perl_version}{$module};
}

sub deprecated_in {
    my $module = shift;
    $module = shift if eval { $module->isa(__PACKAGE__) }
      and scalar @_ and $_[0] =~ m#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#;
    return unless $module;
    my @perls = grep { exists $deprecated{$_}{$module} } keys %deprecated;
    return unless @perls;
    require List::Util;
    return List::Util::minstr(@perls);
}

sub removed_from {
  my @perls = &removed_raw;
  return shift @perls;
}

sub removed_from_by_date {
  my @perls = sort { $released{$a} cmp $released{$b} } &removed_raw;
  return shift @perls;
}

sub removed_raw {
  my $mod = shift;
  $mod = shift if eval { $mod->isa(__PACKAGE__) }
      and scalar @_ and $_[0] =~ m#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#;
  return unless my @perls = sort { $a cmp $b } first_release_raw($mod);
  my $last = pop @perls;
  my @removed = grep { $_ > $last } sort { $a cmp $b } keys %version;
  return @removed;
}

sub changes_between {
  my $left_ver = shift;
  $left_ver = shift if eval { $left_ver->isa(__PACKAGE__) };
  my $right_ver = shift;

  my $left  = $version{ $left_ver };
  my $right = $version{ $right_ver };

  my %uniq = (%$left, %$right);

  my %changes;
  for my $lib (keys %uniq) {
      my $lhs = exists $left->{ $lib }
              ? (defined $left->{ $lib } ? $left->{ $lib } : '(undef)')
              : '(absent)';
      my $rhs = exists $right->{ $lib }
              ? (defined $right->{ $lib } ? $right->{ $lib } : '(undef)')
              : '(absent)';

      next if $lhs eq $rhs;

      my $change = {
        (exists $left->{$lib}  ? (left  => $left->{$lib})  : ()),
        (exists $right->{$lib} ? (right => $right->{$lib}) : ()),
      };

      $changes{$lib} = $change;
  }

  return %changes;
}

# When things escaped.
# NB. If you put version numbers with trailing zeroes here, you
# should also add an alias for the numerical ($]) version; see
# just before the __END__ of this module.
%released = (
    5.000    => '1994-10-17',
    5.001    => '1995-03-14',
    5.002    => '1996-02-29',
    5.00307  => '1996-10-10',
    5.004    => '1997-05-15',
    5.005    => '1998-07-22',
    5.00503  => '1999-03-28',
    5.00405  => '1999-04-29',
    5.006    => '2000-03-22',
    5.006001 => '2001-04-08',
    5.007003 => '2002-03-05',
    5.008    => '2002-07-19',
    5.008001 => '2003-09-25',
    5.009    => '2003-10-27',
    5.008002 => '2003-11-05',
    5.006002 => '2003-11-15',
    5.008003 => '2004-01-14',
    5.00504  => '2004-02-23',
    5.009001 => '2004-03-16',
    5.008004 => '2004-04-21',
    5.008005 => '2004-07-19',
    5.008006 => '2004-11-27',
    5.009002 => '2005-04-01',
    5.008007 => '2005-05-30',
    5.009003 => '2006-01-28',
    5.008008 => '2006-01-31',
    5.009004 => '2006-08-15',
    5.009005 => '2007-07-07',
    5.010000 => '2007-12-18',
    5.008009 => '2008-12-14',
    5.010001 => '2009-08-22',
    5.011000 => '2009-10-02',
    5.011001 => '2009-10-20',
    5.011002 => '2009-11-20',
    5.011003 => '2009-12-20',
    5.011004 => '2010-01-20',
    5.011005 => '2010-02-20',
    5.012000 => '2010-04-12',
    5.013000 => '2010-04-20',
    5.012001 => '2010-05-16',
    5.013001 => '2010-05-20',
    5.013002 => '2010-06-22',
    5.013003 => '2010-07-20',
    5.013004 => '2010-08-20',
    5.012002 => '2010-09-06',
    5.013005 => '2010-09-19',
    5.013006 => '2010-10-20',
    5.013007 => '2010-11-20',
    5.013008 => '2010-12-20',
    5.012003 => '2011-01-21',
    5.013009 => '2011-01-20',
    5.013010 => '2011-02-20',
    5.013011 => '2011-03-20',
    5.014000 => '2011-05-14',
    5.012004 => '2011-06-20',
    5.012005 => '2012-11-10',
    5.014001 => '2011-06-16',
    5.015000 => '2011-06-20',
    5.015001 => '2011-07-20',
    5.015002 => '2011-08-20',
    5.014002 => '2011-09-26',
    5.015003 => '2011-09-20',
    5.015004 => '2011-10-20',
    5.015005 => '2011-11-20',
    5.015006 => '2011-12-20',
    5.015007 => '2012-01-20',
    5.015008 => '2012-02-20',
    5.015009 => '2012-03-20',
    5.016000 => '2012-05-20',
    5.016001 => '2012-08-08',
    5.016002 => '2012-11-01',
    5.017000 => '2012-05-26',
    5.017001 => '2012-06-20',
    5.017002 => '2012-07-20',
    5.017003 => '2012-08-20',
    5.017004 => '2012-09-20',
    5.014003 => '2012-10-12',
    5.017005 => '2012-10-20',
    5.017006 => '2012-11-20',
    5.017007 => '2012-12-18',
    5.017008 => '2013-01-20',
    5.017009 => '2013-02-20',
    5.014004 => '2013-03-10',
    5.016003 => '2013-03-11',
    5.017010 => '2013-03-21',
    5.017011 => '2013-04-20',
    5.018000 => '2013-05-18',
    5.019000 => '2013-05-20',
    5.019001 => '2013-06-21',
    5.019002 => '2013-07-22',
    5.018001 => '2013-08-12',
    5.019003 => '2013-08-20',
    5.019004 => '2013-09-20',
    5.019005 => '2013-10-20',
    5.019006 => '2013-11-20',
    5.019007 => '2013-12-20',
    5.018002 => '2014-01-06',
    5.018003 => '2014-10-01',
    5.018004 => '2014-10-01',
    5.019008 => '2014-01-20',
    5.019009 => '2014-02-20',
    5.01901  => '2014-03-20',
    5.019011 => '2014-04-20',
    5.020000 => '2014-05-27',
    5.021000 => '2014-05-27',
    5.021001 => '2014-06-20',
    5.021002 => '2014-07-20',
    5.021003 => '2014-08-20',
    5.020001 => '2014-09-14',
    5.021004 => '2014-09-20',
    5.021005 => '2014-10-20',
    5.021006 => '2014-11-20',
    5.021007 => '2014-12-20',
    5.021008 => '2015-01-20',
    5.020002 => '2015-02-14',
  );

for my $version ( sort { $a <=> $b } keys %released ) {
    my $family = int ($version * 1000) / 1000;
    push @{ $families{ $family }} , $version;
}

%delta = (
    5 => {
        changed => {
            'AnyDBM_File'           => undef,
            'AutoLoader'            => undef,
            'AutoSplit'             => undef,
            'Benchmark'             => undef,
            'Carp'                  => undef,
            'Cwd'                   => undef,
            'DB_File'               => undef,
            'DynaLoader'            => undef,
            'English'               => undef,
            'Env'                   => undef,
            'Exporter'              => undef,
            'ExtUtils::MakeMaker'   => undef,
            'Fcntl'                 => undef,
            'File::Basename'        => undef,
            'File::CheckTree'       => undef,
            'File::Find'            => undef,
            'FileHandle'            => undef,
            'GDBM_File'             => undef,
            'Getopt::Long'          => undef,
            'Getopt::Std'           => undef,
            'I18N::Collate'         => undef,
            'IPC::Open2'            => undef,
            'IPC::Open3'            => undef,
            'Math::BigFloat'        => undef,
            'Math::BigInt'          => undef,
            'Math::Complex'         => undef,
            'NDBM_File'             => undef,
            'Net::Ping'             => undef,
            'ODBM_File'             => undef,
            'POSIX'                 => undef,
            'SDBM_File'             => undef,
            'Search::Dict'          => undef,
            'Shell'                 => undef,
            'Socket'                => undef,
            'Sys::Hostname'         => undef,
            'Sys::Syslog'           => undef,
            'Term::Cap'             => undef,
            'Term::Complete'        => undef,
            'Test::Harness'         => undef,
            'Text::Abbrev'          => undef,
            'Text::ParseWords'      => undef,
            'Text::Soundex'         => undef,
            'Text::Tabs'            => undef,
            'TieHash'               => undef,
            'Time::Local'           => undef,
            'integer'               => undef,
            'less'                  => undef,
            'sigtrap'               => undef,
            'strict'                => undef,
            'subs'                  => undef,
        },
        removed => {
        }
    },
    5.001 => {
        delta_from => 5,
        changed => {
            'ExtUtils::Liblist'     => undef,
            'ExtUtils::Manifest'    => undef,
            'ExtUtils::Mkbootstrap' => undef,
            'File::Path'            => undef,
            'SubstrHash'            => undef,
            'lib'                   => undef,
        },
        removed => {
        }
    },
    5.002 => {
        delta_from => 5.001,
        changed => {
            'DB_File'               => '1.01',
            'Devel::SelfStubber'    => '1.01',
            'DirHandle'             => undef,
            'DynaLoader'            => '1.00',
            'ExtUtils::Install'     => undef,
            'ExtUtils::MM_OS2'      => undef,
            'ExtUtils::MM_Unix'     => undef,
            'ExtUtils::MM_VMS'      => undef,
            'ExtUtils::MakeMaker'   => '5.21',
            'ExtUtils::Manifest'    => '1.22',
            'ExtUtils::Mksymlists'  => '1.00',
            'Fcntl'                 => '1.00',
            'File::Copy'            => '1.5',
            'File::Path'            => '1.01',
            'FileCache'             => undef,
            'FileHandle'            => '1.00',
            'GDBM_File'             => '1.00',
            'Getopt::Long'          => '2.01',
            'NDBM_File'             => '1.00',
            'Net::Ping'             => '1',
            'ODBM_File'             => '1.00',
            'POSIX'                 => '1.00',
            'Pod::Functions'        => undef,
            'Pod::Text'             => undef,
            'SDBM_File'             => '1.00',
            'Safe'                  => '1.00',
            'SelectSaver'           => undef,
            'SelfLoader'            => '1.06',
            'Socket'                => '1.5',
            'Symbol'                => undef,
            'Term::ReadLine'        => undef,
            'Test::Harness'         => '1.07',
            'Text::Wrap'            => undef,
            'Tie::Hash'             => undef,
            'Tie::Scalar'           => undef,
            'Tie::SubstrHash'       => undef,
            'diagnostics'           => undef,
            'overload'              => undef,
            'vars'                  => undef,
        },
        removed => {
            'SubstrHash'            => 1,
            'TieHash'               => 1,
        }
    },
    5.00307 => {
        delta_from => 5.002,
        changed => {
            'Config'                => undef,
            'DB_File'               => '1.03',
            'ExtUtils::Embed'       => '1.18',
            'ExtUtils::Install'     => '1.15 ',
            'ExtUtils::Liblist'     => '1.20 ',
            'ExtUtils::MM_Unix'     => '1.107 ',
            'ExtUtils::MakeMaker'   => '5.38',
            'ExtUtils::Manifest'    => '1.27',
            'ExtUtils::Mkbootstrap' => '1.13 ',
            'ExtUtils::Mksymlists'  => '1.12 ',
            'ExtUtils::testlib'     => '1.11 ',
            'Fatal'                 => undef,
            'File::Basename'        => '2.4',
            'FindBin'               => '1.04',
            'Getopt::Long'          => '2.04',
            'IO'                    => undef,
            'IO::File'              => '1.05',
            'IO::Handle'            => '1.12',
            'IO::Pipe'              => '1.07',
            'IO::Seekable'          => '1.05',
            'IO::Select'            => '1.09',
            'IO::Socket'            => '1.13',
            'Net::Ping'             => '1.01',
            'OS2::ExtAttr'          => '0.01',
            'OS2::PrfDB'            => '0.02',
            'OS2::Process'          => undef,
            'OS2::REXX'             => undef,
            'Opcode'                => '1.01',
            'Safe'                  => '2.06',
            'Test::Harness'         => '1.13',
            'Text::Tabs'            => '96.051501',
            'Text::Wrap'            => '96.041801',
            'UNIVERSAL'             => undef,
            'VMS::Filespec'         => undef,
            'VMS::Stdio'            => '2.0',
            'ops'                   => undef,
            'sigtrap'               => '1.01',
        },
        removed => {
        }
    },
    5.004 => {
        delta_from => 5.00307,
        changed => {
            'Bundle::CPAN'          => '0.02',
            'CGI'                   => '2.36',
            'CGI::Apache'           => '1.01',
            'CGI::Carp'             => '1.06',
            'CGI::Fast'             => '1.00a',
            'CGI::Push'             => '1.00',
            'CGI::Switch'           => '0.05',
            'CPAN'                  => '1.2401',
            'CPAN::FirstTime'       => '1.18 ',
            'CPAN::Nox'             => undef,
            'Class::Struct'         => undef,
            'Cwd'                   => '2.00',
            'DB_File'               => '1.14',
            'DynaLoader'            => '1.02',
            'ExtUtils::Command'     => '1.00',
            'ExtUtils::Embed'       => '1.2501',
            'ExtUtils::Install'     => '1.16 ',
            'ExtUtils::Liblist'     => '1.2201 ',
            'ExtUtils::MM_Unix'     => '1.114 ',
            'ExtUtils::MM_Win32'    => undef,
            'ExtUtils::MakeMaker'   => '5.4002',
            'ExtUtils::Manifest'    => '1.33 ',
            'ExtUtils::Mksymlists'  => '1.13 ',
            'ExtUtils::XSSymSet'    => '1.0',
            'Fcntl'                 => '1.03',
            'File::Basename'        => '2.5',
            'File::Compare'         => '1.1001',
            'File::Copy'            => '2.02',
            'File::Path'            => '1.04',
            'File::stat'            => undef,
            'FileHandle'            => '2.00',
            'Getopt::Long'          => '2.10',
            'IO::File'              => '1.0602',
            'IO::Handle'            => '1.1504',
            'IO::Pipe'              => '1.0901',
            'IO::Seekable'          => '1.06',
            'IO::Select'            => '1.10',
            'IO::Socket'            => '1.1602',
            'IPC::Open2'            => '1.01',
            'IPC::Open3'            => '1.0101',
            'Math::Complex'         => '1.01',
            'Math::Trig'            => '1',
            'Net::Ping'             => '2.02',
            'Net::hostent'          => undef,
            'Net::netent'           => undef,
            'Net::protoent'         => undef,
            'Net::servent'          => undef,
            'Opcode'                => '1.04',
            'POSIX'                 => '1.02',
            'Pod::Html'             => undef,
            'Pod::Text'             => '1.0203',
            'SelfLoader'            => '1.07',
            'Socket'                => '1.6',
            'Symbol'                => '1.02',
            'Test::Harness'         => '1.1502',
            'Text::Tabs'            => '96.121201',
            'Text::Wrap'            => '97.011701',
            'Tie::RefHash'          => undef,
            'Time::gmtime'          => '1.01',
            'Time::localtime'       => '1.01',
            'Time::tm'              => undef,
            'User::grent'           => undef,
            'User::pwent'           => undef,
            'VMS::DCLsym'           => '1.01',
            'VMS::Stdio'            => '2.02',
            'autouse'               => '1.01',
            'blib'                  => undef,
            'constant'              => '1.00',
            'locale'                => undef,
            'sigtrap'               => '1.02',
            'vmsish'                => undef,
        },
        removed => {
            'Fatal'                 => 1,
        }
    },
    5.00405 => {
        delta_from => 5.004,
        changed => {
            'AutoLoader'            => '5.56',
            'AutoSplit'             => '1.0303',
            'Bundle::CPAN'          => '0.03',
            'CGI'                   => '2.42',
            'CGI::Apache'           => '1.1',
            'CGI::Carp'             => '1.10',
            'CGI::Cookie'           => '1.06',
            'CGI::Push'             => '1.01',
            'CGI::Switch'           => '0.06',
            'CPAN'                  => '1.40',
            'CPAN::FirstTime'       => '1.30 ',
            'Cwd'                   => '2.01',
            'DB_File'               => '1.15',
            'DynaLoader'            => '1.03',
            'ExtUtils::Command'     => '1.01',
            'ExtUtils::Embed'       => '1.2505',
            'ExtUtils::Install'     => '1.28 ',
            'ExtUtils::Liblist'     => '1.25 ',
            'ExtUtils::MM_Unix'     => '1.118 ',
            'ExtUtils::MakeMaker'   => '5.42',
            'ExtUtils::Mkbootstrap' => '1.14 ',
            'ExtUtils::Mksymlists'  => '1.16 ',
            'File::Basename'        => '2.6',
            'File::DosGlob'         => undef,
            'File::Path'            => '1.0402',
            'File::Spec'            => '0.6',
            'File::Spec::Mac'       => '1.0',
            'File::Spec::OS2'       => undef,
            'File::Spec::Unix'      => undef,
            'File::Spec::VMS'       => undef,
            'File::Spec::Win32'     => undef,
            'FindBin'               => '1.41',
            'Getopt::Long'          => '2.19',
            'IO::File'              => '1.06021',
            'IO::Socket'            => '1.1603',
            'IPC::Open3'            => '1.0103',
            'Math::Complex'         => '1.25',
            'NDBM_File'             => '1.01',
            'Pod::Html'             => '1.0101',
            'Pod::Text'             => '1.0204',
            'SelfLoader'            => '1.08',
            'Socket'                => '1.7',
            'Test'                  => '1.04',
            'Test::Harness'         => '1.1602',
            'Text::ParseWords'      => '3.1001',
            'Text::Wrap'            => '98.112902',
            'Tie::Handle'           => undef,
            'attrs'                 => '0.1',
            'base'                  => undef,
            'blib'                  => '1.00',
            're'                    => undef,
            'strict'                => '1.01',
        },
        removed => {
        }
    },
    5.005 => {
        delta_from => 5.00405,
        changed => {
            'AutoLoader'            => undef,
            'AutoSplit'             => '1.0302',
            'B'                     => undef,
            'B::Asmdata'            => undef,
            'B::Assembler'          => undef,
            'B::Bblock'             => undef,
            'B::Bytecode'           => undef,
            'B::C'                  => undef,
            'B::CC'                 => undef,
            'B::Debug'              => undef,
            'B::Deparse'            => '0.56',
            'B::Disassembler'       => undef,
            'B::Lint'               => undef,
            'B::Showlex'            => undef,
            'B::Stackobj'           => undef,
            'B::Terse'              => undef,
            'B::Xref'               => undef,
            'CGI::Carp'             => '1.101',
            'CPAN'                  => '1.3901',
            'CPAN::FirstTime'       => '1.29 ',
            'DB_File'               => '1.60',
            'Data::Dumper'          => '2.09',
            'Errno'                 => '1.09',
            'ExtUtils::Installed'   => '0.02',
            'ExtUtils::MM_Unix'     => '1.12601 ',
            'ExtUtils::MakeMaker'   => '5.4301',
            'ExtUtils::Mkbootstrap' => '1.13 ',
            'ExtUtils::Mksymlists'  => '1.17 ',
            'ExtUtils::Packlist'    => '0.03',
            'Fatal'                 => '1.02',
            'File::Path'            => '1.0401',
            'Getopt::Long'          => '2.17',
            'IO::Handle'            => '1.1505',
            'IPC::Msg'              => '1.00',
            'IPC::Open3'            => '1.0102',
            'IPC::Semaphore'        => '1.00',
            'IPC::SysV'             => '1.03',
            'O'                     => undef,
            'OS2::Process'          => '0.2',
            'Pod::Html'             => '1.01',
            'Pod::Text'             => '1.0203',
            'Text::ParseWords'      => '3.1',
            'Text::Wrap'            => '97.02',
            'Thread'                => '1.0',
            'Thread::Queue'         => undef,
            'Thread::Semaphore'     => undef,
            'Thread::Signal'        => undef,
            'Thread::Specific'      => undef,
            'Tie::Array'            => '1.00',
            'VMS::Stdio'            => '2.1',
            'attrs'                 => '1.0',
            'fields'                => '0.02',
            're'                    => '0.02',
        },
        removed => {
            'Bundle::CPAN'          => 1,
        }
    },
    5.00503 => {
        delta_from => 5.005,
        changed => {
            'AutoSplit'             => '1.0303',
            'CGI'                   => '2.46',
            'CGI::Carp'             => '1.13',
            'CGI::Fast'             => '1.01',
            'CPAN'                  => '1.48',
            'CPAN::FirstTime'       => '1.36',
            'CPAN::Nox'             => '1.00',
            'DB_File'               => '1.65',
            'Data::Dumper'          => '2.101',
            'Dumpvalue'             => undef,
            'Errno'                 => '1.111',
            'ExtUtils::Install'     => '1.28',
            'ExtUtils::Liblist'     => '1.25',
            'ExtUtils::MM_Unix'     => '1.12602',
            'ExtUtils::MakeMaker'   => '5.4302',
            'ExtUtils::Manifest'    => '1.33',
            'ExtUtils::Mkbootstrap' => '1.14',
            'ExtUtils::Mksymlists'  => '1.17',
            'ExtUtils::testlib'     => '1.11',
            'FindBin'               => '1.42',
            'Getopt::Long'          => '2.19',
            'Getopt::Std'           => '1.01',
            'IO::Pipe'              => '1.0902',
            'IPC::Open3'            => '1.0103',
            'Math::Complex'         => '1.26',
            'Test'                  => '1.122',
            'Text::Wrap'            => '98.112902',
        },
        removed => {
        }
    },
    5.00504 => {
        delta_from => 5.00503,
        changed => {
            'CPAN::FirstTime'       => '1.36 ',
            'DB_File'               => '1.807',
            'ExtUtils::Install'     => '1.28 ',
            'ExtUtils::Liblist'     => '1.25 ',
            'ExtUtils::MM_Unix'     => '1.12602 ',
            'ExtUtils::Manifest'    => '1.33 ',
            'ExtUtils::Miniperl'    => undef,
            'ExtUtils::Mkbootstrap' => '1.14 ',
            'ExtUtils::Mksymlists'  => '1.17 ',
            'ExtUtils::testlib'     => '1.11 ',
            'File::Compare'         => '1.1002',
            'File::Spec'            => '0.8',
            'File::Spec::Functions' => undef,
            'File::Spec::Mac'       => undef,
            'Getopt::Long'          => '2.20',
            'Pod::Html'             => '1.02',
        },
        removed => {
        }
    },
    5.006 => {
        delta_from => 5.00504,
        changed => {
            'AutoLoader'            => '5.57',
            'AutoSplit'             => '1.0305',
            'B::Deparse'            => '0.59',
            'B::Stash'              => undef,
            'Benchmark'             => '1',
            'ByteLoader'            => '0.03',
            'CGI'                   => '2.56',
            'CGI::Apache'           => undef,
            'CGI::Carp'             => '1.14',
            'CGI::Cookie'           => '1.12',
            'CGI::Fast'             => '1.02',
            'CGI::Pretty'           => '1.03',
            'CGI::Switch'           => undef,
            'CPAN'                  => '1.52',
            'CPAN::FirstTime'       => '1.38 ',
            'Carp::Heavy'           => undef,
            'Class::Struct'         => '0.58',
            'Cwd'                   => '2.02',
            'DB'                    => '1.0',
            'DB_File'               => '1.72',
            'Devel::DProf'          => '20000000.00_00',
            'Devel::Peek'           => '1.00_01',
            'DynaLoader'            => '1.04',
            'Exporter'              => '5.562',
            'Exporter::Heavy'       => undef,
            'ExtUtils::MM_Cygwin'   => undef,
            'ExtUtils::MM_Unix'     => '1.12603 ',
            'ExtUtils::MakeMaker'   => '5.45',
            'File::Copy'            => '2.03',
            'File::Glob'            => '0.991',
            'File::Path'            => '1.0403',
            'GDBM_File'             => '1.03',
            'Getopt::Long'          => '2.23',
            'Getopt::Std'           => '1.02',
            'IO'                    => '1.20',
            'IO::Dir'               => '1.03',
            'IO::File'              => '1.08',
            'IO::Handle'            => '1.21',
            'IO::Pipe'              => '1.121',
            'IO::Poll'              => '0.01',
            'IO::Seekable'          => '1.08',
            'IO::Select'            => '1.14',
            'IO::Socket'            => '1.26',
            'IO::Socket::INET'      => '1.25',
            'IO::Socket::UNIX'      => '1.20',
            'JNI'                   => '0.01',
            'JPL::AutoLoader'       => undef,
            'JPL::Class'            => undef,
            'JPL::Compile'          => undef,
            'NDBM_File'             => '1.03',
            'ODBM_File'             => '1.02',
            'OS2::DLL'              => undef,
            'POSIX'                 => '1.03',
            'Pod::Checker'          => '1.098',
            'Pod::Find'             => '0.12',
            'Pod::Html'             => '1.03',
            'Pod::InputObjects'     => '1.12',
            'Pod::Man'              => '1.02',
            'Pod::ParseUtils'       => '0.2',
            'Pod::Parser'           => '1.12',
            'Pod::Plainer'          => '0.01',
            'Pod::Select'           => '1.12',
            'Pod::Text'             => '2.03',
            'Pod::Text::Color'      => '0.05',
            'Pod::Text::Termcap'    => '0.04',
            'Pod::Usage'            => '1.12',
            'SDBM_File'             => '1.02',
            'SelfLoader'            => '1.0901',
            'Shell'                 => '0.2',
            'Socket'                => '1.72',
            'Sys::Hostname'         => '1.1',
            'Sys::Syslog'           => '0.01',
            'Term::ANSIColor'       => '1.01',
            'Test'                  => '1.13',
            'Test::Harness'         => '1.1604',
            'Text::ParseWords'      => '3.2',
            'Text::Soundex'         => '1.0',
            'Text::Tabs'            => '98.112801',
            'Tie::Array'            => '1.01',
            'Tie::Handle'           => '1.0',
            'VMS::Stdio'            => '2.2',
            'XSLoader'              => '0.01',
            'attributes'            => '0.03',
            'autouse'               => '1.02',
            'base'                  => '1.01',
            'bytes'                 => undef,
            'charnames'             => undef,
            'constant'              => '1.02',
            'diagnostics'           => '1.0',
            'fields'                => '1.01',
            'filetest'              => undef,
            'lib'                   => '0.5564',
            'open'                  => undef,
            'utf8'                  => undef,
            'warnings'              => undef,
            'warnings::register'    => undef,
        },
        removed => {
        }
    },
    5.006001 => {
        delta_from => 5.006,
        changed => {
            'AutoLoader'            => '5.58',
            'B::Assembler'          => '0.02',
            'B::Concise'            => '0.51',
            'B::Deparse'            => '0.6',
            'ByteLoader'            => '0.04',
            'CGI'                   => '2.752',
            'CGI::Carp'             => '1.20',
            'CGI::Cookie'           => '1.18',
            'CGI::Pretty'           => '1.05',
            'CGI::Push'             => '1.04',
            'CGI::Util'             => '1.1',
            'CPAN'                  => '1.59_54',
            'CPAN::FirstTime'       => '1.53',
            'Class::Struct'         => '0.59',
            'Cwd'                   => '2.04',
            'DB_File'               => '1.75',
            'Data::Dumper'          => '2.102',
            'ExtUtils::Install'     => '1.28',
            'ExtUtils::Liblist'     => '1.26',
            'ExtUtils::MM_Unix'     => '1.12603',
            'ExtUtils::Manifest'    => '1.33',
            'ExtUtils::Mkbootstrap' => '1.14',
            'ExtUtils::Mksymlists'  => '1.17',
            'ExtUtils::testlib'     => '1.11',
            'File::Path'            => '1.0404',
            'File::Spec'            => '0.82',
            'File::Spec::Epoc'      => undef,
            'File::Spec::Functions' => '1.1',
            'File::Spec::Mac'       => '1.2',
            'File::Spec::OS2'       => '1.1',
            'File::Spec::Unix'      => '1.2',
            'File::Spec::VMS'       => '1.1',
            'File::Spec::Win32'     => '1.2',
            'File::Temp'            => '0.12',
            'GDBM_File'             => '1.05',
            'Getopt::Long'          => '2.25',
            'IO::Poll'              => '0.05',
            'JNI'                   => '0.1',
            'Math::BigFloat'        => '0.02',
            'Math::BigInt'          => '0.01',
            'Math::Complex'         => '1.31',
            'NDBM_File'             => '1.04',
            'ODBM_File'             => '1.03',
            'OS2::REXX'             => '1.00',
            'Pod::Checker'          => '1.2',
            'Pod::Find'             => '0.21',
            'Pod::InputObjects'     => '1.13',
            'Pod::LaTeX'            => '0.53',
            'Pod::Man'              => '1.15',
            'Pod::ParseUtils'       => '0.22',
            'Pod::Parser'           => '1.13',
            'Pod::Select'           => '1.13',
            'Pod::Text'             => '2.08',
            'Pod::Text::Color'      => '0.06',
            'Pod::Text::Overstrike' => '1.01',
            'Pod::Text::Termcap'    => '1',
            'Pod::Usage'            => '1.14',
            'SDBM_File'             => '1.03',
            'SelfLoader'            => '1.0902',
            'Shell'                 => '0.3',
            'Term::ANSIColor'       => '1.03',
            'Test'                  => '1.15',
            'Text::Wrap'            => '2001.0131',
            'Tie::Handle'           => '4.0',
            'Tie::RefHash'          => '1.3',
        },
        removed => {
        }
    },
    5.006002 => {
        delta_from => 5.006001,
        changed => {
            'CPAN::FirstTime'       => '1.53 ',
            'DB_File'               => '1.806',
            'Data::Dumper'          => '2.121',
            'ExtUtils::Command'     => '1.05',
            'ExtUtils::Command::MM' => '0.03',
            'ExtUtils::Install'     => '1.32',
            'ExtUtils::Installed'   => '0.08',
            'ExtUtils::Liblist'     => '1.01',
            'ExtUtils::Liblist::Kid'=> '1.3',
            'ExtUtils::MM'          => '0.04',
            'ExtUtils::MM_Any'      => '0.07',
            'ExtUtils::MM_BeOS'     => '1.04',
            'ExtUtils::MM_Cygwin'   => '1.06',
            'ExtUtils::MM_DOS'      => '0.02',
            'ExtUtils::MM_MacOS'    => '1.07',
            'ExtUtils::MM_NW5'      => '2.06',
            'ExtUtils::MM_OS2'      => '1.04',
            'ExtUtils::MM_UWIN'     => '0.02',
            'ExtUtils::MM_Unix'     => '1.42',
            'ExtUtils::MM_VMS'      => '5.70',
            'ExtUtils::MM_Win32'    => '1.09',
            'ExtUtils::MM_Win95'    => '0.03',
            'ExtUtils::MY'          => '0.01',
            'ExtUtils::MakeMaker'   => '6.17',
            'ExtUtils::MakeMaker::bytes'=> '0.01',
            'ExtUtils::MakeMaker::vmsish'=> '0.01',
            'ExtUtils::Manifest'    => '1.42',
            'ExtUtils::Mkbootstrap' => '1.15',
            'ExtUtils::Mksymlists'  => '1.19',
            'ExtUtils::Packlist'    => '0.04',
            'ExtUtils::testlib'     => '1.15',
            'File::Spec'            => '0.86',
            'File::Spec::Cygwin'    => '1.1',
            'File::Spec::Epoc'      => '1.1',
            'File::Spec::Functions' => '1.3',
            'File::Spec::Mac'       => '1.4',
            'File::Spec::OS2'       => '1.2',
            'File::Spec::Unix'      => '1.5',
            'File::Spec::VMS'       => '1.4',
            'File::Spec::Win32'     => '1.4',
            'File::Temp'            => '0.14',
            'Safe'                  => '2.10',
            'Test'                  => '1.24',
            'Test::Builder'         => '0.17',
            'Test::Harness'         => '2.30',
            'Test::Harness::Assert' => '0.01',
            'Test::Harness::Iterator'=> '0.01',
            'Test::Harness::Straps' => '0.15',
            'Test::More'            => '0.47',
            'Test::Simple'          => '0.47',
            'Unicode'               => '3.0.1',
            'if'                    => '0.03',
            'ops'                   => '1.00',
        },
        removed => {
        }
    },
    5.007003 => {
        delta_from => 5.006001,
        changed => {
            'AnyDBM_File'           => '1.00',
            'Attribute::Handlers'   => '0.76',
            'AutoLoader'            => '5.59',
            'AutoSplit'             => '1.0307',
            'B'                     => '1.00',
            'B::Asmdata'            => '1.00',
            'B::Assembler'          => '0.04',
            'B::Bblock'             => '1.00',
            'B::Bytecode'           => '1.00',
            'B::C'                  => '1.01',
            'B::CC'                 => '1.00',
            'B::Concise'            => '0.52',
            'B::Debug'              => '1.00',
            'B::Deparse'            => '0.63',
            'B::Disassembler'       => '1.01',
            'B::Lint'               => '1.00',
            'B::Showlex'            => '1.00',
            'B::Stackobj'           => '1.00',
            'B::Stash'              => '1.00',
            'B::Terse'              => '1.00',
            'B::Xref'               => '1.00',
            'Benchmark'             => '1.04',
            'CGI'                   => '2.80',
            'CGI::Apache'           => '1.00',
            'CGI::Carp'             => '1.22',
            'CGI::Cookie'           => '1.20',
            'CGI::Fast'             => '1.04',
            'CGI::Pretty'           => '1.05_00',
            'CGI::Switch'           => '1.00',
            'CGI::Util'             => '1.3',
            'CPAN'                  => '1.59_56',
            'CPAN::FirstTime'       => '1.54 ',
            'CPAN::Nox'             => '1.00_01',
            'Carp'                  => '1.01',
            'Carp::Heavy'           => '1.01',
            'Class::ISA'            => '0.32',
            'Class::Struct'         => '0.61',
            'Cwd'                   => '2.06',
            'DB_File'               => '1.804',
            'Data::Dumper'          => '2.12',
            'Devel::DProf'          => '20000000.00_01',
            'Devel::PPPort'         => '2.0002',
            'Devel::Peek'           => '1.00_03',
            'Devel::SelfStubber'    => '1.03',
            'Digest'                => '1.00',
            'Digest::MD5'           => '2.16',
            'DirHandle'             => '1.00',
            'Dumpvalue'             => '1.10',
            'Encode'                => '0.40',
            'Encode::CN'            => '0.02',
            'Encode::CN::HZ'        => undef,
            'Encode::Encoding'      => '0.02',
            'Encode::Internal'      => '0.30',
            'Encode::JP'            => '0.02',
            'Encode::JP::Constants' => '1.02',
            'Encode::JP::H2Z'       => '0.77',
            'Encode::JP::ISO_2022_JP'=> undef,
            'Encode::JP::JIS'       => undef,
            'Encode::JP::Tr'        => '0.77',
            'Encode::KR'            => '0.02',
            'Encode::TW'            => '0.02',
            'Encode::Tcl'           => '1.01',
            'Encode::Tcl::Escape'   => '1.01',
            'Encode::Tcl::Extended' => '1.01',
            'Encode::Tcl::HanZi'    => '1.01',
            'Encode::Tcl::Table'    => '1.01',
            'Encode::Unicode'       => '0.30',
            'Encode::XS'            => '0.40',
            'Encode::iso10646_1'    => '0.30',
            'Encode::usc2_le'       => '0.30',
            'Encode::utf8'          => '0.30',
            'English'               => '1.00',
            'Env'                   => '1.00',
            'Exporter'              => '5.566',
            'Exporter::Heavy'       => '5.562',
            'ExtUtils::Command'     => '1.02',
            'ExtUtils::Constant'    => '0.11',
            'ExtUtils::Embed'       => '1.250601',
            'ExtUtils::Install'     => '1.29',
            'ExtUtils::Installed'   => '0.04',
            'ExtUtils::Liblist'     => '1.2701',
            'ExtUtils::MM_BeOS'     => '1.00',
            'ExtUtils::MM_Cygwin'   => '1.00',
            'ExtUtils::MM_OS2'      => '1.00',
            'ExtUtils::MM_Unix'     => '1.12607',
            'ExtUtils::MM_VMS'      => '5.56',
            'ExtUtils::MM_Win32'    => '1.00_02',
            'ExtUtils::MakeMaker'   => '5.48_03',
            'ExtUtils::Manifest'    => '1.35',
            'ExtUtils::Mkbootstrap' => '1.1401',
            'ExtUtils::Mksymlists'  => '1.18',
            'ExtUtils::Packlist'    => '0.04',
            'ExtUtils::testlib'     => '1.1201',
            'Fatal'                 => '1.03',
            'Fcntl'                 => '1.04',
            'File::Basename'        => '2.71',
            'File::CheckTree'       => '4.1',
            'File::Compare'         => '1.1003',
            'File::Copy'            => '2.05',
            'File::DosGlob'         => '1.00',
            'File::Find'            => '1.04',
            'File::Glob'            => '1.01',
            'File::Path'            => '1.05',
            'File::Spec'            => '0.83',
            'File::Spec::Cygwin'    => '1.0',
            'File::Spec::Epoc'      => '1.00',
            'File::Spec::Functions' => '1.2',
            'File::Spec::Mac'       => '1.3',
            'File::Spec::Unix'      => '1.4',
            'File::Spec::VMS'       => '1.2',
            'File::Spec::Win32'     => '1.3',
            'File::Temp'            => '0.13',
            'File::stat'            => '1.00',
            'FileCache'             => '1.00',
            'FileHandle'            => '2.01',
            'Filter::Simple'        => '0.77',
            'Filter::Util::Call'    => '1.06',
            'FindBin'               => '1.43',
            'GDBM_File'             => '1.06',
            'Getopt::Long'          => '2.28',
            'Getopt::Std'           => '1.03',
            'I18N::Collate'         => '1.00',
            'I18N::LangTags'        => '0.27',
            'I18N::LangTags::List'  => '0.25',
            'I18N::Langinfo'        => '0.01',
            'IO::Dir'               => '1.03_00',
            'IO::File'              => '1.09',
            'IO::Handle'            => '1.21_00',
            'IO::Pipe'              => '1.122',
            'IO::Poll'              => '0.06',
            'IO::Seekable'          => '1.08_00',
            'IO::Select'            => '1.15',
            'IO::Socket'            => '1.27',
            'IO::Socket::INET'      => '1.26',
            'IO::Socket::UNIX'      => '1.20_00',
            'IPC::Msg'              => '1.00_00',
            'IPC::Open3'            => '1.0104',
            'IPC::Semaphore'        => '1.00_00',
            'IPC::SysV'             => '1.03_00',
            'List::Util'            => '1.06_00',
            'Locale::Constants'     => '2.01',
            'Locale::Country'       => '2.01',
            'Locale::Currency'      => '2.01',
            'Locale::Language'      => '2.01',
            'Locale::Maketext'      => '1.03',
            'Locale::Script'        => '2.01',
            'MIME::Base64'          => '2.12',
            'MIME::QuotedPrint'     => '2.03',
            'Math::BigFloat'        => '1.30',
            'Math::BigInt'          => '1.54',
            'Math::BigInt::Calc'    => '0.25',
            'Math::Complex'         => '1.34',
            'Math::Trig'            => '1.01',
            'Memoize'               => '0.66',
            'Memoize::AnyDBM_File'  => '0.65',
            'Memoize::Expire'       => '0.66',
            'Memoize::ExpireFile'   => '0.65',
            'Memoize::ExpireTest'   => '0.65',
            'Memoize::NDBM_File'    => '0.65',
            'Memoize::SDBM_File'    => '0.65',
            'Memoize::Storable'     => '0.65',
            'NEXT'                  => '0.50',
            'Net::Cmd'              => '2.21',
            'Net::Config'           => '1.10',
            'Net::Domain'           => '2.17',
            'Net::FTP'              => '2.64',
            'Net::FTP::A'           => '1.15',
            'Net::FTP::E'           => '0.01',
            'Net::FTP::I'           => '1.12',
            'Net::FTP::L'           => '0.01',
            'Net::FTP::dataconn'    => '0.10',
            'Net::NNTP'             => '2.21',
            'Net::Netrc'            => '2.12',
            'Net::POP3'             => '2.23',
            'Net::Ping'             => '2.12',
            'Net::SMTP'             => '2.21',
            'Net::Time'             => '2.09',
            'Net::hostent'          => '1.00',
            'Net::netent'           => '1.00',
            'Net::protoent'         => '1.00',
            'Net::servent'          => '1.00',
            'O'                     => '1.00',
            'OS2::DLL'              => '1.00',
            'OS2::Process'          => '1.0',
            'OS2::REXX'             => '1.01',
            'Opcode'                => '1.05',
            'POSIX'                 => '1.05',
            'PerlIO'                => '1.00',
            'PerlIO::Scalar'        => '0.01',
            'PerlIO::Via'           => '0.01',
            'Pod::Checker'          => '1.3',
            'Pod::Find'             => '0.22',
            'Pod::Functions'        => '1.01',
            'Pod::Html'             => '1.04',
            'Pod::LaTeX'            => '0.54',
            'Pod::Man'              => '1.32',
            'Pod::ParseLink'        => '1.05',
            'Pod::Text'             => '2.18',
            'Pod::Text::Color'      => '1.03',
            'Pod::Text::Overstrike' => '1.08',
            'Pod::Text::Termcap'    => '1.09',
            'Safe'                  => '2.07',
            'Scalar::Util'          => '1.06_00',
            'Search::Dict'          => '1.02',
            'SelectSaver'           => '1.00',
            'SelfLoader'            => '1.0903',
            'Shell'                 => '0.4',
            'Socket'                => '1.75',
            'Storable'              => '1.015',
            'Switch'                => '2.06',
            'Symbol'                => '1.04',
            'Sys::Syslog'           => '0.02',
            'Term::ANSIColor'       => '1.04',
            'Term::Cap'             => '1.07',
            'Term::Complete'        => '1.4',
            'Term::ReadLine'        => '1.00',
            'Test'                  => '1.18',
            'Test::Builder'         => '0.11',
            'Test::Harness'         => '2.01',
            'Test::Harness::Assert' => '0.01',
            'Test::Harness::Iterator'=> '0.01',
            'Test::Harness::Straps' => '0.08',
            'Test::More'            => '0.41',
            'Test::Simple'          => '0.41',
            'Text::Abbrev'          => '1.00',
            'Text::Balanced'        => '1.89',
            'Text::ParseWords'      => '3.21',
            'Text::Soundex'         => '1.01',
            'Text::Wrap'            => '2001.0929',
            'Thread'                => '2.00',
            'Thread::Queue'         => '1.00',
            'Thread::Semaphore'     => '1.00',
            'Thread::Signal'        => '1.00',
            'Thread::Specific'      => '1.00',
            'Tie::Array'            => '1.02',
            'Tie::File'             => '0.17',
            'Tie::Handle'           => '4.1',
            'Tie::Hash'             => '1.00',
            'Tie::Memoize'          => '1.0',
            'Tie::RefHash'          => '1.3_00',
            'Tie::Scalar'           => '1.00',
            'Tie::SubstrHash'       => '1.00',
            'Time::HiRes'           => '1.20_00',
            'Time::Local'           => '1.04',
            'Time::gmtime'          => '1.02',
            'Time::localtime'       => '1.02',
            'Time::tm'              => '1.00',
            'UNIVERSAL'             => '1.00',
            'Unicode::Collate'      => '0.10',
            'Unicode::Normalize'    => '0.14',
            'Unicode::UCD'          => '0.2',
            'User::grent'           => '1.00',
            'User::pwent'           => '1.00',
            'VMS::DCLsym'           => '1.02',
            'VMS::Filespec'         => '1.1',
            'VMS::Stdio'            => '2.3',
            'XS::Typemap'           => '0.01',
            'attributes'            => '0.04_01',
            'attrs'                 => '1.01',
            'autouse'               => '1.03',
            'base'                  => '1.02',
            'blib'                  => '1.01',
            'bytes'                 => '1.00',
            'charnames'             => '1.01',
            'constant'              => '1.04',
            'diagnostics'           => '1.1',
            'encoding'              => '1.00',
            'fields'                => '1.02',
            'filetest'              => '1.00',
            'if'                    => '0.01',
            'integer'               => '1.00',
            'less'                  => '0.01',
            'locale'                => '1.00',
            'open'                  => '1.01',
            'ops'                   => '1.00',
            'overload'              => '1.00',
            're'                    => '0.03',
            'sort'                  => '1.00',
            'strict'                => '1.02',
            'subs'                  => '1.00',
            'threads'               => '0.05',
            'threads::shared'       => '0.90',
            'utf8'                  => '1.00',
            'vars'                  => '1.01',
            'vmsish'                => '1.00',
            'warnings'              => '1.00',
            'warnings::register'    => '1.00',
        },
        removed => {
        }
    },
    5.008 => {
        delta_from => 5.007003,
        changed => {
            'Attribute::Handlers'   => '0.77',
            'B'                     => '1.01',
            'B::Lint'               => '1.01',
            'B::Xref'               => '1.01',
            'CGI'                   => '2.81',
            'CGI::Carp'             => '1.23',
            'CPAN'                  => '1.61',
            'CPAN::FirstTime'       => '1.56 ',
            'CPAN::Nox'             => '1.02',
            'Digest::MD5'           => '2.20',
            'Dumpvalue'             => '1.11',
            'Encode'                => '1.75',
            'Encode::Alias'         => '1.32',
            'Encode::Byte'          => '1.22',
            'Encode::CJKConstants'  => '1.00',
            'Encode::CN'            => '1.24',
            'Encode::CN::HZ'        => '1.04',
            'Encode::Config'        => '1.06',
            'Encode::EBCDIC'        => '1.21',
            'Encode::Encoder'       => '0.05',
            'Encode::Encoding'      => '1.30',
            'Encode::Guess'         => '1.06',
            'Encode::JP'            => '1.25',
            'Encode::JP::H2Z'       => '1.02',
            'Encode::JP::JIS7'      => '1.08',
            'Encode::KR'            => '1.22',
            'Encode::KR::2022_KR'   => '1.05',
            'Encode::MIME::Header'  => '1.05',
            'Encode::Symbol'        => '1.22',
            'Encode::TW'            => '1.26',
            'Encode::Unicode'       => '1.37',
            'Exporter::Heavy'       => '5.566',
            'ExtUtils::Command'     => '1.04',
            'ExtUtils::Command::MM' => '0.01',
            'ExtUtils::Constant'    => '0.12',
            'ExtUtils::Installed'   => '0.06',
            'ExtUtils::Liblist'     => '1.00',
            'ExtUtils::Liblist::Kid'=> '1.29',
            'ExtUtils::MM'          => '0.04',
            'ExtUtils::MM_Any'      => '0.04',
            'ExtUtils::MM_BeOS'     => '1.03',
            'ExtUtils::MM_Cygwin'   => '1.04',
            'ExtUtils::MM_DOS'      => '0.01',
            'ExtUtils::MM_MacOS'    => '1.03',
            'ExtUtils::MM_NW5'      => '2.05',
            'ExtUtils::MM_OS2'      => '1.03',
            'ExtUtils::MM_UWIN'     => '0.01',
            'ExtUtils::MM_Unix'     => '1.33',
            'ExtUtils::MM_VMS'      => '5.65',
            'ExtUtils::MM_Win32'    => '1.05',
            'ExtUtils::MM_Win95'    => '0.02',
            'ExtUtils::MY'          => '0.01',
            'ExtUtils::MakeMaker'   => '6.03',
            'ExtUtils::Manifest'    => '1.38',
            'ExtUtils::Mkbootstrap' => '1.15',
            'ExtUtils::Mksymlists'  => '1.19',
            'ExtUtils::testlib'     => '1.15',
            'File::CheckTree'       => '4.2',
            'FileCache'             => '1.021',
            'Filter::Simple'        => '0.78',
            'Getopt::Long'          => '2.32',
            'Hash::Util'            => '0.04',
            'List::Util'            => '1.07_00',
            'Locale::Country'       => '2.04',
            'Math::BigFloat'        => '1.35',
            'Math::BigFloat::Trace' => '0.01',
            'Math::BigInt'          => '1.60',
            'Math::BigInt::Calc'    => '0.30',
            'Math::BigInt::Trace'   => '0.01',
            'Math::BigRat'          => '0.07',
            'Memoize'               => '1.01',
            'Memoize::Expire'       => '1.00',
            'Memoize::ExpireFile'   => '1.01',
            'Net::FTP'              => '2.65',
            'Net::FTP::dataconn'    => '0.11',
            'Net::Ping'             => '2.19',
            'Net::SMTP'             => '2.24',
            'PerlIO'                => '1.01',
            'PerlIO::encoding'      => '0.06',
            'PerlIO::scalar'        => '0.01',
            'PerlIO::via'           => '0.01',
            'PerlIO::via::QuotedPrint'=> '0.04',
            'Pod::Man'              => '1.33',
            'Pod::Text'             => '2.19',
            'Scalar::Util'          => '1.07_00',
            'Storable'              => '2.04',
            'Switch'                => '2.09',
            'Sys::Syslog'           => '0.03',
            'Test'                  => '1.20',
            'Test::Builder'         => '0.15',
            'Test::Harness'         => '2.26',
            'Test::Harness::Straps' => '0.14',
            'Test::More'            => '0.45',
            'Test::Simple'          => '0.45',
            'Thread::Queue'         => '2.00',
            'Thread::Semaphore'     => '2.00',
            'Tie::File'             => '0.93',
            'Tie::RefHash'          => '1.30',
            'Unicode'               => '3.2.0',
            'Unicode::Collate'      => '0.12',
            'Unicode::Normalize'    => '0.17',
            'XS::APItest'           => '0.01',
            'attributes'            => '0.05',
            'base'                  => '1.03',
            'bigint'                => '0.02',
            'bignum'                => '0.11',
            'bigrat'                => '0.04',
            'blib'                  => '1.02',
            'encoding'              => '1.35',
            'sort'                  => '1.01',
            'threads'               => '0.99',
        },
        removed => {
            'Encode::Internal'      => 1,
            'Encode::JP::Constants' => 1,
            'Encode::JP::ISO_2022_JP'=> 1,
            'Encode::JP::JIS'       => 1,
            'Encode::JP::Tr'        => 1,
            'Encode::Tcl'           => 1,
            'Encode::Tcl::Escape'   => 1,
            'Encode::Tcl::Extended' => 1,
            'Encode::Tcl::HanZi'    => 1,
            'Encode::Tcl::Table'    => 1,
            'Encode::XS'            => 1,
            'Encode::iso10646_1'    => 1,
            'Encode::usc2_le'       => 1,
            'Encode::utf8'          => 1,
            'PerlIO::Scalar'        => 1,
            'PerlIO::Via'           => 1,
        }
    },
    5.008001 => {
        delta_from => 5.008,
        changed => {
            'Attribute::Handlers'   => '0.78',
            'AutoLoader'            => '5.60',
            'AutoSplit'             => '1.04',
            'B'                     => '1.02',
            'B::Asmdata'            => '1.01',
            'B::Assembler'          => '0.06',
            'B::Bblock'             => '1.02',
            'B::Bytecode'           => '1.01',
            'B::C'                  => '1.02',
            'B::Concise'            => '0.56',
            'B::Debug'              => '1.01',
            'B::Deparse'            => '0.64',
            'B::Disassembler'       => '1.03',
            'B::Lint'               => '1.02',
            'B::Terse'              => '1.02',
            'Benchmark'             => '1.051',
            'ByteLoader'            => '0.05',
            'CGI'                   => '3.00',
            'CGI::Carp'             => '1.26',
            'CGI::Cookie'           => '1.24',
            'CGI::Fast'             => '1.041',
            'CGI::Pretty'           => '1.07_00',
            'CGI::Util'             => '1.31',
            'CPAN'                  => '1.76_01',
            'CPAN::FirstTime'       => '1.60 ',
            'CPAN::Nox'             => '1.03',
            'Class::Struct'         => '0.63',
            'Cwd'                   => '2.08',
            'DB_File'               => '1.806',
            'Data::Dumper'          => '2.121',
            'Devel::DProf'          => '20030813.00',
            'Devel::PPPort'         => '2.007',
            'Devel::Peek'           => '1.01',
            'Digest'                => '1.02',
            'Digest::MD5'           => '2.27',
            'Encode'                => '1.9801',
            'Encode::Alias'         => '1.38',
            'Encode::Byte'          => '1.23',
            'Encode::CJKConstants'  => '1.02',
            'Encode::CN::HZ'        => '1.05',
            'Encode::Config'        => '1.07',
            'Encode::Encoder'       => '0.07',
            'Encode::Encoding'      => '1.33',
            'Encode::Guess'         => '1.09',
            'Encode::JP::JIS7'      => '1.12',
            'Encode::KR'            => '1.23',
            'Encode::KR::2022_KR'   => '1.06',
            'Encode::MIME::Header'  => '1.09',
            'Encode::Unicode'       => '1.40',
            'Encode::Unicode::UTF7' => '0.02',
            'English'               => '1.01',
            'Errno'                 => '1.09_00',
            'Exporter'              => '5.567',
            'Exporter::Heavy'       => '5.567',
            'ExtUtils::Command'     => '1.05',
            'ExtUtils::Command::MM' => '0.03',
            'ExtUtils::Constant'    => '0.14',
            'ExtUtils::Install'     => '1.32',
            'ExtUtils::Installed'   => '0.08',
            'ExtUtils::Liblist'     => '1.01',
            'ExtUtils::Liblist::Kid'=> '1.3',
            'ExtUtils::MM_Any'      => '0.07',
            'ExtUtils::MM_BeOS'     => '1.04',
            'ExtUtils::MM_Cygwin'   => '1.06',
            'ExtUtils::MM_DOS'      => '0.02',
            'ExtUtils::MM_MacOS'    => '1.07',
            'ExtUtils::MM_NW5'      => '2.06',
            'ExtUtils::MM_OS2'      => '1.04',
            'ExtUtils::MM_UWIN'     => '0.02',
            'ExtUtils::MM_Unix'     => '1.42',
            'ExtUtils::MM_VMS'      => '5.70',
            'ExtUtils::MM_Win32'    => '1.09',
            'ExtUtils::MM_Win95'    => '0.03',
            'ExtUtils::MakeMaker'   => '6.17',
            'ExtUtils::MakeMaker::bytes'=> '0.01',
            'ExtUtils::MakeMaker::vmsish'=> '0.01',
            'ExtUtils::Manifest'    => '1.42',
            'Fcntl'                 => '1.05',
            'File::Basename'        => '2.72',
            'File::Copy'            => '2.06',
            'File::Find'            => '1.05',
            'File::Glob'            => '1.02',
            'File::Path'            => '1.06',
            'File::Spec'            => '0.86',
            'File::Spec::Cygwin'    => '1.1',
            'File::Spec::Epoc'      => '1.1',
            'File::Spec::Functions' => '1.3',
            'File::Spec::Mac'       => '1.4',
            'File::Spec::OS2'       => '1.2',
            'File::Spec::Unix'      => '1.5',
            'File::Spec::VMS'       => '1.4',
            'File::Spec::Win32'     => '1.4',
            'File::Temp'            => '0.14',
            'FileCache'             => '1.03',
            'Filter::Util::Call'    => '1.0601',
            'GDBM_File'             => '1.07',
            'Getopt::Long'          => '2.34',
            'Getopt::Std'           => '1.04',
            'Hash::Util'            => '0.05',
            'I18N::LangTags'        => '0.28',
            'I18N::LangTags::List'  => '0.26',
            'I18N::Langinfo'        => '0.02',
            'IO'                    => '1.21',
            'IO::Dir'               => '1.04',
            'IO::File'              => '1.10',
            'IO::Handle'            => '1.23',
            'IO::Seekable'          => '1.09',
            'IO::Select'            => '1.16',
            'IO::Socket'            => '1.28',
            'IO::Socket::INET'      => '1.27',
            'IO::Socket::UNIX'      => '1.21',
            'IPC::Msg'              => '1.02',
            'IPC::Open3'            => '1.0105',
            'IPC::Semaphore'        => '1.02',
            'IPC::SysV'             => '1.04',
            'JNI'                   => '0.2',
            'List::Util'            => '1.13',
            'Locale::Country'       => '2.61',
            'Locale::Currency'      => '2.21',
            'Locale::Language'      => '2.21',
            'Locale::Maketext'      => '1.06',
            'Locale::Maketext::Guts'=> undef,
            'Locale::Maketext::GutsLoader'=> undef,
            'Locale::Script'        => '2.21',
            'MIME::Base64'          => '2.20',
            'MIME::QuotedPrint'     => '2.20',
            'Math::BigFloat'        => '1.40',
            'Math::BigInt'          => '1.66',
            'Math::BigInt::Calc'    => '0.36',
            'Math::BigInt::Scalar'  => '0.11',
            'Math::BigRat'          => '0.10',
            'Math::Trig'            => '1.02',
            'NDBM_File'             => '1.05',
            'NEXT'                  => '0.60',
            'Net::Cmd'              => '2.24',
            'Net::Domain'           => '2.18',
            'Net::FTP'              => '2.71',
            'Net::FTP::A'           => '1.16',
            'Net::NNTP'             => '2.22',
            'Net::POP3'             => '2.24',
            'Net::Ping'             => '2.31',
            'Net::SMTP'             => '2.26',
            'Net::hostent'          => '1.01',
            'Net::servent'          => '1.01',
            'ODBM_File'             => '1.04',
            'OS2::DLL'              => '1.01',
            'OS2::ExtAttr'          => '0.02',
            'OS2::PrfDB'            => '0.03',
            'OS2::Process'          => '1.01',
            'OS2::REXX'             => '1.02',
            'POSIX'                 => '1.06',
            'PerlIO'                => '1.02',
            'PerlIO::encoding'      => '0.07',
            'PerlIO::scalar'        => '0.02',
            'PerlIO::via'           => '0.02',
            'PerlIO::via::QuotedPrint'=> '0.05',
            'Pod::Checker'          => '1.41',
            'Pod::Find'             => '0.24',
            'Pod::Functions'        => '1.02',
            'Pod::Html'             => '1.0501',
            'Pod::InputObjects'     => '1.14',
            'Pod::LaTeX'            => '0.55',
            'Pod::Man'              => '1.37',
            'Pod::ParseLink'        => '1.06',
            'Pod::ParseUtils'       => '0.3',
            'Pod::Perldoc'          => '3.10',
            'Pod::Perldoc::BaseTo'  => undef,
            'Pod::Perldoc::GetOptsOO'=> undef,
            'Pod::Perldoc::ToChecker'=> undef,
            'Pod::Perldoc::ToMan'   => undef,
            'Pod::Perldoc::ToNroff' => undef,
            'Pod::Perldoc::ToPod'   => undef,
            'Pod::Perldoc::ToRtf'   => undef,
            'Pod::Perldoc::ToText'  => undef,
            'Pod::Perldoc::ToTk'    => undef,
            'Pod::Perldoc::ToXml'   => undef,
            'Pod::PlainText'        => '2.01',
            'Pod::Text'             => '2.21',
            'Pod::Text::Color'      => '1.04',
            'Pod::Text::Overstrike' => '1.1',
            'Pod::Text::Termcap'    => '1.11',
            'Pod::Usage'            => '1.16',
            'SDBM_File'             => '1.04',
            'Safe'                  => '2.10',
            'Scalar::Util'          => '1.13',
            'SelfLoader'            => '1.0904',
            'Shell'                 => '0.5',
            'Socket'                => '1.76',
            'Storable'              => '2.08',
            'Switch'                => '2.10',
            'Symbol'                => '1.05',
            'Sys::Hostname'         => '1.11',
            'Sys::Syslog'           => '0.04',
            'Term::ANSIColor'       => '1.07',
            'Term::Cap'             => '1.08',
            'Term::Complete'        => '1.401',
            'Term::ReadLine'        => '1.01',
            'Test'                  => '1.24',
            'Test::Builder'         => '0.17',
            'Test::Harness'         => '2.30',
            'Test::Harness::Straps' => '0.15',
            'Test::More'            => '0.47',
            'Test::Simple'          => '0.47',
            'Text::Abbrev'          => '1.01',
            'Text::Balanced'        => '1.95',
            'Text::Wrap'            => '2001.09291',
            'Thread::Semaphore'     => '2.01',
            'Tie::Array'            => '1.03',
            'Tie::File'             => '0.97',
            'Tie::RefHash'          => '1.31',
            'Time::HiRes'           => '1.51',
            'Time::Local'           => '1.07',
            'UNIVERSAL'             => '1.01',
            'Unicode'               => '4.0.0',
            'Unicode::Collate'      => '0.28',
            'Unicode::Normalize'    => '0.23',
            'Unicode::UCD'          => '0.21',
            'VMS::Filespec'         => '1.11',
            'XS::APItest'           => '0.02',
            'XSLoader'              => '0.02',
            'attributes'            => '0.06',
            'base'                  => '2.03',
            'bigint'                => '0.04',
            'bignum'                => '0.14',
            'bigrat'                => '0.06',
            'bytes'                 => '1.01',
            'charnames'             => '1.02',
            'diagnostics'           => '1.11',
            'encoding'              => '1.47',
            'fields'                => '2.03',
            'filetest'              => '1.01',
            'if'                    => '0.03',
            'lib'                   => '0.5565',
            'open'                  => '1.02',
            'overload'              => '1.01',
            're'                    => '0.04',
            'sort'                  => '1.02',
            'strict'                => '1.03',
            'threads'               => '1.00',
            'threads::shared'       => '0.91',
            'utf8'                  => '1.02',
            'vmsish'                => '1.01',
            'warnings'              => '1.03',
        },
        removed => {
        }
    },
    5.008002 => {
        delta_from => 5.008001,
        changed => {
            'DB_File'               => '1.807',
            'Devel::PPPort'         => '2.009',
            'Digest::MD5'           => '2.30',
            'I18N::LangTags'        => '0.29',
            'I18N::LangTags::List'  => '0.29',
            'MIME::Base64'          => '2.21',
            'MIME::QuotedPrint'     => '2.21',
            'Net::Domain'           => '2.19',
            'Net::FTP'              => '2.72',
            'Pod::Perldoc'          => '3.11',
            'Time::HiRes'           => '1.52',
            'Unicode::Collate'      => '0.30',
            'Unicode::Normalize'    => '0.25',
        },
        removed => {
        }
    },
    5.008003 => {
        delta_from => 5.008002,
        changed => {
            'Benchmark'             => '1.052',
            'CGI'                   => '3.01',
            'CGI::Carp'             => '1.27',
            'CGI::Fast'             => '1.05',
            'CGI::Pretty'           => '1.08',
            'CGI::Util'             => '1.4',
            'Cwd'                   => '2.12',
            'DB_File'               => '1.808',
            'Devel::PPPort'         => '2.011',
            'Digest'                => '1.05',
            'Digest::MD5'           => '2.33',
            'Digest::base'          => '1.00',
            'Encode'                => '1.99',
            'Exporter'              => '5.57',
            'File::CheckTree'       => '4.3',
            'File::Copy'            => '2.07',
            'File::Find'            => '1.06',
            'File::Spec'            => '0.87',
            'FindBin'               => '1.44',
            'Getopt::Std'           => '1.05',
            'Math::BigFloat'        => '1.42',
            'Math::BigInt'          => '1.68',
            'Math::BigInt::Calc'    => '0.38',
            'Math::BigInt::CalcEmu' => '0.02',
            'OS2::DLL'              => '1.02',
            'POSIX'                 => '1.07',
            'PerlIO'                => '1.03',
            'PerlIO::via::QuotedPrint'=> '0.06',
            'Pod::Html'             => '1.0502',
            'Pod::Parser'           => '1.14',
            'Pod::Perldoc'          => '3.12',
            'Pod::PlainText'        => '2.02',
            'Storable'              => '2.09',
            'Test::Harness'         => '2.40',
            'Test::Harness::Assert' => '0.02',
            'Test::Harness::Iterator'=> '0.02',
            'Test::Harness::Straps' => '0.19',
            'Tie::Hash'             => '1.01',
            'Unicode::Collate'      => '0.33',
            'Unicode::Normalize'    => '0.28',
            'XS::APItest'           => '0.03',
            'base'                  => '2.04',
            'diagnostics'           => '1.12',
            'encoding'              => '1.48',
            'threads'               => '1.01',
            'threads::shared'       => '0.92',
        },
        removed => {
            'Math::BigInt::Scalar'  => 1,
        }
    },
    5.008004 => {
        delta_from => 5.008003,
        changed => {
            'Attribute::Handlers'   => '0.78_01',
            'B::Assembler'          => '0.07',
            'B::Concise'            => '0.60',
            'B::Deparse'            => '0.66',
            'Benchmark'             => '1.06',
            'CGI'                   => '3.04',
            'Carp'                  => '1.02',
            'Cwd'                   => '2.17',
            'DBM_Filter'            => '0.01',
            'DBM_Filter::compress'  => '0.01',
            'DBM_Filter::encode'    => '0.01',
            'DBM_Filter::int32'     => '0.01',
            'DBM_Filter::null'      => '0.01',
            'DBM_Filter::utf8'      => '0.01',
            'Digest'                => '1.06',
            'DynaLoader'            => '1.05',
            'Encode'                => '1.99_01',
            'Encode::CN::HZ'        => '1.0501',
            'Exporter'              => '5.58',
            'Exporter::Heavy'       => '5.57',
            'ExtUtils::Liblist::Kid'=> '1.3001',
            'ExtUtils::MM_NW5'      => '2.07_02',
            'ExtUtils::MM_Win95'    => '0.0301',
            'File::Find'            => '1.07',
            'IO::Handle'            => '1.24',
            'IO::Pipe'              => '1.123',
            'IPC::Open3'            => '1.0106',
            'Locale::Maketext'      => '1.08',
            'MIME::Base64'          => '3.01',
            'MIME::QuotedPrint'     => '3.01',
            'Math::BigFloat'        => '1.44',
            'Math::BigInt'          => '1.70',
            'Math::BigInt::Calc'    => '0.40',
            'Math::BigInt::CalcEmu' => '0.04',
            'Math::BigRat'          => '0.12',
            'ODBM_File'             => '1.05',
            'POSIX'                 => '1.08',
            'Shell'                 => '0.5.2',
            'Socket'                => '1.77',
            'Storable'              => '2.12',
            'Sys::Syslog'           => '0.05',
            'Term::ANSIColor'       => '1.08',
            'Time::HiRes'           => '1.59',
            'Unicode'               => '4.0.1',
            'Unicode::UCD'          => '0.22',
            'Win32'                 => '0.23',
            'base'                  => '2.05',
            'bigint'                => '0.05',
            'bignum'                => '0.15',
            'charnames'             => '1.03',
            'open'                  => '1.03',
            'threads'               => '1.03',
            'utf8'                  => '1.03',
        },
        removed => {
        }
    },
    5.008005 => {
        delta_from => 5.008004,
        changed => {
            'B::Concise'            => '0.61',
            'B::Deparse'            => '0.67',
            'CGI'                   => '3.05',
            'CGI::Carp'             => '1.28',
            'CGI::Util'             => '1.5',
            'Carp'                  => '1.03',
            'Carp::Heavy'           => '1.03',
            'Cwd'                   => '2.19',
            'DB_File'               => '1.809',
            'Digest'                => '1.08',
            'Encode'                => '2.01',
            'Encode::Alias'         => '2.00',
            'Encode::Byte'          => '2.00',
            'Encode::CJKConstants'  => '2.00',
            'Encode::CN'            => '2.00',
            'Encode::CN::HZ'        => '2.01',
            'Encode::Config'        => '2.00',
            'Encode::EBCDIC'        => '2.00',
            'Encode::Encoder'       => '2.00',
            'Encode::Encoding'      => '2.00',
            'Encode::Guess'         => '2.00',
            'Encode::JP'            => '2.00',
            'Encode::JP::H2Z'       => '2.00',
            'Encode::JP::JIS7'      => '2.00',
            'Encode::KR'            => '2.00',
            'Encode::KR::2022_KR'   => '2.00',
            'Encode::MIME::Header'  => '2.00',
            'Encode::Symbol'        => '2.00',
            'Encode::TW'            => '2.00',
            'Encode::Unicode'       => '2.00',
            'Encode::Unicode::UTF7' => '2.01',
            'File::Basename'        => '2.73',
            'File::Copy'            => '2.08',
            'File::Glob'            => '1.03',
            'FileCache'             => '1.04_01',
            'I18N::LangTags'        => '0.33',
            'I18N::LangTags::Detect'=> '1.03',
            'List::Util'            => '1.14',
            'Locale::Constants'     => '2.07',
            'Locale::Country'       => '2.07',
            'Locale::Currency'      => '2.07',
            'Locale::Language'      => '2.07',
            'Locale::Maketext'      => '1.09',
            'Locale::Script'        => '2.07',
            'Net::Cmd'              => '2.26',
            'Net::FTP'              => '2.75',
            'Net::NNTP'             => '2.23',
            'Net::POP3'             => '2.28',
            'Net::SMTP'             => '2.29',
            'Net::Time'             => '2.10',
            'Pod::Checker'          => '1.42',
            'Pod::Find'             => '0.2401',
            'Pod::LaTeX'            => '0.56',
            'Pod::ParseUtils'       => '1.2',
            'Pod::Perldoc'          => '3.13',
            'Safe'                  => '2.11',
            'Scalar::Util'          => '1.14',
            'Shell'                 => '0.6',
            'Storable'              => '2.13',
            'Term::Cap'             => '1.09',
            'Test'                  => '1.25',
            'Test::Harness'         => '2.42',
            'Text::ParseWords'      => '3.22',
            'Text::Wrap'            => '2001.09292',
            'Time::Local'           => '1.10',
            'Unicode::Collate'      => '0.40',
            'Unicode::Normalize'    => '0.30',
            'XS::APItest'           => '0.04',
            'autouse'               => '1.04',
            'base'                  => '2.06',
            'charnames'             => '1.04',
            'diagnostics'           => '1.13',
            'encoding'              => '2.00',
            'threads'               => '1.05',
            'utf8'                  => '1.04',
        },
        removed => {
        }
    },
    5.008006 => {
        delta_from => 5.008005,
        changed => {
            'B'                     => '1.07',
            'B::C'                  => '1.04',
            'B::Concise'            => '0.64',
            'B::Debug'              => '1.02',
            'B::Deparse'            => '0.69',
            'B::Lint'               => '1.03',
            'B::Showlex'            => '1.02',
            'Cwd'                   => '3.01',
            'DB_File'               => '1.810',
            'Data::Dumper'          => '2.121_02',
            'Devel::PPPort'         => '3.03',
            'Devel::Peek'           => '1.02',
            'Encode'                => '2.08',
            'Encode::Alias'         => '2.02',
            'Encode::Encoding'      => '2.02',
            'Encode::JP'            => '2.01',
            'Encode::Unicode'       => '2.02',
            'Exporter::Heavy'       => '5.58',
            'ExtUtils::Constant'    => '0.1401',
            'File::Spec'            => '3.01',
            'File::Spec::Win32'     => '1.5',
            'I18N::LangTags'        => '0.35',
            'I18N::LangTags::List'  => '0.35',
            'MIME::Base64'          => '3.05',
            'MIME::QuotedPrint'     => '3.03',
            'Math::BigFloat'        => '1.47',
            'Math::BigInt'          => '1.73',
            'Math::BigInt::Calc'    => '0.43',
            'Math::BigRat'          => '0.13',
            'Text::ParseWords'      => '3.23',
            'Time::HiRes'           => '1.65',
            'XS::APItest'           => '0.05',
            'diagnostics'           => '1.14',
            'encoding'              => '2.01',
            'open'                  => '1.04',
            'overload'              => '1.02',
        },
        removed => {
        }
    },
    5.008007 => {
        delta_from => 5.008006,
        changed => {
            'B'                     => '1.09',
            'B::Concise'            => '0.65',
            'B::Deparse'            => '0.7',
            'B::Disassembler'       => '1.04',
            'B::Terse'              => '1.03',
            'Benchmark'             => '1.07',
            'CGI'                   => '3.10',
            'CGI::Carp'             => '1.29',
            'CGI::Cookie'           => '1.25',
            'Carp'                  => '1.04',
            'Carp::Heavy'           => '1.04',
            'Class::ISA'            => '0.33',
            'Cwd'                   => '3.05',
            'DB_File'               => '1.811',
            'Data::Dumper'          => '2.121_04',
            'Devel::DProf'          => '20050310.00',
            'Devel::PPPort'         => '3.06',
            'Digest'                => '1.10',
            'Digest::file'          => '0.01',
            'Encode'                => '2.10',
            'Encode::Alias'         => '2.03',
            'Errno'                 => '1.09_01',
            'ExtUtils::Constant'    => '0.16',
            'ExtUtils::Constant::Base'=> '0.01',
            'ExtUtils::Constant::Utils'=> '0.01',
            'ExtUtils::Constant::XS'=> '0.01',
            'File::Find'            => '1.09',
            'File::Glob'            => '1.04',
            'File::Path'            => '1.07',
            'File::Spec'            => '3.05',
            'File::Temp'            => '0.16',
            'FileCache'             => '1.05',
            'IO::File'              => '1.11',
            'IO::Socket::INET'      => '1.28',
            'Math::BigFloat'        => '1.51',
            'Math::BigInt'          => '1.77',
            'Math::BigInt::Calc'    => '0.47',
            'Math::BigInt::CalcEmu' => '0.05',
            'Math::BigRat'          => '0.15',
            'Pod::Find'             => '1.3',
            'Pod::Html'             => '1.0503',
            'Pod::InputObjects'     => '1.3',
            'Pod::LaTeX'            => '0.58',
            'Pod::ParseUtils'       => '1.3',
            'Pod::Parser'           => '1.3',
            'Pod::Perldoc'          => '3.14',
            'Pod::Select'           => '1.3',
            'Pod::Usage'            => '1.3',
            'SelectSaver'           => '1.01',
            'Symbol'                => '1.06',
            'Sys::Syslog'           => '0.06',
            'Term::ANSIColor'       => '1.09',
            'Term::Complete'        => '1.402',
            'Test::Builder'         => '0.22',
            'Test::Harness'         => '2.48',
            'Test::Harness::Point'  => '0.01',
            'Test::Harness::Straps' => '0.23',
            'Test::More'            => '0.54',
            'Test::Simple'          => '0.54',
            'Text::ParseWords'      => '3.24',
            'Text::Wrap'            => '2001.09293',
            'Tie::RefHash'          => '1.32',
            'Time::HiRes'           => '1.66',
            'Time::Local'           => '1.11',
            'Unicode'               => '4.1.0',
            'Unicode::Normalize'    => '0.32',
            'Unicode::UCD'          => '0.23',
            'Win32'                 => '0.24',
            'XS::APItest'           => '0.06',
            'base'                  => '2.07',
            'bigint'                => '0.07',
            'bignum'                => '0.17',
            'bigrat'                => '0.08',
            'bytes'                 => '1.02',
            'constant'              => '1.05',
            'overload'              => '1.03',
            'threads::shared'       => '0.93',
            'utf8'                  => '1.05',
        },
        removed => {
            'JNI'                   => 1,
            'JPL::AutoLoader'       => 1,
            'JPL::Class'            => 1,
            'JPL::Compile'          => 1,
        }
    },
    5.008008 => {
        delta_from => 5.008007,
        changed => {
            'Attribute::Handlers'   => '0.78_02',
            'B'                     => '1.09_01',
            'B::Bblock'             => '1.02_01',
            'B::Bytecode'           => '1.01_01',
            'B::C'                  => '1.04_01',
            'B::CC'                 => '1.00_01',
            'B::Concise'            => '0.66',
            'B::Debug'              => '1.02_01',
            'B::Deparse'            => '0.71',
            'B::Disassembler'       => '1.05',
            'B::Terse'              => '1.03_01',
            'ByteLoader'            => '0.06',
            'CGI'                   => '3.15',
            'CGI::Cookie'           => '1.26',
            'CPAN'                  => '1.76_02',
            'Cwd'                   => '3.12',
            'DB'                    => '1.01',
            'DB_File'               => '1.814',
            'Data::Dumper'          => '2.121_08',
            'Devel::DProf'          => '20050603.00',
            'Devel::PPPort'         => '3.06_01',
            'Devel::Peek'           => '1.03',
            'Digest'                => '1.14',
            'Digest::MD5'           => '2.36',
            'Digest::file'          => '1.00',
            'Dumpvalue'             => '1.12',
            'Encode'                => '2.12',
            'Encode::Alias'         => '2.04',
            'Encode::Config'        => '2.01',
            'Encode::MIME::Header'  => '2.01',
            'Encode::MIME::Header::ISO_2022_JP'=> '1.01',
            'English'               => '1.02',
            'ExtUtils::Command'     => '1.09',
            'ExtUtils::Command::MM' => '0.05',
            'ExtUtils::Constant'    => '0.17',
            'ExtUtils::Embed'       => '1.26',
            'ExtUtils::Install'     => '1.33',
            'ExtUtils::Liblist::Kid'=> '1.3',
            'ExtUtils::MM'          => '0.05',
            'ExtUtils::MM_AIX'      => '0.03',
            'ExtUtils::MM_Any'      => '0.13',
            'ExtUtils::MM_BeOS'     => '1.05',
            'ExtUtils::MM_Cygwin'   => '1.08',
            'ExtUtils::MM_MacOS'    => '1.08',
            'ExtUtils::MM_NW5'      => '2.08',
            'ExtUtils::MM_OS2'      => '1.05',
            'ExtUtils::MM_QNX'      => '0.02',
            'ExtUtils::MM_Unix'     => '1.50',
            'ExtUtils::MM_VMS'      => '5.73',
            'ExtUtils::MM_VOS'      => '0.02',
            'ExtUtils::MM_Win32'    => '1.12',
            'ExtUtils::MM_Win95'    => '0.04',
            'ExtUtils::MakeMaker'   => '6.30',
            'ExtUtils::MakeMaker::Config'=> '0.02',
            'ExtUtils::Manifest'    => '1.46',
            'File::Basename'        => '2.74',
            'File::Copy'            => '2.09',
            'File::Find'            => '1.10',
            'File::Glob'            => '1.05',
            'File::Path'            => '1.08',
            'File::Spec'            => '3.12',
            'File::Spec::Win32'     => '1.6',
            'FileCache'             => '1.06',
            'Filter::Simple'        => '0.82',
            'FindBin'               => '1.47',
            'GDBM_File'             => '1.08',
            'Getopt::Long'          => '2.35',
            'IO'                    => '1.22',
            'IO::Dir'               => '1.05',
            'IO::File'              => '1.13',
            'IO::Handle'            => '1.25',
            'IO::Pipe'              => '1.13',
            'IO::Poll'              => '0.07',
            'IO::Seekable'          => '1.10',
            'IO::Select'            => '1.17',
            'IO::Socket'            => '1.29',
            'IO::Socket::INET'      => '1.29',
            'IO::Socket::UNIX'      => '1.22',
            'IPC::Open2'            => '1.02',
            'IPC::Open3'            => '1.02',
            'List::Util'            => '1.18',
            'MIME::Base64'          => '3.07',
            'MIME::QuotedPrint'     => '3.07',
            'Math::Complex'         => '1.35',
            'Math::Trig'            => '1.03',
            'NDBM_File'             => '1.06',
            'ODBM_File'             => '1.06',
            'OS2::PrfDB'            => '0.04',
            'OS2::Process'          => '1.02',
            'OS2::REXX'             => '1.03',
            'Opcode'                => '1.06',
            'POSIX'                 => '1.09',
            'PerlIO'                => '1.04',
            'PerlIO::encoding'      => '0.09',
            'PerlIO::scalar'        => '0.04',
            'PerlIO::via'           => '0.03',
            'Pod::Checker'          => '1.43',
            'Pod::Find'             => '1.34',
            'Pod::Functions'        => '1.03',
            'Pod::Html'             => '1.0504',
            'Pod::ParseUtils'       => '1.33',
            'Pod::Parser'           => '1.32',
            'Pod::Usage'            => '1.33',
            'SDBM_File'             => '1.05',
            'Safe'                  => '2.12',
            'Scalar::Util'          => '1.18',
            'Socket'                => '1.78',
            'Storable'              => '2.15',
            'Switch'                => '2.10_01',
            'Sys::Syslog'           => '0.13',
            'Term::ANSIColor'       => '1.10',
            'Term::ReadLine'        => '1.02',
            'Test::Builder'         => '0.32',
            'Test::Builder::Module' => '0.02',
            'Test::Builder::Tester' => '1.02',
            'Test::Builder::Tester::Color'=> undef,
            'Test::Harness'         => '2.56',
            'Test::Harness::Straps' => '0.26',
            'Test::More'            => '0.62',
            'Test::Simple'          => '0.62',
            'Text::Tabs'            => '2005.0824',
            'Text::Wrap'            => '2005.082401',
            'Tie::Hash'             => '1.02',
            'Time::HiRes'           => '1.86',
            'Unicode::Collate'      => '0.52',
            'Unicode::UCD'          => '0.24',
            'User::grent'           => '1.01',
            'Win32'                 => '0.2601',
            'XS::APItest'           => '0.08',
            'XS::Typemap'           => '0.02',
            'XSLoader'              => '0.06',
            'attrs'                 => '1.02',
            'autouse'               => '1.05',
            'blib'                  => '1.03',
            'charnames'             => '1.05',
            'diagnostics'           => '1.15',
            'encoding'              => '2.02',
            'if'                    => '0.05',
            'open'                  => '1.05',
            'ops'                   => '1.01',
            'overload'              => '1.04',
            're'                    => '0.05',
            'threads'               => '1.07',
            'threads::shared'       => '0.94',
            'utf8'                  => '1.06',
            'vmsish'                => '1.02',
            'warnings'              => '1.05',
            'warnings::register'    => '1.01',
        },
        removed => {
        }
    },
    5.008009 => {
        delta_from => 5.008008,
        changed => {
            'Attribute::Handlers'   => '0.78_03',
            'AutoLoader'            => '5.67',
            'AutoSplit'             => '1.06',
            'B'                     => '1.19',
            'B::Asmdata'            => '1.02',
            'B::Assembler'          => '0.08',
            'B::C'                  => '1.05',
            'B::Concise'            => '0.76',
            'B::Debug'              => '1.05',
            'B::Deparse'            => '0.87',
            'B::Lint'               => '1.11',
            'B::Lint::Debug'        => undef,
            'B::Terse'              => '1.05',
            'Benchmark'             => '1.1',
            'CGI'                   => '3.42',
            'CGI::Carp'             => '1.30_01',
            'CGI::Cookie'           => '1.29',
            'CGI::Fast'             => '1.07',
            'CGI::Util'             => '1.5_01',
            'CPAN'                  => '1.9301',
            'CPAN::Debug'           => '5.5',
            'CPAN::DeferedCode'     => '5.50',
            'CPAN::Distroprefs'     => '6',
            'CPAN::FirstTime'       => '5.5_01',
            'CPAN::HandleConfig'    => '5.5',
            'CPAN::Kwalify'         => '5.50',
            'CPAN::Nox'             => '5.50',
            'CPAN::Queue'           => '5.5',
            'CPAN::Tarzip'          => '5.5',
            'CPAN::Version'         => '5.5',
            'Carp'                  => '1.10',
            'Carp::Heavy'           => '1.10',
            'Cwd'                   => '3.29',
            'DBM_Filter'            => '0.02',
            'DBM_Filter::compress'  => '0.02',
            'DBM_Filter::encode'    => '0.02',
            'DBM_Filter::int32'     => '0.02',
            'DBM_Filter::null'      => '0.02',
            'DBM_Filter::utf8'      => '0.02',
            'DB_File'               => '1.817',
            'Data::Dumper'          => '2.121_17',
            'Devel::DProf'          => '20080331.00',
            'Devel::InnerPackage'   => '0.3',
            'Devel::PPPort'         => '3.14',
            'Devel::Peek'           => '1.04',
            'Digest'                => '1.15',
            'Digest::MD5'           => '2.37',
            'DirHandle'             => '1.02',
            'DynaLoader'            => '1.09',
            'Encode'                => '2.26',
            'Encode::Alias'         => '2.10',
            'Encode::Byte'          => '2.03',
            'Encode::CJKConstants'  => '2.02',
            'Encode::CN'            => '2.02',
            'Encode::CN::HZ'        => '2.05',
            'Encode::Config'        => '2.05',
            'Encode::EBCDIC'        => '2.02',
            'Encode::Encoder'       => '2.01',
            'Encode::Encoding'      => '2.05',
            'Encode::GSM0338'       => '2.01',
            'Encode::Guess'         => '2.02',
            'Encode::JP'            => '2.03',
            'Encode::JP::H2Z'       => '2.02',
            'Encode::JP::JIS7'      => '2.04',
            'Encode::KR'            => '2.02',
            'Encode::KR::2022_KR'   => '2.02',
            'Encode::MIME::Header'  => '2.05',
            'Encode::MIME::Header::ISO_2022_JP'=> '1.03',
            'Encode::MIME::Name'    => '1.01',
            'Encode::Symbol'        => '2.02',
            'Encode::TW'            => '2.02',
            'Encode::Unicode'       => '2.05',
            'Encode::Unicode::UTF7' => '2.04',
            'English'               => '1.03',
            'Errno'                 => '1.10',
            'Exporter'              => '5.63',
            'Exporter::Heavy'       => '5.63',
            'ExtUtils::Command'     => '1.15',
            'ExtUtils::Command::MM' => '6.48',
            'ExtUtils::Constant'    => '0.21',
            'ExtUtils::Constant::Base'=> '0.04',
            'ExtUtils::Constant::ProxySubs'=> '0.06',
            'ExtUtils::Constant::Utils'=> '0.02',
            'ExtUtils::Constant::XS'=> '0.02',
            'ExtUtils::Embed'       => '1.28',
            'ExtUtils::Install'     => '1.50_01',
            'ExtUtils::Installed'   => '1.43',
            'ExtUtils::Liblist'     => '6.48',
            'ExtUtils::Liblist::Kid'=> '6.48',
            'ExtUtils::MM'          => '6.48',
            'ExtUtils::MM_AIX'      => '6.48',
            'ExtUtils::MM_Any'      => '6.48',
            'ExtUtils::MM_BeOS'     => '6.48',
            'ExtUtils::MM_Cygwin'   => '6.48',
            'ExtUtils::MM_DOS'      => '6.48',
            'ExtUtils::MM_Darwin'   => '6.48',
            'ExtUtils::MM_MacOS'    => '6.48',
            'ExtUtils::MM_NW5'      => '6.48',
            'ExtUtils::MM_OS2'      => '6.48',
            'ExtUtils::MM_QNX'      => '6.48',
            'ExtUtils::MM_UWIN'     => '6.48',
            'ExtUtils::MM_Unix'     => '6.48',
            'ExtUtils::MM_VMS'      => '6.48',
            'ExtUtils::MM_VOS'      => '6.48',
            'ExtUtils::MM_Win32'    => '6.48',
            'ExtUtils::MM_Win95'    => '6.48',
            'ExtUtils::MY'          => '6.48',
            'ExtUtils::MakeMaker'   => '6.48',
            'ExtUtils::MakeMaker::Config'=> '6.48',
            'ExtUtils::MakeMaker::bytes'=> '6.48',
            'ExtUtils::MakeMaker::vmsish'=> '6.48',
            'ExtUtils::Manifest'    => '1.55',
            'ExtUtils::Mkbootstrap' => '6.48',
            'ExtUtils::Mksymlists'  => '6.48',
            'ExtUtils::Packlist'    => '1.43',
            'ExtUtils::ParseXS'     => '2.19',
            'ExtUtils::XSSymSet'    => '1.1',
            'ExtUtils::testlib'     => '6.48',
            'Fatal'                 => '1.06',
            'Fcntl'                 => '1.06',
            'File::Basename'        => '2.77',
            'File::CheckTree'       => '4.4',
            'File::Compare'         => '1.1005',
            'File::Copy'            => '2.13',
            'File::DosGlob'         => '1.01',
            'File::Find'            => '1.13',
            'File::Glob'            => '1.06',
            'File::Path'            => '2.07_02',
            'File::Spec'            => '3.29',
            'File::Spec::Cygwin'    => '3.29',
            'File::Spec::Epoc'      => '3.29',
            'File::Spec::Functions' => '3.29',
            'File::Spec::Mac'       => '3.29',
            'File::Spec::OS2'       => '3.29',
            'File::Spec::Unix'      => '3.29',
            'File::Spec::VMS'       => '3.29',
            'File::Spec::Win32'     => '3.29',
            'File::Temp'            => '0.20',
            'File::stat'            => '1.01',
            'FileCache'             => '1.07',
            'Filter::Simple'        => '0.83',
            'Filter::Util::Call'    => '1.07',
            'FindBin'               => '1.49',
            'GDBM_File'             => '1.09',
            'Getopt::Long'          => '2.37',
            'Getopt::Std'           => '1.06',
            'Hash::Util'            => '0.06',
            'IO'                    => '1.23',
            'IO::Dir'               => '1.06',
            'IO::File'              => '1.14',
            'IO::Handle'            => '1.27',
            'IO::Socket'            => '1.30',
            'IO::Socket::INET'      => '1.31',
            'IO::Socket::UNIX'      => '1.23',
            'IPC::Msg'              => '2.00',
            'IPC::Open2'            => '1.03',
            'IPC::Open3'            => '1.03',
            'IPC::Semaphore'        => '2.00',
            'IPC::SharedMem'        => '2.00',
            'IPC::SysV'             => '2.00',
            'List::Util'            => '1.19',
            'Locale::Maketext'      => '1.13',
            'Locale::Maketext::Guts'=> '1.13',
            'Locale::Maketext::GutsLoader'=> '1.13',
            'Math::BigFloat'        => '1.60',
            'Math::BigInt'          => '1.89',
            'Math::BigInt::Calc'    => '0.52',
            'Math::BigRat'          => '0.22',
            'Math::Complex'         => '1.54',
            'Math::Trig'            => '1.18',
            'Module::CoreList'      => '2.17',
            'Module::Pluggable'     => '3.8',
            'Module::Pluggable::Object'=> '3.6',
            'NDBM_File'             => '1.07',
            'NEXT'                  => '0.61',
            'Net::Cmd'              => '2.29',
            'Net::Config'           => '1.11',
            'Net::Domain'           => '2.20',
            'Net::FTP'              => '2.77',
            'Net::FTP::A'           => '1.18',
            'Net::NNTP'             => '2.24',
            'Net::POP3'             => '2.29',
            'Net::Ping'             => '2.35',
            'Net::SMTP'             => '2.31',
            'O'                     => '1.01',
            'ODBM_File'             => '1.07',
            'OS2::DLL'              => '1.03',
            'OS2::Process'          => '1.03',
            'Opcode'                => '1.0601',
            'POSIX'                 => '1.15',
            'PerlIO'                => '1.05',
            'PerlIO::encoding'      => '0.11',
            'PerlIO::scalar'        => '0.06',
            'PerlIO::via'           => '0.05',
            'Pod::Html'             => '1.09',
            'Pod::ParseUtils'       => '1.35',
            'Pod::Parser'           => '1.35',
            'Pod::Select'           => '1.35',
            'Pod::Usage'            => '1.35',
            'SDBM_File'             => '1.06',
            'Safe'                  => '2.16',
            'Scalar::Util'          => '1.19',
            'SelfLoader'            => '1.17',
            'Shell'                 => '0.72',
            'Socket'                => '1.81',
            'Storable'              => '2.19',
            'Switch'                => '2.13',
            'Sys::Syslog'           => '0.27',
            'Sys::Syslog::win32::Win32'=> undef,
            'Term::ANSIColor'       => '1.12',
            'Term::Cap'             => '1.12',
            'Term::ReadLine'        => '1.03',
            'Test::Builder'         => '0.80',
            'Test::Builder::Module' => '0.80',
            'Test::Builder::Tester' => '1.13',
            'Test::Harness'         => '2.64',
            'Test::Harness::Results'=> '0.01_01',
            'Test::Harness::Straps' => '0.26_01',
            'Test::Harness::Util'   => '0.01',
            'Test::More'            => '0.80',
            'Test::Simple'          => '0.80',
            'Text::Balanced'        => '1.98',
            'Text::ParseWords'      => '3.27',
            'Text::Soundex'         => '3.03',
            'Text::Tabs'            => '2007.1117',
            'Text::Wrap'            => '2006.1117',
            'Thread'                => '2.01',
            'Thread::Queue'         => '2.11',
            'Thread::Semaphore'     => '2.09',
            'Tie::Handle'           => '4.2',
            'Tie::Hash'             => '1.03',
            'Tie::Memoize'          => '1.1',
            'Tie::RefHash'          => '1.38',
            'Tie::Scalar'           => '1.01',
            'Tie::StdHandle'        => '4.2',
            'Time::HiRes'           => '1.9715',
            'Time::Local'           => '1.1901',
            'Time::gmtime'          => '1.03',
            'Unicode'               => '5.1.0',
            'Unicode::Normalize'    => '1.02',
            'Unicode::UCD'          => '0.25',
            'VMS::DCLsym'           => '1.03',
            'VMS::Stdio'            => '2.4',
            'Win32'                 => '0.38',
            'Win32API::File'        => '0.1001_01',
            'Win32API::File::ExtUtils::Myconst2perl'=> '1',
            'Win32CORE'             => '0.02',
            'XS::APItest'           => '0.15',
            'XS::Typemap'           => '0.03',
            'XSLoader'              => '0.10',
            'attributes'            => '0.09',
            'autouse'               => '1.06',
            'base'                  => '2.13',
            'bigint'                => '0.23',
            'bignum'                => '0.23',
            'bigrat'                => '0.23',
            'blib'                  => '1.04',
            'charnames'             => '1.06',
            'constant'              => '1.17',
            'diagnostics'           => '1.16',
            'encoding'              => '2.6_01',
            'fields'                => '2.12',
            'filetest'              => '1.02',
            'lib'                   => '0.61',
            'open'                  => '1.06',
            'ops'                   => '1.02',
            'overload'              => '1.06',
            're'                    => '0.0601',
            'sigtrap'               => '1.04',
            'threads'               => '1.71',
            'threads::shared'       => '1.27',
            'utf8'                  => '1.07',
            'warnings'              => '1.05_01',
        },
        removed => {
        }
    },
    5.009 => {
        delta_from => 5.008002,
        changed => {
            'B'                     => '1.03',
            'B::C'                  => '1.03',
            'B::Concise'            => '0.57',
            'B::Deparse'            => '0.65',
            'DB_File'               => '1.806',
            'Devel::PPPort'         => '2.008',
            'English'               => '1.02',
            'Fatal'                 => '1.04',
            'OS2::DLL'              => '1.02',
            'Opcode'                => '1.06',
            'Time::HiRes'           => '1.51',
            'Unicode::Collate'      => '0.28',
            'Unicode::Normalize'    => '0.23',
            'XSLoader'              => '0.03',
            'assertions'            => '0.01',
            'assertions::activate'  => '0.01',
            'overload'              => '1.02',
            'version'               => '0.29',
        },
        removed => {
        }
    },
    5.009001 => {
        delta_from => 5.008004,
        changed => {
            'B'                     => '1.05',
            'B::Assembler'          => '0.06',
            'B::C'                  => '1.04',
            'B::Concise'            => '0.59',
            'B::Debug'              => '1.02',
            'B::Deparse'            => '0.65',
            'DB_File'               => '1.808_01',
            'Devel::PPPort'         => '2.011_01',
            'Digest'                => '1.05',
            'DynaLoader'            => '1.04',
            'English'               => '1.02',
            'Exporter::Heavy'       => '5.567',
            'ExtUtils::Command'     => '1.07',
            'ExtUtils::Liblist::Kid'=> '1.3',
            'ExtUtils::MM_Any'      => '0.0901',
            'ExtUtils::MM_Cygwin'   => '1.07',
            'ExtUtils::MM_NW5'      => '2.07_01',
            'ExtUtils::MM_Unix'     => '1.45_01',
            'ExtUtils::MM_VMS'      => '5.71_01',
            'ExtUtils::MM_Win32'    => '1.10_01',
            'ExtUtils::MM_Win95'    => '0.03',
            'ExtUtils::MakeMaker'   => '6.21_02',
            'ExtUtils::Manifest'    => '1.43',
            'Fatal'                 => '1.04',
            'Getopt::Long'          => '2.3401',
            'IO::Handle'            => '1.23',
            'IO::Pipe'              => '1.122',
            'IPC::Open3'            => '1.0105',
            'MIME::Base64'          => '3.00_01',
            'MIME::QuotedPrint'     => '3.00',
            'Memoize'               => '1.01_01',
            'ODBM_File'             => '1.04',
            'Opcode'                => '1.06',
            'POSIX'                 => '1.07',
            'Storable'              => '2.11',
            'Time::HiRes'           => '1.56',
            'Time::Local'           => '1.07_94',
            'UNIVERSAL'             => '1.02',
            'Unicode'               => '4.0.0',
            'Unicode::UCD'          => '0.21',
            'XSLoader'              => '0.03',
            'assertions'            => '0.01',
            'assertions::activate'  => '0.01',
            'base'                  => '2.04',
            'if'                    => '0.0401',
            'open'                  => '1.02',
            'overload'              => '1.02',
            'threads'               => '1.02',
            'utf8'                  => '1.02',
            'version'               => '0.36',
        },
        removed => {
        }
    },
    5.009002 => {
        delta_from => 5.008007,
        changed => {
            'B'                     => '1.07',
            'B::Concise'            => '0.64',
            'B::Deparse'            => '0.69',
            'B::Disassembler'       => '1.03',
            'B::Terse'              => '1.02',
            'CGI'                   => '3.07',
            'Config::Extensions'    => '0.01',
            'Devel::DProf'          => '20030813.00',
            'DynaLoader'            => '1.07',
            'Encode'                => '2.09',
            'Encode::Alias'         => '2.02',
            'English'               => '1.03',
            'Exporter'              => '5.59',
            'Exporter::Heavy'       => '5.59',
            'ExtUtils::Command'     => '1.07',
            'ExtUtils::Command::MM' => '0.03_01',
            'ExtUtils::Embed'       => '1.26',
            'ExtUtils::Liblist::Kid'=> '1.3',
            'ExtUtils::MM_Any'      => '0.10',
            'ExtUtils::MM_Cygwin'   => '1.07',
            'ExtUtils::MM_MacOS'    => '1.08',
            'ExtUtils::MM_NW5'      => '2.07',
            'ExtUtils::MM_Unix'     => '1.46_01',
            'ExtUtils::MM_VMS'      => '5.71',
            'ExtUtils::MM_Win32'    => '1.10',
            'ExtUtils::MM_Win95'    => '0.03',
            'ExtUtils::MakeMaker'   => '6.25',
            'ExtUtils::Manifest'    => '1.44',
            'Fatal'                 => '1.04',
            'File::Path'            => '1.06',
            'FileCache'             => '1.04_01',
            'Getopt::Long'          => '2.3401',
            'IO::File'              => '1.10',
            'IO::Socket::INET'      => '1.27',
            'Math::BigFloat'        => '1.49',
            'Math::BigInt'          => '1.75',
            'Math::BigInt::Calc'    => '0.45',
            'Math::BigRat'          => '0.14',
            'Memoize'               => '1.01_01',
            'Module::CoreList'      => '1.99',
            'NEXT'                  => '0.60_01',
            'Opcode'                => '1.06',
            'Pod::Html'             => '1.0502',
            'Scalar::Util'          => '1.14_1',
            'Storable'              => '2.14',
            'Symbol'                => '1.05',
            'Test::Harness'         => '2.46',
            'Test::Harness::Straps' => '0.20_01',
            'Text::Balanced'        => '1.95_01',
            'Text::Wrap'            => '2001.09292',
            'UNIVERSAL'             => '1.02',
            'Unicode'               => '4.0.1',
            'Unicode::Normalize'    => '0.30',
            'Unicode::UCD'          => '0.22',
            'Win32'                 => '0.23',
            'XS::APItest'           => '0.05',
            'XSLoader'              => '0.03',
            'assertions'            => '0.01',
            'assertions::activate'  => '0.01',
            'base'                  => '2.06',
            'bigint'                => '0.06',
            'bignum'                => '0.16',
            'bigrat'                => '0.07',
            'bytes'                 => '1.01',
            'encoding::warnings'    => '0.05',
            'if'                    => '0.0401',
            're'                    => '0.05',
            'threads::shared'       => '0.92',
            'utf8'                  => '1.04',
            'version'               => '0.42',
            'warnings'              => '1.04',
        },
        removed => {
            'Test::Harness::Point'  => 1,
        }
    },
    5.009003 => {
        delta_from => 5.008008,
        changed => {
            'Archive::Tar'          => '1.26_01',
            'Archive::Tar::Constant'=> '0.02',
            'Archive::Tar::File'    => '0.02',
            'AutoSplit'             => '1.04_01',
            'B'                     => '1.10',
            'B::Bblock'             => '1.02',
            'B::Bytecode'           => '1.01',
            'B::C'                  => '1.04',
            'B::CC'                 => '1.00',
            'B::Concise'            => '0.67',
            'B::Debug'              => '1.02',
            'B::Deparse'            => '0.73',
            'B::Lint'               => '1.04',
            'B::Terse'              => '1.03',
            'CGI'                   => '3.15_01',
            'CPAN'                  => '1.83_58',
            'CPAN::Debug'           => '4.44',
            'CPAN::FirstTime'       => '4.50',
            'CPAN::HandleConfig'    => '4.31',
            'CPAN::Nox'             => '2.31',
            'CPAN::Tarzip'          => '3.36',
            'CPAN::Version'         => '2.55',
            'Carp'                  => '1.05',
            'Carp::Heavy'           => '1.05',
            'Compress::Zlib'        => '2.000_07',
            'Compress::Zlib::Common'=> '2.000_07',
            'Compress::Zlib::Compress::Gzip::Constants'=> '2.000_07',
            'Compress::Zlib::Compress::Zip::Constants'=> '1.00',
            'Compress::Zlib::CompressPlugin::Deflate'=> '2.000_05',
            'Compress::Zlib::CompressPlugin::Identity'=> '2.000_05',
            'Compress::Zlib::File::GlobMapper'=> '0.000_02',
            'Compress::Zlib::FileConstants'=> '2.000_07',
            'Compress::Zlib::IO::Compress::Base'=> '2.000_05',
            'Compress::Zlib::IO::Compress::Deflate'=> '2.000_07',
            'Compress::Zlib::IO::Compress::Gzip'=> '2.000_07',
            'Compress::Zlib::IO::Compress::RawDeflate'=> '2.000_07',
            'Compress::Zlib::IO::Compress::Zip'=> '2.000_04',
            'Compress::Zlib::IO::Uncompress::AnyInflate'=> '2.000_07',
            'Compress::Zlib::IO::Uncompress::AnyUncompress'=> '2.000_05',
            'Compress::Zlib::IO::Uncompress::Base'=> '2.000_05',
            'Compress::Zlib::IO::Uncompress::Gunzip'=> '2.000_07',
            'Compress::Zlib::IO::Uncompress::Inflate'=> '2.000_07',
            'Compress::Zlib::IO::Uncompress::RawInflate'=> '2.000_07',
            'Compress::Zlib::IO::Uncompress::Unzip'=> '2.000_05',
            'Compress::Zlib::ParseParameters'=> '2.000_07',
            'Compress::Zlib::UncompressPlugin::Identity'=> '2.000_05',
            'Compress::Zlib::UncompressPlugin::Inflate'=> '2.000_05',
            'Config::Extensions'    => '0.01',
            'Cwd'                   => '3.15',
            'Devel::PPPort'         => '3.08',
            'Digest::SHA'           => '5.32',
            'DirHandle'             => '1.01',
            'DynaLoader'            => '1.07',
            'Encode'                => '2.14',
            'Encode::CN::HZ'        => '2.02',
            'Encode::MIME::Header'  => '2.02',
            'English'               => '1.04',
            'Exporter'              => '5.59',
            'Exporter::Heavy'       => '5.59',
            'ExtUtils::CBuilder'    => '0.15',
            'ExtUtils::CBuilder::Base'=> '0.12',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.12',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.12',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.12',
            'ExtUtils::CBuilder::Platform::aix'=> '0.12',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.12',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.12',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.01',
            'ExtUtils::CBuilder::Platform::os2'=> '0.13',
            'ExtUtils::Command::MM' => '0.05_01',
            'ExtUtils::Constant'    => '0.2',
            'ExtUtils::Constant::Base'=> '0.02',
            'ExtUtils::Constant::ProxySubs'=> '0.01',
            'ExtUtils::Constant::XS'=> '0.02',
            'ExtUtils::MM_Any'      => '0.13_01',
            'ExtUtils::MM_Unix'     => '1.50_01',
            'ExtUtils::MakeMaker'   => '6.30_01',
            'ExtUtils::ParseXS'     => '2.15_02',
            'Fatal'                 => '1.04',
            'File::Compare'         => '1.1005',
            'File::Spec'            => '3.15',
            'File::Temp'            => '0.16_01',
            'IO::File'              => '1.13_01',
            'IO::Handle'            => '1.26',
            'IO::Socket'            => '1.29_01',
            'IO::Socket::INET'      => '1.29_02',
            'IO::Socket::UNIX'      => '1.22_01',
            'IO::Zlib'              => '1.04_02',
            'Locale::Maketext'      => '1.10_01',
            'Math::BigInt::FastCalc'=> '0.10',
            'Memoize'               => '1.01_01',
            'Module::CoreList'      => '2.02',
            'Moped::Msg'            => '0.01',
            'NEXT'                  => '0.60_01',
            'Net::Cmd'              => '2.26_01',
            'Net::Domain'           => '2.19_01',
            'Net::Ping'             => '2.31_04',
            'Opcode'                => '1.08',
            'POSIX'                 => '1.10',
            'Pod::Escapes'          => '1.04',
            'Pod::Man'              => '2.04',
            'Pod::Perldoc'          => '3.14_01',
            'Pod::Simple'           => '3.04',
            'Pod::Simple::BlackBox' => undef,
            'Pod::Simple::Checker'  => '2.02',
            'Pod::Simple::Debug'    => undef,
            'Pod::Simple::DumpAsText'=> '2.02',
            'Pod::Simple::DumpAsXML'=> '2.02',
            'Pod::Simple::HTML'     => '3.03',
            'Pod::Simple::HTMLBatch'=> '3.02',
            'Pod::Simple::HTMLLegacy'=> '5.01',
            'Pod::Simple::LinkSection'=> undef,
            'Pod::Simple::Methody'  => '2.02',
            'Pod::Simple::Progress' => '1.01',
            'Pod::Simple::PullParser'=> '2.02',
            'Pod::Simple::PullParserEndToken'=> undef,
            'Pod::Simple::PullParserStartToken'=> undef,
            'Pod::Simple::PullParserTextToken'=> undef,
            'Pod::Simple::PullParserToken'=> '2.02',
            'Pod::Simple::RTF'      => '2.02',
            'Pod::Simple::Search'   => '3.04',
            'Pod::Simple::SimpleTree'=> '2.02',
            'Pod::Simple::Text'     => '2.02',
            'Pod::Simple::TextContent'=> '2.02',
            'Pod::Simple::TiedOutFH'=> undef,
            'Pod::Simple::Transcode'=> undef,
            'Pod::Simple::TranscodeDumb'=> '2.02',
            'Pod::Simple::TranscodeSmart'=> undef,
            'Pod::Simple::XMLOutStream'=> '2.02',
            'Pod::Text'             => '3.01',
            'Pod::Text::Color'      => '2.01',
            'Pod::Text::Overstrike' => '2',
            'Pod::Text::Termcap'    => '2.01',
            'Pod::Usage'            => '1.33_01',
            'SelfLoader'            => '1.0905',
            'Storable'              => '2.15_02',
            'Test::Builder::Module' => '0.03',
            'Text::Balanced'        => '1.95_01',
            'Tie::File'             => '0.97_01',
            'UNIVERSAL'             => '1.03',
            'XS::APItest'           => '0.09',
            'assertions'            => '0.02',
            'assertions::activate'  => '0.02',
            'assertions::compat'    => undef,
            'constant'              => '1.07',
            'encoding::warnings'    => '0.05',
            'feature'               => '1.00',
            're'                    => '0.06',
            'sort'                  => '2.00',
            'version'               => '0.53',
        },
        removed => {
        }
    },
    5.009004 => {
        delta_from => 5.009003,
        changed => {
            'Archive::Tar'          => '1.30_01',
            'AutoLoader'            => '5.61',
            'B'                     => '1.11',
            'B::Bytecode'           => '1.02',
            'B::C'                  => '1.05',
            'B::Concise'            => '0.69',
            'B::Deparse'            => '0.76',
            'B::Lint'               => '1.08',
            'Benchmark'             => '1.08',
            'CGI'                   => '3.20',
            'CGI::Cookie'           => '1.27',
            'CGI::Fast'             => '1.07',
            'CPAN'                  => '1.87_55',
            'CPAN::Debug'           => '5.400561',
            'CPAN::FirstTime'       => '5.400742',
            'CPAN::HandleConfig'    => '5.400740',
            'CPAN::Nox'             => '5.400561',
            'CPAN::Tarzip'          => '5.400714',
            'CPAN::Version'         => '5.400561',
            'Compress::Raw::Zlib'   => '2.000_13',
            'Compress::Zlib'        => '2.000_13',
            'Cwd'                   => '3.19',
            'Devel::PPPort'         => '3.10',
            'Digest'                => '1.15',
            'Digest::SHA'           => '5.43',
            'Encode'                => '2.18_01',
            'Encode::Alias'         => '2.06',
            'Encode::Byte'          => '2.02',
            'Encode::CJKConstants'  => '2.02',
            'Encode::CN'            => '2.02',
            'Encode::CN::HZ'        => '2.04',
            'Encode::Config'        => '2.03',
            'Encode::EBCDIC'        => '2.02',
            'Encode::Encoder'       => '2.01',
            'Encode::Encoding'      => '2.04',
            'Encode::Guess'         => '2.02',
            'Encode::JP'            => '2.03',
            'Encode::JP::H2Z'       => '2.02',
            'Encode::JP::JIS7'      => '2.02',
            'Encode::KR'            => '2.02',
            'Encode::KR::2022_KR'   => '2.02',
            'Encode::MIME::Header'  => '2.04',
            'Encode::MIME::Header::ISO_2022_JP'=> '1.03',
            'Encode::Symbol'        => '2.02',
            'Encode::TW'            => '2.02',
            'Encode::Unicode'       => '2.03',
            'Encode::Unicode::UTF7' => '2.04',
            'ExtUtils::CBuilder'    => '0.18',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.12_01',
            'ExtUtils::Constant::Base'=> '0.03',
            'ExtUtils::Constant::ProxySubs'=> '0.03',
            'ExtUtils::Install'     => '1.41',
            'ExtUtils::Installed'   => '1.41',
            'ExtUtils::MM_Any'      => '0.13_02',
            'ExtUtils::MM_NW5'      => '2.08_01',
            'ExtUtils::MM_Unix'     => '1.5003',
            'ExtUtils::MM_VMS'      => '5.73_03',
            'ExtUtils::MM_Win32'    => '1.12_02',
            'ExtUtils::MM_Win95'    => '0.04_01',
            'ExtUtils::MakeMaker'   => '6.30_02',
            'ExtUtils::Manifest'    => '1.46_01',
            'ExtUtils::Mkbootstrap' => '1.15_01',
            'ExtUtils::Mksymlists'  => '1.19_01',
            'ExtUtils::Packlist'    => '1.41',
            'File::Basename'        => '2.75',
            'File::Find'            => '1.11',
            'File::GlobMapper'      => '0.000_02',
            'File::Spec'            => '3.19',
            'FileCache'             => '1.07',
            'Getopt::Long'          => '2.3501',
            'Hash::Util'            => '0.07',
            'Hash::Util::FieldHash' => '0.01',
            'IO'                    => '1.23_01',
            'IO::Compress::Adapter::Deflate'=> '2.000_13',
            'IO::Compress::Adapter::Identity'=> '2.000_13',
            'IO::Compress::Base'    => '2.000_13',
            'IO::Compress::Base::Common'=> '2.000_13',
            'IO::Compress::Deflate' => '2.000_13',
            'IO::Compress::Gzip'    => '2.000_13',
            'IO::Compress::Gzip::Constants'=> '2.000_13',
            'IO::Compress::RawDeflate'=> '2.000_13',
            'IO::Compress::Zip'     => '2.000_13',
            'IO::Compress::Zip::Constants'=> '2.000_13',
            'IO::Compress::Zlib::Constants'=> '2.000_13',
            'IO::Compress::Zlib::Extra'=> '2.000_13',
            'IO::Dir'               => '1.06',
            'IO::File'              => '1.14',
            'IO::Handle'            => '1.27',
            'IO::Socket'            => '1.30_01',
            'IO::Socket::INET'      => '1.31',
            'IO::Socket::UNIX'      => '1.23',
            'IO::Uncompress::Adapter::Identity'=> '2.000_13',
            'IO::Uncompress::Adapter::Inflate'=> '2.000_13',
            'IO::Uncompress::AnyInflate'=> '2.000_13',
            'IO::Uncompress::AnyUncompress'=> '2.000_13',
            'IO::Uncompress::Base'  => '2.000_13',
            'IO::Uncompress::Gunzip'=> '2.000_13',
            'IO::Uncompress::Inflate'=> '2.000_13',
            'IO::Uncompress::RawInflate'=> '2.000_13',
            'IO::Uncompress::Unzip' => '2.000_13',
            'MIME::Base64'          => '3.07_01',
            'Math::Complex'         => '1.36',
            'Math::Trig'            => '1.04',
            'Module::Build'         => '0.2805',
            'Module::Build::Base'   => undef,
            'Module::Build::Compat' => '0.03',
            'Module::Build::ConfigData'=> undef,
            'Module::Build::Cookbook'=> undef,
            'Module::Build::ModuleInfo'=> undef,
            'Module::Build::Notes'  => undef,
            'Module::Build::PPMMaker'=> undef,
            'Module::Build::Platform::Amiga'=> undef,
            'Module::Build::Platform::Default'=> undef,
            'Module::Build::Platform::EBCDIC'=> undef,
            'Module::Build::Platform::MPEiX'=> undef,
            'Module::Build::Platform::MacOS'=> undef,
            'Module::Build::Platform::RiscOS'=> undef,
            'Module::Build::Platform::Unix'=> undef,
            'Module::Build::Platform::VMS'=> undef,
            'Module::Build::Platform::VOS'=> undef,
            'Module::Build::Platform::Windows'=> undef,
            'Module::Build::Platform::aix'=> undef,
            'Module::Build::Platform::cygwin'=> undef,
            'Module::Build::Platform::darwin'=> undef,
            'Module::Build::Platform::os2'=> undef,
            'Module::Build::PodParser'=> undef,
            'Module::Build::Version'=> '0',
            'Module::Build::YAML'   => '0.50',
            'Module::CoreList'      => '2.08',
            'Module::Load'          => '0.10',
            'Module::Loaded'        => '0.01',
            'Package::Constants'    => '0.01',
            'Pod::Html'             => '1.07',
            'Pod::Man'              => '2.09',
            'Pod::Text'             => '3.07',
            'Pod::Text::Color'      => '2.03',
            'Pod::Text::Termcap'    => '2.03',
            'SDBM_File'             => '1.06',
            'Shell'                 => '0.7',
            'Sys::Syslog'           => '0.17',
            'Term::ANSIColor'       => '1.11',
            'Test::Builder'         => '0.33',
            'Test::Builder::Tester' => '1.04',
            'Test::Harness'         => '2.62',
            'Test::Harness::Util'   => '0.01',
            'Test::More'            => '0.64',
            'Test::Simple'          => '0.64',
            'Text::Balanced'        => '1.98_01',
            'Text::ParseWords'      => '3.25',
            'Text::Tabs'            => '2007.071101',
            'Text::Wrap'            => '2006.0711',
            'Tie::RefHash'          => '1.34_01',
            'Time::HiRes'           => '1.87',
            'Time::Local'           => '1.13',
            'Time::gmtime'          => '1.03',
            'UNIVERSAL'             => '1.04',
            'Unicode::Normalize'    => '1.01',
            'Win32API::File'        => '0.1001',
            'Win32API::File::ExtUtils::Myconst2perl'=> '1',
            'assertions'            => '0.03',
            'assertions::compat'    => '0.02',
            'autouse'               => '1.06',
            'diagnostics'           => '1.16',
            'encoding'              => '2.04',
            'encoding::warnings'    => '0.10',
            'feature'               => '1.01',
            're'                    => '0.0601',
            'threads'               => '1.38',
            'threads::shared'       => '0.94_01',
            'version'               => '0.67',
        },
        removed => {
            'Compress::Zlib::Common'=> 1,
            'Compress::Zlib::Compress::Gzip::Constants'=> 1,
            'Compress::Zlib::Compress::Zip::Constants'=> 1,
            'Compress::Zlib::CompressPlugin::Deflate'=> 1,
            'Compress::Zlib::CompressPlugin::Identity'=> 1,
            'Compress::Zlib::File::GlobMapper'=> 1,
            'Compress::Zlib::FileConstants'=> 1,
            'Compress::Zlib::IO::Compress::Base'=> 1,
            'Compress::Zlib::IO::Compress::Deflate'=> 1,
            'Compress::Zlib::IO::Compress::Gzip'=> 1,
            'Compress::Zlib::IO::Compress::RawDeflate'=> 1,
            'Compress::Zlib::IO::Compress::Zip'=> 1,
            'Compress::Zlib::IO::Uncompress::AnyInflate'=> 1,
            'Compress::Zlib::IO::Uncompress::AnyUncompress'=> 1,
            'Compress::Zlib::IO::Uncompress::Base'=> 1,
            'Compress::Zlib::IO::Uncompress::Gunzip'=> 1,
            'Compress::Zlib::IO::Uncompress::Inflate'=> 1,
            'Compress::Zlib::IO::Uncompress::RawInflate'=> 1,
            'Compress::Zlib::IO::Uncompress::Unzip'=> 1,
            'Compress::Zlib::ParseParameters'=> 1,
            'Compress::Zlib::UncompressPlugin::Identity'=> 1,
            'Compress::Zlib::UncompressPlugin::Inflate'=> 1,
        }
    },
    5.009005 => {
        delta_from => 5.009004,
        changed => {
            'Archive::Extract'      => '0.22_01',
            'Archive::Tar'          => '1.32',
            'Attribute::Handlers'   => '0.78_06',
            'AutoLoader'            => '5.63',
            'AutoSplit'             => '1.05',
            'B'                     => '1.16',
            'B::Concise'            => '0.72',
            'B::Debug'              => '1.05',
            'B::Deparse'            => '0.82',
            'B::Lint'               => '1.09',
            'B::Terse'              => '1.05',
            'Benchmark'             => '1.1',
            'CGI'                   => '3.29',
            'CGI::Cookie'           => '1.28',
            'CGI::Util'             => '1.5_01',
            'CPAN'                  => '1.9102',
            'CPAN::Debug'           => '5.400955',
            'CPAN::FirstTime'       => '5.401669',
            'CPAN::HandleConfig'    => '5.401744',
            'CPAN::Kwalify'         => '5.401418',
            'CPAN::Nox'             => '5.400844',
            'CPAN::Queue'           => '5.401704',
            'CPAN::Tarzip'          => '5.401717',
            'CPAN::Version'         => '5.401387',
            'CPANPLUS'              => '0.81_01',
            'CPANPLUS::Backend'     => undef,
            'CPANPLUS::Backend::RV' => undef,
            'CPANPLUS::Config'      => undef,
            'CPANPLUS::Configure'   => undef,
            'CPANPLUS::Configure::Setup'=> undef,
            'CPANPLUS::Dist'        => undef,
            'CPANPLUS::Dist::Base'  => '0.01',
            'CPANPLUS::Dist::Build' => '0.06_01',
            'CPANPLUS::Dist::Build::Constants'=> '0.01',
            'CPANPLUS::Dist::MM'    => undef,
            'CPANPLUS::Dist::Sample'=> undef,
            'CPANPLUS::Error'       => undef,
            'CPANPLUS::Internals'   => '0.81_01',
            'CPANPLUS::Internals::Constants'=> '0.01',
            'CPANPLUS::Internals::Constants::Report'=> '0.01',
            'CPANPLUS::Internals::Extract'=> undef,
            'CPANPLUS::Internals::Fetch'=> undef,
            'CPANPLUS::Internals::Report'=> undef,
            'CPANPLUS::Internals::Search'=> undef,
            'CPANPLUS::Internals::Source'=> undef,
            'CPANPLUS::Internals::Utils'=> undef,
            'CPANPLUS::Internals::Utils::Autoflush'=> undef,
            'CPANPLUS::Module'      => undef,
            'CPANPLUS::Module::Author'=> undef,
            'CPANPLUS::Module::Author::Fake'=> undef,
            'CPANPLUS::Module::Checksums'=> undef,
            'CPANPLUS::Module::Fake'=> undef,
            'CPANPLUS::Module::Signature'=> undef,
            'CPANPLUS::Selfupdate'  => undef,
            'CPANPLUS::Shell'       => undef,
            'CPANPLUS::Shell::Classic'=> '0.0562',
            'CPANPLUS::Shell::Default'=> '0.81_01',
            'CPANPLUS::Shell::Default::Plugins::Remote'=> undef,
            'CPANPLUS::Shell::Default::Plugins::Source'=> undef,
            'CPANPLUS::inc'         => undef,
            'Carp'                  => '1.07',
            'Carp::Heavy'           => '1.07',
            'Compress::Raw::Zlib'   => '2.005',
            'Compress::Zlib'        => '2.005',
            'Cwd'                   => '3.25',
            'DBM_Filter'            => '0.02',
            'DB_File'               => '1.815',
            'Data::Dumper'          => '2.121_13',
            'Devel::InnerPackage'   => '0.3',
            'Devel::PPPort'         => '3.11_01',
            'Digest::MD5'           => '2.36_01',
            'Digest::SHA'           => '5.44',
            'DynaLoader'            => '1.08',
            'Encode'                => '2.23',
            'Encode::Alias'         => '2.07',
            'Encode::Byte'          => '2.03',
            'Encode::Config'        => '2.04',
            'Encode::Encoding'      => '2.05',
            'Encode::GSM0338'       => '2.00',
            'Encode::JP::JIS7'      => '2.03',
            'Encode::MIME::Header'  => '2.05',
            'Encode::MIME::Name'    => '1.01',
            'Encode::Unicode'       => '2.05',
            'Errno'                 => '1.10',
            'Exporter'              => '5.60',
            'Exporter::Heavy'       => '5.60',
            'ExtUtils::CBuilder'    => '0.19',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.13',
            'ExtUtils::Command'     => '1.13',
            'ExtUtils::Command::MM' => '0.07',
            'ExtUtils::Constant::Base'=> '0.04',
            'ExtUtils::Install'     => '1.41_01',
            'ExtUtils::Liblist'     => '1.03',
            'ExtUtils::Liblist::Kid'=> '1.33',
            'ExtUtils::MM'          => '0.07',
            'ExtUtils::MM_AIX'      => '0.05',
            'ExtUtils::MM_Any'      => '0.15',
            'ExtUtils::MM_BeOS'     => '1.07',
            'ExtUtils::MM_Cygwin'   => '1.1',
            'ExtUtils::MM_DOS'      => '0.04',
            'ExtUtils::MM_MacOS'    => '1.1',
            'ExtUtils::MM_NW5'      => '2.1',
            'ExtUtils::MM_OS2'      => '1.07',
            'ExtUtils::MM_QNX'      => '0.04',
            'ExtUtils::MM_UWIN'     => '0.04',
            'ExtUtils::MM_Unix'     => '1.54_01',
            'ExtUtils::MM_VMS'      => '5.76',
            'ExtUtils::MM_VOS'      => '0.04',
            'ExtUtils::MM_Win32'    => '1.15',
            'ExtUtils::MM_Win95'    => '0.06',
            'ExtUtils::MY'          => '0.03',
            'ExtUtils::MakeMaker'   => '6.36',
            'ExtUtils::MakeMaker::Config'=> '0.04',
            'ExtUtils::MakeMaker::bytes'=> '0.03',
            'ExtUtils::MakeMaker::vmsish'=> '0.03',
            'ExtUtils::Manifest'    => '1.51_01',
            'ExtUtils::Mkbootstrap' => '1.17',
            'ExtUtils::Mksymlists'  => '1.21',
            'ExtUtils::ParseXS'     => '2.18',
            'ExtUtils::XSSymSet'    => '1.1',
            'ExtUtils::testlib'     => '1.17',
            'Fatal'                 => '1.05',
            'Fcntl'                 => '1.06',
            'File::Basename'        => '2.76',
            'File::Copy'            => '2.10',
            'File::Fetch'           => '0.10',
            'File::Glob'            => '1.06',
            'File::Path'            => '2.01',
            'File::Spec'            => '3.25',
            'File::Spec::Cygwin'    => '1.1_01',
            'File::Spec::VMS'       => '1.4_01',
            'File::Temp'            => '0.18',
            'Filter::Util::Call'    => '1.0602',
            'FindBin'               => '1.49',
            'Getopt::Long'          => '2.36',
            'Hash::Util::FieldHash' => '1.01',
            'IO::Compress::Adapter::Deflate'=> '2.005',
            'IO::Compress::Adapter::Identity'=> '2.005',
            'IO::Compress::Base'    => '2.005',
            'IO::Compress::Base::Common'=> '2.005',
            'IO::Compress::Deflate' => '2.005',
            'IO::Compress::Gzip'    => '2.005',
            'IO::Compress::Gzip::Constants'=> '2.005',
            'IO::Compress::RawDeflate'=> '2.005',
            'IO::Compress::Zip'     => '2.005',
            'IO::Compress::Zip::Constants'=> '2.005',
            'IO::Compress::Zlib::Constants'=> '2.005',
            'IO::Compress::Zlib::Extra'=> '2.005',
            'IO::Uncompress::Adapter::Identity'=> '2.005',
            'IO::Uncompress::Adapter::Inflate'=> '2.005',
            'IO::Uncompress::AnyInflate'=> '2.005',
            'IO::Uncompress::AnyUncompress'=> '2.005',
            'IO::Uncompress::Base'  => '2.005',
            'IO::Uncompress::Gunzip'=> '2.005',
            'IO::Uncompress::Inflate'=> '2.005',
            'IO::Uncompress::RawInflate'=> '2.005',
            'IO::Uncompress::Unzip' => '2.005',
            'IO::Zlib'              => '1.05_01',
            'IPC::Cmd'              => '0.36_01',
            'List::Util'            => '1.19',
            'Locale::Maketext::Simple'=> '0.18',
            'Log::Message'          => '0.01',
            'Log::Message::Config'  => '0.01',
            'Log::Message::Handlers'=> undef,
            'Log::Message::Item'    => undef,
            'Log::Message::Simple'  => '0.0201',
            'Math::BigFloat'        => '1.58',
            'Math::BigInt'          => '1.87',
            'Math::BigInt::Calc'    => '0.51',
            'Math::BigInt::FastCalc'=> '0.15_01',
            'Math::BigRat'          => '0.19',
            'Math::Complex'         => '1.37',
            'Memoize'               => '1.01_02',
            'Module::Build'         => '0.2808',
            'Module::Build::Config' => undef,
            'Module::Build::Version'=> '0.7203',
            'Module::CoreList'      => '2.12',
            'Module::Load::Conditional'=> '0.16',
            'Module::Pluggable'     => '3.6',
            'Module::Pluggable::Object'=> '3.6',
            'NDBM_File'             => '1.07',
            'Net::Cmd'              => '2.28',
            'Net::Config'           => '1.11',
            'Net::Domain'           => '2.20',
            'Net::FTP'              => '2.77',
            'Net::FTP::A'           => '1.18',
            'Net::NNTP'             => '2.24',
            'Net::POP3'             => '2.29',
            'Net::SMTP'             => '2.31',
            'ODBM_File'             => '1.07',
            'OS2::DLL'              => '1.03',
            'Object::Accessor'      => '0.32',
            'Opcode'                => '1.09',
            'POSIX'                 => '1.13',
            'Params::Check'         => '0.26',
            'PerlIO::encoding'      => '0.10',
            'PerlIO::scalar'        => '0.05',
            'PerlIO::via'           => '0.04',
            'Pod::Html'             => '1.08',
            'Pod::Man'              => '2.12',
            'Pod::ParseUtils'       => '1.35',
            'Pod::Parser'           => '1.35',
            'Pod::Select'           => '1.35',
            'Pod::Simple'           => '3.05',
            'Pod::Text'             => '3.08',
            'Pod::Usage'            => '1.35',
            'Scalar::Util'          => '1.19',
            'SelfLoader'            => '1.11',
            'Shell'                 => '0.72_01',
            'Socket'                => '1.79',
            'Storable'              => '2.16',
            'Switch'                => '2.13',
            'Sys::Syslog'           => '0.18_01',
            'Term::ANSIColor'       => '1.12',
            'Term::UI'              => '0.14_01',
            'Term::UI::History'     => undef,
            'Test::Builder'         => '0.70',
            'Test::Builder::Module' => '0.68',
            'Test::Builder::Tester' => '1.07',
            'Test::Harness'         => '2.64',
            'Test::Harness::Results'=> '0.01',
            'Test::More'            => '0.70',
            'Test::Simple'          => '0.70',
            'Text::Balanced'        => '2.0.0',
            'Text::Soundex'         => '3.02',
            'Text::Tabs'            => '2007.1117',
            'Text::Wrap'            => '2006.1117',
            'Thread'                => '3.02',
            'Tie::File'             => '0.97_02',
            'Tie::Hash::NamedCapture'=> '0.06',
            'Tie::Memoize'          => '1.1',
            'Tie::RefHash'          => '1.37',
            'Time::HiRes'           => '1.9707',
            'Time::Local'           => '1.17',
            'Time::Piece'           => '1.11_02',
            'Time::Seconds'         => undef,
            'Unicode'               => '5.0.0',
            'Unicode::Normalize'    => '1.02',
            'Unicode::UCD'          => '0.25',
            'VMS::DCLsym'           => '1.03',
            'Win32'                 => '0.30',
            'Win32API::File'        => '0.1001_01',
            'Win32CORE'             => '0.02',
            'XS::APItest'           => '0.12',
            'XSLoader'              => '0.08',
            'attributes'            => '0.08',
            'base'                  => '2.12',
            'bigint'                => '0.22',
            'bignum'                => '0.22',
            'bigrat'                => '0.22',
            'bytes'                 => '1.03',
            'charnames'             => '1.06',
            'constant'              => '1.10',
            'diagnostics'           => '1.17',
            'encoding'              => '2.06',
            'encoding::warnings'    => '0.11',
            'feature'               => '1.10',
            'fields'                => '2.12',
            'less'                  => '0.02',
            'mro'                   => '1.00',
            'overload'              => '1.06',
            're'                    => '0.08',
            'sigtrap'               => '1.04',
            'sort'                  => '2.01',
            'strict'                => '1.04',
            'threads'               => '1.63',
            'threads::shared'       => '1.12',
            'utf8'                  => '1.07',
            'version'               => '0.7203',
            'warnings'              => '1.06',
        },
        removed => {
            'B::Asmdata'            => 1,
            'B::Assembler'          => 1,
            'B::Bblock'             => 1,
            'B::Bytecode'           => 1,
            'B::C'                  => 1,
            'B::CC'                 => 1,
            'B::Disassembler'       => 1,
            'B::Stackobj'           => 1,
            'B::Stash'              => 1,
            'ByteLoader'            => 1,
            'Thread::Signal'        => 1,
            'Thread::Specific'      => 1,
            'assertions'            => 1,
            'assertions::activate'  => 1,
            'assertions::compat'    => 1,
        }
    },
    5.01 => {
        delta_from => 5.009005,
        changed => {
            'Archive::Extract'      => '0.24',
            'Archive::Tar'          => '1.38',
            'Attribute::Handlers'   => '0.79',
            'B'                     => '1.17',
            'B::Concise'            => '0.74',
            'B::Deparse'            => '0.83',
            'CPAN'                  => '1.9205',
            'CPAN::API::HOWTO'      => undef,
            'CPAN::Debug'           => '5.402212',
            'CPAN::DeferedCode'     => '5.50',
            'CPAN::FirstTime'       => '5.402229',
            'CPAN::HandleConfig'    => '5.402212',
            'CPAN::Nox'             => '5.402411',
            'CPAN::Queue'           => '5.402212',
            'CPAN::Tarzip'          => '5.402213',
            'CPAN::Version'         => '5.5',
            'CPANPLUS'              => '0.84',
            'CPANPLUS::Dist::Build' => '0.06_02',
            'CPANPLUS::Internals'   => '0.84',
            'CPANPLUS::Shell::Default'=> '0.84',
            'CPANPLUS::Shell::Default::Plugins::CustomSource'=> undef,
            'Carp'                  => '1.08',
            'Carp::Heavy'           => '1.08',
            'Compress::Raw::Zlib'   => '2.008',
            'Compress::Zlib'        => '2.008',
            'Cwd'                   => '3.2501',
            'DB_File'               => '1.816_1',
            'Data::Dumper'          => '2.121_14',
            'Devel::PPPort'         => '3.13',
            'Digest::SHA'           => '5.45',
            'Exporter'              => '5.62',
            'Exporter::Heavy'       => '5.62',
            'ExtUtils::CBuilder'    => '0.21',
            'ExtUtils::CBuilder::Base'=> '0.21',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.21',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.22',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.21',
            'ExtUtils::CBuilder::Platform::aix'=> '0.21',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.21',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.21',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.21',
            'ExtUtils::CBuilder::Platform::os2'=> '0.21',
            'ExtUtils::Command::MM' => '6.42',
            'ExtUtils::Constant::ProxySubs'=> '0.05',
            'ExtUtils::Embed'       => '1.27',
            'ExtUtils::Install'     => '1.44',
            'ExtUtils::Installed'   => '1.43',
            'ExtUtils::Liblist'     => '6.42',
            'ExtUtils::Liblist::Kid'=> '6.42',
            'ExtUtils::MM'          => '6.42',
            'ExtUtils::MM_AIX'      => '6.42',
            'ExtUtils::MM_Any'      => '6.42',
            'ExtUtils::MM_BeOS'     => '6.42',
            'ExtUtils::MM_Cygwin'   => '6.42',
            'ExtUtils::MM_DOS'      => '6.42',
            'ExtUtils::MM_MacOS'    => '6.42',
            'ExtUtils::MM_NW5'      => '6.42',
            'ExtUtils::MM_OS2'      => '6.42',
            'ExtUtils::MM_QNX'      => '6.42',
            'ExtUtils::MM_UWIN'     => '6.42',
            'ExtUtils::MM_Unix'     => '6.42',
            'ExtUtils::MM_VMS'      => '6.42',
            'ExtUtils::MM_VOS'      => '6.42',
            'ExtUtils::MM_Win32'    => '6.42',
            'ExtUtils::MM_Win95'    => '6.42',
            'ExtUtils::MY'          => '6.42',
            'ExtUtils::MakeMaker'   => '6.42',
            'ExtUtils::MakeMaker::Config'=> '6.42',
            'ExtUtils::MakeMaker::bytes'=> '6.42',
            'ExtUtils::MakeMaker::vmsish'=> '6.42',
            'ExtUtils::Mkbootstrap' => '6.42',
            'ExtUtils::Mksymlists'  => '6.42',
            'ExtUtils::Packlist'    => '1.43',
            'ExtUtils::ParseXS'     => '2.18_02',
            'ExtUtils::testlib'     => '6.42',
            'File::Copy'            => '2.11',
            'File::Fetch'           => '0.14',
            'File::Find'            => '1.12',
            'File::Path'            => '2.04',
            'File::Spec'            => '3.2501',
            'File::Spec::Cygwin'    => '3.2501',
            'File::Spec::Epoc'      => '3.2501',
            'File::Spec::Functions' => '3.2501',
            'File::Spec::Mac'       => '3.2501',
            'File::Spec::OS2'       => '3.2501',
            'File::Spec::Unix'      => '3.2501',
            'File::Spec::VMS'       => '3.2501',
            'File::Spec::Win32'     => '3.2501',
            'Filter::Util::Call'    => '1.07',
            'Getopt::Long'          => '2.37',
            'Hash::Util::FieldHash' => '1.03',
            'IO::Compress::Adapter::Deflate'=> '2.008',
            'IO::Compress::Adapter::Identity'=> '2.008',
            'IO::Compress::Base'    => '2.008',
            'IO::Compress::Base::Common'=> '2.008',
            'IO::Compress::Deflate' => '2.008',
            'IO::Compress::Gzip'    => '2.008',
            'IO::Compress::Gzip::Constants'=> '2.008',
            'IO::Compress::RawDeflate'=> '2.008',
            'IO::Compress::Zip'     => '2.008',
            'IO::Compress::Zip::Constants'=> '2.008',
            'IO::Compress::Zlib::Constants'=> '2.008',
            'IO::Compress::Zlib::Extra'=> '2.008',
            'IO::Uncompress::Adapter::Identity'=> '2.008',
            'IO::Uncompress::Adapter::Inflate'=> '2.008',
            'IO::Uncompress::AnyInflate'=> '2.008',
            'IO::Uncompress::AnyUncompress'=> '2.008',
            'IO::Uncompress::Base'  => '2.008',
            'IO::Uncompress::Gunzip'=> '2.008',
            'IO::Uncompress::Inflate'=> '2.008',
            'IO::Uncompress::RawInflate'=> '2.008',
            'IO::Uncompress::Unzip' => '2.008',
            'IO::Zlib'              => '1.07',
            'IPC::Cmd'              => '0.40_1',
            'IPC::SysV'             => '1.05',
            'Locale::Maketext'      => '1.12',
            'Log::Message::Simple'  => '0.04',
            'Math::BigFloat'        => '1.59',
            'Math::BigInt'          => '1.88',
            'Math::BigInt::Calc'    => '0.52',
            'Math::BigInt::FastCalc'=> '0.16',
            'Math::BigRat'          => '0.21',
            'Module::Build'         => '0.2808_01',
            'Module::Build::Base'   => '0.2808_01',
            'Module::Build::Compat' => '0.2808_01',
            'Module::Build::Config' => '0.2808_01',
            'Module::Build::Dumper' => undef,
            'Module::Build::ModuleInfo'=> '0.2808_01',
            'Module::Build::Notes'  => '0.2808_01',
            'Module::Build::PPMMaker'=> '0.2808_01',
            'Module::Build::Platform::Amiga'=> '0.2808_01',
            'Module::Build::Platform::Default'=> '0.2808_01',
            'Module::Build::Platform::EBCDIC'=> '0.2808_01',
            'Module::Build::Platform::MPEiX'=> '0.2808_01',
            'Module::Build::Platform::MacOS'=> '0.2808_01',
            'Module::Build::Platform::RiscOS'=> '0.2808_01',
            'Module::Build::Platform::Unix'=> '0.2808_01',
            'Module::Build::Platform::VMS'=> '0.2808_01',
            'Module::Build::Platform::VOS'=> '0.2808_01',
            'Module::Build::Platform::Windows'=> '0.2808_01',
            'Module::Build::Platform::aix'=> '0.2808_01',
            'Module::Build::Platform::cygwin'=> '0.2808_01',
            'Module::Build::Platform::darwin'=> '0.2808_01',
            'Module::Build::Platform::os2'=> '0.2808_01',
            'Module::Build::PodParser'=> '0.2808_01',
            'Module::CoreList'      => '2.13',
            'Module::Load'          => '0.12',
            'Module::Load::Conditional'=> '0.22',
            'Net::Cmd'              => '2.29',
            'Net::Ping'             => '2.33',
            'Opcode'                => '1.11',
            'Pod::Checker'          => '1.43_01',
            'Pod::Man'              => '2.16',
            'Pod::Perldoc'          => '3.14_02',
            'Socket'                => '1.80',
            'Storable'              => '2.18',
            'Sys::Syslog'           => '0.22',
            'Sys::Syslog::win32::Win32'=> undef,
            'Term::Cap'             => '1.12',
            'Term::ReadLine'        => '1.03',
            'Term::UI'              => '0.18',
            'Test::Builder'         => '0.72',
            'Test::Builder::Module' => '0.72',
            'Test::Builder::Tester' => '1.09',
            'Test::Harness::Straps' => '0.26_01',
            'Test::More'            => '0.72',
            'Test::Simple'          => '0.72',
            'Text::ParseWords'      => '3.26',
            'Text::Soundex'         => '3.03',
            'Tie::StdHandle'        => undef,
            'Time::HiRes'           => '1.9711',
            'Time::Local'           => '1.18',
            'Time::Piece'           => '1.12',
            'VMS::Filespec'         => '1.12',
            'Win32'                 => '0.34',
            'base'                  => '2.13',
            'constant'              => '1.13',
            'feature'               => '1.11',
            'fields'                => '2.13',
            'filetest'              => '1.02',
            'open'                  => '1.06',
            'threads'               => '1.67',
            'threads::shared'       => '1.14',
            'version'               => '0.74',
        },
        removed => {
        }
    },
    5.010001 => {
        delta_from => 5.01,
        changed => {
            'App::Prove'            => '3.17',
            'App::Prove::State'     => '3.17',
            'App::Prove::State::Result'=> '3.17',
            'App::Prove::State::Result::Test'=> '3.17',
            'Archive::Extract'      => '0.34',
            'Archive::Tar'          => '1.52',
            'Attribute::Handlers'   => '0.85',
            'AutoLoader'            => '5.68',
            'AutoSplit'             => '1.06',
            'B'                     => '1.22',
            'B::Concise'            => '0.76',
            'B::Debug'              => '1.11',
            'B::Deparse'            => '0.89',
            'B::Lint'               => '1.11',
            'B::Lint::Debug'        => undef,
            'B::Xref'               => '1.02',
            'Benchmark'             => '1.11',
            'CGI'                   => '3.43',
            'CGI::Carp'             => '1.30_01',
            'CGI::Cookie'           => '1.29',
            'CPAN'                  => '1.9402',
            'CPAN::Author'          => '5.5',
            'CPAN::Bundle'          => '5.5',
            'CPAN::CacheMgr'        => '5.5',
            'CPAN::Complete'        => '5.5',
            'CPAN::Debug'           => '5.5',
            'CPAN::DeferredCode'    => '5.50',
            'CPAN::Distribution'    => '1.93',
            'CPAN::Distroprefs'     => '6',
            'CPAN::Distrostatus'    => '5.5',
            'CPAN::Exception::RecursiveDependency'=> '5.5',
            'CPAN::Exception::blocked_urllist'=> '1.0',
            'CPAN::Exception::yaml_not_installed'=> '5.5',
            'CPAN::FTP'             => '5.5001',
            'CPAN::FTP::netrc'      => '1.00',
            'CPAN::FirstTime'       => '5.53',
            'CPAN::HandleConfig'    => '5.5',
            'CPAN::Index'           => '1.93',
            'CPAN::InfoObj'         => '5.5',
            'CPAN::Kwalify'         => '5.50',
            'CPAN::LWP::UserAgent'  => '1.00',
            'CPAN::Module'          => '5.5',
            'CPAN::Nox'             => '5.50',
            'CPAN::Prompt'          => '5.5',
            'CPAN::Queue'           => '5.5',
            'CPAN::Shell'           => '5.5',
            'CPAN::Tarzip'          => '5.501',
            'CPAN::URL'             => '5.5',
            'CPANPLUS'              => '0.88',
            'CPANPLUS::Dist::Autobundle'=> undef,
            'CPANPLUS::Dist::Base'  => undef,
            'CPANPLUS::Dist::Build' => '0.36',
            'CPANPLUS::Dist::Build::Constants'=> '0.36',
            'CPANPLUS::Internals'   => '0.88',
            'CPANPLUS::Internals::Constants'=> undef,
            'CPANPLUS::Internals::Constants::Report'=> undef,
            'CPANPLUS::Internals::Source::Memory'=> undef,
            'CPANPLUS::Internals::Source::SQLite'=> undef,
            'CPANPLUS::Internals::Source::SQLite::Tie'=> undef,
            'CPANPLUS::Shell::Default'=> '0.88',
            'Carp'                  => '1.11',
            'Carp::Heavy'           => '1.11',
            'Compress::Raw::Bzip2'  => '2.020',
            'Compress::Raw::Zlib'   => '2.020',
            'Compress::Zlib'        => '2.020',
            'Cwd'                   => '3.30',
            'DB'                    => '1.02',
            'DBM_Filter::compress'  => '0.02',
            'DBM_Filter::encode'    => '0.02',
            'DBM_Filter::int32'     => '0.02',
            'DBM_Filter::null'      => '0.02',
            'DBM_Filter::utf8'      => '0.02',
            'DB_File'               => '1.820',
            'Data::Dumper'          => '2.124',
            'Devel::DProf'          => '20080331.00',
            'Devel::PPPort'         => '3.19',
            'Devel::Peek'           => '1.04',
            'Digest'                => '1.16',
            'Digest::MD5'           => '2.39',
            'Digest::SHA'           => '5.47',
            'Digest::base'          => '1.16',
            'Digest::file'          => '1.16',
            'DirHandle'             => '1.03',
            'Dumpvalue'             => '1.13',
            'DynaLoader'            => '1.10',
            'Encode'                => '2.35',
            'Encode::Alias'         => '2.12',
            'Encode::CN::HZ'        => '2.05',
            'Encode::Config'        => '2.05',
            'Encode::GSM0338'       => '2.01',
            'Encode::Guess'         => '2.03',
            'Encode::JP::JIS7'      => '2.04',
            'Encode::MIME::Header'  => '2.11',
            'Encode::Unicode'       => '2.06',
            'Errno'                 => '1.11',
            'Exporter'              => '5.63',
            'Exporter::Heavy'       => '5.63',
            'ExtUtils::CBuilder'    => '0.2602',
            'ExtUtils::CBuilder::Base'=> '0.2602',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.2602',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.2602',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.2602',
            'ExtUtils::CBuilder::Platform::aix'=> '0.2602',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.2602',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.2602',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.2602',
            'ExtUtils::CBuilder::Platform::os2'=> '0.2602',
            'ExtUtils::Command'     => '1.16',
            'ExtUtils::Command::MM' => '6.55_02',
            'ExtUtils::Constant'    => '0.22',
            'ExtUtils::Constant::ProxySubs'=> '0.06',
            'ExtUtils::Constant::Utils'=> '0.02',
            'ExtUtils::Constant::XS'=> '0.03',
            'ExtUtils::Embed'       => '1.28',
            'ExtUtils::Install'     => '1.54',
            'ExtUtils::Installed'   => '1.999_001',
            'ExtUtils::Liblist'     => '6.55_02',
            'ExtUtils::Liblist::Kid'=> '6.5502',
            'ExtUtils::MM'          => '6.55_02',
            'ExtUtils::MM_AIX'      => '6.55_02',
            'ExtUtils::MM_Any'      => '6.55_02',
            'ExtUtils::MM_BeOS'     => '6.55_02',
            'ExtUtils::MM_Cygwin'   => '6.55_02',
            'ExtUtils::MM_DOS'      => '6.5502',
            'ExtUtils::MM_Darwin'   => '6.55_02',
            'ExtUtils::MM_MacOS'    => '6.5502',
            'ExtUtils::MM_NW5'      => '6.55_02',
            'ExtUtils::MM_OS2'      => '6.55_02',
            'ExtUtils::MM_QNX'      => '6.55_02',
            'ExtUtils::MM_UWIN'     => '6.5502',
            'ExtUtils::MM_Unix'     => '6.55_02',
            'ExtUtils::MM_VMS'      => '6.55_02',
            'ExtUtils::MM_VOS'      => '6.55_02',
            'ExtUtils::MM_Win32'    => '6.55_02',
            'ExtUtils::MM_Win95'    => '6.55_02',
            'ExtUtils::MY'          => '6.5502',
            'ExtUtils::MakeMaker'   => '6.55_02',
            'ExtUtils::MakeMaker::Config'=> '6.55_02',
            'ExtUtils::Manifest'    => '1.56',
            'ExtUtils::Mkbootstrap' => '6.55_02',
            'ExtUtils::Mksymlists'  => '6.55_02',
            'ExtUtils::ParseXS'     => '2.2002',
            'ExtUtils::testlib'     => '6.5502',
            'Fatal'                 => '2.06_01',
            'File::Basename'        => '2.77',
            'File::CheckTree'       => '4.4',
            'File::Compare'         => '1.1006',
            'File::Copy'            => '2.14',
            'File::DosGlob'         => '1.01',
            'File::Fetch'           => '0.20',
            'File::Find'            => '1.14',
            'File::GlobMapper'      => '1.000',
            'File::Path'            => '2.07_03',
            'File::Spec'            => '3.30',
            'File::Spec::Cygwin'    => '3.30',
            'File::Spec::Epoc'      => '3.30',
            'File::Spec::Functions' => '3.30',
            'File::Spec::Mac'       => '3.30',
            'File::Spec::OS2'       => '3.30',
            'File::Spec::Unix'      => '3.30',
            'File::Spec::VMS'       => '3.30',
            'File::Spec::Win32'     => '3.30',
            'File::Temp'            => '0.22',
            'File::stat'            => '1.01',
            'FileCache'             => '1.08',
            'FileHandle'            => '2.02',
            'Filter::Simple'        => '0.84',
            'Filter::Util::Call'    => '1.08',
            'FindBin'               => '1.50',
            'GDBM_File'             => '1.09',
            'Getopt::Long'          => '2.38',
            'Getopt::Std'           => '1.06',
            'Hash::Util::FieldHash' => '1.04',
            'I18N::Collate'         => '1.01',
            'IO'                    => '1.25',
            'IO::Compress::Adapter::Bzip2'=> '2.020',
            'IO::Compress::Adapter::Deflate'=> '2.020',
            'IO::Compress::Adapter::Identity'=> '2.020',
            'IO::Compress::Base'    => '2.020',
            'IO::Compress::Base::Common'=> '2.020',
            'IO::Compress::Bzip2'   => '2.020',
            'IO::Compress::Deflate' => '2.020',
            'IO::Compress::Gzip'    => '2.020',
            'IO::Compress::Gzip::Constants'=> '2.020',
            'IO::Compress::RawDeflate'=> '2.020',
            'IO::Compress::Zip'     => '2.020',
            'IO::Compress::Zip::Constants'=> '2.020',
            'IO::Compress::Zlib::Constants'=> '2.020',
            'IO::Compress::Zlib::Extra'=> '2.020',
            'IO::Dir'               => '1.07',
            'IO::Handle'            => '1.28',
            'IO::Socket'            => '1.31',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.020',
            'IO::Uncompress::Adapter::Identity'=> '2.020',
            'IO::Uncompress::Adapter::Inflate'=> '2.020',
            'IO::Uncompress::AnyInflate'=> '2.020',
            'IO::Uncompress::AnyUncompress'=> '2.020',
            'IO::Uncompress::Base'  => '2.020',
            'IO::Uncompress::Bunzip2'=> '2.020',
            'IO::Uncompress::Gunzip'=> '2.020',
            'IO::Uncompress::Inflate'=> '2.020',
            'IO::Uncompress::RawInflate'=> '2.020',
            'IO::Uncompress::Unzip' => '2.020',
            'IO::Zlib'              => '1.09',
            'IPC::Cmd'              => '0.46',
            'IPC::Msg'              => '2.01',
            'IPC::Open2'            => '1.03',
            'IPC::Open3'            => '1.04',
            'IPC::Semaphore'        => '2.01',
            'IPC::SharedMem'        => '2.01',
            'IPC::SysV'             => '2.01',
            'List::Util'            => '1.21',
            'List::Util::PP'        => '1.21',
            'List::Util::XS'        => '1.21',
            'Locale::Maketext'      => '1.13',
            'Locale::Maketext::Guts'=> '1.13',
            'Locale::Maketext::GutsLoader'=> '1.13',
            'Log::Message'          => '0.02',
            'MIME::Base64'          => '3.08',
            'MIME::QuotedPrint'     => '3.08',
            'Math::BigFloat'        => '1.60',
            'Math::BigInt'          => '1.89',
            'Math::BigInt::FastCalc'=> '0.19',
            'Math::BigRat'          => '0.22',
            'Math::Complex'         => '1.56',
            'Math::Trig'            => '1.2',
            'Memoize'               => '1.01_03',
            'Module::Build'         => '0.340201',
            'Module::Build::Base'   => '0.340201',
            'Module::Build::Compat' => '0.340201',
            'Module::Build::Config' => '0.340201',
            'Module::Build::Cookbook'=> '0.340201',
            'Module::Build::Dumper' => '0.340201',
            'Module::Build::ModuleInfo'=> '0.340201',
            'Module::Build::Notes'  => '0.340201',
            'Module::Build::PPMMaker'=> '0.340201',
            'Module::Build::Platform::Amiga'=> '0.340201',
            'Module::Build::Platform::Default'=> '0.340201',
            'Module::Build::Platform::EBCDIC'=> '0.340201',
            'Module::Build::Platform::MPEiX'=> '0.340201',
            'Module::Build::Platform::MacOS'=> '0.340201',
            'Module::Build::Platform::RiscOS'=> '0.340201',
            'Module::Build::Platform::Unix'=> '0.340201',
            'Module::Build::Platform::VMS'=> '0.340201',
            'Module::Build::Platform::VOS'=> '0.340201',
            'Module::Build::Platform::Windows'=> '0.340201',
            'Module::Build::Platform::aix'=> '0.340201',
            'Module::Build::Platform::cygwin'=> '0.340201',
            'Module::Build::Platform::darwin'=> '0.340201',
            'Module::Build::Platform::os2'=> '0.340201',
            'Module::Build::PodParser'=> '0.340201',
            'Module::Build::Version'=> '0.77',
            'Module::CoreList'      => '2.18',
            'Module::Load'          => '0.16',
            'Module::Load::Conditional'=> '0.30',
            'Module::Loaded'        => '0.02',
            'Module::Pluggable'     => '3.9',
            'Module::Pluggable::Object'=> '3.9',
            'NDBM_File'             => '1.08',
            'NEXT'                  => '0.64',
            'Net::Ping'             => '2.36',
            'O'                     => '1.01',
            'OS2::Process'          => '1.03',
            'OS2::REXX'             => '1.04',
            'Object::Accessor'      => '0.34',
            'POSIX'                 => '1.17',
            'Package::Constants'    => '0.02',
            'Parse::CPAN::Meta'     => '1.39',
            'PerlIO'                => '1.06',
            'PerlIO::encoding'      => '0.11',
            'PerlIO::scalar'        => '0.07',
            'PerlIO::via'           => '0.07',
            'Pod::Checker'          => '1.45',
            'Pod::Find'             => '1.35',
            'Pod::Html'             => '1.09',
            'Pod::InputObjects'     => '1.31',
            'Pod::Man'              => '2.22',
            'Pod::ParseLink'        => '1.09',
            'Pod::ParseUtils'       => '1.36',
            'Pod::Parser'           => '1.37',
            'Pod::Perldoc'          => '3.14_04',
            'Pod::PlainText'        => '2.04',
            'Pod::Select'           => '1.36',
            'Pod::Simple'           => '3.07',
            'Pod::Simple::XHTML'    => '3.04',
            'Pod::Text'             => '3.13',
            'Pod::Text::Color'      => '2.05',
            'Pod::Text::Overstrike' => '2.03',
            'Pod::Text::Termcap'    => '2.05',
            'Pod::Usage'            => '1.36',
            'Safe'                  => '2.18',
            'Scalar::Util'          => '1.21',
            'Scalar::Util::PP'      => '1.21',
            'SelectSaver'           => '1.02',
            'SelfLoader'            => '1.17',
            'Socket'                => '1.82',
            'Storable'              => '2.20',
            'Switch'                => '2.14',
            'Symbol'                => '1.07',
            'Sys::Syslog'           => '0.27',
            'TAP::Base'             => '3.17',
            'TAP::Formatter::Base'  => '3.17',
            'TAP::Formatter::Color' => '3.17',
            'TAP::Formatter::Console'=> '3.17',
            'TAP::Formatter::Console::ParallelSession'=> '3.17',
            'TAP::Formatter::Console::Session'=> '3.17',
            'TAP::Formatter::File'  => '3.17',
            'TAP::Formatter::File::Session'=> '3.17',
            'TAP::Formatter::Session'=> '3.17',
            'TAP::Harness'          => '3.17',
            'TAP::Object'           => '3.17',
            'TAP::Parser'           => '3.17',
            'TAP::Parser::Aggregator'=> '3.17',
            'TAP::Parser::Grammar'  => '3.17',
            'TAP::Parser::Iterator' => '3.17',
            'TAP::Parser::Iterator::Array'=> '3.17',
            'TAP::Parser::Iterator::Process'=> '3.17',
            'TAP::Parser::Iterator::Stream'=> '3.17',
            'TAP::Parser::IteratorFactory'=> '3.17',
            'TAP::Parser::Multiplexer'=> '3.17',
            'TAP::Parser::Result'   => '3.17',
            'TAP::Parser::Result::Bailout'=> '3.17',
            'TAP::Parser::Result::Comment'=> '3.17',
            'TAP::Parser::Result::Plan'=> '3.17',
            'TAP::Parser::Result::Pragma'=> '3.17',
            'TAP::Parser::Result::Test'=> '3.17',
            'TAP::Parser::Result::Unknown'=> '3.17',
            'TAP::Parser::Result::Version'=> '3.17',
            'TAP::Parser::Result::YAML'=> '3.17',
            'TAP::Parser::ResultFactory'=> '3.17',
            'TAP::Parser::Scheduler'=> '3.17',
            'TAP::Parser::Scheduler::Job'=> '3.17',
            'TAP::Parser::Scheduler::Spinner'=> '3.17',
            'TAP::Parser::Source'   => '3.17',
            'TAP::Parser::Source::Perl'=> '3.17',
            'TAP::Parser::Utils'    => '3.17',
            'TAP::Parser::YAMLish::Reader'=> '3.17',
            'TAP::Parser::YAMLish::Writer'=> '3.17',
            'Term::ANSIColor'       => '2.00',
            'Term::ReadLine'        => '1.04',
            'Term::UI'              => '0.20',
            'Test'                  => '1.25_02',
            'Test::Builder'         => '0.92',
            'Test::Builder::Module' => '0.92',
            'Test::Builder::Tester' => '1.18',
            'Test::Builder::Tester::Color'=> '1.18',
            'Test::Harness'         => '3.17',
            'Test::More'            => '0.92',
            'Test::Simple'          => '0.92',
            'Text::ParseWords'      => '3.27',
            'Text::Tabs'            => '2009.0305',
            'Text::Wrap'            => '2009.0305',
            'Thread::Queue'         => '2.11',
            'Thread::Semaphore'     => '2.09',
            'Tie::Handle'           => '4.2',
            'Tie::Hash'             => '1.03',
            'Tie::RefHash'          => '1.38',
            'Tie::Scalar'           => '1.01',
            'Tie::StdHandle'        => '4.2',
            'Time::HiRes'           => '1.9719',
            'Time::Local'           => '1.1901',
            'Time::Piece'           => '1.15',
            'UNIVERSAL'             => '1.05',
            'Unicode'               => '5.1.0',
            'Unicode::Normalize'    => '1.03',
            'Unicode::UCD'          => '0.27',
            'VMS::Stdio'            => '2.4',
            'Win32'                 => '0.39',
            'Win32API::File'        => '0.1101',
            'XS::APItest'           => '0.15',
            'XS::Typemap'           => '0.03',
            'XSLoader'              => '0.10',
            'attributes'            => '0.09',
            'attrs'                 => '1.03',
            'autodie'               => '2.06_01',
            'autodie::exception'    => '2.06_01',
            'autodie::exception::system'=> '2.06_01',
            'autodie::hints'        => '2.06_01',
            'base'                  => '2.14',
            'bigint'                => '0.23',
            'bignum'                => '0.23',
            'bigrat'                => '0.23',
            'blib'                  => '1.04',
            'charnames'             => '1.07',
            'constant'              => '1.17',
            'encoding'              => '2.6_01',
            'feature'               => '1.13',
            'fields'                => '2.14',
            'lib'                   => '0.62',
            'mro'                   => '1.01',
            'open'                  => '1.07',
            'ops'                   => '1.02',
            'overload'              => '1.07',
            'overload::numbers'     => undef,
            'overloading'           => '0.01',
            'parent'                => '0.221',
            're'                    => '0.09',
            'threads'               => '1.72',
            'threads::shared'       => '1.29',
            'version'               => '0.77',
        },
        removed => {
            'CPAN::API::HOWTO'      => 1,
            'CPAN::DeferedCode'     => 1,
            'CPANPLUS::inc'         => 1,
            'ExtUtils::MakeMaker::bytes'=> 1,
            'ExtUtils::MakeMaker::vmsish'=> 1,
            'Test::Harness::Assert' => 1,
            'Test::Harness::Iterator'=> 1,
            'Test::Harness::Point'  => 1,
            'Test::Harness::Results'=> 1,
            'Test::Harness::Straps' => 1,
            'Test::Harness::Util'   => 1,
        }
    },
    5.011 => {
        delta_from => 5.010001,
        changed => {
            'Archive::Tar'          => '1.54',
            'Attribute::Handlers'   => '0.87',
            'AutoLoader'            => '5.70',
            'B::Deparse'            => '0.91',
            'B::Lint'               => '1.11_01',
            'B::Lint::Debug'        => '0.01',
            'CGI'                   => '3.45',
            'CGI::Apache'           => '1.01',
            'CGI::Carp'             => '3.45',
            'CGI::Pretty'           => '3.44',
            'CGI::Switch'           => '1.01',
            'CGI::Util'             => '3.45',
            'CPAN'                  => '1.94_51',
            'CPAN::Distribution'    => '1.94',
            'CPAN::FTP'             => '5.5002',
            'CPAN::Index'           => '1.94',
            'CPAN::LWP::UserAgent'  => '1.94',
            'CPANPLUS::Dist::Build' => '0.40',
            'CPANPLUS::Dist::Build::Constants'=> '0.40',
            'Carp'                  => '1.12',
            'Carp::Heavy'           => '1.12',
            'Class::ISA'            => '0.36',
            'Compress::Raw::Bzip2'  => '2.021',
            'Compress::Raw::Zlib'   => '2.021',
            'Compress::Zlib'        => '2.021',
            'Cwd'                   => '3.3002',
            'Data::Dumper'          => '2.125',
            'Encode'                => '2.37',
            'Exporter'              => '5.64',
            'Exporter::Heavy'       => '5.64',
            'ExtUtils::ParseXS'     => '2.200403',
            'File::Basename'        => '2.78',
            'File::Copy'            => '2.16',
            'File::stat'            => '1.02',
            'IO'                    => '1.25_01',
            'IO::Compress::Adapter::Bzip2'=> '2.021',
            'IO::Compress::Adapter::Deflate'=> '2.021',
            'IO::Compress::Adapter::Identity'=> '2.021',
            'IO::Compress::Base'    => '2.021',
            'IO::Compress::Base::Common'=> '2.021',
            'IO::Compress::Bzip2'   => '2.021',
            'IO::Compress::Deflate' => '2.021',
            'IO::Compress::Gzip'    => '2.021',
            'IO::Compress::Gzip::Constants'=> '2.021',
            'IO::Compress::RawDeflate'=> '2.021',
            'IO::Compress::Zip'     => '2.021',
            'IO::Compress::Zip::Constants'=> '2.021',
            'IO::Compress::Zlib::Constants'=> '2.021',
            'IO::Compress::Zlib::Extra'=> '2.021',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.021',
            'IO::Uncompress::Adapter::Identity'=> '2.021',
            'IO::Uncompress::Adapter::Inflate'=> '2.021',
            'IO::Uncompress::AnyInflate'=> '2.021',
            'IO::Uncompress::AnyUncompress'=> '2.021',
            'IO::Uncompress::Base'  => '2.021',
            'IO::Uncompress::Bunzip2'=> '2.021',
            'IO::Uncompress::Gunzip'=> '2.021',
            'IO::Uncompress::Inflate'=> '2.021',
            'IO::Uncompress::RawInflate'=> '2.021',
            'IO::Uncompress::Unzip' => '2.021',
            'IO::Zlib'              => '1.10',
            'IPC::Cmd'              => '0.50',
            'IPC::Open3'            => '1.05',
            'Locale::Maketext::Simple'=> '0.21',
            'Log::Message::Simple'  => '0.06',
            'Math::BigInt'          => '1.89_01',
            'Math::BigRat'          => '0.24',
            'Module::Build'         => '0.35',
            'Module::Build::Base'   => '0.35',
            'Module::Build::Compat' => '0.35',
            'Module::Build::Config' => '0.35',
            'Module::Build::Cookbook'=> '0.35',
            'Module::Build::Dumper' => '0.35',
            'Module::Build::ModuleInfo'=> '0.35',
            'Module::Build::Notes'  => '0.35',
            'Module::Build::PPMMaker'=> '0.35',
            'Module::Build::Platform::Amiga'=> '0.35',
            'Module::Build::Platform::Default'=> '0.35',
            'Module::Build::Platform::EBCDIC'=> '0.35',
            'Module::Build::Platform::MPEiX'=> '0.35',
            'Module::Build::Platform::MacOS'=> '0.35',
            'Module::Build::Platform::RiscOS'=> '0.35',
            'Module::Build::Platform::Unix'=> '0.35',
            'Module::Build::Platform::VMS'=> '0.35',
            'Module::Build::Platform::VOS'=> '0.35',
            'Module::Build::Platform::Windows'=> '0.35',
            'Module::Build::Platform::aix'=> '0.35',
            'Module::Build::Platform::cygwin'=> '0.35',
            'Module::Build::Platform::darwin'=> '0.35',
            'Module::Build::Platform::os2'=> '0.35',
            'Module::Build::PodParser'=> '0.35',
            'Module::CoreList'      => '2.19',
            'Module::Loaded'        => '0.06',
            'Opcode'                => '1.13',
            'PerlIO::via'           => '0.08',
            'Pod::Perldoc'          => '3.15_01',
            'Pod::Plainer'          => '1.01',
            'Safe'                  => '2.19',
            'Socket'                => '1.84',
            'Switch'                => '2.14_01',
            'Term::ANSIColor'       => '2.02',
            'Term::ReadLine'        => '1.05',
            'Text::Balanced'        => '2.02',
            'Text::Soundex'         => '3.03_01',
            'Time::Local'           => '1.1901_01',
            'Unicode::Collate'      => '0.52_01',
            'attributes'            => '0.12',
            'constant'              => '1.19',
            'deprecate'             => '0.01',
            'overload'              => '1.08',
            'parent'                => '0.223',
            're'                    => '0.10',
            'threads'               => '1.74',
            'threads::shared'       => '1.31',
            'warnings'              => '1.07',
        },
        removed => {
            'attrs'                 => 1,
        }
    },
    5.011001 => {
        delta_from => 5.011,
        changed => {
            'B'                     => '1.23',
            'B::Concise'            => '0.77',
            'B::Deparse'            => '0.92',
            'CGI'                   => '3.48',
            'CGI::Pretty'           => '3.46',
            'CGI::Util'             => '3.48',
            'CPANPLUS'              => '0.89_03',
            'CPANPLUS::Internals'   => '0.89_03',
            'CPANPLUS::Shell::Default'=> '0.89_03',
            'Carp'                  => '1.13',
            'Carp::Heavy'           => '1.13',
            'ExtUtils::CBuilder'    => '0.260301',
            'ExtUtils::CBuilder::Base'=> '0.260301',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.260301',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.260301',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.260301',
            'ExtUtils::CBuilder::Platform::aix'=> '0.260301',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.260301',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.260301',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.260301',
            'ExtUtils::CBuilder::Platform::os2'=> '0.260301',
            'ExtUtils::Install'     => '1.55',
            'ExtUtils::Manifest'    => '1.57',
            'ExtUtils::Packlist'    => '1.44',
            'ExtUtils::ParseXS'     => '2.21',
            'File::Glob'            => '1.07',
            'File::Path'            => '2.08',
            'IO'                    => '1.25_02',
            'Module::CoreList'      => '2.21',
            'OS2::DLL'              => '1.04',
            'OS2::Process'          => '1.04',
            'Object::Accessor'      => '0.36',
            'Opcode'                => '1.15',
            'POSIX'                 => '1.18',
            'Parse::CPAN::Meta'     => '1.40',
            'PerlIO::via'           => '0.09',
            'Pod::Simple'           => '3.08',
            'Socket'                => '1.85',
            'Storable'              => '2.22',
            'Switch'                => '2.15',
            'Test::Builder'         => '0.94',
            'Test::Builder::Module' => '0.94',
            'Test::More'            => '0.94',
            'Test::Simple'          => '0.94',
            'XS::APItest'           => '0.16',
            'mro'                   => '1.02',
            'overload'              => '1.09',
            'threads::shared'       => '1.32',
        },
        removed => {
        }
    },
    5.011002 => {
        delta_from => 5.011001,
        changed => {
            'B::Concise'            => '0.78',
            'B::Deparse'            => '0.93',
            'CPANPLUS'              => '0.89_09',
            'CPANPLUS::Dist::Build' => '0.44',
            'CPANPLUS::Dist::Build::Constants'=> '0.44',
            'CPANPLUS::Internals'   => '0.89_09',
            'CPANPLUS::Shell::Default'=> '0.89_09',
            'Carp'                  => '1.14',
            'Carp::Heavy'           => '1.14',
            'Compress::Zlib'        => '2.022',
            'DBM_Filter'            => '0.03',
            'Encode'                => '2.38',
            'Encode::Byte'          => '2.04',
            'Encode::CN'            => '2.03',
            'Encode::JP'            => '2.04',
            'Encode::KR'            => '2.03',
            'Encode::TW'            => '2.03',
            'Encode::Unicode'       => '2.07',
            'Env'                   => '1.01',
            'Exporter'              => '5.64_01',
            'Exporter::Heavy'       => '5.64_01',
            'ExtUtils::CBuilder'    => '0.27',
            'ExtUtils::CBuilder::Base'=> '0.27',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.27',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.27',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.27',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.27',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.27',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.27',
            'ExtUtils::CBuilder::Platform::aix'=> '0.27',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.27',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.27',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.27',
            'ExtUtils::CBuilder::Platform::os2'=> '0.27',
            'File::Fetch'           => '0.22',
            'I18N::LangTags::Detect'=> '1.04',
            'I18N::Langinfo'        => '0.03',
            'IO::Compress::Adapter::Bzip2'=> '2.022',
            'IO::Compress::Adapter::Deflate'=> '2.022',
            'IO::Compress::Adapter::Identity'=> '2.022',
            'IO::Compress::Base'    => '2.022',
            'IO::Compress::Base::Common'=> '2.022',
            'IO::Compress::Bzip2'   => '2.022',
            'IO::Compress::Deflate' => '2.022',
            'IO::Compress::Gzip'    => '2.022',
            'IO::Compress::Gzip::Constants'=> '2.022',
            'IO::Compress::RawDeflate'=> '2.022',
            'IO::Compress::Zip'     => '2.022',
            'IO::Compress::Zip::Constants'=> '2.022',
            'IO::Compress::Zlib::Constants'=> '2.022',
            'IO::Compress::Zlib::Extra'=> '2.022',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.022',
            'IO::Uncompress::Adapter::Identity'=> '2.022',
            'IO::Uncompress::Adapter::Inflate'=> '2.022',
            'IO::Uncompress::AnyInflate'=> '2.022',
            'IO::Uncompress::AnyUncompress'=> '2.022',
            'IO::Uncompress::Base'  => '2.022',
            'IO::Uncompress::Bunzip2'=> '2.022',
            'IO::Uncompress::Gunzip'=> '2.022',
            'IO::Uncompress::Inflate'=> '2.022',
            'IO::Uncompress::RawInflate'=> '2.022',
            'IO::Uncompress::Unzip' => '2.022',
            'IPC::Cmd'              => '0.54',
            'List::Util'            => '1.22',
            'List::Util::PP'        => '1.22',
            'List::Util::XS'        => '1.22',
            'Locale::Maketext'      => '1.14',
            'Module::Build'         => '0.35_09',
            'Module::Build::Base'   => '0.35_09',
            'Module::Build::Compat' => '0.35_09',
            'Module::Build::Config' => '0.35_09',
            'Module::Build::Cookbook'=> '0.35_09',
            'Module::Build::Dumper' => '0.35_09',
            'Module::Build::ModuleInfo'=> '0.35_09',
            'Module::Build::Notes'  => '0.35_09',
            'Module::Build::PPMMaker'=> '0.35_09',
            'Module::Build::Platform::Amiga'=> '0.35_09',
            'Module::Build::Platform::Default'=> '0.35_09',
            'Module::Build::Platform::EBCDIC'=> '0.35_09',
            'Module::Build::Platform::MPEiX'=> '0.35_09',
            'Module::Build::Platform::MacOS'=> '0.35_09',
            'Module::Build::Platform::RiscOS'=> '0.35_09',
            'Module::Build::Platform::Unix'=> '0.35_09',
            'Module::Build::Platform::VMS'=> '0.35_09',
            'Module::Build::Platform::VOS'=> '0.35_09',
            'Module::Build::Platform::Windows'=> '0.35_09',
            'Module::Build::Platform::aix'=> '0.35_09',
            'Module::Build::Platform::cygwin'=> '0.35_09',
            'Module::Build::Platform::darwin'=> '0.35_09',
            'Module::Build::Platform::os2'=> '0.35_09',
            'Module::Build::PodParser'=> '0.35_09',
            'Module::Build::YAML'   => '1.40',
            'Module::CoreList'      => '2.23',
            'Module::Load::Conditional'=> '0.34',
            'Pod::Simple'           => '3.10',
            'Pod::Simple::XHTML'    => '3.10',
            'Scalar::Util'          => '1.22',
            'Scalar::Util::PP'      => '1.22',
            'Switch'                => '2.16',
            'XS::APItest'           => '0.17',
            'XS::APItest::KeywordRPN'=> '0.003',
            'base'                  => '2.15',
            'diagnostics'           => '1.18',
            'fields'                => '2.15',
            'inc::latest'           => '0.35_09',
            'legacy'                => '1.00',
            'overload'              => '1.10',
        },
        removed => {
        }
    },
    5.011003 => {
        delta_from => 5.011002,
        changed => {
            'App::Cpan'             => '1.570001',
            'Archive::Extract'      => '0.36',
            'CPAN'                  => '1.94_5301',
            'CPAN::FTP'             => '5.5004',
            'CPAN::FirstTime'       => '5.530001',
            'CPAN::Mirrors'         => '1.770001',
            'CPANPLUS'              => '0.90',
            'CPANPLUS::Internals'   => '0.90',
            'CPANPLUS::Shell::Default'=> '0.90',
            'Cwd'                   => '3.31',
            'Encode'                => '2.39',
            'ExtUtils::Command::MM' => '6.56',
            'ExtUtils::Liblist'     => '6.56',
            'ExtUtils::Liblist::Kid'=> '6.56',
            'ExtUtils::MM'          => '6.56',
            'ExtUtils::MM_AIX'      => '6.56',
            'ExtUtils::MM_Any'      => '6.56',
            'ExtUtils::MM_BeOS'     => '6.56',
            'ExtUtils::MM_Cygwin'   => '6.56',
            'ExtUtils::MM_DOS'      => '6.56',
            'ExtUtils::MM_Darwin'   => '6.56',
            'ExtUtils::MM_MacOS'    => '6.56',
            'ExtUtils::MM_NW5'      => '6.56',
            'ExtUtils::MM_OS2'      => '6.56',
            'ExtUtils::MM_QNX'      => '6.56',
            'ExtUtils::MM_UWIN'     => '6.56',
            'ExtUtils::MM_Unix'     => '6.56',
            'ExtUtils::MM_VMS'      => '6.56',
            'ExtUtils::MM_VOS'      => '6.56',
            'ExtUtils::MM_Win32'    => '6.56',
            'ExtUtils::MM_Win95'    => '6.56',
            'ExtUtils::MY'          => '6.56',
            'ExtUtils::MakeMaker'   => '6.56',
            'ExtUtils::MakeMaker::Config'=> '6.56',
            'ExtUtils::Mkbootstrap' => '6.56',
            'ExtUtils::Mksymlists'  => '6.56',
            'ExtUtils::testlib'     => '6.56',
            'File::Find'            => '1.15',
            'File::Path'            => '2.08_01',
            'File::Spec'            => '3.31',
            'Module::Build'         => '0.36',
            'Module::Build::Base'   => '0.36',
            'Module::Build::Compat' => '0.36',
            'Module::Build::Config' => '0.36',
            'Module::Build::Cookbook'=> '0.36',
            'Module::Build::Dumper' => '0.36',
            'Module::Build::ModuleInfo'=> '0.36',
            'Module::Build::Notes'  => '0.36',
            'Module::Build::PPMMaker'=> '0.36',
            'Module::Build::Platform::Amiga'=> '0.36',
            'Module::Build::Platform::Default'=> '0.36',
            'Module::Build::Platform::EBCDIC'=> '0.36',
            'Module::Build::Platform::MPEiX'=> '0.36',
            'Module::Build::Platform::MacOS'=> '0.36',
            'Module::Build::Platform::RiscOS'=> '0.36',
            'Module::Build::Platform::Unix'=> '0.36',
            'Module::Build::Platform::VMS'=> '0.36',
            'Module::Build::Platform::VOS'=> '0.36',
            'Module::Build::Platform::Windows'=> '0.36',
            'Module::Build::Platform::aix'=> '0.36',
            'Module::Build::Platform::cygwin'=> '0.36',
            'Module::Build::Platform::darwin'=> '0.36',
            'Module::Build::Platform::os2'=> '0.36',
            'Module::Build::PodParser'=> '0.36',
            'Module::CoreList'      => '2.24',
            'POSIX'                 => '1.19',
            'Pod::Simple'           => '3.13',
            'Pod::Simple::BlackBox' => '3.13',
            'Pod::Simple::Checker'  => '3.13',
            'Pod::Simple::Debug'    => '3.13',
            'Pod::Simple::DumpAsText'=> '3.13',
            'Pod::Simple::DumpAsXML'=> '3.13',
            'Pod::Simple::HTML'     => '3.13',
            'Pod::Simple::HTMLBatch'=> '3.13',
            'Pod::Simple::LinkSection'=> '3.13',
            'Pod::Simple::Methody'  => '3.13',
            'Pod::Simple::Progress' => '3.13',
            'Pod::Simple::PullParser'=> '3.13',
            'Pod::Simple::PullParserEndToken'=> '3.13',
            'Pod::Simple::PullParserStartToken'=> '3.13',
            'Pod::Simple::PullParserTextToken'=> '3.13',
            'Pod::Simple::PullParserToken'=> '3.13',
            'Pod::Simple::RTF'      => '3.13',
            'Pod::Simple::Search'   => '3.13',
            'Pod::Simple::SimpleTree'=> '3.13',
            'Pod::Simple::Text'     => '3.13',
            'Pod::Simple::TextContent'=> '3.13',
            'Pod::Simple::TiedOutFH'=> '3.13',
            'Pod::Simple::Transcode'=> '3.13',
            'Pod::Simple::TranscodeDumb'=> '3.13',
            'Pod::Simple::TranscodeSmart'=> '3.13',
            'Pod::Simple::XHTML'    => '3.13',
            'Pod::Simple::XMLOutStream'=> '3.13',
            'Safe'                  => '2.20',
            'Unicode'               => '5.2.0',
            'constant'              => '1.20',
            'diagnostics'           => '1.19',
            'feature'               => '1.14',
            'inc::latest'           => '0.36',
            'threads'               => '1.75',
            'warnings'              => '1.08',
        },
        removed => {
            'legacy'                => 1,
        }
    },
    5.011004 => {
        delta_from => 5.011003,
        changed => {
            'App::Cpan'             => '1.5701',
            'Archive::Extract'      => '0.38',
            'B::Deparse'            => '0.94',
            'CPAN'                  => '1.94_54',
            'CPAN::FirstTime'       => '5.53',
            'CPAN::Mirrors'         => '1.77',
            'Carp'                  => '1.15',
            'Carp::Heavy'           => '1.15',
            'Compress::Raw::Bzip2'  => '2.024',
            'Compress::Raw::Zlib'   => '2.024',
            'Compress::Zlib'        => '2.024',
            'File::Copy'            => '2.17',
            'File::Fetch'           => '0.24',
            'GDBM_File'             => '1.10',
            'IO::Compress::Adapter::Bzip2'=> '2.024',
            'IO::Compress::Adapter::Deflate'=> '2.024',
            'IO::Compress::Adapter::Identity'=> '2.024',
            'IO::Compress::Base'    => '2.024',
            'IO::Compress::Base::Common'=> '2.024',
            'IO::Compress::Bzip2'   => '2.024',
            'IO::Compress::Deflate' => '2.024',
            'IO::Compress::Gzip'    => '2.024',
            'IO::Compress::Gzip::Constants'=> '2.024',
            'IO::Compress::RawDeflate'=> '2.024',
            'IO::Compress::Zip'     => '2.024',
            'IO::Compress::Zip::Constants'=> '2.024',
            'IO::Compress::Zlib::Constants'=> '2.024',
            'IO::Compress::Zlib::Extra'=> '2.024',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.024',
            'IO::Uncompress::Adapter::Identity'=> '2.024',
            'IO::Uncompress::Adapter::Inflate'=> '2.024',
            'IO::Uncompress::AnyInflate'=> '2.024',
            'IO::Uncompress::AnyUncompress'=> '2.024',
            'IO::Uncompress::Base'  => '2.024',
            'IO::Uncompress::Bunzip2'=> '2.024',
            'IO::Uncompress::Gunzip'=> '2.024',
            'IO::Uncompress::Inflate'=> '2.024',
            'IO::Uncompress::RawInflate'=> '2.024',
            'IO::Uncompress::Unzip' => '2.024',
            'Module::Build'         => '0.3603',
            'Module::Build::Base'   => '0.3603',
            'Module::Build::Compat' => '0.3603',
            'Module::Build::Config' => '0.3603',
            'Module::Build::Cookbook'=> '0.3603',
            'Module::Build::Dumper' => '0.3603',
            'Module::Build::ModuleInfo'=> '0.3603',
            'Module::Build::Notes'  => '0.3603',
            'Module::Build::PPMMaker'=> '0.3603',
            'Module::Build::Platform::Amiga'=> '0.3603',
            'Module::Build::Platform::Default'=> '0.3603',
            'Module::Build::Platform::EBCDIC'=> '0.3603',
            'Module::Build::Platform::MPEiX'=> '0.3603',
            'Module::Build::Platform::MacOS'=> '0.3603',
            'Module::Build::Platform::RiscOS'=> '0.3603',
            'Module::Build::Platform::Unix'=> '0.3603',
            'Module::Build::Platform::VMS'=> '0.3603',
            'Module::Build::Platform::VOS'=> '0.3603',
            'Module::Build::Platform::Windows'=> '0.3603',
            'Module::Build::Platform::aix'=> '0.3603',
            'Module::Build::Platform::cygwin'=> '0.3603',
            'Module::Build::Platform::darwin'=> '0.3603',
            'Module::Build::Platform::os2'=> '0.3603',
            'Module::Build::PodParser'=> '0.3603',
            'Module::CoreList'      => '2.25',
            'PerlIO::encoding'      => '0.12',
            'Safe'                  => '2.21',
            'UNIVERSAL'             => '1.06',
            'feature'               => '1.15',
            'inc::latest'           => '0.3603',
            'less'                  => '0.03',
            're'                    => '0.11',
            'version'               => '0.81',
            'warnings'              => '1.09',
        },
        removed => {
        }
    },
    5.011005 => {
        delta_from => 5.011004,
        changed => {
            'B::Debug'              => '1.12',
            'CPAN'                  => '1.94_56',
            'CPAN::Debug'           => '5.5001',
            'CPAN::Distribution'    => '1.9456',
            'CPAN::FirstTime'       => '5.5301',
            'CPAN::HandleConfig'    => '5.5001',
            'CPAN::Shell'           => '5.5001',
            'CPAN::Tarzip'          => '5.5011',
            'CPANPLUS::Dist::Build' => '0.46',
            'CPANPLUS::Dist::Build::Constants'=> '0.46',
            'Module::CoreList'      => '2.26',
            'Pod::Man'              => '2.23',
            'Pod::ParseLink'        => '1.10',
            'Pod::Perldoc'          => '3.15_02',
            'Pod::Plainer'          => '1.02',
            'Pod::Text'             => '3.14',
            'Pod::Text::Color'      => '2.06',
            'Pod::Text::Overstrike' => '2.04',
            'Pod::Text::Termcap'    => '2.06',
            'Safe'                  => '2.22',
            'Socket'                => '1.86',
            'version'               => '0.82',
        },
        removed => {
        }
    },
    5.012 => {
        delta_from => 5.011005,
        changed => {
            'B::Deparse'            => '0.96',
            'CPAN::Distribution'    => '1.9456_01',
            'Module::CoreList'      => '2.29',
            'Safe'                  => '2.25',
            'Socket'                => '1.87',
            'Tie::Scalar'           => '1.02',
            'Time::Piece'           => '1.15_01',
            'bytes'                 => '1.04',
            'feature'               => '1.16',
            'utf8'                  => '1.08',
        },
        removed => {
        }
    },
    5.012001 => {
        delta_from => 5.012,
        changed => {
            'B::Deparse'            => '0.97',
            'CGI'                   => '3.49',
            'CGI::Fast'             => '1.08',
            'Carp'                  => '1.16',
            'Carp::Heavy'           => '1.16',
            'File::Copy'            => '2.18',
            'Module::CoreList'      => '2.32',
            'Pod::Functions'        => '1.04',
            'Pod::Simple'           => '3.14',
            'Pod::Simple::BlackBox' => '3.14',
            'Pod::Simple::Checker'  => '3.14',
            'Pod::Simple::Debug'    => '3.14',
            'Pod::Simple::DumpAsText'=> '3.14',
            'Pod::Simple::DumpAsXML'=> '3.14',
            'Pod::Simple::HTML'     => '3.14',
            'Pod::Simple::HTMLBatch'=> '3.14',
            'Pod::Simple::LinkSection'=> '3.14',
            'Pod::Simple::Methody'  => '3.14',
            'Pod::Simple::Progress' => '3.14',
            'Pod::Simple::PullParser'=> '3.14',
            'Pod::Simple::PullParserEndToken'=> '3.14',
            'Pod::Simple::PullParserStartToken'=> '3.14',
            'Pod::Simple::PullParserTextToken'=> '3.14',
            'Pod::Simple::PullParserToken'=> '3.14',
            'Pod::Simple::RTF'      => '3.14',
            'Pod::Simple::Search'   => '3.14',
            'Pod::Simple::SimpleTree'=> '3.14',
            'Pod::Simple::Text'     => '3.14',
            'Pod::Simple::TextContent'=> '3.14',
            'Pod::Simple::TiedOutFH'=> '3.14',
            'Pod::Simple::Transcode'=> '3.14',
            'Pod::Simple::TranscodeDumb'=> '3.14',
            'Pod::Simple::TranscodeSmart'=> '3.14',
            'Pod::Simple::XHTML'    => '3.14',
            'Pod::Simple::XMLOutStream'=> '3.14',
            'Safe'                  => '2.27',
        },
        removed => {
        }
    },
    5.012002 => {
        delta_from => 5.012001,
        changed => {
            'Carp'                  => '1.17',
            'Carp::Heavy'           => '1.17',
            'File::Spec'            => '3.31_01',
            'Module::CoreList'      => '2.38',
            'Module::Load::Conditional'=> '0.38',
            'PerlIO::scalar'        => '0.08',
        },
        removed => {
        }
    },
    5.012003 => {
        delta_from => 5.012002,
        changed => {
            'B::Deparse'            => '0.9701',
            'Module::Build::Platform::cygwin'=> '0.360301',
            'Module::CoreList'      => '2.43',
            'Socket'                => '1.87_01',
        },
        removed => {
        }
    },
    5.012004 => {
        delta_from => 5.012003,
        changed => {
            'Module::CoreList'      => '2.50',
        },
        removed => {
        }
    },
    5.012005 => {
        delta_from => 5.012004,
        changed => {
            'B::Concise'            => '0.78_01',
            'Encode'                => '2.39_01',
            'File::Glob'            => '1.07_01',
            'Module::CoreList'      => '2.50_02',
            'Unicode::UCD'          => '0.29',
            'charnames'             => '1.07_01',
        },
        removed => {
        }
    },
    5.013 => {
        delta_from => 5.012,
        changed => {
            'CGI'                   => '3.49',
            'CGI::Fast'             => '1.08',
            'Data::Dumper'          => '2.126',
            'ExtUtils::MM_Unix'     => '6.5601',
            'ExtUtils::MakeMaker'   => '6.5601',
            'File::Copy'            => '2.18',
            'IPC::Open3'            => '1.06',
            'MIME::Base64'          => '3.09',
            'MIME::QuotedPrint'     => '3.09',
            'Module::CoreList'      => '2.31',
            'Pod::Functions'        => '1.04',
            'XS::APItest'           => '0.18',
            'XS::APItest::KeywordRPN'=> '0.004',
            'feature'               => '1.17',
            'threads'               => '1.77_01',
            'threads::shared'       => '1.33',
        },
        removed => {
        }
    },
    5.013001 => {
        delta_from => 5.012001,
        changed => {
            'Data::Dumper'          => '2.126',
            'Dumpvalue'             => '1.14',
            'Errno'                 => '1.12',
            'ExtUtils::MM_Unix'     => '6.5601',
            'ExtUtils::MakeMaker'   => '6.5601',
            'ExtUtils::ParseXS'     => '2.2205',
            'File::Find'            => '1.16',
            'IPC::Cmd'              => '0.58',
            'IPC::Open3'            => '1.06',
            'List::Util'            => '1.23',
            'List::Util::PP'        => '1.23',
            'List::Util::XS'        => '1.23',
            'Locale::Codes'         => '3.12',
            'Locale::Codes::Country'=> '3.12',
            'Locale::Codes::Currency'=> '3.12',
            'Locale::Codes::Language'=> '3.12',
            'Locale::Codes::Script' => '3.12',
            'Locale::Constants'     => '3.12',
            'Locale::Country'       => '3.12',
            'Locale::Currency'      => '3.12',
            'Locale::Language'      => '3.12',
            'Locale::Script'        => '3.12',
            'MIME::Base64'          => '3.09',
            'MIME::QuotedPrint'     => '3.09',
            'Module::Build::Platform::cygwin'=> '0.360301',
            'Module::CoreList'      => '2.34',
            'Module::Load::Conditional'=> '0.38',
            'PerlIO::scalar'        => '0.08',
            'Scalar::Util'          => '1.23',
            'Scalar::Util::PP'      => '1.23',
            'Socket'                => '1.88',
            'Term::ReadLine'        => '1.06',
            'Unicode::UCD'          => '0.28',
            'XS::APItest'           => '0.19',
            'XS::APItest::KeywordRPN'=> '0.004',
            'charnames'             => '1.08',
            'feature'               => '1.17',
            'threads'               => '1.77_01',
            'threads::shared'       => '1.33',
        },
        removed => {
            'Class::ISA'            => 1,
            'Pod::Plainer'          => 1,
            'Switch'                => 1,
        }
    },
    5.013002 => {
        delta_from => 5.013001,
        changed => {
            'B::Concise'            => '0.79',
            'B::Deparse'            => '0.98',
            'CPAN'                  => '1.94_57',
            'CPAN::Distribution'    => '1.9600',
            'Exporter'              => '5.64_02',
            'Exporter::Heavy'       => '5.64_02',
            'File::Copy'            => '2.19',
            'Hash::Util'            => '0.08',
            'IO::Socket'            => '1.32',
            'Locale::Codes'         => '3.13',
            'Locale::Codes::Country'=> '3.13',
            'Locale::Codes::Currency'=> '3.13',
            'Locale::Codes::Language'=> '3.13',
            'Locale::Codes::Script' => '3.13',
            'Locale::Constants'     => '3.13',
            'Locale::Country'       => '3.13',
            'Locale::Currency'      => '3.13',
            'Locale::Language'      => '3.13',
            'Locale::Script'        => '3.13',
            'Search::Dict'          => '1.03',
            'Socket'                => '1.89',
            'Thread::Semaphore'     => '2.11',
            'UNIVERSAL'             => '1.07',
            'VMS::DCLsym'           => '1.04',
            'mro'                   => '1.03',
            'threads'               => '1.77_02',
            'threads::shared'       => '1.33_01',
        },
        removed => {
        }
    },
    5.013003 => {
        delta_from => 5.013002,
        changed => {
            'App::Prove'            => '3.21',
            'App::Prove::State'     => '3.21',
            'App::Prove::State::Result'=> '3.21',
            'App::Prove::State::Result::Test'=> '3.21',
            'Archive::Extract'      => '0.42',
            'Archive::Tar'          => '1.64',
            'Archive::Tar::Constant'=> '1.64',
            'Archive::Tar::File'    => '1.64',
            'Attribute::Handlers'   => '0.88',
            'CPANPLUS'              => '0.9007',
            'CPANPLUS::Internals'   => '0.9007',
            'CPANPLUS::Shell::Default'=> '0.9007',
            'Compress::Raw::Bzip2'  => '2.027',
            'Compress::Raw::Zlib'   => '2.027_01',
            'Compress::Zlib'        => '2.027',
            'DB'                    => '1.03',
            'Digest::MD5'           => '2.40',
            'Digest::SHA'           => '5.48',
            'Exporter'              => '5.64_03',
            'Exporter::Heavy'       => '5.64_03',
            'ExtUtils::CBuilder'    => '0.2703',
            'ExtUtils::CBuilder::Base'=> '0.2703_01',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.2703',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.2703',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.2703',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.2703',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.2703',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.2703',
            'ExtUtils::CBuilder::Platform::aix'=> '0.2703',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.2703',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.2703',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.2703',
            'ExtUtils::CBuilder::Platform::os2'=> '0.2703',
            'ExtUtils::Manifest'    => '1.58',
            'ExtUtils::ParseXS'     => '2.2206',
            'Fatal'                 => '2.10',
            'File::Basename'        => '2.79',
            'File::Copy'            => '2.20',
            'File::DosGlob'         => '1.02',
            'File::Find'            => '1.17',
            'File::Glob'            => '1.08',
            'File::stat'            => '1.03',
            'I18N::LangTags'        => '0.35_01',
            'I18N::LangTags::List'  => '0.35_01',
            'IO::Compress::Adapter::Bzip2'=> '2.027',
            'IO::Compress::Adapter::Deflate'=> '2.027',
            'IO::Compress::Adapter::Identity'=> '2.027',
            'IO::Compress::Base'    => '2.027',
            'IO::Compress::Base::Common'=> '2.027',
            'IO::Compress::Bzip2'   => '2.027',
            'IO::Compress::Deflate' => '2.027',
            'IO::Compress::Gzip'    => '2.027',
            'IO::Compress::Gzip::Constants'=> '2.027',
            'IO::Compress::RawDeflate'=> '2.027',
            'IO::Compress::Zip'     => '2.027',
            'IO::Compress::Zip::Constants'=> '2.027',
            'IO::Compress::Zlib::Constants'=> '2.027',
            'IO::Compress::Zlib::Extra'=> '2.027',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.027',
            'IO::Uncompress::Adapter::Identity'=> '2.027',
            'IO::Uncompress::Adapter::Inflate'=> '2.027',
            'IO::Uncompress::AnyInflate'=> '2.027',
            'IO::Uncompress::AnyUncompress'=> '2.027',
            'IO::Uncompress::Base'  => '2.027',
            'IO::Uncompress::Bunzip2'=> '2.027',
            'IO::Uncompress::Gunzip'=> '2.027',
            'IO::Uncompress::Inflate'=> '2.027',
            'IO::Uncompress::RawInflate'=> '2.027',
            'IO::Uncompress::Unzip' => '2.027',
            'IPC::Cmd'              => '0.60',
            'IPC::Msg'              => '2.03',
            'IPC::Semaphore'        => '2.03',
            'IPC::SharedMem'        => '2.03',
            'IPC::SysV'             => '2.03',
            'Locale::Maketext'      => '1.15',
            'Locale::Maketext::Guts'=> undef,
            'Locale::Maketext::GutsLoader'=> undef,
            'Module::Build'         => '0.3607',
            'Module::Build::Base'   => '0.3607',
            'Module::Build::Compat' => '0.3607',
            'Module::Build::Config' => '0.3607',
            'Module::Build::Cookbook'=> '0.3607',
            'Module::Build::Dumper' => '0.3607',
            'Module::Build::ModuleInfo'=> '0.3607',
            'Module::Build::Notes'  => '0.3607',
            'Module::Build::PPMMaker'=> '0.3607',
            'Module::Build::Platform::Amiga'=> '0.3607',
            'Module::Build::Platform::Default'=> '0.3607',
            'Module::Build::Platform::EBCDIC'=> '0.3607',
            'Module::Build::Platform::MPEiX'=> '0.3607',
            'Module::Build::Platform::MacOS'=> '0.3607',
            'Module::Build::Platform::RiscOS'=> '0.3607',
            'Module::Build::Platform::Unix'=> '0.3607',
            'Module::Build::Platform::VMS'=> '0.3607',
            'Module::Build::Platform::VOS'=> '0.3607',
            'Module::Build::Platform::Windows'=> '0.3607',
            'Module::Build::Platform::aix'=> '0.3607',
            'Module::Build::Platform::cygwin'=> '0.3607',
            'Module::Build::Platform::darwin'=> '0.3607',
            'Module::Build::Platform::os2'=> '0.3607',
            'Module::Build::PodParser'=> '0.3607',
            'Module::CoreList'      => '2.36',
            'Module::Load'          => '0.18',
            'TAP::Base'             => '3.21',
            'TAP::Formatter::Base'  => '3.21',
            'TAP::Formatter::Color' => '3.21',
            'TAP::Formatter::Console'=> '3.21',
            'TAP::Formatter::Console::ParallelSession'=> '3.21',
            'TAP::Formatter::Console::Session'=> '3.21',
            'TAP::Formatter::File'  => '3.21',
            'TAP::Formatter::File::Session'=> '3.21',
            'TAP::Formatter::Session'=> '3.21',
            'TAP::Harness'          => '3.21',
            'TAP::Object'           => '3.21',
            'TAP::Parser'           => '3.21',
            'TAP::Parser::Aggregator'=> '3.21',
            'TAP::Parser::Grammar'  => '3.21',
            'TAP::Parser::Iterator' => '3.21',
            'TAP::Parser::Iterator::Array'=> '3.21',
            'TAP::Parser::Iterator::Process'=> '3.21',
            'TAP::Parser::Iterator::Stream'=> '3.21',
            'TAP::Parser::IteratorFactory'=> '3.21',
            'TAP::Parser::Multiplexer'=> '3.21',
            'TAP::Parser::Result'   => '3.21',
            'TAP::Parser::Result::Bailout'=> '3.21',
            'TAP::Parser::Result::Comment'=> '3.21',
            'TAP::Parser::Result::Plan'=> '3.21',
            'TAP::Parser::Result::Pragma'=> '3.21',
            'TAP::Parser::Result::Test'=> '3.21',
            'TAP::Parser::Result::Unknown'=> '3.21',
            'TAP::Parser::Result::Version'=> '3.21',
            'TAP::Parser::Result::YAML'=> '3.21',
            'TAP::Parser::ResultFactory'=> '3.21',
            'TAP::Parser::Scheduler'=> '3.21',
            'TAP::Parser::Scheduler::Job'=> '3.21',
            'TAP::Parser::Scheduler::Spinner'=> '3.21',
            'TAP::Parser::Source'   => '3.21',
            'TAP::Parser::SourceHandler'=> '3.21',
            'TAP::Parser::SourceHandler::Executable'=> '3.21',
            'TAP::Parser::SourceHandler::File'=> '3.21',
            'TAP::Parser::SourceHandler::Handle'=> '3.21',
            'TAP::Parser::SourceHandler::Perl'=> '3.21',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.21',
            'TAP::Parser::SourceHandler::pgTAP'=> '3.21',
            'TAP::Parser::Utils'    => '3.21',
            'TAP::Parser::YAMLish::Reader'=> '3.21',
            'TAP::Parser::YAMLish::Writer'=> '3.21',
            'Term::ANSIColor'       => '3.00',
            'Term::ReadLine'        => '1.07',
            'Test::Harness'         => '3.21',
            'Tie::Array'            => '1.04',
            'Time::HiRes'           => '1.9721',
            'Time::Piece'           => '1.20_01',
            'Unicode::Collate'      => '0.53',
            'Unicode::Normalize'    => '1.06',
            'Unicode::UCD'          => '0.29',
            'autodie'               => '2.10',
            'autodie::exception'    => '2.10',
            'autodie::exception::system'=> '2.10',
            'autodie::hints'        => '2.10',
            'blib'                  => '1.05',
            'charnames'             => '1.11',
            'diagnostics'           => '1.20',
            'inc::latest'           => '0.3607',
            'lib'                   => '0.63',
            're'                    => '0.12',
            'threads'               => '1.77_03',
            'threads::shared'       => '1.33_02',
            'vars'                  => '1.02',
            'warnings'              => '1.10',
        },
        removed => {
            'TAP::Parser::Source::Perl'=> 1,
        }
    },
    5.013004 => {
        delta_from => 5.013003,
        changed => {
            'App::Prove'            => '3.22',
            'App::Prove::State'     => '3.22',
            'App::Prove::State::Result'=> '3.22',
            'App::Prove::State::Result::Test'=> '3.22',
            'Archive::Tar'          => '1.68',
            'Archive::Tar::Constant'=> '1.68',
            'Archive::Tar::File'    => '1.68',
            'B::Lint'               => '1.12',
            'B::Lint::Debug'        => '1.12',
            'Carp'                  => '1.18',
            'Carp::Heavy'           => '1.18',
            'Compress::Raw::Bzip2'  => '2.030',
            'Compress::Raw::Zlib'   => '2.030',
            'Compress::Zlib'        => '2.030',
            'ExtUtils::ParseXS'     => '2.2207',
            'File::Spec'            => '3.31_01',
            'I18N::Langinfo'        => '0.04',
            'IO::Compress::Adapter::Bzip2'=> '2.030',
            'IO::Compress::Adapter::Deflate'=> '2.030',
            'IO::Compress::Adapter::Identity'=> '2.030',
            'IO::Compress::Base'    => '2.030',
            'IO::Compress::Base::Common'=> '2.030',
            'IO::Compress::Bzip2'   => '2.030',
            'IO::Compress::Deflate' => '2.030',
            'IO::Compress::Gzip'    => '2.030',
            'IO::Compress::Gzip::Constants'=> '2.030',
            'IO::Compress::RawDeflate'=> '2.030',
            'IO::Compress::Zip'     => '2.030',
            'IO::Compress::Zip::Constants'=> '2.030',
            'IO::Compress::Zlib::Constants'=> '2.030',
            'IO::Compress::Zlib::Extra'=> '2.030',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.030',
            'IO::Uncompress::Adapter::Identity'=> '2.030',
            'IO::Uncompress::Adapter::Inflate'=> '2.030',
            'IO::Uncompress::AnyInflate'=> '2.030',
            'IO::Uncompress::AnyUncompress'=> '2.030',
            'IO::Uncompress::Base'  => '2.030',
            'IO::Uncompress::Bunzip2'=> '2.030',
            'IO::Uncompress::Gunzip'=> '2.030',
            'IO::Uncompress::Inflate'=> '2.030',
            'IO::Uncompress::RawInflate'=> '2.030',
            'IO::Uncompress::Unzip' => '2.030',
            'Module::CoreList'      => '2.37',
            'TAP::Base'             => '3.22',
            'TAP::Formatter::Base'  => '3.22',
            'TAP::Formatter::Color' => '3.22',
            'TAP::Formatter::Console'=> '3.22',
            'TAP::Formatter::Console::ParallelSession'=> '3.22',
            'TAP::Formatter::Console::Session'=> '3.22',
            'TAP::Formatter::File'  => '3.22',
            'TAP::Formatter::File::Session'=> '3.22',
            'TAP::Formatter::Session'=> '3.22',
            'TAP::Harness'          => '3.22',
            'TAP::Object'           => '3.22',
            'TAP::Parser'           => '3.22',
            'TAP::Parser::Aggregator'=> '3.22',
            'TAP::Parser::Grammar'  => '3.22',
            'TAP::Parser::Iterator' => '3.22',
            'TAP::Parser::Iterator::Array'=> '3.22',
            'TAP::Parser::Iterator::Process'=> '3.22',
            'TAP::Parser::Iterator::Stream'=> '3.22',
            'TAP::Parser::IteratorFactory'=> '3.22',
            'TAP::Parser::Multiplexer'=> '3.22',
            'TAP::Parser::Result'   => '3.22',
            'TAP::Parser::Result::Bailout'=> '3.22',
            'TAP::Parser::Result::Comment'=> '3.22',
            'TAP::Parser::Result::Plan'=> '3.22',
            'TAP::Parser::Result::Pragma'=> '3.22',
            'TAP::Parser::Result::Test'=> '3.22',
            'TAP::Parser::Result::Unknown'=> '3.22',
            'TAP::Parser::Result::Version'=> '3.22',
            'TAP::Parser::Result::YAML'=> '3.22',
            'TAP::Parser::ResultFactory'=> '3.22',
            'TAP::Parser::Scheduler'=> '3.22',
            'TAP::Parser::Scheduler::Job'=> '3.22',
            'TAP::Parser::Scheduler::Spinner'=> '3.22',
            'TAP::Parser::Source'   => '3.22',
            'TAP::Parser::SourceHandler'=> '3.22',
            'TAP::Parser::SourceHandler::Executable'=> '3.22',
            'TAP::Parser::SourceHandler::File'=> '3.22',
            'TAP::Parser::SourceHandler::Handle'=> '3.22',
            'TAP::Parser::SourceHandler::Perl'=> '3.22',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.22',
            'TAP::Parser::Utils'    => '3.22',
            'TAP::Parser::YAMLish::Reader'=> '3.22',
            'TAP::Parser::YAMLish::Writer'=> '3.22',
            'Test::Builder'         => '0.96',
            'Test::Builder::Module' => '0.96',
            'Test::Builder::Tester' => '1.20',
            'Test::Builder::Tester::Color'=> '1.20',
            'Test::Harness'         => '3.22',
            'Test::More'            => '0.96',
            'Test::Simple'          => '0.96',
            'Unicode::Collate'      => '0.56',
            'Unicode::Collate::Locale'=> '0.56',
            'XS::APItest'           => '0.20',
            'charnames'             => '1.15',
            'feature'               => '1.18',
        },
        removed => {
            'TAP::Parser::SourceHandler::pgTAP'=> 1,
        }
    },
    5.013005 => {
        delta_from => 5.013004,
        changed => {
            'B::Debug'              => '1.16',
            'CPANPLUS::Dist::Build' => '0.48',
            'CPANPLUS::Dist::Build::Constants'=> '0.48',
            'Data::Dumper'          => '2.128',
            'Encode'                => '2.40',
            'Encode::Guess'         => '2.04',
            'Encode::MIME::Header'  => '2.12',
            'Encode::Unicode::UTF7' => '2.05',
            'Errno'                 => '1.13',
            'ExtUtils::Command::MM' => '6.57_05',
            'ExtUtils::Liblist'     => '6.57_05',
            'ExtUtils::Liblist::Kid'=> '6.5705',
            'ExtUtils::MM'          => '6.57_05',
            'ExtUtils::MM_AIX'      => '6.57_05',
            'ExtUtils::MM_Any'      => '6.57_05',
            'ExtUtils::MM_BeOS'     => '6.57_05',
            'ExtUtils::MM_Cygwin'   => '6.57_05',
            'ExtUtils::MM_DOS'      => '6.5705',
            'ExtUtils::MM_Darwin'   => '6.57_05',
            'ExtUtils::MM_MacOS'    => '6.5705',
            'ExtUtils::MM_NW5'      => '6.57_05',
            'ExtUtils::MM_OS2'      => '6.57_05',
            'ExtUtils::MM_QNX'      => '6.57_05',
            'ExtUtils::MM_UWIN'     => '6.5705',
            'ExtUtils::MM_Unix'     => '6.57_05',
            'ExtUtils::MM_VMS'      => '6.57_05',
            'ExtUtils::MM_VOS'      => '6.57_05',
            'ExtUtils::MM_Win32'    => '6.57_05',
            'ExtUtils::MM_Win95'    => '6.57_05',
            'ExtUtils::MY'          => '6.5705',
            'ExtUtils::MakeMaker'   => '6.57_05',
            'ExtUtils::MakeMaker::Config'=> '6.57_05',
            'ExtUtils::MakeMaker::YAML'=> '1.44',
            'ExtUtils::Mkbootstrap' => '6.57_05',
            'ExtUtils::Mksymlists'  => '6.57_05',
            'ExtUtils::testlib'     => '6.5705',
            'Filter::Simple'        => '0.85',
            'Hash::Util'            => '0.09',
            'Math::BigFloat'        => '1.62',
            'Math::BigInt'          => '1.95',
            'Math::BigInt::Calc'    => '0.54',
            'Math::BigInt::CalcEmu' => '0.06',
            'Math::BigInt::FastCalc'=> '0.22',
            'Math::BigRat'          => '0.26',
            'Module::CoreList'      => '2.39',
            'POSIX'                 => '1.20',
            'PerlIO::scalar'        => '0.09',
            'Safe'                  => '2.28',
            'Test::Builder'         => '0.97_01',
            'Test::Builder::Module' => '0.97_01',
            'Test::Builder::Tester' => '1.21_01',
            'Test::Builder::Tester::Color'=> '1.21_01',
            'Test::More'            => '0.97_01',
            'Test::Simple'          => '0.97_01',
            'Tie::Hash'             => '1.04',
            'Unicode::Collate'      => '0.59',
            'Unicode::Collate::Locale'=> '0.59',
            'XS::APItest'           => '0.21',
            'XS::APItest::KeywordRPN'=> '0.005',
            'XSLoader'              => '0.11',
            'bigint'                => '0.25',
            'bignum'                => '0.25',
            'bigrat'                => '0.25',
            'blib'                  => '1.06',
            'open'                  => '1.08',
            'threads::shared'       => '1.33_03',
            'warnings'              => '1.11',
            'warnings::register'    => '1.02',
        },
        removed => {
        }
    },
    5.013006 => {
        delta_from => 5.013005,
        changed => {
            'Archive::Extract'      => '0.44',
            'B'                     => '1.24',
            'B::Deparse'            => '0.99',
            'CPAN'                  => '1.94_61',
            'CPAN::FTP'             => '5.5005',
            'CPAN::Queue'           => '5.5001',
            'CPAN::Version'         => '5.5001',
            'Carp'                  => '1.19',
            'Carp::Heavy'           => '1.19',
            'Compress::Raw::Bzip2'  => '2.031',
            'Cwd'                   => '3.34',
            'Data::Dumper'          => '2.129',
            'Devel::Peek'           => '1.05',
            'Digest::MD5'           => '2.51',
            'ExtUtils::Constant::Base'=> '0.05',
            'ExtUtils::Constant::ProxySubs'=> '0.07',
            'ExtUtils::Embed'       => '1.29',
            'ExtUtils::XSSymSet'    => '1.2',
            'Fcntl'                 => '1.09',
            'File::DosGlob'         => '1.03',
            'File::Find'            => '1.18',
            'File::Glob'            => '1.09',
            'File::Spec'            => '3.33',
            'File::Spec::Cygwin'    => '3.33',
            'File::Spec::Epoc'      => '3.33',
            'File::Spec::Functions' => '3.33',
            'File::Spec::Mac'       => '3.33',
            'File::Spec::OS2'       => '3.33',
            'File::Spec::Unix'      => '3.33',
            'File::Spec::VMS'       => '3.33',
            'File::Spec::Win32'     => '3.33',
            'GDBM_File'             => '1.11',
            'Hash::Util::FieldHash' => '1.05',
            'I18N::Langinfo'        => '0.06',
            'IPC::Cmd'              => '0.64',
            'IPC::Open3'            => '1.07',
            'Locale::Codes'         => '3.14',
            'Locale::Codes::Country'=> '3.14',
            'Locale::Codes::Currency'=> '3.14',
            'Locale::Codes::Language'=> '3.14',
            'Locale::Codes::Script' => '3.14',
            'Locale::Constants'     => '3.14',
            'Locale::Country'       => '3.14',
            'Locale::Currency'      => '3.14',
            'Locale::Language'      => '3.14',
            'Locale::Maketext'      => '1.16',
            'Locale::Script'        => '3.14',
            'Math::BigFloat'        => '1.63',
            'Math::BigInt'          => '1.97',
            'Math::BigInt::Calc'    => '0.55',
            'Math::BigInt::CalcEmu' => '0.07',
            'Module::CoreList'      => '2.40',
            'NDBM_File'             => '1.09',
            'NEXT'                  => '0.65',
            'ODBM_File'             => '1.08',
            'Opcode'                => '1.16',
            'POSIX'                 => '1.21',
            'PerlIO::encoding'      => '0.13',
            'PerlIO::scalar'        => '0.10',
            'PerlIO::via'           => '0.10',
            'Pod::Man'              => '2.25',
            'Pod::Text'             => '3.15',
            'SDBM_File'             => '1.07',
            'Socket'                => '1.90',
            'Sys::Hostname'         => '1.13',
            'Tie::Hash::NamedCapture'=> '0.07',
            'Unicode::Collate'      => '0.63',
            'Unicode::Collate::Locale'=> '0.63',
            'Unicode::Normalize'    => '1.07',
            'XS::APItest'           => '0.23',
            'XSLoader'              => '0.13',
            'attributes'            => '0.13',
            'charnames'             => '1.16',
            'if'                    => '0.06',
            'mro'                   => '1.04',
            'overload'              => '1.11',
            're'                    => '0.13',
            'sigtrap'               => '1.05',
            'threads'               => '1.81_01',
            'threads::shared'       => '1.34',
        },
        removed => {
            'XS::APItest::KeywordRPN'=> 1,
        }
    },
    5.013007 => {
        delta_from => 5.013006,
        changed => {
            'Archive::Extract'      => '0.46',
            'Archive::Tar'          => '1.72',
            'Archive::Tar::Constant'=> '1.72',
            'Archive::Tar::File'    => '1.72',
            'AutoLoader'            => '5.71',
            'B'                     => '1.26',
            'B::Concise'            => '0.81',
            'B::Deparse'            => '1.01',
            'CGI'                   => '3.50',
            'CPAN'                  => '1.94_62',
            'CPANPLUS'              => '0.9010',
            'CPANPLUS::Dist::Build' => '0.50',
            'CPANPLUS::Dist::Build::Constants'=> '0.50',
            'CPANPLUS::Internals'   => '0.9010',
            'CPANPLUS::Shell::Default'=> '0.9010',
            'Data::Dumper'          => '2.130_01',
            'DynaLoader'            => '1.11',
            'ExtUtils::Constant'    => '0.23',
            'ExtUtils::Constant::ProxySubs'=> '0.08',
            'Fcntl'                 => '1.10',
            'File::Fetch'           => '0.28',
            'File::Glob'            => '1.10',
            'File::stat'            => '1.04',
            'GDBM_File'             => '1.12',
            'Hash::Util'            => '0.10',
            'Hash::Util::FieldHash' => '1.06',
            'I18N::Langinfo'        => '0.07',
            'Locale::Maketext'      => '1.17',
            'Locale::Maketext::Guts'=> '1.17',
            'Locale::Maketext::GutsLoader'=> '1.17',
            'MIME::Base64'          => '3.10',
            'MIME::QuotedPrint'     => '3.10',
            'Math::BigFloat'        => '1.99_01',
            'Math::BigInt'          => '1.99_01',
            'Math::BigInt::Calc'    => '1.99_01',
            'Math::BigInt::CalcEmu' => '1.99_01',
            'Math::BigInt::FastCalc'=> '0.24_01',
            'Math::BigRat'          => '0.26_01',
            'Module::CoreList'      => '2.41',
            'NDBM_File'             => '1.10',
            'ODBM_File'             => '1.09',
            'Opcode'                => '1.17',
            'POSIX'                 => '1.22',
            'Pod::Simple'           => '3.15',
            'Pod::Simple::BlackBox' => '3.15',
            'Pod::Simple::Checker'  => '3.15',
            'Pod::Simple::Debug'    => '3.15',
            'Pod::Simple::DumpAsText'=> '3.15',
            'Pod::Simple::DumpAsXML'=> '3.15',
            'Pod::Simple::HTML'     => '3.15',
            'Pod::Simple::HTMLBatch'=> '3.15',
            'Pod::Simple::LinkSection'=> '3.15',
            'Pod::Simple::Methody'  => '3.15',
            'Pod::Simple::Progress' => '3.15',
            'Pod::Simple::PullParser'=> '3.15',
            'Pod::Simple::PullParserEndToken'=> '3.15',
            'Pod::Simple::PullParserStartToken'=> '3.15',
            'Pod::Simple::PullParserTextToken'=> '3.15',
            'Pod::Simple::PullParserToken'=> '3.15',
            'Pod::Simple::RTF'      => '3.15',
            'Pod::Simple::Search'   => '3.15',
            'Pod::Simple::SimpleTree'=> '3.15',
            'Pod::Simple::Text'     => '3.15',
            'Pod::Simple::TextContent'=> '3.15',
            'Pod::Simple::TiedOutFH'=> '3.15',
            'Pod::Simple::Transcode'=> '3.15',
            'Pod::Simple::TranscodeDumb'=> '3.15',
            'Pod::Simple::TranscodeSmart'=> '3.15',
            'Pod::Simple::XHTML'    => '3.15',
            'Pod::Simple::XMLOutStream'=> '3.15',
            'SDBM_File'             => '1.08',
            'Safe'                  => '2.29',
            'SelfLoader'            => '1.18',
            'Socket'                => '1.91',
            'Storable'              => '2.24',
            'Sys::Hostname'         => '1.14',
            'Unicode'               => '6.0.0',
            'Unicode::Collate'      => '0.67',
            'Unicode::Collate::CJK::Big5'=> '0.65',
            'Unicode::Collate::CJK::GB2312'=> '0.65',
            'Unicode::Collate::CJK::JISX0208'=> '0.64',
            'Unicode::Collate::CJK::Korean'=> '0.66',
            'Unicode::Collate::CJK::Pinyin'=> '0.65',
            'Unicode::Collate::CJK::Stroke'=> '0.65',
            'Unicode::Collate::Locale'=> '0.67',
            'XS::APItest'           => '0.26',
            'XS::Typemap'           => '0.04',
            'charnames'             => '1.17',
            'mro'                   => '1.05',
            'parent'                => '0.224',
            're'                    => '0.14',
            'threads'               => '1.81_02',
        },
        removed => {
        }
    },
    5.013008 => {
        delta_from => 5.013007,
        changed => {
            'Archive::Tar'          => '1.74',
            'Archive::Tar::Constant'=> '1.74',
            'Archive::Tar::File'    => '1.74',
            'B'                     => '1.27',
            'B::Concise'            => '0.82',
            'B::Deparse'            => '1.02',
            'Carp::Heavy'           => '1.17',
            'Cwd'                   => '3.35',
            'Data::Dumper'          => '2.130_02',
            'Devel::Peek'           => '1.06',
            'Devel::SelfStubber'    => '1.05',
            'Digest::SHA'           => '5.50',
            'Dumpvalue'             => '1.15',
            'DynaLoader'            => '1.12',
            'Env'                   => '1.02',
            'Exporter::Heavy'       => '5.64_01',
            'ExtUtils::CBuilder'    => '0.280201',
            'ExtUtils::CBuilder::Base'=> '0.280201',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280201',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280201',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280201',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280201',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280201',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280201',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280201',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280201',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280201',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280201',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280201',
            'ExtUtils::Constant::Utils'=> '0.03',
            'ExtUtils::Embed'       => '1.30',
            'ExtUtils::ParseXS'     => '2.2208',
            'Fatal'                 => '2.1001',
            'Fcntl'                 => '1.11',
            'File::CheckTree'       => '4.41',
            'File::Glob'            => '1.11',
            'GDBM_File'             => '1.13',
            'Hash::Util::FieldHash' => '1.07',
            'I18N::Collate'         => '1.02',
            'IO'                    => '1.25_03',
            'IPC::Cmd'              => '0.66',
            'IPC::Open3'            => '1.08',
            'Locale::Codes'         => '3.15',
            'Locale::Codes::Country'=> '3.15',
            'Locale::Codes::Currency'=> '3.15',
            'Locale::Codes::Language'=> '3.15',
            'Locale::Codes::Script' => '3.15',
            'Locale::Constants'     => '3.15',
            'Locale::Country'       => '3.15',
            'Locale::Currency'      => '3.15',
            'Locale::Language'      => '3.15',
            'Locale::Script'        => '3.15',
            'MIME::Base64'          => '3.13',
            'MIME::QuotedPrint'     => '3.13',
            'Math::BigFloat'        => '1.99_02',
            'Math::BigInt'          => '1.99_02',
            'Math::BigInt::Calc'    => '1.99_02',
            'Math::BigInt::CalcEmu' => '1.99_02',
            'Memoize'               => '1.02',
            'Memoize::AnyDBM_File'  => '1.02',
            'Memoize::Expire'       => '1.02',
            'Memoize::ExpireFile'   => '1.02',
            'Memoize::ExpireTest'   => '1.02',
            'Memoize::NDBM_File'    => '1.02',
            'Memoize::SDBM_File'    => '1.02',
            'Memoize::Storable'     => '1.02',
            'Module::CoreList'      => '2.43',
            'NDBM_File'             => '1.11',
            'Net::Ping'             => '2.37',
            'ODBM_File'             => '1.10',
            'Opcode'                => '1.18',
            'POSIX'                 => '1.23',
            'PerlIO::encoding'      => '0.14',
            'PerlIO::scalar'        => '0.11',
            'PerlIO::via'           => '0.11',
            'SDBM_File'             => '1.09',
            'Socket'                => '1.92',
            'Storable'              => '2.25',
            'Time::HiRes'           => '1.9721_01',
            'Unicode::Collate'      => '0.6801',
            'Unicode::Collate::Locale'=> '0.68',
            'Unicode::Normalize'    => '1.08',
            'Unicode::UCD'          => '0.30',
            'Win32'                 => '0.41',
            'XS::APItest'           => '0.27',
            'autodie'               => '2.1001',
            'autodie::exception'    => '2.1001',
            'autodie::exception::system'=> '2.1001',
            'autodie::hints'        => '2.1001',
            'feature'               => '1.19',
            'if'                    => '0.0601',
            'mro'                   => '1.06',
            'overload'              => '1.12',
            're'                    => '0.15',
            'threads'               => '1.81_03',
            'threads::shared'       => '1.35',
            'version'               => '0.86',
        },
        removed => {
        }
    },
    5.013009 => {
        delta_from => 5.013008,
        changed => {
            'Archive::Extract'      => '0.48',
            'Archive::Tar'          => '1.76',
            'Archive::Tar::Constant'=> '1.76',
            'Archive::Tar::File'    => '1.76',
            'B::Concise'            => '0.83',
            'B::Deparse'            => '1.03',
            'B::Lint'               => '1.13',
            'Benchmark'             => '1.12',
            'CGI'                   => '3.51',
            'CGI::Carp'             => '3.51',
            'CGI::Cookie'           => '1.30',
            'CGI::Push'             => '1.05',
            'CGI::Util'             => '3.51',
            'CPAN'                  => '1.94_63',
            'CPAN::HTTP::Client'    => '1.94',
            'CPAN::HTTP::Credentials'=> '1.94',
            'CPAN::Meta::YAML'      => '0.003',
            'CPANPLUS'              => '0.9011',
            'CPANPLUS::Dist::Build' => '0.52',
            'CPANPLUS::Dist::Build::Constants'=> '0.52',
            'CPANPLUS::Internals'   => '0.9011',
            'CPANPLUS::Shell::Default'=> '0.9011',
            'Carp::Heavy'           => '1.19',
            'Compress::Raw::Bzip2'  => '2.033',
            'Compress::Raw::Zlib'   => '2.033',
            'Compress::Zlib'        => '2.033',
            'Cwd'                   => '3.36',
            'DBM_Filter'            => '0.04',
            'DB_File'               => '1.821',
            'Devel::Peek'           => '1.07',
            'DirHandle'             => '1.04',
            'Dumpvalue'             => '1.16',
            'Encode'                => '2.42',
            'Encode::Alias'         => '2.13',
            'Encode::MIME::Header'  => '2.13',
            'Exporter::Heavy'       => '5.64_03',
            'ExtUtils::Install'     => '1.56',
            'ExtUtils::ParseXS'     => '2.2209',
            'File::Basename'        => '2.80',
            'File::Copy'            => '2.21',
            'File::DosGlob'         => '1.04',
            'File::Fetch'           => '0.32',
            'File::Find'            => '1.19',
            'File::Spec::Mac'       => '3.34',
            'File::Spec::VMS'       => '3.34',
            'File::stat'            => '1.05',
            'HTTP::Tiny'            => '0.009',
            'Hash::Util::FieldHash' => '1.08',
            'IO::Compress::Adapter::Bzip2'=> '2.033',
            'IO::Compress::Adapter::Deflate'=> '2.033',
            'IO::Compress::Adapter::Identity'=> '2.033',
            'IO::Compress::Base'    => '2.033',
            'IO::Compress::Base::Common'=> '2.033',
            'IO::Compress::Bzip2'   => '2.033',
            'IO::Compress::Deflate' => '2.033',
            'IO::Compress::Gzip'    => '2.033',
            'IO::Compress::Gzip::Constants'=> '2.033',
            'IO::Compress::RawDeflate'=> '2.033',
            'IO::Compress::Zip'     => '2.033',
            'IO::Compress::Zip::Constants'=> '2.033',
            'IO::Compress::Zlib::Constants'=> '2.033',
            'IO::Compress::Zlib::Extra'=> '2.033',
            'IO::Handle'            => '1.29',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.033',
            'IO::Uncompress::Adapter::Identity'=> '2.033',
            'IO::Uncompress::Adapter::Inflate'=> '2.033',
            'IO::Uncompress::AnyInflate'=> '2.033',
            'IO::Uncompress::AnyUncompress'=> '2.033',
            'IO::Uncompress::Base'  => '2.033',
            'IO::Uncompress::Bunzip2'=> '2.033',
            'IO::Uncompress::Gunzip'=> '2.033',
            'IO::Uncompress::Inflate'=> '2.033',
            'IO::Uncompress::RawInflate'=> '2.033',
            'IO::Uncompress::Unzip' => '2.033',
            'IPC::Cmd'              => '0.68',
            'IPC::Open3'            => '1.09',
            'JSON::PP'              => '2.27103',
            'JSON::PP::Boolean'     => undef,
            'Locale::Maketext'      => '1.18',
            'Log::Message'          => '0.04',
            'Log::Message::Config'  => '0.04',
            'Log::Message::Handlers'=> '0.04',
            'Log::Message::Item'    => '0.04',
            'Log::Message::Simple'  => '0.08',
            'Math::BigFloat'        => '1.99_03',
            'Math::BigInt'          => '1.99_03',
            'Math::BigInt::Calc'    => '1.99_03',
            'Math::BigInt::FastCalc'=> '0.24_02',
            'Math::BigRat'          => '0.26_02',
            'Module::CoreList'      => '2.42_01',
            'Module::Load::Conditional'=> '0.40',
            'Module::Metadata'      => '1.000003',
            'Net::Ping'             => '2.38',
            'OS2::Process'          => '1.05',
            'Object::Accessor'      => '0.38',
            'POSIX'                 => '1.24',
            'Params::Check'         => '0.28',
            'Perl::OSType'          => '1.002',
            'Pod::LaTeX'            => '0.59',
            'Pod::Perldoc'          => '3.15_03',
            'Socket'                => '1.93',
            'Storable'              => '2.26',
            'Sys::Hostname'         => '1.15',
            'Term::UI'              => '0.24',
            'Thread::Queue'         => '2.12',
            'Thread::Semaphore'     => '2.12',
            'Time::Local'           => '1.2000',
            'UNIVERSAL'             => '1.08',
            'Unicode::Normalize'    => '1.10',
            'Win32'                 => '0.44',
            'bigint'                => '0.26',
            'bignum'                => '0.26',
            'bigrat'                => '0.26',
            'charnames'             => '1.18',
            'diagnostics'           => '1.21',
            're'                    => '0.16',
            'threads'               => '1.83',
            'threads::shared'       => '1.36',
            'version'               => '0.88',
        },
        removed => {
        }
    },
    5.01301 => {
        delta_from => 5.013009,
        changed => {
            'Attribute::Handlers'   => '0.89',
            'B'                     => '1.28',
            'B::Showlex'            => '1.03',
            'CGI'                   => '3.52',
            'CPAN'                  => '1.94_65',
            'CPAN::Distribution'    => '1.9601',
            'CPAN::FTP::netrc'      => '1.01',
            'CPAN::FirstTime'       => '5.5303',
            'CPAN::HandleConfig'    => '5.5003',
            'CPAN::Meta'            => '2.110440',
            'CPAN::Meta::Converter' => '2.110440',
            'CPAN::Meta::Feature'   => '2.110440',
            'CPAN::Meta::History'   => '2.110440',
            'CPAN::Meta::Prereqs'   => '2.110440',
            'CPAN::Meta::Spec'      => '2.110440',
            'CPAN::Meta::Validator' => '2.110440',
            'CPAN::Shell'           => '5.5002',
            'CPANPLUS'              => '0.9101',
            'CPANPLUS::Internals'   => '0.9101',
            'CPANPLUS::Shell::Default'=> '0.9101',
            'Carp'                  => '1.20',
            'Carp::Heavy'           => '1.20',
            'Cwd'                   => '3.37',
            'Devel::DProf'          => '20110217.00',
            'DynaLoader'            => '1.13',
            'ExtUtils::CBuilder'    => '0.280202',
            'ExtUtils::CBuilder::Base'=> '0.280202',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280202',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280202',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280202',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280202',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280202',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280202',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280202',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280202',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280202',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280202',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280202',
            'File::Copy'            => '2.22',
            'Filter::Simple'        => '0.86',
            'HTTP::Tiny'            => '0.010',
            'I18N::LangTags::Detect'=> '1.05',
            'IO::Select'            => '1.18',
            'IPC::Cmd'              => '0.70',
            'Locale::Maketext'      => '1.19',
            'Math::BigFloat'        => '1.992',
            'Math::BigInt'          => '1.992',
            'Math::BigInt::Calc'    => '1.992',
            'Math::BigInt::CalcEmu' => '1.992',
            'Module::Build'         => '0.37_05',
            'Module::Build::Base'   => '0.37_05',
            'Module::Build::Compat' => '0.37_05',
            'Module::Build::Config' => '0.37_05',
            'Module::Build::Cookbook'=> '0.37_05',
            'Module::Build::Dumper' => '0.37_05',
            'Module::Build::ModuleInfo'=> '0.37_05',
            'Module::Build::Notes'  => '0.37_05',
            'Module::Build::PPMMaker'=> '0.37_05',
            'Module::Build::Platform::Amiga'=> '0.37_05',
            'Module::Build::Platform::Default'=> '0.37_05',
            'Module::Build::Platform::EBCDIC'=> '0.37_05',
            'Module::Build::Platform::MPEiX'=> '0.37_05',
            'Module::Build::Platform::MacOS'=> '0.37_05',
            'Module::Build::Platform::RiscOS'=> '0.37_05',
            'Module::Build::Platform::Unix'=> '0.37_05',
            'Module::Build::Platform::VMS'=> '0.37_05',
            'Module::Build::Platform::VOS'=> '0.37_05',
            'Module::Build::Platform::Windows'=> '0.37_05',
            'Module::Build::Platform::aix'=> '0.37_05',
            'Module::Build::Platform::cygwin'=> '0.37_05',
            'Module::Build::Platform::darwin'=> '0.37_05',
            'Module::Build::Platform::os2'=> '0.37_05',
            'Module::Build::PodParser'=> '0.37_05',
            'Module::Build::Version'=> '0.87',
            'Module::Build::YAML'   => '1.41',
            'Module::CoreList'      => '2.45',
            'Module::Load::Conditional'=> '0.44',
            'Module::Metadata'      => '1.000004',
            'OS2::Process'          => '1.06',
            'Parse::CPAN::Meta'     => '1.4401',
            'Pod::Html'             => '1.1',
            'Socket'                => '1.94',
            'Term::UI'              => '0.26',
            'Unicode::Collate'      => '0.72',
            'Unicode::Collate::Locale'=> '0.71',
            'Unicode::UCD'          => '0.31',
            'VMS::DCLsym'           => '1.05',
            'Version::Requirements' => '0.101020',
            'bigrat'                => '0.27',
            'deprecate'             => '0.02',
            'diagnostics'           => '1.22',
            'inc::latest'           => '0.37_05',
            'overload'              => '1.13',
            're'                    => '0.17',
            'utf8'                  => '1.09',
            'warnings'              => '1.12',
        },
        removed => {
        }
    },
    5.013011 => {
        delta_from => 5.01301,
        changed => {
            'App::Prove'            => '3.23',
            'App::Prove::State'     => '3.23',
            'App::Prove::State::Result'=> '3.23',
            'App::Prove::State::Result::Test'=> '3.23',
            'B'                     => '1.29',
            'CPAN'                  => '1.9600',
            'CPAN::Author'          => '5.5001',
            'CPAN::CacheMgr'        => '5.5001',
            'CPAN::Distribution'    => '1.9602',
            'CPAN::Exception::blocked_urllist'=> '1.001',
            'CPAN::HTTP::Client'    => '1.9600',
            'CPAN::HTTP::Credentials'=> '1.9600',
            'CPAN::Index'           => '1.9600',
            'CPAN::LWP::UserAgent'  => '1.9600',
            'CPAN::Mirrors'         => '1.9600',
            'CPAN::Module'          => '5.5001',
            'CPANPLUS'              => '0.9103',
            'CPANPLUS::Dist::Build' => '0.54',
            'CPANPLUS::Dist::Build::Constants'=> '0.54',
            'CPANPLUS::Internals'   => '0.9103',
            'CPANPLUS::Shell::Default'=> '0.9103',
            'Cwd'                   => '3.36',
            'Devel::DProf'          => '20110228.00',
            'Digest::SHA'           => '5.61',
            'ExtUtils::Command'     => '1.17',
            'File::Basename'        => '2.81',
            'File::Copy'            => '2.21',
            'File::Glob'            => '1.12',
            'GDBM_File'             => '1.14',
            'HTTP::Tiny'            => '0.011',
            'Hash::Util'            => '0.11',
            'Hash::Util::FieldHash' => '1.09',
            'I18N::Langinfo'        => '0.08',
            'IO'                    => '1.25_04',
            'IO::Dir'               => '1.08',
            'IO::File'              => '1.15',
            'IO::Handle'            => '1.30',
            'IO::Pipe'              => '1.14',
            'IO::Poll'              => '0.08',
            'IO::Select'            => '1.20',
            'JSON::PP'              => '2.27105',
            'Locale::Codes'         => '3.16',
            'Locale::Codes::Country'=> '3.16',
            'Locale::Codes::Currency'=> '3.16',
            'Locale::Codes::Language'=> '3.16',
            'Locale::Codes::Script' => '3.16',
            'Locale::Constants'     => '3.16',
            'Locale::Country'       => '3.16',
            'Locale::Currency'      => '3.16',
            'Locale::Language'      => '3.16',
            'Locale::Script'        => '3.16',
            'Math::BigFloat'        => '1.993',
            'Math::BigInt'          => '1.994',
            'Math::BigInt::Calc'    => '1.993',
            'Math::BigInt::CalcEmu' => '1.993',
            'Math::BigInt::FastCalc'=> '0.28',
            'Module::Build'         => '0.3800',
            'Module::Build::Base'   => '0.3800',
            'Module::Build::Compat' => '0.3800',
            'Module::Build::Config' => '0.3800',
            'Module::Build::Cookbook'=> '0.3800',
            'Module::Build::Dumper' => '0.3800',
            'Module::Build::ModuleInfo'=> '0.3800',
            'Module::Build::Notes'  => '0.3800',
            'Module::Build::PPMMaker'=> '0.3800',
            'Module::Build::Platform::Amiga'=> '0.3800',
            'Module::Build::Platform::Default'=> '0.3800',
            'Module::Build::Platform::EBCDIC'=> '0.3800',
            'Module::Build::Platform::MPEiX'=> '0.3800',
            'Module::Build::Platform::MacOS'=> '0.3800',
            'Module::Build::Platform::RiscOS'=> '0.3800',
            'Module::Build::Platform::Unix'=> '0.3800',
            'Module::Build::Platform::VMS'=> '0.3800',
            'Module::Build::Platform::VOS'=> '0.3800',
            'Module::Build::Platform::Windows'=> '0.3800',
            'Module::Build::Platform::aix'=> '0.3800',
            'Module::Build::Platform::cygwin'=> '0.3800',
            'Module::Build::Platform::darwin'=> '0.3800',
            'Module::Build::Platform::os2'=> '0.3800',
            'Module::Build::PodParser'=> '0.3800',
            'Module::CoreList'      => '2.46',
            'NDBM_File'             => '1.12',
            'Pod::Simple'           => '3.16',
            'Pod::Simple::BlackBox' => '3.16',
            'Pod::Simple::Checker'  => '3.16',
            'Pod::Simple::Debug'    => '3.16',
            'Pod::Simple::DumpAsText'=> '3.16',
            'Pod::Simple::DumpAsXML'=> '3.16',
            'Pod::Simple::HTML'     => '3.16',
            'Pod::Simple::HTMLBatch'=> '3.16',
            'Pod::Simple::LinkSection'=> '3.16',
            'Pod::Simple::Methody'  => '3.16',
            'Pod::Simple::Progress' => '3.16',
            'Pod::Simple::PullParser'=> '3.16',
            'Pod::Simple::PullParserEndToken'=> '3.16',
            'Pod::Simple::PullParserStartToken'=> '3.16',
            'Pod::Simple::PullParserTextToken'=> '3.16',
            'Pod::Simple::PullParserToken'=> '3.16',
            'Pod::Simple::RTF'      => '3.16',
            'Pod::Simple::Search'   => '3.16',
            'Pod::Simple::SimpleTree'=> '3.16',
            'Pod::Simple::Text'     => '3.16',
            'Pod::Simple::TextContent'=> '3.16',
            'Pod::Simple::TiedOutFH'=> '3.16',
            'Pod::Simple::Transcode'=> '3.16',
            'Pod::Simple::TranscodeDumb'=> '3.16',
            'Pod::Simple::TranscodeSmart'=> '3.16',
            'Pod::Simple::XHTML'    => '3.16',
            'Pod::Simple::XMLOutStream'=> '3.16',
            'Storable'              => '2.27',
            'Sys::Hostname'         => '1.16',
            'TAP::Base'             => '3.23',
            'TAP::Formatter::Base'  => '3.23',
            'TAP::Formatter::Color' => '3.23',
            'TAP::Formatter::Console'=> '3.23',
            'TAP::Formatter::Console::ParallelSession'=> '3.23',
            'TAP::Formatter::Console::Session'=> '3.23',
            'TAP::Formatter::File'  => '3.23',
            'TAP::Formatter::File::Session'=> '3.23',
            'TAP::Formatter::Session'=> '3.23',
            'TAP::Harness'          => '3.23',
            'TAP::Object'           => '3.23',
            'TAP::Parser'           => '3.23',
            'TAP::Parser::Aggregator'=> '3.23',
            'TAP::Parser::Grammar'  => '3.23',
            'TAP::Parser::Iterator' => '3.23',
            'TAP::Parser::Iterator::Array'=> '3.23',
            'TAP::Parser::Iterator::Process'=> '3.23',
            'TAP::Parser::Iterator::Stream'=> '3.23',
            'TAP::Parser::IteratorFactory'=> '3.23',
            'TAP::Parser::Multiplexer'=> '3.23',
            'TAP::Parser::Result'   => '3.23',
            'TAP::Parser::Result::Bailout'=> '3.23',
            'TAP::Parser::Result::Comment'=> '3.23',
            'TAP::Parser::Result::Plan'=> '3.23',
            'TAP::Parser::Result::Pragma'=> '3.23',
            'TAP::Parser::Result::Test'=> '3.23',
            'TAP::Parser::Result::Unknown'=> '3.23',
            'TAP::Parser::Result::Version'=> '3.23',
            'TAP::Parser::Result::YAML'=> '3.23',
            'TAP::Parser::ResultFactory'=> '3.23',
            'TAP::Parser::Scheduler'=> '3.23',
            'TAP::Parser::Scheduler::Job'=> '3.23',
            'TAP::Parser::Scheduler::Spinner'=> '3.23',
            'TAP::Parser::Source'   => '3.23',
            'TAP::Parser::SourceHandler'=> '3.23',
            'TAP::Parser::SourceHandler::Executable'=> '3.23',
            'TAP::Parser::SourceHandler::File'=> '3.23',
            'TAP::Parser::SourceHandler::Handle'=> '3.23',
            'TAP::Parser::SourceHandler::Perl'=> '3.23',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.23',
            'TAP::Parser::Utils'    => '3.23',
            'TAP::Parser::YAMLish::Reader'=> '3.23',
            'TAP::Parser::YAMLish::Writer'=> '3.23',
            'Test::Builder'         => '0.98',
            'Test::Builder::Module' => '0.98',
            'Test::Builder::Tester' => '1.22',
            'Test::Builder::Tester::Color'=> '1.22',
            'Test::Harness'         => '3.23',
            'Test::More'            => '0.98',
            'Test::Simple'          => '0.98',
            'Tie::Hash::NamedCapture'=> '0.08',
            'Tie::RefHash'          => '1.39',
            'Unicode::Collate'      => '0.73',
            'Unicode::Collate::Locale'=> '0.73',
            'Unicode::UCD'          => '0.32',
            'XS::Typemap'           => '0.05',
            'attributes'            => '0.14',
            'base'                  => '2.16',
            'inc::latest'           => '0.3800',
            'mro'                   => '1.07',
            'parent'                => '0.225',
        },
        removed => {
        }
    },
    5.014 => {
        delta_from => 5.013011,
        changed => {
            'ExtUtils::CBuilder'    => '0.280203',
            'ExtUtils::CBuilder::Base'=> '0.280203',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280203',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280203',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280203',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280203',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280203',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280203',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280203',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280203',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280203',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280203',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280203',
            'ExtUtils::ParseXS'     => '2.2210',
            'File::Basename'        => '2.82',
            'HTTP::Tiny'            => '0.012',
            'IO::Handle'            => '1.31',
            'Module::CoreList'      => '2.49',
            'PerlIO'                => '1.07',
            'Pod::Html'             => '1.11',
            'XS::APItest'           => '0.28',
            'bigint'                => '0.27',
            'bignum'                => '0.27',
            'bigrat'                => '0.28',
            'constant'              => '1.21',
            'feature'               => '1.20',
            're'                    => '0.18',
            'threads::shared'       => '1.37',
        },
        removed => {
        }
    },
    5.014001 => {
        delta_from => 5.014,
        changed => {
            'B::Deparse'            => '1.04',
            'Module::CoreList'      => '2.49_01',
            'Pod::Perldoc'          => '3.15_04',
        },
        removed => {
        }
    },
    5.014002 => {
        delta_from => 5.014001,
        changed => {
            'CPAN'                  => '1.9600_01',
            'CPAN::Distribution'    => '1.9602_01',
            'Devel::DProf::dprof::V'=> undef,
            'Encode'                => '2.42_01',
            'File::Glob'            => '1.13',
            'Module::CoreList'      => '2.49_02',
            'PerlIO::scalar'        => '0.11_01',
            'Time::Piece::Seconds'  => undef,
        },
        removed => {
        }
    },
    5.014003 => {
        delta_from => 5.014002,
        changed => {
            'Digest'                => '1.16_01',
            'IPC::Open3'            => '1.09_01',
            'Module::CoreList'      => '2.49_04',
        },
        removed => {
        }
    },
    5.014004 => {
        delta_from => 5.014003,
        changed => {
            'Encode'                => '2.42_02',
            'IPC::Open3'            => '1.0901',
            'Module::CoreList'      => '2.49_06',
        },
        removed => {
        }
    },
    5.015 => {
        delta_from => 5.014001,
        changed => {
            'Archive::Extract'      => '0.52',
            'Attribute::Handlers'   => '0.91',
            'B'                     => '1.30',
            'B::Concise'            => '0.84',
            'B::Deparse'            => '1.05',
            'Benchmark'             => '1.13',
            'CGI'                   => '3.54',
            'CGI::Util'             => '3.53',
            'CPAN::Meta'            => '2.110930',
            'CPAN::Meta::Converter' => '2.110930',
            'CPAN::Meta::Feature'   => '2.110930',
            'CPAN::Meta::History'   => '2.110930',
            'CPAN::Meta::Prereqs'   => '2.110930',
            'CPAN::Meta::Spec'      => '2.110930',
            'CPAN::Meta::Validator' => '2.110930',
            'CPANPLUS'              => '0.9105',
            'CPANPLUS::Dist::Build' => '0.56',
            'CPANPLUS::Dist::Build::Constants'=> '0.56',
            'CPANPLUS::Internals'   => '0.9105',
            'CPANPLUS::Shell::Default'=> '0.9105',
            'Compress::Raw::Bzip2'  => '2.035',
            'Compress::Raw::Zlib'   => '2.035',
            'Compress::Zlib'        => '2.035',
            'DB_File'               => '1.822',
            'Data::Dumper'          => '2.131',
            'Devel::Peek'           => '1.08',
            'Digest::SHA'           => '5.62',
            'Encode'                => '2.43',
            'Encode::Alias'         => '2.14',
            'ExtUtils::CBuilder'    => '0.280204',
            'ExtUtils::CBuilder::Base'=> '0.280204',
            'Fatal'                 => '2.10',
            'File::Spec::Win32'     => '3.34',
            'Filter::Simple'        => '0.87',
            'Filter::Util::Call'    => '1.39',
            'FindBin'               => '1.51',
            'Hash::Util::FieldHash' => '1.10',
            'I18N::LangTags'        => '0.36',
            'IO::Compress::Adapter::Bzip2'=> '2.035',
            'IO::Compress::Adapter::Deflate'=> '2.035',
            'IO::Compress::Adapter::Identity'=> '2.035',
            'IO::Compress::Base'    => '2.035',
            'IO::Compress::Base::Common'=> '2.035',
            'IO::Compress::Bzip2'   => '2.035',
            'IO::Compress::Deflate' => '2.035',
            'IO::Compress::Gzip'    => '2.035',
            'IO::Compress::Gzip::Constants'=> '2.035',
            'IO::Compress::RawDeflate'=> '2.035',
            'IO::Compress::Zip'     => '2.035',
            'IO::Compress::Zip::Constants'=> '2.035',
            'IO::Compress::Zlib::Constants'=> '2.035',
            'IO::Compress::Zlib::Extra'=> '2.035',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.035',
            'IO::Uncompress::Adapter::Identity'=> '2.035',
            'IO::Uncompress::Adapter::Inflate'=> '2.035',
            'IO::Uncompress::AnyInflate'=> '2.035',
            'IO::Uncompress::AnyUncompress'=> '2.035',
            'IO::Uncompress::Base'  => '2.035',
            'IO::Uncompress::Bunzip2'=> '2.035',
            'IO::Uncompress::Gunzip'=> '2.035',
            'IO::Uncompress::Inflate'=> '2.035',
            'IO::Uncompress::RawInflate'=> '2.035',
            'IO::Uncompress::Unzip' => '2.035',
            'IPC::Open2'            => '1.04',
            'IPC::Open3'            => '1.11',
            'JSON::PP'              => '2.27200',
            'Math::BigFloat'        => '1.994',
            'Math::BigInt'          => '1.995',
            'Math::Complex'         => '1.57',
            'Math::Trig'            => '1.21',
            'Module::CoreList'      => '2.51',
            'ODBM_File'             => '1.11',
            'Object::Accessor'      => '0.42',
            'Opcode'                => '1.19',
            'PerlIO::encoding'      => '0.15',
            'PerlIO::scalar'        => '0.12',
            'Pod::Perldoc'          => '3.15_05',
            'Storable'              => '2.28',
            'Sys::Syslog'           => '0.29',
            'Time::HiRes'           => '1.9722',
            'Unicode::Collate'      => '0.76',
            'Unicode::Collate::CJK::Pinyin'=> '0.76',
            'Unicode::Collate::CJK::Stroke'=> '0.76',
            'Unicode::Collate::Locale'=> '0.76',
            'Unicode::Normalize'    => '1.12',
            'XS::APItest'           => '0.29',
            'XSLoader'              => '0.15',
            'autodie'               => '2.10',
            'autodie::exception'    => '2.10',
            'autodie::exception::system'=> '2.10',
            'autodie::hints'        => '2.10',
            'base'                  => '2.17',
            'charnames'             => '1.22',
            'constant'              => '1.22',
            'feature'               => '1.21',
            'mro'                   => '1.08',
            'overload'              => '1.14',
            'threads::shared'       => '1.38',
            'vmsish'                => '1.03',
        },
        removed => {
            'Devel::DProf'          => 1,
            'Shell'                 => 1,
        }
    },
    5.015001 => {
        delta_from => 5.015,
        changed => {
            'B::Deparse'            => '1.06',
            'CGI'                   => '3.55',
            'CPAN::Meta'            => '2.110930001',
            'CPAN::Meta::Converter' => '2.110930001',
            'CPANPLUS'              => '0.9108',
            'CPANPLUS::Internals'   => '0.9108',
            'CPANPLUS::Shell::Default'=> '0.9108',
            'Carp'                  => '1.21',
            'Carp::Heavy'           => '1.21',
            'Compress::Raw::Bzip2'  => '2.037',
            'Compress::Raw::Zlib'   => '2.037',
            'Compress::Zlib'        => '2.037',
            'Cwd'                   => '3.37',
            'Env'                   => '1.03',
            'ExtUtils::Command::MM' => '6.58',
            'ExtUtils::Liblist'     => '6.58',
            'ExtUtils::Liblist::Kid'=> '6.58',
            'ExtUtils::MM'          => '6.58',
            'ExtUtils::MM_AIX'      => '6.58',
            'ExtUtils::MM_Any'      => '6.58',
            'ExtUtils::MM_BeOS'     => '6.58',
            'ExtUtils::MM_Cygwin'   => '6.58',
            'ExtUtils::MM_DOS'      => '6.58',
            'ExtUtils::MM_Darwin'   => '6.58',
            'ExtUtils::MM_MacOS'    => '6.58',
            'ExtUtils::MM_NW5'      => '6.58',
            'ExtUtils::MM_OS2'      => '6.58',
            'ExtUtils::MM_QNX'      => '6.58',
            'ExtUtils::MM_UWIN'     => '6.58',
            'ExtUtils::MM_Unix'     => '6.58',
            'ExtUtils::MM_VMS'      => '6.58',
            'ExtUtils::MM_VOS'      => '6.58',
            'ExtUtils::MM_Win32'    => '6.58',
            'ExtUtils::MM_Win95'    => '6.58',
            'ExtUtils::MY'          => '6.58',
            'ExtUtils::MakeMaker'   => '6.58',
            'ExtUtils::MakeMaker::Config'=> '6.58',
            'ExtUtils::Mkbootstrap' => '6.58',
            'ExtUtils::Mksymlists'  => '6.58',
            'ExtUtils::ParseXS'     => '3.00_01',
            'ExtUtils::ParseXS::Constants'=> undef,
            'ExtUtils::ParseXS::CountLines'=> undef,
            'ExtUtils::ParseXS::Utilities'=> undef,
            'ExtUtils::Typemaps'    => '1.00',
            'ExtUtils::Typemaps::InputMap'=> undef,
            'ExtUtils::Typemaps::OutputMap'=> undef,
            'ExtUtils::Typemaps::Type'=> '0.05',
            'ExtUtils::testlib'     => '6.58',
            'File::Basename'        => '2.83',
            'File::Find'            => '1.20',
            'HTTP::Tiny'            => '0.013',
            'I18N::Langinfo'        => '0.08_02',
            'IO::Compress::Adapter::Bzip2'=> '2.037',
            'IO::Compress::Adapter::Deflate'=> '2.037',
            'IO::Compress::Adapter::Identity'=> '2.037',
            'IO::Compress::Base'    => '2.037',
            'IO::Compress::Base::Common'=> '2.037',
            'IO::Compress::Bzip2'   => '2.037',
            'IO::Compress::Deflate' => '2.037',
            'IO::Compress::Gzip'    => '2.037',
            'IO::Compress::Gzip::Constants'=> '2.037',
            'IO::Compress::RawDeflate'=> '2.037',
            'IO::Compress::Zip'     => '2.037',
            'IO::Compress::Zip::Constants'=> '2.037',
            'IO::Compress::Zlib::Constants'=> '2.037',
            'IO::Compress::Zlib::Extra'=> '2.037',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.037',
            'IO::Uncompress::Adapter::Identity'=> '2.037',
            'IO::Uncompress::Adapter::Inflate'=> '2.037',
            'IO::Uncompress::AnyInflate'=> '2.037',
            'IO::Uncompress::AnyUncompress'=> '2.037',
            'IO::Uncompress::Base'  => '2.037',
            'IO::Uncompress::Bunzip2'=> '2.037',
            'IO::Uncompress::Gunzip'=> '2.037',
            'IO::Uncompress::Inflate'=> '2.037',
            'IO::Uncompress::RawInflate'=> '2.037',
            'IO::Uncompress::Unzip' => '2.037',
            'IPC::Cmd'              => '0.72',
            'Locale::Codes'         => '3.17',
            'Locale::Codes::Constants'=> '3.17',
            'Locale::Codes::Country'=> '3.17',
            'Locale::Codes::Country_Codes'=> '3.17',
            'Locale::Codes::Currency'=> '3.17',
            'Locale::Codes::Currency_Codes'=> '3.17',
            'Locale::Codes::LangExt'=> '3.17',
            'Locale::Codes::LangExt_Codes'=> '3.17',
            'Locale::Codes::LangVar'=> '3.17',
            'Locale::Codes::LangVar_Codes'=> '3.17',
            'Locale::Codes::Language'=> '3.17',
            'Locale::Codes::Language_Codes'=> '3.17',
            'Locale::Codes::Script' => '3.17',
            'Locale::Codes::Script_Codes'=> '3.17',
            'Locale::Country'       => '3.17',
            'Locale::Currency'      => '3.17',
            'Locale::Language'      => '3.17',
            'Locale::Script'        => '3.17',
            'Math::BigFloat::Trace' => '0.28',
            'Math::BigInt::FastCalc'=> '0.29',
            'Math::BigInt::Trace'   => '0.28',
            'Math::BigRat'          => '0.2602',
            'Math::Complex'         => '1.58',
            'Math::Trig'            => '1.22',
            'Module::CoreList'      => '2.54',
            'OS2::Process'          => '1.07',
            'Pod::Perldoc'          => '3.15_06',
            'Pod::Simple'           => '3.18',
            'Pod::Simple::BlackBox' => '3.18',
            'Pod::Simple::Checker'  => '3.18',
            'Pod::Simple::Debug'    => '3.18',
            'Pod::Simple::DumpAsText'=> '3.18',
            'Pod::Simple::DumpAsXML'=> '3.18',
            'Pod::Simple::HTML'     => '3.18',
            'Pod::Simple::HTMLBatch'=> '3.18',
            'Pod::Simple::LinkSection'=> '3.18',
            'Pod::Simple::Methody'  => '3.18',
            'Pod::Simple::Progress' => '3.18',
            'Pod::Simple::PullParser'=> '3.18',
            'Pod::Simple::PullParserEndToken'=> '3.18',
            'Pod::Simple::PullParserStartToken'=> '3.18',
            'Pod::Simple::PullParserTextToken'=> '3.18',
            'Pod::Simple::PullParserToken'=> '3.18',
            'Pod::Simple::RTF'      => '3.18',
            'Pod::Simple::Search'   => '3.18',
            'Pod::Simple::SimpleTree'=> '3.18',
            'Pod::Simple::Text'     => '3.18',
            'Pod::Simple::TextContent'=> '3.18',
            'Pod::Simple::TiedOutFH'=> '3.18',
            'Pod::Simple::Transcode'=> '3.18',
            'Pod::Simple::TranscodeDumb'=> '3.18',
            'Pod::Simple::TranscodeSmart'=> '3.18',
            'Pod::Simple::XHTML'    => '3.18',
            'Pod::Simple::XMLOutStream'=> '3.18',
            'Storable'              => '2.31',
            'Sys::Syslog::Win32'    => undef,
            'Time::HiRes'           => '1.9724',
            'Unicode::Collate'      => '0.77',
            'Unicode::UCD'          => '0.33',
            'Win32API::File'        => '0.1200',
            'XS::APItest'           => '0.30',
            'attributes'            => '0.15',
            'bigint'                => '0.28',
            'bignum'                => '0.28',
            'charnames'             => '1.23',
            'diagnostics'           => '1.23',
            'feature'               => '1.22',
            'overload'              => '1.15',
            'perlfaq'               => '5.015000',
            'threads'               => '1.84',
            'version'               => '0.93',
        },
        removed => {
            'ExtUtils::MakeMaker::YAML'=> 1,
            'Locale::Constants'     => 1,
            'Sys::Syslog::win32::Win32'=> 1,
        }
    },
    5.015002 => {
        delta_from => 5.015001,
        changed => {
            'Attribute::Handlers'   => '0.92',
            'B'                     => '1.31',
            'B::Concise'            => '0.85',
            'B::Deparse'            => '1.07',
            'B::Terse'              => '1.06',
            'B::Xref'               => '1.03',
            'CPAN'                  => '1.9800',
            'CPAN::Exception::yaml_process_error'=> '5.5',
            'CPAN::Meta'            => '2.112150',
            'CPAN::Meta::Converter' => '2.112150',
            'CPAN::Meta::Feature'   => '2.112150',
            'CPAN::Meta::History'   => '2.112150',
            'CPAN::Meta::Prereqs'   => '2.112150',
            'CPAN::Meta::Spec'      => '2.112150',
            'CPAN::Meta::Validator' => '2.112150',
            'CPANPLUS'              => '0.9109',
            'CPANPLUS::Internals'   => '0.9109',
            'CPANPLUS::Shell::Default'=> '0.9109',
            'DB_File'               => '1.824',
            'Data::Dumper'          => '2.132',
            'Encode'                => '2.44',
            'Encode::Alias'         => '2.15',
            'Encode::Encoder'       => '2.02',
            'Encode::Guess'         => '2.05',
            'ExtUtils::Command::MM' => '6.59',
            'ExtUtils::Install'     => '1.57',
            'ExtUtils::Installed'   => '1.999002',
            'ExtUtils::Liblist'     => '6.59',
            'ExtUtils::Liblist::Kid'=> '6.59',
            'ExtUtils::MM'          => '6.59',
            'ExtUtils::MM_AIX'      => '6.59',
            'ExtUtils::MM_Any'      => '6.59',
            'ExtUtils::MM_BeOS'     => '6.59',
            'ExtUtils::MM_Cygwin'   => '6.59',
            'ExtUtils::MM_DOS'      => '6.59',
            'ExtUtils::MM_Darwin'   => '6.59',
            'ExtUtils::MM_MacOS'    => '6.59',
            'ExtUtils::MM_NW5'      => '6.59',
            'ExtUtils::MM_OS2'      => '6.59',
            'ExtUtils::MM_QNX'      => '6.59',
            'ExtUtils::MM_UWIN'     => '6.59',
            'ExtUtils::MM_Unix'     => '6.59',
            'ExtUtils::MM_VMS'      => '6.59',
            'ExtUtils::MM_VOS'      => '6.59',
            'ExtUtils::MM_Win32'    => '6.59',
            'ExtUtils::MM_Win95'    => '6.59',
            'ExtUtils::MY'          => '6.59',
            'ExtUtils::MakeMaker'   => '6.59',
            'ExtUtils::MakeMaker::Config'=> '6.59',
            'ExtUtils::Manifest'    => '1.60',
            'ExtUtils::Mkbootstrap' => '6.59',
            'ExtUtils::Mksymlists'  => '6.59',
            'ExtUtils::ParseXS'     => '3.03_01',
            'ExtUtils::Typemaps'    => '1.01',
            'ExtUtils::testlib'     => '6.59',
            'File::Spec'            => '3.34',
            'File::Spec::Mac'       => '3.35',
            'File::Spec::Unix'      => '3.34',
            'File::Spec::VMS'       => '3.35',
            'File::Spec::Win32'     => '3.35',
            'I18N::LangTags'        => '0.37',
            'IO'                    => '1.25_05',
            'IO::Handle'            => '1.32',
            'IO::Socket'            => '1.33',
            'IO::Socket::INET'      => '1.32',
            'IPC::Open3'            => '1.12',
            'Math::BigFloat'        => '1.995',
            'Math::BigFloat::Trace' => '0.29',
            'Math::BigInt'          => '1.996',
            'Math::BigInt::Trace'   => '0.29',
            'Module::Build'         => '0.39_01',
            'Module::Build::Base'   => '0.39_01',
            'Module::Build::Compat' => '0.39_01',
            'Module::Build::Config' => '0.39_01',
            'Module::Build::Cookbook'=> '0.39_01',
            'Module::Build::Dumper' => '0.39_01',
            'Module::Build::ModuleInfo'=> '0.39_01',
            'Module::Build::Notes'  => '0.39_01',
            'Module::Build::PPMMaker'=> '0.39_01',
            'Module::Build::Platform::Amiga'=> '0.39_01',
            'Module::Build::Platform::Default'=> '0.39_01',
            'Module::Build::Platform::EBCDIC'=> '0.39_01',
            'Module::Build::Platform::MPEiX'=> '0.39_01',
            'Module::Build::Platform::MacOS'=> '0.39_01',
            'Module::Build::Platform::RiscOS'=> '0.39_01',
            'Module::Build::Platform::Unix'=> '0.39_01',
            'Module::Build::Platform::VMS'=> '0.39_01',
            'Module::Build::Platform::VOS'=> '0.39_01',
            'Module::Build::Platform::Windows'=> '0.39_01',
            'Module::Build::Platform::aix'=> '0.39_01',
            'Module::Build::Platform::cygwin'=> '0.39_01',
            'Module::Build::Platform::darwin'=> '0.39_01',
            'Module::Build::Platform::os2'=> '0.39_01',
            'Module::Build::PodParser'=> '0.39_01',
            'Module::CoreList'      => '2.55',
            'Module::Load'          => '0.20',
            'Module::Metadata'      => '1.000005_01',
            'Opcode'                => '1.20',
            'Params::Check'         => '0.32',
            'PerlIO::via'           => '0.12',
            'Term::ANSIColor'       => '3.01',
            'Unicode::Collate'      => '0.78',
            'Unicode::Normalize'    => '1.13',
            'Unicode::UCD'          => '0.34',
            'bigint'                => '0.29',
            'bignum'                => '0.29',
            'bigrat'                => '0.29',
            'diagnostics'           => '1.24',
            'fields'                => '2.16',
            'inc::latest'           => '0.39_01',
        },
        removed => {
        }
    },
    5.015003 => {
        delta_from => 5.015002,
        changed => {
            'AnyDBM_File'           => '1.01',
            'Archive::Extract'      => '0.56',
            'Archive::Tar'          => '1.78',
            'Archive::Tar::Constant'=> '1.78',
            'Archive::Tar::File'    => '1.78',
            'Attribute::Handlers'   => '0.93',
            'B'                     => '1.32',
            'B::Concise'            => '0.86',
            'B::Deparse'            => '1.08',
            'CPAN::Meta'            => '2.112621',
            'CPAN::Meta::Converter' => '2.112621',
            'CPAN::Meta::Feature'   => '2.112621',
            'CPAN::Meta::History'   => '2.112621',
            'CPAN::Meta::Prereqs'   => '2.112621',
            'CPAN::Meta::Spec'      => '2.112621',
            'CPAN::Meta::Validator' => '2.112621',
            'CPAN::Meta::YAML'      => '0.004',
            'CPANPLUS'              => '0.9111',
            'CPANPLUS::Dist::Build' => '0.58',
            'CPANPLUS::Dist::Build::Constants'=> '0.58',
            'CPANPLUS::Internals'   => '0.9111',
            'CPANPLUS::Shell::Default'=> '0.9111',
            'Carp'                  => '1.23',
            'Carp::Heavy'           => '1.23',
            'Data::Dumper'          => '2.134',
            'Devel::PPPort'         => '3.20',
            'Errno'                 => '1.14',
            'Exporter'              => '5.65',
            'Exporter::Heavy'       => '5.65',
            'ExtUtils::ParseXS'     => '3.04_04',
            'ExtUtils::ParseXS::Constants'=> '3.04_04',
            'ExtUtils::ParseXS::CountLines'=> '3.04_04',
            'ExtUtils::ParseXS::Utilities'=> '3.04_04',
            'ExtUtils::Typemaps'    => '1.02',
            'File::Glob'            => '1.13',
            'Filter::Simple'        => '0.88',
            'IO'                    => '1.25_06',
            'IO::Handle'            => '1.33',
            'Locale::Codes'         => '3.18',
            'Locale::Codes::Constants'=> '3.18',
            'Locale::Codes::Country'=> '3.18',
            'Locale::Codes::Country_Codes'=> '3.18',
            'Locale::Codes::Currency'=> '3.18',
            'Locale::Codes::Currency_Codes'=> '3.18',
            'Locale::Codes::LangExt'=> '3.18',
            'Locale::Codes::LangExt_Codes'=> '3.18',
            'Locale::Codes::LangVar'=> '3.18',
            'Locale::Codes::LangVar_Codes'=> '3.18',
            'Locale::Codes::Language'=> '3.18',
            'Locale::Codes::Language_Codes'=> '3.18',
            'Locale::Codes::Script' => '3.18',
            'Locale::Codes::Script_Codes'=> '3.18',
            'Locale::Country'       => '3.18',
            'Locale::Currency'      => '3.18',
            'Locale::Language'      => '3.18',
            'Locale::Script'        => '3.18',
            'Math::BigFloat'        => '1.997',
            'Math::BigInt'          => '1.997',
            'Math::BigInt::Calc'    => '1.997',
            'Math::BigInt::CalcEmu' => '1.997',
            'Math::BigInt::FastCalc'=> '0.30',
            'Math::BigRat'          => '0.2603',
            'Module::CoreList'      => '2.56',
            'Module::Load::Conditional'=> '0.46',
            'Module::Metadata'      => '1.000007',
            'ODBM_File'             => '1.12',
            'POSIX'                 => '1.26',
            'Pod::Perldoc'          => '3.15_07',
            'Pod::Simple'           => '3.19',
            'Pod::Simple::BlackBox' => '3.19',
            'Pod::Simple::Checker'  => '3.19',
            'Pod::Simple::Debug'    => '3.19',
            'Pod::Simple::DumpAsText'=> '3.19',
            'Pod::Simple::DumpAsXML'=> '3.19',
            'Pod::Simple::HTML'     => '3.19',
            'Pod::Simple::HTMLBatch'=> '3.19',
            'Pod::Simple::LinkSection'=> '3.19',
            'Pod::Simple::Methody'  => '3.19',
            'Pod::Simple::Progress' => '3.19',
            'Pod::Simple::PullParser'=> '3.19',
            'Pod::Simple::PullParserEndToken'=> '3.19',
            'Pod::Simple::PullParserStartToken'=> '3.19',
            'Pod::Simple::PullParserTextToken'=> '3.19',
            'Pod::Simple::PullParserToken'=> '3.19',
            'Pod::Simple::RTF'      => '3.19',
            'Pod::Simple::Search'   => '3.19',
            'Pod::Simple::SimpleTree'=> '3.19',
            'Pod::Simple::Text'     => '3.19',
            'Pod::Simple::TextContent'=> '3.19',
            'Pod::Simple::TiedOutFH'=> '3.19',
            'Pod::Simple::Transcode'=> '3.19',
            'Pod::Simple::TranscodeDumb'=> '3.19',
            'Pod::Simple::TranscodeSmart'=> '3.19',
            'Pod::Simple::XHTML'    => '3.19',
            'Pod::Simple::XMLOutStream'=> '3.19',
            'Search::Dict'          => '1.04',
            'Socket'                => '1.94_01',
            'Storable'              => '2.32',
            'Text::Abbrev'          => '1.02',
            'Tie::Array'            => '1.05',
            'UNIVERSAL'             => '1.09',
            'Unicode::UCD'          => '0.35',
            'XS::APItest'           => '0.31',
            'XSLoader'              => '0.16',
            'attributes'            => '0.16',
            'diagnostics'           => '1.25',
            'open'                  => '1.09',
            'perlfaq'               => '5.0150034',
            'threads'               => '1.85',
            'threads::shared'       => '1.40',
        },
        removed => {
        }
    },
    5.015004 => {
        delta_from => 5.015003,
        changed => {
            'Archive::Tar'          => '1.80',
            'Archive::Tar::Constant'=> '1.80',
            'Archive::Tar::File'    => '1.80',
            'Digest'                => '1.17',
            'DynaLoader'            => '1.14',
            'ExtUtils::Command::MM' => '6.61_01',
            'ExtUtils::Liblist'     => '6.61_01',
            'ExtUtils::Liblist::Kid'=> '6.61_01',
            'ExtUtils::MM'          => '6.61_01',
            'ExtUtils::MM_AIX'      => '6.61_01',
            'ExtUtils::MM_Any'      => '6.61_01',
            'ExtUtils::MM_BeOS'     => '6.61_01',
            'ExtUtils::MM_Cygwin'   => '6.61_01',
            'ExtUtils::MM_DOS'      => '6.61_01',
            'ExtUtils::MM_Darwin'   => '6.61_01',
            'ExtUtils::MM_MacOS'    => '6.61_01',
            'ExtUtils::MM_NW5'      => '6.61_01',
            'ExtUtils::MM_OS2'      => '6.61_01',
            'ExtUtils::MM_QNX'      => '6.61_01',
            'ExtUtils::MM_UWIN'     => '6.61_01',
            'ExtUtils::MM_Unix'     => '6.61_01',
            'ExtUtils::MM_VMS'      => '6.61_01',
            'ExtUtils::MM_VOS'      => '6.61_01',
            'ExtUtils::MM_Win32'    => '6.61_01',
            'ExtUtils::MM_Win95'    => '6.61_01',
            'ExtUtils::MY'          => '6.61_01',
            'ExtUtils::MakeMaker'   => '6.61_01',
            'ExtUtils::MakeMaker::Config'=> '6.61_01',
            'ExtUtils::Mkbootstrap' => '6.61_01',
            'ExtUtils::Mksymlists'  => '6.61_01',
            'ExtUtils::ParseXS'     => '3.05',
            'ExtUtils::ParseXS::Constants'=> '3.05',
            'ExtUtils::ParseXS::CountLines'=> '3.05',
            'ExtUtils::ParseXS::Utilities'=> '3.05',
            'ExtUtils::testlib'     => '6.61_01',
            'File::DosGlob'         => '1.05',
            'Module::CoreList'      => '2.57',
            'Module::Load'          => '0.22',
            'Unicode::Collate'      => '0.80',
            'Unicode::Collate::Locale'=> '0.80',
            'Unicode::UCD'          => '0.36',
            'XS::APItest'           => '0.32',
            'XS::Typemap'           => '0.07',
            'attributes'            => '0.17',
            'base'                  => '2.18',
            'constant'              => '1.23',
            'mro'                   => '1.09',
            'open'                  => '1.10',
            'perlfaq'               => '5.0150035',
        },
        removed => {
        }
    },
    5.015005 => {
        delta_from => 5.015004,
        changed => {
            'Archive::Extract'      => '0.58',
            'B::Concise'            => '0.87',
            'B::Deparse'            => '1.09',
            'CGI'                   => '3.58',
            'CGI::Fast'             => '1.09',
            'CPANPLUS'              => '0.9112',
            'CPANPLUS::Dist::Build' => '0.60',
            'CPANPLUS::Dist::Build::Constants'=> '0.60',
            'CPANPLUS::Internals'   => '0.9112',
            'CPANPLUS::Shell::Default'=> '0.9112',
            'Compress::Raw::Bzip2'  => '2.042',
            'Compress::Raw::Zlib'   => '2.042',
            'Compress::Zlib'        => '2.042',
            'Digest::SHA'           => '5.63',
            'Errno'                 => '1.15',
            'ExtUtils::Command::MM' => '6.63_02',
            'ExtUtils::Liblist'     => '6.63_02',
            'ExtUtils::Liblist::Kid'=> '6.63_02',
            'ExtUtils::MM'          => '6.63_02',
            'ExtUtils::MM_AIX'      => '6.63_02',
            'ExtUtils::MM_Any'      => '6.63_02',
            'ExtUtils::MM_BeOS'     => '6.63_02',
            'ExtUtils::MM_Cygwin'   => '6.63_02',
            'ExtUtils::MM_DOS'      => '6.63_02',
            'ExtUtils::MM_Darwin'   => '6.63_02',
            'ExtUtils::MM_MacOS'    => '6.63_02',
            'ExtUtils::MM_NW5'      => '6.63_02',
            'ExtUtils::MM_OS2'      => '6.63_02',
            'ExtUtils::MM_QNX'      => '6.63_02',
            'ExtUtils::MM_UWIN'     => '6.63_02',
            'ExtUtils::MM_Unix'     => '6.63_02',
            'ExtUtils::MM_VMS'      => '6.63_02',
            'ExtUtils::MM_VOS'      => '6.63_02',
            'ExtUtils::MM_Win32'    => '6.63_02',
            'ExtUtils::MM_Win95'    => '6.63_02',
            'ExtUtils::MY'          => '6.63_02',
            'ExtUtils::MakeMaker'   => '6.63_02',
            'ExtUtils::MakeMaker::Config'=> '6.63_02',
            'ExtUtils::Mkbootstrap' => '6.63_02',
            'ExtUtils::Mksymlists'  => '6.63_02',
            'ExtUtils::testlib'     => '6.63_02',
            'File::DosGlob'         => '1.06',
            'File::Glob'            => '1.14',
            'HTTP::Tiny'            => '0.016',
            'IO::Compress::Adapter::Bzip2'=> '2.042',
            'IO::Compress::Adapter::Deflate'=> '2.042',
            'IO::Compress::Adapter::Identity'=> '2.042',
            'IO::Compress::Base'    => '2.042',
            'IO::Compress::Base::Common'=> '2.042',
            'IO::Compress::Bzip2'   => '2.042',
            'IO::Compress::Deflate' => '2.042',
            'IO::Compress::Gzip'    => '2.042',
            'IO::Compress::Gzip::Constants'=> '2.042',
            'IO::Compress::RawDeflate'=> '2.042',
            'IO::Compress::Zip'     => '2.042',
            'IO::Compress::Zip::Constants'=> '2.042',
            'IO::Compress::Zlib::Constants'=> '2.042',
            'IO::Compress::Zlib::Extra'=> '2.042',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.042',
            'IO::Uncompress::Adapter::Identity'=> '2.042',
            'IO::Uncompress::Adapter::Inflate'=> '2.042',
            'IO::Uncompress::AnyInflate'=> '2.042',
            'IO::Uncompress::AnyUncompress'=> '2.042',
            'IO::Uncompress::Base'  => '2.042',
            'IO::Uncompress::Bunzip2'=> '2.042',
            'IO::Uncompress::Gunzip'=> '2.042',
            'IO::Uncompress::Inflate'=> '2.042',
            'IO::Uncompress::RawInflate'=> '2.042',
            'IO::Uncompress::Unzip' => '2.042',
            'Locale::Maketext'      => '1.20',
            'Locale::Maketext::Guts'=> '1.20',
            'Locale::Maketext::GutsLoader'=> '1.20',
            'Module::CoreList'      => '2.58',
            'Opcode'                => '1.21',
            'Socket'                => '1.94_02',
            'Storable'              => '2.33',
            'UNIVERSAL'             => '1.10',
            'Unicode::Collate'      => '0.85',
            'Unicode::Collate::CJK::Pinyin'=> '0.85',
            'Unicode::Collate::CJK::Stroke'=> '0.85',
            'Unicode::Collate::Locale'=> '0.85',
            'Unicode::UCD'          => '0.37',
            'XS::APItest'           => '0.33',
            'arybase'               => '0.01',
            'charnames'             => '1.24',
            'feature'               => '1.23',
            'perlfaq'               => '5.0150036',
            'strict'                => '1.05',
            'unicore::Name'         => undef,
        },
        removed => {
        }
    },
    5.015006 => {
        delta_from => 5.015005,
        changed => {
            'Archive::Tar'          => '1.82',
            'Archive::Tar::Constant'=> '1.82',
            'Archive::Tar::File'    => '1.82',
            'AutoLoader'            => '5.72',
            'B::Concise'            => '0.88',
            'B::Debug'              => '1.17',
            'B::Deparse'            => '1.10',
            'CPAN::Meta::YAML'      => '0.005',
            'CPANPLUS'              => '0.9113',
            'CPANPLUS::Internals'   => '0.9113',
            'CPANPLUS::Shell::Default'=> '0.9113',
            'Carp'                  => '1.24',
            'Compress::Raw::Bzip2'  => '2.045',
            'Compress::Raw::Zlib'   => '2.045',
            'Compress::Zlib'        => '2.045',
            'Cwd'                   => '3.38',
            'DB'                    => '1.04',
            'Data::Dumper'          => '2.135_01',
            'Digest::SHA'           => '5.70',
            'Dumpvalue'             => '1.17',
            'Exporter'              => '5.66',
            'Exporter::Heavy'       => '5.66',
            'ExtUtils::CBuilder'    => '0.280205',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280204',
            'ExtUtils::Packlist'    => '1.45',
            'ExtUtils::ParseXS'     => '3.08',
            'ExtUtils::ParseXS::Constants'=> '3.08',
            'ExtUtils::ParseXS::CountLines'=> '3.08',
            'ExtUtils::ParseXS::Utilities'=> '3.08',
            'File::Basename'        => '2.84',
            'File::Glob'            => '1.15',
            'File::Spec::Unix'      => '3.35',
            'Getopt::Std'           => '1.07',
            'I18N::LangTags'        => '0.38',
            'IO::Compress::Adapter::Bzip2'=> '2.045',
            'IO::Compress::Adapter::Deflate'=> '2.045',
            'IO::Compress::Adapter::Identity'=> '2.045',
            'IO::Compress::Base'    => '2.046',
            'IO::Compress::Base::Common'=> '2.045',
            'IO::Compress::Bzip2'   => '2.045',
            'IO::Compress::Deflate' => '2.045',
            'IO::Compress::Gzip'    => '2.045',
            'IO::Compress::Gzip::Constants'=> '2.045',
            'IO::Compress::RawDeflate'=> '2.045',
            'IO::Compress::Zip'     => '2.046',
            'IO::Compress::Zip::Constants'=> '2.045',
            'IO::Compress::Zlib::Constants'=> '2.045',
            'IO::Compress::Zlib::Extra'=> '2.045',
            'IO::Dir'               => '1.09',
            'IO::File'              => '1.16',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.045',
            'IO::Uncompress::Adapter::Identity'=> '2.045',
            'IO::Uncompress::Adapter::Inflate'=> '2.045',
            'IO::Uncompress::AnyInflate'=> '2.045',
            'IO::Uncompress::AnyUncompress'=> '2.045',
            'IO::Uncompress::Base'  => '2.046',
            'IO::Uncompress::Bunzip2'=> '2.045',
            'IO::Uncompress::Gunzip'=> '2.045',
            'IO::Uncompress::Inflate'=> '2.045',
            'IO::Uncompress::RawInflate'=> '2.045',
            'IO::Uncompress::Unzip' => '2.046',
            'Locale::Codes'         => '3.20',
            'Locale::Codes::Constants'=> '3.20',
            'Locale::Codes::Country'=> '3.20',
            'Locale::Codes::Country_Codes'=> '3.20',
            'Locale::Codes::Country_Retired'=> '3.20',
            'Locale::Codes::Currency'=> '3.20',
            'Locale::Codes::Currency_Codes'=> '3.20',
            'Locale::Codes::Currency_Retired'=> '3.20',
            'Locale::Codes::LangExt'=> '3.20',
            'Locale::Codes::LangExt_Codes'=> '3.20',
            'Locale::Codes::LangExt_Retired'=> '3.20',
            'Locale::Codes::LangFam'=> '3.20',
            'Locale::Codes::LangFam_Codes'=> '3.20',
            'Locale::Codes::LangFam_Retired'=> '3.20',
            'Locale::Codes::LangVar'=> '3.20',
            'Locale::Codes::LangVar_Codes'=> '3.20',
            'Locale::Codes::LangVar_Retired'=> '3.20',
            'Locale::Codes::Language'=> '3.20',
            'Locale::Codes::Language_Codes'=> '3.20',
            'Locale::Codes::Language_Retired'=> '3.20',
            'Locale::Codes::Script' => '3.20',
            'Locale::Codes::Script_Codes'=> '3.20',
            'Locale::Codes::Script_Retired'=> '3.20',
            'Locale::Country'       => '3.20',
            'Locale::Currency'      => '3.20',
            'Locale::Language'      => '3.20',
            'Locale::Maketext'      => '1.21',
            'Locale::Script'        => '3.20',
            'Module::CoreList'      => '2.59',
            'Module::Loaded'        => '0.08',
            'Opcode'                => '1.22',
            'POSIX'                 => '1.27',
            'Pod::Html'             => '1.12',
            'Pod::LaTeX'            => '0.60',
            'Pod::Perldoc'          => '3.15_08',
            'Safe'                  => '2.30',
            'SelfLoader'            => '1.20',
            'Socket'                => '1.97',
            'Storable'              => '2.34',
            'UNIVERSAL'             => '1.11',
            'Unicode::Collate'      => '0.87',
            'Unicode::Collate::Locale'=> '0.87',
            'XS::APItest'           => '0.34',
            'arybase'               => '0.02',
            'charnames'             => '1.27',
            'diagnostics'           => '1.26',
            'feature'               => '1.24',
            'if'                    => '0.0602',
            'overload'              => '1.16',
            'sigtrap'               => '1.06',
            'strict'                => '1.06',
            'threads'               => '1.86',
            'version'               => '0.96',
        },
        removed => {
        }
    },
    5.015007 => {
        delta_from => 5.015006,
        changed => {
            'B'                     => '1.33',
            'B::Deparse'            => '1.11',
            'CGI'                   => '3.59',
            'CPAN::Meta'            => '2.113640',
            'CPAN::Meta::Converter' => '2.113640',
            'CPAN::Meta::Feature'   => '2.113640',
            'CPAN::Meta::History'   => '2.113640',
            'CPAN::Meta::Prereqs'   => '2.113640',
            'CPAN::Meta::Requirements'=> '2.113640',
            'CPAN::Meta::Spec'      => '2.113640',
            'CPAN::Meta::Validator' => '2.113640',
            'CPANPLUS'              => '0.9116',
            'CPANPLUS::Internals'   => '0.9116',
            'CPANPLUS::Shell::Default'=> '0.9116',
            'Cwd'                   => '3.39_01',
            'Data::Dumper'          => '2.135_03',
            'Devel::InnerPackage'   => '0.4',
            'ExtUtils::CBuilder::Base'=> '0.280205',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280205',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280205',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280205',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280205',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280205',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280205',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280205',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280205',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280205',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280205',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280205',
            'ExtUtils::Manifest'    => '1.61',
            'ExtUtils::Packlist'    => '1.46',
            'ExtUtils::ParseXS'     => '3.12',
            'ExtUtils::ParseXS::Constants'=> '3.12',
            'ExtUtils::ParseXS::CountLines'=> '3.12',
            'ExtUtils::ParseXS::Utilities'=> '3.12',
            'ExtUtils::Typemaps'    => '1.03',
            'ExtUtils::Typemaps::Cmd'=> undef,
            'ExtUtils::Typemaps::Type'=> '0.06',
            'File::Glob'            => '1.16',
            'File::Spec'            => '3.39_01',
            'File::Spec::Cygwin'    => '3.39_01',
            'File::Spec::Epoc'      => '3.39_01',
            'File::Spec::Functions' => '3.39_01',
            'File::Spec::Mac'       => '3.39_01',
            'File::Spec::OS2'       => '3.39_01',
            'File::Spec::Unix'      => '3.39_01',
            'File::Spec::VMS'       => '3.39_01',
            'File::Spec::Win32'     => '3.39_01',
            'IO::Dir'               => '1.10',
            'IO::Pipe'              => '1.15',
            'IO::Poll'              => '0.09',
            'IO::Select'            => '1.21',
            'IO::Socket'            => '1.34',
            'IO::Socket::INET'      => '1.33',
            'IO::Socket::UNIX'      => '1.24',
            'Locale::Maketext'      => '1.22',
            'Math::BigInt'          => '1.998',
            'Module::CoreList'      => '2.60',
            'Module::Pluggable'     => '4.0',
            'POSIX'                 => '1.28',
            'PerlIO::scalar'        => '0.13',
            'Pod::Html'             => '1.13',
            'Pod::Perldoc'          => '3.15_15',
            'Pod::Perldoc::BaseTo'  => '3.15_15',
            'Pod::Perldoc::GetOptsOO'=> '3.15_15',
            'Pod::Perldoc::ToANSI'  => '3.15_15',
            'Pod::Perldoc::ToChecker'=> '3.15_15',
            'Pod::Perldoc::ToMan'   => '3.15_15',
            'Pod::Perldoc::ToNroff' => '3.15_15',
            'Pod::Perldoc::ToPod'   => '3.15_15',
            'Pod::Perldoc::ToRtf'   => '3.15_15',
            'Pod::Perldoc::ToTerm'  => '3.15_15',
            'Pod::Perldoc::ToText'  => '3.15_15',
            'Pod::Perldoc::ToTk'    => '3.15_15',
            'Pod::Perldoc::ToXml'   =