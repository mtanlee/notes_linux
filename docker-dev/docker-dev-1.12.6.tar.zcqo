" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Simple::XHTML 3pm"
.TH Pod::Simple::XHTML 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Simple::XHTML \-\- format Pod as validating XHTML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Pod::Simple::XHTML;
\&
\&  my $parser = Pod::Simple::XHTML\->new();
\&
\&  ...
\&
\&  $parser\->parse_file(\*(Aqpath/to/file.pod\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a formatter that takes Pod and renders it as \s-1XHTML\s0
validating \s-1HTML\s0.
.PP
This is a subclass of Pod::Simple::Methody and inherits all its
methods. The implementation is entirely different than
Pod::Simple::HTML, but it largely preserves the same interface.
.SS "Minimal code"
.IX Subsection "Minimal code"
.Vb 6
\&  use Pod::Simple::XHTML;
\&  my $psx = Pod::Simple::XHTML\->new;
\&  $psx\->output_string(\emy $html);
\&  $psx\->parse_file(\*(Aqpath/to/Module/Name.pm\*(Aq);
\&  open my $out, \*(Aq>\*(Aq, \*(Aqout.html\*(Aq or die "Cannot open \*(Aqout.html\*(Aq: $!\en";
\&  print $out $html;
.Ve
.PP
You can also control the character encoding and entities. For example, if
you're sure that the \s-1POD\s0 is properly encoded (using the \f(CW\*(C`=encoding\*(C'\fR command),
you can prevent high-bit characters from being encoded as \s-1HTML\s0 entities and
declare the output character set as \s-1UTF\-8\s0 before parsing, like so:
.PP
.Vb 2
\&  $psx\->html_charset(\*(AqUTF\-8\*(Aq);
\&  $psx\->html_encode_chars(\*(Aq&<>">\*(Aq);
.Ve
.SH "METHODS"
.IX Header "METHODS"
Pod::Simple::XHTML offers a number of methods that modify the format of
the \s-1HTML\s0 output. Call these after creating the parser object, but before
the call to \f(CW\*(C`parse_file\*(C'\fR:
.PP
.Vb 3
\&  my $parser = Pod::PseudoPod::HTML\->new();
\&  $parser\->set_optional_param("value");
\&  $parser\->parse_file($file);
.Ve
.SS "perldoc_url_prefix"
.IX Subsection "perldoc_url_prefix"
In turning Foo::Bar into http://whatever/Foo%3a%3aBar, what
to put before the \*(L"Foo%3a%3aBar\*(R". The default value is
\&\*(L"http://search.cpan.org/perldoc?\*(R".
.SS "perldoc_url_postfix"
.IX Subsection "perldoc_url_postfix"
What to put after \*(L"Foo%3a%3aBar\*(R" in the \s-1URL\s0. This option is not set by
default.
.SS "man_url_prefix"
.IX Subsection "man_url_prefix"
In turning \f(CWcrontab(5)\fR into http://whatever/man/1/crontab, what
to put before the \*(L"1/crontab\*(R". The default value is
\&\*(L"http://man.he.net/man\*(R".
.SS "man_url_postfix"
.IX Subsection "man_url_postfix"
What to put after \*(L"1/crontab\*(R" in the \s-1URL\s0. This option is not set by default.
.SS "title_prefix, title_postfix"
.IX Subsection "title_prefix, title_postfix"
What to put before and after the title in the head. The values should
already be &\-escaped.
.SS "html_css"
.IX Subsection "html_css"
.Vb 1
\&  $parser\->html_css(\*(Aqpath/to/style.css\*(Aq);
.Ve
.PP
The \s-1URL\s0 or relative path of a \s-1CSS\s0 file to include. This option is not
set by default.
.SS "html_javascript"
.IX Subsection "html_javascript"
The \s-1URL\s0 or relative path of a JavaScript file to pull in. This option is
not set by default.
.SS "html_doctype"
.IX Subsection "html_doctype"
A document type tag for the file. This option is not set by default.
.SS "html_charset"
.IX Subsection "html_charset"
The charater set to declare in the Content-Type meta tag created by default
for \f(CW\*(C`html_header_tags\*(C'\fR. Note that this option will be ignored if the value of
\&\f(CW\*(C`html_header_tags\*(C'\fR is changed. Defaults to \*(L"\s-1ISO\-8859\-1\s0\*(R".
.SS "html_header_tags"
.IX Subsection "html_header_tags"
Additional arbitrary \s-1HTML\s0 tags for the header of the document. The
default value is just a content type header tag:
.PP
.Vb 1
\&  <meta http\-equiv="Content\-Type" content="text/html; charset=ISO\-8859\-1">
.Ve
.PP
Add additional meta tags here, or blocks of inline \s-1CSS\s0 or JavaScript
(wrapped in the appropriate tags).
.PP
\fIhtml_encode_chars\fR
.IX Subsection "html_encode_chars"
.PP
A string containing all characters that should be encoded as \s-1HTML\s0 entities,
specified using the regular expression character class syntax (what you find
within brackets in regular expressions). This value will be passed as the
second argument to the \f(CW\*(C`encode_entities\*(C'\fR fuction of HTML::Entities. \s-1IF\s0
HTML::Entities is not installed, then any characters other than \f(CW\*(C`&<\*(C'\fR"'>
will be encoded numerically.
.SS "html_h_level"
.IX Subsection "html_h_level"
This is the level of \s-1HTML\s0 \*(L"Hn\*(R" element to which a Pod \*(L"head1\*(R" corresponds.  For
example, if \f(CW\*(C`html_h_level\*(C'\fR is set to 2, a head1 will produce an H2, a head2
will produce an H3, and so on.
.SS "default_title"
.IX Subsection "default_title"
Set a default title for the page if no title can be determined from the
content. The value of this string should already be &\-escaped.
.SS "force_title"
.IX Subsection "force_title"
Force a title for the page (don't try to determine it from the content).
The value of this string should already be &\-escaped.
.SS "html_header, html_footer"
.IX Subsection "html_header, html_footer"
Set the \s-1HTML\s0 output at the beginning and end of each file. The default
header includes a title, a doctype tag (if \f(CW\*(C`html_doctype\*(C'\fR is set), a
content tag (customized by \f(CW\*(C`html_header_tags\*(C'\fR), a tag for a \s-1CSS\s0 file
(if \f(CW\*(C`html_css\*(C'\fR is set), and a tag for a Javascript file (if
\&\f(CW\*(C`html_javascript\*(C'\fR is set). The default footer simply closes the \f(CW\*(C`html\*(C'\fR
and \f(CW\*(C`body\*(C'\fR tags.
.PP
The options listed above customize parts of the default header, but
setting \f(CW\*(C`html_header\*(C'\fR or \f(CW\*(C`html_footer\*(C'\fR completely overrides the
built-in header or footer. These may be useful if you want to use
template tags instead of literal \s-1HTML\s0 headers and footers or are
integrating converted \s-1POD\s0 pages in a larger website.
.PP
If you want no headers or footers output in the \s-1HTML\s0, set these options
to the empty string.
.SS "index"
.IX Subsection "index"
Whether to add a table-of-contents at the top of each page (called an
index for the sake of tradition).
.SS "anchor_items"
.IX Subsection "anchor_items"
Whether to anchor every definition \f(CW\*(C`=item\*(C'\fR directive. This needs to be
enabled if you want to be able to link to specific \f(CW\*(C`=item\*(C'\fR directives, which
are output as \f(CW\*(C`<dt>\*(C'\fR elements. Disabled by default.
.SS "backlink"
.IX Subsection "backlink"
Whether to turn every =head1 directive into a link pointing to the top 
of the page (specifically, the opening body tag).
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
If the standard options aren't enough, you may want to subclass
Pod::Simple::XHMTL. These are the most likely candidates for methods
you'll want to override when subclassing.
.SS "handle_text"
.IX Subsection "handle_text"
This method handles the body of text within any element: it's the body
of a paragraph, or everything between a \*(L"=begin\*(R" tag and the
corresponding \*(L"=end\*(R" tag, or the text within an L entity, etc. You would
want to override this if you are adding a custom element type that does
more than just display formatted text. Perhaps adding a way to generate
\&\s-1HTML\s0 tables from an extended version of \s-1POD\s0.
.PP
So, let's say you want to add a custom element called 'foo'. In your
subclass's \f(CW\*(C`new\*(C'\fR method, after calling \f(CW\*(C`SUPER::new\*(C'\fR you'd call:
.PP
.Vb 1
\&  $new\->accept_targets_as_text( \*(Aqfoo\*(Aq );
.Ve
.PP
Then override the \f(CW\*(C`start_for\*(C'\fR method in the subclass to check for when
\&\*(L"$flags\->{'target'}\*(R" is equal to 'foo' and set a flag that marks that
you're in a foo block (maybe \*(L"$self\->{'in_foo'} = 1\*(R"). Then override the
\&\f(CW\*(C`handle_text\*(C'\fR method to check for the flag, and pass \f(CW$text\fR to your
custom subroutine to construct the \s-1HTML\s0 output for 'foo' elements,
something like:
.PP
.Vb 8
\&  sub handle_text {
\&      my ($self, $text) = @_;
\&      if ($self\->{\*(Aqin_foo\*(Aq}) {
\&          $self\->{\*(Aqscratch\*(Aq} .= build_foo_html($text);
\&      } else {
\&          $self\->{\*(Aqscratch\*(Aq} .= $text;
\&      }
\&  }
.Ve
.SS "accept_targets_as_html"
.IX Subsection "accept_targets_as_html"
This method behaves like \f(CW\*(C`accept_targets_as_text\*(C'\fR, but also marks the region
as one whose content should be emitted literally, without \s-1HTML\s0 entity escaping
or wrapping in a \f(CW\*(C`div\*(C'\fR element.
.SS "resolve_pod_page_link"
.IX Subsection "resolve_pod_page_link"
.Vb 3
\&  my $url = $pod\->resolve_pod_page_link(\*(AqNet::Ping\*(Aq, \*(AqINSTALL\*(Aq);
\&  my $url = $pod\->resolve_pod_page_link(\*(Aqperlpodspec\*(Aq);
\&  my $url = $pod\->resolve_pod_page_link(undef, \*(AqSYNOPSIS\*(Aq);
.Ve
.PP
Resolves a \s-1POD\s0 link target (typically a module or \s-1POD\s0 file name) and section
name to a \s-1URL\s0. The resulting link will be returned for the above examples as:
.PP
.Vb 3
\&  http://search.cpan.org/perldoc?Net::Ping#INSTALL
\&  http://search.cpan.org/perldoc?perlpodspec
\&  #SYNOPSIS
.Ve
.PP
Note that when there is only a section argument the \s-1URL\s0 will simply be a link
to a section in the current document.
.SS "resolve_man_page_link"
.IX Subsection "resolve_man_page_link"
.Vb 2
\&  my $url = $pod\->resolve_man_page_link(\*(Aqcrontab(5)\*(Aq, \*(AqEXAMPLE CRON FILE\*(Aq);
\&  my $url = $pod\->resolve_man_page_link(\*(Aqcrontab\*(Aq);
.Ve
.PP
Resolves a man page link target and numeric section to a \s-1URL\s0. The resulting
link will be returned for the above examples as:
.PP
.Vb 2
\&    http://man.he.net/man5/crontab
\&    http://man.he.net/man1/crontab
.Ve
.PP
Note that the first argument is required. The section number will be parsed
from it, and if it's missing will default to 1. The second argument is
currently ignored, as man.he.net <http://man.he.net> does not currently
include linkable IDs or anchor names in its pages. Subclass to link to a
different man page \s-1HTTP\s0 server.
.SS "idify"
.IX Subsection "idify"
.Vb 2
\&  my $id   = $pod\->idify($text);
\&  my $hash = $pod\->idify($text, 1);
.Ve
.PP
This method turns an arbitrary string into a valid \s-1XHTML\s0 \s-1ID\s0 attribute value.
The rules enforced, following
<http://webdesign.about.com/od/htmltags/a/aa031707.htm>, are:
.IP "\(bu" 4
The id must start with a letter (a\-z or A\-Z)
.IP "\(bu" 4
All subsequent characters can be letters, numbers (0\-9), hyphens (\-),
underscores (_), colons (:), and periods (.).
.IP "\(bu" 4
Each id must be unique within the document.
.PP
In addition, the returned value will be unique within the context of the
Pod::Simple::XHTML object unless a second argument is passed a true value. \s-1ID\s0
attributes should always be unique within a single \s-1XHTML\s0 document, but pass
the true value if you are creating not an \s-1ID\s0 but a \s-1URL\s0 hash to point to
an \s-1ID\s0 (i.e., if you need to put the \*(L"#foo\*(R" in \f(CW\*(C`<a href="#foo">foo</a>\*(C'\fR.
.SS "batch_mode_page_object_init"
.IX Subsection "batch_mode_page_object_init"
.Vb 1
\&  $pod\->batch_mode_page_object_init($batchconvobj, $module, $infile, $outfile, $depth);
.Ve
.PP
Called by Pod::Simple::HTMLBatch so that the class has a chance to
initialize the converter. Internally it sets the \f(CW\*(C`batch_mode\*(C'\fR property to
true and sets \f(CW\*(C`batch_mode_current_level()\*(C'\fR, but Pod::Simple::XHTML does not
currently use those features. Subclasses might, though.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple, Pod::Simple::Text, Pod::Spell
.SH "SUPPORT"
.IX Header "SUPPORT"
Questions or discussion about \s-1POD\s0 and Pod::Simple should be sent to the
pod\-people@perl.org mail list. Send an empty email to
pod\-people\-subscribe@perl.org to subscribe.
.PP
This module is managed in an open GitHub repository,
http://github.com/theory/pod\-simple/ <http://github.com/theory/pod-simple/>. Feel free to fork and contribute, or
to clone git://github.com/theory/pod\-simple.git <git://github.com/theory/pod-simple.git> and send patches!
.PP
Patches against Pod::Simple are welcome. Please send bug reports to
<bug\-pod\-simple@rt.cpan.org>.
.SH "COPYRIGHT AND DISCLAIMERS"
.IX Header "COPYRIGHT AND DISCLAIMERS"
Copyright (c) 2003\-2005 Allison Randal.
.PP
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Hurricane Electric <http://he.net/> for permission to use its
Linux man pages online <http://man.he.net/> site for man page links.
.PP
Thanks to search.cpan.org <http://search.cpan.org/> for permission to use the
site for Perl module links.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pod::Simpele::XHTML was created by Allison Randal <allison@perl.org>.
.PP
Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
But don't bother him, he's retired.
.PP
Pod::Simple is maintained by:
.IP "\(bu" 4
Allison Randal \f(CW\*(C`allison@perl.org\*(C'\fR
.IP "\(bu" 4
Hans Dieter Pearcey \f(CW\*(C`hdp@cpan.org\*(C'\fR
.IP "\(bu" 4
David E. Wheeler \f(CW\*(C`dwheeler@cpan.org\*(C'\fR
                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Simple::XHTML5.18.3pm                   0100644 0001750 0001750 00000043645 12566207462 024714  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Simple::XHTML 3pm"
.TH Pod::Simple::XHTML 3pm "2013-11-14" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Simple::XHTML \-\- format Pod as validating XHTML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Pod::Simple::XHTML;
\&
\&  my $parser = Pod::Simple::XHTML\->new();
\&
\&  ...
\&
\&  $parser\->parse_file(\*(Aqpath/to/file.pod\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a formatter that takes Pod and renders it as \s-1XHTML\s0
validating \s-1HTML.\s0
.PP
This is a subclass of Pod::Simple::Methody and inherits all its
methods. The implementation is entirely different than
Pod::Simple::HTML, but it largely preserves the same interface.
.SS "Minimal code"
.IX Subsection "Minimal code"
.Vb 6
\&  use Pod::Simple::XHTML;
\&  my $psx = Pod::Simple::XHTML\->new;
\&  $psx\->output_string(\emy $html);
\&  $psx\->parse_file(\*(Aqpath/to/Module/Name.pm\*(Aq);
\&  open my $out, \*(Aq>\*(Aq, \*(Aqout.html\*(Aq or die "Cannot open \*(Aqout.html\*(Aq: $!\en";
\&  print $out $html;
.Ve
.PP
You can also control the character encoding and entities. For example, if
you're sure that the \s-1POD\s0 is properly encoded (using the \f(CW\*(C`=encoding\*(C'\fR command),
you can prevent high-bit characters from being encoded as \s-1HTML\s0 entities and
declare the output character set as \s-1UTF\-8\s0 before parsing, like so:
.PP
.Vb 2
\&  $psx\->html_charset(\*(AqUTF\-8\*(Aq);
\&  $psx\->html_encode_chars(\*(Aq&<>">\*(Aq);
.Ve
.SH "METHODS"
.IX Header "METHODS"
Pod::Simple::XHTML offers a number of methods that modify the format of
the \s-1HTML\s0 output. Call these after creating the parser object, but before
the call to \f(CW\*(C`parse_file\*(C'\fR:
.PP
.Vb 3
\&  my $parser = Pod::PseudoPod::HTML\->new();
\&  $parser\->set_optional_param("value");
\&  $parser\->parse_file($file);
.Ve
.SS "perldoc_url_prefix"
.IX Subsection "perldoc_url_prefix"
In turning Foo::Bar into http://whatever/Foo%3a%3aBar, what
to put before the \*(L"Foo%3a%3aBar\*(R". The default value is
\&\*(L"http://search.cpan.org/perldoc?\*(R".
.SS "perldoc_url_postfix"
.IX Subsection "perldoc_url_postfix"
What to put after \*(L"Foo%3a%3aBar\*(R" in the \s-1URL.\s0 This option is not set by
default.
.SS "man_url_prefix"
.IX Subsection "man_url_prefix"
In turning \f(CWcrontab(5)\fR into http://whatever/man/1/crontab, what
to put before the \*(L"1/crontab\*(R". The default value is
\&\*(L"http://man.he.net/man\*(R".
.SS "man_url_postfix"
.IX Subsection "man_url_postfix"
What to put after \*(L"1/crontab\*(R" in the \s-1URL.\s0 This option is not set by default.
.SS "title_prefix, title_postfix"
.IX Subsection "title_prefix, title_postfix"
What to put before and after the title in the head. The values should
already be &\-escaped.
.SS "html_css"
.IX Subsection "html_css"
.Vb 1
\&  $parser\->html_css(\*(Aqpath/to/style.css\*(Aq);
.Ve
.PP
The \s-1URL\s0 or relative path of a \s-1CSS\s0 file to include. This option is not
set by default.
.SS "html_javascript"
.IX Subsection "html_javascript"
The \s-1URL\s0 or relative path of a JavaScript file to pull in. This option is
not set by default.
.SS "html_doctype"
.IX Subsection "html_doctype"
A document type tag for the file. This option is not set by default.
.SS "html_charset"
.IX Subsection "html_charset"
The charater set to declare in the Content-Type meta tag created by default
for \f(CW\*(C`html_header_tags\*(C'\fR. Note that this option will be ignored if the value of
\&\f(CW\*(C`html_header_tags\*(C'\fR is changed. Defaults to \*(L"\s-1ISO\-8859\-1\*(R".\s0
.SS "html_header_tags"
.IX Subsection "html_header_tags"
Additional arbitrary \s-1HTML\s0 tags for the header of the document. The
default value is just a content type header tag:
.PP
.Vb 1
\&  <meta http\-equiv="Content\-Type" content="text/html; charset=ISO\-8859\-1">
.Ve
.PP
Add additional meta tags here, or blocks of inline \s-1CSS\s0 or JavaScript
(wrapped in the appropriate tags).
.PP
\fIhtml_encode_chars\fR
.IX Subsection "html_encode_chars"
.PP
A string containing all characters that should be encoded as \s-1HTML\s0 entities,
specified using the regular expression character class syntax (what you find
within brackets in regular expressions). This value will be passed as the
second argument to the \f(CW\*(C`encode_entities\*(C'\fR function of HTML::Entities. If
HTML::Entities is not installed, then any characters other than \f(CW\*(C`&<\*(C'\fR"'>
will be encoded numerically.
.SS "html_h_level"
.IX Subsection "html_h_level"
This is the level of \s-1HTML \s0\*(L"Hn\*(R" element to which a Pod \*(L"head1\*(R" corresponds.  For
example, if \f(CW\*(C`html_h_level\*(C'\fR is set to 2, a head1 will produce an H2, a head2
will produce an H3, and so on.
.SS "default_title"
.IX Subsection "default_title"
Set a default title for the page if no title can be determined from the
content. The value of this string should already be &\-escaped.
.SS "force_title"
.IX Subsection "force_title"
Force a title for the page (don't try to determine it from the content).
The value of this string should already be &\-escaped.
.SS "html_header, html_footer"
.IX Subsection "html_header, html_footer"
Set the \s-1HTML\s0 output at the beginning and end of each file. The default
header includes a title, a doctype tag (if \f(CW\*(C`html_doctype\*(C'\fR is set), a
content tag (customized by \f(CW\*(C`html_header_tags\*(C'\fR), a tag for a \s-1CSS\s0 file
(if \f(CW\*(C`html_css\*(C'\fR is set), and a tag for a Javascript file (if
\&\f(CW\*(C`html_javascript\*(C'\fR is set). The default footer simply closes the \f(CW\*(C`html\*(C'\fR
and \f(CW\*(C`body\*(C'\fR tags.
.PP
The options listed above customize parts of the default header, but
setting \f(CW\*(C`html_header\*(C'\fR or \f(CW\*(C`html_footer\*(C'\fR completely overrides the
built-in header or footer. These may be useful if you want to use
template tags instead of literal \s-1HTML\s0 headers and footers or are
integrating converted \s-1POD\s0 pages in a larger website.
.PP
If you want no headers or footers output in the \s-1HTML,\s0 set these options
to the empty string.
.SS "index"
.IX Subsection "index"
Whether to add a table-of-contents at the top of each page (called an
index for the sake of tradition).
.SS "anchor_items"
.IX Subsection "anchor_items"
Whether to anchor every definition \f(CW\*(C`=item\*(C'\fR directive. This needs to be
enabled if you want to be able to link to specific \f(CW\*(C`=item\*(C'\fR directives, which
are output as \f(CW\*(C`<dt>\*(C'\fR elements. Disabled by default.
.SS "backlink"
.IX Subsection "backlink"
Whether to turn every =head1 directive into a link pointing to the top 
of the page (specifically, the opening body tag).
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
If the standard options aren't enough, you may want to subclass
Pod::Simple::XHMTL. These are the most likely candidates for methods
you'll want to override when subclassing.
.SS "handle_text"
.IX Subsection "handle_text"
This method handles the body of text within any element: it's the body
of a paragraph, or everything between a \*(L"=begin\*(R" tag and the
corresponding \*(L"=end\*(R" tag, or the text within an L entity, etc. You would
want to override this if you are adding a custom element type that does
more than just display formatted text. Perhaps adding a way to generate
\&\s-1HTML\s0 tables from an extended version of \s-1POD.\s0
.PP
So, let's say you want to add a custom element called 'foo'. In your
subclass's \f(CW\*(C`new\*(C'\fR method, after calling \f(CW\*(C`SUPER::new\*(C'\fR you'd call:
.PP
.Vb 1
\&  $new\->accept_targets_as_text( \*(Aqfoo\*(Aq );
.Ve
.PP
Then override the \f(CW\*(C`start_for\*(C'\fR method in the subclass to check for when
\&\*(L"$flags\->{'target'}\*(R" is equal to 'foo' and set a flag that marks that
you're in a foo block (maybe \*(L"$self\->{'in_foo'} = 1\*(R"). Then override the
\&\f(CW\*(C`handle_text\*(C'\fR method to check for the flag, and pass \f(CW$text\fR to your
custom subroutine to construct the \s-1HTML\s0 output for 'foo' elements,
something like:
.PP
.Vb 8
\&  sub handle_text {
\&      my ($self, $text) = @_;
\&      if ($self\->{\*(Aqin_foo\*(Aq}) {
\&          $self\->{\*(Aqscratch\*(Aq} .= build_foo_html($text);
\&          return;
\&      }
\&      $self\->SUPER::handle_text($text);
\&  }
.Ve
.SS "handle_code"
.IX Subsection "handle_code"
This method handles the body of text that is marked up to be code.
You might for instance override this to plug in a syntax highlighter.
The base implementation just escapes the text.
.PP
The callback methods \f(CW\*(C`start_code\*(C'\fR and \f(CW\*(C`end_code\*(C'\fR emits the \f(CW\*(C`code\*(C'\fR tags
before and after \f(CW\*(C`handle_code\*(C'\fR is invoked, so you might want to override these
together with \f(CW\*(C`handle_code\*(C'\fR if this wrapping isn't suiteable.
.PP
Note that the code might be broken into mulitple segments if there are
nested formatting codes inside a \f(CW\*(C`C<...>\*(C'\fR sequence.  In between the
calls to \f(CW\*(C`handle_code\*(C'\fR other markup tags might have been emitted in that
case.  The same is true for verbatim sections if the \f(CW\*(C`codes_in_verbatim\*(C'\fR
option is turned on.
.SS "accept_targets_as_html"
.IX Subsection "accept_targets_as_html"
This method behaves like \f(CW\*(C`accept_targets_as_text\*(C'\fR, but also marks the region
as one whose content should be emitted literally, without \s-1HTML\s0 entity escaping
or wrapping in a \f(CW\*(C`div\*(C'\fR element.
.SS "resolve_pod_page_link"
.IX Subsection "resolve_pod_page_link"
.Vb 3
\&  my $url = $pod\->resolve_pod_page_link(\*(AqNet::Ping\*(Aq, \*(AqINSTALL\*(Aq);
\&  my $url = $pod\->resolve_pod_page_link(\*(Aqperlpodspec\*(Aq);
\&  my $url = $pod\->resolve_pod_page_link(undef, \*(AqSYNOPSIS\*(Aq);
.Ve
.PP
Resolves a \s-1POD\s0 link target (typically a module or \s-1POD\s0 file name) and section
name to a \s-1URL.\s0 The resulting link will be returned for the above examples as:
.PP
.Vb 3
\&  http://search.cpan.org/perldoc?Net::Ping#INSTALL
\&  http://search.cpan.org/perldoc?perlpodspec
\&  #SYNOPSIS
.Ve
.PP
Note that when there is only a section argument the \s-1URL\s0 will simply be a link
to a section in the current document.
.SS "resolve_man_page_link"
.IX Subsection "resolve_man_page_link"
.Vb 2
\&  my $url = $pod\->resolve_man_page_link(\*(Aqcrontab(5)\*(Aq, \*(AqEXAMPLE CRON FILE\*(Aq);
\&  my $url = $pod\->resolve_man_page_link(\*(Aqcrontab\*(Aq);
.Ve
.PP
Resolves a man page link target and numeric section to a \s-1URL.\s0 The resulting
link will be returned for the above examples as:
.PP
.Vb 2
\&    http://man.he.net/man5/crontab
\&    http://man.he.net/man1/crontab
.Ve
.PP
Note that the first argument is required. The section number will be parsed
from it, and if it's missing will default to 1. The second argument is
currently ignored, as man.he.net <http://man.he.net> does not currently
include linkable IDs or anchor names in its pages. Subclass to link to a
different man page \s-1HTTP\s0 server.
.SS "idify"
.IX Subsection "idify"
.Vb 2
\&  my $id   = $pod\->idify($text);
\&  my $hash = $pod\->idify($text, 1);
.Ve
.PP
This method turns an arbitrary string into a valid \s-1XHTML ID\s0 attribute value.
The rules enforced, following
<http://webdesign.about.com/od/htmltags/a/aa031707.htm>, are:
.IP "\(bu" 4
The id must start with a letter (a\-z or A\-Z)
.IP "\(bu" 4
All subsequent characters can be letters, numbers (0\-9), hyphens (\-),
underscores (_), colons (:), and periods (.).
.IP "\(bu" 4
The final character can't be a hyphen, colon, or period. URLs ending with these
characters, while allowed by \s-1XHTML,\s0 can be awkward to extract from plain text.
.IP "\(bu" 4
Each id must be unique within the document.
.PP
In addition, the returned value will be unique within the context of the
Pod::Simple::XHTML object unless a second argument is passed a true value. \s-1ID\s0
attributes should always be unique within a single \s-1XHTML\s0 document, but pass
the true value if you are creating not an \s-1ID\s0 but a \s-1URL\s0 hash to point to
an \s-1ID \s0(i.e., if you need to put the \*(L"#foo\*(R" in \f(CW\*(C`<a href="#foo">foo</a>\*(C'\fR.
.SS "batch_mode_page_object_init"
.IX Subsection "batch_mode_page_object_init"
.Vb 1
\&  $pod\->batch_mode_page_object_init($batchconvobj, $module, $infile, $outfile, $depth);
.Ve
.PP
Called by Pod::Simple::HTMLBatch so that the class has a chance to
initialize the converter. Internally it sets the \f(CW\*(C`batch_mode\*(C'\fR property to
true and sets \f(CW\*(C`batch_mode_current_level()\*(C'\fR, but Pod::Simple::XHTML does not
currently use those features. Subclasses might, though.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple, Pod::Simple::Text, Pod::Spell
.SH "SUPPORT"
.IX Header "SUPPORT"
Questions or discussion about \s-1POD\s0 and Pod::Simple should be sent to the
pod\-people@perl.org mail list. Send an empty email to
pod\-people\-subscribe@perl.org to subscribe.
.PP
This module is managed in an open GitHub repository,
<https://github.com/theory/pod\-simple/>. Feel free to fork and contribute, or
to clone <git://github.com/theory/pod\-simple.git> and send patches!
.PP
Patches against Pod::Simple are welcome. Please send bug reports to
<bug\-pod\-simple@rt.cpan.org>.
.SH "COPYRIGHT AND DISCLAIMERS"
.IX Header "COPYRIGHT AND DISCLAIMERS"
Copyright (c) 2003\-2005 Allison Randal.
.PP
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Hurricane Electric <http://he.net/> for permission to use its
Linux man pages online <http://man.he.net/> site for man page links.
.PP
Thanks to search.cpan.org <http://search.cpan.org/> for permission to use the
site for Perl module links.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pod::Simpele::XHTML was created by Allison Randal <allison@perl.org>.
.PP
Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
But don't bother him, he's retired.
.PP
Pod::Simple is maintained by:
.IP "\(bu" 4
Allison Randal \f(CW\*(C`allison@perl.org\*(C'\fR
.IP "\(bu" 4
Hans Dieter Pearcey \f(CW\*(C`hdp@cpan.org\*(C'\fR
.IP "\(bu" 4
David E. Wheeler \f(CW\*(C`dwheeler@cpan.org\*(C'\fR
                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Simple::XMLOutStream.3pm                0100644 0001750 0001750 00000015241 12566207462 025777  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Simple::XMLOutStream 3pm"
.TH Pod::Simple::XMLOutStream 3pm "2013-11-14" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Simple::XMLOutStream \-\- turn Pod into XML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  perl \-MPod::Simple::XMLOutStream \-e \e
\&   "exit Pod::Simple::XMLOutStream\->filter(shift)\->any_errata_seen" \e
\&   thingy.pod
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Simple::XMLOutStream is a subclass of Pod::Simple that parses
Pod and turns it into \s-1XML.\s0
.PP
Pod::Simple::XMLOutStream inherits methods from
Pod::Simple.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple::DumpAsXML is rather like this class; see its
documentation for a discussion of the differences.
.PP
Pod::Simple, Pod::Simple::DumpAsXML, Pod::SAX
.PP
Pod::Simple::Subclassing
.PP
The older (and possibly obsolete) libraries Pod::PXML, Pod::XML
.SH "ABOUT EXTENDING POD"
.IX Header "ABOUT EXTENDING POD"
\&\s-1TODO:\s0 An example or two of =extend, then point to Pod::Simple::Subclassing
.SH "ASK ME!"
.IX Header "ASK ME!"
If you actually want to use Pod as a format that you want to render to
\&\s-1XML \s0(particularly if to an \s-1XML\s0 instance with more elements than normal
Pod has), please email me (\f(CW\*(C`sburke@cpan.org\*(C'\fR) and I'll probably have
some recommendations.
.PP
For reasons of concision and energetic laziness, some methods and
options in this module (and the dozen modules it depends on) are
undocumented; but one of those undocumented bits might be just what
you're looking for.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple, Pod::Simple::Text, Pod::Spell
.SH "SUPPORT"
.IX Header "SUPPORT"
Questions or discussion about \s-1POD\s0 and Pod::Simple should be sent to the
pod\-people@perl.org mail list. Send an empty email to
pod\-people\-subscribe@perl.org to subscribe.
.PP
This module is managed in an open GitHub repository,
<https://github.com/theory/pod\-simple/>. Feel free to fork and contribute, or
to clone <git://github.com/theory/pod\-simple.git> and send patches!
.PP
Patches against Pod::Simple are welcome. Please send bug reports to
<bug\-pod\-simple@rt.cpan.org>.
.SH "COPYRIGHT AND DISCLAIMERS"
.IX Header "COPYRIGHT AND DISCLAIMERS"
Copyright (c) 2002\-2004 Sean M. Burke.
.PP
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
But don't bother him, he's retired.
.PP
Pod::Simple is maintained by:
.IP "\(bu" 4
Allison Randal \f(CW\*(C`allison@perl.org\*(C'\fR
.IP "\(bu" 4
Hans Dieter Pearcey \f(CW\*(C`hdp@cpan.org\*(C'\fR
.IP "\(bu" 4
David E. Wheeler \f(CW\*(C`dwheeler@cpan.org\*(C'\fR
                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Simple::XMLOutStream5.16.3pm            0100644 0001750 0001750 00000015033 12566207440 026304  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Simple::XMLOutStream 3pm"
.TH Pod::Simple::XMLOutStream 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Simple::XMLOutStream \-\- turn Pod into XML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  perl \-MPod::Simple::XMLOutStream \-e \e
\&   "exit Pod::Simple::XMLOutStream\->filter(shift)\->any_errata_seen" \e
\&   thingy.pod
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Simple::XMLOutStream is a subclass of Pod::Simple that parses
Pod and turns it into \s-1XML\s0.
.PP
Pod::Simple::XMLOutStream inherits methods from
Pod::Simple.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple::DumpAsXML is rather like this class; see its
documentation for a discussion of the differences.
.PP
Pod::Simple, Pod::Simple::DumpAsXML, Pod::SAX
.PP
Pod::Simple::Subclassing
.PP
The older (and possibly obsolete) libraries Pod::PXML, Pod::XML
.SH "ABOUT EXTENDING POD"
.IX Header "ABOUT EXTENDING POD"
\&\s-1TODO:\s0 An example or two of =extend, then point to Pod::Simple::Subclassing
.SH "ASK ME!"
.IX Header "ASK ME!"
If you actually want to use Pod as a format that you want to render to
\&\s-1XML\s0 (particularly if to an \s-1XML\s0 instance with more elements than normal
Pod has), please email me (\f(CW\*(C`sburke@cpan.org\*(C'\fR) and I'll probably have
some recommendations.
.PP
For reasons of concision and energetic laziness, some methods and
options in this module (and the dozen modules it depends on) are
undocumented; but one of those undocumented bits might be just what
you're looking for.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple, Pod::Simple::Text, Pod::Spell
.SH "SUPPORT"
.IX Header "SUPPORT"
Questions or discussion about \s-1POD\s0 and Pod::Simple should be sent to the
pod\-people@perl.org mail list. Send an empty email to
pod\-people\-subscribe@perl.org to subscribe.
.PP
This module is managed in an open GitHub repository,
http://github.com/theory/pod\-simple/ <http://github.com/theory/pod-simple/>. Feel free to fork and contribute, or
to clone git://github.com/theory/pod\-simple.git <git://github.com/theory/pod-simple.git> and send patches!
.PP
Patches against Pod::Simple are welcome. Please send bug reports to
<bug\-pod\-simple@rt.cpan.org>.
.SH "COPYRIGHT AND DISCLAIMERS"
.IX Header "COPYRIGHT AND DISCLAIMERS"
Copyright (c) 2002\-2004 Sean M. Burke.
.PP
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
But don't bother him, he's retired.
.PP
Pod::Simple is maintained by:
.IP "\(bu" 4
Allison Randal \f(CW\*(C`allison@perl.org\*(C'\fR
.IP "\(bu" 4
Hans Dieter Pearcey \f(CW\*(C`hdp@cpan.org\*(C'\fR
.IP "\(bu" 4
David E. Wheeler \f(CW\*(C`dwheeler@cpan.org\*(C'\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Simple::XMLOutStream5.18.3pm            0100644 0001750 0001750 00000015241 12566207462 026313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Simple::XMLOutStream 3pm"
.TH Pod::Simple::XMLOutStream 3pm "2013-11-14" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Simple::XMLOutStream \-\- turn Pod into XML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  perl \-MPod::Simple::XMLOutStream \-e \e
\&   "exit Pod::Simple::XMLOutStream\->filter(shift)\->any_errata_seen" \e
\&   thingy.pod
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Simple::XMLOutStream is a subclass of Pod::Simple that parses
Pod and turns it into \s-1XML.\s0
.PP
Pod::Simple::XMLOutStream inherits methods from
Pod::Simple.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple::DumpAsXML is rather like this class; see its
documentation for a discussion of the differences.
.PP
Pod::Simple, Pod::Simple::DumpAsXML, Pod::SAX
.PP
Pod::Simple::Subclassing
.PP
The older (and possibly obsolete) libraries Pod::PXML, Pod::XML
.SH "ABOUT EXTENDING POD"
.IX Header "ABOUT EXTENDING POD"
\&\s-1TODO:\s0 An example or two of =extend, then point to Pod::Simple::Subclassing
.SH "ASK ME!"
.IX Header "ASK ME!"
If you actually want to use Pod as a format that you want to render to
\&\s-1XML \s0(particularly if to an \s-1XML\s0 instance with more elements than normal
Pod has), please email me (\f(CW\*(C`sburke@cpan.org\*(C'\fR) and I'll probably have
some recommendations.
.PP
For reasons of concision and energetic laziness, some methods and
options in this module (and the dozen modules it depends on) are
undocumented; but one of those undocumented bits might be just what
you're looking for.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple, Pod::Simple::Text, Pod::Spell
.SH "SUPPORT"
.IX Header "SUPPORT"
Questions or discussion about \s-1POD\s0 and Pod::Simple should be sent to the
pod\-people@perl.org mail list. Send an empty email to
pod\-people\-subscribe@perl.org to subscribe.
.PP
This module is managed in an open GitHub repository,
<https://github.com/theory/pod\-simple/>. Feel free to fork and contribute, or
to clone <git://github.com/theory/pod\-simple.git> and send patches!
.PP
Patches against Pod::Simple are welcome. Please send bug reports to
<bug\-pod\-simple@rt.cpan.org>.
.SH "COPYRIGHT AND DISCLAIMERS"
.IX Header "COPYRIGHT AND DISCLAIMERS"
Copyright (c) 2002\-2004 Sean M. Burke.
.PP
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
But don't bother him, he's retired.
.PP
Pod::Simple is maintained by:
.IP "\(bu" 4
Allison Randal \f(CW\*(C`allison@perl.org\*(C'\fR
.IP "\(bu" 4
Hans Dieter Pearcey \f(CW\*(C`hdp@cpan.org\*(C'\fR
.IP "\(bu" 4
David E. Wheeler \f(CW\*(C`dwheeler@cpan.org\*(C'\fR
                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text.3pm                                0100644 0001750 0001750 00000032725 12566207462 023067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text 3pm"
.TH Pod::Text 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text \- Convert POD data to formatted ASCII text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text;
\&    my $parser = Pod::Text\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text is a module that can convert documentation in the \s-1POD\s0 format (the
preferred language for documenting Perl) into formatted \s-1ASCII. \s0 It uses no
special formatting controls or codes whatsoever, and its output is therefore
suitable for nearly any device.
.PP
As a derived class from Pod::Simple, Pod::Text supports the same methods and
interfaces.  See Pod::Simple for all the details; briefly, one creates a
new parser with \f(CW\*(C`Pod::Text\->new()\*(C'\fR and then normally calls \fIparse_file()\fR.
.PP
\&\fInew()\fR can take options, in the form of key/value pairs, that control the
behavior of the parser.  The currently recognized options are:
.IP "alt" 4
.IX Item "alt"
If set to a true value, selects an alternate output format that, among other
things, uses a different heading style and marks \f(CW\*(C`=item\*(C'\fR entries with a
colon in the left margin.  Defaults to false.
.IP "code" 4
.IX Item "code"
If set to a true value, the non-POD parts of the input file will be included
in the output.  Useful for viewing code documented with \s-1POD\s0 blocks with the
\&\s-1POD\s0 rendered and the code left intact.
.IP "errors" 4
.IX Item "errors"
How to report errors.  \f(CW\*(C`die\*(C'\fR says to throw an exception on any \s-1POD\s0
formatting error.  \f(CW\*(C`stderr\*(C'\fR says to report errors on standard error, but
not to throw an exception.  \f(CW\*(C`pod\*(C'\fR says to include a \s-1POD ERRORS\s0 section
in the resulting documentation summarizing the errors.  \f(CW\*(C`none\*(C'\fR ignores
\&\s-1POD\s0 errors entirely, as much as possible.
.Sp
The default is \f(CW\*(C`output\*(C'\fR.
.IP "indent" 4
.IX Item "indent"
The number of spaces to indent regular text, and the default indentation for
\&\f(CW\*(C`=over\*(C'\fR blocks.  Defaults to 4.
.IP "loose" 4
.IX Item "loose"
If set to a true value, a blank line is printed after a \f(CW\*(C`=head1\*(C'\fR heading.
If set to false (the default), no blank line is printed after \f(CW\*(C`=head1\*(C'\fR,
although one is still printed after \f(CW\*(C`=head2\*(C'\fR.  This is the default because
it's the expected formatting for manual pages; if you're formatting
arbitrary text documents, setting this to true may result in more pleasing
output.
.IP "margin" 4
.IX Item "margin"
The width of the left margin in spaces.  Defaults to 0.  This is the margin
for all text, including headings, not the amount by which regular text is
indented; for the latter, see the \fIindent\fR option.  To set the right
margin, see the \fIwidth\fR option.
.IP "nourls" 4
.IX Item "nourls"
Normally, L<> formatting codes with a \s-1URL\s0 but anchor text are formatted
to show both the anchor text and the \s-1URL. \s0 In other words:
.Sp
.Vb 1
\&    L<foo|http://example.com/>
.Ve
.Sp
is formatted as:
.Sp
.Vb 1
\&    foo <http://example.com/>
.Ve
.Sp
This option, if set to a true value, suppresses the \s-1URL\s0 when anchor text
is given, so this example would be formatted as just \f(CW\*(C`foo\*(C'\fR.  This can
produce less cluttered output in cases where the URLs are not particularly
important.
.IP "quotes" 4
.IX Item "quotes"
Sets the quote marks used to surround C<> text.  If the value is a
single character, it is used as both the left and right quote; if it is two
characters, the first character is used as the left quote and the second as
the right quoted; and if it is four characters, the first two are used as
the left quote and the second two as the right quote.
.Sp
This may also be set to the special value \f(CW\*(C`none\*(C'\fR, in which case no quote
marks are added around C<> text.
.IP "sentence" 4
.IX Item "sentence"
If set to a true value, Pod::Text will assume that each sentence ends in two
spaces, and will try to preserve that spacing.  If set to false, all
consecutive whitespace in non-verbatim paragraphs is compressed into a
single space.  Defaults to true.
.IP "stderr" 4
.IX Item "stderr"
Send error messages about invalid \s-1POD\s0 to standard error instead of
appending a \s-1POD ERRORS\s0 section to the generated output.  This is
equivalent to setting \f(CW\*(C`errors\*(C'\fR to \f(CW\*(C`stderr\*(C'\fR if \f(CW\*(C`errors\*(C'\fR is not already
set.  It is supported for backward compatibility.
.IP "utf8" 4
.IX Item "utf8"
By default, Pod::Text uses the same output encoding as the input encoding
of the \s-1POD\s0 source (provided that Perl was built with PerlIO; otherwise, it
doesn't encode its output).  If this option is given, the output encoding
is forced to \s-1UTF\-8.\s0
.Sp
Be aware that, when using this option, the input encoding of your \s-1POD\s0
source must be properly declared unless it is US-ASCII or Latin\-1.  \s-1POD\s0
input without an \f(CW\*(C`=encoding\*(C'\fR command will be assumed to be in Latin\-1,
and if it's actually in \s-1UTF\-8,\s0 the output will be double-encoded.  See
\&\fIperlpod\fR\|(1) for more information on the \f(CW\*(C`=encoding\*(C'\fR command.
.IP "width" 4
.IX Item "width"
The column at which to wrap text on the right-hand side.  Defaults to 76.
.PP
The standard Pod::Simple method \fIparse_file()\fR takes one argument, the file or
file handle to read from, and writes output to standard output unless that
has been changed with the \fIoutput_fh()\fR method.  See Pod::Simple for the
specific details and for other alternative interfaces.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Bizarre space in item" 4
.IX Item "Bizarre space in item"
.PD 0
.IP "Item called without tag" 4
.IX Item "Item called without tag"
.PD
(W) Something has gone wrong in internal \f(CW\*(C`=item\*(C'\fR processing.  These
messages indicate a bug in Pod::Text; you should never see them.
.ie n .IP "Can't open %s for reading: %s" 4
.el .IP "Can't open \f(CW%s\fR for reading: \f(CW%s\fR" 4
.IX Item "Can't open %s for reading: %s"
(F) Pod::Text was invoked via the compatibility mode \fIpod2text()\fR interface
and the input file it was given could not be opened.
.ie n .IP "Invalid errors setting ""%s""" 4
.el .IP "Invalid errors setting ``%s''" 4
.IX Item "Invalid errors setting %s"
(F) The \f(CW\*(C`errors\*(C'\fR parameter to the constructor was set to an unknown value.
.ie n .IP "Invalid quote specification ""%s""" 4
.el .IP "Invalid quote specification ``%s''" 4
.IX Item "Invalid quote specification %s"
(F) The quote specification given (the \f(CW\*(C`quotes\*(C'\fR option to the
constructor) was invalid.  A quote specification must be one, two, or four
characters long.
.IP "\s-1POD\s0 document had syntax errors" 4
.IX Item "POD document had syntax errors"
(F) The \s-1POD\s0 document being formatted had syntax errors and the \f(CW\*(C`errors\*(C'\fR
option was set to \f(CW\*(C`die\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
Encoding handling assumes that PerlIO is available and does not work
properly if it isn't.  The \f(CW\*(C`utf8\*(C'\fR option is therefore not supported
unless Perl is built with PerlIO support.
.SH "CAVEATS"
.IX Header "CAVEATS"
If Pod::Text is given the \f(CW\*(C`utf8\*(C'\fR option, the encoding of its output file
handle will be forced to \s-1UTF\-8\s0 if possible, overriding any existing
encoding.  This will be done even if the file handle is not created by
Pod::Text and was passed in from outside.  This maintains consistency
regardless of \s-1PERL_UNICODE\s0 and other settings.
.PP
If the \f(CW\*(C`utf8\*(C'\fR option is not given, the encoding of its output file handle
will be forced to the detected encoding of the input \s-1POD,\s0 which preserves
whatever the input text is.  This ensures backward compatibility with
earlier, pre-Unicode versions of this module, without large numbers of
Perl warnings.
.PP
This is not ideal, but it seems to be the best compromise.  If it doesn't
work for you, please let me know the details of how it broke.
.SH "NOTES"
.IX Header "NOTES"
This is a replacement for an earlier Pod::Text module written by Tom
Christiansen.  It has a revamped interface, since it now uses Pod::Simple,
but an interface roughly compatible with the old \fIPod::Text::pod2text()\fR
function is still available.  Please change to the new calling convention,
though.
.PP
The original Pod::Text contained code to do formatting via termcap
sequences, although it wasn't turned on by default and it was problematic to
get it to work at all.  This rewrite doesn't even try to do that, but a
subclass of it does.  Look for Pod::Text::Termcap.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple, Pod::Text::Termcap, \fIperlpod\fR\|(1), \fIpod2text\fR\|(1)
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>, based \fIvery\fR heavily on the original
Pod::Text by Tom Christiansen <tchrist@mox.perl.com> and its conversion to
Pod::Parser by Brad Appleton <bradapp@enteract.com>.  Sean Burke's initial
conversion of Pod::Man to use Pod::Simple provided much-needed guidance on
how to use Pod::Simple.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2000, 2001, 2002, 2004, 2006, 2008, 2009, 2012, 2013 Russ
Allbery <rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text5.16.3pm                            0100644 0001750 0001750 00000027171 12566207440 023374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text 3pm"
.TH Pod::Text 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text \- Convert POD data to formatted ASCII text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text;
\&    my $parser = Pod::Text\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text is a module that can convert documentation in the \s-1POD\s0 format (the
preferred language for documenting Perl) into formatted \s-1ASCII\s0.  It uses no
special formatting controls or codes whatsoever, and its output is therefore
suitable for nearly any device.
.PP
As a derived class from Pod::Simple, Pod::Text supports the same methods and
interfaces.  See Pod::Simple for all the details; briefly, one creates a
new parser with \f(CW\*(C`Pod::Text\->new()\*(C'\fR and then normally calls \fIparse_file()\fR.
.PP
\&\fInew()\fR can take options, in the form of key/value pairs, that control the
behavior of the parser.  The currently recognized options are:
.IP "alt" 4
.IX Item "alt"
If set to a true value, selects an alternate output format that, among other
things, uses a different heading style and marks \f(CW\*(C`=item\*(C'\fR entries with a
colon in the left margin.  Defaults to false.
.IP "code" 4
.IX Item "code"
If set to a true value, the non-POD parts of the input file will be included
in the output.  Useful for viewing code documented with \s-1POD\s0 blocks with the
\&\s-1POD\s0 rendered and the code left intact.
.IP "indent" 4
.IX Item "indent"
The number of spaces to indent regular text, and the default indentation for
\&\f(CW\*(C`=over\*(C'\fR blocks.  Defaults to 4.
.IP "loose" 4
.IX Item "loose"
If set to a true value, a blank line is printed after a \f(CW\*(C`=head1\*(C'\fR heading.
If set to false (the default), no blank line is printed after \f(CW\*(C`=head1\*(C'\fR,
although one is still printed after \f(CW\*(C`=head2\*(C'\fR.  This is the default because
it's the expected formatting for manual pages; if you're formatting
arbitrary text documents, setting this to true may result in more pleasing
output.
.IP "margin" 4
.IX Item "margin"
The width of the left margin in spaces.  Defaults to 0.  This is the margin
for all text, including headings, not the amount by which regular text is
indented; for the latter, see the \fIindent\fR option.  To set the right
margin, see the \fIwidth\fR option.
.IP "quotes" 4
.IX Item "quotes"
Sets the quote marks used to surround C<> text.  If the value is a
single character, it is used as both the left and right quote; if it is two
characters, the first character is used as the left quote and the second as
the right quoted; and if it is four characters, the first two are used as
the left quote and the second two as the right quote.
.Sp
This may also be set to the special value \f(CW\*(C`none\*(C'\fR, in which case no quote
marks are added around C<> text.
.IP "sentence" 4
.IX Item "sentence"
If set to a true value, Pod::Text will assume that each sentence ends in two
spaces, and will try to preserve that spacing.  If set to false, all
consecutive whitespace in non-verbatim paragraphs is compressed into a
single space.  Defaults to true.
.IP "stderr" 4
.IX Item "stderr"
Send error messages about invalid \s-1POD\s0 to standard error instead of
appending a \s-1POD\s0 \s-1ERRORS\s0 section to the generated output.
.IP "utf8" 4
.IX Item "utf8"
By default, Pod::Text uses the same output encoding as the input encoding
of the \s-1POD\s0 source (provided that Perl was built with PerlIO; otherwise, it
doesn't encode its output).  If this option is given, the output encoding
is forced to \s-1UTF\-8\s0.
.Sp
Be aware that, when using this option, the input encoding of your \s-1POD\s0
source must be properly declared unless it is US-ASCII or Latin\-1.  \s-1POD\s0
input without an \f(CW\*(C`=encoding\*(C'\fR command will be assumed to be in Latin\-1,
and if it's actually in \s-1UTF\-8\s0, the output will be double-encoded.  See
\&\fIperlpod\fR\|(1) for more information on the \f(CW\*(C`=encoding\*(C'\fR command.
.IP "width" 4
.IX Item "width"
The column at which to wrap text on the right-hand side.  Defaults to 76.
.PP
The standard Pod::Simple method \fIparse_file()\fR takes one argument, the file or
file handle to read from, and writes output to standard output unless that
has been changed with the \fIoutput_fh()\fR method.  See Pod::Simple for the
specific details and for other alternative interfaces.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Bizarre space in item" 4
.IX Item "Bizarre space in item"
.PD 0
.IP "Item called without tag" 4
.IX Item "Item called without tag"
.PD
(W) Something has gone wrong in internal \f(CW\*(C`=item\*(C'\fR processing.  These
messages indicate a bug in Pod::Text; you should never see them.
.ie n .IP "Can't open %s for reading: %s" 4
.el .IP "Can't open \f(CW%s\fR for reading: \f(CW%s\fR" 4
.IX Item "Can't open %s for reading: %s"
(F) Pod::Text was invoked via the compatibility mode \fIpod2text()\fR interface
and the input file it was given could not be opened.
.ie n .IP "Invalid quote specification ""%s""" 4
.el .IP "Invalid quote specification ``%s''" 4
.IX Item "Invalid quote specification %s"
(F) The quote specification given (the quotes option to the constructor) was
invalid.  A quote specification must be one, two, or four characters long.
.SH "BUGS"
.IX Header "BUGS"
Encoding handling assumes that PerlIO is available and does not work
properly if it isn't.  The \f(CW\*(C`utf8\*(C'\fR option is therefore not supported
unless Perl is built with PerlIO support.
.SH "CAVEATS"
.IX Header "CAVEATS"
If Pod::Text is given the \f(CW\*(C`utf8\*(C'\fR option, the encoding of its output file
handle will be forced to \s-1UTF\-8\s0 if possible, overriding any existing
encoding.  This will be done even if the file handle is not created by
Pod::Text and was passed in from outside.  This maintains consistency
regardless of \s-1PERL_UNICODE\s0 and other settings.
.PP
If the \f(CW\*(C`utf8\*(C'\fR option is not given, the encoding of its output file handle
will be forced to the detected encoding of the input \s-1POD\s0, which preserves
whatever the input text is.  This ensures backward compatibility with
earlier, pre-Unicode versions of this module, without large numbers of
Perl warnings.
.PP
This is not ideal, but it seems to be the best compromise.  If it doesn't
work for you, please let me know the details of how it broke.
.SH "NOTES"
.IX Header "NOTES"
This is a replacement for an earlier Pod::Text module written by Tom
Christiansen.  It has a revamped interface, since it now uses Pod::Simple,
but an interface roughly compatible with the old \fIPod::Text::pod2text()\fR
function is still available.  Please change to the new calling convention,
though.
.PP
The original Pod::Text contained code to do formatting via termcap
sequences, although it wasn't turned on by default and it was problematic to
get it to work at all.  This rewrite doesn't even try to do that, but a
subclass of it does.  Look for Pod::Text::Termcap.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple, Pod::Text::Termcap, \fIperlpod\fR\|(1), \fIpod2text\fR\|(1)
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>, based \fIvery\fR heavily on the original
Pod::Text by Tom Christiansen <tchrist@mox.perl.com> and its conversion to
Pod::Parser by Brad Appleton <bradapp@enteract.com>.  Sean Burke's initial
conversion of Pod::Man to use Pod::Simple provided much-needed guidance on
how to use Pod::Simple.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2000, 2001, 2002, 2004, 2006, 2008, 2009 Russ Allbery
<rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text5.18.3pm                            0100644 0001750 0001750 00000032725 12566207462 023403  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text 3pm"
.TH Pod::Text 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text \- Convert POD data to formatted ASCII text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text;
\&    my $parser = Pod::Text\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text is a module that can convert documentation in the \s-1POD\s0 format (the
preferred language for documenting Perl) into formatted \s-1ASCII. \s0 It uses no
special formatting controls or codes whatsoever, and its output is therefore
suitable for nearly any device.
.PP
As a derived class from Pod::Simple, Pod::Text supports the same methods and
interfaces.  See Pod::Simple for all the details; briefly, one creates a
new parser with \f(CW\*(C`Pod::Text\->new()\*(C'\fR and then normally calls \fIparse_file()\fR.
.PP
\&\fInew()\fR can take options, in the form of key/value pairs, that control the
behavior of the parser.  The currently recognized options are:
.IP "alt" 4
.IX Item "alt"
If set to a true value, selects an alternate output format that, among other
things, uses a different heading style and marks \f(CW\*(C`=item\*(C'\fR entries with a
colon in the left margin.  Defaults to false.
.IP "code" 4
.IX Item "code"
If set to a true value, the non-POD parts of the input file will be included
in the output.  Useful for viewing code documented with \s-1POD\s0 blocks with the
\&\s-1POD\s0 rendered and the code left intact.
.IP "errors" 4
.IX Item "errors"
How to report errors.  \f(CW\*(C`die\*(C'\fR says to throw an exception on any \s-1POD\s0
formatting error.  \f(CW\*(C`stderr\*(C'\fR says to report errors on standard error, but
not to throw an exception.  \f(CW\*(C`pod\*(C'\fR says to include a \s-1POD ERRORS\s0 section
in the resulting documentation summarizing the errors.  \f(CW\*(C`none\*(C'\fR ignores
\&\s-1POD\s0 errors entirely, as much as possible.
.Sp
The default is \f(CW\*(C`output\*(C'\fR.
.IP "indent" 4
.IX Item "indent"
The number of spaces to indent regular text, and the default indentation for
\&\f(CW\*(C`=over\*(C'\fR blocks.  Defaults to 4.
.IP "loose" 4
.IX Item "loose"
If set to a true value, a blank line is printed after a \f(CW\*(C`=head1\*(C'\fR heading.
If set to false (the default), no blank line is printed after \f(CW\*(C`=head1\*(C'\fR,
although one is still printed after \f(CW\*(C`=head2\*(C'\fR.  This is the default because
it's the expected formatting for manual pages; if you're formatting
arbitrary text documents, setting this to true may result in more pleasing
output.
.IP "margin" 4
.IX Item "margin"
The width of the left margin in spaces.  Defaults to 0.  This is the margin
for all text, including headings, not the amount by which regular text is
indented; for the latter, see the \fIindent\fR option.  To set the right
margin, see the \fIwidth\fR option.
.IP "nourls" 4
.IX Item "nourls"
Normally, L<> formatting codes with a \s-1URL\s0 but anchor text are formatted
to show both the anchor text and the \s-1URL. \s0 In other words:
.Sp
.Vb 1
\&    L<foo|http://example.com/>
.Ve
.Sp
is formatted as:
.Sp
.Vb 1
\&    foo <http://example.com/>
.Ve
.Sp
This option, if set to a true value, suppresses the \s-1URL\s0 when anchor text
is given, so this example would be formatted as just \f(CW\*(C`foo\*(C'\fR.  This can
produce less cluttered output in cases where the URLs are not particularly
important.
.IP "quotes" 4
.IX Item "quotes"
Sets the quote marks used to surround C<> text.  If the value is a
single character, it is used as both the left and right quote; if it is two
characters, the first character is used as the left quote and the second as
the right quoted; and if it is four characters, the first two are used as
the left quote and the second two as the right quote.
.Sp
This may also be set to the special value \f(CW\*(C`none\*(C'\fR, in which case no quote
marks are added around C<> text.
.IP "sentence" 4
.IX Item "sentence"
If set to a true value, Pod::Text will assume that each sentence ends in two
spaces, and will try to preserve that spacing.  If set to false, all
consecutive whitespace in non-verbatim paragraphs is compressed into a
single space.  Defaults to true.
.IP "stderr" 4
.IX Item "stderr"
Send error messages about invalid \s-1POD\s0 to standard error instead of
appending a \s-1POD ERRORS\s0 section to the generated output.  This is
equivalent to setting \f(CW\*(C`errors\*(C'\fR to \f(CW\*(C`stderr\*(C'\fR if \f(CW\*(C`errors\*(C'\fR is not already
set.  It is supported for backward compatibility.
.IP "utf8" 4
.IX Item "utf8"
By default, Pod::Text uses the same output encoding as the input encoding
of the \s-1POD\s0 source (provided that Perl was built with PerlIO; otherwise, it
doesn't encode its output).  If this option is given, the output encoding
is forced to \s-1UTF\-8.\s0
.Sp
Be aware that, when using this option, the input encoding of your \s-1POD\s0
source must be properly declared unless it is US-ASCII or Latin\-1.  \s-1POD\s0
input without an \f(CW\*(C`=encoding\*(C'\fR command will be assumed to be in Latin\-1,
and if it's actually in \s-1UTF\-8,\s0 the output will be double-encoded.  See
\&\fIperlpod\fR\|(1) for more information on the \f(CW\*(C`=encoding\*(C'\fR command.
.IP "width" 4
.IX Item "width"
The column at which to wrap text on the right-hand side.  Defaults to 76.
.PP
The standard Pod::Simple method \fIparse_file()\fR takes one argument, the file or
file handle to read from, and writes output to standard output unless that
has been changed with the \fIoutput_fh()\fR method.  See Pod::Simple for the
specific details and for other alternative interfaces.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Bizarre space in item" 4
.IX Item "Bizarre space in item"
.PD 0
.IP "Item called without tag" 4
.IX Item "Item called without tag"
.PD
(W) Something has gone wrong in internal \f(CW\*(C`=item\*(C'\fR processing.  These
messages indicate a bug in Pod::Text; you should never see them.
.ie n .IP "Can't open %s for reading: %s" 4
.el .IP "Can't open \f(CW%s\fR for reading: \f(CW%s\fR" 4
.IX Item "Can't open %s for reading: %s"
(F) Pod::Text was invoked via the compatibility mode \fIpod2text()\fR interface
and the input file it was given could not be opened.
.ie n .IP "Invalid errors setting ""%s""" 4
.el .IP "Invalid errors setting ``%s''" 4
.IX Item "Invalid errors setting %s"
(F) The \f(CW\*(C`errors\*(C'\fR parameter to the constructor was set to an unknown value.
.ie n .IP "Invalid quote specification ""%s""" 4
.el .IP "Invalid quote specification ``%s''" 4
.IX Item "Invalid quote specification %s"
(F) The quote specification given (the \f(CW\*(C`quotes\*(C'\fR option to the
constructor) was invalid.  A quote specification must be one, two, or four
characters long.
.IP "\s-1POD\s0 document had syntax errors" 4
.IX Item "POD document had syntax errors"
(F) The \s-1POD\s0 document being formatted had syntax errors and the \f(CW\*(C`errors\*(C'\fR
option was set to \f(CW\*(C`die\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
Encoding handling assumes that PerlIO is available and does not work
properly if it isn't.  The \f(CW\*(C`utf8\*(C'\fR option is therefore not supported
unless Perl is built with PerlIO support.
.SH "CAVEATS"
.IX Header "CAVEATS"
If Pod::Text is given the \f(CW\*(C`utf8\*(C'\fR option, the encoding of its output file
handle will be forced to \s-1UTF\-8\s0 if possible, overriding any existing
encoding.  This will be done even if the file handle is not created by
Pod::Text and was passed in from outside.  This maintains consistency
regardless of \s-1PERL_UNICODE\s0 and other settings.
.PP
If the \f(CW\*(C`utf8\*(C'\fR option is not given, the encoding of its output file handle
will be forced to the detected encoding of the input \s-1POD,\s0 which preserves
whatever the input text is.  This ensures backward compatibility with
earlier, pre-Unicode versions of this module, without large numbers of
Perl warnings.
.PP
This is not ideal, but it seems to be the best compromise.  If it doesn't
work for you, please let me know the details of how it broke.
.SH "NOTES"
.IX Header "NOTES"
This is a replacement for an earlier Pod::Text module written by Tom
Christiansen.  It has a revamped interface, since it now uses Pod::Simple,
but an interface roughly compatible with the old \fIPod::Text::pod2text()\fR
function is still available.  Please change to the new calling convention,
though.
.PP
The original Pod::Text contained code to do formatting via termcap
sequences, although it wasn't turned on by default and it was problematic to
get it to work at all.  This rewrite doesn't even try to do that, but a
subclass of it does.  Look for Pod::Text::Termcap.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple, Pod::Text::Termcap, \fIperlpod\fR\|(1), \fIpod2text\fR\|(1)
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>, based \fIvery\fR heavily on the original
Pod::Text by Tom Christiansen <tchrist@mox.perl.com> and its conversion to
Pod::Parser by Brad Appleton <bradapp@enteract.com>.  Sean Burke's initial
conversion of Pod::Man to use Pod::Simple provided much-needed guidance on
how to use Pod::Simple.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2000, 2001, 2002, 2004, 2006, 2008, 2009, 2012, 2013 Russ
Allbery <rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text::Color.3pm                         0100644 0001750 0001750 00000013004 12566207462 024237  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text::Color 3pm"
.TH Pod::Text::Color 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text::Color \- Convert POD data to formatted color ASCII text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text::Color;
\&    my $parser = Pod::Text::Color\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text::Color is a simple subclass of Pod::Text that highlights output
text using \s-1ANSI\s0 color escape sequences.  Apart from the color, it in all
ways functions like Pod::Text.  See Pod::Text for details and available
options.
.PP
Term::ANSIColor is used to get colors and therefore must be installed to use
this module.
.SH "BUGS"
.IX Header "BUGS"
This is just a basic proof of concept.  It should be seriously expanded to
support configurable coloration via options passed to the constructor, and
\&\fBpod2text\fR should be taught about those.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Text, Pod::Simple
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2001, 2004, 2006, 2008, 2009 Russ Allbery <rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text::Color5.16.3pm                     0100644 0001750 0001750 00000012463 12566207440 024555  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text::Color 3pm"
.TH Pod::Text::Color 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text::Color \- Convert POD data to formatted color ASCII text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text::Color;
\&    my $parser = Pod::Text::Color\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text::Color is a simple subclass of Pod::Text that highlights output
text using \s-1ANSI\s0 color escape sequences.  Apart from the color, it in all
ways functions like Pod::Text.  See Pod::Text for details and available
options.
.PP
Term::ANSIColor is used to get colors and therefore must be installed to use
this module.
.SH "BUGS"
.IX Header "BUGS"
This is just a basic proof of concept.  It should be seriously expanded to
support configurable coloration via options passed to the constructor, and
\&\fBpod2text\fR should be taught about those.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Text, Pod::Simple
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2001, 2004, 2006, 2008, 2009 Russ Allbery <rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text::Color5.18.3pm                     0100644 0001750 0001750 00000013004 12566207462 024553  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text::Color 3pm"
.TH Pod::Text::Color 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text::Color \- Convert POD data to formatted color ASCII text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text::Color;
\&    my $parser = Pod::Text::Color\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text::Color is a simple subclass of Pod::Text that highlights output
text using \s-1ANSI\s0 color escape sequences.  Apart from the color, it in all
ways functions like Pod::Text.  See Pod::Text for details and available
options.
.PP
Term::ANSIColor is used to get colors and therefore must be installed to use
this module.
.SH "BUGS"
.IX Header "BUGS"
This is just a basic proof of concept.  It should be seriously expanded to
support configurable coloration via options passed to the constructor, and
\&\fBpod2text\fR should be taught about those.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Text, Pod::Simple
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2001, 2004, 2006, 2008, 2009 Russ Allbery <rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text::Overstrike.3pm                    0100644 0001750 0001750 00000014054 12566207462 025324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text::Overstrike 3pm"
.TH Pod::Text::Overstrike 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text::Overstrike \- Convert POD data to formatted overstrike text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text::Overstrike;
\&    my $parser = Pod::Text::Overstrike\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text::Overstrike is a simple subclass of Pod::Text that highlights
output text using overstrike sequences, in a manner similar to nroff.
Characters in bold text are overstruck (character, backspace, character)
and characters in underlined text are converted to overstruck underscores
(underscore, backspace, character).  This format was originally designed
for hard-copy terminals and/or line printers, yet is readable on soft-copy
(\s-1CRT\s0) terminals.
.PP
Overstruck text is best viewed by page-at-a-time programs that take
advantage of the terminal's \fBstand-out\fR and \fIunderline\fR capabilities, such
as the less program on Unix.
.PP
Apart from the overstrike, it in all ways functions like Pod::Text.  See
Pod::Text for details and available options.
.SH "BUGS"
.IX Header "BUGS"
Currently, the outermost formatting instruction wins, so for example
underlined text inside a region of bold text is displayed as simply bold.
There may be some better approach possible.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Text, Pod::Simple
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joe Smith <Joe.Smith@inwap.com>, using the framework created by Russ Allbery
<rra@stanford.edu>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2000 by Joe Smith <Joe.Smith@inwap.com>.
Copyright 2001, 2004, 2008 by Russ Allbery <rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text::Overstrike5.16.3pm                0100644 0001750 0001750 00000013533 12566207441 025634  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text::Overstrike 3pm"
.TH Pod::Text::Overstrike 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text::Overstrike \- Convert POD data to formatted overstrike text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text::Overstrike;
\&    my $parser = Pod::Text::Overstrike\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text::Overstrike is a simple subclass of Pod::Text that highlights
output text using overstrike sequences, in a manner similar to nroff.
Characters in bold text are overstruck (character, backspace, character)
and characters in underlined text are converted to overstruck underscores
(underscore, backspace, character).  This format was originally designed
for hard-copy terminals and/or line printers, yet is readable on soft-copy
(\s-1CRT\s0) terminals.
.PP
Overstruck text is best viewed by page-at-a-time programs that take
advantage of the terminal's \fBstand-out\fR and \fIunderline\fR capabilities, such
as the less program on Unix.
.PP
Apart from the overstrike, it in all ways functions like Pod::Text.  See
Pod::Text for details and available options.
.SH "BUGS"
.IX Header "BUGS"
Currently, the outermost formatting instruction wins, so for example
underlined text inside a region of bold text is displayed as simply bold.
There may be some better approach possible.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Text, Pod::Simple
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joe Smith <Joe.Smith@inwap.com>, using the framework created by Russ Allbery
<rra@stanford.edu>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2000 by Joe Smith <Joe.Smith@inwap.com>.
Copyright 2001, 2004, 2008 by Russ Allbery <rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text::Overstrike5.18.3pm                0100644 0001750 0001750 00000014054 12566207462 025640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text::Overstrike 3pm"
.TH Pod::Text::Overstrike 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text::Overstrike \- Convert POD data to formatted overstrike text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text::Overstrike;
\&    my $parser = Pod::Text::Overstrike\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text::Overstrike is a simple subclass of Pod::Text that highlights
output text using overstrike sequences, in a manner similar to nroff.
Characters in bold text are overstruck (character, backspace, character)
and characters in underlined text are converted to overstruck underscores
(underscore, backspace, character).  This format was originally designed
for hard-copy terminals and/or line printers, yet is readable on soft-copy
(\s-1CRT\s0) terminals.
.PP
Overstruck text is best viewed by page-at-a-time programs that take
advantage of the terminal's \fBstand-out\fR and \fIunderline\fR capabilities, such
as the less program on Unix.
.PP
Apart from the overstrike, it in all ways functions like Pod::Text.  See
Pod::Text for details and available options.
.SH "BUGS"
.IX Header "BUGS"
Currently, the outermost formatting instruction wins, so for example
underlined text inside a region of bold text is displayed as simply bold.
There may be some better approach possible.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Text, Pod::Simple
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joe Smith <Joe.Smith@inwap.com>, using the framework created by Russ Allbery
<rra@stanford.edu>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2000 by Joe Smith <Joe.Smith@inwap.com>.
Copyright 2001, 2004, 2008 by Russ Allbery <rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text::Termcap.3pm                       0100644 0001750 0001750 00000013170 12566207462 024560  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text::Termcap 3pm"
.TH Pod::Text::Termcap 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text::Termcap \- Convert POD data to ASCII text with format escapes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text::Termcap;
\&    my $parser = Pod::Text::Termcap\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output
text using the correct termcap escape sequences for the current terminal.
Apart from the format codes, it in all ways functions like Pod::Text.  See
Pod::Text for details and available options.
.SH "NOTES"
.IX Header "NOTES"
This module uses Term::Cap to retrieve the formatting escape sequences for
the current terminal, and falls back on the \s-1ECMA\-48 \s0(the same in this
regard as \s-1ANSI X3.64\s0 and \s-1ISO 6429,\s0 the escape codes also used by \s-1DEC VT100\s0
terminals) if the bold, underline, and reset codes aren't set in the
termcap information.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Text, Pod::Simple, Term::Cap
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2001, 2002, 2004, 2006, 2008, 2009 Russ Allbery
<rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text::Termcap5.16.3pm                   0100644 0001750 0001750 00000012656 12566207441 025077  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text::Termcap 3pm"
.TH Pod::Text::Termcap 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text::Termcap \- Convert POD data to ASCII text with format escapes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text::Termcap;
\&    my $parser = Pod::Text::Termcap\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output
text using the correct termcap escape sequences for the current terminal.
Apart from the format codes, it in all ways functions like Pod::Text.  See
Pod::Text for details and available options.
.SH "NOTES"
.IX Header "NOTES"
This module uses Term::Cap to retrieve the formatting escape sequences for
the current terminal, and falls back on the \s-1ECMA\-48\s0 (the same in this
regard as \s-1ANSI\s0 X3.64 and \s-1ISO\s0 6429, the escape codes also used by \s-1DEC\s0 \s-1VT100\s0
terminals) if the bold, underline, and reset codes aren't set in the
termcap information.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Text, Pod::Simple, Term::Cap
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2001, 2002, 2004, 2006, 2008, 2009 Russ Allbery
<rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Text::Termcap5.18.3pm                   0100644 0001750 0001750 00000013170 12566207462 025074  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Text::Termcap 3pm"
.TH Pod::Text::Termcap 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Text::Termcap \- Convert POD data to ASCII text with format escapes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::Text::Termcap;
\&    my $parser = Pod::Text::Termcap\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN and write to STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod and write to file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output
text using the correct termcap escape sequences for the current terminal.
Apart from the format codes, it in all ways functions like Pod::Text.  See
Pod::Text for details and available options.
.SH "NOTES"
.IX Header "NOTES"
This module uses Term::Cap to retrieve the formatting escape sequences for
the current terminal, and falls back on the \s-1ECMA\-48 \s0(the same in this
regard as \s-1ANSI X3.64\s0 and \s-1ISO 6429,\s0 the escape codes also used by \s-1DEC VT100\s0
terminals) if the bold, underline, and reset codes aren't set in the
termcap information.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Text, Pod::Simple, Term::Cap
.PP
The current version of this module is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2001, 2002, 2004, 2006, 2008, 2009 Russ Allbery
<rra@stanford.edu>.
.PP
This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Usage.3pm                               0100644 0001750 0001750 00000047446 12566207463 023216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Usage 3pm"
.TH Pod::Usage 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Usage, pod2usage() \- print a usage message from embedded pod documentation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Pod::Usage
\&
\&  my $message_text  = "This text precedes the usage message.";
\&  my $exit_status   = 2;          ## The exit status to use
\&  my $verbose_level = 0;          ## The verbose level to use
\&  my $filehandle    = \e*STDERR;   ## The filehandle to write to
\&
\&  pod2usage($message_text);
\&
\&  pod2usage($exit_status);
\&
\&  pod2usage( { \-message => $message_text ,
\&               \-exitval => $exit_status  ,  
\&               \-verbose => $verbose_level,  
\&               \-output  => $filehandle } );
\&
\&  pod2usage(   \-msg     => $message_text ,
\&               \-exitval => $exit_status  ,  
\&               \-verbose => $verbose_level,  
\&               \-output  => $filehandle   );
\&
\&  pod2usage(   \-verbose => 2,
\&               \-noperldoc => 1  )
.Ve
.SH "ARGUMENTS"
.IX Header "ARGUMENTS"
\&\fBpod2usage\fR should be given either a single argument, or a list of
arguments corresponding to an associative array (a \*(L"hash\*(R"). When a single
argument is given, it should correspond to exactly one of the following:
.IP "\(bu" 4
A string containing the text of a message to print \fIbefore\fR printing
the usage message
.IP "\(bu" 4
A numeric value corresponding to the desired exit status
.IP "\(bu" 4
A reference to a hash
.PP
If more than one argument is given then the entire argument list is
assumed to be a hash.  If a hash is supplied (either as a reference or
as a list) it should contain one or more elements with the following
keys:
.ie n .IP """\-message""" 4
.el .IP "\f(CW\-message\fR" 4
.IX Item "-message"
.PD 0
.ie n .IP """\-msg""" 4
.el .IP "\f(CW\-msg\fR" 4
.IX Item "-msg"
.PD
The text of a message to print immediately prior to printing the
program's usage message.
.ie n .IP """\-exitval""" 4
.el .IP "\f(CW\-exitval\fR" 4
.IX Item "-exitval"
The desired exit status to pass to the \fB\f(BIexit()\fB\fR function.
This should be an integer, or else the string \*(L"\s-1NOEXIT\*(R"\s0 to
indicate that control should simply be returned without
terminating the invoking process.
.ie n .IP """\-verbose""" 4
.el .IP "\f(CW\-verbose\fR" 4
.IX Item "-verbose"
The desired level of \*(L"verboseness\*(R" to use when printing the usage
message. If the corresponding value is 0, then only the \*(L"\s-1SYNOPSIS\*(R"\s0
section of the pod documentation is printed. If the corresponding value
is 1, then the \*(L"\s-1SYNOPSIS\*(R"\s0 section, along with any section entitled
\&\*(L"\s-1OPTIONS\*(R", \*(L"ARGUMENTS\*(R",\s0 or \*(L"\s-1OPTIONS AND ARGUMENTS\*(R"\s0 is printed.  If the
corresponding value is 2 or more then the entire manpage is printed.
.Sp
The special verbosity level 99 requires to also specify the \-sections
parameter; then these sections are extracted (see Pod::Select)
and printed.
.ie n .IP """\-sections""" 4
.el .IP "\f(CW\-sections\fR" 4
.IX Item "-sections"
A string representing a selection list for sections to be printed
when \-verbose is set to 99, e.g. \f(CW"NAME|SYNOPSIS|DESCRIPTION|VERSION"\fR.
.Sp
Alternatively, an array reference of section specifications can be used:
.Sp
.Vb 2
\&  pod2usage(\-verbose => 99, 
\&            \-sections => [ qw(fred fred/subsection) ] );
.Ve
.ie n .IP """\-output""" 4
.el .IP "\f(CW\-output\fR" 4
.IX Item "-output"
A reference to a filehandle, or the pathname of a file to which the
usage message should be written. The default is \f(CW\*(C`\e*STDERR\*(C'\fR unless the
exit value is less than 2 (in which case the default is \f(CW\*(C`\e*STDOUT\*(C'\fR).
.ie n .IP """\-input""" 4
.el .IP "\f(CW\-input\fR" 4
.IX Item "-input"
A reference to a filehandle, or the pathname of a file from which the
invoking script's pod documentation should be read.  It defaults to the
file indicated by \f(CW$0\fR (\f(CW$PROGRAM_NAME\fR for users of \fIEnglish.pm\fR).
.Sp
If you are calling \fB\f(BIpod2usage()\fB\fR from a module and want to display
that module's \s-1POD,\s0 you can use this:
.Sp
.Vb 2
\&  use Pod::Find qw(pod_where);
\&  pod2usage( \-input => pod_where({\-inc => 1}, _\|_PACKAGE_\|_) );
.Ve
.ie n .IP """\-pathlist""" 4
.el .IP "\f(CW\-pathlist\fR" 4
.IX Item "-pathlist"
A list of directory paths. If the input file does not exist, then it
will be searched for in the given directory list (in the order the
directories appear in the list). It defaults to the list of directories
implied by \f(CW$ENV{PATH}\fR. The list may be specified either by a reference
to an array, or by a string of directory paths which use the same path
separator as \f(CW$ENV{PATH}\fR on your system (e.g., \f(CW\*(C`:\*(C'\fR for Unix, \f(CW\*(C`;\*(C'\fR for
MSWin32 and \s-1DOS\s0).
.ie n .IP """\-noperldoc""" 4
.el .IP "\f(CW\-noperldoc\fR" 4
.IX Item "-noperldoc"
By default, Pod::Usage will call perldoc when \-verbose >= 2 is
specified. This does not work well e.g. if the script was packed
with \s-1PAR\s0. The \-noperldoc option suppresses the external call to
perldoc and uses the simple text formatter (Pod::Text) to 
output the \s-1POD.\s0
.SS "Formatting base class"
.IX Subsection "Formatting base class"
The default text formatter depends on the Perl version (Pod::Text or 
Pod::PlainText for Perl versions < 5.005_58). The base class for
Pod::Usage can be defined by pre-setting \f(CW$Pod::Usage::Formatter\fR \fIbefore\fR
loading Pod::Usage, e.g.:
.PP
.Vb 2
\&    BEGIN { $Pod::Usage::Formatter = \*(AqPod::Text::Termcap\*(Aq; }
\&    use Pod::Usage qw(pod2usage);
.Ve
.SS "Pass-through options"
.IX Subsection "Pass-through options"
The following options are passed through to the underlying text formatter.
See the manual pages of these modules for more information.
.PP
.Vb 1
\&  alt code indent loose margin quotes sentence stderr utf8 width
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBpod2usage\fR will print a usage message for the invoking script (using
its embedded pod documentation) and then exit the script with the
desired exit status. The usage message printed may have any one of three
levels of \*(L"verboseness\*(R": If the verbose level is 0, then only a synopsis
is printed. If the verbose level is 1, then the synopsis is printed
along with a description (if present) of the command line options and
arguments. If the verbose level is 2, then the entire manual page is
printed.
.PP
Unless they are explicitly specified, the default values for the exit
status, verbose level, and output stream to use are determined as
follows:
.IP "\(bu" 4
If neither the exit status nor the verbose level is specified, then the
default is to use an exit status of 2 with a verbose level of 0.
.IP "\(bu" 4
If an exit status \fIis\fR specified but the verbose level is \fInot\fR, then the
verbose level will default to 1 if the exit status is less than 2 and
will default to 0 otherwise.
.IP "\(bu" 4
If an exit status is \fInot\fR specified but verbose level \fIis\fR given, then
the exit status will default to 2 if the verbose level is 0 and will
default to 1 otherwise.
.IP "\(bu" 4
If the exit status used is less than 2, then output is printed on
\&\f(CW\*(C`STDOUT\*(C'\fR.  Otherwise output is printed on \f(CW\*(C`STDERR\*(C'\fR.
.PP
Although the above may seem a bit confusing at first, it generally does
\&\*(L"the right thing\*(R" in most situations.  This determination of the default
values to use is based upon the following typical Unix conventions:
.IP "\(bu" 4
An exit status of 0 implies \*(L"success\*(R". For example, \fB\f(BIdiff\fB\|(1)\fR exits
with a status of 0 if the two files have the same contents.
.IP "\(bu" 4
An exit status of 1 implies possibly abnormal, but non-defective, program
termination.  For example, \fB\f(BIgrep\fB\|(1)\fR exits with a status of 1 if
it did \fInot\fR find a matching line for the given regular expression.
.IP "\(bu" 4
An exit status of 2 or more implies a fatal error. For example, \fB\f(BIls\fB\|(1)\fR
exits with a status of 2 if you specify an illegal (unknown) option on
the command line.
.IP "\(bu" 4
Usage messages issued as a result of bad command-line syntax should go
to \f(CW\*(C`STDERR\*(C'\fR.  However, usage messages issued due to an explicit request
to print usage (like specifying \fB\-help\fR on the command line) should go
to \f(CW\*(C`STDOUT\*(C'\fR, just in case the user wants to pipe the output to a pager
(such as \fB\f(BImore\fB\|(1)\fR).
.IP "\(bu" 4
If program usage has been explicitly requested by the user, it is often
desirable to exit with a status of 1 (as opposed to 0) after issuing
the user-requested usage message.  It is also desirable to give a
more verbose description of program usage in this case.
.PP
\&\fBpod2usage\fR doesn't force the above conventions upon you, but it will
use them by default if you don't expressly tell it to do otherwise.  The
ability of \fB\f(BIpod2usage()\fB\fR to accept a single number or a string makes it
convenient to use as an innocent looking error message handling function:
.PP
.Vb 2
\&    use Pod::Usage;
\&    use Getopt::Long;
\&
\&    ## Parse options
\&    GetOptions("help", "man", "flag1")  ||  pod2usage(2);
\&    pod2usage(1)  if ($opt_help);
\&    pod2usage(\-verbose => 2)  if ($opt_man);
\&
\&    ## Check for too many filenames
\&    pod2usage("$0: Too many files given.\en")  if (@ARGV > 1);
.Ve
.PP
Some user's however may feel that the above \*(L"economy of expression\*(R" is
not particularly readable nor consistent and may instead choose to do
something more like the following:
.PP
.Vb 2
\&    use Pod::Usage;
\&    use Getopt::Long;
\&
\&    ## Parse options
\&    GetOptions("help", "man", "flag1")  ||  pod2usage(\-verbose => 0);
\&    pod2usage(\-verbose => 1)  if ($opt_help);
\&    pod2usage(\-verbose => 2)  if ($opt_man);
\&
\&    ## Check for too many filenames
\&    pod2usage(\-verbose => 2, \-message => "$0: Too many files given.\en")
\&        if (@ARGV > 1);
.Ve
.PP
As with all things in Perl, \fIthere's more than one way to do it\fR, and
\&\fB\f(BIpod2usage()\fB\fR adheres to this philosophy.  If you are interested in
seeing a number of different ways to invoke \fBpod2usage\fR (although by no
means exhaustive), please refer to \*(L"\s-1EXAMPLES\*(R"\s0.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print just the
\&\*(L"\s-1SYNOPSIS\*(R"\s0 section to \f(CW\*(C`STDERR\*(C'\fR and will exit with a status of 2:
.PP
.Vb 1
\&    pod2usage();
\&
\&    pod2usage(2);
\&
\&    pod2usage(\-verbose => 0);
\&
\&    pod2usage(\-exitval => 2);
\&
\&    pod2usage({\-exitval => 2, \-output => \e*STDERR});
\&
\&    pod2usage({\-verbose => 0, \-output  => \e*STDERR});
\&
\&    pod2usage(\-exitval => 2, \-verbose => 0);
\&
\&    pod2usage(\-exitval => 2, \-verbose => 0, \-output => \e*STDERR);
.Ve
.PP
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print a message
of \*(L"Syntax error.\*(R" (followed by a newline) to \f(CW\*(C`STDERR\*(C'\fR, immediately
followed by just the \*(L"\s-1SYNOPSIS\*(R"\s0 section (also printed to \f(CW\*(C`STDERR\*(C'\fR) and
will exit with a status of 2:
.PP
.Vb 1
\&    pod2usage("Syntax error.");
\&
\&    pod2usage(\-message => "Syntax error.", \-verbose => 0);
\&
\&    pod2usage(\-msg  => "Syntax error.", \-exitval => 2);
\&
\&    pod2usage({\-msg => "Syntax error.", \-exitval => 2, \-output => \e*STDERR});
\&
\&    pod2usage({\-msg => "Syntax error.", \-verbose => 0, \-output => \e*STDERR});
\&
\&    pod2usage(\-msg  => "Syntax error.", \-exitval => 2, \-verbose => 0);
\&
\&    pod2usage(\-message => "Syntax error.",
\&              \-exitval => 2,
\&              \-verbose => 0,
\&              \-output  => \e*STDERR);
.Ve
.PP
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print the
\&\*(L"\s-1SYNOPSIS\*(R"\s0 section and any \*(L"\s-1OPTIONS\*(R"\s0 and/or \*(L"\s-1ARGUMENTS\*(R"\s0 sections to
\&\f(CW\*(C`STDOUT\*(C'\fR and will exit with a status of 1:
.PP
.Vb 1
\&    pod2usage(1);
\&
\&    pod2usage(\-verbose => 1);
\&
\&    pod2usage(\-exitval => 1);
\&
\&    pod2usage({\-exitval => 1, \-output => \e*STDOUT});
\&
\&    pod2usage({\-verbose => 1, \-output => \e*STDOUT});
\&
\&    pod2usage(\-exitval => 1, \-verbose => 1);
\&
\&    pod2usage(\-exitval => 1, \-verbose => 1, \-output => \e*STDOUT});
.Ve
.PP
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print the
entire manual page to \f(CW\*(C`STDOUT\*(C'\fR and will exit with a status of 1:
.PP
.Vb 1
\&    pod2usage(\-verbose  => 2);
\&
\&    pod2usage({\-verbose => 2, \-output => \e*STDOUT});
\&
\&    pod2usage(\-exitval  => 1, \-verbose => 2);
\&
\&    pod2usage({\-exitval => 1, \-verbose => 2, \-output => \e*STDOUT});
.Ve
.SS "Recommended Use"
.IX Subsection "Recommended Use"
Most scripts should print some type of usage message to \f(CW\*(C`STDERR\*(C'\fR when a
command line syntax error is detected. They should also provide an
option (usually \f(CW\*(C`\-H\*(C'\fR or \f(CW\*(C`\-help\*(C'\fR) to print a (possibly more verbose)
usage message to \f(CW\*(C`STDOUT\*(C'\fR. Some scripts may even wish to go so far as to
provide a means of printing their complete documentation to \f(CW\*(C`STDOUT\*(C'\fR
(perhaps by allowing a \f(CW\*(C`\-man\*(C'\fR option). The following complete example
uses \fBPod::Usage\fR in combination with \fBGetopt::Long\fR to do all of these
things:
.PP
.Vb 2
\&    use Getopt::Long;
\&    use Pod::Usage;
\&
\&    my $man = 0;
\&    my $help = 0;
\&    ## Parse options and print usage if there is a syntax error,
\&    ## or if usage was explicitly requested.
\&    GetOptions(\*(Aqhelp|?\*(Aq => \e$help, man => \e$man) or pod2usage(2);
\&    pod2usage(1) if $help;
\&    pod2usage(\-verbose => 2) if $man;
\&
\&    ## If no arguments were given, then allow STDIN to be used only
\&    ## if it\*(Aqs not connected to a terminal (otherwise print usage)
\&    pod2usage("$0: No files given.")  if ((@ARGV == 0) && (\-t STDIN));
\&    _\|_END_\|_
\&
\&    =head1 NAME
\&
\&    sample \- Using GetOpt::Long and Pod::Usage
\&
\&    =head1 SYNOPSIS
\&
\&    sample [options] [file ...]
\&
\&     Options:
\&       \-help            brief help message
\&       \-man             full documentation
\&
\&    =head1 OPTIONS
\&
\&    =over 8
\&
\&    =item B<\-help>
\&
\&    Print a brief help message and exits.
\&
\&    =item B<\-man>
\&
\&    Prints the manual page and exits.
\&
\&    =back
\&
\&    =head1 DESCRIPTION
\&
\&    B<This program> will read the given input file(s) and do something
\&    useful with the contents thereof.
\&
\&    =cut
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
By default, \fB\f(BIpod2usage()\fB\fR will use \f(CW$0\fR as the path to the pod input
file.  Unfortunately, not all systems on which Perl runs will set \f(CW$0\fR
properly (although if \f(CW$0\fR isn't found, \fB\f(BIpod2usage()\fB\fR will search
\&\f(CW$ENV{PATH}\fR or else the list specified by the \f(CW\*(C`\-pathlist\*(C'\fR option).
If this is the case for your system, you may need to explicitly specify
the path to the pod docs for the invoking script using something
similar to the following:
.PP
.Vb 1
\&    pod2usage(\-exitval => 2, \-input => "/path/to/your/pod/docs");
.Ve
.PP
In the pathological case that a script is called via a relative path
\&\fIand\fR the script itself changes the current working directory
(see \*(L"chdir\*(R" in perlfunc) \fIbefore\fR calling pod2usage, Pod::Usage will
fail even on robust platforms. Don't do that. Or use FindBin to locate
the script:
.PP
.Vb 2
\&    use FindBin;
\&    pod2usage(\-input => $FindBin::Bin . "/" . $FindBin::Script);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Please report bugs using <http://rt.cpan.org>.
.PP
Marek Rouchal <marekr@cpan.org>
.PP
Brad Appleton <bradapp@enteract.com>
.PP
Based on code for \fB\f(BIPod::Text::pod2text()\fB\fR written by
Tom Christiansen <tchrist@mox.perl.com>
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Steven McDougall <swmcd@world.std.com> for his help and patience
with re-writing this manpage.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBPod::Usage\fR is now a standalone distribution.
.PP
Pod::Parser, Pod::Perldoc, Getopt::Long, Pod::Find, FindBin,
Pod::Text, Pod::PlainText, Pod::Text::Termcap
                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Usage5.16.3pm                           0100644 0001750 0001750 00000046053 12566207441 023515  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Usage 3pm"
.TH Pod::Usage 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Usage, pod2usage() \- print a usage message from embedded pod documentation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Pod::Usage
\&
\&  my $message_text  = "This text precedes the usage message.";
\&  my $exit_status   = 2;          ## The exit status to use
\&  my $verbose_level = 0;          ## The verbose level to use
\&  my $filehandle    = \e*STDERR;   ## The filehandle to write to
\&
\&  pod2usage($message_text);
\&
\&  pod2usage($exit_status);
\&
\&  pod2usage( { \-message => $message_text ,
\&               \-exitval => $exit_status  ,  
\&               \-verbose => $verbose_level,  
\&               \-output  => $filehandle } );
\&
\&  pod2usage(   \-msg     => $message_text ,
\&               \-exitval => $exit_status  ,  
\&               \-verbose => $verbose_level,  
\&               \-output  => $filehandle   );
\&
\&  pod2usage(   \-verbose => 2,
\&               \-noperldoc => 1  )
.Ve
.SH "ARGUMENTS"
.IX Header "ARGUMENTS"
\&\fBpod2usage\fR should be given either a single argument, or a list of
arguments corresponding to an associative array (a \*(L"hash\*(R"). When a single
argument is given, it should correspond to exactly one of the following:
.IP "\(bu" 4
A string containing the text of a message to print \fIbefore\fR printing
the usage message
.IP "\(bu" 4
A numeric value corresponding to the desired exit status
.IP "\(bu" 4
A reference to a hash
.PP
If more than one argument is given then the entire argument list is
assumed to be a hash.  If a hash is supplied (either as a reference or
as a list) it should contain one or more elements with the following
keys:
.ie n .IP """\-message""" 4
.el .IP "\f(CW\-message\fR" 4
.IX Item "-message"
.PD 0
.ie n .IP """\-msg""" 4
.el .IP "\f(CW\-msg\fR" 4
.IX Item "-msg"
.PD
The text of a message to print immediately prior to printing the
program's usage message.
.ie n .IP """\-exitval""" 4
.el .IP "\f(CW\-exitval\fR" 4
.IX Item "-exitval"
The desired exit status to pass to the \fB\f(BIexit()\fB\fR function.
This should be an integer, or else the string \*(L"\s-1NOEXIT\s0\*(R" to
indicate that control should simply be returned without
terminating the invoking process.
.ie n .IP """\-verbose""" 4
.el .IP "\f(CW\-verbose\fR" 4
.IX Item "-verbose"
The desired level of \*(L"verboseness\*(R" to use when printing the usage
message. If the corresponding value is 0, then only the \*(L"\s-1SYNOPSIS\s0\*(R"
section of the pod documentation is printed. If the corresponding value
is 1, then the \*(L"\s-1SYNOPSIS\s0\*(R" section, along with any section entitled
\&\*(L"\s-1OPTIONS\s0\*(R", \*(L"\s-1ARGUMENTS\s0\*(R", or \*(L"\s-1OPTIONS\s0 \s-1AND\s0 \s-1ARGUMENTS\s0\*(R" is printed.  If the
corresponding value is 2 or more then the entire manpage is printed.
.Sp
The special verbosity level 99 requires to also specify the \-sections
parameter; then these sections are extracted (see Pod::Select)
and printed.
.ie n .IP """\-sections""" 4
.el .IP "\f(CW\-sections\fR" 4
.IX Item "-sections"
A string representing a selection list for sections to be printed
when \-verbose is set to 99, e.g. \f(CW"NAME|SYNOPSIS|DESCRIPTION|VERSION"\fR.
.Sp
Alternatively, an array reference of section specifications can be used:
.Sp
.Vb 2
\&  pod2usage(\-verbose => 99, 
\&            \-sections => [ qw(fred fred/subsection) ] );
.Ve
.ie n .IP """\-output""" 4
.el .IP "\f(CW\-output\fR" 4
.IX Item "-output"
A reference to a filehandle, or the pathname of a file to which the
usage message should be written. The default is \f(CW\*(C`\e*STDERR\*(C'\fR unless the
exit value is less than 2 (in which case the default is \f(CW\*(C`\e*STDOUT\*(C'\fR).
.ie n .IP """\-input""" 4
.el .IP "\f(CW\-input\fR" 4
.IX Item "-input"
A reference to a filehandle, or the pathname of a file from which the
invoking script's pod documentation should be read.  It defaults to the
file indicated by \f(CW$0\fR (\f(CW$PROGRAM_NAME\fR for users of \fIEnglish.pm\fR).
.Sp
If you are calling \fB\f(BIpod2usage()\fB\fR from a module and want to display
that module's \s-1POD\s0, you can use this:
.Sp
.Vb 2
\&  use Pod::Find qw(pod_where);
\&  pod2usage( \-input => pod_where({\-inc => 1}, _\|_PACKAGE_\|_) );
.Ve
.ie n .IP """\-pathlist""" 4
.el .IP "\f(CW\-pathlist\fR" 4
.IX Item "-pathlist"
A list of directory paths. If the input file does not exist, then it
will be searched for in the given directory list (in the order the
directories appear in the list). It defaults to the list of directories
implied by \f(CW$ENV{PATH}\fR. The list may be specified either by a reference
to an array, or by a string of directory paths which use the same path
separator as \f(CW$ENV{PATH}\fR on your system (e.g., \f(CW\*(C`:\*(C'\fR for Unix, \f(CW\*(C`;\*(C'\fR for
MSWin32 and \s-1DOS\s0).
.ie n .IP """\-noperldoc""" 4
.el .IP "\f(CW\-noperldoc\fR" 4
.IX Item "-noperldoc"
By default, Pod::Usage will call perldoc when \-verbose >= 2 is
specified. This does not work well e.g. if the script was packed
with \s-1PAR\s0. The \-noperldoc option suppresses the external call to
perldoc and uses the simple text formatter (Pod::Text) to 
output the \s-1POD\s0.
.SS "Pass-through options"
.IX Subsection "Pass-through options"
The following options are passed through to the underlying text formatter
(Pod::Text or Pod::PlainText for Perl versions < 5.005_58). See 
the manual pages of these modules for more information.
.PP
.Vb 1
\&  alt code indent loose margin quotes sentence stderr utf8 width
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBpod2usage\fR will print a usage message for the invoking script (using
its embedded pod documentation) and then exit the script with the
desired exit status. The usage message printed may have any one of three
levels of \*(L"verboseness\*(R": If the verbose level is 0, then only a synopsis
is printed. If the verbose level is 1, then the synopsis is printed
along with a description (if present) of the command line options and
arguments. If the verbose level is 2, then the entire manual page is
printed.
.PP
Unless they are explicitly specified, the default values for the exit
status, verbose level, and output stream to use are determined as
follows:
.IP "\(bu" 4
If neither the exit status nor the verbose level is specified, then the
default is to use an exit status of 2 with a verbose level of 0.
.IP "\(bu" 4
If an exit status \fIis\fR specified but the verbose level is \fInot\fR, then the
verbose level will default to 1 if the exit status is less than 2 and
will default to 0 otherwise.
.IP "\(bu" 4
If an exit status is \fInot\fR specified but verbose level \fIis\fR given, then
the exit status will default to 2 if the verbose level is 0 and will
default to 1 otherwise.
.IP "\(bu" 4
If the exit status used is less than 2, then output is printed on
\&\f(CW\*(C`STDOUT\*(C'\fR.  Otherwise output is printed on \f(CW\*(C`STDERR\*(C'\fR.
.PP
Although the above may seem a bit confusing at first, it generally does
\&\*(L"the right thing\*(R" in most situations.  This determination of the default
values to use is based upon the following typical Unix conventions:
.IP "\(bu" 4
An exit status of 0 implies \*(L"success\*(R". For example, \fB\f(BIdiff\fB\|(1)\fR exits
with a status of 0 if the two files have the same contents.
.IP "\(bu" 4
An exit status of 1 implies possibly abnormal, but non-defective, program
termination.  For example, \fB\f(BIgrep\fB\|(1)\fR exits with a status of 1 if
it did \fInot\fR find a matching line for the given regular expression.
.IP "\(bu" 4
An exit status of 2 or more implies a fatal error. For example, \fB\f(BIls\fB\|(1)\fR
exits with a status of 2 if you specify an illegal (unknown) option on
the command line.
.IP "\(bu" 4
Usage messages issued as a result of bad command-line syntax should go
to \f(CW\*(C`STDERR\*(C'\fR.  However, usage messages issued due to an explicit request
to print usage (like specifying \fB\-help\fR on the command line) should go
to \f(CW\*(C`STDOUT\*(C'\fR, just in case the user wants to pipe the output to a pager
(such as \fB\f(BImore\fB\|(1)\fR).
.IP "\(bu" 4
If program usage has been explicitly requested by the user, it is often
desirable to exit with a status of 1 (as opposed to 0) after issuing
the user-requested usage message.  It is also desirable to give a
more verbose description of program usage in this case.
.PP
\&\fBpod2usage\fR doesn't force the above conventions upon you, but it will
use them by default if you don't expressly tell it to do otherwise.  The
ability of \fB\f(BIpod2usage()\fB\fR to accept a single number or a string makes it
convenient to use as an innocent looking error message handling function:
.PP
.Vb 2
\&    use Pod::Usage;
\&    use Getopt::Long;
\&
\&    ## Parse options
\&    GetOptions("help", "man", "flag1")  ||  pod2usage(2);
\&    pod2usage(1)  if ($opt_help);
\&    pod2usage(\-verbose => 2)  if ($opt_man);
\&
\&    ## Check for too many filenames
\&    pod2usage("$0: Too many files given.\en")  if (@ARGV > 1);
.Ve
.PP
Some user's however may feel that the above \*(L"economy of expression\*(R" is
not particularly readable nor consistent and may instead choose to do
something more like the following:
.PP
.Vb 2
\&    use Pod::Usage;
\&    use Getopt::Long;
\&
\&    ## Parse options
\&    GetOptions("help", "man", "flag1")  ||  pod2usage(\-verbose => 0);
\&    pod2usage(\-verbose => 1)  if ($opt_help);
\&    pod2usage(\-verbose => 2)  if ($opt_man);
\&
\&    ## Check for too many filenames
\&    pod2usage(\-verbose => 2, \-message => "$0: Too many files given.\en")
\&        if (@ARGV > 1);
.Ve
.PP
As with all things in Perl, \fIthere's more than one way to do it\fR, and
\&\fB\f(BIpod2usage()\fB\fR adheres to this philosophy.  If you are interested in
seeing a number of different ways to invoke \fBpod2usage\fR (although by no
means exhaustive), please refer to \*(L"\s-1EXAMPLES\s0\*(R".
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print just the
\&\*(L"\s-1SYNOPSIS\s0\*(R" section to \f(CW\*(C`STDERR\*(C'\fR and will exit with a status of 2:
.PP
.Vb 1
\&    pod2usage();
\&
\&    pod2usage(2);
\&
\&    pod2usage(\-verbose => 0);
\&
\&    pod2usage(\-exitval => 2);
\&
\&    pod2usage({\-exitval => 2, \-output => \e*STDERR});
\&
\&    pod2usage({\-verbose => 0, \-output  => \e*STDERR});
\&
\&    pod2usage(\-exitval => 2, \-verbose => 0);
\&
\&    pod2usage(\-exitval => 2, \-verbose => 0, \-output => \e*STDERR);
.Ve
.PP
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print a message
of \*(L"Syntax error.\*(R" (followed by a newline) to \f(CW\*(C`STDERR\*(C'\fR, immediately
followed by just the \*(L"\s-1SYNOPSIS\s0\*(R" section (also printed to \f(CW\*(C`STDERR\*(C'\fR) and
will exit with a status of 2:
.PP
.Vb 1
\&    pod2usage("Syntax error.");
\&
\&    pod2usage(\-message => "Syntax error.", \-verbose => 0);
\&
\&    pod2usage(\-msg  => "Syntax error.", \-exitval => 2);
\&
\&    pod2usage({\-msg => "Syntax error.", \-exitval => 2, \-output => \e*STDERR});
\&
\&    pod2usage({\-msg => "Syntax error.", \-verbose => 0, \-output => \e*STDERR});
\&
\&    pod2usage(\-msg  => "Syntax error.", \-exitval => 2, \-verbose => 0);
\&
\&    pod2usage(\-message => "Syntax error.",
\&              \-exitval => 2,
\&              \-verbose => 0,
\&              \-output  => \e*STDERR);
.Ve
.PP
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print the
\&\*(L"\s-1SYNOPSIS\s0\*(R" section and any \*(L"\s-1OPTIONS\s0\*(R" and/or \*(L"\s-1ARGUMENTS\s0\*(R" sections to
\&\f(CW\*(C`STDOUT\*(C'\fR and will exit with a status of 1:
.PP
.Vb 1
\&    pod2usage(1);
\&
\&    pod2usage(\-verbose => 1);
\&
\&    pod2usage(\-exitval => 1);
\&
\&    pod2usage({\-exitval => 1, \-output => \e*STDOUT});
\&
\&    pod2usage({\-verbose => 1, \-output => \e*STDOUT});
\&
\&    pod2usage(\-exitval => 1, \-verbose => 1);
\&
\&    pod2usage(\-exitval => 1, \-verbose => 1, \-output => \e*STDOUT});
.Ve
.PP
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print the
entire manual page to \f(CW\*(C`STDOUT\*(C'\fR and will exit with a status of 1:
.PP
.Vb 1
\&    pod2usage(\-verbose  => 2);
\&
\&    pod2usage({\-verbose => 2, \-output => \e*STDOUT});
\&
\&    pod2usage(\-exitval  => 1, \-verbose => 2);
\&
\&    pod2usage({\-exitval => 1, \-verbose => 2, \-output => \e*STDOUT});
.Ve
.SS "Recommended Use"
.IX Subsection "Recommended Use"
Most scripts should print some type of usage message to \f(CW\*(C`STDERR\*(C'\fR when a
command line syntax error is detected. They should also provide an
option (usually \f(CW\*(C`\-H\*(C'\fR or \f(CW\*(C`\-help\*(C'\fR) to print a (possibly more verbose)
usage message to \f(CW\*(C`STDOUT\*(C'\fR. Some scripts may even wish to go so far as to
provide a means of printing their complete documentation to \f(CW\*(C`STDOUT\*(C'\fR
(perhaps by allowing a \f(CW\*(C`\-man\*(C'\fR option). The following complete example
uses \fBPod::Usage\fR in combination with \fBGetopt::Long\fR to do all of these
things:
.PP
.Vb 2
\&    use Getopt::Long;
\&    use Pod::Usage;
\&
\&    my $man = 0;
\&    my $help = 0;
\&    ## Parse options and print usage if there is a syntax error,
\&    ## or if usage was explicitly requested.
\&    GetOptions(\*(Aqhelp|?\*(Aq => \e$help, man => \e$man) or pod2usage(2);
\&    pod2usage(1) if $help;
\&    pod2usage(\-verbose => 2) if $man;
\&
\&    ## If no arguments were given, then allow STDIN to be used only
\&    ## if it\*(Aqs not connected to a terminal (otherwise print usage)
\&    pod2usage("$0: No files given.")  if ((@ARGV == 0) && (\-t STDIN));
\&    _\|_END_\|_
\&
\&    =head1 NAME
\&
\&    sample \- Using GetOpt::Long and Pod::Usage
\&
\&    =head1 SYNOPSIS
\&
\&    sample [options] [file ...]
\&
\&     Options:
\&       \-help            brief help message
\&       \-man             full documentation
\&
\&    =head1 OPTIONS
\&
\&    =over 8
\&
\&    =item B<\-help>
\&
\&    Print a brief help message and exits.
\&
\&    =item B<\-man>
\&
\&    Prints the manual page and exits.
\&
\&    =back
\&
\&    =head1 DESCRIPTION
\&
\&    B<This program> will read the given input file(s) and do something
\&    useful with the contents thereof.
\&
\&    =cut
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
By default, \fB\f(BIpod2usage()\fB\fR will use \f(CW$0\fR as the path to the pod input
file.  Unfortunately, not all systems on which Perl runs will set \f(CW$0\fR
properly (although if \f(CW$0\fR isn't found, \fB\f(BIpod2usage()\fB\fR will search
\&\f(CW$ENV{PATH}\fR or else the list specified by the \f(CW\*(C`\-pathlist\*(C'\fR option).
If this is the case for your system, you may need to explicitly specify
the path to the pod docs for the invoking script using something
similar to the following:
.PP
.Vb 1
\&    pod2usage(\-exitval => 2, \-input => "/path/to/your/pod/docs");
.Ve
.PP
In the pathological case that a script is called via a relative path
\&\fIand\fR the script itself changes the current working directory
(see \*(L"chdir\*(R" in perlfunc) \fIbefore\fR calling pod2usage, Pod::Usage will
fail even on robust platforms. Don't do that.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please report bugs using <http://rt.cpan.org>.
.PP
Marek Rouchal <marekr@cpan.org>
.PP
Brad Appleton <bradapp@enteract.com>
.PP
Based on code for \fB\f(BIPod::Text::pod2text()\fB\fR written by
Tom Christiansen <tchrist@mox.perl.com>
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Steven McDougall <swmcd@world.std.com> for his help and patience
with re-writing this manpage.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBPod::Usage\fR is part of the Pod::Parser distribution.
.PP
Pod::Parser, Getopt::Long, Pod::Find
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Pod::Usage5.18.3pm                           0100644 0001750 0001750 00000047446 12566207463 023532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Usage 3pm"
.TH Pod::Usage 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Usage, pod2usage() \- print a usage message from embedded pod documentation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Pod::Usage
\&
\&  my $message_text  = "This text precedes the usage message.";
\&  my $exit_status   = 2;          ## The exit status to use
\&  my $verbose_level = 0;          ## The verbose level to use
\&  my $filehandle    = \e*STDERR;   ## The filehandle to write to
\&
\&  pod2usage($message_text);
\&
\&  pod2usage($exit_status);
\&
\&  pod2usage( { \-message => $message_text ,
\&               \-exitval => $exit_status  ,  
\&               \-verbose => $verbose_level,  
\&               \-output  => $filehandle } );
\&
\&  pod2usage(   \-msg     => $message_text ,
\&               \-exitval => $exit_status  ,  
\&               \-verbose => $verbose_level,  
\&               \-output  => $filehandle   );
\&
\&  pod2usage(   \-verbose => 2,
\&               \-noperldoc => 1  )
.Ve
.SH "ARGUMENTS"
.IX Header "ARGUMENTS"
\&\fBpod2usage\fR should be given either a single argument, or a list of
arguments corresponding to an associative array (a \*(L"hash\*(R"). When a single
argument is given, it should correspond to exactly one of the following:
.IP "\(bu" 4
A string containing the text of a message to print \fIbefore\fR printing
the usage message
.IP "\(bu" 4
A numeric value corresponding to the desired exit status
.IP "\(bu" 4
A reference to a hash
.PP
If more than one argument is given then the entire argument list is
assumed to be a hash.  If a hash is supplied (either as a reference or
as a list) it should contain one or more elements with the following
keys:
.ie n .IP """\-message""" 4
.el .IP "\f(CW\-message\fR" 4
.IX Item "-message"
.PD 0
.ie n .IP """\-msg""" 4
.el .IP "\f(CW\-msg\fR" 4
.IX Item "-msg"
.PD
The text of a message to print immediately prior to printing the
program's usage message.
.ie n .IP """\-exitval""" 4
.el .IP "\f(CW\-exitval\fR" 4
.IX Item "-exitval"
The desired exit status to pass to the \fB\f(BIexit()\fB\fR function.
This should be an integer, or else the string \*(L"\s-1NOEXIT\*(R"\s0 to
indicate that control should simply be returned without
terminating the invoking process.
.ie n .IP """\-verbose""" 4
.el .IP "\f(CW\-verbose\fR" 4
.IX Item "-verbose"
The desired level of \*(L"verboseness\*(R" to use when printing the usage
message. If the corresponding value is 0, then only the \*(L"\s-1SYNOPSIS\*(R"\s0
section of the pod documentation is printed. If the corresponding value
is 1, then the \*(L"\s-1SYNOPSIS\*(R"\s0 section, along with any section entitled
\&\*(L"\s-1OPTIONS\*(R", \*(L"ARGUMENTS\*(R",\s0 or \*(L"\s-1OPTIONS AND ARGUMENTS\*(R"\s0 is printed.  If the
corresponding value is 2 or more then the entire manpage is printed.
.Sp
The special verbosity level 99 requires to also specify the \-sections
parameter; then these sections are extracted (see Pod::Select)
and printed.
.ie n .IP """\-sections""" 4
.el .IP "\f(CW\-sections\fR" 4
.IX Item "-sections"
A string representing a selection list for sections to be printed
when \-verbose is set to 99, e.g. \f(CW"NAME|SYNOPSIS|DESCRIPTION|VERSION"\fR.
.Sp
Alternatively, an array reference of section specifications can be used:
.Sp
.Vb 2
\&  pod2usage(\-verbose => 99, 
\&            \-sections => [ qw(fred fred/subsection) ] );
.Ve
.ie n .IP """\-output""" 4
.el .IP "\f(CW\-output\fR" 4
.IX Item "-output"
A reference to a filehandle, or the pathname of a file to which the
usage message should be written. The default is \f(CW\*(C`\e*STDERR\*(C'\fR unless the
exit value is less than 2 (in which case the default is \f(CW\*(C`\e*STDOUT\*(C'\fR).
.ie n .IP """\-input""" 4
.el .IP "\f(CW\-input\fR" 4
.IX Item "-input"
A reference to a filehandle, or the pathname of a file from which the
invoking script's pod documentation should be read.  It defaults to the
file indicated by \f(CW$0\fR (\f(CW$PROGRAM_NAME\fR for users of \fIEnglish.pm\fR).
.Sp
If you are calling \fB\f(BIpod2usage()\fB\fR from a module and want to display
that module's \s-1POD,\s0 you can use this:
.Sp
.Vb 2
\&  use Pod::Find qw(pod_where);
\&  pod2usage( \-input => pod_where({\-inc => 1}, _\|_PACKAGE_\|_) );
.Ve
.ie n .IP """\-pathlist""" 4
.el .IP "\f(CW\-pathlist\fR" 4
.IX Item "-pathlist"
A list of directory paths. If the input file does not exist, then it
will be searched for in the given directory list (in the order the
directories appear in the list). It defaults to the list of directories
implied by \f(CW$ENV{PATH}\fR. The list may be specified either by a reference
to an array, or by a string of directory paths which use the same path
separator as \f(CW$ENV{PATH}\fR on your system (e.g., \f(CW\*(C`:\*(C'\fR for Unix, \f(CW\*(C`;\*(C'\fR for
MSWin32 and \s-1DOS\s0).
.ie n .IP """\-noperldoc""" 4
.el .IP "\f(CW\-noperldoc\fR" 4
.IX Item "-noperldoc"
By default, Pod::Usage will call perldoc when \-verbose >= 2 is
specified. This does not work well e.g. if the script was packed
with \s-1PAR\s0. The \-noperldoc option suppresses the external call to
perldoc and uses the simple text formatter (Pod::Text) to 
output the \s-1POD.\s0
.SS "Formatting base class"
.IX Subsection "Formatting base class"
The default text formatter depends on the Perl version (Pod::Text or 
Pod::PlainText for Perl versions < 5.005_58). The base class for
Pod::Usage can be defined by pre-setting \f(CW$Pod::Usage::Formatter\fR \fIbefore\fR
loading Pod::Usage, e.g.:
.PP
.Vb 2
\&    BEGIN { $Pod::Usage::Formatter = \*(AqPod::Text::Termcap\*(Aq; }
\&    use Pod::Usage qw(pod2usage);
.Ve
.SS "Pass-through options"
.IX Subsection "Pass-through options"
The following options are passed through to the underlying text formatter.
See the manual pages of these modules for more information.
.PP
.Vb 1
\&  alt code indent loose margin quotes sentence stderr utf8 width
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBpod2usage\fR will print a usage message for the invoking script (using
its embedded pod documentation) and then exit the script with the
desired exit status. The usage message printed may have any one of three
levels of \*(L"verboseness\*(R": If the verbose level is 0, then only a synopsis
is printed. If the verbose level is 1, then the synopsis is printed
along with a description (if present) of the command line options and
arguments. If the verbose level is 2, then the entire manual page is
printed.
.PP
Unless they are explicitly specified, the default values for the exit
status, verbose level, and output stream to use are determined as
follows:
.IP "\(bu" 4
If neither the exit status nor the verbose level is specified, then the
default is to use an exit status of 2 with a verbose level of 0.
.IP "\(bu" 4
If an exit status \fIis\fR specified but the verbose level is \fInot\fR, then the
verbose level will default to 1 if the exit status is less than 2 and
will default to 0 otherwise.
.IP "\(bu" 4
If an exit status is \fInot\fR specified but verbose level \fIis\fR given, then
the exit status will default to 2 if the verbose level is 0 and will
default to 1 otherwise.
.IP "\(bu" 4
If the exit status used is less than 2, then output is printed on
\&\f(CW\*(C`STDOUT\*(C'\fR.  Otherwise output is printed on \f(CW\*(C`STDERR\*(C'\fR.
.PP
Although the above may seem a bit confusing at first, it generally does
\&\*(L"the right thing\*(R" in most situations.  This determination of the default
values to use is based upon the following typical Unix conventions:
.IP "\(bu" 4
An exit status of 0 implies \*(L"success\*(R". For example, \fB\f(BIdiff\fB\|(1)\fR exits
with a status of 0 if the two files have the same contents.
.IP "\(bu" 4
An exit status of 1 implies possibly abnormal, but non-defective, program
termination.  For example, \fB\f(BIgrep\fB\|(1)\fR exits with a status of 1 if
it did \fInot\fR find a matching line for the given regular expression.
.IP "\(bu" 4
An exit status of 2 or more implies a fatal error. For example, \fB\f(BIls\fB\|(1)\fR
exits with a status of 2 if you specify an illegal (unknown) option on
the command line.
.IP "\(bu" 4
Usage messages issued as a result of bad command-line syntax should go
to \f(CW\*(C`STDERR\*(C'\fR.  However, usage messages issued due to an explicit request
to print usage (like specifying \fB\-help\fR on the command line) should go
to \f(CW\*(C`STDOUT\*(C'\fR, just in case the user wants to pipe the output to a pager
(such as \fB\f(BImore\fB\|(1)\fR).
.IP "\(bu" 4
If program usage has been explicitly requested by the user, it is often
desirable to exit with a status of 1 (as opposed to 0) after issuing
the user-requested usage message.  It is also desirable to give a
more verbose description of program usage in this case.
.PP
\&\fBpod2usage\fR doesn't force the above conventions upon you, but it will
use them by default if you don't expressly tell it to do otherwise.  The
ability of \fB\f(BIpod2usage()\fB\fR to accept a single number or a string makes it
convenient to use as an innocent looking error message handling function:
.PP
.Vb 2
\&    use Pod::Usage;
\&    use Getopt::Long;
\&
\&    ## Parse options
\&    GetOptions("help", "man", "flag1")  ||  pod2usage(2);
\&    pod2usage(1)  if ($opt_help);
\&    pod2usage(\-verbose => 2)  if ($opt_man);
\&
\&    ## Check for too many filenames
\&    pod2usage("$0: Too many files given.\en")  if (@ARGV > 1);
.Ve
.PP
Some user's however may feel that the above \*(L"economy of expression\*(R" is
not particularly readable nor consistent and may instead choose to do
something more like the following:
.PP
.Vb 2
\&    use Pod::Usage;
\&    use Getopt::Long;
\&
\&    ## Parse options
\&    GetOptions("help", "man", "flag1")  ||  pod2usage(\-verbose => 0);
\&    pod2usage(\-verbose => 1)  if ($opt_help);
\&    pod2usage(\-verbose => 2)  if ($opt_man);
\&
\&    ## Check for too many filenames
\&    pod2usage(\-verbose => 2, \-message => "$0: Too many files given.\en")
\&        if (@ARGV > 1);
.Ve
.PP
As with all things in Perl, \fIthere's more than one way to do it\fR, and
\&\fB\f(BIpod2usage()\fB\fR adheres to this philosophy.  If you are interested in
seeing a number of different ways to invoke \fBpod2usage\fR (although by no
means exhaustive), please refer to \*(L"\s-1EXAMPLES\*(R"\s0.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print just the
\&\*(L"\s-1SYNOPSIS\*(R"\s0 section to \f(CW\*(C`STDERR\*(C'\fR and will exit with a status of 2:
.PP
.Vb 1
\&    pod2usage();
\&
\&    pod2usage(2);
\&
\&    pod2usage(\-verbose => 0);
\&
\&    pod2usage(\-exitval => 2);
\&
\&    pod2usage({\-exitval => 2, \-output => \e*STDERR});
\&
\&    pod2usage({\-verbose => 0, \-output  => \e*STDERR});
\&
\&    pod2usage(\-exitval => 2, \-verbose => 0);
\&
\&    pod2usage(\-exitval => 2, \-verbose => 0, \-output => \e*STDERR);
.Ve
.PP
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print a message
of \*(L"Syntax error.\*(R" (followed by a newline) to \f(CW\*(C`STDERR\*(C'\fR, immediately
followed by just the \*(L"\s-1SYNOPSIS\*(R"\s0 section (also printed to \f(CW\*(C`STDERR\*(C'\fR) and
will exit with a status of 2:
.PP
.Vb 1
\&    pod2usage("Syntax error.");
\&
\&    pod2usage(\-message => "Syntax error.", \-verbose => 0);
\&
\&    pod2usage(\-msg  => "Syntax error.", \-exitval => 2);
\&
\&    pod2usage({\-msg => "Syntax error.", \-exitval => 2, \-output => \e*STDERR});
\&
\&    pod2usage({\-msg => "Syntax error.", \-verbose => 0, \-output => \e*STDERR});
\&
\&    pod2usage(\-msg  => "Syntax error.", \-exitval => 2, \-verbose => 0);
\&
\&    pod2usage(\-message => "Syntax error.",
\&              \-exitval => 2,
\&              \-verbose => 0,
\&              \-output  => \e*STDERR);
.Ve
.PP
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print the
\&\*(L"\s-1SYNOPSIS\*(R"\s0 section and any \*(L"\s-1OPTIONS\*(R"\s0 and/or \*(L"\s-1ARGUMENTS\*(R"\s0 sections to
\&\f(CW\*(C`STDOUT\*(C'\fR and will exit with a status of 1:
.PP
.Vb 1
\&    pod2usage(1);
\&
\&    pod2usage(\-verbose => 1);
\&
\&    pod2usage(\-exitval => 1);
\&
\&    pod2usage({\-exitval => 1, \-output => \e*STDOUT});
\&
\&    pod2usage({\-verbose => 1, \-output => \e*STDOUT});
\&
\&    pod2usage(\-exitval => 1, \-verbose => 1);
\&
\&    pod2usage(\-exitval => 1, \-verbose => 1, \-output => \e*STDOUT});
.Ve
.PP
Each of the following invocations of \f(CW\*(C`pod2usage()\*(C'\fR will print the
entire manual page to \f(CW\*(C`STDOUT\*(C'\fR and will exit with a status of 1:
.PP
.Vb 1
\&    pod2usage(\-verbose  => 2);
\&
\&    pod2usage({\-verbose => 2, \-output => \e*STDOUT});
\&
\&    pod2usage(\-exitval  => 1, \-verbose => 2);
\&
\&    pod2usage({\-exitval => 1, \-verbose => 2, \-output => \e*STDOUT});
.Ve
.SS "Recommended Use"
.IX Subsection "Recommended Use"
Most scripts should print some type of usage message to \f(CW\*(C`STDERR\*(C'\fR when a
command line syntax error is detected. They should also provide an
option (usually \f(CW\*(C`\-H\*(C'\fR or \f(CW\*(C`\-help\*(C'\fR) to print a (possibly more verbose)
usage message to \f(CW\*(C`STDOUT\*(C'\fR. Some scripts may even wish to go so far as to
provide a means of printing their complete documentation to \f(CW\*(C`STDOUT\*(C'\fR
(perhaps by allowing a \f(CW\*(C`\-man\*(C'\fR option). The following complete example
uses \fBPod::Usage\fR in combination with \fBGetopt::Long\fR to do all of these
things:
.PP
.Vb 2
\&    use Getopt::Long;
\&    use Pod::Usage;
\&
\&    my $man = 0;
\&    my $help = 0;
\&    ## Parse options and print usage if there is a syntax error,
\&    ## or if usage was explicitly requested.
\&    GetOptions(\*(Aqhelp|?\*(Aq => \e$help, man => \e$man) or pod2usage(2);
\&    pod2usage(1) if $help;
\&    pod2usage(\-verbose => 2) if $man;
\&
\&    ## If no arguments were given, then allow STDIN to be used only
\&    ## if it\*(Aqs not connected to a terminal (otherwise print usage)
\&    pod2usage("$0: No files given.")  if ((@ARGV == 0) && (\-t STDIN));
\&    _\|_END_\|_
\&
\&    =head1 NAME
\&
\&    sample \- Using GetOpt::Long and Pod::Usage
\&
\&    =head1 SYNOPSIS
\&
\&    sample [options] [file ...]
\&
\&     Options:
\&       \-help            brief help message
\&       \-man             full documentation
\&
\&    =head1 OPTIONS
\&
\&    =over 8
\&
\&    =item B<\-help>
\&
\&    Print a brief help message and exits.
\&
\&    =item B<\-man>
\&
\&    Prints the manual page and exits.
\&
\&    =back
\&
\&    =head1 DESCRIPTION
\&
\&    B<This program> will read the given input file(s) and do something
\&    useful with the contents thereof.
\&
\&    =cut
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
By default, \fB\f(BIpod2usage()\fB\fR will use \f(CW$0\fR as the path to the pod input
file.  Unfortunately, not all systems on which Perl runs will set \f(CW$0\fR
properly (although if \f(CW$0\fR isn't found, \fB\f(BIpod2usage()\fB\fR will search
\&\f(CW$ENV{PATH}\fR or else the list specified by the \f(CW\*(C`\-pathlist\*(C'\fR option).
If this is the case for your system, you may need to explicitly specify
the path to the pod docs for the invoking script using something
similar to the following:
.PP
.Vb 1
\&    pod2usage(\-exitval => 2, \-input => "/path/to/your/pod/docs");
.Ve
.PP
In the pathological case that a script is called via a relative path
\&\fIand\fR the script itself changes the current working directory
(see \*(L"chdir\*(R" in perlfunc) \fIbefore\fR calling pod2usage, Pod::Usage will
fail even on robust platforms. Don't do that. Or use FindBin to locate
the script:
.PP
.Vb 2
\&    use FindBin;
\&    pod2usage(\-input => $FindBin::Bin . "/" . $FindBin::Script);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Please report bugs using <http://rt.cpan.org>.
.PP
Marek Rouchal <marekr@cpan.org>
.PP
Brad Appleton <bradapp@enteract.com>
.PP
Based on code for \fB\f(BIPod::Text::pod2text()\fB\fR written by
Tom Christiansen <tchrist@mox.perl.com>
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Steven McDougall <swmcd@world.std.com> for his help and patience
with re-writing this manpage.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBPod::Usage\fR is now a standalone distribution.
.PP
Pod::Parser, Pod::Perldoc, Getopt::Long, Pod::Find, FindBin,
Pod::Text, Pod::PlainText, Pod::Text::Termcap
                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Probe::Perl.3pm                              0100644 0001750 0001750 00000020464 12566242640 023364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Probe::Perl 3"
.TH Probe::Perl 3 "2013-08-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Probe::Perl \- Information about the currently running perl
.SH "VERSION"
.IX Header "VERSION"
version 0.03
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Probe::Perl;
\& $p = Probe::Perl\->new();
\& 
\& # Version of this perl as a floating point number
\& $ver = $p\->perl_version();
\& $ver = Probe::Perl\->perl_version();
\& 
\& # Convert a multi\-dotted string to a floating point number
\& $ver = $p\->perl_version_to_float($ver);
\& $ver = Probe::Perl\->perl_version_to_float($ver);
\& 
\& # Check if the given perl is the same as the one currently running
\& $bool = $p\->perl_is_same($perl_path);
\& $bool = Probe::Perl\->perl_is_same($perl_path);
\& 
\& # Find a path to the currently\-running perl
\& $path = $p\->find_perl_interpreter();
\& $path = Probe::Perl\->find_perl_interpreter();
\& 
\& # Get @INC before run\-time additions
\& @paths = $p\->perl_inc();
\& @paths = Probe::Perl\->perl_inc();
\& 
\& # Get the general type of operating system
\& $type = $p\->os_type();
\& $type = Probe::Perl\->os_type();
\& 
\& # Access Config.pm values
\& $val = $p\->config(\*(Aqfoo\*(Aq);
\& $val = Probe::Perl\->config(\*(Aqfoo\*(Aq);
\& $p\->config(\*(Aqfoo\*(Aq => \*(Aqbar\*(Aq);  # Set locally
\& $p\->config_revert(\*(Aqfoo\*(Aq);  # Revert
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides methods for obtaining information about the
currently running perl interpreter.  It originally began life as code
in the \f(CW\*(C`Module::Build\*(C'\fR project, but has been externalized here for
general use.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
Creates a new Probe::Perl object and returns it.  Most methods in
the Probe::Perl packages are available as class methods, so you
don't always need to create a new object.  But if you want to create a
mutable view of the \f(CW\*(C`Config.pm\*(C'\fR data, it's necessary to create an
object to store the values in.
.ie n .IP "config( $key [, $value] )" 4
.el .IP "config( \f(CW$key\fR [, \f(CW$value\fR] )" 4
.IX Item "config( $key [, $value] )"
Returns the \f(CW\*(C`Config.pm\*(C'\fR value associated with \f(CW$key\fR.  If \f(CW$value\fR
is also specified, then the value is set to \f(CW$value\fR for this view of
the data.  In this case, \f(CW\*(C`config()\*(C'\fR must be called as an object
method, not a class method.
.ie n .IP "config_revert( $key )" 4
.el .IP "config_revert( \f(CW$key\fR )" 4
.IX Item "config_revert( $key )"
Removes any user-assigned value in this view of the \f(CW\*(C`Config.pm\*(C'\fR data.
.IP "find_perl_interpreter( )" 4
.IX Item "find_perl_interpreter( )"
Returns the absolute path of this perl interpreter.  This is actually
sort of a tricky thing to discover sometimes \- in these cases we use
\&\f(CW\*(C`perl_is_same()\*(C'\fR to verify.
.IP "perl_version( )" 4
.IX Item "perl_version( )"
Returns the version of this perl interpreter as a perl-styled version
number using \f(CW\*(C`perl_version_to_float()\*(C'\fR.  Uses \f(CW$^V\fR if your perl is
recent enough, otherwise uses \f(CW$]\fR.
.ie n .IP "perl_version_to_float( $version )" 4
.el .IP "perl_version_to_float( \f(CW$version\fR )" 4
.IX Item "perl_version_to_float( $version )"
Formats \f(CW$version\fR as a perl-styled version number like \f(CW5.008001\fR.
.ie n .IP "perl_is_same( $perl )" 4
.el .IP "perl_is_same( \f(CW$perl\fR )" 4
.IX Item "perl_is_same( $perl )"
Given the name of a perl interpreter, this method determines if it has
the same configuration as the one represented by the current perl
instance.  Usually this means it's exactly the same
.IP "perl_inc( )" 4
.IX Item "perl_inc( )"
Returns a list of directories in this perl's \f(CW@INC\fR path, \fIbefore\fR
any entries from \f(CW\*(C`use lib\*(C'\fR, \f(CW$ENV{PERL5LIB}\fR, or \f(CW\*(C`\-I\*(C'\fR switches are
added.
.IP "os_type( [$osname] )" 4
.IX Item "os_type( [$osname] )"
Returns a generic \s-1OS\s0 type (e.g. \*(L"Unix\*(R", \*(L"Windows\*(R", \*(L"MacOS\*(R") for the
given \s-1OS\s0 name. If no \s-1OS\s0 name is given it uses the value in $^O, which
is the same as \f(CW$Config\fR{osname}.
.SH "AUTHOR"
.IX Header "AUTHOR"
Randy W. Sims <randys@thepierianspring.org>
.PP
Based partly on code from the Module::Build project, by Ken Williams
<kwilliams@cpan.org> and others.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2005 Ken Williams and Randy Sims.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Probe::Perl5.16.3pm                          0100644 0001750 0001750 00000020063 12566242634 023674  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Probe::Perl 3"
.TH Probe::Perl 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Probe::Perl \- Information about the currently running perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Probe::Perl;
\& $p = Probe::Perl\->new();
\& 
\& # Version of this perl as a floating point number
\& $ver = $p\->perl_version();
\& $ver = Probe::Perl\->perl_version();
\& 
\& # Convert a multi\-dotted string to a floating point number
\& $ver = $p\->perl_version_to_float($ver);
\& $ver = Probe::Perl\->perl_version_to_float($ver);
\& 
\& # Check if the given perl is the same as the one currently running
\& $bool = $p\->perl_is_same($perl_path);
\& $bool = Probe::Perl\->perl_is_same($perl_path);
\& 
\& # Find a path to the currently\-running perl
\& $path = $p\->find_perl_interpreter();
\& $path = Probe::Perl\->find_perl_interpreter();
\& 
\& # Get @INC before run\-time additions
\& @paths = $p\->perl_inc();
\& @paths = Probe::Perl\->perl_inc();
\& 
\& # Get the general type of operating system
\& $type = $p\->os_type();
\& $type = Probe::Perl\->os_type();
\& 
\& # Access Config.pm values
\& $val = $p\->config(\*(Aqfoo\*(Aq);
\& $val = Probe::Perl\->config(\*(Aqfoo\*(Aq);
\& $p\->config(\*(Aqfoo\*(Aq => \*(Aqbar\*(Aq);  # Set locally
\& $p\->config_revert(\*(Aqfoo\*(Aq);  # Revert
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides methods for obtaining information about the
currently running perl interpreter.  It originally began life as code
in the \f(CW\*(C`Module::Build\*(C'\fR project, but has been externalized here for
general use.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
Creates a new Probe::Perl object and returns it.  Most methods in
the Probe::Perl packages are available as class methods, so you
don't always need to create a new object.  But if you want to create a
mutable view of the \f(CW\*(C`Config.pm\*(C'\fR data, it's necessary to create an
object to store the values in.
.ie n .IP "config( $key [, $value] )" 4
.el .IP "config( \f(CW$key\fR [, \f(CW$value\fR] )" 4
.IX Item "config( $key [, $value] )"
Returns the \f(CW\*(C`Config.pm\*(C'\fR value associated with \f(CW$key\fR.  If \f(CW$value\fR
is also specified, then the value is set to \f(CW$value\fR for this view of
the data.  In this case, \f(CW\*(C`config()\*(C'\fR must be called as an object
method, not a class method.
.ie n .IP "config_revert( $key )" 4
.el .IP "config_revert( \f(CW$key\fR )" 4
.IX Item "config_revert( $key )"
Removes any user-assigned value in this view of the \f(CW\*(C`Config.pm\*(C'\fR data.
.IP "find_perl_interpreter( )" 4
.IX Item "find_perl_interpreter( )"
Returns the absolute path of this perl interpreter.  This is actually
sort of a tricky thing to discover sometimes \- in these cases we use
\&\f(CW\*(C`perl_is_same()\*(C'\fR to verify.
.IP "perl_version( )" 4
.IX Item "perl_version( )"
Returns the version of this perl interpreter as a perl-styled version
number using \f(CW\*(C`perl_version_to_float()\*(C'\fR.  Uses \f(CW$^V\fR if your perl is
recent enough, otherwise uses \f(CW$]\fR.
.ie n .IP "perl_version_to_float( $version )" 4
.el .IP "perl_version_to_float( \f(CW$version\fR )" 4
.IX Item "perl_version_to_float( $version )"
Formats \f(CW$version\fR as a perl-styled version number like \f(CW5.008001\fR.
.ie n .IP "perl_is_same( $perl )" 4
.el .IP "perl_is_same( \f(CW$perl\fR )" 4
.IX Item "perl_is_same( $perl )"
Given the name of a perl interpreter, this method determines if it has
the same configuration as the one represented by the current perl
instance.  Usually this means it's exactly the same
.IP "perl_inc( )" 4
.IX Item "perl_inc( )"
Returns a list of directories in this perl's \f(CW@INC\fR path, \fIbefore\fR
any entries from \f(CW\*(C`use lib\*(C'\fR, \f(CW$ENV{PERL5LIB}\fR, or \f(CW\*(C`\-I\*(C'\fR switches are
added.
.IP "os_type( [$osname] )" 4
.IX Item "os_type( [$osname] )"
Returns a generic \s-1OS\s0 type (e.g. \*(L"Unix\*(R", \*(L"Windows\*(R", \*(L"MacOS\*(R") for the
given \s-1OS\s0 name. If no \s-1OS\s0 name is given it uses the value in $^O, which
is the same as \f(CW$Config\fR{osname}.
.SH "AUTHOR"
.IX Header "AUTHOR"
Randy W. Sims <randys@thepierianspring.org>
.PP
Based partly on code from the Module::Build project, by Ken Williams
<kwilliams@cpan.org> and others.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2005 Ken Williams and Randy Sims.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Probe::Perl5.18.3pm                          0100644 0001750 0001750 00000020464 12566242640 023700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Probe::Perl 3"
.TH Probe::Perl 3 "2013-08-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Probe::Perl \- Information about the currently running perl
.SH "VERSION"
.IX Header "VERSION"
version 0.03
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Probe::Perl;
\& $p = Probe::Perl\->new();
\& 
\& # Version of this perl as a floating point number
\& $ver = $p\->perl_version();
\& $ver = Probe::Perl\->perl_version();
\& 
\& # Convert a multi\-dotted string to a floating point number
\& $ver = $p\->perl_version_to_float($ver);
\& $ver = Probe::Perl\->perl_version_to_float($ver);
\& 
\& # Check if the given perl is the same as the one currently running
\& $bool = $p\->perl_is_same($perl_path);
\& $bool = Probe::Perl\->perl_is_same($perl_path);
\& 
\& # Find a path to the currently\-running perl
\& $path = $p\->find_perl_interpreter();
\& $path = Probe::Perl\->find_perl_interpreter();
\& 
\& # Get @INC before run\-time additions
\& @paths = $p\->perl_inc();
\& @paths = Probe::Perl\->perl_inc();
\& 
\& # Get the general type of operating system
\& $type = $p\->os_type();
\& $type = Probe::Perl\->os_type();
\& 
\& # Access Config.pm values
\& $val = $p\->config(\*(Aqfoo\*(Aq);
\& $val = Probe::Perl\->config(\*(Aqfoo\*(Aq);
\& $p\->config(\*(Aqfoo\*(Aq => \*(Aqbar\*(Aq);  # Set locally
\& $p\->config_revert(\*(Aqfoo\*(Aq);  # Revert
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides methods for obtaining information about the
currently running perl interpreter.  It originally began life as code
in the \f(CW\*(C`Module::Build\*(C'\fR project, but has been externalized here for
general use.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
Creates a new Probe::Perl object and returns it.  Most methods in
the Probe::Perl packages are available as class methods, so you
don't always need to create a new object.  But if you want to create a
mutable view of the \f(CW\*(C`Config.pm\*(C'\fR data, it's necessary to create an
object to store the values in.
.ie n .IP "config( $key [, $value] )" 4
.el .IP "config( \f(CW$key\fR [, \f(CW$value\fR] )" 4
.IX Item "config( $key [, $value] )"
Returns the \f(CW\*(C`Config.pm\*(C'\fR value associated with \f(CW$key\fR.  If \f(CW$value\fR
is also specified, then the value is set to \f(CW$value\fR for this view of
the data.  In this case, \f(CW\*(C`config()\*(C'\fR must be called as an object
method, not a class method.
.ie n .IP "config_revert( $key )" 4
.el .IP "config_revert( \f(CW$key\fR )" 4
.IX Item "config_revert( $key )"
Removes any user-assigned value in this view of the \f(CW\*(C`Config.pm\*(C'\fR data.
.IP "find_perl_interpreter( )" 4
.IX Item "find_perl_interpreter( )"
Returns the absolute path of this perl interpreter.  This is actually
sort of a tricky thing to discover sometimes \- in these cases we use
\&\f(CW\*(C`perl_is_same()\*(C'\fR to verify.
.IP "perl_version( )" 4
.IX Item "perl_version( )"
Returns the version of this perl interpreter as a perl-styled version
number using \f(CW\*(C`perl_version_to_float()\*(C'\fR.  Uses \f(CW$^V\fR if your perl is
recent enough, otherwise uses \f(CW$]\fR.
.ie n .IP "perl_version_to_float( $version )" 4
.el .IP "perl_version_to_float( \f(CW$version\fR )" 4
.IX Item "perl_version_to_float( $version )"
Formats \f(CW$version\fR as a perl-styled version number like \f(CW5.008001\fR.
.ie n .IP "perl_is_same( $perl )" 4
.el .IP "perl_is_same( \f(CW$perl\fR )" 4
.IX Item "perl_is_same( $perl )"
Given the name of a perl interpreter, this method determines if it has
the same configuration as the one represented by the current perl
instance.  Usually this means it's exactly the same
.IP "perl_inc( )" 4
.IX Item "perl_inc( )"
Returns a list of directories in this perl's \f(CW@INC\fR path, \fIbefore\fR
any entries from \f(CW\*(C`use lib\*(C'\fR, \f(CW$ENV{PERL5LIB}\fR, or \f(CW\*(C`\-I\*(C'\fR switches are
added.
.IP "os_type( [$osname] )" 4
.IX Item "os_type( [$osname] )"
Returns a generic \s-1OS\s0 type (e.g. \*(L"Unix\*(R", \*(L"Windows\*(R", \*(L"MacOS\*(R") for the
given \s-1OS\s0 name. If no \s-1OS\s0 name is given it uses the value in $^O, which
is the same as \f(CW$Config\fR{osname}.
.SH "AUTHOR"
.IX Header "AUTHOR"
Randy W. Sims <randys@thepierianspring.org>
.PP
Based partly on code from the Module::Build project, by Ken Williams
<kwilliams@cpan.org> and others.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2005 Ken Williams and Randy Sims.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Proc::Reliable.3pm                           0100644 0001750 0001750 00000040111 12566241514 024023  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Reliable 3"
.TH Reliable 3 "2003-11-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Proc::Reliable \-\- Run external processes reliably with many options.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Proc::Reliable;
.PP
Create a new process object
.PP
.Vb 1
\&   $myproc = Proc::Reliable\->new();
.Ve
.PP
Run a subprocess and collect its output
.PP
.Vb 1
\&   $output = $myproc\->run("/bin/ls \-l");
.Ve
.PP
Check for problems
.PP
.Vb 3
\&   if($myproc\->status()) {
\&     print("problem!\en");
\&   }
.Ve
.PP
Run another subprocess, keeping stdout and stderr separated.
Also, send the subprocess some data on stdin.
.PP
.Vb 6
\&   $msg = "Hello World\en");
\&   $p\->want_single_list(0);
\&   $stdout = $p\->run("/usr/bin/fastmail \- foo@bar.com", $msg);
\&   if($p\->status()) {
\&     print("problem: ", $p\->stderr(), "\en");
\&   }
.Ve
.PP
Another way to get output
.PP
.Vb 1
\&   ($stdout, $stderr, $status, $msg) = $p\->run("/bin/ls \-l");
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Run Modes
.PP
.Vb 5
\& $p\->run("shell\-command\-line");  # Launch a shell process
\& $p\->run("cmdline", "data");     # Launch a shell process with stdin data
\& $p\->run(["cmd", "arg1", ...]);  # Bypass shell processing of arguments
\& $p\->run(sub { ... });           # Launch a perl subroutine
\& $p\->run(\e&subroutine);          # Launch a perl subroutine
.Ve
.PP
Option settings below represent defaults
.PP
.Vb 10
\& $p\->num_tries(1);           # execute the program only once
\& $p\->time_per_try(60);       # time per try 60 sec
\& $p\->maxtime(60);            # set overall timeout
\& $p\->time_btw_tries(5);      # time between tries 5 sec
\& $p\->want_single_list();     # return STDOUT and STDERR together
\& $p\->accept_no_error();      # Re\-try if any STDERR output
\& $p\->pattern_stdout($pat);   # require STDOUT to match regex $pat
\& $p\->pattern_stderr($pat);   # require STDERR to match regex $pat
\& $p\->allow_shell(1);         # allowed to use shell for operation
\& $p\->child_exit_time(1.0);   # timeout for child to exit after it closes stdout
\& $p\->sigterm_exit_time(0.5); # timeout for child to exit after sigterm
\& $p\->sigkill_exit_time(0.5); # timeout for child to exit after sigkill
\& $p\->input_chunking(0);      # feed stdin data line\-by\-line to subprocess
\& $p\->stdin_error_ok(0);      # ok if child exits without reading all stdin
\& $p\->stdout_cb(undef);       # callback function for line\-by\-line stdout
\& $p\->stderr_cb(undef);       # callback function for line\-by\-line stderr
.Ve
.PP
Getting output
.PP
.Vb 4
\& $out = $p\->stdout();        # stdout produced by last run()
\& $err = $p\->stderr();        # stderr produced by last run()
\& $stat = $p\->status();       # exit code produced by last run()
\& $msg = $p\->msg();           # module messages produced by last run()
.Ve
.PP
Debug
.PP
Proc::Reliable::debug($level);         # Turn debug on
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Proc::Reliable is a class for simple, reliable and
configurable subprocess execution in perl.  In particular, it is
especially useful for managing the execution of 'problem' programs
which are likely to fail, hang, or otherwise behave in an unruly manner.
.PP
Proc::Reliable includes all the
functionality of the backticks operator and \fIsystem()\fR functions, plus
many common uses of \fIfork()\fR and \fIexec()\fR, \fIopen2()\fR and \fIopen3()\fR.
Proc::Reliable incorporates a number of options, including 
sending data to the subprocess on \s-1STDIN,\s0 collecting \s-1STDOUT\s0 and \s-1STDERR\s0
separately or together, killing hung processes, timouts and automatic retries.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A new process object is created by
.PP
.Vb 1
\&   $myproc = Proc::Reliable\->new();
.Ve
.PP
The default will run a subprocess only once with a 60\-second timeout.
Either shell-like command lines or references 
to perl subroutines can be specified for launching a process in 
background.  A simple list process, for example, can be started 
via the shell as
.PP
.Vb 1
\&   $out = $myproc\->run("ls");
.Ve
.PP
To separate stdout, stderr, and exit status:
.PP
.Vb 1
\&   ($out, $err, $status, $msg) = $myproc\->run("ls");
.Ve
.PP
The output data is also stored within the \f(CW$myproc\fR object for later
retrieval.  You can also run a perl subroutine in a subprocess, with
.PP
.Vb 1
\&   $myproc\->run(sub { return <*>; });
.Ve
.PP
The \fIrun\fR Method will try to run the named process.  If the 
process times out (after \fItime_per_try\fR seconds) or has an
error defined as unacceptable and you would like to re-run it,
you can use the \fInum_tries\fR option.  Use the \fItime_btw_tries\fR
option to set the number of seconds between runs.  This can repeat
until \fImaxtime\fR seconds have elapsed.
.PP
When using \fInum_tries\fR, the user can specify what constitutes an
unacceptable error of \s-1STDOUT\s0 or \s-1STDERR\s0 output \*(-- i.e. demanding a retry.
One common shorthand is to have the \fIrun\fR method retry if there
is any return from \s-1STDERR.  \s0
.PP
.Vb 3
\&   $myproc\->accept_no_error();    # Re\-try if any STDERR
\&   $myproc\->pattern_stdout($pat); # require STDOUT to match regex $pat
\&   $myproc\->pattern_stderr($pat); # require STDERR to match regex $pat
.Ve
.PP
Subprocess completion is detected when the process closes all filehandles.
The process must then exit before child_exit_time expires, or it will be
killed.  If the subprocess does not exit, it is sent a \s-1TERM\s0 signal unless
sigterm_exit_time is 0.  then if it does not exit before sigterm_exit_time
expires, it is sent a \s-1KILL\s0 signal unless sigkill_exit_time is 0.  then if
it does not exit before sigkill_exit_time expires an error is generated.
waiting is done in 0.01 second increments.
.PP
Proc::Reliable is not MT-Safe due to signals usage.
.SH "METHODS"
.IX Header "METHODS"
The following methods are available:
.IP "new (Constructor)" 4
.IX Item "new (Constructor)"
Create a new instance of this class by writing either
.Sp
.Vb 1
\&    $proc = new Proc::Reliable;   or   $proc = Proc::Reliable\->new();
.Ve
.Sp
The \fInew\fR method accepts any valid configuration options:
.Sp
.Vb 1
\&    $proc = Proc::Reliable\->new(\*(Aqmaxtime\*(Aq => 200, \*(Aqnum_tries\*(Aq => 3);
.Ve
.IP "run" 4
.IX Item "run"
Run a new process and collect the standard output and standard 
error via separate pipes.
.Sp
.Vb 2
\&  $out = $proc\->run("program\-name");
\& ($out, $err, $status, $msg) = $proc\->run("program\-name");
.Ve
.Sp
by default with a single return value, stdout and stderr are combined
to a single stream and returned.  with 4 return values, stdout and
stderr are separated, and the program exit status is also returned.
\&\f(CW$msg\fR contains messages from Proc::Reliable when errors occur.
Set \fIwant_single_list\fR\|(1) to force stdout and stderr to be combined,
and \fIwant_single_list\fR\|(0) to force them separated.  The results from
\&\fIrun()\fR are stored as member data also:
.Sp
.Vb 9
\&  $proc\->want_single_list(0);
\&  $proc\->run("program");
\&  if($proc\->status) {
\&    print($proc\->stderr);
\&    exit;
\&  }
\&  else {
\&    print($proc\->stdout);
\&  }
.Ve
.Sp
Program exit status is returned in the same format as \fIexec()\fR:
bits 0\-7 set if program exited from a signal, bits 8\-15 are the exit status
on a normal program exit.
.Sp
You can also set up callbacks to run a function of your choice as
each line of stdout and stderr is produced by the child process
using the stdout_cb and stderr_cb options.
.Sp
There are a number of other options.
You can also feed the forked program data on stdin via a second argument to \fIrun()\fR:
.Sp
.Vb 2
\& $myinput = "hello\entest\en";
\& $output = $proc\->run("program\-name", $myinput);
.Ve
.Sp
The first option to \fIrun()\fR supports three forms:
1) string containing command string to execute.  this incurs shell parsing.
2) arrayref containing split command string to execute.  this bypasses shell parsing.
3) coderef to perl function.
The first two options are executed via \fIexec()\fR, so the specifics of incurring shell
parsing are the same.
.Sp
The second option to \fIrun()\fR supports two forms:
1) string containing data to feed on stdin
2) stringref pointing to data to feed on stdin
.Sp
You can start execution of an 
independent Perl function (like \*(L"eval\*(R" except with timeout, 
retries, etc.).  Simply provide the function reference like
.Sp
.Vb 1
\& $output = $proc\->run(\e&perl_function);
.Ve
.Sp
or supply an unnamed subroutine:
.Sp
.Vb 1
\& $output = $proc\->run( sub { sleep(1) } );
.Ve
.Sp
The \fIrun\fR Method returns after the the function finishes, 
one way or another.
.IP "debug" 4
.IX Item "debug"
Switches debug messages on and off \*(-- \fIProc::Reliable::debug\fR\|(1) switches
them on, \fIProc::Reliable::debug\fR\|(0) keeps Proc::Reliable quiet.
.IP "maxtime" 4
.IX Item "maxtime"
Return or set the maximum time in seconds per \fIrun\fR method call.  
Default is 300 seconds (i.e. 5 minutes).
.IP "num_tries" 4
.IX Item "num_tries"
Return or set the maximum number of tries the \fIrun\fR method will 
attempt an operation if there are unallowed errors.  Default is 5.
.IP "time_per_try" 4
.IX Item "time_per_try"
Return or set the maximum time in seconds for each attempt which 
\&\fIrun\fR makes of an operation.  Multiple tries in case of error 
can go longer than this.  Default is 30 seconds.
.IP "time_btw_tries" 4
.IX Item "time_btw_tries"
Return or set the time in seconds between attempted operations 
in case of unacceptable error.  Default is 5 seconds.
.IP "child_exit_time" 4
.IX Item "child_exit_time"
When the subprocess closes stdout, it is assumed to have completed
normal operation.  It is expected to exit within the amount of time
specified.  If it does not exit, it will be killed (with \s-1SIGTERM\s0).
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "sigterm_exit_time" 4
.IX Item "sigterm_exit_time"
If the \fItime_per_try\fR or \fImax_time\fR has been exceeded, or if
\&\fIchild_exit_time\fR action has not succeeded, the subprocess will be
killed with \s-1SIGTERM. \s0 This option specifies the amount of time to allow
the process to exit after closing stdout.
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "sigkill_exit_time" 4
.IX Item "sigkill_exit_time"
Similar to \fIsigterm_exit_time\fR, but a \s-1SIGKILL\s0 is sent instead of a
\&\s-1SIGTERM. \s0 When both options are enabled, the \s-1SIGTERM\s0 is sent first
and \s-1SIGKILL\s0 is then sent after the specified time only if the
subprocess is still alive.
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "input_chunking" 4
.IX Item "input_chunking"
If data is being written to the subprocess on stdin, this option will
cause the module to \fIsplit()\fR the input data at linefeeds, and only feed
the subprocess a line at a time.  This option typically would be used
when the subprocess is an application with a command prompt and does
not work properly when all the data is fed on stdin at once.
The module will feed the subprocess one line of data on stdin, and
will then wait until some data is produced by the subprocess on stdout
or stderr.  It will then feed the next line of data on stdin.
.IP "stdout_cb" 4
.IX Item "stdout_cb"
Set up a callback function to get stdout data from the child line-by-line.
The function you supply will be called whenever the child prints a line
onto stdout.  This is the only way to get output from the child while it
is still running, the normal method will give you all the output at once
after the child exits.
.IP "stderr_cb" 4
.IX Item "stderr_cb"
Similar to stdout_cb for stderr data.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
I recommend using at least perl 5.003.
.SH "AUTHORS"
.IX Header "AUTHORS"
Proc::Reliable by Dan Goldwater <dgold at zblob dot com>
.PP
Based on Proc::Short, written by John Hanju Kim <jhkim@fnal.gov>.
.PP
Contributions by Stephen Cope and Jason Robertson.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 by Dan Goldwater, all rights reserved.
Copyright 1999 by John Hanju Kim, all rights reserved.
.PP
This program is free software, you can redistribute it and/or 
modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 907:" 4
.IX Item "Around line 907:"
You forgot a '=back' before '=head1'
                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Proc::Reliable5.16.3pm                       0100644 0001750 0001750 00000037566 12566241513 024360  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Reliable 3"
.TH Reliable 3 "2003-11-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Proc::Reliable \-\- Run external processes reliably with many options.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Proc::Reliable;
.PP
Create a new process object
.PP
.Vb 1
\&   $myproc = Proc::Reliable\->new();
.Ve
.PP
Run a subprocess and collect its output
.PP
.Vb 1
\&   $output = $myproc\->run("/bin/ls \-l");
.Ve
.PP
Check for problems
.PP
.Vb 3
\&   if($myproc\->status()) {
\&     print("problem!\en");
\&   }
.Ve
.PP
Run another subprocess, keeping stdout and stderr separated.
Also, send the subprocess some data on stdin.
.PP
.Vb 6
\&   $msg = "Hello World\en");
\&   $p\->want_single_list(0);
\&   $stdout = $p\->run("/usr/bin/fastmail \- foo@bar.com", $msg);
\&   if($p\->status()) {
\&     print("problem: ", $p\->stderr(), "\en");
\&   }
.Ve
.PP
Another way to get output
.PP
.Vb 1
\&   ($stdout, $stderr, $status, $msg) = $p\->run("/bin/ls \-l");
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Run Modes
.PP
.Vb 5
\& $p\->run("shell\-command\-line");  # Launch a shell process
\& $p\->run("cmdline", "data");     # Launch a shell process with stdin data
\& $p\->run(["cmd", "arg1", ...]);  # Bypass shell processing of arguments
\& $p\->run(sub { ... });           # Launch a perl subroutine
\& $p\->run(\e&subroutine);          # Launch a perl subroutine
.Ve
.PP
Option settings below represent defaults
.PP
.Vb 10
\& $p\->num_tries(1);           # execute the program only once
\& $p\->time_per_try(60);       # time per try 60 sec
\& $p\->maxtime(60);            # set overall timeout
\& $p\->time_btw_tries(5);      # time between tries 5 sec
\& $p\->want_single_list();     # return STDOUT and STDERR together
\& $p\->accept_no_error();      # Re\-try if any STDERR output
\& $p\->pattern_stdout($pat);   # require STDOUT to match regex $pat
\& $p\->pattern_stderr($pat);   # require STDERR to match regex $pat
\& $p\->allow_shell(1);         # allowed to use shell for operation
\& $p\->child_exit_time(1.0);   # timeout for child to exit after it closes stdout
\& $p\->sigterm_exit_time(0.5); # timeout for child to exit after sigterm
\& $p\->sigkill_exit_time(0.5); # timeout for child to exit after sigkill
\& $p\->input_chunking(0);      # feed stdin data line\-by\-line to subprocess
\& $p\->stdin_error_ok(0);      # ok if child exits without reading all stdin
\& $p\->stdout_cb(undef);       # callback function for line\-by\-line stdout
\& $p\->stderr_cb(undef);       # callback function for line\-by\-line stderr
.Ve
.PP
Getting output
.PP
.Vb 4
\& $out = $p\->stdout();        # stdout produced by last run()
\& $err = $p\->stderr();        # stderr produced by last run()
\& $stat = $p\->status();       # exit code produced by last run()
\& $msg = $p\->msg();           # module messages produced by last run()
.Ve
.PP
Debug
.PP
Proc::Reliable::debug($level);         # Turn debug on
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Proc::Reliable is a class for simple, reliable and
configurable subprocess execution in perl.  In particular, it is
especially useful for managing the execution of 'problem' programs
which are likely to fail, hang, or otherwise behave in an unruly manner.
.PP
Proc::Reliable includes all the
functionality of the backticks operator and \fIsystem()\fR functions, plus
many common uses of \fIfork()\fR and \fIexec()\fR, \fIopen2()\fR and \fIopen3()\fR.
Proc::Reliable incorporates a number of options, including 
sending data to the subprocess on \s-1STDIN\s0, collecting \s-1STDOUT\s0 and \s-1STDERR\s0
separately or together, killing hung processes, timouts and automatic retries.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A new process object is created by
.PP
.Vb 1
\&   $myproc = Proc::Reliable\->new();
.Ve
.PP
The default will run a subprocess only once with a 60\-second timeout.
Either shell-like command lines or references 
to perl subroutines can be specified for launching a process in 
background.  A simple list process, for example, can be started 
via the shell as
.PP
.Vb 1
\&   $out = $myproc\->run("ls");
.Ve
.PP
To separate stdout, stderr, and exit status:
.PP
.Vb 1
\&   ($out, $err, $status, $msg) = $myproc\->run("ls");
.Ve
.PP
The output data is also stored within the \f(CW$myproc\fR object for later
retrieval.  You can also run a perl subroutine in a subprocess, with
.PP
.Vb 1
\&   $myproc\->run(sub { return <*>; });
.Ve
.PP
The \fIrun\fR Method will try to run the named process.  If the 
process times out (after \fItime_per_try\fR seconds) or has an
error defined as unacceptable and you would like to re-run it,
you can use the \fInum_tries\fR option.  Use the \fItime_btw_tries\fR
option to set the number of seconds between runs.  This can repeat
until \fImaxtime\fR seconds have elapsed.
.PP
When using \fInum_tries\fR, the user can specify what constitutes an
unacceptable error of \s-1STDOUT\s0 or \s-1STDERR\s0 output \*(-- i.e. demanding a retry.
One common shorthand is to have the \fIrun\fR method retry if there
is any return from \s-1STDERR\s0.
.PP
.Vb 3
\&   $myproc\->accept_no_error();    # Re\-try if any STDERR
\&   $myproc\->pattern_stdout($pat); # require STDOUT to match regex $pat
\&   $myproc\->pattern_stderr($pat); # require STDERR to match regex $pat
.Ve
.PP
Subprocess completion is detected when the process closes all filehandles.
The process must then exit before child_exit_time expires, or it will be
killed.  If the subprocess does not exit, it is sent a \s-1TERM\s0 signal unless
sigterm_exit_time is 0.  then if it does not exit before sigterm_exit_time
expires, it is sent a \s-1KILL\s0 signal unless sigkill_exit_time is 0.  then if
it does not exit before sigkill_exit_time expires an error is generated.
waiting is done in 0.01 second increments.
.PP
Proc::Reliable is not MT-Safe due to signals usage.
.SH "METHODS"
.IX Header "METHODS"
The following methods are available:
.IP "new (Constructor)" 4
.IX Item "new (Constructor)"
Create a new instance of this class by writing either
.Sp
.Vb 1
\&    $proc = new Proc::Reliable;   or   $proc = Proc::Reliable\->new();
.Ve
.Sp
The \fInew\fR method accepts any valid configuration options:
.Sp
.Vb 1
\&    $proc = Proc::Reliable\->new(\*(Aqmaxtime\*(Aq => 200, \*(Aqnum_tries\*(Aq => 3);
.Ve
.IP "run" 4
.IX Item "run"
Run a new process and collect the standard output and standard 
error via separate pipes.
.Sp
.Vb 2
\&  $out = $proc\->run("program\-name");
\& ($out, $err, $status, $msg) = $proc\->run("program\-name");
.Ve
.Sp
by default with a single return value, stdout and stderr are combined
to a single stream and returned.  with 4 return values, stdout and
stderr are separated, and the program exit status is also returned.
\&\f(CW$msg\fR contains messages from Proc::Reliable when errors occur.
Set \fIwant_single_list\fR\|(1) to force stdout and stderr to be combined,
and \fIwant_single_list\fR\|(0) to force them separated.  The results from
\&\fIrun()\fR are stored as member data also:
.Sp
.Vb 9
\&  $proc\->want_single_list(0);
\&  $proc\->run("program");
\&  if($proc\->status) {
\&    print($proc\->stderr);
\&    exit;
\&  }
\&  else {
\&    print($proc\->stdout);
\&  }
.Ve
.Sp
Program exit status is returned in the same format as \fIexec()\fR:
bits 0\-7 set if program exited from a signal, bits 8\-15 are the exit status
on a normal program exit.
.Sp
You can also set up callbacks to run a function of your choice as
each line of stdout and stderr is produced by the child process
using the stdout_cb and stderr_cb options.
.Sp
There are a number of other options.
You can also feed the forked program data on stdin via a second argument to \fIrun()\fR:
.Sp
.Vb 2
\& $myinput = "hello\entest\en";
\& $output = $proc\->run("program\-name", $myinput);
.Ve
.Sp
The first option to \fIrun()\fR supports three forms:
1) string containing command string to execute.  this incurs shell parsing.
2) arrayref containing split command string to execute.  this bypasses shell parsing.
3) coderef to perl function.
The first two options are executed via \fIexec()\fR, so the specifics of incurring shell
parsing are the same.
.Sp
The second option to \fIrun()\fR supports two forms:
1) string containing data to feed on stdin
2) stringref pointing to data to feed on stdin
.Sp
You can start execution of an 
independent Perl function (like \*(L"eval\*(R" except with timeout, 
retries, etc.).  Simply provide the function reference like
.Sp
.Vb 1
\& $output = $proc\->run(\e&perl_function);
.Ve
.Sp
or supply an unnamed subroutine:
.Sp
.Vb 1
\& $output = $proc\->run( sub { sleep(1) } );
.Ve
.Sp
The \fIrun\fR Method returns after the the function finishes, 
one way or another.
.IP "debug" 4
.IX Item "debug"
Switches debug messages on and off \*(-- \fIProc::Reliable::debug\fR\|(1) switches
them on, \fIProc::Reliable::debug\fR\|(0) keeps Proc::Reliable quiet.
.IP "maxtime" 4
.IX Item "maxtime"
Return or set the maximum time in seconds per \fIrun\fR method call.  
Default is 300 seconds (i.e. 5 minutes).
.IP "num_tries" 4
.IX Item "num_tries"
Return or set the maximum number of tries the \fIrun\fR method will 
attempt an operation if there are unallowed errors.  Default is 5.
.IP "time_per_try" 4
.IX Item "time_per_try"
Return or set the maximum time in seconds for each attempt which 
\&\fIrun\fR makes of an operation.  Multiple tries in case of error 
can go longer than this.  Default is 30 seconds.
.IP "time_btw_tries" 4
.IX Item "time_btw_tries"
Return or set the time in seconds between attempted operations 
in case of unacceptable error.  Default is 5 seconds.
.IP "child_exit_time" 4
.IX Item "child_exit_time"
When the subprocess closes stdout, it is assumed to have completed
normal operation.  It is expected to exit within the amount of time
specified.  If it does not exit, it will be killed (with \s-1SIGTERM\s0).
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "sigterm_exit_time" 4
.IX Item "sigterm_exit_time"
If the \fItime_per_try\fR or \fImax_time\fR has been exceeded, or if
\&\fIchild_exit_time\fR action has not succeeded, the subprocess will be
killed with \s-1SIGTERM\s0.  This option specifies the amount of time to allow
the process to exit after closing stdout.
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "sigkill_exit_time" 4
.IX Item "sigkill_exit_time"
Similar to \fIsigterm_exit_time\fR, but a \s-1SIGKILL\s0 is sent instead of a
\&\s-1SIGTERM\s0.  When both options are enabled, the \s-1SIGTERM\s0 is sent first
and \s-1SIGKILL\s0 is then sent after the specified time only if the
subprocess is still alive.
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "input_chunking" 4
.IX Item "input_chunking"
If data is being written to the subprocess on stdin, this option will
cause the module to \fIsplit()\fR the input data at linefeeds, and only feed
the subprocess a line at a time.  This option typically would be used
when the subprocess is an application with a command prompt and does
not work properly when all the data is fed on stdin at once.
The module will feed the subprocess one line of data on stdin, and
will then wait until some data is produced by the subprocess on stdout
or stderr.  It will then feed the next line of data on stdin.
.IP "stdout_cb" 4
.IX Item "stdout_cb"
Set up a callback function to get stdout data from the child line-by-line.
The function you supply will be called whenever the child prints a line
onto stdout.  This is the only way to get output from the child while it
is still running, the normal method will give you all the output at once
after the child exits.
.IP "stderr_cb" 4
.IX Item "stderr_cb"
Similar to stdout_cb for stderr data.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
I recommend using at least perl 5.003.
.SH "AUTHORS"
.IX Header "AUTHORS"
Proc::Reliable by Dan Goldwater <dgold at zblob dot com>
.PP
Based on Proc::Short, written by John Hanju Kim <jhkim@fnal.gov>.
.PP
Contributions by Stephen Cope and Jason Robertson.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 by Dan Goldwater, all rights reserved.
Copyright 1999 by John Hanju Kim, all rights reserved.
.PP
This program is free software, you can redistribute it and/or 
modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 907:" 4
.IX Item "Around line 907:"
You forgot a '=back' before '=head1'
                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Proc::Reliable5.18.3pm                       0100644 0001750 0001750 00000040111 12566241514 024337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Reliable 3"
.TH Reliable 3 "2003-11-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Proc::Reliable \-\- Run external processes reliably with many options.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Proc::Reliable;
.PP
Create a new process object
.PP
.Vb 1
\&   $myproc = Proc::Reliable\->new();
.Ve
.PP
Run a subprocess and collect its output
.PP
.Vb 1
\&   $output = $myproc\->run("/bin/ls \-l");
.Ve
.PP
Check for problems
.PP
.Vb 3
\&   if($myproc\->status()) {
\&     print("problem!\en");
\&   }
.Ve
.PP
Run another subprocess, keeping stdout and stderr separated.
Also, send the subprocess some data on stdin.
.PP
.Vb 6
\&   $msg = "Hello World\en");
\&   $p\->want_single_list(0);
\&   $stdout = $p\->run("/usr/bin/fastmail \- foo@bar.com", $msg);
\&   if($p\->status()) {
\&     print("problem: ", $p\->stderr(), "\en");
\&   }
.Ve
.PP
Another way to get output
.PP
.Vb 1
\&   ($stdout, $stderr, $status, $msg) = $p\->run("/bin/ls \-l");
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Run Modes
.PP
.Vb 5
\& $p\->run("shell\-command\-line");  # Launch a shell process
\& $p\->run("cmdline", "data");     # Launch a shell process with stdin data
\& $p\->run(["cmd", "arg1", ...]);  # Bypass shell processing of arguments
\& $p\->run(sub { ... });           # Launch a perl subroutine
\& $p\->run(\e&subroutine);          # Launch a perl subroutine
.Ve
.PP
Option settings below represent defaults
.PP
.Vb 10
\& $p\->num_tries(1);           # execute the program only once
\& $p\->time_per_try(60);       # time per try 60 sec
\& $p\->maxtime(60);            # set overall timeout
\& $p\->time_btw_tries(5);      # time between tries 5 sec
\& $p\->want_single_list();     # return STDOUT and STDERR together
\& $p\->accept_no_error();      # Re\-try if any STDERR output
\& $p\->pattern_stdout($pat);   # require STDOUT to match regex $pat
\& $p\->pattern_stderr($pat);   # require STDERR to match regex $pat
\& $p\->allow_shell(1);         # allowed to use shell for operation
\& $p\->child_exit_time(1.0);   # timeout for child to exit after it closes stdout
\& $p\->sigterm_exit_time(0.5); # timeout for child to exit after sigterm
\& $p\->sigkill_exit_time(0.5); # timeout for child to exit after sigkill
\& $p\->input_chunking(0);      # feed stdin data line\-by\-line to subprocess
\& $p\->stdin_error_ok(0);      # ok if child exits without reading all stdin
\& $p\->stdout_cb(undef);       # callback function for line\-by\-line stdout
\& $p\->stderr_cb(undef);       # callback function for line\-by\-line stderr
.Ve
.PP
Getting output
.PP
.Vb 4
\& $out = $p\->stdout();        # stdout produced by last run()
\& $err = $p\->stderr();        # stderr produced by last run()
\& $stat = $p\->status();       # exit code produced by last run()
\& $msg = $p\->msg();           # module messages produced by last run()
.Ve
.PP
Debug
.PP
Proc::Reliable::debug($level);         # Turn debug on
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Proc::Reliable is a class for simple, reliable and
configurable subprocess execution in perl.  In particular, it is
especially useful for managing the execution of 'problem' programs
which are likely to fail, hang, or otherwise behave in an unruly manner.
.PP
Proc::Reliable includes all the
functionality of the backticks operator and \fIsystem()\fR functions, plus
many common uses of \fIfork()\fR and \fIexec()\fR, \fIopen2()\fR and \fIopen3()\fR.
Proc::Reliable incorporates a number of options, including 
sending data to the subprocess on \s-1STDIN,\s0 collecting \s-1STDOUT\s0 and \s-1STDERR\s0
separately or together, killing hung processes, timouts and automatic retries.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A new process object is created by
.PP
.Vb 1
\&   $myproc = Proc::Reliable\->new();
.Ve
.PP
The default will run a subprocess only once with a 60\-second timeout.
Either shell-like command lines or references 
to perl subroutines can be specified for launching a process in 
background.  A simple list process, for example, can be started 
via the shell as
.PP
.Vb 1
\&   $out = $myproc\->run("ls");
.Ve
.PP
To separate stdout, stderr, and exit status:
.PP
.Vb 1
\&   ($out, $err, $status, $msg) = $myproc\->run("ls");
.Ve
.PP
The output data is also stored within the \f(CW$myproc\fR object for later
retrieval.  You can also run a perl subroutine in a subprocess, with
.PP
.Vb 1
\&   $myproc\->run(sub { return <*>; });
.Ve
.PP
The \fIrun\fR Method will try to run the named process.  If the 
process times out (after \fItime_per_try\fR seconds) or has an
error defined as unacceptable and you would like to re-run it,
you can use the \fInum_tries\fR option.  Use the \fItime_btw_tries\fR
option to set the number of seconds between runs.  This can repeat
until \fImaxtime\fR seconds have elapsed.
.PP
When using \fInum_tries\fR, the user can specify what constitutes an
unacceptable error of \s-1STDOUT\s0 or \s-1STDERR\s0 output \*(-- i.e. demanding a retry.
One common shorthand is to have the \fIrun\fR method retry if there
is any return from \s-1STDERR.  \s0
.PP
.Vb 3
\&   $myproc\->accept_no_error();    # Re\-try if any STDERR
\&   $myproc\->pattern_stdout($pat); # require STDOUT to match regex $pat
\&   $myproc\->pattern_stderr($pat); # require STDERR to match regex $pat
.Ve
.PP
Subprocess completion is detected when the process closes all filehandles.
The process must then exit before child_exit_time expires, or it will be
killed.  If the subprocess does not exit, it is sent a \s-1TERM\s0 signal unless
sigterm_exit_time is 0.  then if it does not exit before sigterm_exit_time
expires, it is sent a \s-1KILL\s0 signal unless sigkill_exit_time is 0.  then if
it does not exit before sigkill_exit_time expires an error is generated.
waiting is done in 0.01 second increments.
.PP
Proc::Reliable is not MT-Safe due to signals usage.
.SH "METHODS"
.IX Header "METHODS"
The following methods are available:
.IP "new (Constructor)" 4
.IX Item "new (Constructor)"
Create a new instance of this class by writing either
.Sp
.Vb 1
\&    $proc = new Proc::Reliable;   or   $proc = Proc::Reliable\->new();
.Ve
.Sp
The \fInew\fR method accepts any valid configuration options:
.Sp
.Vb 1
\&    $proc = Proc::Reliable\->new(\*(Aqmaxtime\*(Aq => 200, \*(Aqnum_tries\*(Aq => 3);
.Ve
.IP "run" 4
.IX Item "run"
Run a new process and collect the standard output and standard 
error via separate pipes.
.Sp
.Vb 2
\&  $out = $proc\->run("program\-name");
\& ($out, $err, $status, $msg) = $proc\->run("program\-name");
.Ve
.Sp
by default with a single return value, stdout and stderr are combined
to a single stream and returned.  with 4 return values, stdout and
stderr are separated, and the program exit status is also returned.
\&\f(CW$msg\fR contains messages from Proc::Reliable when errors occur.
Set \fIwant_single_list\fR\|(1) to force stdout and stderr to be combined,
and \fIwant_single_list\fR\|(0) to force them separated.  The results from
\&\fIrun()\fR are stored as member data also:
.Sp
.Vb 9
\&  $proc\->want_single_list(0);
\&  $proc\->run("program");
\&  if($proc\->status) {
\&    print($proc\->stderr);
\&    exit;
\&  }
\&  else {
\&    print($proc\->stdout);
\&  }
.Ve
.Sp
Program exit status is returned in the same format as \fIexec()\fR:
bits 0\-7 set if program exited from a signal, bits 8\-15 are the exit status
on a normal program exit.
.Sp
You can also set up callbacks to run a function of your choice as
each line of stdout and stderr is produced by the child process
using the stdout_cb and stderr_cb options.
.Sp
There are a number of other options.
You can also feed the forked program data on stdin via a second argument to \fIrun()\fR:
.Sp
.Vb 2
\& $myinput = "hello\entest\en";
\& $output = $proc\->run("program\-name", $myinput);
.Ve
.Sp
The first option to \fIrun()\fR supports three forms:
1) string containing command string to execute.  this incurs shell parsing.
2) arrayref containing split command string to execute.  this bypasses shell parsing.
3) coderef to perl function.
The first two options are executed via \fIexec()\fR, so the specifics of incurring shell
parsing are the same.
.Sp
The second option to \fIrun()\fR supports two forms:
1) string containing data to feed on stdin
2) stringref pointing to data to feed on stdin
.Sp
You can start execution of an 
independent Perl function (like \*(L"eval\*(R" except with timeout, 
retries, etc.).  Simply provide the function reference like
.Sp
.Vb 1
\& $output = $proc\->run(\e&perl_function);
.Ve
.Sp
or supply an unnamed subroutine:
.Sp
.Vb 1
\& $output = $proc\->run( sub { sleep(1) } );
.Ve
.Sp
The \fIrun\fR Method returns after the the function finishes, 
one way or another.
.IP "debug" 4
.IX Item "debug"
Switches debug messages on and off \*(-- \fIProc::Reliable::debug\fR\|(1) switches
them on, \fIProc::Reliable::debug\fR\|(0) keeps Proc::Reliable quiet.
.IP "maxtime" 4
.IX Item "maxtime"
Return or set the maximum time in seconds per \fIrun\fR method call.  
Default is 300 seconds (i.e. 5 minutes).
.IP "num_tries" 4
.IX Item "num_tries"
Return or set the maximum number of tries the \fIrun\fR method will 
attempt an operation if there are unallowed errors.  Default is 5.
.IP "time_per_try" 4
.IX Item "time_per_try"
Return or set the maximum time in seconds for each attempt which 
\&\fIrun\fR makes of an operation.  Multiple tries in case of error 
can go longer than this.  Default is 30 seconds.
.IP "time_btw_tries" 4
.IX Item "time_btw_tries"
Return or set the time in seconds between attempted operations 
in case of unacceptable error.  Default is 5 seconds.
.IP "child_exit_time" 4
.IX Item "child_exit_time"
When the subprocess closes stdout, it is assumed to have completed
normal operation.  It is expected to exit within the amount of time
specified.  If it does not exit, it will be killed (with \s-1SIGTERM\s0).
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "sigterm_exit_time" 4
.IX Item "sigterm_exit_time"
If the \fItime_per_try\fR or \fImax_time\fR has been exceeded, or if
\&\fIchild_exit_time\fR action has not succeeded, the subprocess will be
killed with \s-1SIGTERM. \s0 This option specifies the amount of time to allow
the process to exit after closing stdout.
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "sigkill_exit_time" 4
.IX Item "sigkill_exit_time"
Similar to \fIsigterm_exit_time\fR, but a \s-1SIGKILL\s0 is sent instead of a
\&\s-1SIGTERM. \s0 When both options are enabled, the \s-1SIGTERM\s0 is sent first
and \s-1SIGKILL\s0 is then sent after the specified time only if the
subprocess is still alive.
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "input_chunking" 4
.IX Item "input_chunking"
If data is being written to the subprocess on stdin, this option will
cause the module to \fIsplit()\fR the input data at linefeeds, and only feed
the subprocess a line at a time.  This option typically would be used
when the subprocess is an application with a command prompt and does
not work properly when all the data is fed on stdin at once.
The module will feed the subprocess one line of data on stdin, and
will then wait until some data is produced by the subprocess on stdout
or stderr.  It will then feed the next line of data on stdin.
.IP "stdout_cb" 4
.IX Item "stdout_cb"
Set up a callback function to get stdout data from the child line-by-line.
The function you supply will be called whenever the child prints a line
onto stdout.  This is the only way to get output from the child while it
is still running, the normal method will give you all the output at once
after the child exits.
.IP "stderr_cb" 4
.IX Item "stderr_cb"
Similar to stdout_cb for stderr data.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
I recommend using at least perl 5.003.
.SH "AUTHORS"
.IX Header "AUTHORS"
Proc::Reliable by Dan Goldwater <dgold at zblob dot com>
.PP
Based on Proc::Short, written by John Hanju Kim <jhkim@fnal.gov>.
.PP
Contributions by Stephen Cope and Jason Robertson.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 by Dan Goldwater, all rights reserved.
Copyright 1999 by John Hanju Kim, all rights reserved.
.PP
This program is free software, you can redistribute it and/or 
modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 907:" 4
.IX Item "Around line 907:"
You forgot a '=back' before '=head1'
                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Proc::test_intercept.3pm                     0100644 0001750 0001750 00000011013 12566241514 025337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "test_intercept 3"
.TH test_intercept 3 "2003-11-21" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "test User Intercept Methods"
.IX Header "test User Intercept Methods"
This performs very minimal testing and was written to test
some minor changes I made to Proc::Reliable so that \s-1STDERR\s0
was properly routed to user methods \s-1AND\s0 any left over strings
were passed (those not terminated by an ending newline).
.PP
Written by Robb Canfield <robb at canfield dot com>
.PP
Date 2003\-11\-21
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 14:" 4
.IX Item "Around line 14:"
\&'=end' without a target?
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Proc::test_intercept5.16.3pm                 0100644 0001750 0001750 00000010472 12566241513 025660  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "test_intercept 3"
.TH test_intercept 3 "2003-11-21" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "test User Intercept Methods"
.IX Header "test User Intercept Methods"
This performs very minimal testing and was written to test
some minor changes I made to Proc::Reliable so that \s-1STDERR\s0
was properly routed to user methods \s-1AND\s0 any left over strings
were passed (those not terminated by an ending newline).
.PP
Written by Robb Canfield <robb at canfield dot com>
.PP
Date 2003\-11\-21
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 14:" 4
.IX Item "Around line 14:"
\&'=end' without a target?
                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Proc::test_intercept5.18.3pm                 0100644 0001750 0001750 00000011013 12566241514 025653  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "test_intercept 3"
.TH test_intercept 3 "2003-11-21" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "test User Intercept Methods"
.IX Header "test User Intercept Methods"
This performs very minimal testing and was written to test
some minor changes I made to Proc::Reliable so that \s-1STDERR\s0
was properly routed to user methods \s-1AND\s0 any left over strings
were passed (those not terminated by an ending newline).
.PP
Written by Robb Canfield <robb at canfield dot com>
.PP
Date 2003\-11\-21
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 14:" 4
.IX Item "Around line 14:"
\&'=end' without a target?
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_SSLeay.3ssl                             0120777 0001750 0001750 00000000000 12620245063 030172  2RAND_set_rand_method.3ssl                                                                           ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_add.3ssl                                0100644 0001750 0001750 00000015604 12566201134 023020  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RAND_add 3"
.TH RAND_add 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RAND_add, RAND_seed, RAND_status, RAND_event, RAND_screen \- add
entropy to the PRNG
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rand.h>
\&
\& void RAND_seed(const void *buf, int num);
\&
\& void RAND_add(const void *buf, int num, double entropy);
\&
\& int  RAND_status(void);
\&
\& int  RAND_event(UINT iMsg, WPARAM wParam, LPARAM lParam);
\& void RAND_screen(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIRAND_add()\fR mixes the \fBnum\fR bytes at \fBbuf\fR into the \s-1PRNG\s0 state. Thus,
if the data at \fBbuf\fR are unpredictable to an adversary, this
increases the uncertainty about the state and makes the \s-1PRNG\s0 output
less predictable. Suitable input comes from user interaction (random
key presses, mouse movements) and certain hardware events. The
\&\fBentropy\fR argument is (the lower bound of) an estimate of how much
randomness is contained in \fBbuf\fR, measured in bytes. Details about
sources of randomness and how to estimate their entropy can be found
in the literature, e.g. \s-1RFC 1750.\s0
.PP
\&\fIRAND_add()\fR may be called with sensitive data such as user entered
passwords. The seed values cannot be recovered from the \s-1PRNG\s0 output.
.PP
OpenSSL makes sure that the \s-1PRNG\s0 state is unique for each thread. On
systems that provide \f(CW\*(C`/dev/urandom\*(C'\fR, the randomness device is used
to seed the \s-1PRNG\s0 transparently. However, on all other systems, the
application is responsible for seeding the \s-1PRNG\s0 by calling \fIRAND_add()\fR,
\&\fIRAND_egd\fR\|(3)
or \fIRAND_load_file\fR\|(3).
.PP
\&\fIRAND_seed()\fR is equivalent to \fIRAND_add()\fR when \fBnum == entropy\fR.
.PP
\&\fIRAND_event()\fR collects the entropy from Windows events such as mouse
movements and other user interaction. It should be called with the
\&\fBiMsg\fR, \fBwParam\fR and \fBlParam\fR arguments of \fIall\fR messages sent to
the window procedure. It will estimate the entropy contained in the
event message (if any), and add it to the \s-1PRNG.\s0 The program can then
process the messages as usual.
.PP
The \fIRAND_screen()\fR function is available for the convenience of Windows
programmers. It adds the current contents of the screen to the \s-1PRNG.\s0
For applications that can catch Windows events, seeding the \s-1PRNG\s0 by
calling \fIRAND_event()\fR is a significantly better source of
randomness. It should be noted that both methods cannot be used on
servers that run without user interaction.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRAND_status()\fR and \fIRAND_event()\fR return 1 if the \s-1PRNG\s0 has been seeded
with enough data, 0 otherwise.
.PP
The other functions do not return values.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrand\fR\|(3), \fIRAND_egd\fR\|(3),
\&\fIRAND_load_file\fR\|(3), \fIRAND_cleanup\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRAND_seed()\fR and \fIRAND_screen()\fR are available in all versions of SSLeay
and OpenSSL. \fIRAND_add()\fR and \fIRAND_status()\fR have been added in OpenSSL
0.9.5, \fIRAND_event()\fR in OpenSSL 0.9.5a.
                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_bytes.3ssl                              0100644 0001750 0001750 00000013061 12566201134 023411  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RAND_bytes 3"
.TH RAND_bytes 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RAND_bytes, RAND_pseudo_bytes \- generate random data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rand.h>
\&
\& int RAND_bytes(unsigned char *buf, int num);
\&
\& int RAND_pseudo_bytes(unsigned char *buf, int num);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIRAND_bytes()\fR puts \fBnum\fR cryptographically strong pseudo-random bytes
into \fBbuf\fR. An error occurs if the \s-1PRNG\s0 has not been seeded with
enough randomness to ensure an unpredictable byte sequence.
.PP
\&\fIRAND_pseudo_bytes()\fR puts \fBnum\fR pseudo-random bytes into \fBbuf\fR.
Pseudo-random byte sequences generated by \fIRAND_pseudo_bytes()\fR will be
unique if they are of sufficient length, but are not necessarily
unpredictable. They can be used for non-cryptographic purposes and for
certain purposes in cryptographic protocols, but usually not for key
generation etc.
.PP
The contents of \fBbuf\fR is mixed into the entropy pool before retrieving
the new pseudo-random bytes unless disabled at compile time (see \s-1FAQ\s0).
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRAND_bytes()\fR returns 1 on success, 0 otherwise. The error code can be
obtained by \fIERR_get_error\fR\|(3). \fIRAND_pseudo_bytes()\fR returns 1 if the
bytes generated are cryptographically strong, 0 otherwise. Both
functions return \-1 if they are not supported by the current \s-1RAND\s0
method.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrand\fR\|(3), \fIERR_get_error\fR\|(3),
\&\fIRAND_add\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRAND_bytes()\fR is available in all versions of SSLeay and OpenSSL.  It
has a return value since OpenSSL 0.9.5. \fIRAND_pseudo_bytes()\fR was added
in OpenSSL 0.9.5.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_cleanup.3ssl                            0100644 0001750 0001750 00000010613 12566201135 023713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RAND_cleanup 3"
.TH RAND_cleanup 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RAND_cleanup \- erase the PRNG state
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rand.h>
\&
\& void RAND_cleanup(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIRAND_cleanup()\fR erases the memory used by the \s-1PRNG.\s0
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
\&\fIRAND_cleanup()\fR returns no value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrand\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRAND_cleanup()\fR is available in all versions of SSLeay and OpenSSL.
                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_egd.3ssl                                0100644 0001750 0001750 00000016754 12566201135 023037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RAND_egd 3"
.TH RAND_egd 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RAND_egd \- query entropy gathering daemon
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rand.h>
\&
\& int RAND_egd(const char *path);
\& int RAND_egd_bytes(const char *path, int bytes);
\&
\& int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIRAND_egd()\fR queries the entropy gathering daemon \s-1EGD\s0 on socket \fBpath\fR.
It queries 255 bytes and uses \fIRAND_add\fR\|(3) to seed the
OpenSSL built-in \s-1PRNG.\s0 RAND_egd(path) is a wrapper for
RAND_egd_bytes(path, 255);
.PP
\&\fIRAND_egd_bytes()\fR queries the entropy gathering daemon \s-1EGD\s0 on socket \fBpath\fR.
It queries \fBbytes\fR bytes and uses \fIRAND_add\fR\|(3) to seed the
OpenSSL built-in \s-1PRNG.\s0
This function is more flexible than \fIRAND_egd()\fR.
When only one secret key must
be generated, it is not necessary to request the full amount 255 bytes from
the \s-1EGD\s0 socket. This can be advantageous, since the amount of entropy
that can be retrieved from \s-1EGD\s0 over time is limited.
.PP
\&\fIRAND_query_egd_bytes()\fR performs the actual query of the \s-1EGD\s0 daemon on socket
\&\fBpath\fR. If \fBbuf\fR is given, \fBbytes\fR bytes are queried and written into
\&\fBbuf\fR. If \fBbuf\fR is \s-1NULL, \s0\fBbytes\fR bytes are queried and used to seed the
OpenSSL built-in \s-1PRNG\s0 using \fIRAND_add\fR\|(3).
.SH "NOTES"
.IX Header "NOTES"
On systems without /dev/*random devices providing entropy from the kernel,
the \s-1EGD\s0 entropy gathering daemon can be used to collect entropy. It provides
a socket interface through which entropy can be gathered in chunks up to
255 bytes. Several chunks can be queried during one connection.
.PP
\&\s-1EGD\s0 is available from http://www.lothar.com/tech/crypto/ (\f(CW\*(C`perl
Makefile.PL; make; make install\*(C'\fR to install). It is run as \fBegd\fR
\&\fIpath\fR, where \fIpath\fR is an absolute path designating a socket. When
\&\fIRAND_egd()\fR is called with that path as an argument, it tries to read
random bytes that \s-1EGD\s0 has collected. \fIRAND_egd()\fR retrieves entropy from the
daemon using the daemon's \*(L"non-blocking read\*(R" command which shall
be answered immediately by the daemon without waiting for additional
entropy to be collected. The write and read socket operations in the
communication are blocking.
.PP
Alternatively, the EGD-interface compatible daemon \s-1PRNGD\s0 can be used. It is
available from
http://prngd.sourceforge.net/ .
\&\s-1PRNGD\s0 does employ an internal \s-1PRNG\s0 itself and can therefore never run
out of entropy.
.PP
OpenSSL automatically queries \s-1EGD\s0 when entropy is requested via \fIRAND_bytes()\fR
or the status is checked via \fIRAND_status()\fR for the first time, if the socket
is located at /var/run/egd\-pool, /dev/egd\-pool or /etc/egd\-pool.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
\&\fIRAND_egd()\fR and \fIRAND_egd_bytes()\fR return the number of bytes read from the
daemon on success, and \-1 if the connection failed or the daemon did not
return enough data to fully seed the \s-1PRNG.\s0
.PP
\&\fIRAND_query_egd_bytes()\fR returns the number of bytes read from the daemon on
success, and \-1 if the connection failed. The \s-1PRNG\s0 state is not considered.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrand\fR\|(3), \fIRAND_add\fR\|(3),
\&\fIRAND_cleanup\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRAND_egd()\fR is available since OpenSSL 0.9.5.
.PP
\&\fIRAND_egd_bytes()\fR is available since OpenSSL 0.9.6.
.PP
\&\fIRAND_query_egd_bytes()\fR is available since OpenSSL 0.9.7.
.PP
The automatic query of /var/run/egd\-pool et al was added in OpenSSL 0.9.7.
                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_event.3ssl                              0120777 0001750 0001750 00000000000 12620245063 025544  2RAND_add.3ssl                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_file_name.3ssl                          0120777 0001750 0001750 00000000000 12620245063 027530  2RAND_load_file.3ssl                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_get_rand_method.3ssl                    0120777 0001750 0001750 00000000000 12620245063 032155  2RAND_set_rand_method.3ssl                                                                           ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_load_file.3ssl                          0100644 0001750 0001750 00000013224 12566201135 024203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RAND_load_file 3"
.TH RAND_load_file 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RAND_load_file, RAND_write_file, RAND_file_name \- PRNG seed file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rand.h>
\&
\& const char *RAND_file_name(char *buf, size_t num);
\&
\& int RAND_load_file(const char *filename, long max_bytes);
\&
\& int RAND_write_file(const char *filename);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIRAND_file_name()\fR generates a default path for the random seed
file. \fBbuf\fR points to a buffer of size \fBnum\fR in which to store the
filename. The seed file is \f(CW$RANDFILE\fR if that environment variable is
set, \f(CW$HOME\fR/.rnd otherwise. If \f(CW$HOME\fR is not set either, or \fBnum\fR is
too small for the path name, an error occurs.
.PP
\&\fIRAND_load_file()\fR reads a number of bytes from file \fBfilename\fR and
adds them to the \s-1PRNG.\s0 If \fBmax_bytes\fR is non-negative,
up to to \fBmax_bytes\fR are read; starting with OpenSSL 0.9.5,
if \fBmax_bytes\fR is \-1, the complete file is read.
.PP
\&\fIRAND_write_file()\fR writes a number of random bytes (currently 1024) to
file \fBfilename\fR which can be used to initialize the \s-1PRNG\s0 by calling
\&\fIRAND_load_file()\fR in a later session.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRAND_load_file()\fR returns the number of bytes read.
.PP
\&\fIRAND_write_file()\fR returns the number of bytes written, and \-1 if the
bytes written were generated without appropriate seed.
.PP
\&\fIRAND_file_name()\fR returns a pointer to \fBbuf\fR on success, and \s-1NULL\s0 on
error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrand\fR\|(3), \fIRAND_add\fR\|(3), \fIRAND_cleanup\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRAND_load_file()\fR, \fIRAND_write_file()\fR and \fIRAND_file_name()\fR are available in
all versions of SSLeay and OpenSSL.
                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_pseudo_bytes.3ssl                       0120777 0001750 0001750 00000000000 12620245063 027526  2RAND_bytes.3ssl                                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_screen.3ssl                             0120777 0001750 0001750 00000000000 12620245063 025702  2RAND_add.3ssl                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_seed.3ssl                               0120777 0001750 0001750 00000000000 12620245063 025343  2RAND_add.3ssl                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_set_rand_method.3ssl                    0100644 0001750 0001750 00000016316 12566201135 025431  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RAND_set_rand_method 3"
.TH RAND_set_rand_method 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RAND_set_rand_method, RAND_get_rand_method, RAND_SSLeay \- select RAND method
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rand.h>
\&
\& void RAND_set_rand_method(const RAND_METHOD *meth);
\&
\& const RAND_METHOD *RAND_get_rand_method(void);
\&
\& RAND_METHOD *RAND_SSLeay(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \fB\s-1RAND_METHOD\s0\fR specifies the functions that OpenSSL uses for random number
generation. By modifying the method, alternative implementations such as
hardware RNGs may be used. \s-1IMPORTANT:\s0 See the \s-1NOTES\s0 section for important
information about how these \s-1RAND API\s0 functions are affected by the use of
\&\fB\s-1ENGINE\s0\fR \s-1API\s0 calls.
.PP
Initially, the default \s-1RAND_METHOD\s0 is the OpenSSL internal implementation, as
returned by \fIRAND_SSLeay()\fR.
.PP
\&\fIRAND_set_default_method()\fR makes \fBmeth\fR the method for \s-1PRNG\s0 use. \fB\s-1NB\s0\fR: This is
true only whilst no \s-1ENGINE\s0 has been set as a default for \s-1RAND,\s0 so this function
is no longer recommended.
.PP
\&\fIRAND_get_default_method()\fR returns a pointer to the current \s-1RAND_METHOD.\s0
However, the meaningfulness of this result is dependent on whether the \s-1ENGINE
API\s0 is being used, so this function is no longer recommended.
.SH "THE RAND_METHOD STRUCTURE"
.IX Header "THE RAND_METHOD STRUCTURE"
.Vb 9
\& typedef struct rand_meth_st
\& {
\&        void (*seed)(const void *buf, int num);
\&        int (*bytes)(unsigned char *buf, int num);
\&        void (*cleanup)(void);
\&        void (*add)(const void *buf, int num, int entropy);
\&        int (*pseudorand)(unsigned char *buf, int num);
\&        int (*status)(void);
\& } RAND_METHOD;
.Ve
.PP
The components point to the implementation of \fIRAND_seed()\fR,
\&\fIRAND_bytes()\fR, \fIRAND_cleanup()\fR, \fIRAND_add()\fR, \fIRAND_pseudo_rand()\fR
and \fIRAND_status()\fR.
Each component may be \s-1NULL\s0 if the function is not implemented.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRAND_set_rand_method()\fR returns no value. \fIRAND_get_rand_method()\fR and
\&\fIRAND_SSLeay()\fR return pointers to the respective methods.
.SH "NOTES"
.IX Header "NOTES"
As of version 0.9.7, \s-1RAND_METHOD\s0 implementations are grouped together with other
algorithmic APIs (eg. \s-1RSA_METHOD, EVP_CIPHER,\s0 etc) in \fB\s-1ENGINE\s0\fR modules. If a
default \s-1ENGINE\s0 is specified for \s-1RAND\s0 functionality using an \s-1ENGINE API\s0 function,
that will override any \s-1RAND\s0 defaults set using the \s-1RAND API \s0(ie.
\&\fIRAND_set_rand_method()\fR). For this reason, the \s-1ENGINE API\s0 is the recommended way
to control default implementations for use in \s-1RAND\s0 and other cryptographic
algorithms.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrand\fR\|(3), \fIengine\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRAND_set_rand_method()\fR, \fIRAND_get_rand_method()\fR and \fIRAND_SSLeay()\fR are
available in all versions of OpenSSL.
.PP
In the engine version of version 0.9.6, \fIRAND_set_rand_method()\fR was altered to
take an \s-1ENGINE\s0 pointer as its argument. As of version 0.9.7, that has been
reverted as the \s-1ENGINE API\s0 transparently overrides \s-1RAND\s0 defaults if used,
otherwise \s-1RAND API\s0 functions work as before. \fIRAND_set_rand_engine()\fR was also
introduced in version 0.9.7.
                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_status.3ssl                             0120777 0001750 0001750 00000000000 12620245063 025746  2RAND_add.3ssl                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RAND_write_file.3ssl                         0120777 0001750 0001750 00000000000 12620245063 027742  2RAND_load_file.3ssl                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RC4_set_key.3ssl                             0120777 0001750 0001750 00000000000 12620245063 025066  2rc4.3ssl                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RIPEMD160.3ssl                               0120777 0001750 0001750 00000000000 12620245063 024752  2ripemd.3ssl                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RIPEMD160_Final.3ssl                         0120777 0001750 0001750 00000000000 12620245063 026063  2ripemd.3ssl                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RIPEMD160_Init.3ssl                          0120777 0001750 0001750 00000000000 12620245063 025735  2ripemd.3ssl                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RIPEMD160_Update.3ssl                        0120777 0001750 0001750 00000000000 12620245063 026254  2ripemd.3ssl                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_PKCS1_SSLeay.3ssl                        0120777 0001750 0001750 00000000000 12620245063 027671  2RSA_set_method.3ssl                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_blinding_off.3ssl                        0120777 0001750 0001750 00000000000 12620245063 030377  2RSA_blinding_on.3ssl                                                                                ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_blinding_on.3ssl                         0100644 0001750 0001750 00000012171 12566201136 024451  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_blinding_on 3"
.TH RSA_blinding_on 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_blinding_on, RSA_blinding_off \- protect the RSA operation from timing attacks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_blinding_on(RSA *rsa, BN_CTX *ctx);
\&
\& void RSA_blinding_off(RSA *rsa);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1RSA\s0 is vulnerable to timing attacks. In a setup where attackers can
measure the time of \s-1RSA\s0 decryption or signature operations, blinding
must be used to protect the \s-1RSA\s0 operation from that attack.
.PP
\&\fIRSA_blinding_on()\fR turns blinding on for key \fBrsa\fR and generates a
random blinding factor. \fBctx\fR is \fB\s-1NULL\s0\fR or a pre-allocated and
initialized \fB\s-1BN_CTX\s0\fR. The random number generator must be seeded
prior to calling \fIRSA_blinding_on()\fR.
.PP
\&\fIRSA_blinding_off()\fR turns blinding off and frees the memory used for
the blinding factor.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRSA_blinding_on()\fR returns 1 on success, and 0 if an error occurred.
.PP
\&\fIRSA_blinding_off()\fR returns no value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrsa\fR\|(3), \fIrand\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_blinding_on()\fR and \fIRSA_blinding_off()\fR appeared in SSLeay 0.9.0.
                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_check_key.3ssl                           0100644 0001750 0001750 00000014702 12566201136 024116  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_check_key 3"
.TH RSA_check_key 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_check_key \- validate private RSA keys
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_check_key(RSA *rsa);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This function validates \s-1RSA\s0 keys. It checks that \fBp\fR and \fBq\fR are
in fact prime, and that \fBn = p*q\fR.
.PP
It also checks that \fBd*e = 1 mod (p\-1*q\-1)\fR,
and that \fBdmp1\fR, \fBdmq1\fR and \fBiqmp\fR are set correctly or are \fB\s-1NULL\s0\fR.
.PP
As such, this function can not be used with any arbitrary \s-1RSA\s0 key object,
even if it is otherwise fit for regular \s-1RSA\s0 operation. See \fB\s-1NOTES\s0\fR for more
information.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
\&\fIRSA_check_key()\fR returns 1 if \fBrsa\fR is a valid \s-1RSA\s0 key, and 0 otherwise.
\&\-1 is returned if an error occurs while checking the key.
.PP
If the key is invalid or an error occurred, the reason code can be
obtained using \fIERR_get_error\fR\|(3).
.SH "NOTES"
.IX Header "NOTES"
This function does not work on \s-1RSA\s0 public keys that have only the modulus
and public exponent elements populated. It performs integrity checks on all
the \s-1RSA\s0 key material, so the \s-1RSA\s0 key structure must contain all the private
key data too.
.PP
Unlike most other \s-1RSA\s0 functions, this function does \fBnot\fR work
transparently with any underlying \s-1ENGINE\s0 implementation because it uses the
key data in the \s-1RSA\s0 structure directly. An \s-1ENGINE\s0 implementation can
override the way key data is stored and handled, and can even provide
support for \s-1HSM\s0 keys \- in which case the \s-1RSA\s0 structure may contain \fBno\fR
key data at all! If the \s-1ENGINE\s0 in question is only being used for
acceleration or analysis purposes, then in all likelihood the \s-1RSA\s0 key data
is complete and untouched, but this can't be assumed in the general case.
.SH "BUGS"
.IX Header "BUGS"
A method of verifying the \s-1RSA\s0 key using opaque \s-1RSA API\s0 functions might need
to be considered. Right now \fIRSA_check_key()\fR simply uses the \s-1RSA\s0 structure
elements directly, bypassing the \s-1RSA_METHOD\s0 table altogether (and
completely violating encapsulation and object-orientation in the process).
The best fix will probably be to introduce a \*(L"\fIcheck_key()\fR\*(R" handler to the
\&\s-1RSA_METHOD\s0 function table so that alternative implementations can also
provide their own verifiers.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrsa\fR\|(3), \fIERR_get_error\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_check_key()\fR appeared in OpenSSL 0.9.4.
                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_flags.3ssl                               0120777 0001750 0001750 00000000000 12620245063 026724  2RSA_set_method.3ssl                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_free.3ssl                                0120777 0001750 0001750 00000000000 12620245063 025207  2RSA_new.3ssl                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_generate_key.3ssl                        0100644 0001750 0001750 00000013366 12566201136 024640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_generate_key 3"
.TH RSA_generate_key 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_generate_key \- generate RSA key pair
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& RSA *RSA_generate_key(int num, unsigned long e,
\&    void (*callback)(int,int,void *), void *cb_arg);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIRSA_generate_key()\fR generates a key pair and returns it in a newly
allocated \fB\s-1RSA\s0\fR structure. The pseudo-random number generator must
be seeded prior to calling \fIRSA_generate_key()\fR.
.PP
The modulus size will be \fBnum\fR bits, and the public exponent will be
\&\fBe\fR. Key sizes with \fBnum\fR < 1024 should be considered insecure.
The exponent is an odd number, typically 3, 17 or 65537.
.PP
A callback function may be used to provide feedback about the
progress of the key generation. If \fBcallback\fR is not \fB\s-1NULL\s0\fR, it
will be called as follows:
.IP "\(bu" 4
While a random prime number is generated, it is called as
described in \fIBN_generate_prime\fR\|(3).
.IP "\(bu" 4
When the n\-th randomly generated prime is rejected as not
suitable for the key, \fBcallback(2, n, cb_arg)\fR is called.
.IP "\(bu" 4
When a random p has been found with p\-1 relatively prime to \fBe\fR,
it is called as \fBcallback(3, 0, cb_arg)\fR.
.PP
The process is then repeated for prime q with \fBcallback(3, 1, cb_arg)\fR.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
If key generation fails, \fIRSA_generate_key()\fR returns \fB\s-1NULL\s0\fR; the
error codes can be obtained by \fIERR_get_error\fR\|(3).
.SH "BUGS"
.IX Header "BUGS"
\&\fBcallback(2, x, cb_arg)\fR is used with two different meanings.
.PP
\&\fIRSA_generate_key()\fR goes into an infinite loop for illegal input values.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fIrand\fR\|(3), \fIrsa\fR\|(3),
\&\fIRSA_free\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
The \fBcb_arg\fR argument was added in SSLeay 0.9.0.
                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_get_default_method.3ssl                  0120777 0001750 0001750 00000000000 12620245063 031453  2RSA_set_method.3ssl                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_get_ex_data.3ssl                         0120777 0001750 0001750 00000000000 12620245063 031254  2RSA_get_ex_new_index.3ssl                                                                           ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_get_ex_new_index.3ssl                    0100644 0001750 0001750 00000023270 12566201137 025505  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_get_ex_new_index 3"
.TH RSA_get_ex_new_index 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_get_ex_new_index, RSA_set_ex_data, RSA_get_ex_data \- add application specific data to RSA structures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_get_ex_new_index(long argl, void *argp,
\&                CRYPTO_EX_new *new_func,
\&                CRYPTO_EX_dup *dup_func,
\&                CRYPTO_EX_free *free_func);
\&
\& int RSA_set_ex_data(RSA *r, int idx, void *arg);
\&
\& void *RSA_get_ex_data(RSA *r, int idx);
\&
\& typedef int CRYPTO_EX_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
\&                           int idx, long argl, void *argp);
\& typedef void CRYPTO_EX_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
\&                             int idx, long argl, void *argp);
\& typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d,
\&                           int idx, long argl, void *argp);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Several OpenSSL structures can have application specific data attached to them.
This has several potential uses, it can be used to cache data associated with
a structure (for example the hash of some part of the structure) or some
additional data (for example a handle to the data in an external library).
.PP
Since the application data can be anything at all it is passed and retrieved
as a \fBvoid *\fR type.
.PP
The \fB\f(BIRSA_get_ex_new_index()\fB\fR function is initially called to \*(L"register\*(R" some
new application specific data. It takes three optional function pointers which
are called when the parent structure (in this case an \s-1RSA\s0 structure) is
initially created, when it is copied and when it is freed up. If any or all of
these function pointer arguments are not used they should be set to \s-1NULL.\s0 The
precise manner in which these function pointers are called is described in more
detail below. \fB\f(BIRSA_get_ex_new_index()\fB\fR also takes additional long and pointer
parameters which will be passed to the supplied functions but which otherwise
have no special meaning. It returns an \fBindex\fR which should be stored
(typically in a static variable) and passed used in the \fBidx\fR parameter in
the remaining functions. Each successful call to \fB\f(BIRSA_get_ex_new_index()\fB\fR
will return an index greater than any previously returned, this is important
because the optional functions are called in order of increasing index value.
.PP
\&\fB\f(BIRSA_set_ex_data()\fB\fR is used to set application specific data, the data is
supplied in the \fBarg\fR parameter and its precise meaning is up to the
application.
.PP
\&\fB\f(BIRSA_get_ex_data()\fB\fR is used to retrieve application specific data. The data
is returned to the application, this will be the same value as supplied to
a previous \fB\f(BIRSA_set_ex_data()\fB\fR call.
.PP
\&\fB\f(BInew_func()\fB\fR is called when a structure is initially allocated (for example
with \fB\f(BIRSA_new()\fB\fR. The parent structure members will not have any meaningful
values at this point. This function will typically be used to allocate any
application specific structure.
.PP
\&\fB\f(BIfree_func()\fB\fR is called when a structure is being freed up. The dynamic parent
structure members should not be accessed because they will be freed up when
this function is called.
.PP
\&\fB\f(BInew_func()\fB\fR and \fB\f(BIfree_func()\fB\fR take the same parameters. \fBparent\fR is a
pointer to the parent \s-1RSA\s0 structure. \fBptr\fR is a the application specific data
(this wont be of much use in \fB\f(BInew_func()\fB\fR. \fBad\fR is a pointer to the
\&\fB\s-1CRYPTO_EX_DATA\s0\fR structure from the parent \s-1RSA\s0 structure: the functions
\&\fB\f(BICRYPTO_get_ex_data()\fB\fR and \fB\f(BICRYPTO_set_ex_data()\fB\fR can be called to manipulate
it. The \fBidx\fR parameter is the index: this will be the same value returned by
\&\fB\f(BIRSA_get_ex_new_index()\fB\fR when the functions were initially registered. Finally
the \fBargl\fR and \fBargp\fR parameters are the values originally passed to the same
corresponding parameters when \fB\f(BIRSA_get_ex_new_index()\fB\fR was called.
.PP
\&\fB\f(BIdup_func()\fB\fR is called when a structure is being copied. Pointers to the
destination and source \fB\s-1CRYPTO_EX_DATA\s0\fR structures are passed in the \fBto\fR and
\&\fBfrom\fR parameters respectively. The \fBfrom_d\fR parameter is passed a pointer to
the source application data when the function is called, when the function returns
the value is copied to the destination: the application can thus modify the data
pointed to by \fBfrom_d\fR and have different values in the source and destination.
The \fBidx\fR, \fBargl\fR and \fBargp\fR parameters are the same as those in \fB\f(BInew_func()\fB\fR
and \fB\f(BIfree_func()\fB\fR.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fB\f(BIRSA_get_ex_new_index()\fB\fR returns a new index or \-1 on failure (note 0 is a valid
index value).
.PP
\&\fB\f(BIRSA_set_ex_data()\fB\fR returns 1 on success or 0 on failure.
.PP
\&\fB\f(BIRSA_get_ex_data()\fB\fR returns the application data or 0 on failure. 0 may also
be valid application data but currently it can only fail if given an invalid \fBidx\fR
parameter.
.PP
\&\fB\f(BInew_func()\fB\fR and \fB\f(BIdup_func()\fB\fR should return 0 for failure and 1 for success.
.PP
On failure an error code can be obtained from \fIERR_get_error\fR\|(3).
.SH "BUGS"
.IX Header "BUGS"
\&\fB\f(BIdup_func()\fB\fR is currently never called.
.PP
The return value of \fB\f(BInew_func()\fB\fR is ignored.
.PP
The \fB\f(BInew_func()\fB\fR function isn't very useful because no meaningful values are
present in the parent \s-1RSA\s0 structure when it is called.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrsa\fR\|(3), \fICRYPTO_set_ex_data\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_get_ex_new_index()\fR, \fIRSA_set_ex_data()\fR and \fIRSA_get_ex_data()\fR are
available since SSLeay 0.9.0.
                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_get_method.3ssl                          0120777 0001750 0001750 00000000000 12620245063 027747  2RSA_set_method.3ssl                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_new.3ssl                                 0100644 0001750 0001750 00000011657 12566201137 022771  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_new 3"
.TH RSA_new 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_new, RSA_free \- allocate and free RSA objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& RSA * RSA_new(void);
\&
\& void RSA_free(RSA *rsa);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIRSA_new()\fR allocates and initializes an \fB\s-1RSA\s0\fR structure. It is equivalent to
calling RSA_new_method(\s-1NULL\s0).
.PP
\&\fIRSA_free()\fR frees the \fB\s-1RSA\s0\fR structure and its components. The key is
erased before the memory is returned to the system.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
If the allocation fails, \fIRSA_new()\fR returns \fB\s-1NULL\s0\fR and sets an error
code that can be obtained by \fIERR_get_error\fR\|(3). Otherwise it returns
a pointer to the newly allocated structure.
.PP
\&\fIRSA_free()\fR returns no value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fIrsa\fR\|(3),
\&\fIRSA_generate_key\fR\|(3),
\&\fIRSA_new_method\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_new()\fR and \fIRSA_free()\fR are available in all versions of SSLeay and OpenSSL.
                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_new_method.3ssl                          0120777 0001750 0001750 00000000000 12620245063 027761  2RSA_set_method.3ssl                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_null_method.3ssl                         0120777 0001750 0001750 00000000000 12620245063 030142  2RSA_set_method.3ssl                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_padding_add_PKCS1_OAEP.3ssl              0120777 0001750 0001750 00000000000 12620245063 034020  2RSA_padding_add_PKCS1_type_1.3ssl                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_padding_add_PKCS1_type_1.3ssl            0100644 0001750 0001750 00000020107 12566201137 026566  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_padding_add_PKCS1_type_1 3"
.TH RSA_padding_add_PKCS1_type_1 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_padding_add_PKCS1_type_1, RSA_padding_check_PKCS1_type_1,
RSA_padding_add_PKCS1_type_2, RSA_padding_check_PKCS1_type_2,
RSA_padding_add_PKCS1_OAEP, RSA_padding_check_PKCS1_OAEP,
RSA_padding_add_SSLv23, RSA_padding_check_SSLv23,
RSA_padding_add_none, RSA_padding_check_none \- asymmetric encryption
padding
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,
\&    unsigned char *f, int fl);
\&
\& int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
\&    unsigned char *f, int fl, int rsa_len);
\&
\& int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,
\&    unsigned char *f, int fl);
\&
\& int RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,
\&    unsigned char *f, int fl, int rsa_len);
\&
\& int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,
\&    unsigned char *f, int fl, unsigned char *p, int pl);
\&
\& int RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,
\&    unsigned char *f, int fl, int rsa_len, unsigned char *p, int pl);
\&
\& int RSA_padding_add_SSLv23(unsigned char *to, int tlen,
\&    unsigned char *f, int fl);
\&
\& int RSA_padding_check_SSLv23(unsigned char *to, int tlen,
\&    unsigned char *f, int fl, int rsa_len);
\&
\& int RSA_padding_add_none(unsigned char *to, int tlen,
\&    unsigned char *f, int fl);
\&
\& int RSA_padding_check_none(unsigned char *to, int tlen,
\&    unsigned char *f, int fl, int rsa_len);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fIRSA_padding_xxx_xxx()\fR functions are called from the \s-1RSA\s0 encrypt,
decrypt, sign and verify functions. Normally they should not be called
from application programs.
.PP
However, they can also be called directly to implement padding for other
asymmetric ciphers. \fIRSA_padding_add_PKCS1_OAEP()\fR and
\&\fIRSA_padding_check_PKCS1_OAEP()\fR may be used in an application combined
with \fB\s-1RSA_NO_PADDING\s0\fR in order to implement \s-1OAEP\s0 with an encoding
parameter.
.PP
\&\fIRSA_padding_add_xxx()\fR encodes \fBfl\fR bytes from \fBf\fR so as to fit into
\&\fBtlen\fR bytes and stores the result at \fBto\fR. An error occurs if \fBfl\fR
does not meet the size requirements of the encoding method.
.PP
The following encoding methods are implemented:
.IP "PKCS1_type_1" 4
.IX Item "PKCS1_type_1"
\&\s-1PKCS\s0 #1 v2.0 EMSA\-PKCS1\-v1_5 (\s-1PKCS\s0 #1 v1.5 block type 1); used for signatures
.IP "PKCS1_type_2" 4
.IX Item "PKCS1_type_2"
\&\s-1PKCS\s0 #1 v2.0 EME\-PKCS1\-v1_5 (\s-1PKCS\s0 #1 v1.5 block type 2)
.IP "\s-1PKCS1_OAEP\s0" 4
.IX Item "PKCS1_OAEP"
\&\s-1PKCS\s0 #1 v2.0 EME-OAEP
.IP "SSLv23" 4
.IX Item "SSLv23"
\&\s-1PKCS\s0 #1 EME\-PKCS1\-v1_5 with SSL-specific modification
.IP "none" 4
.IX Item "none"
simply copy the data
.PP
The random number generator must be seeded prior to calling
\&\fIRSA_padding_add_xxx()\fR.
.PP
\&\fIRSA_padding_check_xxx()\fR verifies that the \fBfl\fR bytes at \fBf\fR contain
a valid encoding for a \fBrsa_len\fR byte \s-1RSA\s0 key in the respective
encoding method and stores the recovered data of at most \fBtlen\fR bytes
(for \fB\s-1RSA_NO_PADDING\s0\fR: of size \fBtlen\fR)
at \fBto\fR.
.PP
For \fIRSA_padding_xxx_OAEP()\fR, \fBp\fR points to the encoding parameter
of length \fBpl\fR. \fBp\fR may be \fB\s-1NULL\s0\fR if \fBpl\fR is 0.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
The \fIRSA_padding_add_xxx()\fR functions return 1 on success, 0 on error.
The \fIRSA_padding_check_xxx()\fR functions return the length of the
recovered data, \-1 on error. Error codes can be obtained by calling
\&\fIERR_get_error\fR\|(3).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIRSA_public_encrypt\fR\|(3),
\&\fIRSA_private_decrypt\fR\|(3),
\&\fIRSA_sign\fR\|(3), \fIRSA_verify\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_padding_add_PKCS1_type_1()\fR, \fIRSA_padding_check_PKCS1_type_1()\fR,
\&\fIRSA_padding_add_PKCS1_type_2()\fR, \fIRSA_padding_check_PKCS1_type_2()\fR,
\&\fIRSA_padding_add_SSLv23()\fR, \fIRSA_padding_check_SSLv23()\fR,
\&\fIRSA_padding_add_none()\fR and \fIRSA_padding_check_none()\fR appeared in
SSLeay 0.9.0.
.PP
\&\fIRSA_padding_add_PKCS1_OAEP()\fR and \fIRSA_padding_check_PKCS1_OAEP()\fR were
added in OpenSSL 0.9.2b.
                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_padding_add_PKCS1_type_2.3ssl            0120777 0001750 0001750 00000000000 12620245063 034476  2RSA_padding_add_PKCS1_type_1.3ssl                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_padding_add_SSLv23.3ssl                  0120777 0001750 0001750 00000000000 12620245063 033367  2RSA_padding_add_PKCS1_type_1.3ssl                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_padding_add_none.3ssl                    0120777 0001750 0001750 00000000000 12620245063 033332  2RSA_padding_add_PKCS1_type_1.3ssl                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_padding_check_PKCS1_OAEP.3ssl            0120777 0001750 0001750 00000000000 12620245063 034345  2RSA_padding_add_PKCS1_type_1.3ssl                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_padding_check_PKCS1_type_1.3ssl          0120777 0001750 0001750 00000000000 12620245063 035022  2RSA_padding_add_PKCS1_type_1.3ssl                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_padding_check_PKCS1_type_2.3ssl          0120777 0001750 0001750 00000000000 12620245063 035023  2RSA_padding_add_PKCS1_type_1.3ssl                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_padding_check_SSLv23.3ssl                0120777 0001750 0001750 00000000000 12620245063 033714  2RSA_padding_add_PKCS1_type_1.3ssl                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_padding_check_none.3ssl                  0120777 0001750 0001750 00000000000 12620245063 033657  2RSA_padding_add_PKCS1_type_1.3ssl                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_print.3ssl                               0100644 0001750 0001750 00000012442 12566201140 023317  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_print 3"
.TH RSA_print 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_print, RSA_print_fp,
DSAparams_print, DSAparams_print_fp, DSA_print, DSA_print_fp,
DHparams_print, DHparams_print_fp \- print cryptographic parameters
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_print(BIO *bp, RSA *x, int offset);
\& int RSA_print_fp(FILE *fp, RSA *x, int offset);
\&
\& #include <openssl/dsa.h>
\&
\& int DSAparams_print(BIO *bp, DSA *x);
\& int DSAparams_print_fp(FILE *fp, DSA *x);
\& int DSA_print(BIO *bp, DSA *x, int offset);
\& int DSA_print_fp(FILE *fp, DSA *x, int offset);
\&
\& #include <openssl/dh.h>
\&
\& int DHparams_print(BIO *bp, DH *x);
\& int DHparams_print_fp(FILE *fp, DH *x);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A human-readable hexadecimal output of the components of the \s-1RSA\s0
key, \s-1DSA\s0 parameters or key or \s-1DH\s0 parameters is printed to \fBbp\fR or \fBfp\fR.
.PP
The output lines are indented by \fBoffset\fR spaces.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
These functions return 1 on success, 0 on error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIdh\fR\|(3), \fIdsa\fR\|(3), \fIrsa\fR\|(3), \fIBN_bn2bin\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_print()\fR, \fIRSA_print_fp()\fR, \fIDSA_print()\fR, \fIDSA_print_fp()\fR, \fIDH_print()\fR,
\&\fIDH_print_fp()\fR are available in all versions of SSLeay and OpenSSL.
\&\fIDSAparams_print()\fR and \fIDSAparams_print_fp()\fR were added in SSLeay 0.8.
                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_print_fp.3ssl                            0120777 0001750 0001750 00000000000 12620245063 026452  2RSA_print.3ssl                                                                                      ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_private_decrypt.3ssl                     0120777 0001750 0001750 00000000000 12620245063 031723  2RSA_public_encrypt.3ssl                                                                             ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_private_encrypt.3ssl                     0100644 0001750 0001750 00000014202 12566201140 025375  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_private_encrypt 3"
.TH RSA_private_encrypt 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_private_encrypt, RSA_public_decrypt \- low level signature operations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_private_encrypt(int flen, unsigned char *from,
\&    unsigned char *to, RSA *rsa, int padding);
\&
\& int RSA_public_decrypt(int flen, unsigned char *from, 
\&    unsigned char *to, RSA *rsa, int padding);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These functions handle \s-1RSA\s0 signatures at a low level.
.PP
\&\fIRSA_private_encrypt()\fR signs the \fBflen\fR bytes at \fBfrom\fR (usually a
message digest with an algorithm identifier) using the private key
\&\fBrsa\fR and stores the signature in \fBto\fR. \fBto\fR must point to
\&\fBRSA_size(rsa)\fR bytes of memory.
.PP
\&\fBpadding\fR denotes one of the following modes:
.IP "\s-1RSA_PKCS1_PADDING\s0" 4
.IX Item "RSA_PKCS1_PADDING"
\&\s-1PKCS\s0 #1 v1.5 padding. This function does not handle the
\&\fBalgorithmIdentifier\fR specified in \s-1PKCS\s0 #1. When generating or
verifying \s-1PKCS\s0 #1 signatures, \fIRSA_sign\fR\|(3) and \fIRSA_verify\fR\|(3) should be
used.
.IP "\s-1RSA_NO_PADDING\s0" 4
.IX Item "RSA_NO_PADDING"
Raw \s-1RSA\s0 signature. This mode should \fIonly\fR be used to implement
cryptographically sound padding modes in the application code.
Signing user data directly with \s-1RSA\s0 is insecure.
.PP
\&\fIRSA_public_decrypt()\fR recovers the message digest from the \fBflen\fR
bytes long signature at \fBfrom\fR using the signer's public key
\&\fBrsa\fR. \fBto\fR must point to a memory section large enough to hold the
message digest (which is smaller than \fBRSA_size(rsa) \-
11\fR). \fBpadding\fR is the padding mode that was used to sign the data.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRSA_private_encrypt()\fR returns the size of the signature (i.e.,
RSA_size(rsa)). \fIRSA_public_decrypt()\fR returns the size of the
recovered message digest.
.PP
On error, \-1 is returned; the error codes can be
obtained by \fIERR_get_error\fR\|(3).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fIrsa\fR\|(3),
\&\fIRSA_sign\fR\|(3), \fIRSA_verify\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
The \fBpadding\fR argument was added in SSLeay 0.8. \s-1RSA_NO_PADDING\s0 is
available since SSLeay 0.9.0.
                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_public_decrypt.3ssl                      0120777 0001750 0001750 00000000000 12620245063 031723  2RSA_private_encrypt.3ssl                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_public_encrypt.3ssl                      0100644 0001750 0001750 00000015301 12566201140 025202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_public_encrypt 3"
.TH RSA_public_encrypt 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_public_encrypt, RSA_private_decrypt \- RSA public key cryptography
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_public_encrypt(int flen, unsigned char *from,
\&    unsigned char *to, RSA *rsa, int padding);
\&
\& int RSA_private_decrypt(int flen, unsigned char *from,
\&     unsigned char *to, RSA *rsa, int padding);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIRSA_public_encrypt()\fR encrypts the \fBflen\fR bytes at \fBfrom\fR (usually a
session key) using the public key \fBrsa\fR and stores the ciphertext in
\&\fBto\fR. \fBto\fR must point to RSA_size(\fBrsa\fR) bytes of memory.
.PP
\&\fBpadding\fR denotes one of the following modes:
.IP "\s-1RSA_PKCS1_PADDING\s0" 4
.IX Item "RSA_PKCS1_PADDING"
\&\s-1PKCS\s0 #1 v1.5 padding. This currently is the most widely used mode.
.IP "\s-1RSA_PKCS1_OAEP_PADDING\s0" 4
.IX Item "RSA_PKCS1_OAEP_PADDING"
EME-OAEP as defined in \s-1PKCS\s0 #1 v2.0 with \s-1SHA\-1, MGF1\s0 and an empty
encoding parameter. This mode is recommended for all new applications.
.IP "\s-1RSA_SSLV23_PADDING\s0" 4
.IX Item "RSA_SSLV23_PADDING"
\&\s-1PKCS\s0 #1 v1.5 padding with an SSL-specific modification that denotes
that the server is \s-1SSL3\s0 capable.
.IP "\s-1RSA_NO_PADDING\s0" 4
.IX Item "RSA_NO_PADDING"
Raw \s-1RSA\s0 encryption. This mode should \fIonly\fR be used to implement
cryptographically sound padding modes in the application code.
Encrypting user data directly with \s-1RSA\s0 is insecure.
.PP
\&\fBflen\fR must be less than RSA_size(\fBrsa\fR) \- 11 for the \s-1PKCS\s0 #1 v1.5
based padding modes, less than RSA_size(\fBrsa\fR) \- 41 for
\&\s-1RSA_PKCS1_OAEP_PADDING\s0 and exactly RSA_size(\fBrsa\fR) for \s-1RSA_NO_PADDING.\s0
The random number generator must be seeded prior to calling
\&\fIRSA_public_encrypt()\fR.
.PP
\&\fIRSA_private_decrypt()\fR decrypts the \fBflen\fR bytes at \fBfrom\fR using the
private key \fBrsa\fR and stores the plaintext in \fBto\fR. \fBto\fR must point
to a memory section large enough to hold the decrypted data (which is
smaller than RSA_size(\fBrsa\fR)). \fBpadding\fR is the padding mode that
was used to encrypt the data.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRSA_public_encrypt()\fR returns the size of the encrypted data (i.e.,
RSA_size(\fBrsa\fR)). \fIRSA_private_decrypt()\fR returns the size of the
recovered plaintext.
.PP
On error, \-1 is returned; the error codes can be
obtained by \fIERR_get_error\fR\|(3).
.SH "CONFORMING TO"
.IX Header "CONFORMING TO"
\&\s-1SSL, PKCS\s0 #1 v2.0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fIrand\fR\|(3), \fIrsa\fR\|(3),
\&\fIRSA_size\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
The \fBpadding\fR argument was added in SSLeay 0.8. \s-1RSA_NO_PADDING\s0 is
available since SSLeay 0.9.0, \s-1OAEP\s0 was added in OpenSSL 0.9.2b.
                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_set_default_method.3ssl                  0120777 0001750 0001750 00000000000 12620245063 031467  2RSA_set_method.3ssl                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_set_ex_data.3ssl                         0120777 0001750 0001750 00000000000 12620245063 031270  2RSA_get_ex_new_index.3ssl                                                                           ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_set_method.3ssl                          0100644 0001750 0001750 00000032076 12566201141 024324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_set_method 3"
.TH RSA_set_method 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_set_default_method, RSA_get_default_method, RSA_set_method,
RSA_get_method, RSA_PKCS1_SSLeay, RSA_null_method, RSA_flags,
RSA_new_method \- select RSA method
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& void RSA_set_default_method(const RSA_METHOD *meth);
\&
\& RSA_METHOD *RSA_get_default_method(void);
\&
\& int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);
\&
\& RSA_METHOD *RSA_get_method(const RSA *rsa);
\&
\& RSA_METHOD *RSA_PKCS1_SSLeay(void);
\&
\& RSA_METHOD *RSA_null_method(void);
\&
\& int RSA_flags(const RSA *rsa);
\&
\& RSA *RSA_new_method(RSA_METHOD *method);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \fB\s-1RSA_METHOD\s0\fR specifies the functions that OpenSSL uses for \s-1RSA\s0
operations. By modifying the method, alternative implementations such as
hardware accelerators may be used. \s-1IMPORTANT:\s0 See the \s-1NOTES\s0 section for
important information about how these \s-1RSA API\s0 functions are affected by the
use of \fB\s-1ENGINE\s0\fR \s-1API\s0 calls.
.PP
Initially, the default \s-1RSA_METHOD\s0 is the OpenSSL internal implementation,
as returned by \fIRSA_PKCS1_SSLeay()\fR.
.PP
\&\fIRSA_set_default_method()\fR makes \fBmeth\fR the default method for all \s-1RSA\s0
structures created later. \fB\s-1NB\s0\fR: This is true only whilst no \s-1ENGINE\s0 has
been set as a default for \s-1RSA,\s0 so this function is no longer recommended.
.PP
\&\fIRSA_get_default_method()\fR returns a pointer to the current default
\&\s-1RSA_METHOD.\s0 However, the meaningfulness of this result is dependent on
whether the \s-1ENGINE API\s0 is being used, so this function is no longer 
recommended.
.PP
\&\fIRSA_set_method()\fR selects \fBmeth\fR to perform all operations using the key
\&\fBrsa\fR. This will replace the \s-1RSA_METHOD\s0 used by the \s-1RSA\s0 key and if the
previous method was supplied by an \s-1ENGINE,\s0 the handle to that \s-1ENGINE\s0 will
be released during the change. It is possible to have \s-1RSA\s0 keys that only
work with certain \s-1RSA_METHOD\s0 implementations (eg. from an \s-1ENGINE\s0 module
that supports embedded hardware-protected keys), and in such cases
attempting to change the \s-1RSA_METHOD\s0 for the key can have unexpected
results.
.PP
\&\fIRSA_get_method()\fR returns a pointer to the \s-1RSA_METHOD\s0 being used by \fBrsa\fR.
This method may or may not be supplied by an \s-1ENGINE\s0 implementation, but if
it is, the return value can only be guaranteed to be valid as long as the
\&\s-1RSA\s0 key itself is valid and does not have its implementation changed by
\&\fIRSA_set_method()\fR.
.PP
\&\fIRSA_flags()\fR returns the \fBflags\fR that are set for \fBrsa\fR's current
\&\s-1RSA_METHOD.\s0 See the \s-1BUGS\s0 section.
.PP
\&\fIRSA_new_method()\fR allocates and initializes an \s-1RSA\s0 structure so that
\&\fBengine\fR will be used for the \s-1RSA\s0 operations. If \fBengine\fR is \s-1NULL,\s0 the
default \s-1ENGINE\s0 for \s-1RSA\s0 operations is used, and if no default \s-1ENGINE\s0 is set,
the \s-1RSA_METHOD\s0 controlled by \fIRSA_set_default_method()\fR is used.
.PP
\&\fIRSA_flags()\fR returns the \fBflags\fR that are set for \fBrsa\fR's current method.
.PP
\&\fIRSA_new_method()\fR allocates and initializes an \fB\s-1RSA\s0\fR structure so that
\&\fBmethod\fR will be used for the \s-1RSA\s0 operations. If \fBmethod\fR is \fB\s-1NULL\s0\fR,
the default method is used.
.SH "THE RSA_METHOD STRUCTURE"
.IX Header "THE RSA_METHOD STRUCTURE"
.Vb 4
\& typedef struct rsa_meth_st
\& {
\&     /* name of the implementation */
\&        const char *name;
\&
\&     /* encrypt */
\&        int (*rsa_pub_enc)(int flen, unsigned char *from,
\&          unsigned char *to, RSA *rsa, int padding);
\&
\&     /* verify arbitrary data */
\&        int (*rsa_pub_dec)(int flen, unsigned char *from,
\&          unsigned char *to, RSA *rsa, int padding);
\&
\&     /* sign arbitrary data */
\&        int (*rsa_priv_enc)(int flen, unsigned char *from,
\&          unsigned char *to, RSA *rsa, int padding);
\&
\&     /* decrypt */
\&        int (*rsa_priv_dec)(int flen, unsigned char *from,
\&          unsigned char *to, RSA *rsa, int padding);
\&
\&     /* compute r0 = r0 ^ I mod rsa\->n (May be NULL for some
\&                                        implementations) */
\&        int (*rsa_mod_exp)(BIGNUM *r0, BIGNUM *I, RSA *rsa);
\&
\&     /* compute r = a ^ p mod m (May be NULL for some implementations) */
\&        int (*bn_mod_exp)(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
\&          const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
\&
\&     /* called at RSA_new */
\&        int (*init)(RSA *rsa);
\&
\&     /* called at RSA_free */
\&        int (*finish)(RSA *rsa);
\&
\&     /* RSA_FLAG_EXT_PKEY        \- rsa_mod_exp is called for private key
\&      *                            operations, even if p,q,dmp1,dmq1,iqmp
\&      *                            are NULL
\&      * RSA_FLAG_SIGN_VER        \- enable rsa_sign and rsa_verify
\&      * RSA_METHOD_FLAG_NO_CHECK \- don\*(Aqt check pub/private match
\&      */
\&        int flags;
\&
\&        char *app_data; /* ?? */
\&
\&     /* sign. For backward compatibility, this is used only
\&      * if (flags & RSA_FLAG_SIGN_VER)
\&      */
\&        int (*rsa_sign)(int type,
\&                const unsigned char *m, unsigned int m_length,
\&                unsigned char *sigret, unsigned int *siglen, const RSA *rsa);
\&     /* verify. For backward compatibility, this is used only
\&      * if (flags & RSA_FLAG_SIGN_VER)
\&      */
\&        int (*rsa_verify)(int dtype,
\&                const unsigned char *m, unsigned int m_length,
\&                const unsigned char *sigbuf, unsigned int siglen,
\&                                                                const RSA *rsa);
\&     /* keygen. If NULL builtin RSA key generation will be used */
\&        int (*rsa_keygen)(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
\&
\& } RSA_METHOD;
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRSA_PKCS1_SSLeay()\fR, \fIRSA_PKCS1_null_method()\fR, \fIRSA_get_default_method()\fR
and \fIRSA_get_method()\fR return pointers to the respective RSA_METHODs.
.PP
\&\fIRSA_set_default_method()\fR returns no value.
.PP
\&\fIRSA_set_method()\fR returns a pointer to the old \s-1RSA_METHOD\s0 implementation
that was replaced. However, this return value should probably be ignored
because if it was supplied by an \s-1ENGINE,\s0 the pointer could be invalidated
at any time if the \s-1ENGINE\s0 is unloaded (in fact it could be unloaded as a
result of the \fIRSA_set_method()\fR function releasing its handle to the
\&\s-1ENGINE\s0). For this reason, the return type may be replaced with a \fBvoid\fR
declaration in a future release.
.PP
\&\fIRSA_new_method()\fR returns \s-1NULL\s0 and sets an error code that can be obtained
by \fIERR_get_error\fR\|(3) if the allocation fails. Otherwise
it returns a pointer to the newly allocated structure.
.SH "NOTES"
.IX Header "NOTES"
As of version 0.9.7, \s-1RSA_METHOD\s0 implementations are grouped together with
other algorithmic APIs (eg. \s-1DSA_METHOD, EVP_CIPHER,\s0 etc) into \fB\s-1ENGINE\s0\fR
modules. If a default \s-1ENGINE\s0 is specified for \s-1RSA\s0 functionality using an
\&\s-1ENGINE API\s0 function, that will override any \s-1RSA\s0 defaults set using the \s-1RSA
API \s0(ie.  \fIRSA_set_default_method()\fR). For this reason, the \s-1ENGINE API\s0 is the
recommended way to control default implementations for use in \s-1RSA\s0 and other
cryptographic algorithms.
.SH "BUGS"
.IX Header "BUGS"
The behaviour of \fIRSA_flags()\fR is a mis-feature that is left as-is for now
to avoid creating compatibility problems. \s-1RSA\s0 functionality, such as the
encryption functions, are controlled by the \fBflags\fR value in the \s-1RSA\s0 key
itself, not by the \fBflags\fR value in the \s-1RSA_METHOD\s0 attached to the \s-1RSA\s0 key
(which is what this function returns). If the flags element of an \s-1RSA\s0 key
is changed, the changes will be honoured by \s-1RSA\s0 functionality but will not
be reflected in the return value of the \fIRSA_flags()\fR function \- in effect
\&\fIRSA_flags()\fR behaves more like an \fIRSA_default_flags()\fR function (which does
not currently exist).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrsa\fR\|(3), \fIRSA_new\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_new_method()\fR and \fIRSA_set_default_method()\fR appeared in SSLeay 0.8.
\&\fIRSA_get_default_method()\fR, \fIRSA_set_method()\fR and \fIRSA_get_method()\fR as
well as the rsa_sign and rsa_verify components of \s-1RSA_METHOD\s0 were
added in OpenSSL 0.9.4.
.PP
\&\fIRSA_set_default_openssl_method()\fR and \fIRSA_get_default_openssl_method()\fR
replaced \fIRSA_set_default_method()\fR and \fIRSA_get_default_method()\fR
respectively, and \fIRSA_set_method()\fR and \fIRSA_new_method()\fR were altered to use
\&\fB\s-1ENGINE\s0\fRs rather than \fB\s-1RSA_METHOD\s0\fRs during development of the engine
version of OpenSSL 0.9.6. For 0.9.7, the handling of defaults in the \s-1ENGINE
API\s0 was restructured so that this change was reversed, and behaviour of the
other functions resembled more closely the previous behaviour. The
behaviour of defaults in the \s-1ENGINE API\s0 now transparently overrides the
behaviour of defaults in the \s-1RSA API\s0 without requiring changing these
function prototypes.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_sign.3ssl                                0100644 0001750 0001750 00000014155 12566201141 023127  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_sign 3"
.TH RSA_sign 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_sign, RSA_verify \- RSA signatures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_sign(int type, const unsigned char *m, unsigned int m_len,
\&    unsigned char *sigret, unsigned int *siglen, RSA *rsa);
\&
\& int RSA_verify(int type, const unsigned char *m, unsigned int m_len,
\&    unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIRSA_sign()\fR signs the message digest \fBm\fR of size \fBm_len\fR using the
private key \fBrsa\fR as specified in \s-1PKCS\s0 #1 v2.0. It stores the
signature in \fBsigret\fR and the signature size in \fBsiglen\fR. \fBsigret\fR
must point to RSA_size(\fBrsa\fR) bytes of memory.
Note that \s-1PKCS\s0 #1 adds meta-data, placing limits on the size of the
key that can be used.
See \fIRSA_private_encrypt\fR\|(3) for lower-level
operations.
.PP
\&\fBtype\fR denotes the message digest algorithm that was used to generate
\&\fBm\fR. It usually is one of \fBNID_sha1\fR, \fBNID_ripemd160\fR and \fBNID_md5\fR;
see \fIobjects\fR\|(3) for details. If \fBtype\fR is \fBNID_md5_sha1\fR,
an \s-1SSL\s0 signature (\s-1MD5\s0 and \s-1SHA1\s0 message digests with \s-1PKCS\s0 #1 padding
and no algorithm identifier) is created.
.PP
\&\fIRSA_verify()\fR verifies that the signature \fBsigbuf\fR of size \fBsiglen\fR
matches a given message digest \fBm\fR of size \fBm_len\fR. \fBtype\fR denotes
the message digest algorithm that was used to generate the signature.
\&\fBrsa\fR is the signer's public key.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRSA_sign()\fR returns 1 on success, 0 otherwise.  \fIRSA_verify()\fR returns 1
on successful verification, 0 otherwise.
.PP
The error codes can be obtained by \fIERR_get_error\fR\|(3).
.SH "BUGS"
.IX Header "BUGS"
Certain signatures with an improper algorithm identifier are accepted
for compatibility with SSLeay 0.4.5 :\-)
.SH "CONFORMING TO"
.IX Header "CONFORMING TO"
\&\s-1SSL, PKCS\s0 #1 v2.0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fIobjects\fR\|(3),
\&\fIrsa\fR\|(3), \fIRSA_private_encrypt\fR\|(3),
\&\fIRSA_public_decrypt\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_sign()\fR and \fIRSA_verify()\fR are available in all versions of SSLeay
and OpenSSL.
                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_sign_ASN1_OCTET_STRING.3ssl              0100644 0001750 0001750 00000013366 12566201141 025740  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_sign_ASN1_OCTET_STRING 3"
.TH RSA_sign_ASN1_OCTET_STRING 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_sign_ASN1_OCTET_STRING, RSA_verify_ASN1_OCTET_STRING \- RSA signatures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_sign_ASN1_OCTET_STRING(int dummy, unsigned char *m,
\&    unsigned int m_len, unsigned char *sigret, unsigned int *siglen,
\&    RSA *rsa);
\&
\& int RSA_verify_ASN1_OCTET_STRING(int dummy, unsigned char *m,
\&    unsigned int m_len, unsigned char *sigbuf, unsigned int siglen,
\&    RSA *rsa);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIRSA_sign_ASN1_OCTET_STRING()\fR signs the octet string \fBm\fR of size
\&\fBm_len\fR using the private key \fBrsa\fR represented in \s-1DER\s0 using \s-1PKCS\s0 #1
padding. It stores the signature in \fBsigret\fR and the signature size
in \fBsiglen\fR. \fBsigret\fR must point to \fBRSA_size(rsa)\fR bytes of
memory.
.PP
\&\fBdummy\fR is ignored.
.PP
The random number generator must be seeded prior to calling \fIRSA_sign_ASN1_OCTET_STRING()\fR.
.PP
\&\fIRSA_verify_ASN1_OCTET_STRING()\fR verifies that the signature \fBsigbuf\fR
of size \fBsiglen\fR is the \s-1DER\s0 representation of a given octet string
\&\fBm\fR of size \fBm_len\fR. \fBdummy\fR is ignored. \fBrsa\fR is the signer's
public key.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRSA_sign_ASN1_OCTET_STRING()\fR returns 1 on success, 0 otherwise.
\&\fIRSA_verify_ASN1_OCTET_STRING()\fR returns 1 on successful verification, 0
otherwise.
.PP
The error codes can be obtained by \fIERR_get_error\fR\|(3).
.SH "BUGS"
.IX Header "BUGS"
These functions serve no recognizable purpose.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fIobjects\fR\|(3),
\&\fIrand\fR\|(3), \fIrsa\fR\|(3), \fIRSA_sign\fR\|(3),
\&\fIRSA_verify\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_sign_ASN1_OCTET_STRING()\fR and \fIRSA_verify_ASN1_OCTET_STRING()\fR were
added in SSLeay 0.8.
                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_size.3ssl                                0100644 0001750 0001750 00000010766 12566201142 023146  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_size 3"
.TH RSA_size 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_size \- get RSA modulus size
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_size(const RSA *rsa);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This function returns the \s-1RSA\s0 modulus size in bytes. It can be used to
determine how much memory must be allocated for an \s-1RSA\s0 encrypted
value.
.PP
\&\fBrsa\->n\fR must not be \fB\s-1NULL\s0\fR.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
The size in bytes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrsa\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_size()\fR is available in all versions of SSLeay and OpenSSL.
          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_verify.3ssl                              0120777 0001750 0001750 00000000000 12620245063 025741  2RSA_sign.3ssl                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/RSA_verify_ASN1_OCTET_STRING.3ssl            0120777 0001750 0001750 00000000000 12620245063 033355  2RSA_sign_ASN1_OCTET_STRING.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common.3pm                           0100644 0001750 0001750 00000065476 12566242002 024101  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common 3"
.TH Regexp::Common 3 "2013-03-13" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common \- Provide commonly requested regular expressions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # STANDARD USAGE 
\&
\& use Regexp::Common;
\&
\& while (<>) {
\&     /$RE{num}{real}/               and print q{a number};
\&     /$RE{quoted}/                  and print q{a [\*(Aq"\`] quoted string};
\&     /$RE{delimited}{\-delim=>\*(Aq/\*(Aq}/  and print q{a /.../ sequence};
\&     /$RE{balanced}{\-parens=>\*(Aq()\*(Aq}/ and print q{balanced parentheses};
\&     /$RE{profanity}/               and print q{a #*@%\-ing word};
\& }
\&
\&
\& # SUBROUTINE\-BASED INTERFACE
\&
\& use Regexp::Common \*(AqRE_ALL\*(Aq;
\&
\& while (<>) {
\&     $_ =~ RE_num_real()              and print q{a number};
\&     $_ =~ RE_quoted()                and print q{a [\*(Aq"\`] quoted string};
\&     $_ =~ RE_delimited(\-delim=>\*(Aq/\*(Aq)  and print q{a /.../ sequence};
\&     $_ =~ RE_balanced(\-parens=>\*(Aq()\*(Aq} and print q{balanced parentheses};
\&     $_ =~ RE_profanity()             and print q{a #*@%\-ing word};
\& }
\&
\&
\& # IN\-LINE MATCHING...
\&
\& if ( $RE{num}{int}\->matches($text) ) {...}
\&
\&
\& # ...AND SUBSTITUTION
\&
\& my $cropped = $RE{ws}{crop}\->subs($uncropped);
\&
\&
\& # ROLL\-YOUR\-OWN PATTERNS
\&
\& use Regexp::Common \*(Aqpattern\*(Aq;
\&
\& pattern name   => [\*(Aqname\*(Aq, \*(Aqmine\*(Aq],
\&         create => \*(Aq(?i:J[.]?\es+A[.]?\es+Perl\-Hacker)\*(Aq,
\&         ;
\&
\& my $name_matcher = $RE{name}{mine};
\&
\& pattern name    => [ \*(Aqlineof\*(Aq, \*(Aq\-char=_\*(Aq ],
\&         create  => sub {
\&                        my $flags = shift;
\&                        my $char = quotemeta $flags\->{\-char};
\&                        return \*(Aq(?:^$char+$)\*(Aq;
\&                    },
\&         match   => sub {
\&                        my ($self, $str) = @_;
\&                        return $str !~ /[^$self\->{flags}{\-char}]/;
\&                    },
\&         subs   => sub {
\&                        my ($self, $str, $replacement) = @_;
\&                        $_[1] =~ s/^$self\->{flags}{\-char}+$//g;
\&                   },
\&         ;
\&
\& my $asterisks = $RE{lineof}{\-char=>\*(Aq*\*(Aq};
\&
\& # DECIDING WHICH PATTERNS TO LOAD.
\&
\& use Regexp::Common qw /comment number/;  # Comment and number patterns.
\& use Regexp::Common qw /no_defaults/;     # Don\*(Aqt load any patterns.
\& use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
By default, this module exports a single hash (\f(CW%RE\fR) that stores or generates
commonly needed regular expressions (see \*(L"List of available patterns\*(R").
.PP
There is an alternative, subroutine-based syntax described in
\&\*(L"Subroutine-based interface\*(R".
.SS "General syntax for requesting patterns"
.IX Subsection "General syntax for requesting patterns"
To access a particular pattern, \f(CW%RE\fR is treated as a hierarchical hash of
hashes (of hashes...), with each successive key being an identifier. For
example, to access the pattern that matches real numbers, you 
specify:
.PP
.Vb 1
\&        $RE{num}{real}
.Ve
.PP
and to access the pattern that matches integers:
.PP
.Vb 1
\&        $RE{num}{int}
.Ve
.PP
Deeper layers of the hash are used to specify \fIflags\fR: arguments that
modify the resulting pattern in some way. The keys used to access these
layers are prefixed with a minus sign and may have a value; if a value
is given, it's done by using a multidimensional key.
For example, to access the pattern that
matches base\-2 real numbers with embedded commas separating
groups of three digits (e.g. 10,101,110.110101101):
.PP
.Vb 1
\&        $RE{num}{real}{\-base => 2}{\-sep => \*(Aq,\*(Aq}{\-group => 3}
.Ve
.PP
Through the magic of Perl, these flag layers may be specified in any order
(and even interspersed through the identifier keys!)
so you could get the same pattern with:
.PP
.Vb 1
\&        $RE{num}{real}{\-sep => \*(Aq,\*(Aq}{\-group => 3}{\-base => 2}
.Ve
.PP
or:
.PP
.Vb 1
\&        $RE{num}{\-base => 2}{real}{\-group => 3}{\-sep => \*(Aq,\*(Aq}
.Ve
.PP
or even:
.PP
.Vb 1
\&        $RE{\-base => 2}{\-group => 3}{\-sep => \*(Aq,\*(Aq}{num}{real}
.Ve
.PP
etc.
.PP
Note, however, that the relative order of amongst the identifier keys
\&\fIis\fR significant. That is:
.PP
.Vb 1
\&        $RE{list}{set}
.Ve
.PP
would not be the same as:
.PP
.Vb 1
\&        $RE{set}{list}
.Ve
.SS "Flag syntax"
.IX Subsection "Flag syntax"
In versions prior to 2.113, flags could also be written as
\&\f(CW\*(C`{"\-flag=value"}\*(C'\fR. This no longer works, although \f(CW\*(C`{"\-flag$;value"}\*(C'\fR
still does. However, \f(CW\*(C`{\-flag => \*(Aqvalue\*(Aq}\*(C'\fR is the preferred syntax.
.SS "Universal flags"
.IX Subsection "Universal flags"
Normally, flags are specific to a single pattern.
However, there is two flags that all patterns may specify.
.ie n .IP """\-keep""" 4
.el .IP "\f(CW\-keep\fR" 4
.IX Item "-keep"
By default, the patterns provided by \f(CW%RE\fR contain no capturing
parentheses. However, if the \f(CW\*(C`\-keep\*(C'\fR flag is specified (it requires
no value) then any significant substrings that the pattern matches
are captured. For example:
.Sp
.Vb 5
\&        if ($str =~ $RE{num}{real}{\-keep}) {
\&                $number   = $1;
\&                $whole    = $3;
\&                $decimals = $5;
\&        }
.Ve
.Sp
Special care is needed if a \*(L"kept\*(R" pattern is interpolated into a
larger regular expression, as the presence of other capturing
parentheses is likely to change the \*(L"number variables\*(R" into which significant
substrings are saved.
.Sp
See also \*(L"Adding new regular expressions\*(R", which describes how to create
new patterns with \*(L"optional\*(R" capturing brackets that respond to \f(CW\*(C`\-keep\*(C'\fR.
.ie n .IP """\-i""" 4
.el .IP "\f(CW\-i\fR" 4
.IX Item "-i"
Some patterns or subpatterns only match lowercase or uppercase letters.
If one wants the do case insensitive matching, one option is to use
the \f(CW\*(C`/i\*(C'\fR regexp modifier, or the special sequence \f(CW\*(C`(?i)\*(C'\fR. But if the
functional interface is used, one does not have this option. The 
\&\f(CW\*(C`\-i\*(C'\fR switch solves this problem; by using it, the pattern will do
case insensitive matching.
.SS "\s-1OO\s0 interface and inline matching/substitution"
.IX Subsection "OO interface and inline matching/substitution"
The patterns returned from \f(CW%RE\fR are objects, so rather than writing:
.PP
.Vb 1
\&        if ($str =~ /$RE{some}{pattern}/ ) {...}
.Ve
.PP
you can write:
.PP
.Vb 1
\&        if ( $RE{some}{pattern}\->matches($str) ) {...}
.Ve
.PP
For matching this would seem to have no great advantage apart from readability
(but see below).
.PP
For substitutions, it has other significant benefits. Frequently you want to
perform a substitution on a string without changing the original. Most people
use this:
.PP
.Vb 2
\&        $changed = $original;
\&        $changed =~ s/$RE{some}{pattern}/$replacement/;
.Ve
.PP
The more adept use:
.PP
.Vb 1
\&        ($changed = $original) =~ s/$RE{some}{pattern}/$replacement/;
.Ve
.PP
Regexp::Common allows you do write this:
.PP
.Vb 1
\&        $changed = $RE{some}{pattern}\->subs($original=>$replacement);
.Ve
.PP
Apart from reducing precedence-angst, this approach has the added
advantages that the substitution behaviour can be optimized from the 
regular expression, and the replacement string can be provided by
default (see \*(L"Adding new regular expressions\*(R").
.PP
For example, in the implementation of this substitution:
.PP
.Vb 1
\&        $cropped = $RE{ws}{crop}\->subs($uncropped);
.Ve
.PP
the default empty string is provided automatically, and the substitution is
optimized to use:
.PP
.Vb 2
\&        $uncropped =~ s/^\es+//;
\&        $uncropped =~ s/\es+$//;
.Ve
.PP
rather than:
.PP
.Vb 1
\&        $uncropped =~ s/^\es+|\es+$//g;
.Ve
.SS "Subroutine-based interface"
.IX Subsection "Subroutine-based interface"
The hash-based interface was chosen because it allows regexes to be
effortlessly interpolated, and because it also allows them to be
\&\*(L"curried\*(R". For example:
.PP
.Vb 1
\&        my $num = $RE{num}{int};
\&
\&        my $commad     = $num\->{\-sep=>\*(Aq,\*(Aq}{\-group=>3};
\&        my $duodecimal = $num\->{\-base=>12};
.Ve
.PP
However, the use of tied hashes does make the access to Regexp::Common
patterns slower than it might otherwise be. In contexts where impatience
overrules laziness, Regexp::Common provides an additional
subroutine-based interface.
.PP
For each (sub\-)entry in the \f(CW%RE\fR hash (\f(CW$RE{key1}{key2}{etc}\fR), there
is a corresponding exportable subroutine: \f(CW\*(C`RE_key1_key2_etc()\*(C'\fR. The name of
each subroutine is the underscore-separated concatenation of the \fInon-flag\fR
keys that locate the same pattern in \f(CW%RE\fR. Flags are passed to the subroutine
in its argument list. Thus:
.PP
.Vb 1
\&        use Regexp::Common qw( RE_ws_crop RE_num_real RE_profanity );
\&
\&        $str =~ RE_ws_crop() and die "Surrounded by whitespace";
\&
\&        $str =~ RE_num_real(\-base=>8, \-sep=>" ") or next;
\&
\&        $offensive = RE_profanity(\-keep);
\&        $str =~ s/$offensive/$bad{$1}++; "<expletive deleted>"/ge;
.Ve
.PP
Note that, unlike the hash-based interface (which returns objects), these
subroutines return ordinary \f(CW\*(C`qr\*(C'\fR'd regular expressions. Hence they do not
curry, nor do they provide the \s-1OO\s0 match and substitution inlining described
in the previous section.
.PP
It is also possible to export subroutines for all available patterns like so:
.PP
.Vb 1
\&        use Regexp::Common \*(AqRE_ALL\*(Aq;
.Ve
.PP
Or you can export all subroutines with a common prefix of keys like so:
.PP
.Vb 1
\&        use Regexp::Common \*(AqRE_num_ALL\*(Aq;
.Ve
.PP
which will export \f(CW\*(C`RE_num_int\*(C'\fR and \f(CW\*(C`RE_num_real\*(C'\fR (and if you have
create more patterns who have first key \fInum\fR, those will be exported
as well). In general, \fIRE_key1_..._keyn_ALL\fR will export all subroutines
whose pattern names have first keys \fIkey1\fR ... \fIkeyn\fR.
.SS "Adding new regular expressions"
.IX Subsection "Adding new regular expressions"
You can add your own regular expressions to the \f(CW%RE\fR hash at run-time,
using the exportable \f(CW\*(C`pattern\*(C'\fR subroutine. It expects a hash-like list of 
key/value pairs that specify the behaviour of the pattern. The various
possible argument pairs are:
.ie n .IP """name => [ @list ]""" 4
.el .IP "\f(CWname => [ @list ]\fR" 4
.IX Item "name => [ @list ]"
A required argument that specifies the name of the pattern, and any
flags it may take, via a reference to a list of strings. For example:
.Sp
.Vb 3
\&         pattern name => [qw( line of \-char )],
\&                 # other args here
\&                 ;
.Ve
.Sp
This specifies an entry \f(CW$RE{line}{of}\fR, which may take a \f(CW\*(C`\-char\*(C'\fR flag.
.Sp
Flags may also be specified with a default value, which is then used whenever
the flag is specified without an explicit value (but not when the flag is
omitted). For example:
.Sp
.Vb 4
\&         pattern name => [qw( line of \-char=_ )],
\&                 # default char is \*(Aq_\*(Aq
\&                 # other args here
\&                 ;
.Ve
.ie n .IP """create => $sub_ref_or_string""" 4
.el .IP "\f(CWcreate => $sub_ref_or_string\fR" 4
.IX Item "create => $sub_ref_or_string"
A required argument that specifies either a string that is to be returned
as the pattern:
.Sp
.Vb 3
\&        pattern name    => [qw( line of underscores )],
\&                create  => q/(?:^_+$)/
\&                ;
.Ve
.Sp
or a reference to a subroutine that will be called to create the pattern:
.Sp
.Vb 7
\&        pattern name    => [qw( line of \-char=_ )],
\&                create  => sub {
\&                                my ($self, $flags) = @_;
\&                                my $char = quotemeta $flags\->{\-char};
\&                                return \*(Aq(?:^$char+$)\*(Aq;
\&                            },
\&                ;
.Ve
.Sp
If the subroutine version is used, the subroutine will be called with 
three arguments: a reference to the pattern object itself, a reference
to a hash containing the flags and their values,
and a reference to an array containing the non-flag keys.
.Sp
Whatever the subroutine returns is stringified as the pattern.
.Sp
No matter how the pattern is created, it is immediately postprocessed to
include or exclude capturing parentheses (according to the value of the
\&\f(CW\*(C`\-keep\*(C'\fR flag). To specify such \*(L"optional\*(R" capturing parentheses within
the regular expression associated with \f(CW\*(C`create\*(C'\fR, use the notation
\&\f(CW\*(C`(?k:...)\*(C'\fR. Any parentheses of this type will be converted to \f(CW\*(C`(...)\*(C'\fR
when the \f(CW\*(C`\-keep\*(C'\fR flag is specified, or \f(CW\*(C`(?:...)\*(C'\fR when it is not.
It is a Regexp::Common convention that the outermost capturing parentheses
always capture the entire pattern, but this is not enforced.
.ie n .IP """match => $sub_ref""" 4
.el .IP "\f(CWmatch => $sub_ref\fR" 4
.IX Item "match => $sub_ref"
An optional argument that specifies a subroutine that is to be called when
the \f(CW\*(C`$RE{...}\->matches(...)\*(C'\fR method of this pattern is invoked.
.Sp
The subroutine should expect two arguments: a reference to the pattern object
itself, and the string to be matched against.
.Sp
It should return the same types of values as a \f(CW\*(C`m/.../\*(C'\fR does.
.Sp
.Vb 7
\&     pattern name    => [qw( line of \-char )],
\&             create  => sub {...},
\&             match   => sub {
\&                             my ($self, $str) = @_;
\&                             $str !~ /[^$self\->{flags}{\-char}]/;
\&                        },
\&             ;
.Ve
.ie n .IP """subs => $sub_ref""" 4
.el .IP "\f(CWsubs => $sub_ref\fR" 4
.IX Item "subs => $sub_ref"
An optional argument that specifies a subroutine that is to be called when
the \f(CW\*(C`$RE{...}\->subs(...)\*(C'\fR method of this pattern is invoked.
.Sp
The subroutine should expect three arguments: a reference to the pattern object
itself, the string to be changed, and the value to be substituted into it.
The third argument may be \f(CW\*(C`undef\*(C'\fR, indicating the default substitution is
required.
.Sp
The subroutine should return the same types of values as an \f(CW\*(C`s/.../.../\*(C'\fR does.
.Sp
For example:
.Sp
.Vb 7
\&     pattern name    => [ \*(Aqlineof\*(Aq, \*(Aq\-char=_\*(Aq ],
\&             create  => sub {...},
\&             subs    => sub {
\&                          my ($self, $str, $ignore_replacement) = @_;
\&                          $_[1] =~ s/^$self\->{flags}{\-char}+$//g;
\&                        },
\&             ;
.Ve
.Sp
Note that such a subroutine will almost always need to modify \f(CW$_[1]\fR directly.
.ie n .IP """version => $minimum_perl_version""" 4
.el .IP "\f(CWversion => $minimum_perl_version\fR" 4
.IX Item "version => $minimum_perl_version"
If this argument is given, it specifies the minimum version of perl required
to use the new pattern. Attempts to use the pattern with earlier versions of
perl will generate a fatal diagnostic.
.SS "Loading specific sets of patterns."
.IX Subsection "Loading specific sets of patterns."
By default, all the sets of patterns listed below are made available.
However, it is possible to indicate which sets of patterns should
be made available \- the wanted sets should be given as arguments to
\&\f(CW\*(C`use\*(C'\fR. Alternatively, it is also possible to indicate which sets of
patterns should not be made available \- those sets will be given as
argument to the \f(CW\*(C`use\*(C'\fR statement, but are preceeded with an exclaimation
mark. The argument \fIno_defaults\fR indicates none of the default patterns
should be made available. This is useful for instance if all you want
is the \f(CW\*(C`pattern()\*(C'\fR subroutine.
.PP
Examples:
.PP
.Vb 3
\& use Regexp::Common qw /comment number/;  # Comment and number patterns.
\& use Regexp::Common qw /no_defaults/;     # Don\*(Aqt load any patterns.
\& use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
.Ve
.PP
It's also possible to load your own set of patterns. If you have a
module \f(CW\*(C`Regexp::Common::my_patterns\*(C'\fR that makes patterns available,
you can have it made available with
.PP
.Vb 1
\& use Regexp::Common qw /my_patterns/;
.Ve
.PP
Note that the default patterns will still be made available \- only if
you use \fIno_defaults\fR, or mention one of the default sets explicitely,
the non mentioned defaults aren't made available.
.SS "List of available patterns"
.IX Subsection "List of available patterns"
The patterns listed below are currently available. Each set of patterns
has its own manual page describing the details. For each pattern set
named \fIname\fR, the manual page \fIRegexp::Common::name\fR describes the
details.
.PP
Currently available are:
.IP "Regexp::Common::balanced" 4
.IX Item "Regexp::Common::balanced"
Provides regexes for strings with balanced parenthesized delimiters.
.IP "Regexp::Common::comment" 4
.IX Item "Regexp::Common::comment"
Provides regexes for comments of various languages (43 languages
currently).
.IP "Regexp::Common::delimited" 4
.IX Item "Regexp::Common::delimited"
Provides regexes for delimited strings.
.IP "Regexp::Common::lingua" 4
.IX Item "Regexp::Common::lingua"
Provides regexes for palindromes.
.IP "Regexp::Common::list" 4
.IX Item "Regexp::Common::list"
Provides regexes for lists.
.IP "Regexp::Common::net" 4
.IX Item "Regexp::Common::net"
Provides regexes for IPv4 addresses and \s-1MAC\s0 addresses.
.IP "Regexp::Common::number" 4
.IX Item "Regexp::Common::number"
Provides regexes for numbers (integers and reals).
.IP "Regexp::Common::profanity" 4
.IX Item "Regexp::Common::profanity"
Provides regexes for profanity.
.IP "Regexp::Common::whitespace" 4
.IX Item "Regexp::Common::whitespace"
Provides regexes for leading and trailing whitespace.
.IP "Regexp::Common::zip" 4
.IX Item "Regexp::Common::zip"
Provides regexes for zip codes.
.SS "Forthcoming patterns and features"
.IX Subsection "Forthcoming patterns and features"
Future releases of the module will also provide patterns for the following:
.PP
.Vb 9
\&        * email addresses 
\&        * HTML/XML tags
\&        * more numerical matchers,
\&        * mail headers (including multiline ones),
\&        * more URLS
\&        * telephone numbers of various countries
\&        * currency (universal 3 letter format, Latin\-1, currency names)
\&        * dates
\&        * binary formats (e.g. UUencoded, MIMEd)
.Ve
.PP
If you have other patterns or pattern generators that you think would be
generally useful, please send them to the maintainer \*(-- preferably as source
code using the \f(CW\*(C`pattern\*(C'\fR subroutine. Submissions that include a set of
tests will be especially welcome.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Can\*(Aqt export unknown subroutine %s""" 4
.el .IP "\f(CWCan\*(Aqt export unknown subroutine %s\fR" 4
.IX Item "Cant export unknown subroutine %s"
The subroutine-based interface didn't recognize the requested subroutine.
Often caused by a spelling mistake or an incompletely specified name.
.ie n .IP """Can\*(Aqt create unknown regex: $RE{...}""" 4
.el .IP "\f(CWCan\*(Aqt create unknown regex: $RE{...}\fR" 4
.IX Item "Cant create unknown regex: $RE{...}"
Regexp::Common doesn't have a generator for the requested pattern.
Often indicates a mispelt or missing parameter.
.ie n .IP " ""Perl %f does not support the pattern $RE{...}. You need Perl %f or later""" 4
.el .IP " \f(CWPerl %f does not support the pattern $RE{...}. You need Perl %f or later\fR" 4
.IX Item " Perl %f does not support the pattern $RE{...}. You need Perl %f or later"
The requested pattern requires advanced regex features (e.g. recursion)
that not available in your version of Perl. Time to upgrade.
.ie n .IP """pattern() requires argument: name => [ @list ]""" 4
.el .IP "\f(CWpattern() requires argument: name => [ @list ]\fR" 4
.IX Item "pattern() requires argument: name => [ @list ]"
Every user-defined pattern specification must have a name.
.ie n .IP """pattern() requires argument: create => $sub_ref_or_string""" 4
.el .IP "\f(CWpattern() requires argument: create => $sub_ref_or_string\fR" 4
.IX Item "pattern() requires argument: create => $sub_ref_or_string"
Every user-defined pattern specification must provide a pattern creation
mechanism: either a pattern string or a reference to a subroutine that
returns the pattern string.
.ie n .IP """Base must be between 1 and 36""" 4
.el .IP "\f(CWBase must be between 1 and 36\fR" 4
.IX Item "Base must be between 1 and 36"
The \f(CW$RE{num}{real}{\-base=>\*(Aq\f(CIN\f(CW\*(Aq}\fR pattern uses the characters [0\-9A\-Z]
to represent the digits of various bases. Hence it only produces
regular expressions for bases up to hexatricensimal.
.ie n .IP """Must specify delimiter in $RE{delimited}""" 4
.el .IP "\f(CWMust specify delimiter in $RE{delimited}\fR" 4
.IX Item "Must specify delimiter in $RE{delimited}"
The pattern has no default delimiter.
You need to write: \f(CW$RE{delimited}{\-delim=>\f(CIX\f(CW\*(Aq}\fR for some character \fIX\fR
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Deepest thanks to the many people who have encouraged and contributed to this
project, especially: Elijah, Jarkko, Tom, Nat, Ed, and Vivek.
.PP
Further thanks go to: Alexandr Ciornii, Blair Zajac, Bob Stockdale,
Charles Thomas, Chris Vertonghen, the \s-1CPAN\s0 Testers, David Hand,
Fany, Geoffrey Leach, Hermann-Marcus Behrens, Jerome Quelin, Jim Cromie,
Lars Wilke, Linda Julien, Mike Arms, Mike Castle, Mikko, Murat Uenalan,
Rafae\*:l Garcia-Suarez, Ron Savage, Sam Vilain, Slaven Rezic, Smylers,
Tim Maher, and all the others I've forgotten.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in to \fIregexp\-common@abigail.be\fR.
.PP
There are some \s-1POD\s0 issues when installing this module using a pre\-5.6.0 perl;
some manual pages may not install, or may not install correctly using a perl
that is that old. You might consider upgrading your perl.
.SH "NOT A BUG"
.IX Header "NOT A BUG"
.IP "\(bu" 4
The various patterns are not anchored. That is, a pattern like 
\&\f(CW\*(C`$RE {num} {int}\*(C'\fR will match against \*(L"abc4def\*(R", because a 
substring of the subject matches. This is by design, and not a
bug. If you want the pattern to be anchored, use something like:
.Sp
.Vb 2
\& my $integer = $RE {num} {int};
\& $subj =~ /^$integer$/ and print "Matches!\en";
.Ve
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2011, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common5.16.3pm                       0100644 0001750 0001750 00000065155 12566242000 024403  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common 3"
.TH Regexp::Common 3 "2011-12-10" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common \- Provide commonly requested regular expressions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # STANDARD USAGE 
\&
\& use Regexp::Common;
\&
\& while (<>) {
\&     /$RE{num}{real}/               and print q{a number};
\&     /$RE{quoted}/                  and print q{a [\*(Aq"\`] quoted string};
\&     /$RE{delimited}{\-delim=>\*(Aq/\*(Aq}/  and print q{a /.../ sequence};
\&     /$RE{balanced}{\-parens=>\*(Aq()\*(Aq}/ and print q{balanced parentheses};
\&     /$RE{profanity}/               and print q{a #*@%\-ing word};
\& }
\&
\&
\& # SUBROUTINE\-BASED INTERFACE
\&
\& use Regexp::Common \*(AqRE_ALL\*(Aq;
\&
\& while (<>) {
\&     $_ =~ RE_num_real()              and print q{a number};
\&     $_ =~ RE_quoted()                and print q{a [\*(Aq"\`] quoted string};
\&     $_ =~ RE_delimited(\-delim=>\*(Aq/\*(Aq)  and print q{a /.../ sequence};
\&     $_ =~ RE_balanced(\-parens=>\*(Aq()\*(Aq} and print q{balanced parentheses};
\&     $_ =~ RE_profanity()             and print q{a #*@%\-ing word};
\& }
\&
\&
\& # IN\-LINE MATCHING...
\&
\& if ( $RE{num}{int}\->matches($text) ) {...}
\&
\&
\& # ...AND SUBSTITUTION
\&
\& my $cropped = $RE{ws}{crop}\->subs($uncropped);
\&
\&
\& # ROLL\-YOUR\-OWN PATTERNS
\&
\& use Regexp::Common \*(Aqpattern\*(Aq;
\&
\& pattern name   => [\*(Aqname\*(Aq, \*(Aqmine\*(Aq],
\&         create => \*(Aq(?i:J[.]?\es+A[.]?\es+Perl\-Hacker)\*(Aq,
\&         ;
\&
\& my $name_matcher = $RE{name}{mine};
\&
\& pattern name    => [ \*(Aqlineof\*(Aq, \*(Aq\-char=_\*(Aq ],
\&         create  => sub {
\&                        my $flags = shift;
\&                        my $char = quotemeta $flags\->{\-char};
\&                        return \*(Aq(?:^$char+$)\*(Aq;
\&                    },
\&         match   => sub {
\&                        my ($self, $str) = @_;
\&                        return $str !~ /[^$self\->{flags}{\-char}]/;
\&                    },
\&         subs   => sub {
\&                        my ($self, $str, $replacement) = @_;
\&                        $_[1] =~ s/^$self\->{flags}{\-char}+$//g;
\&                   },
\&         ;
\&
\& my $asterisks = $RE{lineof}{\-char=>\*(Aq*\*(Aq};
\&
\& # DECIDING WHICH PATTERNS TO LOAD.
\&
\& use Regexp::Common qw /comment number/;  # Comment and number patterns.
\& use Regexp::Common qw /no_defaults/;     # Don\*(Aqt load any patterns.
\& use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
By default, this module exports a single hash (\f(CW%RE\fR) that stores or generates
commonly needed regular expressions (see \*(L"List of available patterns\*(R").
.PP
There is an alternative, subroutine-based syntax described in
\&\*(L"Subroutine-based interface\*(R".
.SS "General syntax for requesting patterns"
.IX Subsection "General syntax for requesting patterns"
To access a particular pattern, \f(CW%RE\fR is treated as a hierarchical hash of
hashes (of hashes...), with each successive key being an identifier. For
example, to access the pattern that matches real numbers, you 
specify:
.PP
.Vb 1
\&        $RE{num}{real}
.Ve
.PP
and to access the pattern that matches integers:
.PP
.Vb 1
\&        $RE{num}{int}
.Ve
.PP
Deeper layers of the hash are used to specify \fIflags\fR: arguments that
modify the resulting pattern in some way. The keys used to access these
layers are prefixed with a minus sign and may have a value; if a value
is given, it's done by using a multidimensional key.
For example, to access the pattern that
matches base\-2 real numbers with embedded commas separating
groups of three digits (e.g. 10,101,110.110101101):
.PP
.Vb 1
\&        $RE{num}{real}{\-base => 2}{\-sep => \*(Aq,\*(Aq}{\-group => 3}
.Ve
.PP
Through the magic of Perl, these flag layers may be specified in any order
(and even interspersed through the identifier keys!)
so you could get the same pattern with:
.PP
.Vb 1
\&        $RE{num}{real}{\-sep => \*(Aq,\*(Aq}{\-group => 3}{\-base => 2}
.Ve
.PP
or:
.PP
.Vb 1
\&        $RE{num}{\-base => 2}{real}{\-group => 3}{\-sep => \*(Aq,\*(Aq}
.Ve
.PP
or even:
.PP
.Vb 1
\&        $RE{\-base => 2}{\-group => 3}{\-sep => \*(Aq,\*(Aq}{num}{real}
.Ve
.PP
etc.
.PP
Note, however, that the relative order of amongst the identifier keys
\&\fIis\fR significant. That is:
.PP
.Vb 1
\&        $RE{list}{set}
.Ve
.PP
would not be the same as:
.PP
.Vb 1
\&        $RE{set}{list}
.Ve
.SS "Flag syntax"
.IX Subsection "Flag syntax"
In versions prior to 2.113, flags could also be written as
\&\f(CW\*(C`{"\-flag=value"}\*(C'\fR. This no longer works, although \f(CW\*(C`{"\-flag$;value"}\*(C'\fR
still does. However, \f(CW\*(C`{\-flag => \*(Aqvalue\*(Aq}\*(C'\fR is the preferred syntax.
.SS "Universal flags"
.IX Subsection "Universal flags"
Normally, flags are specific to a single pattern.
However, there is two flags that all patterns may specify.
.ie n .IP """\-keep""" 4
.el .IP "\f(CW\-keep\fR" 4
.IX Item "-keep"
By default, the patterns provided by \f(CW%RE\fR contain no capturing
parentheses. However, if the \f(CW\*(C`\-keep\*(C'\fR flag is specified (it requires
no value) then any significant substrings that the pattern matches
are captured. For example:
.Sp
.Vb 5
\&        if ($str =~ $RE{num}{real}{\-keep}) {
\&                $number   = $1;
\&                $whole    = $3;
\&                $decimals = $5;
\&        }
.Ve
.Sp
Special care is needed if a \*(L"kept\*(R" pattern is interpolated into a
larger regular expression, as the presence of other capturing
parentheses is likely to change the \*(L"number variables\*(R" into which significant
substrings are saved.
.Sp
See also \*(L"Adding new regular expressions\*(R", which describes how to create
new patterns with \*(L"optional\*(R" capturing brackets that respond to \f(CW\*(C`\-keep\*(C'\fR.
.ie n .IP """\-i""" 4
.el .IP "\f(CW\-i\fR" 4
.IX Item "-i"
Some patterns or subpatterns only match lowercase or uppercase letters.
If one wants the do case insensitive matching, one option is to use
the \f(CW\*(C`/i\*(C'\fR regexp modifier, or the special sequence \f(CW\*(C`(?i)\*(C'\fR. But if the
functional interface is used, one does not have this option. The 
\&\f(CW\*(C`\-i\*(C'\fR switch solves this problem; by using it, the pattern will do
case insensitive matching.
.SS "\s-1OO\s0 interface and inline matching/substitution"
.IX Subsection "OO interface and inline matching/substitution"
The patterns returned from \f(CW%RE\fR are objects, so rather than writing:
.PP
.Vb 1
\&        if ($str =~ /$RE{some}{pattern}/ ) {...}
.Ve
.PP
you can write:
.PP
.Vb 1
\&        if ( $RE{some}{pattern}\->matches($str) ) {...}
.Ve
.PP
For matching this would seem to have no great advantage apart from readability
(but see below).
.PP
For substitutions, it has other significant benefits. Frequently you want to
perform a substitution on a string without changing the original. Most people
use this:
.PP
.Vb 2
\&        $changed = $original;
\&        $changed =~ s/$RE{some}{pattern}/$replacement/;
.Ve
.PP
The more adept use:
.PP
.Vb 1
\&        ($changed = $original) =~ s/$RE{some}{pattern}/$replacement/;
.Ve
.PP
Regexp::Common allows you do write this:
.PP
.Vb 1
\&        $changed = $RE{some}{pattern}\->subs($original=>$replacement);
.Ve
.PP
Apart from reducing precedence-angst, this approach has the added
advantages that the substitution behaviour can be optimized from the 
regular expression, and the replacement string can be provided by
default (see \*(L"Adding new regular expressions\*(R").
.PP
For example, in the implementation of this substitution:
.PP
.Vb 1
\&        $cropped = $RE{ws}{crop}\->subs($uncropped);
.Ve
.PP
the default empty string is provided automatically, and the substitution is
optimized to use:
.PP
.Vb 2
\&        $uncropped =~ s/^\es+//;
\&        $uncropped =~ s/\es+$//;
.Ve
.PP
rather than:
.PP
.Vb 1
\&        $uncropped =~ s/^\es+|\es+$//g;
.Ve
.SS "Subroutine-based interface"
.IX Subsection "Subroutine-based interface"
The hash-based interface was chosen because it allows regexes to be
effortlessly interpolated, and because it also allows them to be
\&\*(L"curried\*(R". For example:
.PP
.Vb 1
\&        my $num = $RE{num}{int};
\&
\&        my $commad     = $num\->{\-sep=>\*(Aq,\*(Aq}{\-group=>3};
\&        my $duodecimal = $num\->{\-base=>12};
.Ve
.PP
However, the use of tied hashes does make the access to Regexp::Common
patterns slower than it might otherwise be. In contexts where impatience
overrules laziness, Regexp::Common provides an additional
subroutine-based interface.
.PP
For each (sub\-)entry in the \f(CW%RE\fR hash (\f(CW$RE{key1}{key2}{etc}\fR), there
is a corresponding exportable subroutine: \f(CW\*(C`RE_key1_key2_etc()\*(C'\fR. The name of
each subroutine is the underscore-separated concatenation of the \fInon-flag\fR
keys that locate the same pattern in \f(CW%RE\fR. Flags are passed to the subroutine
in its argument list. Thus:
.PP
.Vb 1
\&        use Regexp::Common qw( RE_ws_crop RE_num_real RE_profanity );
\&
\&        $str =~ RE_ws_crop() and die "Surrounded by whitespace";
\&
\&        $str =~ RE_num_real(\-base=>8, \-sep=>" ") or next;
\&
\&        $offensive = RE_profanity(\-keep);
\&        $str =~ s/$offensive/$bad{$1}++; "<expletive deleted>"/ge;
.Ve
.PP
Note that, unlike the hash-based interface (which returns objects), these
subroutines return ordinary \f(CW\*(C`qr\*(C'\fR'd regular expressions. Hence they do not
curry, nor do they provide the \s-1OO\s0 match and substitution inlining described
in the previous section.
.PP
It is also possible to export subroutines for all available patterns like so:
.PP
.Vb 1
\&        use Regexp::Common \*(AqRE_ALL\*(Aq;
.Ve
.PP
Or you can export all subroutines with a common prefix of keys like so:
.PP
.Vb 1
\&        use Regexp::Common \*(AqRE_num_ALL\*(Aq;
.Ve
.PP
which will export \f(CW\*(C`RE_num_int\*(C'\fR and \f(CW\*(C`RE_num_real\*(C'\fR (and if you have
create more patterns who have first key \fInum\fR, those will be exported
as well). In general, \fIRE_key1_..._keyn_ALL\fR will export all subroutines
whose pattern names have first keys \fIkey1\fR ... \fIkeyn\fR.
.SS "Adding new regular expressions"
.IX Subsection "Adding new regular expressions"
You can add your own regular expressions to the \f(CW%RE\fR hash at run-time,
using the exportable \f(CW\*(C`pattern\*(C'\fR subroutine. It expects a hash-like list of 
key/value pairs that specify the behaviour of the pattern. The various
possible argument pairs are:
.ie n .IP """name => [ @list ]""" 4
.el .IP "\f(CWname => [ @list ]\fR" 4
.IX Item "name => [ @list ]"
A required argument that specifies the name of the pattern, and any
flags it may take, via a reference to a list of strings. For example:
.Sp
.Vb 3
\&         pattern name => [qw( line of \-char )],
\&                 # other args here
\&                 ;
.Ve
.Sp
This specifies an entry \f(CW$RE{line}{of}\fR, which may take a \f(CW\*(C`\-char\*(C'\fR flag.
.Sp
Flags may also be specified with a default value, which is then used whenever
the flag is specified without an explicit value (but not when the flag is
omitted). For example:
.Sp
.Vb 4
\&         pattern name => [qw( line of \-char=_ )],
\&                 # default char is \*(Aq_\*(Aq
\&                 # other args here
\&                 ;
.Ve
.ie n .IP """create => $sub_ref_or_string""" 4
.el .IP "\f(CWcreate => $sub_ref_or_string\fR" 4
.IX Item "create => $sub_ref_or_string"
A required argument that specifies either a string that is to be returned
as the pattern:
.Sp
.Vb 3
\&        pattern name    => [qw( line of underscores )],
\&                create  => q/(?:^_+$)/
\&                ;
.Ve
.Sp
or a reference to a subroutine that will be called to create the pattern:
.Sp
.Vb 7
\&        pattern name    => [qw( line of \-char=_ )],
\&                create  => sub {
\&                                my ($self, $flags) = @_;
\&                                my $char = quotemeta $flags\->{\-char};
\&                                return \*(Aq(?:^$char+$)\*(Aq;
\&                            },
\&                ;
.Ve
.Sp
If the subroutine version is used, the subroutine will be called with 
three arguments: a reference to the pattern object itself, a reference
to a hash containing the flags and their values,
and a reference to an array containing the non-flag keys.
.Sp
Whatever the subroutine returns is stringified as the pattern.
.Sp
No matter how the pattern is created, it is immediately postprocessed to
include or exclude capturing parentheses (according to the value of the
\&\f(CW\*(C`\-keep\*(C'\fR flag). To specify such \*(L"optional\*(R" capturing parentheses within
the regular expression associated with \f(CW\*(C`create\*(C'\fR, use the notation
\&\f(CW\*(C`(?k:...)\*(C'\fR. Any parentheses of this type will be converted to \f(CW\*(C`(...)\*(C'\fR
when the \f(CW\*(C`\-keep\*(C'\fR flag is specified, or \f(CW\*(C`(?:...)\*(C'\fR when it is not.
It is a Regexp::Common convention that the outermost capturing parentheses
always capture the entire pattern, but this is not enforced.
.ie n .IP """match => $sub_ref""" 4
.el .IP "\f(CWmatch => $sub_ref\fR" 4
.IX Item "match => $sub_ref"
An optional argument that specifies a subroutine that is to be called when
the \f(CW\*(C`$RE{...}\->matches(...)\*(C'\fR method of this pattern is invoked.
.Sp
The subroutine should expect two arguments: a reference to the pattern object
itself, and the string to be matched against.
.Sp
It should return the same types of values as a \f(CW\*(C`m/.../\*(C'\fR does.
.Sp
.Vb 7
\&     pattern name    => [qw( line of \-char )],
\&             create  => sub {...},
\&             match   => sub {
\&                             my ($self, $str) = @_;
\&                             $str !~ /[^$self\->{flags}{\-char}]/;
\&                        },
\&             ;
.Ve
.ie n .IP """subs => $sub_ref""" 4
.el .IP "\f(CWsubs => $sub_ref\fR" 4
.IX Item "subs => $sub_ref"
An optional argument that specifies a subroutine that is to be called when
the \f(CW\*(C`$RE{...}\->subs(...)\*(C'\fR method of this pattern is invoked.
.Sp
The subroutine should expect three arguments: a reference to the pattern object
itself, the string to be changed, and the value to be substituted into it.
The third argument may be \f(CW\*(C`undef\*(C'\fR, indicating the default substitution is
required.
.Sp
The subroutine should return the same types of values as an \f(CW\*(C`s/.../.../\*(C'\fR does.
.Sp
For example:
.Sp
.Vb 7
\&     pattern name    => [ \*(Aqlineof\*(Aq, \*(Aq\-char=_\*(Aq ],
\&             create  => sub {...},
\&             subs    => sub {
\&                          my ($self, $str, $ignore_replacement) = @_;
\&                          $_[1] =~ s/^$self\->{flags}{\-char}+$//g;
\&                        },
\&             ;
.Ve
.Sp
Note that such a subroutine will almost always need to modify \f(CW$_[1]\fR directly.
.ie n .IP """version => $minimum_perl_version""" 4
.el .IP "\f(CWversion => $minimum_perl_version\fR" 4
.IX Item "version => $minimum_perl_version"
If this argument is given, it specifies the minimum version of perl required
to use the new pattern. Attempts to use the pattern with earlier versions of
perl will generate a fatal diagnostic.
.SS "Loading specific sets of patterns."
.IX Subsection "Loading specific sets of patterns."
By default, all the sets of patterns listed below are made available.
However, it is possible to indicate which sets of patterns should
be made available \- the wanted sets should be given as arguments to
\&\f(CW\*(C`use\*(C'\fR. Alternatively, it is also possible to indicate which sets of
patterns should not be made available \- those sets will be given as
argument to the \f(CW\*(C`use\*(C'\fR statement, but are preceeded with an exclaimation
mark. The argument \fIno_defaults\fR indicates none of the default patterns
should be made available. This is useful for instance if all you want
is the \f(CW\*(C`pattern()\*(C'\fR subroutine.
.PP
Examples:
.PP
.Vb 3
\& use Regexp::Common qw /comment number/;  # Comment and number patterns.
\& use Regexp::Common qw /no_defaults/;     # Don\*(Aqt load any patterns.
\& use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
.Ve
.PP
It's also possible to load your own set of patterns. If you have a
module \f(CW\*(C`Regexp::Common::my_patterns\*(C'\fR that makes patterns available,
you can have it made available with
.PP
.Vb 1
\& use Regexp::Common qw /my_patterns/;
.Ve
.PP
Note that the default patterns will still be made available \- only if
you use \fIno_defaults\fR, or mention one of the default sets explicitely,
the non mentioned defaults aren't made available.
.SS "List of available patterns"
.IX Subsection "List of available patterns"
The patterns listed below are currently available. Each set of patterns
has its own manual page describing the details. For each pattern set
named \fIname\fR, the manual page \fIRegexp::Common::name\fR describes the
details.
.PP
Currently available are:
.IP "Regexp::Common::balanced" 4
.IX Item "Regexp::Common::balanced"
Provides regexes for strings with balanced parenthesized delimiters.
.IP "Regexp::Common::comment" 4
.IX Item "Regexp::Common::comment"
Provides regexes for comments of various languages (43 languages
currently).
.IP "Regexp::Common::delimited" 4
.IX Item "Regexp::Common::delimited"
Provides regexes for delimited strings.
.IP "Regexp::Common::lingua" 4
.IX Item "Regexp::Common::lingua"
Provides regexes for palindromes.
.IP "Regexp::Common::list" 4
.IX Item "Regexp::Common::list"
Provides regexes for lists.
.IP "Regexp::Common::net" 4
.IX Item "Regexp::Common::net"
Provides regexes for IPv4 addresses and \s-1MAC\s0 addresses.
.IP "Regexp::Common::number" 4
.IX Item "Regexp::Common::number"
Provides regexes for numbers (integers and reals).
.IP "Regexp::Common::profanity" 4
.IX Item "Regexp::Common::profanity"
Provides regexes for profanity.
.IP "Regexp::Common::whitespace" 4
.IX Item "Regexp::Common::whitespace"
Provides regexes for leading and trailing whitespace.
.IP "Regexp::Common::zip" 4
.IX Item "Regexp::Common::zip"
Provides regexes for zip codes.
.SS "Forthcoming patterns and features"
.IX Subsection "Forthcoming patterns and features"
Future releases of the module will also provide patterns for the following:
.PP
.Vb 9
\&        * email addresses 
\&        * HTML/XML tags
\&        * more numerical matchers,
\&        * mail headers (including multiline ones),
\&        * more URLS
\&        * telephone numbers of various countries
\&        * currency (universal 3 letter format, Latin\-1, currency names)
\&        * dates
\&        * binary formats (e.g. UUencoded, MIMEd)
.Ve
.PP
If you have other patterns or pattern generators that you think would be
generally useful, please send them to the maintainer \*(-- preferably as source
code using the \f(CW\*(C`pattern\*(C'\fR subroutine. Submissions that include a set of
tests will be especially welcome.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Can\*(Aqt export unknown subroutine %s""" 4
.el .IP "\f(CWCan\*(Aqt export unknown subroutine %s\fR" 4
.IX Item "Cant export unknown subroutine %s"
The subroutine-based interface didn't recognize the requested subroutine.
Often caused by a spelling mistake or an incompletely specified name.
.ie n .IP """Can\*(Aqt create unknown regex: $RE{...}""" 4
.el .IP "\f(CWCan\*(Aqt create unknown regex: $RE{...}\fR" 4
.IX Item "Cant create unknown regex: $RE{...}"
Regexp::Common doesn't have a generator for the requested pattern.
Often indicates a mispelt or missing parameter.
.ie n .IP " ""Perl %f does not support the pattern $RE{...}. You need Perl %f or later""" 4
.el .IP " \f(CWPerl %f does not support the pattern $RE{...}. You need Perl %f or later\fR" 4
.IX Item " Perl %f does not support the pattern $RE{...}. You need Perl %f or later"
The requested pattern requires advanced regex features (e.g. recursion)
that not available in your version of Perl. Time to upgrade.
.ie n .IP """pattern() requires argument: name => [ @list ]""" 4
.el .IP "\f(CWpattern() requires argument: name => [ @list ]\fR" 4
.IX Item "pattern() requires argument: name => [ @list ]"
Every user-defined pattern specification must have a name.
.ie n .IP """pattern() requires argument: create => $sub_ref_or_string""" 4
.el .IP "\f(CWpattern() requires argument: create => $sub_ref_or_string\fR" 4
.IX Item "pattern() requires argument: create => $sub_ref_or_string"
Every user-defined pattern specification must provide a pattern creation
mechanism: either a pattern string or a reference to a subroutine that
returns the pattern string.
.ie n .IP """Base must be between 1 and 36""" 4
.el .IP "\f(CWBase must be between 1 and 36\fR" 4
.IX Item "Base must be between 1 and 36"
The \f(CW$RE{num}{real}{\-base=>\*(Aq\f(CIN\f(CW\*(Aq}\fR pattern uses the characters [0\-9A\-Z]
to represent the digits of various bases. Hence it only produces
regular expressions for bases up to hexatricensimal.
.ie n .IP """Must specify delimiter in $RE{delimited}""" 4
.el .IP "\f(CWMust specify delimiter in $RE{delimited}\fR" 4
.IX Item "Must specify delimiter in $RE{delimited}"
The pattern has no default delimiter.
You need to write: \f(CW$RE{delimited}{\-delim=>\f(CIX\f(CW\*(Aq}\fR for some character \fIX\fR
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Deepest thanks to the many people who have encouraged and contributed to this
project, especially: Elijah, Jarkko, Tom, Nat, Ed, and Vivek.
.PP
Further thanks go to: Alexandr Ciornii, Blair Zajac, Bob Stockdale,
Charles Thomas, Chris Vertonghen, the \s-1CPAN\s0 Testers, David Hand,
Fany, Geoffrey Leach, Hermann-Marcus Behrens, Jerome Quelin, Jim Cromie,
Lars Wilke, Linda Julien, Mike Arms, Mike Castle, Mikko, Murat Uenalan,
Rafae\*:l Garcia-Suarez, Ron Savage, Sam Vilain, Slaven Rezic, Smylers,
Tim Maher, and all the others I've forgotten.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in to \fIregexp\-common@abigail.be\fR.
.PP
There are some \s-1POD\s0 issues when installing this module using a pre\-5.6.0 perl;
some manual pages may not install, or may not install correctly using a perl
that is that old. You might consider upgrading your perl.
.SH "NOT A BUG"
.IX Header "NOT A BUG"
.IP "\(bu" 4
The various patterns are not anchored. That is, a pattern like 
\&\f(CW\*(C`$RE {num} {int}\*(C'\fR will match against \*(L"abc4def\*(R", because a 
substring of the subject matches. This is by design, and not a
bug. If you want the pattern to be anchored, use something like:
.Sp
.Vb 2
\& my $integer = $RE {num} {int};
\& $subj =~ /^$integer$/ and print "Matches!\en";
.Ve
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2011, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common5.18.3pm                       0100644 0001750 0001750 00000065476 12566242002 024415  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common 3"
.TH Regexp::Common 3 "2013-03-13" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common \- Provide commonly requested regular expressions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # STANDARD USAGE 
\&
\& use Regexp::Common;
\&
\& while (<>) {
\&     /$RE{num}{real}/               and print q{a number};
\&     /$RE{quoted}/                  and print q{a [\*(Aq"\`] quoted string};
\&     /$RE{delimited}{\-delim=>\*(Aq/\*(Aq}/  and print q{a /.../ sequence};
\&     /$RE{balanced}{\-parens=>\*(Aq()\*(Aq}/ and print q{balanced parentheses};
\&     /$RE{profanity}/               and print q{a #*@%\-ing word};
\& }
\&
\&
\& # SUBROUTINE\-BASED INTERFACE
\&
\& use Regexp::Common \*(AqRE_ALL\*(Aq;
\&
\& while (<>) {
\&     $_ =~ RE_num_real()              and print q{a number};
\&     $_ =~ RE_quoted()                and print q{a [\*(Aq"\`] quoted string};
\&     $_ =~ RE_delimited(\-delim=>\*(Aq/\*(Aq)  and print q{a /.../ sequence};
\&     $_ =~ RE_balanced(\-parens=>\*(Aq()\*(Aq} and print q{balanced parentheses};
\&     $_ =~ RE_profanity()             and print q{a #*@%\-ing word};
\& }
\&
\&
\& # IN\-LINE MATCHING...
\&
\& if ( $RE{num}{int}\->matches($text) ) {...}
\&
\&
\& # ...AND SUBSTITUTION
\&
\& my $cropped = $RE{ws}{crop}\->subs($uncropped);
\&
\&
\& # ROLL\-YOUR\-OWN PATTERNS
\&
\& use Regexp::Common \*(Aqpattern\*(Aq;
\&
\& pattern name   => [\*(Aqname\*(Aq, \*(Aqmine\*(Aq],
\&         create => \*(Aq(?i:J[.]?\es+A[.]?\es+Perl\-Hacker)\*(Aq,
\&         ;
\&
\& my $name_matcher = $RE{name}{mine};
\&
\& pattern name    => [ \*(Aqlineof\*(Aq, \*(Aq\-char=_\*(Aq ],
\&         create  => sub {
\&                        my $flags = shift;
\&                        my $char = quotemeta $flags\->{\-char};
\&                        return \*(Aq(?:^$char+$)\*(Aq;
\&                    },
\&         match   => sub {
\&                        my ($self, $str) = @_;
\&                        return $str !~ /[^$self\->{flags}{\-char}]/;
\&                    },
\&         subs   => sub {
\&                        my ($self, $str, $replacement) = @_;
\&                        $_[1] =~ s/^$self\->{flags}{\-char}+$//g;
\&                   },
\&         ;
\&
\& my $asterisks = $RE{lineof}{\-char=>\*(Aq*\*(Aq};
\&
\& # DECIDING WHICH PATTERNS TO LOAD.
\&
\& use Regexp::Common qw /comment number/;  # Comment and number patterns.
\& use Regexp::Common qw /no_defaults/;     # Don\*(Aqt load any patterns.
\& use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
By default, this module exports a single hash (\f(CW%RE\fR) that stores or generates
commonly needed regular expressions (see \*(L"List of available patterns\*(R").
.PP
There is an alternative, subroutine-based syntax described in
\&\*(L"Subroutine-based interface\*(R".
.SS "General syntax for requesting patterns"
.IX Subsection "General syntax for requesting patterns"
To access a particular pattern, \f(CW%RE\fR is treated as a hierarchical hash of
hashes (of hashes...), with each successive key being an identifier. For
example, to access the pattern that matches real numbers, you 
specify:
.PP
.Vb 1
\&        $RE{num}{real}
.Ve
.PP
and to access the pattern that matches integers:
.PP
.Vb 1
\&        $RE{num}{int}
.Ve
.PP
Deeper layers of the hash are used to specify \fIflags\fR: arguments that
modify the resulting pattern in some way. The keys used to access these
layers are prefixed with a minus sign and may have a value; if a value
is given, it's done by using a multidimensional key.
For example, to access the pattern that
matches base\-2 real numbers with embedded commas separating
groups of three digits (e.g. 10,101,110.110101101):
.PP
.Vb 1
\&        $RE{num}{real}{\-base => 2}{\-sep => \*(Aq,\*(Aq}{\-group => 3}
.Ve
.PP
Through the magic of Perl, these flag layers may be specified in any order
(and even interspersed through the identifier keys!)
so you could get the same pattern with:
.PP
.Vb 1
\&        $RE{num}{real}{\-sep => \*(Aq,\*(Aq}{\-group => 3}{\-base => 2}
.Ve
.PP
or:
.PP
.Vb 1
\&        $RE{num}{\-base => 2}{real}{\-group => 3}{\-sep => \*(Aq,\*(Aq}
.Ve
.PP
or even:
.PP
.Vb 1
\&        $RE{\-base => 2}{\-group => 3}{\-sep => \*(Aq,\*(Aq}{num}{real}
.Ve
.PP
etc.
.PP
Note, however, that the relative order of amongst the identifier keys
\&\fIis\fR significant. That is:
.PP
.Vb 1
\&        $RE{list}{set}
.Ve
.PP
would not be the same as:
.PP
.Vb 1
\&        $RE{set}{list}
.Ve
.SS "Flag syntax"
.IX Subsection "Flag syntax"
In versions prior to 2.113, flags could also be written as
\&\f(CW\*(C`{"\-flag=value"}\*(C'\fR. This no longer works, although \f(CW\*(C`{"\-flag$;value"}\*(C'\fR
still does. However, \f(CW\*(C`{\-flag => \*(Aqvalue\*(Aq}\*(C'\fR is the preferred syntax.
.SS "Universal flags"
.IX Subsection "Universal flags"
Normally, flags are specific to a single pattern.
However, there is two flags that all patterns may specify.
.ie n .IP """\-keep""" 4
.el .IP "\f(CW\-keep\fR" 4
.IX Item "-keep"
By default, the patterns provided by \f(CW%RE\fR contain no capturing
parentheses. However, if the \f(CW\*(C`\-keep\*(C'\fR flag is specified (it requires
no value) then any significant substrings that the pattern matches
are captured. For example:
.Sp
.Vb 5
\&        if ($str =~ $RE{num}{real}{\-keep}) {
\&                $number   = $1;
\&                $whole    = $3;
\&                $decimals = $5;
\&        }
.Ve
.Sp
Special care is needed if a \*(L"kept\*(R" pattern is interpolated into a
larger regular expression, as the presence of other capturing
parentheses is likely to change the \*(L"number variables\*(R" into which significant
substrings are saved.
.Sp
See also \*(L"Adding new regular expressions\*(R", which describes how to create
new patterns with \*(L"optional\*(R" capturing brackets that respond to \f(CW\*(C`\-keep\*(C'\fR.
.ie n .IP """\-i""" 4
.el .IP "\f(CW\-i\fR" 4
.IX Item "-i"
Some patterns or subpatterns only match lowercase or uppercase letters.
If one wants the do case insensitive matching, one option is to use
the \f(CW\*(C`/i\*(C'\fR regexp modifier, or the special sequence \f(CW\*(C`(?i)\*(C'\fR. But if the
functional interface is used, one does not have this option. The 
\&\f(CW\*(C`\-i\*(C'\fR switch solves this problem; by using it, the pattern will do
case insensitive matching.
.SS "\s-1OO\s0 interface and inline matching/substitution"
.IX Subsection "OO interface and inline matching/substitution"
The patterns returned from \f(CW%RE\fR are objects, so rather than writing:
.PP
.Vb 1
\&        if ($str =~ /$RE{some}{pattern}/ ) {...}
.Ve
.PP
you can write:
.PP
.Vb 1
\&        if ( $RE{some}{pattern}\->matches($str) ) {...}
.Ve
.PP
For matching this would seem to have no great advantage apart from readability
(but see below).
.PP
For substitutions, it has other significant benefits. Frequently you want to
perform a substitution on a string without changing the original. Most people
use this:
.PP
.Vb 2
\&        $changed = $original;
\&        $changed =~ s/$RE{some}{pattern}/$replacement/;
.Ve
.PP
The more adept use:
.PP
.Vb 1
\&        ($changed = $original) =~ s/$RE{some}{pattern}/$replacement/;
.Ve
.PP
Regexp::Common allows you do write this:
.PP
.Vb 1
\&        $changed = $RE{some}{pattern}\->subs($original=>$replacement);
.Ve
.PP
Apart from reducing precedence-angst, this approach has the added
advantages that the substitution behaviour can be optimized from the 
regular expression, and the replacement string can be provided by
default (see \*(L"Adding new regular expressions\*(R").
.PP
For example, in the implementation of this substitution:
.PP
.Vb 1
\&        $cropped = $RE{ws}{crop}\->subs($uncropped);
.Ve
.PP
the default empty string is provided automatically, and the substitution is
optimized to use:
.PP
.Vb 2
\&        $uncropped =~ s/^\es+//;
\&        $uncropped =~ s/\es+$//;
.Ve
.PP
rather than:
.PP
.Vb 1
\&        $uncropped =~ s/^\es+|\es+$//g;
.Ve
.SS "Subroutine-based interface"
.IX Subsection "Subroutine-based interface"
The hash-based interface was chosen because it allows regexes to be
effortlessly interpolated, and because it also allows them to be
\&\*(L"curried\*(R". For example:
.PP
.Vb 1
\&        my $num = $RE{num}{int};
\&
\&        my $commad     = $num\->{\-sep=>\*(Aq,\*(Aq}{\-group=>3};
\&        my $duodecimal = $num\->{\-base=>12};
.Ve
.PP
However, the use of tied hashes does make the access to Regexp::Common
patterns slower than it might otherwise be. In contexts where impatience
overrules laziness, Regexp::Common provides an additional
subroutine-based interface.
.PP
For each (sub\-)entry in the \f(CW%RE\fR hash (\f(CW$RE{key1}{key2}{etc}\fR), there
is a corresponding exportable subroutine: \f(CW\*(C`RE_key1_key2_etc()\*(C'\fR. The name of
each subroutine is the underscore-separated concatenation of the \fInon-flag\fR
keys that locate the same pattern in \f(CW%RE\fR. Flags are passed to the subroutine
in its argument list. Thus:
.PP
.Vb 1
\&        use Regexp::Common qw( RE_ws_crop RE_num_real RE_profanity );
\&
\&        $str =~ RE_ws_crop() and die "Surrounded by whitespace";
\&
\&        $str =~ RE_num_real(\-base=>8, \-sep=>" ") or next;
\&
\&        $offensive = RE_profanity(\-keep);
\&        $str =~ s/$offensive/$bad{$1}++; "<expletive deleted>"/ge;
.Ve
.PP
Note that, unlike the hash-based interface (which returns objects), these
subroutines return ordinary \f(CW\*(C`qr\*(C'\fR'd regular expressions. Hence they do not
curry, nor do they provide the \s-1OO\s0 match and substitution inlining described
in the previous section.
.PP
It is also possible to export subroutines for all available patterns like so:
.PP
.Vb 1
\&        use Regexp::Common \*(AqRE_ALL\*(Aq;
.Ve
.PP
Or you can export all subroutines with a common prefix of keys like so:
.PP
.Vb 1
\&        use Regexp::Common \*(AqRE_num_ALL\*(Aq;
.Ve
.PP
which will export \f(CW\*(C`RE_num_int\*(C'\fR and \f(CW\*(C`RE_num_real\*(C'\fR (and if you have
create more patterns who have first key \fInum\fR, those will be exported
as well). In general, \fIRE_key1_..._keyn_ALL\fR will export all subroutines
whose pattern names have first keys \fIkey1\fR ... \fIkeyn\fR.
.SS "Adding new regular expressions"
.IX Subsection "Adding new regular expressions"
You can add your own regular expressions to the \f(CW%RE\fR hash at run-time,
using the exportable \f(CW\*(C`pattern\*(C'\fR subroutine. It expects a hash-like list of 
key/value pairs that specify the behaviour of the pattern. The various
possible argument pairs are:
.ie n .IP """name => [ @list ]""" 4
.el .IP "\f(CWname => [ @list ]\fR" 4
.IX Item "name => [ @list ]"
A required argument that specifies the name of the pattern, and any
flags it may take, via a reference to a list of strings. For example:
.Sp
.Vb 3
\&         pattern name => [qw( line of \-char )],
\&                 # other args here
\&                 ;
.Ve
.Sp
This specifies an entry \f(CW$RE{line}{of}\fR, which may take a \f(CW\*(C`\-char\*(C'\fR flag.
.Sp
Flags may also be specified with a default value, which is then used whenever
the flag is specified without an explicit value (but not when the flag is
omitted). For example:
.Sp
.Vb 4
\&         pattern name => [qw( line of \-char=_ )],
\&                 # default char is \*(Aq_\*(Aq
\&                 # other args here
\&                 ;
.Ve
.ie n .IP """create => $sub_ref_or_string""" 4
.el .IP "\f(CWcreate => $sub_ref_or_string\fR" 4
.IX Item "create => $sub_ref_or_string"
A required argument that specifies either a string that is to be returned
as the pattern:
.Sp
.Vb 3
\&        pattern name    => [qw( line of underscores )],
\&                create  => q/(?:^_+$)/
\&                ;
.Ve
.Sp
or a reference to a subroutine that will be called to create the pattern:
.Sp
.Vb 7
\&        pattern name    => [qw( line of \-char=_ )],
\&                create  => sub {
\&                                my ($self, $flags) = @_;
\&                                my $char = quotemeta $flags\->{\-char};
\&                                return \*(Aq(?:^$char+$)\*(Aq;
\&                            },
\&                ;
.Ve
.Sp
If the subroutine version is used, the subroutine will be called with 
three arguments: a reference to the pattern object itself, a reference
to a hash containing the flags and their values,
and a reference to an array containing the non-flag keys.
.Sp
Whatever the subroutine returns is stringified as the pattern.
.Sp
No matter how the pattern is created, it is immediately postprocessed to
include or exclude capturing parentheses (according to the value of the
\&\f(CW\*(C`\-keep\*(C'\fR flag). To specify such \*(L"optional\*(R" capturing parentheses within
the regular expression associated with \f(CW\*(C`create\*(C'\fR, use the notation
\&\f(CW\*(C`(?k:...)\*(C'\fR. Any parentheses of this type will be converted to \f(CW\*(C`(...)\*(C'\fR
when the \f(CW\*(C`\-keep\*(C'\fR flag is specified, or \f(CW\*(C`(?:...)\*(C'\fR when it is not.
It is a Regexp::Common convention that the outermost capturing parentheses
always capture the entire pattern, but this is not enforced.
.ie n .IP """match => $sub_ref""" 4
.el .IP "\f(CWmatch => $sub_ref\fR" 4
.IX Item "match => $sub_ref"
An optional argument that specifies a subroutine that is to be called when
the \f(CW\*(C`$RE{...}\->matches(...)\*(C'\fR method of this pattern is invoked.
.Sp
The subroutine should expect two arguments: a reference to the pattern object
itself, and the string to be matched against.
.Sp
It should return the same types of values as a \f(CW\*(C`m/.../\*(C'\fR does.
.Sp
.Vb 7
\&     pattern name    => [qw( line of \-char )],
\&             create  => sub {...},
\&             match   => sub {
\&                             my ($self, $str) = @_;
\&                             $str !~ /[^$self\->{flags}{\-char}]/;
\&                        },
\&             ;
.Ve
.ie n .IP """subs => $sub_ref""" 4
.el .IP "\f(CWsubs => $sub_ref\fR" 4
.IX Item "subs => $sub_ref"
An optional argument that specifies a subroutine that is to be called when
the \f(CW\*(C`$RE{...}\->subs(...)\*(C'\fR method of this pattern is invoked.
.Sp
The subroutine should expect three arguments: a reference to the pattern object
itself, the string to be changed, and the value to be substituted into it.
The third argument may be \f(CW\*(C`undef\*(C'\fR, indicating the default substitution is
required.
.Sp
The subroutine should return the same types of values as an \f(CW\*(C`s/.../.../\*(C'\fR does.
.Sp
For example:
.Sp
.Vb 7
\&     pattern name    => [ \*(Aqlineof\*(Aq, \*(Aq\-char=_\*(Aq ],
\&             create  => sub {...},
\&             subs    => sub {
\&                          my ($self, $str, $ignore_replacement) = @_;
\&                          $_[1] =~ s/^$self\->{flags}{\-char}+$//g;
\&                        },
\&             ;
.Ve
.Sp
Note that such a subroutine will almost always need to modify \f(CW$_[1]\fR directly.
.ie n .IP """version => $minimum_perl_version""" 4
.el .IP "\f(CWversion => $minimum_perl_version\fR" 4
.IX Item "version => $minimum_perl_version"
If this argument is given, it specifies the minimum version of perl required
to use the new pattern. Attempts to use the pattern with earlier versions of
perl will generate a fatal diagnostic.
.SS "Loading specific sets of patterns."
.IX Subsection "Loading specific sets of patterns."
By default, all the sets of patterns listed below are made available.
However, it is possible to indicate which sets of patterns should
be made available \- the wanted sets should be given as arguments to
\&\f(CW\*(C`use\*(C'\fR. Alternatively, it is also possible to indicate which sets of
patterns should not be made available \- those sets will be given as
argument to the \f(CW\*(C`use\*(C'\fR statement, but are preceeded with an exclaimation
mark. The argument \fIno_defaults\fR indicates none of the default patterns
should be made available. This is useful for instance if all you want
is the \f(CW\*(C`pattern()\*(C'\fR subroutine.
.PP
Examples:
.PP
.Vb 3
\& use Regexp::Common qw /comment number/;  # Comment and number patterns.
\& use Regexp::Common qw /no_defaults/;     # Don\*(Aqt load any patterns.
\& use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
.Ve
.PP
It's also possible to load your own set of patterns. If you have a
module \f(CW\*(C`Regexp::Common::my_patterns\*(C'\fR that makes patterns available,
you can have it made available with
.PP
.Vb 1
\& use Regexp::Common qw /my_patterns/;
.Ve
.PP
Note that the default patterns will still be made available \- only if
you use \fIno_defaults\fR, or mention one of the default sets explicitely,
the non mentioned defaults aren't made available.
.SS "List of available patterns"
.IX Subsection "List of available patterns"
The patterns listed below are currently available. Each set of patterns
has its own manual page describing the details. For each pattern set
named \fIname\fR, the manual page \fIRegexp::Common::name\fR describes the
details.
.PP
Currently available are:
.IP "Regexp::Common::balanced" 4
.IX Item "Regexp::Common::balanced"
Provides regexes for strings with balanced parenthesized delimiters.
.IP "Regexp::Common::comment" 4
.IX Item "Regexp::Common::comment"
Provides regexes for comments of various languages (43 languages
currently).
.IP "Regexp::Common::delimited" 4
.IX Item "Regexp::Common::delimited"
Provides regexes for delimited strings.
.IP "Regexp::Common::lingua" 4
.IX Item "Regexp::Common::lingua"
Provides regexes for palindromes.
.IP "Regexp::Common::list" 4
.IX Item "Regexp::Common::list"
Provides regexes for lists.
.IP "Regexp::Common::net" 4
.IX Item "Regexp::Common::net"
Provides regexes for IPv4 addresses and \s-1MAC\s0 addresses.
.IP "Regexp::Common::number" 4
.IX Item "Regexp::Common::number"
Provides regexes for numbers (integers and reals).
.IP "Regexp::Common::profanity" 4
.IX Item "Regexp::Common::profanity"
Provides regexes for profanity.
.IP "Regexp::Common::whitespace" 4
.IX Item "Regexp::Common::whitespace"
Provides regexes for leading and trailing whitespace.
.IP "Regexp::Common::zip" 4
.IX Item "Regexp::Common::zip"
Provides regexes for zip codes.
.SS "Forthcoming patterns and features"
.IX Subsection "Forthcoming patterns and features"
Future releases of the module will also provide patterns for the following:
.PP
.Vb 9
\&        * email addresses 
\&        * HTML/XML tags
\&        * more numerical matchers,
\&        * mail headers (including multiline ones),
\&        * more URLS
\&        * telephone numbers of various countries
\&        * currency (universal 3 letter format, Latin\-1, currency names)
\&        * dates
\&        * binary formats (e.g. UUencoded, MIMEd)
.Ve
.PP
If you have other patterns or pattern generators that you think would be
generally useful, please send them to the maintainer \*(-- preferably as source
code using the \f(CW\*(C`pattern\*(C'\fR subroutine. Submissions that include a set of
tests will be especially welcome.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Can\*(Aqt export unknown subroutine %s""" 4
.el .IP "\f(CWCan\*(Aqt export unknown subroutine %s\fR" 4
.IX Item "Cant export unknown subroutine %s"
The subroutine-based interface didn't recognize the requested subroutine.
Often caused by a spelling mistake or an incompletely specified name.
.ie n .IP """Can\*(Aqt create unknown regex: $RE{...}""" 4
.el .IP "\f(CWCan\*(Aqt create unknown regex: $RE{...}\fR" 4
.IX Item "Cant create unknown regex: $RE{...}"
Regexp::Common doesn't have a generator for the requested pattern.
Often indicates a mispelt or missing parameter.
.ie n .IP " ""Perl %f does not support the pattern $RE{...}. You need Perl %f or later""" 4
.el .IP " \f(CWPerl %f does not support the pattern $RE{...}. You need Perl %f or later\fR" 4
.IX Item " Perl %f does not support the pattern $RE{...}. You need Perl %f or later"
The requested pattern requires advanced regex features (e.g. recursion)
that not available in your version of Perl. Time to upgrade.
.ie n .IP """pattern() requires argument: name => [ @list ]""" 4
.el .IP "\f(CWpattern() requires argument: name => [ @list ]\fR" 4
.IX Item "pattern() requires argument: name => [ @list ]"
Every user-defined pattern specification must have a name.
.ie n .IP """pattern() requires argument: create => $sub_ref_or_string""" 4
.el .IP "\f(CWpattern() requires argument: create => $sub_ref_or_string\fR" 4
.IX Item "pattern() requires argument: create => $sub_ref_or_string"
Every user-defined pattern specification must provide a pattern creation
mechanism: either a pattern string or a reference to a subroutine that
returns the pattern string.
.ie n .IP """Base must be between 1 and 36""" 4
.el .IP "\f(CWBase must be between 1 and 36\fR" 4
.IX Item "Base must be between 1 and 36"
The \f(CW$RE{num}{real}{\-base=>\*(Aq\f(CIN\f(CW\*(Aq}\fR pattern uses the characters [0\-9A\-Z]
to represent the digits of various bases. Hence it only produces
regular expressions for bases up to hexatricensimal.
.ie n .IP """Must specify delimiter in $RE{delimited}""" 4
.el .IP "\f(CWMust specify delimiter in $RE{delimited}\fR" 4
.IX Item "Must specify delimiter in $RE{delimited}"
The pattern has no default delimiter.
You need to write: \f(CW$RE{delimited}{\-delim=>\f(CIX\f(CW\*(Aq}\fR for some character \fIX\fR
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Deepest thanks to the many people who have encouraged and contributed to this
project, especially: Elijah, Jarkko, Tom, Nat, Ed, and Vivek.
.PP
Further thanks go to: Alexandr Ciornii, Blair Zajac, Bob Stockdale,
Charles Thomas, Chris Vertonghen, the \s-1CPAN\s0 Testers, David Hand,
Fany, Geoffrey Leach, Hermann-Marcus Behrens, Jerome Quelin, Jim Cromie,
Lars Wilke, Linda Julien, Mike Arms, Mike Castle, Mikko, Murat Uenalan,
Rafae\*:l Garcia-Suarez, Ron Savage, Sam Vilain, Slaven Rezic, Smylers,
Tim Maher, and all the others I've forgotten.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in to \fIregexp\-common@abigail.be\fR.
.PP
There are some \s-1POD\s0 issues when installing this module using a pre\-5.6.0 perl;
some manual pages may not install, or may not install correctly using a perl
that is that old. You might consider upgrading your perl.
.SH "NOT A BUG"
.IX Header "NOT A BUG"
.IP "\(bu" 4
The various patterns are not anchored. That is, a pattern like 
\&\f(CW\*(C`$RE {num} {int}\*(C'\fR will match against \*(L"abc4def\*(R", because a 
substring of the subject matches. This is by design, and not a
bug. If you want the pattern to be anchored, use something like:
.Sp
.Vb 2
\& my $integer = $RE {num} {int};
\& $subj =~ /^$integer$/ and print "Matches!\en";
.Ve
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2011, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::CC.3pm                       0100644 0001750 0001750 00000014016 12566242002 024453  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::CC 3"
.TH Regexp::Common::CC 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::CC \-\- provide patterns for credit card numbers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /CC/;
\&
\&    while (<>) {
\&        /^$RE{CC}{Mastercard}$/   and  print "Mastercard card number\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Please consult the manual of Regexp::Common for a general description
of the works of this interface.
.PP
Do not use this module directly, but load it via \fIRegexp::Common\fR.
.PP
This module offers patterns for credit card numbers of several major
credit card types. Currently, the supported cards are: \fIMastercard\fR,
\&\fIAmex\fR, \fIDiners Club\fR, and \fIDiscover\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common for a general description of how to use this interface.
.IP "<http://www.beachnet.com/~hstiles/cardtype.html>" 4
.IX Item "<http://www.beachnet.com/~hstiles/cardtype.html>"
Credit Card Validation \- Check Digits
.IP "<http://euro.ecom.cmu.edu/resources/elibrary/everycc.htm>" 4
.IX Item "<http://euro.ecom.cmu.edu/resources/elibrary/everycc.htm>"
Everything you ever wanted to know about \s-1CC\s0's
.IP "<http://www.webopedia.com/TERM/L/Luhn_formula.html>" 4
.IX Item "<http://www.webopedia.com/TERM/L/Luhn_formula.html>"
Luhn formula
.SH "AUTHORS"
.IX Header "AUTHORS"
Damian Conway (\fIdamian@conway.org\fR) and
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty. Send them in to \fIregexp\-common@abigail.be\fR.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::CC5.16.3pm                   0100644 0001750 0001750 00000013475 12566242000 024773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::CC 3"
.TH Regexp::Common::CC 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::CC \-\- provide patterns for credit card numbers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /CC/;
\&
\&    while (<>) {
\&        /^$RE{CC}{Mastercard}$/   and  print "Mastercard card number\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Please consult the manual of Regexp::Common for a general description
of the works of this interface.
.PP
Do not use this module directly, but load it via \fIRegexp::Common\fR.
.PP
This module offers patterns for credit card numbers of several major
credit card types. Currently, the supported cards are: \fIMastercard\fR,
\&\fIAmex\fR, \fIDiners Club\fR, and \fIDiscover\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common for a general description of how to use this interface.
.IP "<http://www.beachnet.com/~hstiles/cardtype.html>" 4
.IX Item "<http://www.beachnet.com/~hstiles/cardtype.html>"
Credit Card Validation \- Check Digits
.IP "<http://euro.ecom.cmu.edu/resources/elibrary/everycc.htm>" 4
.IX Item "<http://euro.ecom.cmu.edu/resources/elibrary/everycc.htm>"
Everything you ever wanted to know about \s-1CC\s0's
.IP "<http://www.webopedia.com/TERM/L/Luhn_formula.html>" 4
.IX Item "<http://www.webopedia.com/TERM/L/Luhn_formula.html>"
Luhn formula
.SH "AUTHORS"
.IX Header "AUTHORS"
Damian Conway (\fIdamian@conway.org\fR) and
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty. Send them in to \fIregexp\-common@abigail.be\fR.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::CC5.18.3pm                   0100644 0001750 0001750 00000014016 12566242002 024767  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::CC 3"
.TH Regexp::Common::CC 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::CC \-\- provide patterns for credit card numbers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /CC/;
\&
\&    while (<>) {
\&        /^$RE{CC}{Mastercard}$/   and  print "Mastercard card number\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Please consult the manual of Regexp::Common for a general description
of the works of this interface.
.PP
Do not use this module directly, but load it via \fIRegexp::Common\fR.
.PP
This module offers patterns for credit card numbers of several major
credit card types. Currently, the supported cards are: \fIMastercard\fR,
\&\fIAmex\fR, \fIDiners Club\fR, and \fIDiscover\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common for a general description of how to use this interface.
.IP "<http://www.beachnet.com/~hstiles/cardtype.html>" 4
.IX Item "<http://www.beachnet.com/~hstiles/cardtype.html>"
Credit Card Validation \- Check Digits
.IP "<http://euro.ecom.cmu.edu/resources/elibrary/everycc.htm>" 4
.IX Item "<http://euro.ecom.cmu.edu/resources/elibrary/everycc.htm>"
Everything you ever wanted to know about \s-1CC\s0's
.IP "<http://www.webopedia.com/TERM/L/Luhn_formula.html>" 4
.IX Item "<http://www.webopedia.com/TERM/L/Luhn_formula.html>"
Luhn formula
.SH "AUTHORS"
.IX Header "AUTHORS"
Damian Conway (\fIdamian@conway.org\fR) and
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty. Send them in to \fIregexp\-common@abigail.be\fR.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::SEN.3pm                      0100644 0001750 0001750 00000014760 12566242002 024621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::SEN 3"
.TH Regexp::Common::SEN 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::SEN \-\- provide regexes for Social\-Economical Numbers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Regexp::Common qw /SEN/;
\&
\& while (<>) {
\&     /^$RE{SEN}{USA}{SSN}$/    and  print "Social Security Number\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Please consult the manual of Regexp::Common for a general description
of the works of this interface.
.PP
Do not use this module directly, but load it via \fIRegexp::Common\fR.
.ie n .SS "$RE{SEN}{USA}{SSN}{\-sep}"
.el .SS "\f(CW$RE{SEN}{USA}{SSN}{\-sep}\fP"
.IX Subsection "$RE{SEN}{USA}{SSN}{-sep}"
Returns a pattern that matches an American Social Security Number (\s-1SSN\s0).
SSNs consist of three groups of numbers, separated by a hypen (\f(CW\*(C`\-\*(C'\fR).
This pattern only checks for a valid structure, that is, it validates
whether a number is valid \s-1SSN,\s0 was a valid \s-1SSN,\s0 or maybe a valid \s-1SSN\s0
in the future. There are almost a billion possible SSNs, and about 
400 million are in use, or have been in use.
.PP
If \f(CW\*(C`\-sep=\f(CIP\f(CW\*(C'\fR is specified, the pattern \fIP\fR is used as the
separator between the groups of numbers.
.PP
Under \f(CW\*(C`\-keep\*(C'\fR (see Regexp::Common):
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire \s-1SSN.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
captures the first group of digits (the area number).
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
captures the second group of digits (the group number).
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
captures the third group of digits (the serial number).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common for a general description of how to use this interface.
.SH "AUTHORS"
.IX Header "AUTHORS"
Damian Conway and Abigail.
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in to \fIregexp\-common@abigail.be\fR.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::SEN5.16.3pm                  0100644 0001750 0001750 00000014437 12566242000 025132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::SEN 3"
.TH Regexp::Common::SEN 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::SEN \-\- provide regexes for Social\-Economical Numbers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Regexp::Common qw /SEN/;
\&
\& while (<>) {
\&     /^$RE{SEN}{USA}{SSN}$/    and  print "Social Security Number\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Please consult the manual of Regexp::Common for a general description
of the works of this interface.
.PP
Do not use this module directly, but load it via \fIRegexp::Common\fR.
.ie n .SS "$RE{SEN}{USA}{SSN}{\-sep}"
.el .SS "\f(CW$RE{SEN}{USA}{SSN}{\-sep}\fP"
.IX Subsection "$RE{SEN}{USA}{SSN}{-sep}"
Returns a pattern that matches an American Social Security Number (\s-1SSN\s0).
SSNs consist of three groups of numbers, separated by a hypen (\f(CW\*(C`\-\*(C'\fR).
This pattern only checks for a valid structure, that is, it validates
whether a number is valid \s-1SSN\s0, was a valid \s-1SSN\s0, or maybe a valid \s-1SSN\s0
in the future. There are almost a billion possible SSNs, and about 
400 million are in use, or have been in use.
.PP
If \f(CW\*(C`\-sep=\f(CIP\f(CW\*(C'\fR is specified, the pattern \fIP\fR is used as the
separator between the groups of numbers.
.PP
Under \f(CW\*(C`\-keep\*(C'\fR (see Regexp::Common):
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire \s-1SSN\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
captures the first group of digits (the area number).
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
captures the second group of digits (the group number).
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
captures the third group of digits (the serial number).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common for a general description of how to use this interface.
.SH "AUTHORS"
.IX Header "AUTHORS"
Damian Conway and Abigail.
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in to \fIregexp\-common@abigail.be\fR.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::SEN5.18.3pm                  0100644 0001750 0001750 00000014760 12566242002 025135  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::SEN 3"
.TH Regexp::Common::SEN 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::SEN \-\- provide regexes for Social\-Economical Numbers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Regexp::Common qw /SEN/;
\&
\& while (<>) {
\&     /^$RE{SEN}{USA}{SSN}$/    and  print "Social Security Number\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Please consult the manual of Regexp::Common for a general description
of the works of this interface.
.PP
Do not use this module directly, but load it via \fIRegexp::Common\fR.
.ie n .SS "$RE{SEN}{USA}{SSN}{\-sep}"
.el .SS "\f(CW$RE{SEN}{USA}{SSN}{\-sep}\fP"
.IX Subsection "$RE{SEN}{USA}{SSN}{-sep}"
Returns a pattern that matches an American Social Security Number (\s-1SSN\s0).
SSNs consist of three groups of numbers, separated by a hypen (\f(CW\*(C`\-\*(C'\fR).
This pattern only checks for a valid structure, that is, it validates
whether a number is valid \s-1SSN,\s0 was a valid \s-1SSN,\s0 or maybe a valid \s-1SSN\s0
in the future. There are almost a billion possible SSNs, and about 
400 million are in use, or have been in use.
.PP
If \f(CW\*(C`\-sep=\f(CIP\f(CW\*(C'\fR is specified, the pattern \fIP\fR is used as the
separator between the groups of numbers.
.PP
Under \f(CW\*(C`\-keep\*(C'\fR (see Regexp::Common):
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire \s-1SSN.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
captures the first group of digits (the area number).
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
captures the second group of digits (the group number).
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
captures the third group of digits (the serial number).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common for a general description of how to use this interface.
.SH "AUTHORS"
.IX Header "AUTHORS"
Damian Conway and Abigail.
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in to \fIregexp\-common@abigail.be\fR.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI.3pm                      0100644 0001750 0001750 00000015610 12566242002 024626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI 3"
.TH Regexp::Common::URI 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI \-\- provide patterns for URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{HTTP}/       and  print "Contains an HTTP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Patterns for the following URIs are supported: fax, file, \s-1FTP,\s0 gopher,
\&\s-1HTTP,\s0 news, \s-1NTTP,\s0 pop, prospero, tel, telnet, tv and \s-1WAIS.\s0
Each is documented in the \fIRegexp::Common::URI::\f(BIscheme\fI\fR,
manual page, for the appropriate scheme (in lowercase), except for
\&\fI\s-1NNTP\s0\fR URIs which are found in \fIRegexp::Common::URI::news\fR.
.ie n .SS "$RE{URI}"
.el .SS "\f(CW$RE{URI}\fP"
.IX Subsection "$RE{URI}"
Return a pattern that recognizes any of the supported URIs. With
\&\f(CW\*(C`{\-keep}\*(C'\fR, only the entire \s-1URI\s0 is returned (in \f(CW$1\fR).
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1DRAFT\-URI\-TV\s0]\fR" 4
.IX Item "[DRAFT-URI-TV]"
Zigmond, D. and Vickers, M: \fIUniform Resource Identifiers for
Television Broadcasts\fR. December 2000.
.IP "\fB[\s-1DRAFT\-URL\-FTP\s0]\fR" 4
.IX Item "[DRAFT-URL-FTP]"
Casey, James: \fIA \s-1FTP URL\s0 Format\fR. November 1996.
.IP "\fB[\s-1RFC 1035\s0]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN NAMES \- IMPLEMENTATION AND SPECIFICATION\s0\fR.
November 1987.
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC 2616\s0]\fR" 4
.IX Item "[RFC 2616]"
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
Leach, P. and Berners-Lee, Tim: \fIHypertext Transfer Protocol \*(-- \s-1HTTP/1.1\s0\fR.
June 1999.
.IP "\fB[\s-1RFC 2806\s0]\fR" 4
.IX Item "[RFC 2806]"
Vaha-Sipila, A.: \fIURLs for Telephone Calls\fR. April 2000.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common for a general description of how to use this interface.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in to \fIregexp\-common@abigail.be\fR.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI5.16.3pm                  0100644 0001750 0001750 00000015332 12566242000 025137  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI 3"
.TH Regexp::Common::URI 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI \-\- provide patterns for URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{HTTP}/       and  print "Contains an HTTP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Patterns for the following URIs are supported: fax, file, \s-1FTP\s0, gopher,
\&\s-1HTTP\s0, news, \s-1NTTP\s0, pop, prospero, tel, telnet, tv and \s-1WAIS\s0.
Each is documented in the \fIRegexp::Common::URI::\f(BIscheme\fI\fR,
manual page, for the appropriate scheme (in lowercase), except for
\&\fI\s-1NNTP\s0\fR URIs which are found in \fIRegexp::Common::URI::news\fR.
.ie n .SS "$RE{URI}"
.el .SS "\f(CW$RE{URI}\fP"
.IX Subsection "$RE{URI}"
Return a pattern that recognizes any of the supported URIs. With
\&\f(CW\*(C`{\-keep}\*(C'\fR, only the entire \s-1URI\s0 is returned (in \f(CW$1\fR).
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1DRAFT\-URI\-TV\s0]\fR" 4
.IX Item "[DRAFT-URI-TV]"
Zigmond, D. and Vickers, M: \fIUniform Resource Identifiers for
Television Broadcasts\fR. December 2000.
.IP "\fB[\s-1DRAFT\-URL\-FTP\s0]\fR" 4
.IX Item "[DRAFT-URL-FTP]"
Casey, James: \fIA \s-1FTP\s0 \s-1URL\s0 Format\fR. November 1996.
.IP "\fB[\s-1RFC\s0 1035]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN\s0 \s-1NAMES\s0 \- \s-1IMPLEMENTATION\s0 \s-1AND\s0 \s-1SPECIFICATION\s0\fR.
November 1987.
.IP "\fB[\s-1RFC\s0 1738]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.IP "\fB[\s-1RFC\s0 2396]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC\s0 2616]\fR" 4
.IX Item "[RFC 2616]"
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
Leach, P. and Berners-Lee, Tim: \fIHypertext Transfer Protocol \*(-- \s-1HTTP/1\s0.1\fR.
June 1999.
.IP "\fB[\s-1RFC\s0 2806]\fR" 4
.IX Item "[RFC 2806]"
Vaha-Sipila, A.: \fIURLs for Telephone Calls\fR. April 2000.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common for a general description of how to use this interface.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in to \fIregexp\-common@abigail.be\fR.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI5.18.3pm                  0100644 0001750 0001750 00000015610 12566242002 025142  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI 3"
.TH Regexp::Common::URI 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI \-\- provide patterns for URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{HTTP}/       and  print "Contains an HTTP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Patterns for the following URIs are supported: fax, file, \s-1FTP,\s0 gopher,
\&\s-1HTTP,\s0 news, \s-1NTTP,\s0 pop, prospero, tel, telnet, tv and \s-1WAIS.\s0
Each is documented in the \fIRegexp::Common::URI::\f(BIscheme\fI\fR,
manual page, for the appropriate scheme (in lowercase), except for
\&\fI\s-1NNTP\s0\fR URIs which are found in \fIRegexp::Common::URI::news\fR.
.ie n .SS "$RE{URI}"
.el .SS "\f(CW$RE{URI}\fP"
.IX Subsection "$RE{URI}"
Return a pattern that recognizes any of the supported URIs. With
\&\f(CW\*(C`{\-keep}\*(C'\fR, only the entire \s-1URI\s0 is returned (in \f(CW$1\fR).
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1DRAFT\-URI\-TV\s0]\fR" 4
.IX Item "[DRAFT-URI-TV]"
Zigmond, D. and Vickers, M: \fIUniform Resource Identifiers for
Television Broadcasts\fR. December 2000.
.IP "\fB[\s-1DRAFT\-URL\-FTP\s0]\fR" 4
.IX Item "[DRAFT-URL-FTP]"
Casey, James: \fIA \s-1FTP URL\s0 Format\fR. November 1996.
.IP "\fB[\s-1RFC 1035\s0]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN NAMES \- IMPLEMENTATION AND SPECIFICATION\s0\fR.
November 1987.
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC 2616\s0]\fR" 4
.IX Item "[RFC 2616]"
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
Leach, P. and Berners-Lee, Tim: \fIHypertext Transfer Protocol \*(-- \s-1HTTP/1.1\s0\fR.
June 1999.
.IP "\fB[\s-1RFC 2806\s0]\fR" 4
.IX Item "[RFC 2806]"
Vaha-Sipila, A.: \fIURLs for Telephone Calls\fR. April 2000.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common for a general description of how to use this interface.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in to \fIregexp\-common@abigail.be\fR.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC1035.3pm             0100644 0001750 0001750 00000012365 12566242002 025662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC1035 3"
.TH Regexp::Common::URI::RFC1035 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC1035 \-\- Definitions from RFC1035;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC1035 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC1035.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1035\s0]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN NAMES \- IMPLEMENTATION AND SPECIFICATION\s0\fR.
November 1987.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC10355.16.3pm         0100644 0001750 0001750 00000012100 12566242000 026155  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC1035 3"
.TH Regexp::Common::URI::RFC1035 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC1035 \-\- Definitions from RFC1035;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC1035 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC1035\s0. It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 1035]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN\s0 \s-1NAMES\s0 \- \s-1IMPLEMENTATION\s0 \s-1AND\s0 \s-1SPECIFICATION\s0\fR.
November 1987.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC10355.18.3pm         0100644 0001750 0001750 00000012365 12566242002 026176  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC1035 3"
.TH Regexp::Common::URI::RFC1035 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC1035 \-\- Definitions from RFC1035;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC1035 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC1035.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1035\s0]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN NAMES \- IMPLEMENTATION AND SPECIFICATION\s0\fR.
November 1987.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC1738.3pm             0100644 0001750 0001750 00000012224 12566242002 025666  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC1738 3"
.TH Regexp::Common::URI::RFC1738 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC1738 \-\- Definitions from RFC1738;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC1738 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC1738.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC17385.16.3pm         0100644 0001750 0001750 00000011703 12566242000 026177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC1738 3"
.TH Regexp::Common::URI::RFC1738 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC1738 \-\- Definitions from RFC1738;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC1738 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC1738\s0. It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 1738]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC17385.18.3pm         0100644 0001750 0001750 00000012224 12566242002 026202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC1738 3"
.TH Regexp::Common::URI::RFC1738 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC1738 \-\- Definitions from RFC1738;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC1738 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC1738.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC1808.3pm             0100644 0001750 0001750 00000012346 12566242002 025671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC1808 3"
.TH Regexp::Common::URI::RFC1808 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC1808 \-\- Definitions from RFC1808;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC1808 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC1808.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1808\s0]\fR" 4
.IX Item "[RFC 1808]"
Fielding, R.: \fIRelative Uniform Resource Locators (\s-1URL\s0)\fR. June 1995.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC18085.16.3pm         0100644 0001750 0001750 00000012025 12566242000 026173  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC1808 3"
.TH Regexp::Common::URI::RFC1808 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC1808 \-\- Definitions from RFC1808;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC1808 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC1808\s0. It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 1808]\fR" 4
.IX Item "[RFC 1808]"
Fielding, R.: \fIRelative Uniform Resource Locators (\s-1URL\s0)\fR. June 1995.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC18085.18.3pm         0100644 0001750 0001750 00000012346 12566242002 026205  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC1808 3"
.TH Regexp::Common::URI::RFC1808 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC1808 \-\- Definitions from RFC1808;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC1808 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC1808.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1808\s0]\fR" 4
.IX Item "[RFC 1808]"
Fielding, R.: \fIRelative Uniform Resource Locators (\s-1URL\s0)\fR. June 1995.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC2384.3pm             0100644 0001750 0001750 00000012137 12566242002 025667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC2384 3"
.TH Regexp::Common::URI::RFC2384 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC2384 \-\- Definitions from RFC2384;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC2384 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC2384.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 2384\s0]\fR" 4
.IX Item "[RFC 2384]"
Gellens, R.: \fI\s-1POP URL\s0 scheme\fR August 1998.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC23845.16.3pm         0100644 0001750 0001750 00000011625 12566242000 026200  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC2384 3"
.TH Regexp::Common::URI::RFC2384 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC2384 \-\- Definitions from RFC2384;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC2384 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC2384\s0. It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 2384]\fR" 4
.IX Item "[RFC 2384]"
Gellens, R.: \fI\s-1POP\s0 \s-1URL\s0 scheme\fR August 1998.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC23845.18.3pm         0100644 0001750 0001750 00000012137 12566242002 026203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC2384 3"
.TH Regexp::Common::URI::RFC2384 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC2384 \-\- Definitions from RFC2384;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC2384 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC2384.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 2384\s0]\fR" 4
.IX Item "[RFC 2384]"
Gellens, R.: \fI\s-1POP URL\s0 scheme\fR August 1998.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC2396.3pm             0100644 0001750 0001750 00000012426 12566242002 025673  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC2396 3"
.TH Regexp::Common::URI::RFC2396 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC2396 \-\- Definitions from RFC2396;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC2396 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC2396.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC23965.16.3pm         0100644 0001750 0001750 00000012105 12566242000 026175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC2396 3"
.TH Regexp::Common::URI::RFC2396 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC2396 \-\- Definitions from RFC2396;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC2396 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC2396\s0. It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 2396]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC23965.18.3pm         0100644 0001750 0001750 00000012426 12566242002 026207  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC2396 3"
.TH Regexp::Common::URI::RFC2396 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC2396 \-\- Definitions from RFC2396;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC2396 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC2396.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC2806.3pm             0100644 0001750 0001750 00000012473 12566242002 025671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC2806 3"
.TH Regexp::Common::URI::RFC2806 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC2806 \-\- Definitions from RFC2806;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC2806 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC2806.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 2616\s0]\fR" 4
.IX Item "[RFC 2616]"
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
Leach, P. and Berners-Lee, Tim: \fIHypertext Transfer Protocol \*(-- \s-1HTTP/1.1\s0\fR.
June 1999.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC28065.16.3pm         0100644 0001750 0001750 00000012152 12566242000 026173  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC2806 3"
.TH Regexp::Common::URI::RFC2806 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC2806 \-\- Definitions from RFC2806;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC2806 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC2806\s0. It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 2616]\fR" 4
.IX Item "[RFC 2616]"
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
Leach, P. and Berners-Lee, Tim: \fIHypertext Transfer Protocol \*(-- \s-1HTTP/1\s0.1\fR.
June 1999.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::RFC28065.18.3pm         0100644 0001750 0001750 00000012473 12566242002 026205  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::RFC2806 3"
.TH Regexp::Common::URI::RFC2806 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::RFC2806 \-\- Definitions from RFC2806;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::URI::RFC2806 qw /:ALL/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package exports definitions from \s-1RFC2806.\s0 It's intended
usage is for Regexp::Common::URI submodules only. Its interface
might change without notice.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 2616\s0]\fR" 4
.IX Item "[RFC 2616]"
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
Leach, P. and Berners-Lee, Tim: \fIHypertext Transfer Protocol \*(-- \s-1HTTP/1.1\s0\fR.
June 1999.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::fax.3pm                 0100644 0001750 0001750 00000015140 12566242002 025507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::fax 3"
.TH Regexp::Common::URI::fax 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::fax \-\- Returns a pattern for fax URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{fax}/       and  print "Contains a fax URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{fax}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{fax}"
.IX Subsection "$RE{URI}{fax}"
Returns a pattern that matches \fIfax\fR URIs, as defined by \s-1RFC 2806.\s0
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The phone number, including any possible add-ons like \s-1ISDN\s0 subaddress,
a post dial part, area specifier, service provider, etc.
.ie n .SS "$RE{URI}{fax}{nofuture}"
.el .SS "\f(CW$RE{URI}{fax}{nofuture}\fP"
.IX Subsection "$RE{URI}{fax}{nofuture}"
As above (including what's returned by \f(CW\*(C`{\-keep}\*(C'\fR), with the exception
that \fIfuture extensions\fR are not allowed. Without allowing 
those \fIfuture extensions\fR, it becomes much easier to check a \s-1URI\s0 if
the correct syntax for post dial, service provider, phone context,
etc has been used \- otherwise the regex could always classify them
as a \fIfuture extension\fR.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1035\s0]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN NAMES \- IMPLEMENTATION AND SPECIFICATION\s0\fR.
November 1987.
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC 2806\s0]\fR" 4
.IX Item "[RFC 2806]"
Vaha-Sipila, A.: \fIURLs for Telephone Calls\fR. April 2000.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::fax5.16.3pm             0100644 0001750 0001750 00000014653 12566242000 026027  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::fax 3"
.TH Regexp::Common::URI::fax 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::fax \-\- Returns a pattern for fax URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{fax}/       and  print "Contains a fax URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{fax}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{fax}"
.IX Subsection "$RE{URI}{fax}"
Returns a pattern that matches \fIfax\fR URIs, as defined by \s-1RFC\s0 2806.
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The phone number, including any possible add-ons like \s-1ISDN\s0 subaddress,
a post dial part, area specifier, service provider, etc.
.ie n .SS "$RE{URI}{fax}{nofuture}"
.el .SS "\f(CW$RE{URI}{fax}{nofuture}\fP"
.IX Subsection "$RE{URI}{fax}{nofuture}"
As above (including what's returned by \f(CW\*(C`{\-keep}\*(C'\fR), with the exception
that \fIfuture extensions\fR are not allowed. Without allowing 
those \fIfuture extensions\fR, it becomes much easier to check a \s-1URI\s0 if
the correct syntax for post dial, service provider, phone context,
etc has been used \- otherwise the regex could always classify them
as a \fIfuture extension\fR.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 1035]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN\s0 \s-1NAMES\s0 \- \s-1IMPLEMENTATION\s0 \s-1AND\s0 \s-1SPECIFICATION\s0\fR.
November 1987.
.IP "\fB[\s-1RFC\s0 2396]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC\s0 2806]\fR" 4
.IX Item "[RFC 2806]"
Vaha-Sipila, A.: \fIURLs for Telephone Calls\fR. April 2000.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::fax5.18.3pm             0100644 0001750 0001750 00000015140 12566242002 026023  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::fax 3"
.TH Regexp::Common::URI::fax 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::fax \-\- Returns a pattern for fax URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{fax}/       and  print "Contains a fax URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{fax}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{fax}"
.IX Subsection "$RE{URI}{fax}"
Returns a pattern that matches \fIfax\fR URIs, as defined by \s-1RFC 2806.\s0
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The phone number, including any possible add-ons like \s-1ISDN\s0 subaddress,
a post dial part, area specifier, service provider, etc.
.ie n .SS "$RE{URI}{fax}{nofuture}"
.el .SS "\f(CW$RE{URI}{fax}{nofuture}\fP"
.IX Subsection "$RE{URI}{fax}{nofuture}"
As above (including what's returned by \f(CW\*(C`{\-keep}\*(C'\fR), with the exception
that \fIfuture extensions\fR are not allowed. Without allowing 
those \fIfuture extensions\fR, it becomes much easier to check a \s-1URI\s0 if
the correct syntax for post dial, service provider, phone context,
etc has been used \- otherwise the regex could always classify them
as a \fIfuture extension\fR.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1035\s0]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN NAMES \- IMPLEMENTATION AND SPECIFICATION\s0\fR.
November 1987.
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC 2806\s0]\fR" 4
.IX Item "[RFC 2806]"
Vaha-Sipila, A.: \fIURLs for Telephone Calls\fR. April 2000.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::file.3pm                0100644 0001750 0001750 00000014142 12566242002 025651  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::file 3"
.TH Regexp::Common::URI::file 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::file \-\- Returns a pattern for file URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{file}/       and  print "Contains a file URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{file}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{file}"
.IX Subsection "$RE{URI}{file}"
Returns a pattern that matches \fIfile\fR URIs, as defined by \s-1RFC 1738.\s0
File URIs have the form:
.PP
.Vb 1
\&    "file:" "//" [ host | "localhost" ] "/" fpath
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The part of the \s-1URI\s0 following \*(L"file://\*(R".
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The hostname.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The path name, including the leading slash.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The path name, without the leading slash.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::file5.16.3pm            0100644 0001750 0001750 00000013621 12566242000 026162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::file 3"
.TH Regexp::Common::URI::file 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::file \-\- Returns a pattern for file URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{file}/       and  print "Contains a file URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{file}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{file}"
.IX Subsection "$RE{URI}{file}"
Returns a pattern that matches \fIfile\fR URIs, as defined by \s-1RFC\s0 1738.
File URIs have the form:
.PP
.Vb 1
\&    "file:" "//" [ host | "localhost" ] "/" fpath
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The part of the \s-1URI\s0 following \*(L"file://\*(R".
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The hostname.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The path name, including the leading slash.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The path name, without the leading slash.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 1738]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::file5.18.3pm            0100644 0001750 0001750 00000014142 12566242002 026165  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::file 3"
.TH Regexp::Common::URI::file 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::file \-\- Returns a pattern for file URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{file}/       and  print "Contains a file URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{file}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{file}"
.IX Subsection "$RE{URI}{file}"
Returns a pattern that matches \fIfile\fR URIs, as defined by \s-1RFC 1738.\s0
File URIs have the form:
.PP
.Vb 1
\&    "file:" "//" [ host | "localhost" ] "/" fpath
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The part of the \s-1URI\s0 following \*(L"file://\*(R".
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The hostname.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The path name, including the leading slash.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The path name, without the leading slash.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::ftp.3pm                 0100644 0001750 0001750 00000022447 12566242002 025532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::ftp 3"
.TH Regexp::Common::URI::ftp 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::ftp \-\- Returns a pattern for FTP URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{FTP}/       and  print "Contains an FTP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1FTP\s0}{\-type}{\-password};"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1FTP\s0}{\-type}{\-password};"
.IX Subsection "$RE{URI}{FTP}{-type}{-password};"
Returns a regex for \s-1FTP\s0 URIs. Note: \s-1FTP\s0 URIs are not formally defined.
\&\s-1RFC 1738\s0 defines \s-1FTP\s0 URLs, but parts of that \s-1RFC\s0 have been obsoleted
by \s-1RFC 2396.\s0 However, the differences between \s-1RFC 1738\s0 and \s-1RFC 2396 \s0
are such that they aren't applicable straightforwardly to \s-1FTP\s0 URIs.
.PP
There are two main problems:
.IP "Passwords." 4
.IX Item "Passwords."
\&\s-1RFC 1738\s0 allowed an optional username and an optional password (separated
by a colon) in the \s-1FTP URL.\s0 Hence, colons were not allowed in either the
username or the password. \s-1RFC 2396\s0 strongly recommends passwords should
not be used in URIs. It does allow for \fIuserinfo\fR instead. This userinfo
part may contain colons, and hence contain more than one colon. The regexp
returned follows the \s-1RFC 2396\s0 specification, unless the \fI{\-password}\fR
option is given; then the regex allows for an optional username and
password, separated by a colon.
.IP "The ;type specifier." 4
.IX Item "The ;type specifier."
\&\s-1RFC 1738\s0 does not allow semi-colons in \s-1FTP\s0 path names, because a semi-colon
is a reserved character for \s-1FTP\s0 URIs. The semi-colon is used to separate
the path from the option \fItype\fR specifier. However, in \s-1RFC 2396,\s0 paths
consist of slash separated segments, and each segment is a semi-colon 
separated group of parameters. Straigthforward application of \s-1RFC 2396\s0
would mean that a trailing \fItype\fR specifier couldn't be distinguished
from the last segment of the path having a two parameters, the last one
starting with \fItype=\fR. Therefore we have opted to disallow a semi-colon
in the path part of an \s-1FTP URI.\s0
.Sp
Furthermore, \s-1RFC 1738\s0 allows three values for the type specifier, \fIA\fR,
\&\fII\fR and \fID\fR (either upper case or lower case). However, the internet
draft about \s-1FTP\s0 URIs \fB[\s-1DRAFT\-FTP\-URL\s0]\fR (which expired in May 1997) notes
the lack of consistent implementation of the \fID\fR parameter and drops \fID\fR
from the set of possible values. We follow this practise; however, \s-1RFC 1738\s0
behaviour can be archieved by using the \fI\-type =\fR \*(L"[ADIadi]\*(R"> parameter.
.PP
\&\s-1FTP\s0 URIs have the following syntax:
.PP
.Vb 2
\&    "ftp:" "//" [ userinfo "@" ] host [ ":" port ]
\&                [ "/" path [ ";type=" value ]]
.Ve
.PP
When using \fI{\-password}\fR, we have the syntax:
.PP
.Vb 2
\&    "ftp:" "//" [ user [ ":" password ] "@" ] host [ ":" port ]
\&                [ "/" path [ ";type=" value ]]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The userinfo, or if \fI{\-password}\fR is used, the username.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
If \fI{\-password}\fR is used, the password, else \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The hostname or \s-1IP\s0 address.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The port number.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The full path and type specification, including the leading slash.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The full path and type specification, without the leading slash.
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The full path, without the type specification nor the leading slash.
.ie n .IP "$10" 4
.el .IP "\f(CW$10\fR" 4
.IX Item "$10"
The value of the type specification.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1DRAFT\-URL\-FTP\s0]\fR" 4
.IX Item "[DRAFT-URL-FTP]"
Casey, James: \fIA \s-1FTP URL\s0 Format\fR. November 1996.
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::ftp5.16.3pm             0100644 0001750 0001750 00000022153 12566242000 026034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::ftp 3"
.TH Regexp::Common::URI::ftp 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::ftp \-\- Returns a pattern for FTP URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{FTP}/       and  print "Contains an FTP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1FTP\s0}{\-type}{\-password};"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1FTP\s0}{\-type}{\-password};"
.IX Subsection "$RE{URI}{FTP}{-type}{-password};"
Returns a regex for \s-1FTP\s0 URIs. Note: \s-1FTP\s0 URIs are not formally defined.
\&\s-1RFC\s0 1738 defines \s-1FTP\s0 URLs, but parts of that \s-1RFC\s0 have been obsoleted
by \s-1RFC\s0 2396. However, the differences between \s-1RFC\s0 1738 and \s-1RFC\s0 2396 
are such that they aren't applicable straightforwardly to \s-1FTP\s0 URIs.
.PP
There are two main problems:
.IP "Passwords." 4
.IX Item "Passwords."
\&\s-1RFC\s0 1738 allowed an optional username and an optional password (separated
by a colon) in the \s-1FTP\s0 \s-1URL\s0. Hence, colons were not allowed in either the
username or the password. \s-1RFC\s0 2396 strongly recommends passwords should
not be used in URIs. It does allow for \fIuserinfo\fR instead. This userinfo
part may contain colons, and hence contain more than one colon. The regexp
returned follows the \s-1RFC\s0 2396 specification, unless the \fI{\-password}\fR
option is given; then the regex allows for an optional username and
password, separated by a colon.
.IP "The ;type specifier." 4
.IX Item "The ;type specifier."
\&\s-1RFC\s0 1738 does not allow semi-colons in \s-1FTP\s0 path names, because a semi-colon
is a reserved character for \s-1FTP\s0 URIs. The semi-colon is used to separate
the path from the option \fItype\fR specifier. However, in \s-1RFC\s0 2396, paths
consist of slash separated segments, and each segment is a semi-colon 
separated group of parameters. Straigthforward application of \s-1RFC\s0 2396
would mean that a trailing \fItype\fR specifier couldn't be distinguished
from the last segment of the path having a two parameters, the last one
starting with \fItype=\fR. Therefore we have opted to disallow a semi-colon
in the path part of an \s-1FTP\s0 \s-1URI\s0.
.Sp
Furthermore, \s-1RFC\s0 1738 allows three values for the type specifier, \fIA\fR,
\&\fII\fR and \fID\fR (either upper case or lower case). However, the internet
draft about \s-1FTP\s0 URIs \fB[\s-1DRAFT\-FTP\-URL\s0]\fR (which expired in May 1997) notes
the lack of consistent implementation of the \fID\fR parameter and drops \fID\fR
from the set of possible values. We follow this practise; however, \s-1RFC\s0 1738
behaviour can be archieved by using the \fI\-type =\fR \*(L"[ADIadi]\*(R"> parameter.
.PP
\&\s-1FTP\s0 URIs have the following syntax:
.PP
.Vb 2
\&    "ftp:" "//" [ userinfo "@" ] host [ ":" port ]
\&                [ "/" path [ ";type=" value ]]
.Ve
.PP
When using \fI{\-password}\fR, we have the syntax:
.PP
.Vb 2
\&    "ftp:" "//" [ user [ ":" password ] "@" ] host [ ":" port ]
\&                [ "/" path [ ";type=" value ]]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The userinfo, or if \fI{\-password}\fR is used, the username.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
If \fI{\-password}\fR is used, the password, else \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The hostname or \s-1IP\s0 address.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The port number.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The full path and type specification, including the leading slash.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The full path and type specification, without the leading slash.
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The full path, without the type specification nor the leading slash.
.ie n .IP "$10" 4
.el .IP "\f(CW$10\fR" 4
.IX Item "$10"
The value of the type specification.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1DRAFT\-URL\-FTP\s0]\fR" 4
.IX Item "[DRAFT-URL-FTP]"
Casey, James: \fIA \s-1FTP\s0 \s-1URL\s0 Format\fR. November 1996.
.IP "\fB[\s-1RFC\s0 1738]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.IP "\fB[\s-1RFC\s0 2396]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::ftp5.18.3pm             0100644 0001750 0001750 00000022447 12566242002 026046  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::ftp 3"
.TH Regexp::Common::URI::ftp 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::ftp \-\- Returns a pattern for FTP URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{FTP}/       and  print "Contains an FTP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1FTP\s0}{\-type}{\-password};"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1FTP\s0}{\-type}{\-password};"
.IX Subsection "$RE{URI}{FTP}{-type}{-password};"
Returns a regex for \s-1FTP\s0 URIs. Note: \s-1FTP\s0 URIs are not formally defined.
\&\s-1RFC 1738\s0 defines \s-1FTP\s0 URLs, but parts of that \s-1RFC\s0 have been obsoleted
by \s-1RFC 2396.\s0 However, the differences between \s-1RFC 1738\s0 and \s-1RFC 2396 \s0
are such that they aren't applicable straightforwardly to \s-1FTP\s0 URIs.
.PP
There are two main problems:
.IP "Passwords." 4
.IX Item "Passwords."
\&\s-1RFC 1738\s0 allowed an optional username and an optional password (separated
by a colon) in the \s-1FTP URL.\s0 Hence, colons were not allowed in either the
username or the password. \s-1RFC 2396\s0 strongly recommends passwords should
not be used in URIs. It does allow for \fIuserinfo\fR instead. This userinfo
part may contain colons, and hence contain more than one colon. The regexp
returned follows the \s-1RFC 2396\s0 specification, unless the \fI{\-password}\fR
option is given; then the regex allows for an optional username and
password, separated by a colon.
.IP "The ;type specifier." 4
.IX Item "The ;type specifier."
\&\s-1RFC 1738\s0 does not allow semi-colons in \s-1FTP\s0 path names, because a semi-colon
is a reserved character for \s-1FTP\s0 URIs. The semi-colon is used to separate
the path from the option \fItype\fR specifier. However, in \s-1RFC 2396,\s0 paths
consist of slash separated segments, and each segment is a semi-colon 
separated group of parameters. Straigthforward application of \s-1RFC 2396\s0
would mean that a trailing \fItype\fR specifier couldn't be distinguished
from the last segment of the path having a two parameters, the last one
starting with \fItype=\fR. Therefore we have opted to disallow a semi-colon
in the path part of an \s-1FTP URI.\s0
.Sp
Furthermore, \s-1RFC 1738\s0 allows three values for the type specifier, \fIA\fR,
\&\fII\fR and \fID\fR (either upper case or lower case). However, the internet
draft about \s-1FTP\s0 URIs \fB[\s-1DRAFT\-FTP\-URL\s0]\fR (which expired in May 1997) notes
the lack of consistent implementation of the \fID\fR parameter and drops \fID\fR
from the set of possible values. We follow this practise; however, \s-1RFC 1738\s0
behaviour can be archieved by using the \fI\-type =\fR \*(L"[ADIadi]\*(R"> parameter.
.PP
\&\s-1FTP\s0 URIs have the following syntax:
.PP
.Vb 2
\&    "ftp:" "//" [ userinfo "@" ] host [ ":" port ]
\&                [ "/" path [ ";type=" value ]]
.Ve
.PP
When using \fI{\-password}\fR, we have the syntax:
.PP
.Vb 2
\&    "ftp:" "//" [ user [ ":" password ] "@" ] host [ ":" port ]
\&                [ "/" path [ ";type=" value ]]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The userinfo, or if \fI{\-password}\fR is used, the username.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
If \fI{\-password}\fR is used, the password, else \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The hostname or \s-1IP\s0 address.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The port number.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The full path and type specification, including the leading slash.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The full path and type specification, without the leading slash.
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The full path, without the type specification nor the leading slash.
.ie n .IP "$10" 4
.el .IP "\f(CW$10\fR" 4
.IX Item "$10"
The value of the type specification.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1DRAFT\-URL\-FTP\s0]\fR" 4
.IX Item "[DRAFT-URL-FTP]"
Casey, James: \fIA \s-1FTP URL\s0 Format\fR. November 1996.
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::gopher.3pm              0100644 0001750 0001750 00000020101 12566242002 026206  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::gopher 3"
.TH Regexp::Common::URI::gopher 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::gopher \-\- Returns a pattern for gopher URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{gopher}/       and  print "Contains a gopher URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{gopher}{\-notab}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{gopher}{\-notab}"
.IX Subsection "$RE{URI}{gopher}{-notab}"
Gopher URIs are poorly defined. Originally, \s-1RFC 1738\s0 defined gopher URIs,
but they were later redefined in an internet draft. One that was expired
in June 1997.
.PP
The internet draft for gopher URIs defines them as follows:
.PP
.Vb 2
\&    "gopher:" "//" host [ ":" port ] "/" gopher\-type selector
\&                        [ "%09" search [ "%09" gopherplus_string ]]
.Ve
.PP
Unfortunally, a \fIselector\fR is defined in such a way that characters
may be escaped using the \s-1URI\s0 escape mechanism. This includes tabs,
which escaped are \f(CW%09\fR. Hence, the syntax cannot distinguish between
a \s-1URI\s0 that has both a \fIselector\fR and a \fIsearch\fR part, and an \s-1URI\s0
where the \fIselector\fR includes an escaped tab. (The text of the draft
forbids tabs to be present in the \fIselector\fR though).
.PP
\&\f(CW$RE{URI}{gopher}\fR follows the defined syntax. To disallow escaped
tabs in the \fIselector\fR and \fIsearch\fR parts, use \f(CW$RE{URI}{gopher}{\-notab}\fR.
.PP
There are other differences between the text and the given syntax.
According to the text, selector strings cannot have tabs, linefeeds
or carriage returns in them. The text also allows the entire \fIgopher-path\fR,
(the part after the slash following the hostport) to be empty; if this
is empty the slash may be omitted as well. However, this isn't reflected
in the syntax.
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The entire \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The host (name or address).
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The port (if any).
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The \*(L"gopher-path\*(R", the part after the / following the host and port.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The gopher-type.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The selector. (When no \f(CW\*(C`{\-notab}\*(C'\fR is used, this includes the search
and gopherplus_string, including the separating escaped tabs).
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The search, if given. (Only when \f(CW\*(C`{\-notab}\*(C'\fR is given).
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The gopherplus_string, if given. (Only when \f(CW\*(C`{\-notab}\*(C'\fR is given).
.PP
head1 \s-1REFERENCES\s0
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.IP "\fB[\s-1RFC 1808\s0]\fR" 4
.IX Item "[RFC 1808]"
Fielding, R.: \fIRelative Uniform Resource Locators (\s-1URL\s0)\fR. June 1995.
.IP "\fB[\s-1GOPHER URL\s0]\fR" 4
.IX Item "[GOPHER URL]"
Krishnan, Murali R., Casey, James: \*(L"A Gopher \s-1URL\s0 Format\*(R". Expired
Internet draft \fIdraft-murali-url-gopher\fR. December 1996.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::gopher5.16.3pm          0100644 0001750 0001750 00000017567 12566242000 026544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::gopher 3"
.TH Regexp::Common::URI::gopher 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::gopher \-\- Returns a pattern for gopher URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{gopher}/       and  print "Contains a gopher URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{gopher}{\-notab}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{gopher}{\-notab}"
.IX Subsection "$RE{URI}{gopher}{-notab}"
Gopher URIs are poorly defined. Originally, \s-1RFC\s0 1738 defined gopher URIs,
but they were later redefined in an internet draft. One that was expired
in June 1997.
.PP
The internet draft for gopher URIs defines them as follows:
.PP
.Vb 2
\&    "gopher:" "//" host [ ":" port ] "/" gopher\-type selector
\&                        [ "%09" search [ "%09" gopherplus_string ]]
.Ve
.PP
Unfortunally, a \fIselector\fR is defined in such a way that characters
may be escaped using the \s-1URI\s0 escape mechanism. This includes tabs,
which escaped are \f(CW%09\fR. Hence, the syntax cannot distinguish between
a \s-1URI\s0 that has both a \fIselector\fR and a \fIsearch\fR part, and an \s-1URI\s0
where the \fIselector\fR includes an escaped tab. (The text of the draft
forbids tabs to be present in the \fIselector\fR though).
.PP
\&\f(CW$RE{URI}{gopher}\fR follows the defined syntax. To disallow escaped
tabs in the \fIselector\fR and \fIsearch\fR parts, use \f(CW$RE{URI}{gopher}{\-notab}\fR.
.PP
There are other differences between the text and the given syntax.
According to the text, selector strings cannot have tabs, linefeeds
or carriage returns in them. The text also allows the entire \fIgopher-path\fR,
(the part after the slash following the hostport) to be empty; if this
is empty the slash may be omitted as well. However, this isn't reflected
in the syntax.
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The entire \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The host (name or address).
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The port (if any).
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The \*(L"gopher-path\*(R", the part after the / following the host and port.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The gopher-type.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The selector. (When no \f(CW\*(C`{\-notab}\*(C'\fR is used, this includes the search
and gopherplus_string, including the separating escaped tabs).
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The search, if given. (Only when \f(CW\*(C`{\-notab}\*(C'\fR is given).
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The gopherplus_string, if given. (Only when \f(CW\*(C`{\-notab}\*(C'\fR is given).
.PP
head1 \s-1REFERENCES\s0
.IP "\fB[\s-1RFC\s0 1738]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.IP "\fB[\s-1RFC\s0 1808]\fR" 4
.IX Item "[RFC 1808]"
Fielding, R.: \fIRelative Uniform Resource Locators (\s-1URL\s0)\fR. June 1995.
.IP "\fB[\s-1GOPHER\s0 \s-1URL\s0]\fR" 4
.IX Item "[GOPHER URL]"
Krishnan, Murali R., Casey, James: \*(L"A Gopher \s-1URL\s0 Format\*(R". Expired
Internet draft \fIdraft-murali-url-gopher\fR. December 1996.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::gopher5.18.3pm          0100644 0001750 0001750 00000020101 12566242002 026522  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::gopher 3"
.TH Regexp::Common::URI::gopher 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::gopher \-\- Returns a pattern for gopher URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{gopher}/       and  print "Contains a gopher URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{gopher}{\-notab}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{gopher}{\-notab}"
.IX Subsection "$RE{URI}{gopher}{-notab}"
Gopher URIs are poorly defined. Originally, \s-1RFC 1738\s0 defined gopher URIs,
but they were later redefined in an internet draft. One that was expired
in June 1997.
.PP
The internet draft for gopher URIs defines them as follows:
.PP
.Vb 2
\&    "gopher:" "//" host [ ":" port ] "/" gopher\-type selector
\&                        [ "%09" search [ "%09" gopherplus_string ]]
.Ve
.PP
Unfortunally, a \fIselector\fR is defined in such a way that characters
may be escaped using the \s-1URI\s0 escape mechanism. This includes tabs,
which escaped are \f(CW%09\fR. Hence, the syntax cannot distinguish between
a \s-1URI\s0 that has both a \fIselector\fR and a \fIsearch\fR part, and an \s-1URI\s0
where the \fIselector\fR includes an escaped tab. (The text of the draft
forbids tabs to be present in the \fIselector\fR though).
.PP
\&\f(CW$RE{URI}{gopher}\fR follows the defined syntax. To disallow escaped
tabs in the \fIselector\fR and \fIsearch\fR parts, use \f(CW$RE{URI}{gopher}{\-notab}\fR.
.PP
There are other differences between the text and the given syntax.
According to the text, selector strings cannot have tabs, linefeeds
or carriage returns in them. The text also allows the entire \fIgopher-path\fR,
(the part after the slash following the hostport) to be empty; if this
is empty the slash may be omitted as well. However, this isn't reflected
in the syntax.
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The entire \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The host (name or address).
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The port (if any).
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The \*(L"gopher-path\*(R", the part after the / following the host and port.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The gopher-type.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The selector. (When no \f(CW\*(C`{\-notab}\*(C'\fR is used, this includes the search
and gopherplus_string, including the separating escaped tabs).
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The search, if given. (Only when \f(CW\*(C`{\-notab}\*(C'\fR is given).
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The gopherplus_string, if given. (Only when \f(CW\*(C`{\-notab}\*(C'\fR is given).
.PP
head1 \s-1REFERENCES\s0
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.IP "\fB[\s-1RFC 1808\s0]\fR" 4
.IX Item "[RFC 1808]"
Fielding, R.: \fIRelative Uniform Resource Locators (\s-1URL\s0)\fR. June 1995.
.IP "\fB[\s-1GOPHER URL\s0]\fR" 4
.IX Item "[GOPHER URL]"
Krishnan, Murali R., Casey, James: \*(L"A Gopher \s-1URL\s0 Format\*(R". Expired
Internet draft \fIdraft-murali-url-gopher\fR. December 1996.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::http.3pm                0100644 0001750 0001750 00000015611 12566242002 025713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::http 3"
.TH Regexp::Common::URI::http 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::http \-\- Returns a pattern for HTTP URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{HTTP}/       and  print "Contains an HTTP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1HTTP\s0}{\-scheme}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1HTTP\s0}{\-scheme}"
.IX Subsection "$RE{URI}{HTTP}{-scheme}"
Provides a regex for an \s-1HTTP URI\s0 as defined by \s-1RFC 2396 \s0(generic syntax)
and \s-1RFC 2616 \s0(\s-1HTTP\s0).
.PP
If \f(CW\*(C`\-scheme => \f(CIP\f(CW\*(C'\fR is specified the pattern \fIP\fR is used as the scheme.
By default \fIP\fR is \f(CW\*(C`qr/http/\*(C'\fR. \f(CW\*(C`https\*(C'\fR and \f(CW\*(C`https?\*(C'\fR are reasonable
alternatives.
.PP
The syntax for an \s-1HTTP URI\s0 is:
.PP
.Vb 1
\&    "http:" "//" host [ ":" port ] [ "/" path [ "?" query ]]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The entire \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The host (name or address).
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The port (if any).
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The absolute path, including the query and leading slash.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The absolute path, including the query, without the leading slash.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The absolute path, without the query or leading slash.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The query, without the question mark.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC 2616\s0]\fR" 4
.IX Item "[RFC 2616]"
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
Leach, P. and Berners-Lee, Tim: \fIHypertext Transfer Protocol \*(-- \s-1HTTP/1.1\s0\fR.
June 1999.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::http5.16.3pm            0100644 0001750 0001750 00000015306 12566242000 026224  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::http 3"
.TH Regexp::Common::URI::http 3 "2011-04-17" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::http \-\- Returns a pattern for HTTP URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{HTTP}/       and  print "Contains an HTTP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1HTTP\s0}{\-scheme}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1HTTP\s0}{\-scheme}"
.IX Subsection "$RE{URI}{HTTP}{-scheme}"
Provides a regex for an \s-1HTTP\s0 \s-1URI\s0 as defined by \s-1RFC\s0 2396 (generic syntax)
and \s-1RFC\s0 2616 (\s-1HTTP\s0).
.PP
If \f(CW\*(C`\-scheme => \f(CIP\f(CW\*(C'\fR is specified the pattern \fIP\fR is used as the scheme.
By default \fIP\fR is \f(CW\*(C`qr/http/\*(C'\fR. \f(CW\*(C`https\*(C'\fR and \f(CW\*(C`https?\*(C'\fR are reasonable
alternatives.
.PP
The syntax for an \s-1HTTP\s0 \s-1URI\s0 is:
.PP
.Vb 1
\&    "http:" "//" host [ ":" port ] [ "/" path [ "?" query ]]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The entire \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The host (name or address).
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The port (if any).
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The absolute path, including the query and leading slash.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The absolute path, including the query, without the leading slash.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The absolute path, without the query or leading slash.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The query, without the question mark.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 2396]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC\s0 2616]\fR" 4
.IX Item "[RFC 2616]"
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
Leach, P. and Berners-Lee, Tim: \fIHypertext Transfer Protocol \*(-- \s-1HTTP/1\s0.1\fR.
June 1999.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::http5.18.3pm            0100644 0001750 0001750 00000015611 12566242002 026227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::http 3"
.TH Regexp::Common::URI::http 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::http \-\- Returns a pattern for HTTP URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{HTTP}/       and  print "Contains an HTTP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1HTTP\s0}{\-scheme}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1HTTP\s0}{\-scheme}"
.IX Subsection "$RE{URI}{HTTP}{-scheme}"
Provides a regex for an \s-1HTTP URI\s0 as defined by \s-1RFC 2396 \s0(generic syntax)
and \s-1RFC 2616 \s0(\s-1HTTP\s0).
.PP
If \f(CW\*(C`\-scheme => \f(CIP\f(CW\*(C'\fR is specified the pattern \fIP\fR is used as the scheme.
By default \fIP\fR is \f(CW\*(C`qr/http/\*(C'\fR. \f(CW\*(C`https\*(C'\fR and \f(CW\*(C`https?\*(C'\fR are reasonable
alternatives.
.PP
The syntax for an \s-1HTTP URI\s0 is:
.PP
.Vb 1
\&    "http:" "//" host [ ":" port ] [ "/" path [ "?" query ]]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The entire \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The host (name or address).
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The port (if any).
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The absolute path, including the query and leading slash.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The absolute path, including the query, without the leading slash.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The absolute path, without the query or leading slash.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The query, without the question mark.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC 2616\s0]\fR" 4
.IX Item "[RFC 2616]"
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
Leach, P. and Berners-Lee, Tim: \fIHypertext Transfer Protocol \*(-- \s-1HTTP/1.1\s0\fR.
June 1999.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::news.3pm                0100644 0001750 0001750 00000015545 12566242002 025716  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::news 3"
.TH Regexp::Common::URI::news 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::news \-\- Returns a pattern for file URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{news}/       and  print "Contains a news URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{news}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{news}"
.IX Subsection "$RE{URI}{news}"
Returns a pattern that matches \fInews\fR URIs, as defined by \s-1RFC 1738.\s0
News URIs have the form:
.PP
.Vb 1
\&    "news:" ( "*" | group | article "@" host )
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The part of the \s-1URI\s0 following \*(L"news://\*(R".
.ie n .SS "$RE{\s-1URI\s0}{\s-1NNTP\s0}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1NNTP\s0}"
.IX Subsection "$RE{URI}{NNTP}"
Returns a pattern that matches \fI\s-1NNTP\s0\fR URIs, as defined by \s-1RFC 1738.
NNTP\s0 URIs have the form:
.PP
.Vb 1
\&    "nntp://" host [ ":" port ] "/" group [ "/" digits ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The part of the \s-1URI\s0 following \*(L"nntp://\*(R".
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The host and port, separated by a colon. If no port was given, just
the host.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The host.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The port, if given.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The group.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The digits, if given.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::news5.16.3pm            0100644 0001750 0001750 00000015235 12566242000 026222  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::news 3"
.TH Regexp::Common::URI::news 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::news \-\- Returns a pattern for file URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{news}/       and  print "Contains a news URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{news}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{news}"
.IX Subsection "$RE{URI}{news}"
Returns a pattern that matches \fInews\fR URIs, as defined by \s-1RFC\s0 1738.
News URIs have the form:
.PP
.Vb 1
\&    "news:" ( "*" | group | article "@" host )
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The part of the \s-1URI\s0 following \*(L"news://\*(R".
.ie n .SS "$RE{\s-1URI\s0}{\s-1NNTP\s0}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1NNTP\s0}"
.IX Subsection "$RE{URI}{NNTP}"
Returns a pattern that matches \fI\s-1NNTP\s0\fR URIs, as defined by \s-1RFC\s0 1738.
\&\s-1NNTP\s0 URIs have the form:
.PP
.Vb 1
\&    "nntp://" host [ ":" port ] "/" group [ "/" digits ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The part of the \s-1URI\s0 following \*(L"nntp://\*(R".
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The host and port, separated by a colon. If no port was given, just
the host.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The host.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The port, if given.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The group.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The digits, if given.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 1738]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::news5.18.3pm            0100644 0001750 0001750 00000015545 12566242002 026232  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::news 3"
.TH Regexp::Common::URI::news 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::news \-\- Returns a pattern for file URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{news}/       and  print "Contains a news URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{news}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{news}"
.IX Subsection "$RE{URI}{news}"
Returns a pattern that matches \fInews\fR URIs, as defined by \s-1RFC 1738.\s0
News URIs have the form:
.PP
.Vb 1
\&    "news:" ( "*" | group | article "@" host )
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The part of the \s-1URI\s0 following \*(L"news://\*(R".
.ie n .SS "$RE{\s-1URI\s0}{\s-1NNTP\s0}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1NNTP\s0}"
.IX Subsection "$RE{URI}{NNTP}"
Returns a pattern that matches \fI\s-1NNTP\s0\fR URIs, as defined by \s-1RFC 1738.
NNTP\s0 URIs have the form:
.PP
.Vb 1
\&    "nntp://" host [ ":" port ] "/" group [ "/" digits ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The part of the \s-1URI\s0 following \*(L"nntp://\*(R".
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The host and port, separated by a colon. If no port was given, just
the host.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The host.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The port, if given.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The group.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The digits, if given.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::pop.3pm                 0100644 0001750 0001750 00000013751 12566242002 025535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::pop 3"
.TH Regexp::Common::URI::pop 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::pop \-\- Returns a pattern for POP URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{POP}/       and  print "Contains a POP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1POP\s0}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1POP\s0}"
.IX Subsection "$RE{URI}{POP}"
Returns a pattern that matches \fI\s-1POP\s0\fR URIs, as defined by \s-1RFC 2384.
POP\s0 URIs have the form:
.PP
.Vb 2
\&    "pop:" "//" [ user [ ";AUTH" ( "*" | auth_type ) ] "@" ]
\&                  host [ ":" port ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The \fIscheme\fR.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The \fIuser\fR, if given.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The \fIauthentication type\fR, if given (could be a \fI*\fR).
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The \fIhost\fR.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The \fIport\fR, if given.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 2384\s0]\fR" 4
.IX Item "[RFC 2384]"
Gellens, R.: \fI\s-1POP URL\s0 Scheme\fR. August 1998.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail. (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::pop5.16.3pm             0100644 0001750 0001750 00000013450 12566242000 026041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::pop 3"
.TH Regexp::Common::URI::pop 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::pop \-\- Returns a pattern for POP URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{POP}/       and  print "Contains a POP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1POP\s0}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1POP\s0}"
.IX Subsection "$RE{URI}{POP}"
Returns a pattern that matches \fI\s-1POP\s0\fR URIs, as defined by \s-1RFC\s0 2384.
\&\s-1POP\s0 URIs have the form:
.PP
.Vb 2
\&    "pop:" "//" [ user [ ";AUTH" ( "*" | auth_type ) ] "@" ]
\&                  host [ ":" port ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The \fIscheme\fR.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The \fIuser\fR, if given.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The \fIauthentication type\fR, if given (could be a \fI*\fR).
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The \fIhost\fR.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The \fIport\fR, if given.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 2384]\fR" 4
.IX Item "[RFC 2384]"
Gellens, R.: \fI\s-1POP\s0 \s-1URL\s0 Scheme\fR. August 1998.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail. (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::pop5.18.3pm             0100644 0001750 0001750 00000013751 12566242002 026051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::pop 3"
.TH Regexp::Common::URI::pop 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::pop \-\- Returns a pattern for POP URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{POP}/       and  print "Contains a POP URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1POP\s0}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1POP\s0}"
.IX Subsection "$RE{URI}{POP}"
Returns a pattern that matches \fI\s-1POP\s0\fR URIs, as defined by \s-1RFC 2384.
POP\s0 URIs have the form:
.PP
.Vb 2
\&    "pop:" "//" [ user [ ";AUTH" ( "*" | auth_type ) ] "@" ]
\&                  host [ ":" port ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The \fIscheme\fR.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The \fIuser\fR, if given.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The \fIauthentication type\fR, if given (could be a \fI*\fR).
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The \fIhost\fR.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The \fIport\fR, if given.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 2384\s0]\fR" 4
.IX Item "[RFC 2384]"
Gellens, R.: \fI\s-1POP URL\s0 Scheme\fR. August 1998.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail. (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::prospero.3pm            0100644 0001750 0001750 00000014110 12566242002 026576  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::prospero 3"
.TH Regexp::Common::URI::prospero 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::prospero \-\- Returns a pattern for prospero URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{prospero}/ and print "Contains a prospero URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{prospero}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{prospero}"
.IX Subsection "$RE{URI}{prospero}"
Returns a pattern that matches \fIprospero\fR URIs, as defined by \s-1RFC 1738.\s0
prospero URIs have the form:
.PP
.Vb 1
\&    "prospero:" "//" host [ ":" port ] "/" path [ fieldspec ] *
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The \fIscheme\fR.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The \fIhostname\fR.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The \fIport\fR, if given.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The propero path.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The field specifications, if given. There can be more field specifications;
they will all be returned in \f(CW$6\fR.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail. (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::prospero5.16.3pm        0100644 0001750 0001750 00000013567 12566242000 027125  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::prospero 3"
.TH Regexp::Common::URI::prospero 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::prospero \-\- Returns a pattern for prospero URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{prospero}/ and print "Contains a prospero URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{prospero}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{prospero}"
.IX Subsection "$RE{URI}{prospero}"
Returns a pattern that matches \fIprospero\fR URIs, as defined by \s-1RFC\s0 1738.
prospero URIs have the form:
.PP
.Vb 1
\&    "prospero:" "//" host [ ":" port ] "/" path [ fieldspec ] *
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The \fIscheme\fR.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The \fIhostname\fR.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The \fIport\fR, if given.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The propero path.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The field specifications, if given. There can be more field specifications;
they will all be returned in \f(CW$6\fR.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 1738]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail. (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::prospero5.18.3pm        0100644 0001750 0001750 00000014110 12566242002 027112  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::prospero 3"
.TH Regexp::Common::URI::prospero 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::prospero \-\- Returns a pattern for prospero URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{prospero}/ and print "Contains a prospero URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{prospero}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{prospero}"
.IX Subsection "$RE{URI}{prospero}"
Returns a pattern that matches \fIprospero\fR URIs, as defined by \s-1RFC 1738.\s0
prospero URIs have the form:
.PP
.Vb 1
\&    "prospero:" "//" host [ ":" port ] "/" path [ fieldspec ] *
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The \fIscheme\fR.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The \fIhostname\fR.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The \fIport\fR, if given.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The propero path.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The field specifications, if given. There can be more field specifications;
they will all be returned in \f(CW$6\fR.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail. (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::tel.3pm                 0100644 0001750 0001750 00000015154 12566242002 025522  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::tel 3"
.TH Regexp::Common::URI::tel 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::tel \-\- Returns a pattern for telephone URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{tel}/       and  print "Contains a telephone URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{tel}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{tel}"
.IX Subsection "$RE{URI}{tel}"
Returns a pattern that matches \fItel\fR URIs, as defined by \s-1RFC 2806.\s0
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The phone number, including any possible add-ons like \s-1ISDN\s0 subaddress,
a post dial part, area specifier, service provider, etc.
.ie n .SS "$RE{URI}{tel}{nofuture}"
.el .SS "\f(CW$RE{URI}{tel}{nofuture}\fP"
.IX Subsection "$RE{URI}{tel}{nofuture}"
As above (including what's returned by \f(CW\*(C`{\-keep}\*(C'\fR), with the exception
that \fIfuture extensions\fR are not allowed. Without allowing 
those \fIfuture extensions\fR, it becomes much easier to check a \s-1URI\s0 if
the correct syntax for post dial, service provider, phone context,
etc has been used \- otherwise the regex could always classify them
as a \fIfuture extension\fR.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1035\s0]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN NAMES \- IMPLEMENTATION AND SPECIFICATION\s0\fR.
November 1987.
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC 2806\s0]\fR" 4
.IX Item "[RFC 2806]"
Vaha-Sipila, A.: \fIURLs for Telephone Calls\fR. April 2000.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::tel5.16.3pm             0100644 0001750 0001750 00000014667 12566242000 026042  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::tel 3"
.TH Regexp::Common::URI::tel 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::tel \-\- Returns a pattern for telephone URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{tel}/       and  print "Contains a telephone URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{tel}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{tel}"
.IX Subsection "$RE{URI}{tel}"
Returns a pattern that matches \fItel\fR URIs, as defined by \s-1RFC\s0 2806.
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The phone number, including any possible add-ons like \s-1ISDN\s0 subaddress,
a post dial part, area specifier, service provider, etc.
.ie n .SS "$RE{URI}{tel}{nofuture}"
.el .SS "\f(CW$RE{URI}{tel}{nofuture}\fP"
.IX Subsection "$RE{URI}{tel}{nofuture}"
As above (including what's returned by \f(CW\*(C`{\-keep}\*(C'\fR), with the exception
that \fIfuture extensions\fR are not allowed. Without allowing 
those \fIfuture extensions\fR, it becomes much easier to check a \s-1URI\s0 if
the correct syntax for post dial, service provider, phone context,
etc has been used \- otherwise the regex could always classify them
as a \fIfuture extension\fR.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 1035]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN\s0 \s-1NAMES\s0 \- \s-1IMPLEMENTATION\s0 \s-1AND\s0 \s-1SPECIFICATION\s0\fR.
November 1987.
.IP "\fB[\s-1RFC\s0 2396]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC\s0 2806]\fR" 4
.IX Item "[RFC 2806]"
Vaha-Sipila, A.: \fIURLs for Telephone Calls\fR. April 2000.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::tel5.18.3pm             0100644 0001750 0001750 00000015154 12566242002 026036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::tel 3"
.TH Regexp::Common::URI::tel 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::tel \-\- Returns a pattern for telephone URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{tel}/       and  print "Contains a telephone URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{tel}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{tel}"
.IX Subsection "$RE{URI}{tel}"
Returns a pattern that matches \fItel\fR URIs, as defined by \s-1RFC 2806.\s0
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The phone number, including any possible add-ons like \s-1ISDN\s0 subaddress,
a post dial part, area specifier, service provider, etc.
.ie n .SS "$RE{URI}{tel}{nofuture}"
.el .SS "\f(CW$RE{URI}{tel}{nofuture}\fP"
.IX Subsection "$RE{URI}{tel}{nofuture}"
As above (including what's returned by \f(CW\*(C`{\-keep}\*(C'\fR), with the exception
that \fIfuture extensions\fR are not allowed. Without allowing 
those \fIfuture extensions\fR, it becomes much easier to check a \s-1URI\s0 if
the correct syntax for post dial, service provider, phone context,
etc has been used \- otherwise the regex could always classify them
as a \fIfuture extension\fR.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1035\s0]\fR" 4
.IX Item "[RFC 1035]"
Mockapetris, P.: \fI\s-1DOMAIN NAMES \- IMPLEMENTATION AND SPECIFICATION\s0\fR.
November 1987.
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.IP "\fB[\s-1RFC 2806\s0]\fR" 4
.IX Item "[RFC 2806]"
Vaha-Sipila, A.: \fIURLs for Telephone Calls\fR. April 2000.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::telnet.3pm              0100644 0001750 0001750 00000014606 12566242002 026232  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::telnet 3"
.TH Regexp::Common::URI::telnet 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::telnet \-\- Returns a pattern for telnet URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{telnet}/       and  print "Contains a telnet URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{telnet}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{telnet}"
.IX Subsection "$RE{URI}{telnet}"
Returns a pattern that matches \fItelnet\fR URIs, as defined by \s-1RFC 1738.\s0
Telnet URIs have the form:
.PP
.Vb 1
\&    "telnet:" "//" [ user [ ":" password ] "@" ] host [ ":" port ] [ "/" ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The username:password combo, or just the username if there is no password.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The username, if given.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The password, if given.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The host:port combo, or just the host if there's no port.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The host.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The port, if given.
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The trailing slash, if any.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::telnet5.16.3pm          0100644 0001750 0001750 00000014265 12566242000 026543  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::telnet 3"
.TH Regexp::Common::URI::telnet 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::telnet \-\- Returns a pattern for telnet URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{telnet}/       and  print "Contains a telnet URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{telnet}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{telnet}"
.IX Subsection "$RE{URI}{telnet}"
Returns a pattern that matches \fItelnet\fR URIs, as defined by \s-1RFC\s0 1738.
Telnet URIs have the form:
.PP
.Vb 1
\&    "telnet:" "//" [ user [ ":" password ] "@" ] host [ ":" port ] [ "/" ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The username:password combo, or just the username if there is no password.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The username, if given.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The password, if given.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The host:port combo, or just the host if there's no port.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The host.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The port, if given.
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The trailing slash, if any.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 1738]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::telnet5.18.3pm          0100644 0001750 0001750 00000014606 12566242002 026546  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::telnet 3"
.TH Regexp::Common::URI::telnet 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::telnet \-\- Returns a pattern for telnet URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{telnet}/       and  print "Contains a telnet URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{telnet}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{telnet}"
.IX Subsection "$RE{URI}{telnet}"
Returns a pattern that matches \fItelnet\fR URIs, as defined by \s-1RFC 1738.\s0
Telnet URIs have the form:
.PP
.Vb 1
\&    "telnet:" "//" [ user [ ":" password ] "@" ] host [ ":" port ] [ "/" ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The username:password combo, or just the username if there is no password.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The username, if given.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The password, if given.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The host:port combo, or just the host if there's no port.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The host.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The port, if given.
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The trailing slash, if any.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::tv.3pm                  0100644 0001750 0001750 00000013603 12566242002 025364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::tv 3"
.TH Regexp::Common::URI::tv 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::tv \-\- Returns a pattern for tv URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{tv}/       and  print "Contains a tv URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{URI}{tv}"
.el .SS "\f(CW$RE{URI}{tv}\fP"
.IX Subsection "$RE{URI}{tv}"
Returns a pattern that recognizes \s-1TV\s0 uris as per an Internet draft
[\s-1DRAFT\-URI\-TV\s0].
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The entire \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The host.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1DRAFT\-URI\-TV\s0]\fR" 4
.IX Item "[DRAFT-URI-TV]"
Zigmond, D. and Vickers, M: \fIUniform Resource Identifiers for
Television Broadcasts\fR. December 2000.
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::tv5.16.3pm              0100644 0001750 0001750 00000013262 12566242000 025675  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::tv 3"
.TH Regexp::Common::URI::tv 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::tv \-\- Returns a pattern for tv URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{tv}/       and  print "Contains a tv URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{URI}{tv}"
.el .SS "\f(CW$RE{URI}{tv}\fP"
.IX Subsection "$RE{URI}{tv}"
Returns a pattern that recognizes \s-1TV\s0 uris as per an Internet draft
[\s-1DRAFT\-URI\-TV\s0].
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The entire \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The host.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1DRAFT\-URI\-TV\s0]\fR" 4
.IX Item "[DRAFT-URI-TV]"
Zigmond, D. and Vickers, M: \fIUniform Resource Identifiers for
Television Broadcasts\fR. December 2000.
.IP "\fB[\s-1RFC\s0 2396]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::tv5.18.3pm              0100644 0001750 0001750 00000013603 12566242002 025700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::tv 3"
.TH Regexp::Common::URI::tv 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::tv \-\- Returns a pattern for tv URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{tv}/       and  print "Contains a tv URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{URI}{tv}"
.el .SS "\f(CW$RE{URI}{tv}\fP"
.IX Subsection "$RE{URI}{tv}"
Returns a pattern that recognizes \s-1TV\s0 uris as per an Internet draft
[\s-1DRAFT\-URI\-TV\s0].
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The entire \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The scheme.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The host.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1DRAFT\-URI\-TV\s0]\fR" 4
.IX Item "[DRAFT-URI-TV]"
Zigmond, D. and Vickers, M: \fIUniform Resource Identifiers for
Television Broadcasts\fR. December 2000.
.IP "\fB[\s-1RFC 2396\s0]\fR" 4
.IX Item "[RFC 2396]"
Berners-Lee, Tim, Fielding, R., and Masinter, L.: \fIUniform Resource
Identifiers (\s-1URI\s0): Generic Syntax\fR. August 1998.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::wais.3pm                0100644 0001750 0001750 00000015074 12566242002 025702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::wais 3"
.TH Regexp::Common::URI::wais 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::wais \-\- Returns a pattern for WAIS URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{WAIS}/       and  print "Contains a WAIS URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1WAIS\s0}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1WAIS\s0}"
.IX Subsection "$RE{URI}{WAIS}"
Returns a pattern that matches \fI\s-1WAIS\s0\fR URIs, as defined by \s-1RFC 1738.
WAIS\s0 URIs have the form:
.PP
.Vb 2
\&    "wais:" "//" host [ ":" port ] "/" database
\&                      [ ( "?" search ) | ( "/" wtype "/" wpath ) ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The \fIscheme\fR.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The \fIhostname\fR.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The \fIport\fR, if given.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The \fIdatabase\fR, followed by \fIsearch\fR or \fIwtype/wpath\fR, if given.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The \fIdatabase\fR.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The part following the \fIdatabase\fR if given, including the question mark 
or slash.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The \fIsearch\fR part, if given.
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The \fIwtype\fR, if given.
.ie n .IP "$10" 4
.el .IP "\f(CW$10\fR" 4
.IX Item "$10"
The \fIwpath\fR, if given.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::wais5.16.3pm            0100644 0001750 0001750 00000014564 12566242000 026215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::wais 3"
.TH Regexp::Common::URI::wais 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::wais \-\- Returns a pattern for WAIS URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{WAIS}/       and  print "Contains a WAIS URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1WAIS\s0}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1WAIS\s0}"
.IX Subsection "$RE{URI}{WAIS}"
Returns a pattern that matches \fI\s-1WAIS\s0\fR URIs, as defined by \s-1RFC\s0 1738.
\&\s-1WAIS\s0 URIs have the form:
.PP
.Vb 2
\&    "wais:" "//" host [ ":" port ] "/" database
\&                      [ ( "?" search ) | ( "/" wtype "/" wpath ) ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI\s0.
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The \fIscheme\fR.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The \fIhostname\fR.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The \fIport\fR, if given.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The \fIdatabase\fR, followed by \fIsearch\fR or \fIwtype/wpath\fR, if given.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The \fIdatabase\fR.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The part following the \fIdatabase\fR if given, including the question mark 
or slash.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The \fIsearch\fR part, if given.
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The \fIwtype\fR, if given.
.ie n .IP "$10" 4
.el .IP "\f(CW$10\fR" 4
.IX Item "$10"
The \fIwpath\fR, if given.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC\s0 1738]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::URI::wais5.18.3pm            0100644 0001750 0001750 00000015074 12566242002 026216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::URI::wais 3"
.TH Regexp::Common::URI::wais 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::URI::wais \-\- Returns a pattern for WAIS URIs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /URI/;
\&
\&    while (<>) {
\&        /$RE{URI}{WAIS}/       and  print "Contains a WAIS URI.\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$RE{\s-1URI\s0}{\s-1WAIS\s0}"
.el .SS "\f(CW$RE\fP{\s-1URI\s0}{\s-1WAIS\s0}"
.IX Subsection "$RE{URI}{WAIS}"
Returns a pattern that matches \fI\s-1WAIS\s0\fR URIs, as defined by \s-1RFC 1738.
WAIS\s0 URIs have the form:
.PP
.Vb 2
\&    "wais:" "//" host [ ":" port ] "/" database
\&                      [ ( "?" search ) | ( "/" wtype "/" wpath ) ]
.Ve
.PP
Under \f(CW\*(C`{\-keep}\*(C'\fR, the following are returned:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
The complete \s-1URI.\s0
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
The \fIscheme\fR.
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
The \fIhostname\fR.
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
The \fIport\fR, if given.
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
The \fIdatabase\fR, followed by \fIsearch\fR or \fIwtype/wpath\fR, if given.
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
The \fIdatabase\fR.
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
The part following the \fIdatabase\fR if given, including the question mark 
or slash.
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
The \fIsearch\fR part, if given.
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
The \fIwtype\fR, if given.
.ie n .IP "$10" 4
.el .IP "\f(CW$10\fR" 4
.IX Item "$10"
The \fIwpath\fR, if given.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\fB[\s-1RFC 1738\s0]\fR" 4
.IX Item "[RFC 1738]"
Berners-Lee, Tim, Masinter, L., McCahill, M.: \fIUniform Resource
Locators (\s-1URL\s0)\fR. December 1994.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common::URI for other supported URIs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::_support.3pm                 0100644 0001750 0001750 00000012433 12566242002 026042  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::_support 3"
.TH Regexp::Common::_support 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::support \-\- Support functions for Regexp::Common.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::_support qw /luhn/;
\&
\&    luhn ($number)    # Returns true/false.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains some subroutines to be used by other \f(CW\*(C`Regexp::Common\*(C'\fR
modules. It's not intended to be used directly. Subroutines from the 
module may disappear without any notice, or their meaning or interface
may change without notice.
.IP "luhn" 4
.IX Item "luhn"
This subroutine returns true if its argument passes the luhn checksum test.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://www.webopedia.com/TERM/L/Luhn_formula.html>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::_support5.16.3pm             0100644 0001750 0001750 00000012112 12566242000 026344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::_support 3"
.TH Regexp::Common::_support 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::support \-\- Support functions for Regexp::Common.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::_support qw /luhn/;
\&
\&    luhn ($number)    # Returns true/false.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains some subroutines to be used by other \f(CW\*(C`Regexp::Common\*(C'\fR
modules. It's not intended to be used directly. Subroutines from the 
module may disappear without any notice, or their meaning or interface
may change without notice.
.IP "luhn" 4
.IX Item "luhn"
This subroutine returns true if its argument passes the luhn checksum test.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://www.webopedia.com/TERM/L/Luhn_formula.html>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::_support5.18.3pm             0100644 0001750 0001750 00000012433 12566242002 026356  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::_support 3"
.TH Regexp::Common::_support 3 "2013-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::support \-\- Support functions for Regexp::Common.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common::_support qw /luhn/;
\&
\&    luhn ($number)    # Returns true/false.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains some subroutines to be used by other \f(CW\*(C`Regexp::Common\*(C'\fR
modules. It's not intended to be used directly. Subroutines from the 
module may disappear without any notice, or their meaning or interface
may change without notice.
.IP "luhn" 4
.IX Item "luhn"
This subroutine returns true if its argument passes the luhn checksum test.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://www.webopedia.com/TERM/L/Luhn_formula.html>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2009, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::balanced.3pm                 0100644 0001750 0001750 00000017313 12566242002 025722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::balanced 3"
.TH Regexp::Common::balanced 3 "2013-03-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::balanced \-\- provide regexes for strings with balanced
parenthesized delimiters or arbitrary delimiters.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /balanced/;
\&
\&    while (<>) {
\&        /$RE{balanced}{\-parens=>\*(Aq()\*(Aq}/
\&                                   and print q{balanced parentheses\en};
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Please consult the manual of Regexp::Common for a general description
of the works of this interface.
.PP
Do not use this module directly, but load it via \fIRegexp::Common\fR.
.ie n .SS "$RE{balanced}{\-parens}"
.el .SS "\f(CW$RE{balanced}{\-parens}\fP"
.IX Subsection "$RE{balanced}{-parens}"
Returns a pattern that matches a string that starts with the nominated
opening parenthesis or bracket, contains characters and properly nested
parenthesized subsequences, and ends in the matching parenthesis.
.PP
More than one type of parenthesis can be specified:
.PP
.Vb 1
\&        $RE{balanced}{\-parens=>\*(Aq(){}\*(Aq}
.Ve
.PP
in which case all specified parenthesis types must be correctly balanced within
the string.
.PP
Since version 2013030901, \f(CW$1\fR will always be set (to the entire
matched substring), regardless whether \f(CW\*(C`{\-keep}\*(C'\fR is used or not.
.ie n .SS "$RE{balanced}{\-begin => ""begin""}{\-end => ""end""}"
.el .SS "\f(CW$RE{balanced}{\-begin => ``begin''}{\-end => ``end''}\fP"
.IX Subsection "$RE{balanced}{-begin => ""begin""}{-end => ""end""}"
Returns a pattern that matches a string that is properly balanced
using the \fIbegin\fR and \fIend\fR strings as start and end delimiters.
Multiple sets of begin and end strings can be given by separating
them by \f(CW\*(C`|\*(C'\fRs (which can be escaped with a backslash).
.PP
.Vb 1
\&    qr/$RE{balanced}{\-begin => "do|if|case"}{\-end => "done|fi|esac"}/
.Ve
.PP
will match properly balanced strings that either start with \fIdo\fR and
end with \fIdone\fR, start with \fIif\fR and end with \fIfi\fR, or start with
\&\fIcase\fR and end with \fIesac\fR.
.PP
If \fI\-end\fR contains less cases than \fI\-begin\fR, the last case of \fI\-end\fR
is repeated. If it contains more cases than \fI\-begin\fR, the extra cases
are ignored. If either of \fI\-begin\fR or \fI\-end\fR isn't given, or is empty,
\&\fI\-begin => '('\fR and \fI\-end => ')'\fR are assumed.
.PP
Since version 2013030901, \f(CW$1\fR will always be set (to the entire
matched substring), regardless whether \f(CW\*(C`{\-keep}\*(C'\fR is used or not.
.SS "Note"
.IX Subsection "Note"
Since version 2013030901 the pattern will make of the recursive construct
\&\f(CW\*(C`(?\-1)\*(C'\fR, instead of using the problematic \f(CW\*(C`(??{ })\*(C'\fR construct.
This fixes an problem that was introduced in the 5.17 development track.
This also means the pattern is no longer available for Perls older than 5.010.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Common for a general description of how to use this interface.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "MAINTAINANCE"
.IX Header "MAINTAINANCE"
This package is maintained by Abigail (\fIregexp\-common@abigail.be\fR).
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in to \fIregexp\-common@abigail.be\fR.
.SH "LICENSE and COPYRIGHT"
.IX Header "LICENSE and COPYRIGHT"
This software is Copyright (c) 2001 \- 2013, Damian Conway and Abigail.
.PP
This module is free software, and maybe used under any of the following
licenses:
.PP
.Vb 4
\& 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
\& 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
\& 3) The BSD Licence.               See the file COPYRIGHT.BSD.
\& 4) The MIT Licence.               See the file COPYRIGHT.MIT.
.Ve
                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Regexp::Common::balanced5.16.3pm             0100644 0001750 0001750 00000016155 12566242000 026235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common::balanced 3"
.TH Regexp::Common::balanced 3 "2010-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common::balanced \-\- provide regexes for strings with balanced
parenthesized delimiters or arbitrary delimiters.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Common qw /balanced/;
\&
\&    while (<>) {
\&        /$RE{balanced}{\-parens=>\*(Aq()\*(Aq}/
\&                                   and print q{balanced parentheses\en};
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Please consult the manual of Regexp::Common for a general description
of the works of this interface.
.PP
Do not use this module directly, but load it via \fIRegexp::Common\fR.
.ie n .SS "$RE{balanced}{\-parens}"
.el .SS "\f(CW$RE{balanced}{\-parens}\fP"
.IX Subsection "$RE{balanced}{-parens}"
Returns a pattern that matches a string that starts with the nominated
opening parenthesis or bracket, contains characters and properly nested
parenthesized subsequences, and ends in the matching parenthesis.
.PP
More than one type of parenthesis can be specified:
.PP
.Vb 1
\&        $RE{balanced}{\-parens=>\*(Aq(){}\*(Aq}
.Ve
.PP
in which case all specified parenthesis types must be correctly balanced within
the string.
.PP
If we are using C{\-keep} (See Regexp::Common):
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire expression
.ie n .SS "$RE{balanced}{\-begin => ""begin""}{\-end => ""end""}"
.el .SS "\f(CW$RE{balanced}{\-begin => ``begin''}{\-end => ``end''}\fP"
.IX Subsection "$RE{balanced}{-begin => ""begin""}{-end => ""end""}"
Returns a pattern that matches a string that is properly balanced
using the \fIbegin\fR and \fIend\fR strings as start and end delimiters.
Multiple sets of begin and end strings can be given by separating
them by \f(CW\*(C`|\*(C'\fRs (which can be escaped with a backslash).
.PP
.Vb 1
\&    qr/$RE{balanced}{\-begin => "do|i