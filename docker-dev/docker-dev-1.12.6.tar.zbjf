8E, 0xF6, 0xE7, 0x99, 0x82, 0xF6,
		0xE8, 0x93, 0xBC, 0xF6, 0xE9, 0x81, 0xBC, 0xF6,
		0xE9, 0xBE, 0x8D, 0xF6, 0xE6, 0x9A, 0x88, 0xF6,
		0xE9, 0x98, 0xAE, 0xF6, 0xE5, 0x8A, 0x89, 0xF6,
		0xE6, 0x9D, 0xBB, 0xF6, 0xE6, 0x9F, 0xB3, 0xF6,
		0xE6, 0xB5, 0x81, 0xF6, 0xE6, 0xBA, 0x9C, 0xF6,
		0xE7, 0x90, 0x89, 0xF6, 0xE7, 0x95, 0x99, 0xF6,
		0xE7, 0xA1, 0xAB, 0xF6, 0xE7, 0xB4, 0x90, 0xF6,
		0xE9, 0xA1, 0x9E, 0xF6, 0xE5, 0x85, 0xAD, 0xF6,
		0xE6, 0x88, 0xAE, 0xF6, 0xE9, 0x99, 0xB8, 0xF6,
		0xE5, 0x80, 0xAB, 0xF6, 0xE5, 0xB4, 0x99, 0xF6,
		0xE6, 0xB7, 0xAA, 0xF6, 0xE8, 0xBC, 0xAA, 0xF6,
		0xE5, 0xBE, 0x8B, 0xF6, 0xE6, 0x85, 0x84, 0xF6,
		0xE6, 0xA0, 0x97, 0xF6, 0xE7, 0x8E, 0x87, 0xF6,
		0xE9, 0x9A, 0x86, 0xF6, 0xE5, 0x88, 0xA9, 0xF6,
		0xE5, 0x90, 0x8F, 0xF6, 0xE5, 0xB1, 0xA5, 0xF6,
		0xE6, 0x98, 0x93, 0xF6, 0xE6, 0x9D, 0x8E, 0xF6,
		0xE6, 0xA2, 0xA8, 0xF6, 0xE6, 0xB3, 0xA5, 0xF6,
		0xE7, 0x90, 0x86, 0xF6, 0xE7, 0x97, 0xA2, 0xF6,
		0xE7, 0xBD, 0xB9, 0xF6, 0xE8, 0xA3, 0x8F, 0xF6,
		0xE8, 0xA3, 0xA1, 0xF6, 0xE9, 0x87, 0x8C, 0xF6,
		0xE9, 0x9B, 0xA2, 0xF6, 0xE5, 0x8C, 0xBF, 0xF6,
		0xE6, 0xBA, 0xBA, 0xF6, 0xE5, 0x90, 0x9D, 0xF6,
		0xE7, 0x87, 0x90, 0xF6, 0xE7, 0x92, 0x98, 0xF6,
		0xE8, 0x97, 0xBA, 0xF6, 0xE9, 0x9A, 0xA3, 0xF6,
		0xE9, 0xB1, 0x97, 0xF6, 0xE9, 0xBA, 0x9F, 0xF6,
		0xE6, 0x9E, 0x97, 0xF6, 0xE6, 0xB7, 0x8B, 0xF6,
		0xE8, 0x87, 0xA8, 0xF6, 0xE7, 0xAB, 0x8B, 0xF6,
		0xE7, 0xAC, 0xA0, 0xF6, 0xE7, 0xB2, 0x92, 0xF6,
		0xE7, 0x8B, 0x80, 0xF6, 0xE7, 0x82, 0x99, 0xF6,
		0xE8, 0xAD, 0x98, 0xF6, 0xE4, 0xBB, 0x80, 0xF6,
		0xE8, 0x8C, 0xB6, 0xF6, 0xE5, 0x88, 0xBA, 0xF6,
		0xE5, 0x88, 0x87, 0xF6, 0xE5, 0xBA, 0xA6, 0xF6,
		0xE6, 0x8B, 0x93, 0xF6, 0xE7, 0xB3, 0x96, 0xF6,
		0xE5, 0xAE, 0x85, 0xF6, 0xE6, 0xB4, 0x9E, 0xF6,
		0xE6, 0x9A, 0xB4, 0xF6, 0xE8, 0xBC, 0xBB, 0xF6,
		0xE8, 0xA1, 0x8C, 0xF6, 0xE9, 0x99, 0x8D, 0xF6,
		0xE8, 0xA6, 0x8B, 0xF6, 0xE5, 0xBB, 0x93, 0xF6,
		0xE5, 0x85, 0x80, 0xF6, 0xE5, 0x97, 0x80, 0xF6,
		0xE5, 0xA1, 0x9A, 0xF6, 0xE6, 0x99, 0xB4, 0xF6,
		0xE5, 0x87, 0x9E, 0xF6, 0xE7, 0x8C, 0xAA, 0xF6,
		0xE7, 0x9B, 0x8A, 0xF6, 0xE7, 0xA4, 0xBC, 0xF6,
		0xE7, 0xA5, 0x9E, 0xF6, 0xE7, 0xA5, 0xA5, 0xF6,
		0xE7, 0xA6, 0x8F, 0xF6, 0xE9, 0x9D, 0x96, 0xF6,
		0xE7, 0xB2, 0xBE, 0xF6, 0xE7, 0xBE, 0xBD, 0xF6,
		0xE8, 0x98, 0x92, 0xF6, 0xE8, 0xAB, 0xB8, 0xF6,
		0xE9, 0x80, 0xB8, 0xF6, 0xE9, 0x83, 0xBD, 0xF6,
		0xE9, 0xA3, 0xAF, 0xF6, 0xE9, 0xA3, 0xBC, 0xF6,
		0xE9, 0xA4, 0xA8, 0xF6, 0xE9, 0xB6, 0xB4, 0xF6,
		0xE4, 0xBE, 0xAE, 0xF6, 0xE5, 0x83, 0xA7, 0xF6,
		0xE5, 0x85, 0x8D, 0xF6, 0xE5, 0x8B, 0x89, 0xF6,
		0xE5, 0x8B, 0xA4, 0xF6, 0xE5, 0x8D, 0x91, 0xF6,
		0xE5, 0x96, 0x9D, 0xF6, 0xE5, 0x98, 0x86, 0xF6,
		0xE5, 0x99, 0xA8, 0xF6, 0xE5, 0xA1, 0x80, 0xF6,
		0xE5, 0xA2, 0xA8, 0xF6, 0xE5, 0xB1, 0xA4, 0xF6,
		0xE5, 0xB1, 0xAE, 0xF6, 0xE6, 0x82, 0x94, 0xF6,
		0xE6, 0x85, 0xA8, 0xF6, 0xE6, 0x86, 0x8E, 0xF6,
		0xE6, 0x87, 0xB2, 0xF6, 0xE6, 0x95, 0x8F, 0xF6,
		0xE6, 0x97, 0xA2, 0xF6, 0xE6, 0x9A, 0x91, 0xF6,
		0xE6, 0xA2, 0x85, 0xF6, 0xE6, 0xB5, 0xB7, 0xF6,
		0xE6, 0xB8, 0x9A, 0xF6, 0xE6, 0xBC, 0xA2, 0xF6,
		0xE7, 0x85, 0xAE, 0xF6, 0xE7, 0x88, 0xAB, 0xF6,
		0xE7, 0x90, 0xA2, 0xF6, 0xE7, 0xA2, 0x91, 0xF6,
		0xE7, 0xA4, 0xBE, 0xF6, 0xE7, 0xA5, 0x89, 0xF6,
		0xE7, 0xA5, 0x88, 0xF6, 0xE7, 0xA5, 0x90, 0xF6,
		0xE7, 0xA5, 0x96, 0xF6, 0xE7, 0xA5, 0x9D, 0xF6,
		0xE7, 0xA6, 0x8D, 0xF6, 0xE7, 0xA6, 0x8E, 0xF6,
		0xE7, 0xA9, 0x80, 0xF6, 0xE7, 0xAA, 0x81, 0xF6,
		0xE7, 0xAF, 0x80, 0xF6, 0xE7, 0xB7, 0xB4, 0xF6,
		0xE7, 0xB8, 0x89, 0xF6, 0xE7, 0xB9, 0x81, 0xF6,
		0xE7, 0xBD, 0xB2, 0xF6, 0xE8, 0x80, 0x85, 0xF6,
		0xE8, 0x87, 0xAD, 0xF6, 0xE8, 0x89, 0xB9, 0xF6,
		0xE8, 0x89, 0xB9, 0xF6, 0xE8, 0x91, 0x97, 0xF6,
		0xE8, 0xA4, 0x90, 0xF6, 0xE8, 0xA6, 0x96, 0xF6,
		0xE8, 0xAC, 0x81, 0xF6, 0xE8, 0xAC, 0xB9, 0xF6,
		0xE8, 0xB3, 0x93, 0xF6, 0xE8, 0xB4, 0x88, 0xF6,
		0xE8, 0xBE, 0xB6, 0xF6, 0xE9, 0x80, 0xB8, 0xF6,
		0xE9, 0x9B, 0xA3, 0xF6, 0xE9, 0x9F, 0xBF, 0xF6,
		0xE9, 0xA0, 0xBB, 0x66, 0x66, 0x66, 0x69, 0x66,
		0x6C, 0x66, 0x66, 0x69, 0x66, 0x66, 0x6C, 0x73,
		0x74, 0x73, 0x74, 0xD5, 0xB4, 0xD5, 0xB6, 0xD5,
		0xB4, 0xD5, 0xA5, 0xD5, 0xB4, 0xD5, 0xAB, 0xD5,
		0xBE, 0xD5, 0xB6, 0xD5, 0xB4, 0xD5, 0xAD, 0xF6,
		0xD7, 0x99, 0xD6, 0xB4, 0xF6, 0xD7, 0xB2, 0xD6,
		0xB7, 0xD7, 0xA2, 0xD7, 0x90, 0xD7, 0x93, 0xD7,
		0x94, 0xD7, 0x9B, 0xD7, 0x9C, 0xD7, 0x9D, 0xD7,
		0xA8, 0xD7, 0xAA, 0x2B, 0xF6, 0xD7, 0xA9, 0xD7,
		0x81, 0xF6, 0xD7, 0xA9, 0xD7, 0x82, 0xF6, 0xD7,
		0xA9, 0xD6, 0xBC, 0xD7, 0x81, 0xF6, 0xD7, 0xA9,
		0xD6, 0xBC, 0xD7, 0x82, 0xF6, 0xD7, 0x90, 0xD6,
		0xB7, 0xF6, 0xD7, 0x90, 0xD6, 0xB8, 0xF6, 0xD7,
		0x90, 0xD6, 0xBC, 0xF6, 0xD7, 0x91, 0xD6, 0xBC,
		0xF6, 0xD7, 0x92, 0xD6, 0xBC, 0xF6, 0xD7, 0x93,
		0xD6, 0xBC, 0xF6, 0xD7, 0x94, 0xD6, 0xBC, 0xF6,
		0xD7, 0x95, 0xD6, 0xBC, 0xF6, 0xD7, 0x96, 0xD6,
		0xBC, 0xF6, 0xD7, 0x98, 0xD6, 0xBC, 0xF6, 0xD7,
		0x99, 0xD6, 0xBC, 0xF6, 0xD7, 0x9A, 0xD6, 0xBC,
		0xF6, 0xD7, 0x9B, 0xD6, 0xBC, 0xF6, 0xD7, 0x9C,
		0xD6, 0xBC, 0xF6, 0xD7, 0x9E, 0xD6, 0xBC, 0xF6,
		0xD7, 0xA0, 0xD6, 0xBC, 0xF6, 0xD7, 0xA1, 0xD6,
		0xBC, 0xF6, 0xD7, 0xA3, 0xD6, 0xBC, 0xF6, 0xD7,
		0xA4, 0xD6, 0xBC, 0xF6, 0xD7, 0xA6, 0xD6, 0xBC,
		0xF6, 0xD7, 0xA7, 0xD6, 0xBC, 0xF6, 0xD7, 0xA8,
		0xD6, 0xBC, 0xF6, 0xD7, 0xA9, 0xD6, 0xBC, 0xF6,
		0xD7, 0xAA, 0xD6, 0xBC, 0xF6, 0xD7, 0x95, 0xD6,
		0xB9, 0xF6, 0xD7, 0x91, 0xD6, 0xBF, 0xF6, 0xD7,
		0x9B, 0xD6, 0xBF, 0xF6, 0xD7, 0xA4, 0xD6, 0xBF,
		0xD7, 0x90, 0xD7, 0x9C, 0xD9, 0xB1, 0xD9, 0xB1,
		0xD9, 0xBB, 0xD9, 0xBB, 0xD9, 0xBB, 0xD9, 0xBB,
		0xD9, 0xBE, 0xD9, 0xBE, 0xD9, 0xBE, 0xD9, 0xBE,
		0xDA, 0x80, 0xDA, 0x80, 0xDA, 0x80, 0xDA, 0x80,
		0xD9, 0xBA, 0xD9, 0xBA, 0xD9, 0xBA, 0xD9, 0xBA,
		0xD9, 0xBF, 0xD9, 0xBF, 0xD9, 0xBF, 0xD9, 0xBF,
		0xD9, 0xB9, 0xD9, 0xB9, 0xD9, 0xB9, 0xD9, 0xB9,
		0xDA, 0xA4, 0xDA, 0xA4, 0xDA, 0xA4, 0xDA, 0xA4,
		0xDA, 0xA6, 0xDA, 0xA6, 0xDA, 0xA6, 0xDA, 0xA6,
		0xDA, 0x84, 0xDA, 0x84, 0xDA, 0x84, 0xDA, 0x84,
		0xDA, 0x83, 0xDA, 0x83, 0xDA, 0x83, 0xDA, 0x83,
		0xDA, 0x86, 0xDA, 0x86, 0xDA, 0x86, 0xDA, 0x86,
		0xDA, 0x87, 0xDA, 0x87, 0xDA, 0x87, 0xDA, 0x87,
		0xDA, 0x8D, 0xDA, 0x8D, 0xDA, 0x8C, 0xDA, 0x8C,
		0xDA, 0x8E, 0xDA, 0x8E, 0xDA, 0x88, 0xDA, 0x88,
		0xDA, 0x98, 0xDA, 0x98, 0xDA, 0x91, 0xDA, 0x91,
		0xDA, 0xA9, 0xDA, 0xA9, 0xDA, 0xA9, 0xDA, 0xA9,
		0xDA, 0xAF, 0xDA, 0xAF, 0xDA, 0xAF, 0xDA, 0xAF,
		0xDA, 0xB3, 0xDA, 0xB3, 0xDA, 0xB3, 0xDA, 0xB3,
		0xDA, 0xB1, 0xDA, 0xB1, 0xDA, 0xB1, 0xDA, 0xB1,
		0xDA, 0xBA, 0xDA, 0xBA, 0xDA, 0xBB, 0xDA, 0xBB,
		0xDA, 0xBB, 0xDA, 0xBB, 0xDB, 0x95, 0xD9, 0x94,
		0xDB, 0x95, 0xD9, 0x94, 0xDB, 0x81, 0xDB, 0x81,
		0xDB, 0x81, 0xDB, 0x81, 0xDA, 0xBE, 0xDA, 0xBE,
		0xDA, 0xBE, 0xDA, 0xBE, 0xDB, 0x92, 0xDB, 0x92,
		0xDB, 0x92, 0xD9, 0x94, 0xDB, 0x92, 0xD9, 0x94,
		0xDA, 0xAD, 0xDA, 0xAD, 0xDA, 0xAD, 0xDA, 0xAD,
		0xDB, 0x87, 0xDB, 0x87, 0xDB, 0x86, 0xDB, 0x86,
		0xDB, 0x88, 0xDB, 0x88, 0xDB, 0x87, 0xD9, 0xB4,
		0xDB, 0x8B, 0xDB, 0x8B, 0xDB, 0x85, 0xDB, 0x85,
		0xDB, 0x89, 0xDB, 0x89, 0xDB, 0x90, 0xDB, 0x90,
		0xDB, 0x90, 0xDB, 0x90, 0xD9, 0x89, 0xD9, 0x89,
		0xD9, 0x8A, 0xD9, 0x94, 0xD8, 0xA7, 0xD9, 0x8A,
		0xD9, 0x94, 0xD8, 0xA7, 0xD9, 0x8A, 0xD9, 0x94,
		0xDB, 0x95, 0xD9, 0x8A, 0xD9, 0x94, 0xDB, 0x95,
		0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x88, 0xD9, 0x8A,
		0xD9, 0x94, 0xD9, 0x88, 0xD9, 0x8A, 0xD9, 0x94,
		0xDB, 0x87, 0xD9, 0x8A, 0xD9, 0x94, 0xDB, 0x87,
		0xD9, 0x8A, 0xD9, 0x94, 0xDB, 0x86, 0xD9, 0x8A,
		0xD9, 0x94, 0xDB, 0x86, 0xD9, 0x8A, 0xD9, 0x94,
		0xDB, 0x88, 0xD9, 0x8A, 0xD9, 0x94, 0xDB, 0x88,
		0xD9, 0x8A, 0xD9, 0x94, 0xDB, 0x90, 0xD9, 0x8A,
		0xD9, 0x94, 0xDB, 0x90, 0xD9, 0x8A, 0xD9, 0x94,
		0xDB, 0x90, 0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x89,
		0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x89, 0xD9, 0x8A,
		0xD9, 0x94, 0xD9, 0x89, 0xDB, 0x8C, 0xDB, 0x8C,
		0xDB, 0x8C, 0xDB, 0x8C, 0xD9, 0x8A, 0xD9, 0x94,
		0xD8, 0xAC, 0xD9, 0x8A, 0xD9, 0x94, 0xD8, 0xAD,
		0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x85, 0xD9, 0x8A,
		0xD9, 0x94, 0xD9, 0x89, 0xD9, 0x8A, 0xD9, 0x94,
		0xD9, 0x8A, 0xD8, 0xA8, 0xD8, 0xAC, 0xD8, 0xA8,
		0xD8, 0xAD, 0xD8, 0xA8, 0xD8, 0xAE, 0xD8, 0xA8,
		0xD9, 0x85, 0xD8, 0xA8, 0xD9, 0x89, 0xD8, 0xA8,
		0xD9, 0x8A, 0xD8, 0xAA, 0xD8, 0xAC, 0xD8, 0xAA,
		0xD8, 0xAD, 0xD8, 0xAA, 0xD8, 0xAE, 0xD8, 0xAA,
		0xD9, 0x85, 0xD8, 0xAA, 0xD9, 0x89, 0xD8, 0xAA,
		0xD9, 0x8A, 0xD8, 0xAB, 0xD8, 0xAC, 0xD8, 0xAB,
		0xD9, 0x85, 0xD8, 0xAB, 0xD9, 0x89, 0xD8, 0xAB,
		0xD9, 0x8A, 0xD8, 0xAC, 0xD8, 0xAD, 0xD8, 0xAC,
		0xD9, 0x85, 0xD8, 0xAD, 0xD8, 0xAC, 0xD8, 0xAD,
		0xD9, 0x85, 0xD8, 0xAE, 0xD8, 0xAC, 0xD8, 0xAE,
		0xD8, 0xAD, 0xD8, 0xAE, 0xD9, 0x85, 0xD8, 0xB3,
		0xD8, 0xAC, 0xD8, 0xB3, 0xD8, 0xAD, 0xD8, 0xB3,
		0xD8, 0xAE, 0xD8, 0xB3, 0xD9, 0x85, 0xD8, 0xB5,
		0xD8, 0xAD, 0xD8, 0xB5, 0xD9, 0x85, 0xD8, 0xB6,
		0xD8, 0xAC, 0xD8, 0xB6, 0xD8, 0xAD, 0xD8, 0xB6,
		0xD8, 0xAE, 0xD8, 0xB6, 0xD9, 0x85, 0xD8, 0xB7,
		0xD8, 0xAD, 0xD8, 0xB7, 0xD9, 0x85, 0xD8, 0xB8,
		0xD9, 0x85, 0xD8, 0xB9, 0xD8, 0xAC, 0xD8, 0xB9,
		0xD9, 0x85, 0xD8, 0xBA, 0xD8, 0xAC, 0xD8, 0xBA,
		0xD9, 0x85, 0xD9, 0x81, 0xD8, 0xAC, 0xD9, 0x81,
		0xD8, 0xAD, 0xD9, 0x81, 0xD8, 0xAE, 0xD9, 0x81,
		0xD9, 0x85, 0xD9, 0x81, 0xD9, 0x89, 0xD9, 0x81,
		0xD9, 0x8A, 0xD9, 0x82, 0xD8, 0xAD, 0xD9, 0x82,
		0xD9, 0x85, 0xD9, 0x82, 0xD9, 0x89, 0xD9, 0x82,
		0xD9, 0x8A, 0xD9, 0x83, 0xD8, 0xA7, 0xD9, 0x83,
		0xD8, 0xAC, 0xD9, 0x83, 0xD8, 0xAD, 0xD9, 0x83,
		0xD8, 0xAE, 0xD9, 0x83, 0xD9, 0x84, 0xD9, 0x83,
		0xD9, 0x85, 0xD9, 0x83, 0xD9, 0x89, 0xD9, 0x83,
		0xD9, 0x8A, 0xD9, 0x84, 0xD8, 0xAC, 0xD9, 0x84,
		0xD8, 0xAD, 0xD9, 0x84, 0xD8, 0xAE, 0xD9, 0x84,
		0xD9, 0x85, 0xD9, 0x84, 0xD9, 0x89, 0xD9, 0x84,
		0xD9, 0x8A, 0xD9, 0x85, 0xD8, 0xAC, 0xD9, 0x85,
		0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAE, 0xD9, 0x85,
		0xD9, 0x85, 0xD9, 0x85, 0xD9, 0x89, 0xD9, 0x85,
		0xD9, 0x8A, 0xD9, 0x86, 0xD8, 0xAC, 0xD9, 0x86,
		0xD8, 0xAD, 0xD9, 0x86, 0xD8, 0xAE, 0xD9, 0x86,
		0xD9, 0x85, 0xD9, 0x86, 0xD9, 0x89, 0xD9, 0x86,
		0xD9, 0x8A, 0xD9, 0x87, 0xD8, 0xAC, 0xD9, 0x87,
		0xD9, 0x85, 0xD9, 0x87, 0xD9, 0x89, 0xD9, 0x87,
		0xD9, 0x8A, 0xD9, 0x8A, 0xD8, 0xAC, 0xD9, 0x8A,
		0xD8, 0xAD, 0xD9, 0x8A, 0xD8, 0xAE, 0xD9, 0x8A,
		0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x89, 0xD9, 0x8A,
		0xD9, 0x8A, 0xD8, 0xB0, 0xD9, 0xB0, 0xD8, 0xB1,
		0xD9, 0xB0, 0xD9, 0x89, 0xD9, 0xB0, 0x20, 0xD9,
		0x8C, 0xD9, 0x91, 0x20, 0xD9, 0x8D, 0xD9, 0x91,
		0x20, 0xD9, 0x8E, 0xD9, 0x91, 0x20, 0xD9, 0x8F,
		0xD9, 0x91, 0x20, 0xD9, 0x90, 0xD9, 0x91, 0x20,
		0xD9, 0x91, 0xD9, 0xB0, 0xD9, 0x8A, 0xD9, 0x94,
		0xD8, 0xB1, 0xD9, 0x8A, 0xD9, 0x94, 0xD8, 0xB2,
		0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x85, 0xD9, 0x8A,
		0xD9, 0x94, 0xD9, 0x86, 0xD9, 0x8A, 0xD9, 0x94,
		0xD9, 0x89, 0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x8A,
		0xD8, 0xA8, 0xD8, 0xB1, 0xD8, 0xA8, 0xD8, 0xB2,
		0xD8, 0xA8, 0xD9, 0x85, 0xD8, 0xA8, 0xD9, 0x86,
		0xD8, 0xA8, 0xD9, 0x89, 0xD8, 0xA8, 0xD9, 0x8A,
		0xD8, 0xAA, 0xD8, 0xB1, 0xD8, 0xAA, 0xD8, 0xB2,
		0xD8, 0xAA, 0xD9, 0x85, 0xD8, 0xAA, 0xD9, 0x86,
		0xD8, 0xAA, 0xD9, 0x89, 0xD8, 0xAA, 0xD9, 0x8A,
		0xD8, 0xAB, 0xD8, 0xB1, 0xD8, 0xAB, 0xD8, 0xB2,
		0xD8, 0xAB, 0xD9, 0x85, 0xD8, 0xAB, 0xD9, 0x86,
		0xD8, 0xAB, 0xD9, 0x89, 0xD8, 0xAB, 0xD9, 0x8A,
		0xD9, 0x81, 0xD9, 0x89, 0xD9, 0x81, 0xD9, 0x8A,
		0xD9, 0x82, 0xD9, 0x89, 0xD9, 0x82, 0xD9, 0x8A,
		0xD9, 0x83, 0xD8, 0xA7, 0xD9, 0x83, 0xD9, 0x84,
		0xD9, 0x83, 0xD9, 0x85, 0xD9, 0x83, 0xD9, 0x89,
		0xD9, 0x83, 0xD9, 0x8A, 0xD9, 0x84, 0xD9, 0x85,
		0xD9, 0x84, 0xD9, 0x89, 0xD9, 0x84, 0xD9, 0x8A,
		0xD9, 0x85, 0xD8, 0xA7, 0xD9, 0x85, 0xD9, 0x85,
		0xD9, 0x86, 0xD8, 0xB1, 0xD9, 0x86, 0xD8, 0xB2,
		0xD9, 0x86, 0xD9, 0x85, 0xD9, 0x86, 0xD9, 0x86,
		0xD9, 0x86, 0xD9, 0x89, 0xD9, 0x86, 0xD9, 0x8A,
		0xD9, 0x89, 0xD9, 0xB0, 0xD9, 0x8A, 0xD8, 0xB1,
		0xD9, 0x8A, 0xD8, 0xB2, 0xD9, 0x8A, 0xD9, 0x85,
		0xD9, 0x8A, 0xD9, 0x86, 0xD9, 0x8A, 0xD9, 0x89,
		0xD9, 0x8A, 0xD9, 0x8A, 0xD9, 0x8A, 0xD9, 0x94,
		0xD8, 0xAC, 0xD9, 0x8A, 0xD9, 0x94, 0xD8, 0xAD,
		0xD9, 0x8A, 0xD9, 0x94, 0xD8, 0xAE, 0xD9, 0x8A,
		0xD9, 0x94, 0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x94,
		0xD9, 0x87, 0xD8, 0xA8, 0xD8, 0xAC, 0xD8, 0xA8,
		0xD8, 0xAD, 0xD8, 0xA8, 0xD8, 0xAE, 0xD8, 0xA8,
		0xD9, 0x85, 0xD8, 0xA8, 0xD9, 0x87, 0xD8, 0xAA,
		0xD8, 0xAC, 0xD8, 0xAA, 0xD8, 0xAD, 0xD8, 0xAA,
		0xD8, 0xAE, 0xD8, 0xAA, 0xD9, 0x85, 0xD8, 0xAA,
		0xD9, 0x87, 0xD8, 0xAB, 0xD9, 0x85, 0xD8, 0xAC,
		0xD8, 0xAD, 0xD8, 0xAC, 0xD9, 0x85, 0xD8, 0xAD,
		0xD8, 0xAC, 0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAE,
		0xD8, 0xAC, 0xD8, 0xAE, 0xD9, 0x85, 0xD8, 0xB3,
		0xD8, 0xAC, 0xD8, 0xB3, 0xD8, 0xAD, 0xD8, 0xB3,
		0xD8, 0xAE, 0xD8, 0xB3, 0xD9, 0x85, 0xD8, 0xB5,
		0xD8, 0xAD, 0xD8, 0xB5, 0xD8, 0xAE, 0xD8, 0xB5,
		0xD9, 0x85, 0xD8, 0xB6, 0xD8, 0xAC, 0xD8, 0xB6,
		0xD8, 0xAD, 0xD8, 0xB6, 0xD8, 0xAE, 0xD8, 0xB6,
		0xD9, 0x85, 0xD8, 0xB7, 0xD8, 0xAD, 0xD8, 0xB8,
		0xD9, 0x85, 0xD8, 0xB9, 0xD8, 0xAC, 0xD8, 0xB9,
		0xD9, 0x85, 0xD8, 0xBA, 0xD8, 0xAC, 0xD8, 0xBA,
		0xD9, 0x85, 0xD9, 0x81, 0xD8, 0xAC, 0xD9, 0x81,
		0xD8, 0xAD, 0xD9, 0x81, 0xD8, 0xAE, 0xD9, 0x81,
		0xD9, 0x85, 0xD9, 0x82, 0xD8, 0xAD, 0xD9, 0x82,
		0xD9, 0x85, 0xD9, 0x83, 0xD8, 0xAC, 0xD9, 0x83,
		0xD8, 0xAD, 0xD9, 0x83, 0xD8, 0xAE, 0xD9, 0x83,
		0xD9, 0x84, 0xD9, 0x83, 0xD9, 0x85, 0xD9, 0x84,
		0xD8, 0xAC, 0xD9, 0x84, 0xD8, 0xAD, 0xD9, 0x84,
		0xD8, 0xAE, 0xD9, 0x84, 0xD9, 0x85, 0xD9, 0x84,
		0xD9, 0x87, 0xD9, 0x85, 0xD8, 0xAC, 0xD9, 0x85,
		0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAE, 0xD9, 0x85,
		0xD9, 0x85, 0xD9, 0x86, 0xD8, 0xAC, 0xD9, 0x86,
		0xD8, 0xAD, 0xD9, 0x86, 0xD8, 0xAE, 0xD9, 0x86,
		0xD9, 0x85, 0xD9, 0x86, 0xD9, 0x87, 0xD9, 0x87,
		0xD8, 0xAC, 0xD9, 0x87, 0xD9, 0x85, 0xD9, 0x87,
		0xD9, 0xB0, 0xD9, 0x8A, 0xD8, 0xAC, 0xD9, 0x8A,
		0xD8, 0xAD, 0xD9, 0x8A, 0xD8, 0xAE, 0xD9, 0x8A,
		0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x87, 0xD9, 0x8A,
		0xD9, 0x94, 0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x94,
		0xD9, 0x87, 0xD8, 0xA8, 0xD9, 0x85, 0xD8, 0xA8,
		0xD9, 0x87, 0xD8, 0xAA, 0xD9, 0x85, 0xD8, 0xAA,
		0xD9, 0x87, 0xD8, 0xAB, 0xD9, 0x85, 0xD8, 0xAB,
		0xD9, 0x87, 0xD8, 0xB3, 0xD9, 0x85, 0xD8, 0xB3,
		0xD9, 0x87, 0xD8, 0xB4, 0xD9, 0x85, 0xD8, 0xB4,
		0xD9, 0x87, 0xD9, 0x83, 0xD9, 0x84, 0xD9, 0x83,
		0xD9, 0x85, 0xD9, 0x84, 0xD9, 0x85, 0xD9, 0x86,
		0xD9, 0x85, 0xD9, 0x86, 0xD9, 0x87, 0xD9, 0x8A,
		0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x87, 0xD9, 0x80,
		0xD9, 0x8E, 0xD9, 0x91, 0xD9, 0x80, 0xD9, 0x8F,
		0xD9, 0x91, 0xD9, 0x80, 0xD9, 0x90, 0xD9, 0x91,
		0xD8, 0xB7, 0xD9, 0x89, 0xD8, 0xB7, 0xD9, 0x8A,
		0xD8, 0xB9, 0xD9, 0x89, 0xD8, 0xB9, 0xD9, 0x8A,
		0xD8, 0xBA, 0xD9, 0x89, 0xD8, 0xBA, 0xD9, 0x8A,
		0xD8, 0xB3, 0xD9, 0x89, 0xD8, 0xB3, 0xD9, 0x8A,
		0xD8, 0xB4, 0xD9, 0x89, 0xD8, 0xB4, 0xD9, 0x8A,
		0xD8, 0xAD, 0xD9, 0x89, 0xD8, 0xAD, 0xD9, 0x8A,
		0xD8, 0xAC, 0xD9, 0x89, 0xD8, 0xAC, 0xD9, 0x8A,
		0xD8, 0xAE, 0xD9, 0x89, 0xD8, 0xAE, 0xD9, 0x8A,
		0xD8, 0xB5, 0xD9, 0x89, 0xD8, 0xB5, 0xD9, 0x8A,
		0xD8, 0xB6, 0xD9, 0x89, 0xD8, 0xB6, 0xD9, 0x8A,
		0xD8, 0xB4, 0xD8, 0xAC, 0xD8, 0xB4, 0xD8, 0xAD,
		0xD8, 0xB4, 0xD8, 0xAE, 0xD8, 0xB4, 0xD9, 0x85,
		0xD8, 0xB4, 0xD8, 0xB1, 0xD8, 0xB3, 0xD8, 0xB1,
		0xD8, 0xB5, 0xD8, 0xB1, 0xD8, 0xB6, 0xD8, 0xB1,
		0xD8, 0xB7, 0xD9, 0x89, 0xD8, 0xB7, 0xD9, 0x8A,
		0xD8, 0xB9, 0xD9, 0x89, 0xD8, 0xB9, 0xD9, 0x8A,
		0xD8, 0xBA, 0xD9, 0x89, 0xD8, 0xBA, 0xD9, 0x8A,
		0xD8, 0xB3, 0xD9, 0x89, 0xD8, 0xB3, 0xD9, 0x8A,
		0xD8, 0xB4, 0xD9, 0x89, 0xD8, 0xB4, 0xD9, 0x8A,
		0xD8, 0xAD, 0xD9, 0x89, 0xD8, 0xAD, 0xD9, 0x8A,
		0xD8, 0xAC, 0xD9, 0x89, 0xD8, 0xAC, 0xD9, 0x8A,
		0xD8, 0xAE, 0xD9, 0x89, 0xD8, 0xAE, 0xD9, 0x8A,
		0xD8, 0xB5, 0xD9, 0x89, 0xD8, 0xB5, 0xD9, 0x8A,
		0xD8, 0xB6, 0xD9, 0x89, 0xD8, 0xB6, 0xD9, 0x8A,
		0xD8, 0xB4, 0xD8, 0xAC, 0xD8, 0xB4, 0xD8, 0xAD,
		0xD8, 0xB4, 0xD8, 0xAE, 0xD8, 0xB4, 0xD9, 0x85,
		0xD8, 0xB4, 0xD8, 0xB1, 0xD8, 0xB3, 0xD8, 0xB1,
		0xD8, 0xB5, 0xD8, 0xB1, 0xD8, 0xB6, 0xD8, 0xB1,
		0xD8, 0xB4, 0xD8, 0xAC, 0xD8, 0xB4, 0xD8, 0xAD,
		0xD8, 0xB4, 0xD8, 0xAE, 0xD8, 0xB4, 0xD9, 0x85,
		0xD8, 0xB3, 0xD9, 0x87, 0xD8, 0xB4, 0xD9, 0x87,
		0xD8, 0xB7, 0xD9, 0x85, 0xD8, 0xB3, 0xD8, 0xAC,
		0xD8, 0xB3, 0xD8, 0xAD, 0xD8, 0xB3, 0xD8, 0xAE,
		0xD8, 0xB4, 0xD8, 0xAC, 0xD8, 0xB4, 0xD8, 0xAD,
		0xD8, 0xB4, 0xD8, 0xAE, 0xD8, 0xB7, 0xD9, 0x85,
		0xD8, 0xB8, 0xD9, 0x85, 0xD8, 0xA7, 0xD9, 0x8B,
		0xD8, 0xA7, 0xD9, 0x8B, 0xD8, 0xAA, 0xD8, 0xAC,
		0xD9, 0x85, 0xD8, 0xAA, 0xD8, 0xAD, 0xD8, 0xAC,
		0xD8, 0xAA, 0xD8, 0xAD, 0xD8, 0xAC, 0xD8, 0xAA,
		0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAA, 0xD8, 0xAE,
		0xD9, 0x85, 0xD8, 0xAA, 0xD9, 0x85, 0xD8, 0xAC,
		0xD8, 0xAA, 0xD9, 0x85, 0xD8, 0xAD, 0xD8, 0xAA,
		0xD9, 0x85, 0xD8, 0xAE, 0xD8, 0xAC, 0xD9, 0x85,
		0xD8, 0xAD, 0xD8, 0xAC, 0xD9, 0x85, 0xD8, 0xAD,
		0xD8, 0xAD, 0xD9, 0x85, 0xD9, 0x8A, 0xD8, 0xAD,
		0xD9, 0x85, 0xD9, 0x89, 0xD8, 0xB3, 0xD8, 0xAD,
		0xD8, 0xAC, 0xD8, 0xB3, 0xD8, 0xAC, 0xD8, 0xAD,
		0xD8, 0xB3, 0xD8, 0xAC, 0xD9, 0x89, 0xD8, 0xB3,
		0xD9, 0x85, 0xD8, 0xAD, 0xD8, 0xB3, 0xD9, 0x85,
		0xD8, 0xAD, 0xD8, 0xB3, 0xD9, 0x85, 0xD8, 0xAC,
		0xD8, 0xB3, 0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB3,
		0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB5, 0xD8, 0xAD,
		0xD8, 0xAD, 0xD8, 0xB5, 0xD8, 0xAD, 0xD8, 0xAD,
		0xD8, 0xB5, 0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB4,
		0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xB4, 0xD8, 0xAD,
		0xD9, 0x85, 0xD8, 0xB4, 0xD8, 0xAC, 0xD9, 0x8A,
		0xD8, 0xB4, 0xD9, 0x85, 0xD8, 0xAE, 0xD8, 0xB4,
		0xD9, 0x85, 0xD8, 0xAE, 0xD8, 0xB4, 0xD9, 0x85,
		0xD9, 0x85, 0xD8, 0xB4, 0xD9, 0x85, 0xD9, 0x85,
		0xD8, 0xB6, 0xD8, 0xAD, 0xD9, 0x89, 0xD8, 0xB6,
		0xD8, 0xAE, 0xD9, 0x85, 0xD8, 0xB6, 0xD8, 0xAE,
		0xD9, 0x85, 0xD8, 0xB7, 0xD9, 0x85, 0xD8, 0xAD,
		0xD8, 0xB7, 0xD9, 0x85, 0xD8, 0xAD, 0xD8, 0xB7,
		0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB7, 0xD9, 0x85,
		0xD9, 0x8A, 0xD8, 0xB9, 0xD8, 0xAC, 0xD9, 0x85,
		0xD8, 0xB9, 0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB9,
		0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB9, 0xD9, 0x85,
		0xD9, 0x89, 0xD8, 0xBA, 0xD9, 0x85, 0xD9, 0x85,
		0xD8, 0xBA, 0xD9, 0x85, 0xD9, 0x8A, 0xD8, 0xBA,
		0xD9, 0x85, 0xD9, 0x89, 0xD9, 0x81, 0xD8, 0xAE,
		0xD9, 0x85, 0xD9, 0x81, 0xD8, 0xAE, 0xD9, 0x85,
		0xD9, 0x82, 0xD9, 0x85, 0xD8, 0xAD, 0xD9, 0x82,
		0xD9, 0x85, 0xD9, 0x85, 0xD9, 0x84, 0xD8, 0xAD,
		0xD9, 0x85, 0xD9, 0x84, 0xD8, 0xAD, 0xD9, 0x8A,
		0xD9, 0x84, 0xD8, 0xAD, 0xD9, 0x89, 0xD9, 0x84,
		0xD8, 0xAC, 0xD8, 0xAC, 0xD9, 0x84, 0xD8, 0xAC,
		0xD8, 0xAC, 0xD9, 0x84, 0xD8, 0xAE, 0xD9, 0x85,
		0xD9, 0x84, 0xD8, 0xAE, 0xD9, 0x85, 0xD9, 0x84,
		0xD9, 0x85, 0xD8, 0xAD, 0xD9, 0x84, 0xD9, 0x85,
		0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAD, 0xD8, 0xAC,
		0xD9, 0x85, 0xD8, 0xAD, 0xD9, 0x85, 0xD9, 0x85,
		0xD8, 0xAD, 0xD9, 0x8A, 0xD9, 0x85, 0xD8, 0xAC,
		0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAC, 0xD9, 0x85,
		0xD9, 0x85, 0xD8, 0xAE, 0xD8, 0xAC, 0xD9, 0x85,
		0xD8, 0xAE, 0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xAC,
		0xD8, 0xAE, 0xD9, 0x87, 0xD9, 0x85, 0xD8, 0xAC,
		0xD9, 0x87, 0xD9, 0x85, 0xD9, 0x85, 0xD9, 0x86,
		0xD8, 0xAD, 0xD9, 0x85, 0xD9, 0x86, 0xD8, 0xAD,
		0xD9, 0x89, 0xD9, 0x86, 0xD8, 0xAC, 0xD9, 0x85,
		0xD9, 0x86, 0xD8, 0xAC, 0xD9, 0x85, 0xD9, 0x86,
		0xD8, 0xAC, 0xD9, 0x89, 0xD9, 0x86, 0xD9, 0x85,
		0xD9, 0x8A, 0xD9, 0x86, 0xD9, 0x85, 0xD9, 0x89,
		0xD9, 0x8A, 0xD9, 0x85, 0xD9, 0x85, 0xD9, 0x8A,
		0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xA8, 0xD8, 0xAE,
		0xD9, 0x8A, 0xD8, 0xAA, 0xD8, 0xAC, 0xD9, 0x8A,
		0xD8, 0xAA, 0xD8, 0xAC, 0xD9, 0x89, 0xD8, 0xAA,
		0xD8, 0xAE, 0xD9, 0x8A, 0xD8, 0xAA, 0xD8, 0xAE,
		0xD9, 0x89, 0xD8, 0xAA, 0xD9, 0x85, 0xD9, 0x8A,
		0xD8, 0xAA, 0xD9, 0x85, 0xD9, 0x89, 0xD8, 0xAC,
		0xD9, 0x85, 0xD9, 0x8A, 0xD8, 0xAC, 0xD8, 0xAD,
		0xD9, 0x89, 0xD8, 0xAC, 0xD9, 0x85, 0xD9, 0x89,
		0xD8, 0xB3, 0xD8, 0xAE, 0xD9, 0x89, 0xD8, 0xB5,
		0xD8, 0xAD, 0xD9, 0x8A, 0xD8, 0xB4, 0xD8, 0xAD,
		0xD9, 0x8A, 0xD8, 0xB6, 0xD8, 0xAD, 0xD9, 0x8A,
		0xD9, 0x84, 0xD8, 0xAC, 0xD9, 0x8A, 0xD9, 0x84,
		0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x8A, 0xD8, 0xAD,
		0xD9, 0x8A, 0xD9, 0x8A, 0xD8, 0xAC, 0xD9, 0x8A,
		0xD9, 0x8A, 0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x85,
		0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x82, 0xD9, 0x85,
		0xD9, 0x8A, 0xD9, 0x86, 0xD8, 0xAD, 0xD9, 0x8A,
		0xD9, 0x82, 0xD9, 0x85, 0xD8, 0xAD, 0xD9, 0x84,
		0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xB9, 0xD9, 0x85,
		0xD9, 0x8A, 0xD9, 0x83, 0xD9, 0x85, 0xD9, 0x8A,
		0xD9, 0x86, 0xD8, 0xAC, 0xD8, 0xAD, 0xD9, 0x85,
		0xD8, 0xAE, 0xD9, 0x8A, 0xD9, 0x84, 0xD8, 0xAC,
		0xD9, 0x85, 0xD9, 0x83, 0xD9, 0x85, 0xD9, 0x85,
		0xD9, 0x84, 0xD8, 0xAC, 0xD9, 0x85, 0xD9, 0x86,
		0xD8, 0xAC, 0xD8, 0xAD, 0xD8, 0xAC, 0xD8, 0xAD,
		0xD9, 0x8A, 0xD8, 0xAD, 0xD8, 0xAC, 0xD9, 0x8A,
		0xD9, 0x85, 0xD8, 0xAC, 0xD9, 0x8A, 0xD9, 0x81,
		0xD9, 0x85, 0xD9, 0x8A, 0xD8, 0xA8, 0xD8, 0xAD,
		0xD9, 0x8A, 0xD9, 0x83, 0xD9, 0x85, 0xD9, 0x85,
		0xD8, 0xB9, 0xD8, 0xAC, 0xD9, 0x85, 0xD8, 0xB5,
		0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB3, 0xD8, 0xAE,
		0xD9, 0x8A, 0xD9, 0x86, 0xD8, 0xAC, 0xD9, 0x8A,
		0xD8, 0xB5, 0xD9, 0x84, 0xDB, 0x92, 0xD9, 0x82,
		0xD9, 0x84, 0xDB, 0x92, 0xD8, 0xA7, 0xD9, 0x84,
		0xD9, 0x84, 0xD9, 0x87, 0xD8, 0xA7, 0xD9, 0x83,
		0xD8, 0xA8, 0xD8, 0xB1, 0xD9, 0x85, 0xD8, 0xAD,
		0xD9, 0x85, 0xD8, 0xAF, 0xD8, 0xB5, 0xD9, 0x84,
		0xD8, 0xB9, 0xD9, 0x85, 0xD8, 0xB1, 0xD8, 0xB3,
		0xD9, 0x88, 0xD9, 0x84, 0xD8, 0xB9, 0xD9, 0x84,
		0xD9, 0x8A, 0xD9, 0x87, 0xD9, 0x88, 0xD8, 0xB3,
		0xD9, 0x84, 0xD9, 0x85, 0xD8, 0xB5, 0xD9, 0x84,
		0xD9, 0x89, 0xD8, 0xB5, 0xD9, 0x84, 0xD9, 0x89,
		0x20, 0xD8, 0xA7, 0xD9, 0x84, 0xD9, 0x84, 0xD9,
		0x87, 0x20, 0xD8, 0xB9, 0xD9, 0x84, 0xD9, 0x8A,
		0xD9, 0x87, 0x20, 0xD9, 0x88, 0xD8, 0xB3, 0xD9,
		0x84, 0xD9, 0x85, 0xD8, 0xAC, 0xD9, 0x84, 0x20,
		0xD8, 0xAC, 0xD9, 0x84, 0xD8, 0xA7, 0xD9, 0x84,
		0xD9, 0x87, 0xD8, 0xB1, 0xDB, 0x8C, 0xD8, 0xA7,
		0xD9, 0x84, 0x2E, 0x2E, 0xE2, 0x80, 0x94, 0xE2,
		0x80, 0x93, 0x5F, 0x5F, 0x28, 0x29, 0x7B, 0x7D,
		0xE3, 0x80, 0x94, 0xE3, 0x80, 0x95, 0xE3, 0x80,
		0x90, 0xE3, 0x80, 0x91, 0xE3, 0x80, 0x8A, 0xE3,
		0x80, 0x8B, 0xE3, 0x80, 0x88, 0xE3, 0x80, 0x89,
		0xE3, 0x80, 0x8C, 0xE3, 0x80, 0x8D, 0xE3, 0x80,
		0x8E, 0xE3, 0x80, 0x8F, 0x20, 0xCC, 0x85, 0x20,
		0xCC, 0x85, 0x20, 0xCC, 0x85, 0x20, 0xCC, 0x85,
		0x5F, 0x5F, 0x5F, 0x2C, 0xE3, 0x80, 0x81, 0x2E,
		0x3B, 0x3A, 0x3F, 0x21, 0xE2, 0x80, 0x94, 0x28,
		0x29, 0x7B, 0x7D, 0xE3, 0x80, 0x94, 0xE3, 0x80,
		0x95, 0x23, 0x26, 0x2A, 0x2B, 0x2D, 0x3C, 0x3E,
		0x3D, 0x5C, 0x24, 0x25, 0x40, 0x20, 0xD9, 0x8B,
		0xD9, 0x80, 0xD9, 0x8B, 0x20, 0xD9, 0x8C, 0x20,
		0xD9, 0x8D, 0x20, 0xD9, 0x8E, 0xD9, 0x80, 0xD9,
		0x8E, 0x20, 0xD9, 0x8F, 0xD9, 0x80, 0xD9, 0x8F,
		0x20, 0xD9, 0x90, 0xD9, 0x80, 0xD9, 0x90, 0x20,
		0xD9, 0x91, 0xD9, 0x80, 0xD9, 0x91, 0x20, 0xD9,
		0x92, 0xD9, 0x80, 0xD9, 0x92, 0xD8, 0xA1, 0xD8,
		0xA7, 0xD9, 0x93, 0xD8, 0xA7, 0xD9, 0x93, 0xD8,
		0xA7, 0xD9, 0x94, 0xD8, 0xA7, 0xD9, 0x94, 0xD9,
		0x88, 0xD9, 0x94, 0xD9, 0x88, 0xD9, 0x94, 0xD8,
		0xA7, 0xD9, 0x95, 0xD8, 0xA7, 0xD9, 0x95, 0xD9,
		0x8A, 0xD9, 0x94, 0xD9, 0x8A, 0xD9, 0x94, 0xD9,
		0x8A, 0xD9, 0x94, 0xD9, 0x8A, 0xD9, 0x94, 0xD8,
		0xA7, 0xD8, 0xA7, 0xD8, 0xA8, 0xD8, 0xA8, 0xD8,
		0xA8, 0xD8, 0xA8, 0xD8, 0xA9, 0xD8, 0xA9, 0xD8,
		0xAA, 0xD8, 0xAA, 0xD8, 0xAA, 0xD8, 0xAA, 0xD8,
		0xAB, 0xD8, 0xAB, 0xD8, 0xAB, 0xD8, 0xAB, 0xD8,
		0xAC, 0xD8, 0xAC, 0xD8, 0xAC, 0xD8, 0xAC, 0xD8,
		0xAD, 0xD8, 0xAD, 0xD8, 0xAD, 0xD8, 0xAD, 0xD8,
		0xAE, 0xD8, 0xAE, 0xD8, 0xAE, 0xD8, 0xAE, 0xD8,
		0xAF, 0xD8, 0xAF, 0xD8, 0xB0, 0xD8, 0xB0, 0xD8,
		0xB1, 0xD8, 0xB1, 0xD8, 0xB2, 0xD8, 0xB2, 0xD8,
		0xB3, 0xD8, 0xB3, 0xD8, 0xB3, 0xD8, 0xB3, 0xD8,
		0xB4, 0xD8, 0xB4, 0xD8, 0xB4, 0xD8, 0xB4, 0xD8,
		0xB5, 0xD8, 0xB5, 0xD8, 0xB5, 0xD8, 0xB5, 0xD8,
		0xB6, 0xD8, 0xB6, 0xD8, 0xB6, 0xD8, 0xB6, 0xD8,
		0xB7, 0xD8, 0xB7, 0xD8, 0xB7, 0xD8, 0xB7, 0xD8,
		0xB8, 0xD8, 0xB8, 0xD8, 0xB8, 0xD8, 0xB8, 0xD8,
		0xB9, 0xD8, 0xB9, 0xD8, 0xB9, 0xD8, 0xB9, 0xD8,
		0xBA, 0xD8, 0xBA, 0xD8, 0xBA, 0xD8, 0xBA, 0xD9,
		0x81, 0xD9, 0x81, 0xD9, 0x81, 0xD9, 0x81, 0xD9,
		0x82, 0xD9, 0x82, 0xD9, 0x82, 0xD9, 0x82, 0xD9,
		0x83, 0xD9, 0x83, 0xD9, 0x83, 0xD9, 0x83, 0xD9,
		0x84, 0xD9, 0x84, 0xD9, 0x84, 0xD9, 0x84, 0xD9,
		0x85, 0xD9, 0x85, 0xD9, 0x85, 0xD9, 0x85, 0xD9,
		0x86, 0xD9, 0x86, 0xD9, 0x86, 0xD9, 0x86, 0xD9,
		0x87, 0xD9, 0x87, 0xD9, 0x87, 0xD9, 0x87, 0xD9,
		0x88, 0xD9, 0x88, 0xD9, 0x89, 0xD9, 0x89, 0xD9,
		0x8A, 0xD9, 0x8A, 0xD9, 0x8A, 0xD9, 0x8A, 0xD9,
		0x84, 0xD8, 0xA7, 0xD9, 0x93, 0xD9, 0x84, 0xD8,
		0xA7, 0xD9, 0x93, 0xD9, 0x84, 0xD8, 0xA7, 0xD9,
		0x94, 0xD9, 0x84, 0xD8, 0xA7, 0xD9, 0x94, 0xD9,
		0x84, 0xD8, 0xA7, 0xD9, 0x95, 0xD9, 0x84, 0xD8,
		0xA7, 0xD9, 0x95, 0xD9, 0x84, 0xD8, 0xA7, 0xD9,
		0x84, 0xD8, 0xA7, 0x21, 0x22, 0x23, 0x24, 0x25,
		0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
		0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
		0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D,
		0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45,
		0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
		0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
		0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D,
		0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D,
		0x7E, 0xE2, 0xA6, 0x85, 0xE2, 0xA6, 0x86, 0xE3,
		0x80, 0x82, 0xE3, 0x80, 0x8C, 0xE3, 0x80, 0x8D,
		0xE3, 0x80, 0x81, 0xE3, 0x83, 0xBB, 0xE3, 0x83,
		0xB2, 0xE3, 0x82, 0xA1, 0xE3, 0x82, 0xA3, 0xE3,
		0x82, 0xA5, 0xE3, 0x82, 0xA7, 0xE3, 0x82, 0xA9,
		0xE3, 0x83, 0xA3, 0xE3, 0x83, 0xA5, 0xE3, 0x83,
		0xA7, 0xE3, 0x83, 0x83, 0xE3, 0x83, 0xBC, 0xE3,
		0x82, 0xA2, 0xE3, 0x82, 0xA4, 0xE3, 0x82, 0xA6,
		0xE3, 0x82, 0xA8, 0xE3, 0x82, 0xAA, 0xE3, 0x82,
		0xAB, 0xE3, 0x82, 0xAD, 0xE3, 0x82, 0xAF, 0xE3,
		0x82, 0xB1, 0xE3, 0x82, 0xB3, 0xE3, 0x82, 0xB5,
		0xE3, 0x82, 0xB7, 0xE3, 0x82, 0xB9, 0xE3, 0x82,
		0xBB, 0xE3, 0x82, 0xBD, 0xE3, 0x82, 0xBF, 0xE3,
		0x83, 0x81, 0xE3, 0x83, 0x84, 0xE3, 0x83, 0x86,
		0xE3, 0x83, 0x88, 0xE3, 0x83, 0x8A, 0xE3, 0x83,
		0x8B, 0xE3, 0x83, 0x8C, 0xE3, 0x83, 0x8D, 0xE3,
		0x83, 0x8E, 0xE3, 0x83, 0x8F, 0xE3, 0x83, 0x92,
		0xE3, 0x83, 0x95, 0xE3, 0x83, 0x98, 0xE3, 0x83,
		0x9B, 0xE3, 0x83, 0x9E, 0xE3, 0x83, 0x9F, 0xE3,
		0x83, 0xA0, 0xE3, 0x83, 0xA1, 0xE3, 0x83, 0xA2,
		0xE3, 0x83, 0xA4, 0xE3, 0x83, 0xA6, 0xE3, 0x83,
		0xA8, 0xE3, 0x83, 0xA9, 0xE3, 0x83, 0xAA, 0xE3,
		0x83, 0xAB, 0xE3, 0x83, 0xAC, 0xE3, 0x83, 0xAD,
		0xE3, 0x83, 0xAF, 0xE3, 0x83, 0xB3, 0xE3, 0x82,
		0x99, 0xE3, 0x82, 0x9A, 0xE1, 0x85, 0xA0, 0xE1,
		0x84, 0x80, 0xE1, 0x84, 0x81, 0xE1, 0x86, 0xAA,
		0xE1, 0x84, 0x82, 0xE1, 0x86, 0xAC, 0xE1, 0x86,
		0xAD, 0xE1, 0x84, 0x83, 0xE1, 0x84, 0x84, 0xE1,
		0x84, 0x85, 0xE1, 0x86, 0xB0, 0xE1, 0x86, 0xB1,
		0xE1, 0x86, 0xB2, 0xE1, 0x86, 0xB3, 0xE1, 0x86,
		0xB4, 0xE1, 0x86, 0xB5, 0xE1, 0x84, 0x9A, 0xE1,
		0x84, 0x86, 0xE1, 0x84, 0x87, 0xE1, 0x84, 0x88,
		0xE1, 0x84, 0xA1, 0xE1, 0x84, 0x89, 0xE1, 0x84,
		0x8A, 0xE1, 0x84, 0x8B, 0xE1, 0x84, 0x8C, 0xE1,
		0x84, 0x8D, 0xE1, 0x84, 0x8E, 0xE1, 0x84, 0x8F,
		0xE1, 0x84, 0x90, 0xE1, 0x84, 0x91, 0xE1, 0x84,
		0x92, 0xE1, 0x85, 0xA1, 0xE1, 0x85, 0xA2, 0xE1,
		0x85, 0xA3, 0xE1, 0x85, 0xA4, 0xE1, 0x85, 0xA5,
		0xE1, 0x85, 0xA6, 0xE1, 0x85, 0xA7, 0xE1, 0x85,
		0xA8, 0xE1, 0x85, 0xA9, 0xE1, 0x85, 0xAA, 0xE1,
		0x85, 0xAB, 0xE1, 0x85, 0xAC, 0xE1, 0x85, 0xAD,
		0xE1, 0x85, 0xAE, 0xE1, 0x85, 0xAF, 0xE1, 0x85,
		0xB0, 0xE1, 0x85, 0xB1, 0xE1, 0x85, 0xB2, 0xE1,
		0x85, 0xB3, 0xE1, 0x85, 0xB4, 0xE1, 0x85, 0xB5,
		0xC2, 0xA2, 0xC2, 0xA3, 0xC2, 0xAC, 0x20, 0xCC,
		0x84, 0xC2, 0xA6, 0xC2, 0xA5, 0xE2, 0x82, 0xA9,
		0xE2, 0x94, 0x82, 0xE2, 0x86, 0x90, 0xE2, 0x86,
		0x91, 0xE2, 0x86, 0x92, 0xE2, 0x86, 0x93, 0xE2,
		0x96, 0xA0, 0xE2, 0x97, 0x8B, 0xF6, 0xF0, 0x9D,
		0x85, 0x97, 0xF0, 0x9D, 0x85, 0xA5, 0xF6, 0xF0,
		0x9D, 0x85, 0x98, 0xF0, 0x9D, 0x85, 0xA5, 0xF6,
		0xF0, 0x9D, 0x85, 0x98, 0xF0, 0x9D, 0x85, 0xA5,
		0xF0, 0x9D, 0x85, 0xAE, 0xF6, 0xF0, 0x9D, 0x85,
		0x98, 0xF0, 0x9D, 0x85, 0xA5, 0xF0, 0x9D, 0x85,
		0xAF, 0xF6, 0xF0, 0x9D, 0x85, 0x98, 0xF0, 0x9D,
		0x85, 0xA5, 0xF0, 0x9D, 0x85, 0xB0, 0xF6, 0xF0,
		0x9D, 0x85, 0x98, 0xF0, 0x9D, 0x85, 0xA5, 0xF0,
		0x9D, 0x85, 0xB1, 0xF6, 0xF0, 0x9D, 0x85, 0x98,
		0xF0, 0x9D, 0x85, 0xA5, 0xF0, 0x9D, 0x85, 0xB2,
		0xF6, 0xF0, 0x9D, 0x86, 0xB9, 0xF0, 0x9D, 0x85,
		0xA5, 0xF6, 0xF0, 0x9D, 0x86, 0xBA, 0xF0, 0x9D,
		0x85, 0xA5, 0xF6, 0xF0, 0x9D, 0x86, 0xB9, 0xF0,
		0x9D, 0x85, 0xA5, 0xF0, 0x9D, 0x85, 0xAE, 0xF6,
		0xF0, 0x9D, 0x86, 0xBA, 0xF0, 0x9D, 0x85, 0xA5,
		0xF0, 0x9D, 0x85, 0xAE, 0xF6, 0xF0, 0x9D, 0x86,
		0xB9, 0xF0, 0x9D, 0x85, 0xA5, 0xF0, 0x9D, 0x85,
		0xAF, 0xF6, 0xF0, 0x9D, 0x86, 0xBA, 0xF0, 0x9D,
		0x85, 0xA5, 0xF0, 0x9D, 0x85, 0xAF, 0x41, 0x42,
		0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A,
		0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,
		0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A,
		0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
		0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
		0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
		0x79, 0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
		0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E,
		0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
		0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64,
		0x65, 0x66, 0x67, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x43,
		0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B,
		0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53,
		0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61,
		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x41, 0x43, 0x44, 0x47, 0x4A, 0x4B, 0x4E,
		0x4F, 0x50, 0x51, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x66,
		0x68, 0x69, 0x6A, 0x6B, 0x6D, 0x6E, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x44,
		0x45, 0x46, 0x47, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E,
		0x4F, 0x50, 0x51, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
		0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
		0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
		0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x44, 0x45,
		0x46, 0x47, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4F,
		0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x61,
		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x43,
		0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B,
		0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53,
		0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61,
		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x43,
		0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B,
		0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53,
		0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61,
		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x43,
		0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B,
		0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53,
		0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61,
		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0xCE, 0x91, 0xCE, 0x92, 0xCE, 0x93, 0xCE,
		0x94, 0xCE, 0x95, 0xCE, 0x96, 0xCE, 0x97, 0xCE,
		0x98, 0xCE, 0x99, 0xCE, 0x9A, 0xCE, 0x9B, 0xCE,
		0x9C, 0xCE, 0x9D, 0xCE, 0x9E, 0xCE, 0x9F, 0xCE,
		0xA0, 0xCE, 0xA1, 0xCE, 0x98, 0xCE, 0xA3, 0xCE,
		0xA4, 0xCE, 0xA5, 0xCE, 0xA6, 0xCE, 0xA7, 0xCE,
		0xA8, 0xCE, 0xA9, 0xE2, 0x88, 0x87, 0xCE, 0xB1,
		0xCE, 0xB2, 0xCE, 0xB3, 0xCE, 0xB4, 0xCE, 0xB5,
		0xCE, 0xB6, 0xCE, 0xB7, 0xCE, 0xB8, 0xCE, 0xB9,
		0xCE, 0xBA, 0xCE, 0xBB, 0xCE, 0xBC, 0xCE, 0xBD,
		0xCE, 0xBE, 0xCE, 0xBF, 0xCF, 0x80, 0xCF, 0x81,
		0xCF, 0x82, 0xCF, 0x83, 0xCF, 0x84, 0xCF, 0x85,
		0xCF, 0x86, 0xCF, 0x87, 0xCF, 0x88, 0xCF, 0x89,
		0xE2, 0x88, 0x82, 0xCE, 0xB5, 0xCE, 0xB8, 0xCE,
		0xBA, 0xCF, 0x86, 0xCF, 0x81, 0xCF, 0x80, 0xCE,
		0x91, 0xCE, 0x92, 0xCE, 0x93, 0xCE, 0x94, 0xCE,
		0x95, 0xCE, 0x96, 0xCE, 0x97, 0xCE, 0x98, 0xCE,
		0x99, 0xCE, 0x9A, 0xCE, 0x9B, 0xCE, 0x9C, 0xCE,
		0x9D, 0xCE, 0x9E, 0xCE, 0x9F, 0xCE, 0xA0, 0xCE,
		0xA1, 0xCE, 0x98, 0xCE, 0xA3, 0xCE, 0xA4, 0xCE,
		0xA5, 0xCE, 0xA6, 0xCE, 0xA7, 0xCE, 0xA8, 0xCE,
		0xA9, 0xE2, 0x88, 0x87, 0xCE, 0xB1, 0xCE, 0xB2,
		0xCE, 0xB3, 0xCE, 0xB4, 0xCE, 0xB5, 0xCE, 0xB6,
		0xCE, 0xB7, 0xCE, 0xB8, 0xCE, 0xB9, 0xCE, 0xBA,
		0xCE, 0xBB, 0xCE, 0xBC, 0xCE, 0xBD, 0xCE, 0xBE,
		0xCE, 0xBF, 0xCF, 0x80, 0xCF, 0x81, 0xCF, 0x82,
		0xCF, 0x83, 0xCF, 0x84, 0xCF, 0x85, 0xCF, 0x86,
		0xCF, 0x87, 0xCF, 0x88, 0xCF, 0x89, 0xE2, 0x88,
		0x82, 0xCE, 0xB5, 0xCE, 0xB8, 0xCE, 0xBA, 0xCF,
		0x86, 0xCF, 0x81, 0xCF, 0x80, 0xCE, 0x91, 0xCE,
		0x92, 0xCE, 0x93, 0xCE, 0x94, 0xCE, 0x95, 0xCE,
		0x96, 0xCE, 0x97, 0xCE, 0x98, 0xCE, 0x99, 0xCE,
		0x9A, 0xCE, 0x9B, 0xCE, 0x9C, 0xCE, 0x9D, 0xCE,
		0x9E, 0xCE, 0x9F, 0xCE, 0xA0, 0xCE, 0xA1, 0xCE,
		0x98, 0xCE, 0xA3, 0xCE, 0xA4, 0xCE, 0xA5, 0xCE,
		0xA6, 0xCE, 0xA7, 0xCE, 0xA8, 0xCE, 0xA9, 0xE2,
		0x88, 0x87, 0xCE, 0xB1, 0xCE, 0xB2, 0xCE, 0xB3,
		0xCE, 0xB4, 0xCE, 0xB5, 0xCE, 0xB6, 0xCE, 0xB7,
		0xCE, 0xB8, 0xCE, 0xB9, 0xCE, 0xBA, 0xCE, 0xBB,
		0xCE, 0xBC, 0xCE, 0xBD, 0xCE, 0xBE, 0xCE, 0xBF,
		0xCF, 0x80, 0xCF, 0x81, 0xCF, 0x82, 0xCF, 0x83,
		0xCF, 0x84, 0xCF, 0x85, 0xCF, 0x86, 0xCF, 0x87,
		0xCF, 0x88, 0xCF, 0x89, 0xE2, 0x88, 0x82, 0xCE,
		0xB5, 0xCE, 0xB8, 0xCE, 0xBA, 0xCF, 0x86, 0xCF,
		0x81, 0xCF, 0x80, 0xCE, 0x91, 0xCE, 0x92, 0xCE,
		0x93, 0xCE, 0x94, 0xCE, 0x95, 0xCE, 0x96, 0xCE,
		0x97, 0xCE, 0x98, 0xCE, 0x99, 0xCE, 0x9A, 0xCE,
		0x9B, 0xCE, 0x9C, 0xCE, 0x9D, 0xCE, 0x9E, 0xCE,
		0x9F, 0xCE, 0xA0, 0xCE, 0xA1, 0xCE, 0x98, 0xCE,
		0xA3, 0xCE, 0xA4, 0xCE, 0xA5, 0xCE, 0xA6, 0xCE,
		0xA7, 0xCE, 0xA8, 0xCE, 0xA9, 0xE2, 0x88, 0x87,
		0xCE, 0xB1, 0xCE, 0xB2, 0xCE, 0xB3, 0xCE, 0xB4,
		0xCE, 0xB5, 0xCE, 0xB6, 0xCE, 0xB7, 0xCE, 0xB8,
		0xCE, 0xB9, 0xCE, 0xBA, 0xCE, 0xBB, 0xCE, 0xBC,
		0xCE, 0xBD, 0xCE, 0xBE, 0xCE, 0xBF, 0xCF, 0x80,
		0xCF, 0x81, 0xCF, 0x82, 0xCF, 0x83, 0xCF, 0x84,
		0xCF, 0x85, 0xCF, 0x86, 0xCF, 0x87, 0xCF, 0x88,
		0xCF, 0x89, 0xE2, 0x88, 0x82, 0xCE, 0xB5, 0xCE,
		0xB8, 0xCE, 0xBA, 0xCF, 0x86, 0xCF, 0x81, 0xCF,
		0x80, 0xCE, 0x91, 0xCE, 0x92, 0xCE, 0x93, 0xCE,
		0x94, 0xCE, 0x95, 0xCE, 0x96, 0xCE, 0x97, 0xCE,
		0x98, 0xCE, 0x99, 0xCE, 0x9A, 0xCE, 0x9B, 0xCE,
		0x9C, 0xCE, 0x9D, 0xCE, 0x9E, 0xCE, 0x9F, 0xCE,
		0xA0, 0xCE, 0xA1, 0xCE, 0x98, 0xCE, 0xA3, 0xCE,
		0xA4, 0xCE, 0xA5, 0xCE, 0xA6, 0xCE, 0xA7, 0xCE,
		0xA8, 0xCE, 0xA9, 0xE2, 0x88, 0x87, 0xCE, 0xB1,
		0xCE, 0xB2, 0xCE, 0xB3, 0xCE, 0xB4, 0xCE, 0xB5,
		0xCE, 0xB6, 0xCE, 0xB7, 0xCE, 0xB8, 0xCE, 0xB9,
		0xCE, 0xBA, 0xCE, 0xBB, 0xCE, 0xBC, 0xCE, 0xBD,
		0xCE, 0xBE, 0xCE, 0xBF, 0xCF, 0x80, 0xCF, 0x81,
		0xCF, 0x82, 0xCF, 0x83, 0xCF, 0x84, 0xCF, 0x85,
		0xCF, 0x86, 0xCF, 0x87, 0xCF, 0x88, 0xCF, 0x89,
		0xE2, 0x88, 0x82, 0xCE, 0xB5, 0xCE, 0xB8, 0xCE,
		0xBA, 0xCF, 0x86, 0xCF, 0x81, 0xCF, 0x80, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
		0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34,
		0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32,
		0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
		0x39, 0xF6, 0xE4, 0xB8, 0xBD, 0xF6, 0xE4, 0xB8,
		0xB8, 0xF6, 0xE4, 0xB9, 0x81, 0xF6, 0xF0, 0xA0,
		0x84, 0xA2, 0xF6, 0xE4, 0xBD, 0xA0, 0xF6, 0xE4,
		0xBE, 0xAE, 0xF6, 0xE4, 0xBE, 0xBB, 0xF6, 0xE5,
		0x80, 0x82, 0xF6, 0xE5, 0x81, 0xBA, 0xF6, 0xE5,
		0x82, 0x99, 0xF6, 0xE5, 0x83, 0xA7, 0xF6, 0xE5,
		0x83, 0x8F, 0xF6, 0xE3, 0x92, 0x9E, 0xF6, 0xF0,
		0xA0, 0x98, 0xBA, 0xF6, 0xE5, 0x85, 0x8D, 0xF6,
		0xE5, 0x85, 0x94, 0xF6, 0xE5, 0x85, 0xA4, 0xF6,
		0xE5, 0x85, 0xB7, 0xF6, 0xF0, 0xA0, 0x94, 0x9C,
		0xF6, 0xE3, 0x92, 0xB9, 0xF6, 0xE5, 0x85, 0xA7,
		0xF6, 0xE5, 0x86, 0x8D, 0xF6, 0xF0, 0xA0, 0x95,
		0x8B, 0xF6, 0xE5, 0x86, 0x97, 0xF6, 0xE5, 0x86,
		0xA4, 0xF6, 0xE4, 0xBB, 0x8C, 0xF6, 0xE5, 0x86,
		0xAC, 0xF6, 0xE5, 0x86, 0xB5, 0xF6, 0xF0, 0xA9,
		0x87, 0x9F, 0xF6, 0xE5, 0x87, 0xB5, 0xF6, 0xE5,
		0x88, 0x83, 0xF6, 0xE3, 0x93, 0x9F, 0xF6, 0xE5,
		0x88, 0xBB, 0xF6, 0xE5, 0x89, 0x86, 0xF6, 0xE5,
		0x89, 0xB2, 0xF6, 0xE5, 0x89, 0xB7, 0xF6, 0xE3,
		0x94, 0x95, 0xF6, 0xE5, 0x8B, 0x87, 0xF6, 0xE5,
		0x8B, 0x89, 0xF6, 0xE5, 0x8B, 0xA4, 0xF6, 0xE5,
		0x8B, 0xBA, 0xF6, 0xE5, 0x8C, 0x85, 0xF6, 0xE5,
		0x8C, 0x86, 0xF6, 0xE5, 0x8C, 0x97, 0xF6, 0xE5,
		0x8D, 0x89, 0xF6, 0xE5, 0x8D, 0x91, 0xF6, 0xE5,
		0x8D, 0x9A, 0xF6, 0xE5, 0x8D, 0xB3, 0xF6, 0xE5,
		0x8D, 0xBD, 0xF6, 0xE5, 0x8D, 0xBF, 0xF6, 0xE5,
		0x8D, 0xBF, 0xF6, 0xE5, 0x8D, 0xBF, 0xF6, 0xF0,
		0xA0, 0xA8, 0xAC, 0xF6, 0xE7, 0x81, 0xB0, 0xF6,
		0xE5, 0x8F, 0x8A, 0xF6, 0xE5, 0x8F, 0x9F, 0xF6,
		0xF0, 0xA0, 0xAD, 0xA3, 0xF6, 0xE5, 0x8F, 0xAB,
		0xF6, 0xE5, 0x8F, 0xB1, 0xF6, 0xE5, 0x90, 0x86,
		0xF6, 0xE5, 0x92, 0x9E, 0xF6, 0xE5, 0x90, 0xB8,
		0xF6, 0xE5, 0x91, 0x88, 0xF6, 0xE5, 0x91, 0xA8,
		0xF6, 0xE5, 0x92, 0xA2, 0xF6, 0xE5, 0x93, 0xB6,
		0xF6, 0xE5, 0x94, 0x90, 0xF6, 0xE5, 0x95, 0x93,
		0xF6, 0xE5, 0x95, 0xA3, 0xF6, 0xE5, 0x96, 0x84,
		0xF6, 0xE5, 0x96, 0x84, 0xF6, 0xE5, 0x96, 0x99,
		0xF6, 0xE5, 0x96, 0xAB, 0xF6, 0xE5, 0x96, 0xB3,
		0xF6, 0xE5, 0x97, 0x82, 0xF6, 0xE5, 0x9C, 0x96,
		0xF6, 0xE5, 0x98, 0x86, 0xF6, 0xE5, 0x9C, 0x97,
		0xF6, 0xE5, 0x99, 0x91, 0xF6, 0xE5, 0x99, 0xB4,
		0xF6, 0xE5, 0x88, 0x87, 0xF6, 0xE5, 0xA3, 0xAE,
		0xF6, 0xE5, 0x9F, 0x8E, 0xF6, 0xE5, 0x9F, 0xB4,
		0xF6, 0xE5, 0xA0, 0x8D, 0xF6, 0xE5, 0x9E, 0x8B,
		0xF6, 0xE5, 0xA0, 0xB2, 0xF6, 0xE5, 0xA0, 0xB1,
		0xF6, 0xE5, 0xA2, 0xAC, 0xF6, 0xF0, 0xA1, 0x93,
		0xA4, 0xF6, 0xE5, 0xA3, 0xB2, 0xF6, 0xE5, 0xA3,
		0xB7, 0xF6, 0xE5, 0xA4, 0x86, 0xF6, 0xE5, 0xA4,
		0x9A, 0xF6, 0xE5, 0xA4, 0xA2, 0xF6, 0xE5, 0xA5,
		0xA2, 0xF6, 0xF0, 0xA1, 0x9A, 0xA8, 0xF6, 0xF0,
		0xA1, 0x9B, 0xAA, 0xF6, 0xE5, 0xA7, 0xAC, 0xF6,
		0xE5, 0xA8, 0x9B, 0xF6, 0xE5, 0xA8, 0xA7, 0xF6,
		0xE5, 0xA7, 0x98, 0xF6, 0xE5, 0xA9, 0xA6, 0xF6,
		0xE3, 0x9B, 0xAE, 0xF6, 0xE3, 0x9B, 0xBC, 0xF6,
		0xE5, 0xAC, 0x88, 0xF6, 0xE5, 0xAC, 0xBE, 0xF6,
		0xE5, 0xAC, 0xBE, 0xF6, 0xF0, 0xA1, 0xA7, 0x88,
		0xF6, 0xE5, 0xAF, 0x83, 0xF6, 0xE5, 0xAF, 0x98,
		0xF6, 0xE5, 0xAF, 0xA7, 0xF6, 0xE5, 0xAF, 0xB3,
		0xF6, 0xF0, 0xA1, 0xAC, 0x98, 0xF6, 0xE5, 0xAF,
		0xBF, 0xF6, 0xE5, 0xB0, 0x86, 0xF6, 0xE5, 0xBD,
		0x93, 0xF6, 0xE5, 0xB0, 0xA2, 0xF6, 0xE3, 0x9E,
		0x81, 0xF6, 0xE5, 0xB1, 0xA0, 0xF6, 0xE5, 0xB1,
		0xAE, 0xF6, 0xE5, 0xB3, 0x80, 0xF6, 0xE5, 0xB2,
		0x8D, 0xF6, 0xF0, 0xA1, 0xB7, 0xA4, 0xF6, 0xE5,
		0xB5, 0x83, 0xF6, 0xF0, 0xA1, 0xB7, 0xA6, 0xF6,
		0xE5, 0xB5, 0xAE, 0xF6, 0xE5, 0xB5, 0xAB, 0xF6,
		0xE5, 0xB5, 0xBC, 0xF6, 0xE5, 0xB7, 0xA1, 0xF6,
		0xE5, 0xB7, 0xA2, 0xF6, 0xE3, 0xA0, 0xAF, 0xF6,
		0xE5, 0xB7, 0xBD, 0xF6, 0xE5, 0xB8, 0xA8, 0xF6,
		0xE5, 0xB8, 0xBD, 0xF6, 0xE5, 0xB9, 0xA9, 0xF6,
		0xE3, 0xA1, 0xA2, 0xF6, 0xF0, 0xA2, 0x86, 0x83,
		0xF6, 0xE3, 0xA1, 0xBC, 0xF6, 0xE5, 0xBA, 0xB0,
		0xF6, 0xE5, 0xBA, 0xB3, 0xF6, 0xE5, 0xBA, 0xB6,
		0xF6, 0xE5, 0xBB, 0x8A, 0xF6, 0xF0, 0xAA, 0x8E,
		0x92, 0xF6, 0xE5, 0xBB, 0xBE, 0xF6, 0xF0, 0xA2,
		0x8C, 0xB1, 0xF6, 0xF0, 0xA2, 0x8C, 0xB1, 0xF6,
		0xE8, 0x88, 0x81, 0xF6, 0xE5, 0xBC, 0xA2, 0xF6,
		0xE5, 0xBC, 0xA2, 0xF6, 0xE3, 0xA3, 0x87, 0xF6,
		0xF0, 0xA3, 0x8A, 0xB8, 0xF6, 0xF0, 0xA6, 0x87,
		0x9A, 0xF6, 0xE5, 0xBD, 0xA2, 0xF6, 0xE5, 0xBD,
		0xAB, 0xF6, 0xE3, 0xA3, 0xA3, 0xF6, 0xE5, 0xBE,
		0x9A, 0xF6, 0xE5, 0xBF, 0x8D, 0xF6, 0xE5, 0xBF,
		0x97, 0xF6, 0xE5, 0xBF, 0xB9, 0xF6, 0xE6, 0x82,
		0x81, 0xF6, 0xE3, 0xA4, 0xBA, 0xF6, 0xE3, 0xA4,
		0x9C, 0xF6, 0xE6, 0x82, 0x94, 0xF6, 0xF0, 0xA2,
		0x9B, 0x94, 0xF6, 0xE6, 0x83, 0x87, 0xF6, 0xE6,
		0x85, 0x88, 0xF6, 0xE6, 0x85, 0x8C, 0xF6, 0xE6,
		0x85, 0x8E, 0xF6, 0xE6, 0x85, 0x8C, 0xF6, 0xE6,
		0x85, 0xBA, 0xF6, 0xE6, 0x86, 0x8E, 0xF6, 0xE6,
		0x86, 0xB2, 0xF6, 0xE6, 0x86, 0xA4, 0xF6, 0xE6,
		0x86, 0xAF, 0xF6, 0xE6, 0x87, 0x9E, 0xF6, 0xE6,
		0x87, 0xB2, 0xF6, 0xE6, 0x87, 0xB6, 0xF6, 0xE6,
		0x88, 0x90, 0xF6, 0xE6, 0x88, 0x9B, 0xF6, 0xE6,
		0x89, 0x9D, 0xF6, 0xE6, 0x8A, 0xB1, 0xF6, 0xE6,
		0x8B, 0x94, 0xF6, 0xE6, 0x8D, 0x90, 0xF6, 0xF0,
		0xA2, 0xAC, 0x8C, 0xF6, 0xE6, 0x8C, 0xBD, 0xF6,
		0xE6, 0x8B, 0xBC, 0xF6, 0xE6, 0x8D, 0xA8, 0xF6,
		0xE6, 0x8E, 0x83, 0xF6, 0xE6, 0x8F, 0xA4, 0xF6,
		0xF0, 0xA2, 0xAF, 0xB1, 0xF6, 0xE6, 0x90, 0xA2,
		0xF6, 0xE6, 0x8F, 0x85, 0xF6, 0xE6, 0x8E, 0xA9,
		0xF6, 0xE3, 0xA8, 0xAE, 0xF6, 0xE6, 0x91, 0xA9,
		0xF6, 0xE6, 0x91, 0xBE, 0xF6, 0xE6, 0x92, 0x9D,
		0xF6, 0xE6, 0x91, 0xB7, 0xF6, 0xE3, 0xA9, 0xAC,
		0xF6, 0xE6, 0x95, 0x8F, 0xF6, 0xE6, 0x95, 0xAC,
		0xF6, 0xF0, 0xA3, 0x80, 0x8A, 0xF6, 0xE6, 0x97,
		0xA3, 0xF6, 0xE6, 0x9B, 0xB8, 0xF6, 0xE6, 0x99,
		0x89, 0xF6, 0xE3, 0xAC, 0x99, 0xF6, 0xE6, 0x9A,
		0x91, 0xF6, 0xE3, 0xAC, 0x88, 0xF6, 0xE3, 0xAB,
		0xA4, 0xF6, 0xE5, 0x86, 0x92, 0xF6, 0xE5, 0x86,
		0x95, 0xF6, 0xE6, 0x9C, 0x80, 0xF6, 0xE6, 0x9A,
		0x9C, 0xF6, 0xE8, 0x82, 0xAD, 0xF6, 0xE4, 0x8F,
		0x99, 0xF6, 0xE6, 0x9C, 0x97, 0xF6, 0xE6, 0x9C,
		0x9B, 0xF6, 0xE6, 0x9C, 0xA1, 0xF6, 0xE6, 0x9D,
		0x9E, 0xF6, 0xE6, 0x9D, 0x93, 0xF6, 0xF0, 0xA3,
		0x8F, 0x83, 0xF6, 0xE3, 0xAD, 0x89, 0xF6, 0xE6,
		0x9F, 0xBA, 0xF6, 0xE6, 0x9E, 0x85, 0xF6, 0xE6,
		0xA1, 0x92, 0xF6, 0xE6, 0xA2, 0x85, 0xF6, 0xF0,
		0xA3, 0x91, 0xAD, 0xF6, 0xE6, 0xA2, 0x8E, 0xF6,
		0xE6, 0xA0, 0x9F, 0xF6, 0xE6, 0xA4, 0x94, 0xF6,
		0xE3, 0xAE, 0x9D, 0xF6, 0xE6, 0xA5, 0x82, 0xF6,
		0xE6, 0xA6, 0xA3, 0xF6, 0xE6, 0xA7, 0xAA, 0xF6,
		0xE6, 0xAA, 0xA8, 0xF6, 0xF0, 0xA3, 0x9A, 0xA3,
		0xF6, 0xE6, 0xAB, 0x9B, 0xF6, 0xE3, 0xB0, 0x98,
		0xF6, 0xE6, 0xAC, 0xA1, 0xF6, 0xF0, 0xA3, 0xA2,
		0xA7, 0xF6, 0xE6, 0xAD, 0x94, 0xF6, 0xE3, 0xB1,
		0x8E, 0xF6, 0xE6, 0xAD, 0xB2, 0xF6, 0xE6, 0xAE,
		0x9F, 0xF6, 0xE6, 0xAE, 0xBA, 0xF6, 0xE6, 0xAE,
		0xBB, 0xF6, 0xF0, 0xA3, 0xAA, 0x8D, 0xF6, 0xF0,
		0xA1, 0xB4, 0x8B, 0xF6, 0xF0, 0xA3, 0xAB, 0xBA,
		0xF6, 0xE6, 0xB1, 0x8E, 0xF6, 0xF0, 0xA3, 0xB2,
		0xBC, 0xF6, 0xE6, 0xB2, 0xBF, 0xF6, 0xE6, 0xB3,
		0x8D, 0xF6, 0xE6, 0xB1, 0xA7, 0xF6, 0xE6, 0xB4,
		0x96, 0xF6, 0xE6, 0xB4, 0xBE, 0xF6, 0xE6, 0xB5,
		0xB7, 0xF6, 0xE6, 0xB5, 0x81, 0xF6, 0xE6, 0xB5,
		0xA9, 0xF6, 0xE6, 0xB5, 0xB8, 0xF6, 0xE6, 0xB6,
		0x85, 0xF6, 0xF0, 0xA3, 0xB4, 0x9E, 0xF6, 0xE6,
		0xB4, 0xB4, 0xF6, 0xE6, 0xB8, 0xAF, 0xF6, 0xE6,
		0xB9, 0xAE, 0xF6, 0xE3, 0xB4, 0xB3, 0xF6, 0xE6,
		0xBB, 0x8B, 0xF6, 0xE6, 0xBB, 0x87, 0xF6, 0xF0,
		0xA3, 0xBB, 0x91, 0xF6, 0xE6, 0xB7, 0xB9, 0xF6,
		0xE6, 0xBD, 0xAE, 0xF6, 0xF0, 0xA3, 0xBD, 0x9E,
		0xF6, 0xF0, 0xA3, 0xBE, 0x8E, 0xF6, 0xE6, 0xBF,
		0x86, 0xF6, 0xE7, 0x80, 0xB9, 0xF6, 0xE7, 0x80,
		0x9E, 0xF6, 0xE7, 0x80, 0x9B, 0xF6, 0xE3, 0xB6,
		0x96, 0xF6, 0xE7, 0x81, 0x8A, 0xF6, 0xE7, 0x81,
		0xBD, 0xF6, 0xE7, 0x81, 0xB7, 0xF6, 0xE7, 0x82,
		0xAD, 0xF6, 0xF0, 0xA0, 0x94, 0xA5, 0xF6, 0xE7,
		0x85, 0x85, 0xF6, 0xF0, 0xA4, 0x89, 0xA3, 0xF6,
		0xE7, 0x86, 0x9C, 0xF6, 0xF0, 0xA4, 0x8E, 0xAB,
		0xF6, 0xE7, 0x88, 0xA8, 0xF6, 0xE7, 0x88, 0xB5,
		0xF6, 0xE7, 0x89, 0x90, 0xF6, 0xF0, 0xA4, 0x98,
		0x88, 0xF6, 0xE7, 0x8A, 0x80, 0xF6, 0xE7, 0x8A,
		0x95, 0xF6, 0xF0, 0xA4, 0x9C, 0xB5, 0xF6, 0xF0,
		0xA4, 0xA0, 0x94, 0xF6, 0xE7, 0x8D, 0xBA, 0xF6,
		0xE7, 0x8E, 0x8B, 0xF6, 0xE3, 0xBA, 0xAC, 0xF6,
		0xE7, 0x8E, 0xA5, 0xF6, 0xE3, 0xBA, 0xB8, 0xF6,
		0xE3, 0xBA, 0xB8, 0xF6, 0xE7, 0x91, 0x87, 0xF6,
		0xE7, 0x91, 0x9C, 0xF6, 0xE7, 0x91, 0xB1, 0xF6,
		0xE7, 0x92, 0x85, 0xF6, 0xE7, 0x93, 0x8A, 0xF6,
		0xE3, 0xBC, 0x9B, 0xF6, 0xE7, 0x94, 0xA4, 0xF6,
		0xF0, 0xA4, 0xB0, 0xB6, 0xF6, 0xE7, 0x94, 0xBE,
		0xF6, 0xF0, 0xA4, 0xB2, 0x92, 0xF6, 0xE7, 0x95,
		0xB0, 0xF6, 0xF0, 0xA2, 0x86, 0x9F, 0xF6, 0xE7,
		0x98, 0x90, 0xF6, 0xF0, 0xA4, 0xBE, 0xA1, 0xF6,
		0xF0, 0xA4, 0xBE, 0xB8, 0xF6, 0xF0, 0xA5, 0x81,
		0x84, 0xF6, 0xE3, 0xBF, 0xBC, 0xF6, 0xE4, 0x80,
		0x88, 0xF6, 0xE7, 0x9B, 0xB4, 0xF6, 0xF0, 0xA5,
		0x83, 0xB3, 0xF6, 0xF0, 0xA5, 0x83, 0xB2, 0xF6,
		0xF0, 0xA5, 0x84, 0x99, 0xF6, 0xF0, 0xA5, 0x84,
		0xB3, 0xF6, 0xE7, 0x9C, 0x9E, 0xF6, 0xE7, 0x9C,
		0x9F, 0xF6, 0xE7, 0x9C, 0x9F, 0xF6, 0xE7, 0x9D,
		0x8A, 0xF6, 0xE4, 0x80, 0xB9, 0xF6, 0xE7, 0x9E,
		0x8B, 0xF6, 0xE4, 0x81, 0x86, 0xF6, 0xE4, 0x82,
		0x96, 0xF6, 0xF0, 0xA5, 0x90, 0x9D, 0xF6, 0xE7,
		0xA1, 0x8E, 0xF6, 0xE7, 0xA2, 0x8C, 0xF6, 0xE7,
		0xA3, 0x8C, 0xF6, 0xE4, 0x83, 0xA3, 0xF6, 0xF0,
		0xA5, 0x98, 0xA6, 0xF6, 0xE7, 0xA5, 0x96, 0xF6,
		0xF0, 0xA5, 0x9A, 0x9A, 0xF6, 0xF0, 0xA5, 0x9B,
		0x85, 0xF6, 0xE7, 0xA6, 0x8F, 0xF6, 0xE7, 0xA7,
		0xAB, 0xF6, 0xE4, 0x84, 0xAF, 0xF6, 0xE7, 0xA9,
		0x80, 0xF6, 0xE7, 0xA9, 0x8A, 0xF6, 0xE7, 0xA9,
		0x8F, 0xF6, 0xF0, 0xA5, 0xA5, 0xBC, 0xF6, 0xF0,
		0xA5, 0xAA, 0xA7, 0xF6, 0xF0, 0xA5, 0xAA, 0xA7,
		0xF6, 0xE7, 0xAB, 0xAE, 0xF6, 0xE4, 0x88, 0x82,
		0xF6, 0xF0, 0xA5, 0xAE, 0xAB, 0xF6, 0xE7, 0xAF,
		0x86, 0xF6, 0xE7, 0xAF, 0x89, 0xF6, 0xE4, 0x88,
		0xA7, 0xF6, 0xF0, 0xA5, 0xB2, 0x80, 0xF6, 0xE7,
		0xB3, 0x92, 0xF6, 0xE4, 0x8A, 0xA0, 0xF6, 0xE7,
		0xB3, 0xA8, 0xF6, 0xE7, 0xB3, 0xA3, 0xF6, 0xE7,
		0xB4, 0x80, 0xF6, 0xF0, 0xA5, 0xBE, 0x86, 0xF6,
		0xE7, 0xB5, 0xA3, 0xF6, 0xE4, 0x8C, 0x81, 0xF6,
		0xE7, 0xB7, 0x87, 0xF6, 0xE7, 0xB8, 0x82, 0xF6,
		0xE7, 0xB9, 0x85, 0xF6, 0xE4, 0x8C, 0xB4, 0xF6,
		0xF0, 0xA6, 0x88, 0xA8, 0xF6, 0xF0, 0xA6, 0x89,
		0x87, 0xF6, 0xE4, 0x8D, 0x99, 0xF6, 0xF0, 0xA6,
		0x8B, 0x99, 0xF6, 0xE7, 0xBD, 0xBA, 0xF6, 0xF0,
		0xA6, 0x8C, 0xBE, 0xF6, 0xE7, 0xBE, 0x95, 0xF6,
		0xE7, 0xBF, 0xBA, 0xF6, 0xE8, 0x80, 0x85, 0xF6,
		0xF0, 0xA6, 0x93, 0x9A, 0xF6, 0xF0, 0xA6, 0x94,
		0xA3, 0xF6, 0xE8, 0x81, 0xA0, 0xF6, 0xF0, 0xA6,
		0x96, 0xA8, 0xF6, 0xE8, 0x81, 0xB0, 0xF6, 0xF0,
		0xA3, 0x8D, 0x9F, 0xF6, 0xE4, 0x8F, 0x95, 0xF6,
		0xE8, 0x82, 0xB2, 0xF6, 0xE8, 0x84, 0x83, 0xF6,
		0xE4, 0x90, 0x8B, 0xF6, 0xE8, 0x84, 0xBE, 0xF6,
		0xE5, 0xAA, 0xB5, 0xF6, 0xF0, 0xA6, 0x9E, 0xA7,
		0xF6, 0xF0, 0xA6, 0x9E, 0xB5, 0xF6, 0xF0, 0xA3,
		0x8E, 0x93, 0xF6, 0xF0, 0xA3, 0x8E, 0x9C, 0xF6,
		0xE8, 0x88, 0x81, 0xF6, 0xE8, 0x88, 0x84, 0xF6,
		0xE8, 0xBE, 0x9E, 0xF6, 0xE4, 0x91, 0xAB, 0xF6,
		0xE8, 0x8A, 0x91, 0xF6, 0xE8, 0x8A, 0x8B, 0xF6,
		0xE8, 0x8A, 0x9D, 0xF6, 0xE5, 0x8A, 0xB3, 0xF6,
		0xE8, 0x8A, 0xB1, 0xF6, 0xE8, 0x8A, 0xB3, 0xF6,
		0xE8, 0x8A, 0xBD, 0xF6, 0xE8, 0x8B, 0xA6, 0xF6,
		0xF0, 0xA6, 0xAC, 0xBC, 0xF6, 0xE8, 0x8B, 0xA5,
		0xF6, 0xE8, 0x8C, 0x9D, 0xF6, 0xE8, 0x8D, 0xA3,
		0xF6, 0xE8, 0x8E, 0xAD, 0xF6, 0xE8, 0x8C, 0xA3,
		0xF6, 0xE8, 0x8E, 0xBD, 0xF6, 0xE8, 0x8F, 0xA7,
		0xF6, 0xE8, 0x91, 0x97, 0xF6, 0xE8, 0x8D, 0x93,
		0xF6, 0xE8, 0x8F, 0x8A, 0xF6, 0xE8, 0x8F, 0x8C,
		0xF6, 0xE8, 0x8F, 0x9C, 0xF6, 0xF0, 0xA6, 0xB0,
		0xB6, 0xF6, 0xF0, 0xA6, 0xB5, 0xAB, 0xF6, 0xF0,
		0xA6, 0xB3, 0x95, 0xF6, 0xE4, 0x94, 0xAB, 0xF6,
		0xE8, 0x93, 0xB1, 0xF6, 0xE8, 0x93, 0xB3, 0xF6,
		0xE8, 0x94, 0x96, 0xF6, 0xF0, 0xA7, 0x8F, 0x8A,
		0xF6, 0xE8, 0x95, 0xA4, 0xF6, 0xF0, 0xA6, 0xBC,
		0xAC, 0xF6, 0xE4, 0x95, 0x9D, 0xF6, 0xE4, 0x95,
		0xA1, 0xF6, 0xF0, 0xA6, 0xBE, 0xB1, 0xF6, 0xF0,
		0xA7, 0x83, 0x92, 0xF6, 0xE4, 0x95, 0xAB, 0xF6,
		0xE8, 0x99, 0x90, 0xF6, 0xE8, 0x99, 0x9C, 0xF6,
		0xE8, 0x99, 0xA7, 0xF6, 0xE8, 0x99, 0xA9, 0xF6,
		0xE8, 0x9A, 0xA9, 0xF6, 0xE8, 0x9A, 0x88, 0xF6,
		0xE8, 0x9C, 0x8E, 0xF6, 0xE8, 0x9B, 0xA2, 0xF6,
		0xE8, 0x9D, 0xB9, 0xF6, 0xE8, 0x9C, 0xA8, 0xF6,
		0xE8, 0x9D, 0xAB, 0xF6, 0xE8, 0x9E, 0x86, 0xF6,
		0xE4, 0x97, 0x97, 0xF6, 0xE8, 0x9F, 0xA1, 0xF6,
		0xE8, 0xA0, 0x81, 0xF6, 0xE4, 0x97, 0xB9, 0xF6,
		0xE8, 0xA1, 0xA0, 0xF6, 0xE8, 0xA1, 0xA3, 0xF6,
		0xF0, 0xA7, 0x99, 0xA7, 0xF6, 0xE8, 0xA3, 0x97,
		0xF6, 0xE8, 0xA3, 0x9E, 0xF6, 0xE4, 0x98, 0xB5,
		0xF6, 0xE8, 0xA3, 0xBA, 0xF6, 0xE3, 0x92, 0xBB,
		0xF6, 0xF0, 0xA7, 0xA2, 0xAE, 0xF6, 0xF0, 0xA7,
		0xA5, 0xA6, 0xF6, 0xE4, 0x9A, 0xBE, 0xF6, 0xE4,
		0x9B, 0x87, 0xF6, 0xE8, 0xAA, 0xA0, 0xF6, 0xE8,
		0xAB, 0xAD, 0xF6, 0xE8, 0xAE, 0x8A, 0xF6, 0xE8,
		0xB1, 0x95, 0xF6, 0xF0, 0xA7, 0xB2, 0xA8, 0xF6,
		0xE8, 0xB2, 0xAB, 0xF6, 0xE8, 0xB3, 0x81, 0xF6,
		0xE8, 0xB4, 0x9B, 0xF6, 0xE8, 0xB5, 0xB7, 0xF6,
		0xF0, 0xA7, 0xBC, 0xAF, 0xF6, 0xF0, 0xA0, 0xA0,
		0x84, 0xF6, 0xE8, 0xB7, 0x8B, 0xF6, 0xE8, 0xB6,
		0xBC, 0xF6, 0xE8, 0xB7, 0xB0, 0xF6, 0xF0, 0xA0,
		0xA3, 0x9E, 0xF6, 0xE8, 0xBB, 0x94, 0xF6, 0xE8,
		0xBC, 0xB8, 0xF6, 0xF0, 0xA8, 0x97, 0x92, 0xF6,
		0xF0, 0xA8, 0x97, 0xAD, 0xF6, 0xE9, 0x82, 0x94,
		0xF6, 0xE9, 0x83, 0xB1, 0xF6, 0xE9, 0x84, 0x91,
		0xF6, 0xF0, 0xA8, 0x9C, 0xAE, 0xF6, 0xE9, 0x84,
		0x9B, 0xF6, 0xE9, 0x88, 0xB8, 0xF6, 0xE9, 0x8B,
		0x97, 0xF6, 0xE9, 0x8B, 0x98, 0xF6, 0xE9, 0x89,
		0xBC, 0xF6, 0xE9, 0x8F, 0xB9, 0xF6, 0xE9, 0x90,
		0x95, 0xF6, 0xF0, 0xA8, 0xAF, 0xBA, 0xF6, 0xE9,
		0x96, 0x8B, 0xF6, 0xE4, 0xA6, 0x95, 0xF6, 0xE9,
		0x96, 0xB7, 0xF6, 0xF0, 0xA8, 0xB5, 0xB7, 0xF6,
		0xE4, 0xA7, 0xA6, 0xF6, 0xE9, 0x9B, 0x83, 0xF6,
		0xE5, 0xB6, 0xB2, 0xF6, 0xE9, 0x9C, 0xA3, 0xF6,
		0xF0, 0xA9, 0x85, 0x85, 0xF6, 0xF0, 0xA9, 0x88,
		0x9A, 0xF6, 0xE4, 0xA9, 0xAE, 0xF6, 0xE4, 0xA9,
		0xB6, 0xF6, 0xE9, 0x9F, 0xA0, 0xF6, 0xF0, 0xA9,
		0x90, 0x8A, 0xF6, 0xE4, 0xAA, 0xB2, 0xF6, 0xF0,
		0xA9, 0x92, 0x96, 0xF6, 0xE9, 0xA0, 0x8B, 0xF6,
		0xE9, 0xA0, 0x8B, 0xF6, 0xE9, 0xA0, 0xA9, 0xF6,
		0xF0, 0xA9, 0x96, 0xB6, 0xF6, 0xE9, 0xA3, 0xA2,
		0xF6, 0xE4, 0xAC, 0xB3, 0xF6, 0xE9, 0xA4, 0xA9,
		0xF6, 0xE9, 0xA6, 0xA7, 0xF6, 0xE9, 0xA7, 0x82,
		0xF6, 0xE9, 0xA7, 0xBE, 0xF6, 0xE4, 0xAF, 0x8E,
		0xF6, 0xF0, 0xA9, 0xAC, 0xB0, 0xF6, 0xE9, 0xAC,
		0x92, 0xF6, 0xE9, 0xB1, 0x80, 0xF6, 0xE9, 0xB3,
		0xBD, 0xF6, 0xE4, 0xB3, 0x8E, 0xF6, 0xE4, 0xB3,
		0xAD, 0xF6, 0xE9, 0xB5, 0xA7, 0xF6, 0xF0, 0xAA,
		0x83, 0x8E, 0xF6, 0xE4, 0xB3, 0xB8, 0xF6, 0xF0,
		0xAA, 0x84, 0x85, 0xF6, 0xF0, 0xAA, 0x88, 0x8E,
		0xF6, 0xF0, 0xAA, 0x8A, 0x91, 0xF6, 0xE9, 0xBA,
		0xBB, 0xF6, 0xE4, 0xB5, 0x96, 0xF6, 0xE9, 0xBB,
		0xB9, 0xF6, 0xE9, 0xBB, 0xBE, 0xF6, 0xE9, 0xBC,
		0x85, 0xF6, 0xE9, 0xBC, 0x8F, 0xF6, 0xE9, 0xBC,
		0x96, 0xF6, 0xE9, 0xBC, 0xBB, 0xF6, 0xF0, 0xAA,
		0x98, 0x80, 0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,
	},
	{
		0x20, 0x20, 0xCC, 0x88, 0x61, 0x20, 0xCC, 0x84,
		0x32, 0x33, 0x20, 0xCC, 0x81, 0xCE, 0xBC, 0x20,
		0xCC, 0xA7, 0x31, 0x6F, 0x31, 0xE2, 0x81, 0x84,
		0x34, 0x31, 0xE2, 0x81, 0x84, 0x32, 0x33, 0xE2,
		0x81, 0x84, 0x34, 0xF6, 0x41, 0xCC, 0x80, 0xF6,
		0x41, 0xCC, 0x81, 0xF6, 0x41, 0xCC, 0x82, 0xF6,
		0x41, 0xCC, 0x83, 0xF6, 0x41, 0xCC, 0x88, 0xF6,
		0x41, 0xCC, 0x8A, 0xF6, 0x43, 0xCC, 0xA7, 0xF6,
		0x45, 0xCC, 0x80, 0xF6, 0x45, 0xCC, 0x81, 0xF6,
		0x45, 0xCC, 0x82, 0xF6, 0x45, 0xCC, 0x88, 0xF6,
		0x49, 0xCC, 0x80, 0xF6, 0x49, 0xCC, 0x81, 0xF6,
		0x49, 0xCC, 0x82, 0xF6, 0x49, 0xCC, 0x88, 0xF6,
		0x4E, 0xCC, 0x83, 0xF6, 0x4F, 0xCC, 0x80, 0xF6,
		0x4F, 0xCC, 0x81, 0xF6, 0x4F, 0xCC, 0x82, 0xF6,
		0x4F, 0xCC, 0x83, 0xF6, 0x4F, 0xCC, 0x88, 0xF6,
		0x55, 0xCC, 0x80, 0xF6, 0x55, 0xCC, 0x81, 0xF6,
		0x55, 0xCC, 0x82, 0xF6, 0x55, 0xCC, 0x88, 0xF6,
		0x59, 0xCC, 0x81, 0xF6, 0x61, 0xCC, 0x80, 0xF6,
		0x61, 0xCC, 0x81, 0xF6, 0x61, 0xCC, 0x82, 0xF6,
		0x61, 0xCC, 0x83, 0xF6, 0x61, 0xCC, 0x88, 0xF6,
		0x61, 0xCC, 0x8A, 0xF6, 0x63, 0xCC, 0xA7, 0xF6,
		0x65, 0xCC, 0x80, 0xF6, 0x65, 0xCC, 0x81, 0xF6,
		0x65, 0xCC, 0x82, 0xF6, 0x65, 0xCC, 0x88, 0xF6,
		0x69, 0xCC, 0x80, 0xF6, 0x69, 0xCC, 0x81, 0xF6,
		0x69, 0xCC, 0x82, 0xF6, 0x69, 0xCC, 0x88, 0xF6,
		0x6E, 0xCC, 0x83, 0xF6, 0x6F, 0xCC, 0x80, 0xF6,
		0x6F, 0xCC, 0x81, 0xF6, 0x6F, 0xCC, 0x82, 0xF6,
		0x6F, 0xCC, 0x83, 0xF6, 0x6F, 0xCC, 0x88, 0xF6,
		0x75, 0xCC, 0x80, 0xF6, 0x75, 0xCC, 0x81, 0xF6,
		0x75, 0xCC, 0x82, 0xF6, 0x75, 0xCC, 0x88, 0xF6,
		0x79, 0xCC, 0x81, 0xF6, 0x79, 0xCC, 0x88, 0xF6,
		0x41, 0xCC, 0x84, 0xF6, 0x61, 0xCC, 0x84, 0xF6,
		0x41, 0xCC, 0x86, 0xF6, 0x61, 0xCC, 0x86, 0xF6,
		0x41, 0xCC, 0xA8, 0xF6, 0x61, 0xCC, 0xA8, 0xF6,
		0x43, 0xCC, 0x81, 0xF6, 0x63, 0xCC, 0x81, 0xF6,
		0x43, 0xCC, 0x82, 0xF6, 0x63, 0xCC, 0x82, 0xF6,
		0x43, 0xCC, 0x87, 0xF6, 0x63, 0xCC, 0x87, 0xF6,
		0x43, 0xCC, 0x8C, 0xF6, 0x63, 0xCC, 0x8C, 0xF6,
		0x44, 0xCC, 0x8C, 0xF6, 0x64, 0xCC, 0x8C, 0xF6,
		0x45, 0xCC, 0x84, 0xF6, 0x65, 0xCC, 0x84, 0xF6,
		0x45, 0xCC, 0x86, 0xF6, 0x65, 0xCC, 0x86, 0xF6,
		0x45, 0xCC, 0x87, 0xF6, 0x65, 0xCC, 0x87, 0xF6,
		0x45, 0xCC, 0xA8, 0xF6, 0x65, 0xCC, 0xA8, 0xF6,
		0x45, 0xCC, 0x8C, 0xF6, 0x65, 0xCC, 0x8C, 0xF6,
		0x47, 0xCC, 0x82, 0xF6, 0x67, 0xCC, 0x82, 0xF6,
		0x47, 0xCC, 0x86, 0xF6, 0x67, 0xCC, 0x86, 0xF6,
		0x47, 0xCC, 0x87, 0xF6, 0x67, 0xCC, 0x87, 0xF6,
		0x47, 0xCC, 0xA7, 0xF6, 0x67, 0xCC, 0xA7, 0xF6,
		0x48, 0xCC, 0x82, 0xF6, 0x68, 0xCC, 0x82, 0xF6,
		0x49, 0xCC, 0x83, 0xF6, 0x69, 0xCC, 0x83, 0xF6,
		0x49, 0xCC, 0x84, 0xF6, 0x69, 0xCC, 0x84, 0xF6,
		0x49, 0xCC, 0x86, 0xF6, 0x69, 0xCC, 0x86, 0xF6,
		0x49, 0xCC, 0xA8, 0xF6, 0x69, 0xCC, 0xA8, 0xF6,
		0x49, 0xCC, 0x87, 0x49, 0x4A, 0x69, 0x6A, 0xF6,
		0x4A, 0xCC, 0x82, 0xF6, 0x6A, 0xCC, 0x82, 0xF6,
		0x4B, 0xCC, 0xA7, 0xF6, 0x6B, 0xCC, 0xA7, 0xF6,
		0x4C, 0xCC, 0x81, 0xF6, 0x6C, 0xCC, 0x81, 0xF6,
		0x4C, 0xCC, 0xA7, 0xF6, 0x6C, 0xCC, 0xA7, 0xF6,
		0x4C, 0xCC, 0x8C, 0xF6, 0x6C, 0xCC, 0x8C, 0x4C,
		0xC2, 0xB7, 0x6C, 0xC2, 0xB7, 0xF6, 0x4E, 0xCC,
		0x81, 0xF6, 0x6E, 0xCC, 0x81, 0xF6, 0x4E, 0xCC,
		0xA7, 0xF6, 0x6E, 0xCC, 0xA7, 0xF6, 0x4E, 0xCC,
		0x8C, 0xF6, 0x6E, 0xCC, 0x8C, 0xCA, 0xBC, 0x6E,
		0xF6, 0x4F, 0xCC, 0x84, 0xF6, 0x6F, 0xCC, 0x84,
		0xF6, 0x4F, 0xCC, 0x86, 0xF6, 0x6F, 0xCC, 0x86,
		0xF6, 0x4F, 0xCC, 0x8B, 0xF6, 0x6F, 0xCC, 0x8B,
		0xF6, 0x52, 0xCC, 0x81, 0xF6, 0x72, 0xCC, 0x81,
		0xF6, 0x52, 0xCC, 0xA7, 0xF6, 0x72, 0xCC, 0xA7,
		0xF6, 0x52, 0xCC, 0x8C, 0xF6, 0x72, 0xCC, 0x8C,
		0xF6, 0x53, 0xCC, 0x81, 0xF6, 0x73, 0xCC, 0x81,
		0xF6, 0x53, 0xCC, 0x82, 0xF6, 0x73, 0xCC, 0x82,
		0xF6, 0x53, 0xCC, 0xA7, 0xF6, 0x73, 0xCC, 0xA7,
		0xF6, 0x53, 0xCC, 0x8C, 0xF6, 0x73, 0xCC, 0x8C,
		0xF6, 0x54, 0xCC, 0xA7, 0xF6, 0x74, 0xCC, 0xA7,
		0xF6, 0x54, 0xCC, 0x8C, 0xF6, 0x74, 0xCC, 0x8C,
		0xF6, 0x55, 0xCC, 0x83, 0xF6, 0x75, 0xCC, 0x83,
		0xF6, 0x55, 0xCC, 0x84, 0xF6, 0x75, 0xCC, 0x84,
		0xF6, 0x55, 0xCC, 0x86, 0xF6, 0x75, 0xCC, 0x86,
		0xF6, 0x55, 0xCC, 0x8A, 0xF6, 0x75, 0xCC, 0x8A,
		0xF6, 0x55, 0xCC, 0x8B, 0xF6, 0x75, 0xCC, 0x8B,
		0xF6, 0x55, 0xCC, 0xA8, 0xF6, 0x75, 0xCC, 0xA8,
		0xF6, 0x57, 0xCC, 0x82, 0xF6, 0x77, 0xCC, 0x82,
		0xF6, 0x59, 0xCC, 0x82, 0xF6, 0x79, 0xCC, 0x82,
		0xF6, 0x59, 0xCC, 0x88, 0xF6, 0x5A, 0xCC, 0x81,
		0xF6, 0x7A, 0xCC, 0x81, 0xF6, 0x5A, 0xCC, 0x87,
		0xF6, 0x7A, 0xCC, 0x87, 0xF6, 0x5A, 0xCC, 0x8C,
		0xF6, 0x7A, 0xCC, 0x8C, 0x73, 0xF6, 0x4F, 0xCC,
		0x9B, 0xF6, 0x6F, 0xCC, 0x9B, 0xF6, 0x55, 0xCC,
		0x9B, 0xF6, 0x75, 0xCC, 0x9B, 0x44, 0x5A, 0xCC,
		0x8C, 0x44, 0x7A, 0xCC, 0x8C, 0x64, 0x7A, 0xCC,
		0x8C, 0x4C, 0x4A, 0x4C, 0x6A, 0x6C, 0x6A, 0x4E,
		0x4A, 0x4E, 0x6A, 0x6E, 0x6A, 0xF6, 0x41, 0xCC,
		0x8C, 0xF6, 0x61, 0xCC, 0x8C, 0xF6, 0x49, 0xCC,
		0x8C, 0xF6, 0x69, 0xCC, 0x8C, 0xF6, 0x4F, 0xCC,
		0x8C, 0xF6, 0x6F, 0xCC, 0x8C, 0xF6, 0x55, 0xCC,
		0x8C, 0xF6, 0x75, 0xCC, 0x8C, 0xF6, 0x55, 0xCC,
		0x88, 0xCC, 0x84, 0xF6, 0x75, 0xCC, 0x88, 0xCC,
		0x84, 0xF6, 0x55, 0xCC, 0x88, 0xCC, 0x81, 0xF6,
		0x75, 0xCC, 0x88, 0xCC, 0x81, 0xF6, 0x55, 0xCC,
		0x88, 0xCC, 0x8C, 0xF6, 0x75, 0xCC, 0x88, 0xCC,
		0x8C, 0xF6, 0x55, 0xCC, 0x88, 0xCC, 0x80, 0xF6,
		0x75, 0xCC, 0x88, 0xCC, 0x80, 0xF6, 0x41, 0xCC,
		0x88, 0xCC, 0x84, 0xF6, 0x61, 0xCC, 0x88, 0xCC,
		0x84, 0xF6, 0x41, 0xCC, 0x87, 0xCC, 0x84, 0xF6,
		0x61, 0xCC, 0x87, 0xCC, 0x84, 0xF6, 0xC3, 0x86,
		0xCC, 0x84, 0xF6, 0xC3, 0xA6, 0xCC, 0x84, 0xF6,
		0x47, 0xCC, 0x8C, 0xF6, 0x67, 0xCC, 0x8C, 0xF6,
		0x4B, 0xCC, 0x8C, 0xF6, 0x6B, 0xCC, 0x8C, 0xF6,
		0x4F, 0xCC, 0xA8, 0xF6, 0x6F, 0xCC, 0xA8, 0xF6,
		0x4F, 0xCC, 0xA8, 0xCC, 0x84, 0xF6, 0x6F, 0xCC,
		0xA8, 0xCC, 0x84, 0xF6, 0xC6, 0xB7, 0xCC, 0x8C,
		0xF6, 0xCA, 0x92, 0xCC, 0x8C, 0xF6, 0x6A, 0xCC,
		0x8C, 0x44, 0x5A, 0x44, 0x7A, 0x64, 0x7A, 0xF6,
		0x47, 0xCC, 0x81, 0xF6, 0x67, 0xCC, 0x81, 0xF6,
		0x4E, 0xCC, 0x80, 0xF6, 0x6E, 0xCC, 0x80, 0xF6,
		0x41, 0xCC, 0x8A, 0xCC, 0x81, 0xF6, 0x61, 0xCC,
		0x8A, 0xCC, 0x81, 0xF6, 0xC3, 0x86, 0xCC, 0x81,
		0xF6, 0xC3, 0xA6, 0xCC, 0x81, 0xF6, 0xC3, 0x98,
		0xCC, 0x81, 0xF6, 0xC3, 0xB8, 0xCC, 0x81, 0xF6,
		0x41, 0xCC, 0x8F, 0xF6, 0x61, 0xCC, 0x8F, 0xF6,
		0x41, 0xCC, 0x91, 0xF6, 0x61, 0xCC, 0x91, 0xF6,
		0x45, 0xCC, 0x8F, 0xF6, 0x65, 0xCC, 0x8F, 0xF6,
		0x45, 0xCC, 0x91, 0xF6, 0x65, 0xCC, 0x91, 0xF6,
		0x49, 0xCC, 0x8F, 0xF6, 0x69, 0xCC, 0x8F, 0xF6,
		0x49, 0xCC, 0x91, 0xF6, 0x69, 0xCC, 0x91, 0xF6,
		0x4F, 0xCC, 0x8F, 0xF6, 0x6F, 0xCC, 0x8F, 0xF6,
		0x4F, 0xCC, 0x91, 0xF6, 0x6F, 0xCC, 0x91, 0xF6,
		0x52, 0xCC, 0x8F, 0xF6, 0x72, 0xCC, 0x8F, 0xF6,
		0x52, 0xCC, 0x91, 0xF6, 0x72, 0xCC, 0x91, 0xF6,
		0x55, 0xCC, 0x8F, 0xF6, 0x75, 0xCC, 0x8F, 0xF6,
		0x55, 0xCC, 0x91, 0xF6, 0x75, 0xCC, 0x91, 0xF6,
		0x53, 0xCC, 0xA6, 0xF6, 0x73, 0xCC, 0xA6, 0xF6,
		0x54, 0xCC, 0xA6, 0xF6, 0x74, 0xCC, 0xA6, 0xF6,
		0x48, 0xCC, 0x8C, 0xF6, 0x68, 0xCC, 0x8C, 0xF6,
		0x41, 0xCC, 0x87, 0xF6, 0x61, 0xCC, 0x87, 0xF6,
		0x45, 0xCC, 0xA7, 0xF6, 0x65, 0xCC, 0xA7, 0xF6,
		0x4F, 0xCC, 0x88, 0xCC, 0x84, 0xF6, 0x6F, 0xCC,
		0x88, 0xCC, 0x84, 0xF6, 0x4F, 0xCC, 0x83, 0xCC,
		0x84, 0xF6, 0x6F, 0xCC, 0x83, 0xCC, 0x84, 0xF6,
		0x4F, 0xCC, 0x87, 0xF6, 0x6F, 0xCC, 0x87, 0xF6,
		0x4F, 0xCC, 0x87, 0xCC, 0x84, 0xF6, 0x6F, 0xCC,
		0x87, 0xCC, 0x84, 0xF6, 0x59, 0xCC, 0x84, 0xF6,
		0x79, 0xCC, 0x84, 0x68, 0xC9, 0xA6, 0x6A, 0x72,
		0xC9, 0xB9, 0xC9, 0xBB, 0xCA, 0x81, 0x77, 0x79,
		0x20, 0xCC, 0x86, 0x20, 0xCC, 0x87, 0x20, 0xCC,
		0x8A, 0x20, 0xCC, 0xA8, 0x20, 0xCC, 0x83, 0x20,
		0xCC, 0x8B, 0xC9, 0xA3, 0x6C, 0x73, 0x78, 0xCA,
		0x95, 0xF6, 0xCC, 0x80, 0xF6, 0xCC, 0x81, 0xF6,
		0xCC, 0x93, 0xF6, 0xCC, 0x88, 0xCC, 0x81, 0xF6,
		0xCA, 0xB9, 0x20, 0xCD, 0x85, 0xF6, 0x3B, 0x20,
		0xCC, 0x81, 0xF5, 0x05, 0xC2, 0xA8, 0xCC, 0x81,
		0x20, 0xCC, 0x88, 0xCC, 0x81, 0xF6, 0xCE, 0x91,
		0xCC, 0x81, 0xF6, 0xC2, 0xB7, 0xF6, 0xCE, 0x95,
		0xCC, 0x81, 0xF6, 0xCE, 0x97, 0xCC, 0x81, 0xF6,
		0xCE, 0x99, 0xCC, 0x81, 0xF6, 0xCE, 0x9F, 0xCC,
		0x81, 0xF6, 0xCE, 0xA5, 0xCC, 0x81, 0xF6, 0xCE,
		0xA9, 0xCC, 0x81, 0xF6, 0xCE, 0xB9, 0xCC, 0x88,
		0xCC, 0x81, 0xF6, 0xCE, 0x99, 0xCC, 0x88, 0xF6,
		0xCE, 0xA5, 0xCC, 0x88, 0xF6, 0xCE, 0xB1, 0xCC,
		0x81, 0xF6, 0xCE, 0xB5, 0xCC, 0x81, 0xF6, 0xCE,
		0xB7, 0xCC, 0x81, 0xF6, 0xCE, 0xB9, 0xCC, 0x81,
		0xF6, 0xCF, 0x85, 0xCC, 0x88, 0xCC, 0x81, 0xF6,
		0xCE, 0xB9, 0xCC, 0x88, 0xF6, 0xCF, 0x85, 0xCC,
		0x88, 0xF6, 0xCE, 0xBF, 0xCC, 0x81, 0xF6, 0xCF,
		0x85, 0xCC, 0x81, 0xF6, 0xCF, 0x89, 0xCC, 0x81,
		0xCE, 0xB2, 0xCE, 0xB8, 0xCE, 0xA5, 0xF5, 0x05,
		0xCF, 0x92, 0xCC, 0x81, 0xCE, 0xA5, 0xCC, 0x81,
		0xF5, 0x05, 0xCF, 0x92, 0xCC, 0x88, 0xCE, 0xA5,
		0xCC, 0x88, 0xCF, 0x86, 0xCF, 0x80, 0xCE, 0xBA,
		0xCF, 0x81, 0xCF, 0x82, 0xCE, 0x98, 0xCE, 0xB5,
		0xCE, 0xA3, 0xF6, 0xD0, 0x95, 0xCC, 0x80, 0xF6,
		0xD0, 0x95, 0xCC, 0x88, 0xF6, 0xD0, 0x93, 0xCC,
		0x81, 0xF6, 0xD0, 0x86, 0xCC, 0x88, 0xF6, 0xD0,
		0x9A, 0xCC, 0x81, 0xF6, 0xD0, 0x98, 0xCC, 0x80,
		0xF6, 0xD0, 0xA3, 0xCC, 0x86, 0xF6, 0xD0, 0x98,
		0xCC, 0x86, 0xF6, 0xD0, 0xB8, 0xCC, 0x86, 0xF6,
		0xD0, 0xB5, 0xCC, 0x80, 0xF6, 0xD0, 0xB5, 0xCC,
		0x88, 0xF6, 0xD0, 0xB3, 0xCC, 0x81, 0xF6, 0xD1,
		0x96, 0xCC, 0x88, 0xF6, 0xD0, 0xBA, 0xCC, 0x81,
		0xF6, 0xD0, 0xB8, 0xCC, 0x80, 0xF6, 0xD1, 0x83,
		0xCC, 0x86, 0xF6, 0xD1, 0xB4, 0xCC, 0x8F, 0xF6,
		0xD1, 0xB5, 0xCC, 0x8F, 0xF6, 0xD0, 0x96, 0xCC,
		0x86, 0xF6, 0xD0, 0xB6, 0xCC, 0x86, 0xF6, 0xD0,
		0x90, 0xCC, 0x86, 0xF6, 0xD0, 0xB0, 0xCC, 0x86,
		0xF6, 0xD0, 0x90, 0xCC, 0x88, 0xF6, 0xD0, 0xB0,
		0xCC, 0x88, 0xF6, 0xD0, 0x95, 0xCC, 0x86, 0xF6,
		0xD0, 0xB5, 0xCC, 0x86, 0xF6, 0xD3, 0x98, 0xCC,
		0x88, 0xF6, 0xD3, 0x99, 0xCC, 0x88, 0xF6, 0xD0,
		0x96, 0xCC, 0x88, 0xF6, 0xD0, 0xB6, 0xCC, 0x88,
		0xF6, 0xD0, 0x97, 0xCC, 0x88, 0xF6, 0xD0, 0xB7,
		0xCC, 0x88, 0xF6, 0xD0, 0x98, 0xCC, 0x84, 0xF6,
		0xD0, 0xB8, 0xCC, 0x84, 0xF6, 0xD0, 0x98, 0xCC,
		0x88, 0xF6, 0xD0, 0xB8, 0xCC, 0x88, 0xF6, 0xD0,
		0x9E, 0xCC, 0x88, 0xF6, 0xD0, 0xBE, 0xCC, 0x88,
		0xF6, 0xD3, 0xA8, 0xCC, 0x88, 0xF6, 0xD3, 0xA9,
		0xCC, 0x88, 0xF6, 0xD0, 0xAD, 0xCC, 0x88, 0xF6,
		0xD1, 0x8D, 0xCC, 0x88, 0xF6, 0xD0, 0xA3, 0xCC,
		0x84, 0xF6, 0xD1, 0x83, 0xCC, 0x84, 0xF6, 0xD0,
		0xA3, 0xCC, 0x88, 0xF6, 0xD1, 0x83, 0xCC, 0x88,
		0xF6, 0xD0, 0xA3, 0xCC, 0x8B, 0xF6, 0xD1, 0x83,
		0xCC, 0x8B, 0xF6, 0xD0, 0xA7, 0xCC, 0x88, 0xF6,
		0xD1, 0x87, 0xCC, 0x88, 0xF6, 0xD0, 0xAB, 0xCC,
		0x88, 0xF6, 0xD1, 0x8B, 0xCC, 0x88, 0xD5, 0xA5,
		0xD6, 0x82, 0xF6, 0xD8, 0xA7, 0xD9, 0x93, 0xF6,
		0xD8, 0xA7, 0xD9, 0x94, 0xF6, 0xD9, 0x88, 0xD9,
		0x94, 0xF6, 0xD8, 0xA7, 0xD9, 0x95, 0xF6, 0xD9,
		0x8A, 0xD9, 0x94, 0xD8, 0xA7, 0xD9, 0xB4, 0xD9,
		0x88, 0xD9, 0xB4, 0xDB, 0x87, 0xD9, 0xB4, 0xD9,
		0x8A, 0xD9, 0xB4, 0xF6, 0xDB, 0x95, 0xD9, 0x94,
		0xF6, 0xDB, 0x81, 0xD9, 0x94, 0xF6, 0xDB, 0x92,
		0xD9, 0x94, 0xF6, 0xE0, 0xA4, 0xA8, 0xE0, 0xA4,
		0xBC, 0xF6, 0xE0, 0xA4, 0xB0, 0xE0, 0xA4, 0xBC,
		0xF6, 0xE0, 0xA4, 0xB3, 0xE0, 0xA4, 0xBC, 0xF6,
		0xE0, 0xA4, 0x95, 0xE0, 0xA4, 0xBC, 0xF6, 0xE0,
		0xA4, 0x96, 0xE0, 0xA4, 0xBC, 0xF6, 0xE0, 0xA4,
		0x97, 0xE0, 0xA4, 0xBC, 0xF6, 0xE0, 0xA4, 0x9C,
		0xE0, 0xA4, 0xBC, 0xF6, 0xE0, 0xA4, 0xA1, 0xE0,
		0xA4, 0xBC, 0xF6, 0xE0, 0xA4, 0xA2, 0xE0, 0xA4,
		0xBC, 0xF6, 0xE0, 0xA4, 0xAB, 0xE0, 0xA4, 0xBC,
		0xF6, 0xE0, 0xA4, 0xAF, 0xE0, 0xA4, 0xBC, 0xF6,
		0xE0, 0xA7, 0x87, 0xE0, 0xA6, 0xBE, 0xF6, 0xE0,
		0xA7, 0x87, 0xE0, 0xA7, 0x97, 0xF6, 0xE0, 0xA6,
		0xA1, 0xE0, 0xA6, 0xBC, 0xF6, 0xE0, 0xA6, 0xA2,
		0xE0, 0xA6, 0xBC, 0xF6, 0xE0, 0xA6, 0xAF, 0xE0,
		0xA6, 0xBC, 0xF6, 0xE0, 0xA8, 0xB2, 0xE0, 0xA8,
		0xBC, 0xF6, 0xE0, 0xA8, 0xB8, 0xE0, 0xA8, 0xBC,
		0xF6, 0xE0, 0xA8, 0x96, 0xE0, 0xA8, 0xBC, 0xF6,
		0xE0, 0xA8, 0x97, 0xE0, 0xA8, 0xBC, 0xF6, 0xE0,
		0xA8, 0x9C, 0xE0, 0xA8, 0xBC, 0xF6, 0xE0, 0xA8,
		0xAB, 0xE0, 0xA8, 0xBC, 0xF6, 0xE0, 0xAD, 0x87,
		0xE0, 0xAD, 0x96, 0xF6, 0xE0, 0xAD, 0x87, 0xE0,
		0xAC, 0xBE, 0xF6, 0xE0, 0xAD, 0x87, 0xE0, 0xAD,
		0x97, 0xF6, 0xE0, 0xAC, 0xA1, 0xE0, 0xAC, 0xBC,
		0xF6, 0xE0, 0xAC, 0xA2, 0xE0, 0xAC, 0xBC, 0xF6,
		0xE0, 0xAE, 0x92, 0xE0, 0xAF, 0x97, 0xF6, 0xE0,
		0xAF, 0x86, 0xE0, 0xAE, 0xBE, 0xF6, 0xE0, 0xAF,
		0x87, 0xE0, 0xAE, 0xBE, 0xF6, 0xE0, 0xAF, 0x86,
		0xE0, 0xAF, 0x97, 0xF6, 0xE0, 0xB1, 0x86, 0xE0,
		0xB1, 0x96, 0xF6, 0xE0, 0xB2, 0xBF, 0xE0, 0xB3,
		0x95, 0xF6, 0xE0, 0xB3, 0x86, 0xE0, 0xB3, 0x95,
		0xF6, 0xE0, 0xB3, 0x86, 0xE0, 0xB3, 0x96, 0xF6,
		0xE0, 0xB3, 0x86, 0xE0, 0xB3, 0x82, 0xF6, 0xE0,
		0xB3, 0x86, 0xE0, 0xB3, 0x82, 0xE0, 0xB3, 0x95,
		0xF6, 0xE0, 0xB5, 0x86, 0xE0, 0xB4, 0xBE, 0xF6,
		0xE0, 0xB5, 0x87, 0xE0, 0xB4, 0xBE, 0xF6, 0xE0,
		0xB5, 0x86, 0xE0, 0xB5, 0x97, 0xF6, 0xE0, 0xB7,
		0x99, 0xE0, 0xB7, 0x8A, 0xF6, 0xE0, 0xB7, 0x99,
		0xE0, 0xB7, 0x8F, 0xF6, 0xE0, 0xB7, 0x99, 0xE0,
		0xB7, 0x8F, 0xE0, 0xB7, 0x8A, 0xF6, 0xE0, 0xB7,
		0x99, 0xE0, 0xB7, 0x9F, 0xE0, 0xB9, 0x8D, 0xE0,
		0xB8, 0xB2, 0xE0, 0xBB, 0x8D, 0xE0, 0xBA, 0xB2,
		0xE0, 0xBA, 0xAB, 0xE0, 0xBA, 0x99, 0xE0, 0xBA,
		0xAB, 0xE0, 0xBA, 0xA1, 0xE0, 0xBC, 0x8B, 0xF6,
		0xE0, 0xBD, 0x82, 0xE0, 0xBE, 0xB7, 0xF6, 0xE0,
		0xBD, 0x8C, 0xE0, 0xBE, 0xB7, 0xF6, 0xE0, 0xBD,
		0x91, 0xE0, 0xBE, 0xB7, 0xF6, 0xE0, 0xBD, 0x96,
		0xE0, 0xBE, 0xB7, 0xF6, 0xE0, 0xBD, 0x9B, 0xE0,
		0xBE, 0xB7, 0xF6, 0xE0, 0xBD, 0x80, 0xE0, 0xBE,
		0xB5, 0xF6, 0xE0, 0xBD, 0xB1, 0xE0, 0xBD, 0xB2,
		0xF6, 0xE0, 0xBD, 0xB1, 0xE0, 0xBD, 0xB4, 0xF6,
		0xE0, 0xBE, 0xB2, 0xE0, 0xBE, 0x80, 0xE0, 0xBE,
		0xB2, 0xE0, 0xBD, 0xB1, 0xE0, 0xBE, 0x80, 0xF6,
		0xE0, 0xBE, 0xB3, 0xE0, 0xBE, 0x80, 0xE0, 0xBE,
		0xB3, 0xE0, 0xBD, 0xB1, 0xE0, 0xBE, 0x80, 0xF6,
		0xE0, 0xBD, 0xB1, 0xE0, 0xBE, 0x80, 0xF6, 0xE0,
		0xBE, 0x92, 0xE0, 0xBE, 0xB7, 0xF6, 0xE0, 0xBE,
		0x9C, 0xE0, 0xBE, 0xB7, 0xF6, 0xE0, 0xBE, 0xA1,
		0xE0, 0xBE, 0xB7, 0xF6, 0xE0, 0xBE, 0xA6, 0xE0,
		0xBE, 0xB7, 0xF6, 0xE0, 0xBE, 0xAB, 0xE0, 0xBE,
		0xB7, 0xF6, 0xE0, 0xBE, 0x90, 0xE0, 0xBE, 0xB5,
		0xF6, 0xE1, 0x80, 0xA5, 0xE1, 0x80, 0xAE, 0xE1,
		0x83, 0x9C, 0xF6, 0xE1, 0xAC, 0x85, 0xE1, 0xAC,
		0xB5, 0xF6, 0xE1, 0xAC, 0x87, 0xE1, 0xAC, 0xB5,
		0xF6, 0xE1, 0xAC, 0x89, 0xE1, 0xAC, 0xB5, 0xF6,
		0xE1, 0xAC, 0x8B, 0xE1, 0xAC, 0xB5, 0xF6, 0xE1,
		0xAC, 0x8D, 0xE1, 0xAC, 0xB5, 0xF6, 0xE1, 0xAC,
		0x91, 0xE1, 0xAC, 0xB5, 0xF6, 0xE1, 0xAC, 0xBA,
		0xE1, 0xAC, 0xB5, 0xF6, 0xE1, 0xAC, 0xBC, 0xE1,
		0xAC, 0xB5, 0xF6, 0xE1, 0xAC, 0xBE, 0xE1, 0xAC,
		0xB5, 0xF6, 0xE1, 0xAC, 0xBF, 0xE1, 0xAC, 0xB5,
		0xF6, 0xE1, 0xAD, 0x82, 0xE1, 0xAC, 0xB5, 0x41,
		0xC3, 0x86, 0x42, 0x44, 0x45, 0xC6, 0x8E, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0xC8, 0xA2, 0x50, 0x52, 0x54, 0x55, 0x57, 0x61,
		0xC9, 0x90, 0xC9, 0x91, 0xE1, 0xB4, 0x82, 0x62,
		0x64, 0x65, 0xC9, 0x99, 0xC9, 0x9B, 0xC9, 0x9C,
		0x67, 0x6B, 0x6D, 0xC5, 0x8B, 0x6F, 0xC9, 0x94,
		0xE1, 0xB4, 0x96, 0xE1, 0xB4, 0x97, 0x70, 0x74,
		0x75, 0xE1, 0xB4, 0x9D, 0xC9, 0xAF, 0x76, 0xE1,
		0xB4, 0xA5, 0xCE, 0xB2, 0xCE, 0xB3, 0xCE, 0xB4,
		0xCF, 0x86, 0xCF, 0x87, 0x69, 0x72, 0x75, 0x76,
		0xCE, 0xB2, 0xCE, 0xB3, 0xCF, 0x81, 0xCF, 0x86,
		0xCF, 0x87, 0xD0, 0xBD, 0xC9, 0x92, 0x63, 0xC9,
		0x95, 0xC3, 0xB0, 0xC9, 0x9C, 0x66, 0xC9, 0x9F,
		0xC9, 0xA1, 0xC9, 0xA5, 0xC9, 0xA8, 0xC9, 0xA9,
		0xC9, 0xAA, 0xE1, 0xB5, 0xBB, 0xCA, 0x9D, 0xC9,
		0xAD, 0xE1, 0xB6, 0x85, 0xCA, 0x9F, 0xC9, 0xB1,
		0xC9, 0xB0, 0xC9, 0xB2, 0xC9, 0xB3, 0xC9, 0xB4,
		0xC9, 0xB5, 0xC9, 0xB8, 0xCA, 0x82, 0xCA, 0x83,
		0xC6, 0xAB, 0xCA, 0x89, 0xCA, 0x8A, 0xE1, 0xB4,
		0x9C, 0xCA, 0x8B, 0xCA, 0x8C, 0x7A, 0xCA, 0x90,
		0xCA, 0x91, 0xCA, 0x92, 0xCE, 0xB8, 0xF6, 0x41,
		0xCC, 0xA5, 0xF6, 0x61, 0xCC, 0xA5, 0xF6, 0x42,
		0xCC, 0x87, 0xF6, 0x62, 0xCC, 0x87, 0xF6, 0x42,
		0xCC, 0xA3, 0xF6, 0x62, 0xCC, 0xA3, 0xF6, 0x42,
		0xCC, 0xB1, 0xF6, 0x62, 0xCC, 0xB1, 0xF6, 0x43,
		0xCC, 0xA7, 0xCC, 0x81, 0xF6, 0x63, 0xCC, 0xA7,
		0xCC, 0x81, 0xF6, 0x44, 0xCC, 0x87, 0xF6, 0x64,
		0xCC, 0x87, 0xF6, 0x44, 0xCC, 0xA3, 0xF6, 0x64,
		0xCC, 0xA3, 0xF6, 0x44, 0xCC, 0xB1, 0xF6, 0x64,
		0xCC, 0xB1, 0xF6, 0x44, 0xCC, 0xA7, 0xF6, 0x64,
		0xCC, 0xA7, 0xF6, 0x44, 0xCC, 0xAD, 0xF6, 0x64,
		0xCC, 0xAD, 0xF6, 0x45, 0xCC, 0x84, 0xCC, 0x80,
		0xF6, 0x65, 0xCC, 0x84, 0xCC, 0x80, 0xF6, 0x45,
		0xCC, 0x84, 0xCC, 0x81, 0xF6, 0x65, 0xCC, 0x84,
		0xCC, 0x81, 0xF6, 0x45, 0xCC, 0xAD, 0xF6, 0x65,
		0xCC, 0xAD, 0xF6, 0x45, 0xCC, 0xB0, 0xF6, 0x65,
		0xCC, 0xB0, 0xF6, 0x45, 0xCC, 0xA7, 0xCC, 0x86,
		0xF6, 0x65, 0xCC, 0xA7, 0xCC, 0x86, 0xF6, 0x46,
		0xCC, 0x87, 0xF6, 0x66, 0xCC, 0x87, 0xF6, 0x47,
		0xCC, 0x84, 0xF6, 0x67, 0xCC, 0x84, 0xF6, 0x48,
		0xCC, 0x87, 0xF6, 0x68, 0xCC, 0x87, 0xF6, 0x48,
		0xCC, 0xA3, 0xF6, 0x68, 0xCC, 0xA3, 0xF6, 0x48,
		0xCC, 0x88, 0xF6, 0x68, 0xCC, 0x88, 0xF6, 0x48,
		0xCC, 0xA7, 0xF6, 0x68, 0xCC, 0xA7, 0xF6, 0x48,
		0xCC, 0xAE, 0xF6, 0x68, 0xCC, 0xAE, 0xF6, 0x49,
		0xCC, 0xB0, 0xF6, 0x69, 0xCC, 0xB0, 0xF6, 0x49,
		0xCC, 0x88, 0xCC, 0x81, 0xF6, 0x69, 0xCC, 0x88,
		0xCC, 0x81, 0xF6, 0x4B, 0xCC, 0x81, 0xF6, 0x6B,
		0xCC, 0x81, 0xF6, 0x4B, 0xCC, 0xA3, 0xF6, 0x6B,
		0xCC, 0xA3, 0xF6, 0x4B, 0xCC, 0xB1, 0xF6, 0x6B,
		0xCC, 0xB1, 0xF6, 0x4C, 0xCC, 0xA3, 0xF6, 0x6C,
		0xCC, 0xA3, 0xF6, 0x4C, 0xCC, 0xA3, 0xCC, 0x84,
		0xF6, 0x6C, 0xCC, 0xA3, 0xCC, 0x84, 0xF6, 0x4C,
		0xCC, 0xB1, 0xF6, 0x6C, 0xCC, 0xB1, 0xF6, 0x4C,
		0xCC, 0xAD, 0xF6, 0x6C, 0xCC, 0xAD, 0xF6, 0x4D,
		0xCC, 0x81, 0xF6, 0x6D, 0xCC, 0x81, 0xF6, 0x4D,
		0xCC, 0x87, 0xF6, 0x6D, 0xCC, 0x87, 0xF6, 0x4D,
		0xCC, 0xA3, 0xF6, 0x6D, 0xCC, 0xA3, 0xF6, 0x4E,
		0xCC, 0x87, 0xF6, 0x6E, 0xCC, 0x87, 0xF6, 0x4E,
		0xCC, 0xA3, 0xF6, 0x6E, 0xCC, 0xA3, 0xF6, 0x4E,
		0xCC, 0xB1, 0xF6, 0x6E, 0xCC, 0xB1, 0xF6, 0x4E,
		0xCC, 0xAD, 0xF6, 0x6E, 0xCC, 0xAD, 0xF6, 0x4F,
		0xCC, 0x83, 0xCC, 0x81, 0xF6, 0x6F, 0xCC, 0x83,
		0xCC, 0x81, 0xF6, 0x4F, 0xCC, 0x83, 0xCC, 0x88,
		0xF6, 0x6F, 0xCC, 0x83, 0xCC, 0x88, 0xF6, 0x4F,
		0xCC, 0x84, 0xCC, 0x80, 0xF6, 0x6F, 0xCC, 0x84,
		0xCC, 0x80, 0xF6, 0x4F, 0xCC, 0x84, 0xCC, 0x81,
		0xF6, 0x6F, 0xCC, 0x84, 0xCC, 0x81, 0xF6, 0x50,
		0xCC, 0x81, 0xF6, 0x70, 0xCC, 0x81, 0xF6, 0x50,
		0xCC, 0x87, 0xF6, 0x70, 0xCC, 0x87, 0xF6, 0x52,
		0xCC, 0x87, 0xF6, 0x72, 0xCC, 0x87, 0xF6, 0x52,
		0xCC, 0xA3, 0xF6, 0x72, 0xCC, 0xA3, 0xF6, 0x52,
		0xCC, 0xA3, 0xCC, 0x84, 0xF6, 0x72, 0xCC, 0xA3,
		0xCC, 0x84, 0xF6, 0x52, 0xCC, 0xB1, 0xF6, 0x72,
		0xCC, 0xB1, 0xF6, 0x53, 0xCC, 0x87, 0xF6, 0x73,
		0xCC, 0x87, 0xF6, 0x53, 0xCC, 0xA3, 0xF6, 0x73,
		0xCC, 0xA3, 0xF6, 0x53, 0xCC, 0x81, 0xCC, 0x87,
		0xF6, 0x73, 0xCC, 0x81, 0xCC, 0x87, 0xF6, 0x53,
		0xCC, 0x8C, 0xCC, 0x87, 0xF6, 0x73, 0xCC, 0x8C,
		0xCC, 0x87, 0xF6, 0x53, 0xCC, 0xA3, 0xCC, 0x87,
		0xF6, 0x73, 0xCC, 0xA3, 0xCC, 0x87, 0xF6, 0x54,
		0xCC, 0x87, 0xF6, 0x74, 0xCC, 0x87, 0xF6, 0x54,
		0xCC, 0xA3, 0xF6, 0x74, 0xCC, 0xA3, 0xF6, 0x54,
		0xCC, 0xB1, 0xF6, 0x74, 0xCC, 0xB1, 0xF6, 0x54,
		0xCC, 0xAD, 0xF6, 0x74, 0xCC, 0xAD, 0xF6, 0x55,
		0xCC, 0xA4, 0xF6, 0x75, 0xCC, 0xA4, 0xF6, 0x55,
		0xCC, 0xB0, 0xF6, 0x75, 0xCC, 0xB0, 0xF6, 0x55,
		0xCC, 0xAD, 0xF6, 0x75, 0xCC, 0xAD, 0xF6, 0x55,
		0xCC, 0x83, 0xCC, 0x81, 0xF6, 0x75, 0xCC, 0x83,
		0xCC, 0x81, 0xF6, 0x55, 0xCC, 0x84, 0xCC, 0x88,
		0xF6, 0x75, 0xCC, 0x84, 0xCC, 0x88, 0xF6, 0x56,
		0xCC, 0x83, 0xF6, 0x76, 0xCC, 0x83, 0xF6, 0x56,
		0xCC, 0xA3, 0xF6, 0x76, 0xCC, 0xA3, 0xF6, 0x57,
		0xCC, 0x80, 0xF6, 0x77, 0xCC, 0x80, 0xF6, 0x57,
		0xCC, 0x81, 0xF6, 0x77, 0xCC, 0x81, 0xF6, 0x57,
		0xCC, 0x88, 0xF6, 0x77, 0xCC, 0x88, 0xF6, 0x57,
		0xCC, 0x87, 0xF6, 0x77, 0xCC, 0x87, 0xF6, 0x57,
		0xCC, 0xA3, 0xF6, 0x77, 0xCC, 0xA3, 0xF6, 0x58,
		0xCC, 0x87, 0xF6, 0x78, 0xCC, 0x87, 0xF6, 0x58,
		0xCC, 0x88, 0xF6, 0x78, 0xCC, 0x88, 0xF6, 0x59,
		0xCC, 0x87, 0xF6, 0x79, 0xCC, 0x87, 0xF6, 0x5A,
		0xCC, 0x82, 0xF6, 0x7A, 0xCC, 0x82, 0xF6, 0x5A,
		0xCC, 0xA3, 0xF6, 0x7A, 0xCC, 0xA3, 0xF6, 0x5A,
		0xCC, 0xB1, 0xF6, 0x7A, 0xCC, 0xB1, 0xF6, 0x68,
		0xCC, 0xB1, 0xF6, 0x74, 0xCC, 0x88, 0xF6, 0x77,
		0xCC, 0x8A, 0xF6, 0x79, 0xCC, 0x8A, 0x61, 0xCA,
		0xBE, 0xF5, 0x05, 0xC5, 0xBF, 0xCC, 0x87, 0x73,
		0xCC, 0x87, 0xF6, 0x41, 0xCC, 0xA3, 0xF6, 0x61,
		0xCC, 0xA3, 0xF6, 0x41, 0xCC, 0x89, 0xF6, 0x61,
		0xCC, 0x89, 0xF6, 0x41, 0xCC, 0x82, 0xCC, 0x81,
		0xF6, 0x61, 0xCC, 0x82, 0xCC, 0x81, 0xF6, 0x41,
		0xCC, 0x82, 0xCC, 0x80, 0xF6, 0x61, 0xCC, 0x82,
		0xCC, 0x80, 0xF6, 0x41, 0xCC, 0x82, 0xCC, 0x89,
		0xF6, 0x61, 0xCC, 0x82, 0xCC, 0x89, 0xF6, 0x41,
		0xCC, 0x82, 0xCC, 0x83, 0xF6, 0x61, 0xCC, 0x82,
		0xCC, 0x83, 0xF6, 0x41, 0xCC, 0xA3, 0xCC, 0x82,
		0xF6, 0x61, 0xCC, 0xA3, 0xCC, 0x82, 0xF6, 0x41,
		0xCC, 0x86, 0xCC, 0x81, 0xF6, 0x61, 0xCC, 0x86,
		0xCC, 0x81, 0xF6, 0x41, 0xCC, 0x86, 0xCC, 0x80,
		0xF6, 0x61, 0xCC, 0x86, 0xCC, 0x80, 0xF6, 0x41,
		0xCC, 0x86, 0xCC, 0x89, 0xF6, 0x61, 0xCC, 0x86,
		0xCC, 0x89, 0xF6, 0x41, 0xCC, 0x86, 0xCC, 0x83,
		0xF6, 0x61, 0xCC, 0x86, 0xCC, 0x83, 0xF6, 0x41,
		0xCC, 0xA3, 0xCC, 0x86, 0xF6, 0x61, 0xCC, 0xA3,
		0xCC, 0x86, 0xF6, 0x45, 0xCC, 0xA3, 0xF6, 0x65,
		0xCC, 0xA3, 0xF6, 0x45, 0xCC, 0x89, 0xF6, 0x65,
		0xCC, 0x89, 0xF6, 0x45, 0xCC, 0x83, 0xF6, 0x65,
		0xCC, 0x83, 0xF6, 0x45, 0xCC, 0x82, 0xCC, 0x81,
		0xF6, 0x65, 0xCC, 0x82, 0xCC, 0x81, 0xF6, 0x45,
		0xCC, 0x82, 0xCC, 0x80, 0xF6, 0x65, 0xCC, 0x82,
		0xCC, 0x80, 0xF6, 0x45, 0xCC, 0x82, 0xCC, 0x89,
		0xF6, 0x65, 0xCC, 0x82, 0xCC, 0x89, 0xF6, 0x45,
		0xCC, 0x82, 0xCC, 0x83, 0xF6, 0x65, 0xCC, 0x82,
		0xCC, 0x83, 0xF6, 0x45, 0xCC, 0xA3, 0xCC, 0x82,
		0xF6, 0x65, 0xCC, 0xA3, 0xCC, 0x82, 0xF6, 0x49,
		0xCC, 0x89, 0xF6, 0x69, 0xCC, 0x89, 0xF6, 0x49,
		0xCC, 0xA3, 0xF6, 0x69, 0xCC, 0xA3, 0xF6, 0x4F,
		0xCC, 0xA3, 0xF6, 0x6F, 0xCC, 0xA3, 0xF6, 0x4F,
		0xCC, 0x89, 0xF6, 0x6F, 0xCC, 0x89, 0xF6, 0x4F,
		0xCC, 0x82, 0xCC, 0x81, 0xF6, 0x6F, 0xCC, 0x82,
		0xCC, 0x81, 0xF6, 0x4F, 0xCC, 0x82, 0xCC, 0x80,
		0xF6, 0x6F, 0xCC, 0x82, 0xCC, 0x80, 0xF6, 0x4F,
		0xCC, 0x82, 0xCC, 0x89, 0xF6, 0x6F, 0xCC, 0x82,
		0xCC, 0x89, 0xF6, 0x4F, 0xCC, 0x82, 0xCC, 0x83,
		0xF6, 0x6F, 0xCC, 0x82, 0xCC, 0x83, 0xF6, 0x4F,
		0xCC, 0xA3, 0xCC, 0x82, 0xF6, 0x6F, 0xCC, 0xA3,
		0xCC, 0x82, 0xF6, 0x4F, 0xCC, 0x9B, 0xCC, 0x81,
		0xF6, 0x6F, 0xCC, 0x9B, 0xCC, 0x81, 0xF6, 0x4F,
		0xCC, 0x9B, 0xCC, 0x80, 0xF6, 0x6F, 0xCC, 0x9B,
		0xCC, 0x80, 0xF6, 0x4F, 0xCC, 0x9B, 0xCC, 0x89,
		0xF6, 0x6F, 0xCC, 0x9B, 0xCC, 0x89, 0xF6, 0x4F,
		0xCC, 0x9B, 0xCC, 0x83, 0xF6, 0x6F, 0xCC, 0x9B,
		0xCC, 0x83, 0xF6, 0x4F, 0xCC, 0x9B, 0xCC, 0xA3,
		0xF6, 0x6F, 0xCC, 0x9B, 0xCC, 0xA3, 0xF6, 0x55,
		0xCC, 0xA3, 0xF6, 0x75, 0xCC, 0xA3, 0xF6, 0x55,
		0xCC, 0x89, 0xF6, 0x75, 0xCC, 0x89, 0xF6, 0x55,
		0xCC, 0x9B, 0xCC, 0x81, 0xF6, 0x75, 0xCC, 0x9B,
		0xCC, 0x81, 0xF6, 0x55, 0xCC, 0x9B, 0xCC, 0x80,
		0xF6, 0x75, 0xCC, 0x9B, 0xCC, 0x80, 0xF6, 0x55,
		0xCC, 0x9B, 0xCC, 0x89, 0xF6, 0x75, 0xCC, 0x9B,
		0xCC, 0x89, 0xF6, 0x55, 0xCC, 0x9B, 0xCC, 0x83,
		0xF6, 0x75, 0xCC, 0x9B, 0xCC, 0x83, 0xF6, 0x55,
		0xCC, 0x9B, 0xCC, 0xA3, 0xF6, 0x75, 0xCC, 0x9B,
		0xCC, 0xA3, 0xF6, 0x59, 0xCC, 0x80, 0xF6, 0x79,
		0xCC, 0x80, 0xF6, 0x59, 0xCC, 0xA3, 0xF6, 0x79,
		0xCC, 0xA3, 0xF6, 0x59, 0xCC, 0x89, 0xF6, 0x79,
		0xCC, 0x89, 0xF6, 0x59, 0xCC, 0x83, 0xF6, 0x79,
		0xCC, 0x83, 0xF6, 0xCE, 0xB1, 0xCC, 0x93, 0xF6,
		0xCE, 0xB1, 0xCC, 0x94, 0xF6, 0xCE, 0xB1, 0xCC,
		0x93, 0xCC, 0x80, 0xF6, 0xCE, 0xB1, 0xCC, 0x94,
		0xCC, 0x80, 0xF6, 0xCE, 0xB1, 0xCC, 0x93, 0xCC,
		0x81, 0xF6, 0xCE, 0xB1, 0xCC, 0x94, 0xCC, 0x81,
		0xF6, 0xCE, 0xB1, 0xCC, 0x93, 0xCD, 0x82, 0xF6,
		0xCE, 0xB1, 0xCC, 0x94, 0xCD, 0x82, 0xF6, 0xCE,
		0x91, 0xCC, 0x93, 0xF6, 0xCE, 0x91, 0xCC, 0x94,
		0xF6, 0xCE, 0x91, 0xCC, 0x93, 0xCC, 0x80, 0xF6,
		0xCE, 0x91, 0xCC, 0x94, 0xCC, 0x80, 0xF6, 0xCE,
		0x91, 0xCC, 0x93, 0xCC, 0x81, 0xF6, 0xCE, 0x91,
		0xCC, 0x94, 0xCC, 0x81, 0xF6, 0xCE, 0x91, 0xCC,
		0x93, 0xCD, 0x82, 0xF6, 0xCE, 0x91, 0xCC, 0x94,
		0xCD, 0x82, 0xF6, 0xCE, 0xB5, 0xCC, 0x93, 0xF6,
		0xCE, 0xB5, 0xCC, 0x94, 0xF6, 0xCE, 0xB5, 0xCC,
		0x93, 0xCC, 0x80, 0xF6, 0xCE, 0xB5, 0xCC, 0x94,
		0xCC, 0x80, 0xF6, 0xCE, 0xB5, 0xCC, 0x93, 0xCC,
		0x81, 0xF6, 0xCE, 0xB5, 0xCC, 0x94, 0xCC, 0x81,
		0xF6, 0xCE, 0x95, 0xCC, 0x93, 0xF6, 0xCE, 0x95,
		0xCC, 0x94, 0xF6, 0xCE, 0x95, 0xCC, 0x93, 0xCC,
		0x80, 0xF6, 0xCE, 0x95, 0xCC, 0x94, 0xCC, 0x80,
		0xF6, 0xCE, 0x95, 0xCC, 0x93, 0xCC, 0x81, 0xF6,
		0xCE, 0x95, 0xCC, 0x94, 0xCC, 0x81, 0xF6, 0xCE,
		0xB7, 0xCC, 0x93, 0xF6, 0xCE, 0xB7, 0xCC, 0x94,
		0xF6, 0xCE, 0xB7, 0xCC, 0x93, 0xCC, 0x80, 0xF6,
		0xCE, 0xB7, 0xCC, 0x94, 0xCC, 0x80, 0xF6, 0xCE,
		0xB7, 0xCC, 0x93, 0xCC, 0x81, 0xF6, 0xCE, 0xB7,
		0xCC, 0x94, 0xCC, 0x81, 0xF6, 0xCE, 0xB7, 0xCC,
		0x93, 0xCD, 0x82, 0xF6, 0xCE, 0xB7, 0xCC, 0x94,
		0xCD, 0x82, 0xF6, 0xCE, 0x97, 0xCC, 0x93, 0xF6,
		0xCE, 0x97, 0xCC, 0x94, 0xF6, 0xCE, 0x97, 0xCC,
		0x93, 0xCC, 0x80, 0xF6, 0xCE, 0x97, 0xCC, 0x94,
		0xCC, 0x80, 0xF6, 0xCE, 0x97, 0xCC, 0x93, 0xCC,
		0x81, 0xF6, 0xCE, 0x97, 0xCC, 0x94, 0xCC, 0x81,
		0xF6, 0xCE, 0x97, 0xCC, 0x93, 0xCD, 0x82, 0xF6,
		0xCE, 0x97, 0xCC, 0x94, 0xCD, 0x82, 0xF6, 0xCE,
		0xB9, 0xCC, 0x93, 0xF6, 0xCE, 0xB9, 0xCC, 0x94,
		0xF6, 0xCE, 0xB9, 0xCC, 0x93, 0xCC, 0x80, 0xF6,
		0xCE, 0xB9, 0xCC, 0x94, 0xCC, 0x80, 0xF6, 0xCE,
		0xB9, 0xCC, 0x93, 0xCC, 0x81, 0xF6, 0xCE, 0xB9,
		0xCC, 0x94, 0xCC, 0x81, 0xF6, 0xCE, 0xB9, 0xCC,
		0x93, 0xCD, 0x82, 0xF6, 0xCE, 0xB9, 0xCC, 0x94,
		0xCD, 0x82, 0xF6, 0xCE, 0x99, 0xCC, 0x93, 0xF6,
		0xCE, 0x99, 0xCC, 0x94, 0xF6, 0xCE, 0x99, 0xCC,
		0x93, 0xCC, 0x80, 0xF6, 0xCE, 0x99, 0xCC, 0x94,
		0xCC, 0x80, 0xF6, 0xCE, 0x99, 0xCC, 0x93, 0xCC,
		0x81, 0xF6, 0xCE, 0x99, 0xCC, 0x94, 0xCC, 0x81,
		0xF6, 0xCE, 0x99, 0xCC, 0x93, 0xCD, 0x82, 0xF6,
		0xCE, 0x99, 0xCC, 0x94, 0xCD, 0x82, 0xF6, 0xCE,
		0xBF, 0xCC, 0x93, 0xF6, 0xCE, 0xBF, 0xCC, 0x94,
		0xF6, 0xCE, 0xBF, 0xCC, 0x93, 0xCC, 0x80, 0xF6,
		0xCE, 0xBF, 0xCC, 0x94, 0xCC, 0x80, 0xF6, 0xCE,
		0xBF, 0xCC, 0x93, 0xCC, 0x81, 0xF6, 0xCE, 0xBF,
		0xCC, 0x94, 0xCC, 0x81, 0xF6, 0xCE, 0x9F, 0xCC,
		0x93, 0xF6, 0xCE, 0x9F, 0xCC, 0x94, 0xF6, 0xCE,
		0x9F, 0xCC, 0x93, 0xCC, 0x80, 0xF6, 0xCE, 0x9F,
		0xCC, 0x94, 0xCC, 0x80, 0xF6, 0xCE, 0x9F, 0xCC,
		0x93, 0xCC, 0x81, 0xF6, 0xCE, 0x9F, 0xCC, 0x94,
		0xCC, 0x81, 0xF6, 0xCF, 0x85, 0xCC, 0x93, 0xF6,
		0xCF, 0x85, 0xCC, 0x94, 0xF6, 0xCF, 0x85, 0xCC,
		0x93, 0xCC, 0x80, 0xF6, 0xCF, 0x85, 0xCC, 0x94,
		0xCC, 0x80, 0xF6, 0xCF, 0x85, 0xCC, 0x93, 0xCC,
		0x81, 0xF6, 0xCF, 0x85, 0xCC, 0x94, 0xCC, 0x81,
		0xF6, 0xCF, 0x85, 0xCC, 0x93, 0xCD, 0x82, 0xF6,
		0xCF, 0x85, 0xCC, 0x94, 0xCD, 0x82, 0xF6, 0xCE,
		0xA5, 0xCC, 0x94, 0xF6, 0xCE, 0xA5, 0xCC, 0x94,
		0xCC, 0x80, 0xF6, 0xCE, 0xA5, 0xCC, 0x94, 0xCC,
		0x81, 0xF6, 0xCE, 0xA5, 0xCC, 0x94, 0xCD, 0x82,
		0xF6, 0xCF, 0x89, 0xCC, 0x93, 0xF6, 0xCF, 0x89,
		0xCC, 0x94, 0xF6, 0xCF, 0x89, 0xCC, 0x93, 0xCC,
		0x80, 0xF6, 0xCF, 0x89, 0xCC, 0x94, 0xCC, 0x80,
		0xF6, 0xCF, 0x89, 0xCC, 0x93, 0xCC, 0x81, 0xF6,
		0xCF, 0x89, 0xCC, 0x94, 0xCC, 0x81, 0xF6, 0xCF,
		0x89, 0xCC, 0x93, 0xCD, 0x82, 0xF6, 0xCF, 0x89,
		0xCC, 0x94, 0xCD, 0x82, 0xF6, 0xCE, 0xA9, 0xCC,
		0x93, 0xF6, 0xCE, 0xA9, 0xCC, 0x94, 0xF6, 0xCE,
		0xA9, 0xCC, 0x93, 0xCC, 0x80, 0xF6, 0xCE, 0xA9,
		0xCC, 0x94, 0xCC, 0x80, 0xF6, 0xCE, 0xA9, 0xCC,
		0x93, 0xCC, 0x81, 0xF6, 0xCE, 0xA9, 0xCC, 0x94,
		0xCC, 0x81, 0xF6, 0xCE, 0xA9, 0xCC, 0x93, 0xCD,
		0x82, 0xF6, 0xCE, 0xA9, 0xCC, 0x94, 0xCD, 0x82,
		0xF6, 0xCE, 0xB1, 0xCC, 0x80, 0xF6, 0xCE, 0xB1,
		0xCC, 0x81, 0xF6, 0xCE, 0xB5, 0xCC, 0x80, 0xF6,
		0xCE, 0xB5, 0xCC, 0x81, 0xF6, 0xCE, 0xB7, 0xCC,
		0x80, 0xF6, 0xCE, 0xB7, 0xCC, 0x81, 0xF6, 0xCE,
		0xB9, 0xCC, 0x80, 0xF6, 0xCE, 0xB9, 0xCC, 0x81,
		0xF6, 0xCE, 0xBF, 0xCC, 0x80, 0xF6, 0xCE, 0xBF,
		0xCC, 0x81, 0xF6, 0xCF, 0x85, 0xCC, 0x80, 0xF6,
		0xCF, 0x85, 0xCC, 0x81, 0xF6, 0xCF, 0x89, 0xCC,
		0x80, 0xF6, 0xCF, 0x89, 0xCC, 0x81, 0xF6, 0xCE,
		0xB1, 0xCC, 0x93, 0xCD, 0x85, 0xF6, 0xCE, 0xB1,
		0xCC, 0x94, 0xCD, 0x85, 0xF6, 0xCE, 0xB1, 0xCC,
		0x93, 0xCC, 0x80, 0xCD, 0x85, 0xF6, 0xCE, 0xB1,
		0xCC, 0x94, 0xCC, 0x80, 0xCD, 0x85, 0xF6, 0xCE,
		0xB1, 0xCC, 0x93, 0xCC, 0x81, 0xCD, 0x85, 0xF6,
		0xCE, 0xB1, 0xCC, 0x94, 0xCC, 0x81, 0xCD, 0x85,
		0xF6, 0xCE, 0xB1, 0xCC, 0x93, 0xCD, 0x82, 0xCD,
		0x85, 0xF6, 0xCE, 0xB1, 0xCC, 0x94, 0xCD, 0x82,
		0xCD, 0x85, 0xF6, 0xCE, 0x91, 0xCC, 0x93, 0xCD,
		0x85, 0xF6, 0xCE, 0x91, 0xCC, 0x94, 0xCD, 0x85,
		0xF6, 0xCE, 0x91, 0xCC, 0x93, 0xCC, 0x80, 0xCD,
		0x85, 0xF6, 0xCE, 0x91, 0xCC, 0x94, 0xCC, 0x80,
		0xCD, 0x85, 0xF6, 0xCE, 0x91, 0xCC, 0x93, 0xCC,
		0x81, 0xCD, 0x85, 0xF6, 0xCE, 0x91, 0xCC, 0x94,
		0xCC, 0x81, 0xCD, 0x85, 0xF6, 0xCE, 0x91, 0xCC,
		0x93, 0xCD, 0x82, 0xCD, 0x85, 0xF6, 0xCE, 0x91,
		0xCC, 0x94, 0xCD, 0x82, 0xCD, 0x85, 0xF6, 0xCE,
		0xB7, 0xCC, 0x93, 0xCD, 0x85, 0xF6, 0xCE, 0xB7,
		0xCC, 0x94, 0xCD, 0x85, 0xF6, 0xCE, 0xB7, 0xCC,
		0x93, 0xCC, 0x80, 0xCD, 0x85, 0xF6, 0xCE, 0xB7,
		0xCC, 0x94, 0xCC, 0x80, 0xCD, 0x85, 0xF6, 0xCE,
		0xB7, 0xCC, 0x93, 0xCC, 0x81, 0xCD, 0x85, 0xF6,
		0xCE, 0xB7, 0xCC, 0x94, 0xCC, 0x81, 0xCD, 0x85,
		0xF6, 0xCE, 0xB7, 0xCC, 0x93, 0xCD, 0x82, 0xCD,
		0x85, 0xF6, 0xCE, 0xB7, 0xCC, 0x94, 0xCD, 0x82,
		0xCD, 0x85, 0xF6, 0xCE, 0x97, 0xCC, 0x93, 0xCD,
		0x85, 0xF6, 0xCE, 0x97, 0xCC, 0x94, 0xCD, 0x85,
		0xF6, 0xCE, 0x97, 0xCC, 0x93, 0xCC, 0x80, 0xCD,
		0x85, 0xF6, 0xCE, 0x97, 0xCC, 0x94, 0xCC, 0x80,
		0xCD, 0x85, 0xF6, 0xCE, 0x97, 0xCC, 0x93, 0xCC,
		0x81, 0xCD, 0x85, 0xF6, 0xCE, 0x97, 0xCC, 0x94,
		0xCC, 0x81, 0xCD, 0x85, 0xF6, 0xCE, 0x97, 0xCC,
		0x93, 0xCD, 0x82, 0xCD, 0x85, 0xF6, 0xCE, 0x97,
		0xCC, 0x94, 0xCD, 0x82, 0xCD, 0x85, 0xF6, 0xCF,
		0x89, 0xCC, 0x93, 0xCD, 0x85, 0xF6, 0xCF, 0x89,
		0xCC, 0x94, 0xCD, 0x85, 0xF6, 0xCF, 0x89, 0xCC,
		0x93, 0xCC, 0x80, 0xCD, 0x85, 0xF6, 0xCF, 0x89,
		0xCC, 0x94, 0xCC, 0x80, 0xCD, 0x85, 0xF6, 0xCF,
		0x89, 0xCC, 0x93, 0xCC, 0x81, 0xCD, 0x85, 0xF6,
		0xCF, 0x89, 0xCC, 0x94, 0xCC, 0x81, 0xCD, 0x85,
		0xF6, 0xCF, 0x89, 0xCC, 0x93, 0xCD, 0x82, 0xCD,
		0x85, 0xF6, 0xCF, 0x89, 0xCC, 0x94, 0xCD, 0x82,
		0xCD, 0x85, 0xF6, 0xCE, 0xA9, 0xCC, 0x93, 0xCD,
		0x85, 0xF6, 0xCE, 0xA9, 0xCC, 0x94, 0xCD, 0x85,
		0xF6, 0xCE, 0xA9, 0xCC, 0x93, 0xCC, 0x80, 0xCD,
		0x85, 0xF6, 0xCE, 0xA9, 0xCC, 0x94, 0xCC, 0x80,
		0xCD, 0x85, 0xF6, 0xCE, 0xA9, 0xCC, 0x93, 0xCC,
		0x81, 0xCD, 0x85, 0xF6, 0xCE, 0xA9, 0xCC, 0x94,
		0xCC, 0x81, 0xCD, 0x85, 0xF6, 0xCE, 0xA9, 0xCC,
		0x93, 0xCD, 0x82, 0xCD, 0x85, 0xF6, 0xCE, 0xA9,
		0xCC, 0x94, 0xCD, 0x82, 0xCD, 0x85, 0xF6, 0xCE,
		0xB1, 0xCC, 0x86, 0xF6, 0xCE, 0xB1, 0xCC, 0x84,
		0xF6, 0xCE, 0xB1, 0xCC, 0x80, 0xCD, 0x85, 0xF6,
		0xCE, 0xB1, 0xCD, 0x85, 0xF6, 0xCE, 0xB1, 0xCC,
		0x81, 0xCD, 0x85, 0xF6, 0xCE, 0xB1, 0xCD, 0x82,
		0xF6, 0xCE, 0xB1, 0xCD, 0x82, 0xCD, 0x85, 0xF6,
		0xCE, 0x91, 0xCC, 0x86, 0xF6, 0xCE, 0x91, 0xCC,
		0x84, 0xF6, 0xCE, 0x91, 0xCC, 0x80, 0xF6, 0xCE,
		0x91, 0xCC, 0x81, 0xF6, 0xCE, 0x91, 0xCD, 0x85,
		0x20, 0xCC, 0x93, 0xF6, 0xCE, 0xB9, 0x20, 0xCC,
		0x93, 0x20, 0xCD, 0x82, 0xF5, 0x05, 0xC2, 0xA8,
		0xCD, 0x82, 0x20, 0xCC, 0x88, 0xCD, 0x82, 0xF6,
		0xCE, 0xB7, 0xCC, 0x80, 0xCD, 0x85, 0xF6, 0xCE,
		0xB7, 0xCD, 0x85, 0xF6, 0xCE, 0xB7, 0xCC, 0x81,
		0xCD, 0x85, 0xF6, 0xCE, 0xB7, 0xCD, 0x82, 0xF6,
		0xCE, 0xB7, 0xCD, 0x82, 0xCD, 0x85, 0xF6, 0xCE,
		0x95, 0xCC, 0x80, 0xF6, 0xCE, 0x95, 0xCC, 0x81,
		0xF6, 0xCE, 0x97, 0xCC, 0x80, 0xF6, 0xCE, 0x97,
		0xCC, 0x81, 0xF6, 0xCE, 0x97, 0xCD, 0x85, 0xF5,
		0x06, 0xE1, 0xBE, 0xBF, 0xCC, 0x80, 0x20, 0xCC,
		0x93, 0xCC, 0x80, 0xF5, 0x06, 0xE1, 0xBE, 0xBF,
		0xCC, 0x81, 0x20, 0xCC, 0x93, 0xCC, 0x81, 0xF5,
		0x06, 0xE1, 0xBE, 0xBF, 0xCD, 0x82, 0x20, 0xCC,
		0x93, 0xCD, 0x82, 0xF6, 0xCE, 0xB9, 0xCC, 0x86,
		0xF6, 0xCE, 0xB9, 0xCC, 0x84, 0xF6, 0xCE, 0xB9,
		0xCC, 0x88, 0xCC, 0x80, 0xF6, 0xCE, 0xB9, 0xCC,
		0x88, 0xCC, 0x81, 0xF6, 0xCE, 0xB9, 0xCD, 0x82,
		0xF6, 0xCE, 0xB9, 0xCC, 0x88, 0xCD, 0x82, 0xF6,
		0xCE, 0x99, 0xCC, 0x86, 0xF6, 0xCE, 0x99, 0xCC,
		0x84, 0xF6, 0xCE, 0x99, 0xCC, 0x80, 0xF6, 0xCE,
		0x99, 0xCC, 0x81, 0xF5, 0x06, 0xE1, 0xBF, 0xBE,
		0xCC, 0x80, 0x20, 0xCC, 0x94, 0xCC, 0x80, 0xF5,
		0x06, 0xE1, 0xBF, 0xBE, 0xCC, 0x81, 0x20, 0xCC,
		0x94, 0xCC, 0x81, 0xF5, 0x06, 0xE1, 0xBF, 0xBE,
		0xCD, 0x82, 0x20, 0xCC, 0x94, 0xCD, 0x82, 0xF6,
		0xCF, 0x85, 0xCC, 0x86, 0xF6, 0xCF, 0x85, 0xCC,
		0x84, 0xF6, 0xCF, 0x85, 0xCC, 0x88, 0xCC, 0x80,
		0xF6, 0xCF, 0x85, 0xCC, 0x88, 0xCC, 0x81, 0xF6,
		0xCF, 0x81, 0xCC, 0x93, 0xF6, 0xCF, 0x81, 0xCC,
		0x94, 0xF6, 0xCF, 0x85, 0xCD, 0x82, 0xF6, 0xCF,
		0x85, 0xCC, 0x88, 0xCD, 0x82, 0xF6, 0xCE, 0xA5,
		0xCC, 0x86, 0xF6, 0xCE, 0xA5, 0xCC, 0x84, 0xF6,
		0xCE, 0xA5, 0xCC, 0x80, 0xF6, 0xCE, 0xA5, 0xCC,
		0x81, 0xF6, 0xCE, 0xA1, 0xCC, 0x94, 0xF5, 0x05,
		0xC2, 0xA8, 0xCC, 0x80, 0x20, 0xCC, 0x88, 0xCC,
		0x80, 0xF5, 0x05, 0xC2, 0xA8, 0xCC, 0x81, 0x20,
		0xCC, 0x88, 0xCC, 0x81, 0xF6, 0x60, 0xF6, 0xCF,
		0x89, 0xCC, 0x80, 0xCD, 0x85, 0xF6, 0xCF, 0x89,
		0xCD, 0x85, 0xF6, 0xCF, 0x89, 0xCC, 0x81, 0xCD,
		0x85, 0xF6, 0xCF, 0x89, 0xCD, 0x82, 0xF6, 0xCF,
		0x89, 0xCD, 0x82, 0xCD, 0x85, 0xF6, 0xCE, 0x9F,
		0xCC, 0x80, 0xF6, 0xCE, 0x9F, 0xCC, 0x81, 0xF6,
		0xCE, 0xA9, 0xCC, 0x80, 0xF6, 0xCE, 0xA9, 0xCC,
		0x81, 0xF6, 0xCE, 0xA9, 0xCD, 0x85, 0xF5, 0x03,
		0xC2, 0xB4, 0x20, 0xCC, 0x81, 0x20, 0xCC, 0x94,
		0xF5, 0x04, 0xE2, 0x80, 0x82, 0x20, 0xF5, 0x04,
		0xE2, 0x80, 0x83, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0xE2, 0x80, 0x90,
		0x20, 0xCC, 0xB3, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
		0x2E, 0x20, 0xE2, 0x80, 0xB2, 0xE2, 0x80, 0xB2,
		0xE2, 0x80, 0xB2, 0xE2, 0x80, 0xB2, 0xE2, 0x80,
		0xB2, 0xE2, 0x80, 0xB5, 0xE2, 0x80, 0xB5, 0xE2,
		0x80, 0xB5, 0xE2, 0x80, 0xB5, 0xE2, 0x80, 0xB5,
		0x21, 0x21, 0x20, 0xCC, 0x85, 0x3F, 0x3F, 0x3F,
		0x21, 0x21, 0x3F, 0xE2, 0x80, 0xB2, 0xE2, 0x80,
		0xB2, 0xE2, 0x80, 0xB2, 0xE2, 0x80, 0xB2, 0x20,
		0x30, 0x69, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
		0x2B, 0xE2, 0x88, 0x92, 0x3D, 0x28, 0x29, 0x6E,
		0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
		0x38, 0x39, 0x2B, 0xE2, 0x88, 0x92, 0x3D, 0x28,
		0x29, 0x61, 0x65, 0x6F, 0x78, 0xC9, 0x99, 0x52,
		0x73, 0x61, 0x2F, 0x63, 0x61, 0x2F, 0x73, 0x43,
		0xC2, 0xB0, 0x43, 0x63, 0x2F, 0x6F, 0x63, 0x2F,
		0x75, 0xC6, 0x90, 0xC2, 0xB0, 0x46, 0x67, 0x48,
		0x48, 0x48, 0x68, 0xC4, 0xA7, 0x49, 0x49, 0x4C,
		0x6C, 0x4E, 0x4E, 0x6F, 0x50, 0x51, 0x52, 0x52,
		0x52, 0x53, 0x4D, 0x54, 0x45, 0x4C, 0x54, 0x4D,
		0x5A, 0xF6, 0xCE, 0xA9, 0x5A, 0xF6, 0x4B, 0xF6,
		0x41, 0xCC, 0x8A, 0x42, 0x43, 0x65, 0x45, 0x46,
		0x4D, 0x6F, 0xD7, 0x90, 0xD7, 0x91, 0xD7, 0x92,
		0xD7, 0x93, 0x69, 0x46, 0x41, 0x58, 0xCF, 0x80,
		0xCE, 0xB3, 0xCE, 0x93, 0xCE, 0xA0, 0xE2, 0x88,
		0x91, 0x44, 0x64, 0x65, 0x69, 0x6A, 0x31, 0xE2,
		0x81, 0x84, 0x33, 0x32, 0xE2, 0x81, 0x84, 0x33,
		0x31, 0xE2, 0x81, 0x84, 0x35, 0x32, 0xE2, 0x81,
		0x84, 0x35, 0x33, 0xE2, 0x81, 0x84, 0x35, 0x34,
		0xE2, 0x81, 0x84, 0x35, 0x31, 0xE2, 0x81, 0x84,
		0x36, 0x35, 0xE2, 0x81, 0x84, 0x36, 0x31, 0xE2,
		0x81, 0x84, 0x38, 0x33, 0xE2, 0x81, 0x84, 0x38,
		0x35, 0xE2, 0x81, 0x84, 0x38, 0x37, 0xE2, 0x81,
		0x84, 0x38, 0x31, 0xE2, 0x81, 0x84, 0x49, 0x49,
		0x49, 0x49, 0x49, 0x49, 0x49, 0x56, 0x56, 0x56,
		0x49, 0x56, 0x49, 0x49, 0x56, 0x49, 0x49, 0x49,
		0x49, 0x58, 0x58, 0x58, 0x49, 0x58, 0x49, 0x49,
		0x4C, 0x43, 0x44, 0x4D, 0x69, 0x69, 0x69, 0x69,
		0x69, 0x69, 0x69, 0x76, 0x76, 0x76, 0x69, 0x76,
		0x69, 0x69, 0x76, 0x69, 0x69, 0x69, 0x69, 0x78,
		0x78, 0x78, 0x69, 0x78, 0x69, 0x69, 0x6C, 0x63,
		0x64, 0x6D, 0xF6, 0xE2, 0x86, 0x90, 0xCC, 0xB8,
		0xF6, 0xE2, 0x86, 0x92, 0xCC, 0xB8, 0xF6, 0xE2,
		0x86, 0x94, 0xCC, 0xB8, 0xF6, 0xE2, 0x87, 0x90,
		0xCC, 0xB8, 0xF6, 0xE2, 0x87, 0x94, 0xCC, 0xB8,
		0xF6, 0xE2, 0x87, 0x92, 0xCC, 0xB8, 0xF6, 0xE2,
		0x88, 0x83, 0xCC, 0xB8, 0xF6, 0xE2, 0x88, 0x88,
		0xCC, 0xB8, 0xF6, 0xE2, 0x88, 0x8B, 0xCC, 0xB8,
		0xF6, 0xE2, 0x88, 0xA3, 0xCC, 0xB8, 0xF6, 0xE2,
		0x88, 0xA5, 0xCC, 0xB8, 0xE2, 0x88, 0xAB, 0xE2,
		0x88, 0xAB, 0xE2, 0x88, 0xAB, 0xE2, 0x88, 0xAB,
		0xE2, 0x88, 0xAB, 0xE2, 0x88, 0xAE, 0xE2, 0x88,
		0xAE, 0xE2, 0x88, 0xAE, 0xE2, 0x88, 0xAE, 0xE2,
		0x88, 0xAE, 0xF6, 0xE2, 0x88, 0xBC, 0xCC, 0xB8,
		0xF6, 0xE2, 0x89, 0x83, 0xCC, 0xB8, 0xF6, 0xE2,
		0x89, 0x85, 0xCC, 0xB8, 0xF6, 0xE2, 0x89, 0x88,
		0xCC, 0xB8, 0xF6, 0x3D, 0xCC, 0xB8, 0xF6, 0xE2,
		0x89, 0xA1, 0xCC, 0xB8, 0xF6, 0xE2, 0x89, 0x8D,
		0xCC, 0xB8, 0xF6, 0x3C, 0xCC, 0xB8, 0xF6, 0x3E,
		0xCC, 0xB8, 0xF6, 0xE2, 0x89, 0xA4, 0xCC, 0xB8,
		0xF6, 0xE2, 0x89, 0xA5, 0xCC, 0xB8, 0xF6, 0xE2,
		0x89, 0xB2, 0xCC, 0xB8, 0xF6, 0xE2, 0x89, 0xB3,
		0xCC, 0xB8, 0xF6, 0xE2, 0x89, 0xB6, 0xCC, 0xB8,
		0xF6, 0xE2, 0x89, 0xB7, 0xCC, 0xB8, 0xF6, 0xE2,
		0x89, 0xBA, 0xCC, 0xB8, 0xF6, 0xE2, 0x89, 0xBB,
		0xCC, 0xB8, 0xF6, 0xE2, 0x8A, 0x82, 0xCC, 0xB8,
		0xF6, 0xE2, 0x8A, 0x83, 0xCC, 0xB8, 0xF6, 0xE2,
		0x8A, 0x86, 0xCC, 0xB8, 0xF6, 0xE2, 0x8A, 0x87,
		0xCC, 0xB8, 0xF6, 0xE2, 0x8A, 0xA2, 0xCC, 0xB8,
		0xF6, 0xE2, 0x8A, 0xA8, 0xCC, 0xB8, 0xF6, 0xE2,
		0x8A, 0xA9, 0xCC, 0xB8, 0xF6, 0xE2, 0x8A, 0xAB,
		0xCC, 0xB8, 0xF6, 0xE2, 0x89, 0xBC, 0xCC, 0xB8,
		0xF6, 0xE2, 0x89, 0xBD, 0xCC, 0xB8, 0xF6, 0xE2,
		0x8A, 0x91, 0xCC, 0xB8, 0xF6, 0xE2, 0x8A, 0x92,
		0xCC, 0xB8, 0xF6, 0xE2, 0x8A, 0xB2, 0xCC, 0xB8,
		0xF6, 0xE2, 0x8A, 0xB3, 0xCC, 0xB8, 0xF6, 0xE2,
		0x8A, 0xB4, 0xCC, 0xB8, 0xF6, 0xE2, 0x8A, 0xB5,
		0xCC, 0xB8, 0xF6, 0xE3, 0x80, 0x88, 0xF6, 0xE3,
		0x80, 0x89, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x31, 0x30, 0x31, 0x31, 0x31,
		0x32, 0x31, 0x33, 0x31, 0x34, 0x31, 0x35, 0x31,
		0x36, 0x31, 0x37, 0x31, 0x38, 0x31, 0x39, 0x32,
		0x30, 0x28, 0x31, 0x29, 0x28, 0x32, 0x29, 0x28,
		0x33, 0x29, 0x28, 0x34, 0x29, 0x28, 0x35, 0x29,
		0x28, 0x36, 0x29, 0x28, 0x37, 0x29, 0x28, 0x38,
		0x29, 0x28, 0x39, 0x29, 0x28, 0x31, 0x30, 0x29,
		0x28, 0x31, 0x31, 0x29, 0x28, 0x31, 0x32, 0x29,
		0x28, 0x31, 0x33, 0x29, 0x28, 0x31, 0x34, 0x29,
		0x28, 0x31, 0x35, 0x29, 0x28, 0x31, 0x36, 0x29,
		0x28, 0x31, 0x37, 0x29, 0x28, 0x31, 0x38, 0x29,
		0x28, 0x31, 0x39, 0x29, 0x28, 0x32, 0x30, 0x29,
		0x31, 0x2E, 0x32, 0x2E, 0x33, 0x2E, 0x34, 0x2E,
		0x35, 0x2E, 0x36, 0x2E, 0x37, 0x2E, 0x38, 0x2E,
		0x39, 0x2E, 0x31, 0x30, 0x2E, 0x31, 0x31, 0x2E,
		0x31, 0x32, 0x2E, 0x31, 0x33, 0x2E, 0x31, 0x34,
		0x2E, 0x31, 0x35, 0x2E, 0x31, 0x36, 0x2E, 0x31,
		0x37, 0x2E, 0x31, 0x38, 0x2E, 0x31, 0x39, 0x2E,
		0x32, 0x30, 0x2E, 0x28, 0x61, 0x29, 0x28, 0x62,
		0x29, 0x28, 0x63, 0x29, 0x28, 0x64, 0x29, 0x28,
		0x65, 0x29, 0x28, 0x66, 0x29, 0x28, 0x67, 0x29,
		0x28, 0x68, 0x29, 0x28, 0x69, 0x29, 0x28, 0x6A,
		0x29, 0x28, 0x6B, 0x29, 0x28, 0x6C, 0x29, 0x28,
		0x6D, 0x29, 0x28, 0x6E, 0x29, 0x28, 0x6F, 0x29,
		0x28, 0x70, 0x29, 0x28, 0x71, 0x29, 0x28, 0x72,
		0x29, 0x28, 0x73, 0x29, 0x28, 0x74, 0x29, 0x28,
		0x75, 0x29, 0x28, 0x76, 0x29, 0x28, 0x77, 0x29,
		0x28, 0x78, 0x29, 0x28, 0x79, 0x29, 0x28, 0x7A,
		0x29, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0xE2, 0x88,
		0xAB, 0xE2, 0x88, 0xAB, 0xE2, 0x88, 0xAB, 0xE2,
		0x88, 0xAB, 0x3A, 0x3A, 0x3D, 0x3D, 0x3D, 0x3D,
		0x3D, 0x3D, 0xF6, 0xE2, 0xAB, 0x9D, 0xCC, 0xB8,
		0xE2, 0xB5, 0xA1, 0xE6, 0xAF, 0x8D, 0xE9, 0xBE,
		0x9F, 0xE4, 0xB8, 0x80, 0xE4, 0xB8, 0xA8, 0xE4,
		0xB8, 0xB6, 0xE4, 0xB8, 0xBF, 0xE4, 0xB9, 0x99,
		0xE4, 0xBA, 0x85, 0xE4, 0xBA, 0x8C, 0xE4, 0xBA,
		0xA0, 0xE4, 0xBA, 0xBA, 0xE5, 0x84, 0xBF, 0xE5,
		0x85, 0xA5, 0xE5, 0x85, 0xAB, 0xE5, 0x86, 0x82,
		0xE5, 0x86, 0x96, 0xE5, 0x86, 0xAB, 0xE5, 0x87,
		0xA0, 0xE5, 0x87, 0xB5, 0xE5, 0x88, 0x80, 0xE5,
		0x8A, 0x9B, 0xE5, 0x8B, 0xB9, 0xE5, 0x8C, 0x95,
		0xE5, 0x8C, 0x9A, 0xE5, 0x8C, 0xB8, 0xE5, 0x8D,
		0x81, 0xE5, 0x8D, 0x9C, 0xE5, 0x8D, 0xA9, 0xE5,
		0x8E, 0x82, 0xE5, 0x8E, 0xB6, 0xE5, 0x8F, 0x88,
		0xE5, 0x8F, 0xA3, 0xE5, 0x9B, 0x97, 0xE5, 0x9C,
		0x9F, 0xE5, 0xA3, 0xAB, 0xE5, 0xA4, 0x82, 0xE5,
		0xA4, 0x8A, 0xE5, 0xA4, 0x95, 0xE5, 0xA4, 0xA7,
		0xE5, 0xA5, 0xB3, 0xE5, 0xAD, 0x90, 0xE5, 0xAE,
		0x80, 0xE5, 0xAF, 0xB8, 0xE5, 0xB0, 0x8F, 0xE5,
		0xB0, 0xA2, 0xE5, 0xB0, 0xB8, 0xE5, 0xB1, 0xAE,
		0xE5, 0xB1, 0xB1, 0xE5, 0xB7, 0x9B, 0xE5, 0xB7,
		0xA5, 0xE5, 0xB7, 0xB1, 0xE5, 0xB7, 0xBE, 0xE5,
		0xB9, 0xB2, 0xE5, 0xB9, 0xBA, 0xE5, 0xB9, 0xBF,
		0xE5, 0xBB, 0xB4, 0xE5, 0xBB, 0xBE, 0xE5, 0xBC,
		0x8B, 0xE5, 0xBC, 0x93, 0xE5, 0xBD, 0x90, 0xE5,
		0xBD, 0xA1, 0xE5, 0xBD, 0xB3, 0xE5, 0xBF, 0x83,
		0xE6, 0x88, 0x88, 0xE6, 0x88, 0xB6, 0xE6, 0x89,
		0x8B, 0xE6, 0x94, 0xAF, 0xE6, 0x94, 0xB4, 0xE6,
		0x96, 0x87, 0xE6, 0x96, 0x97, 0xE6, 0x96, 0xA4,
		0xE6, 0x96, 0xB9, 0xE6, 0x97, 0xA0, 0xE6, 0x97,
		0xA5, 0xE6, 0x9B, 0xB0, 0xE6, 0x9C, 0x88, 0xE6,
		0x9C, 0xA8, 0xE6, 0xAC, 0xA0, 0xE6, 0xAD, 0xA2,
		0xE6, 0xAD, 0xB9, 0xE6, 0xAE, 0xB3, 0xE6, 0xAF,
		0x8B, 0xE6, 0xAF, 0x94, 0xE6, 0xAF, 0x9B, 0xE6,
		0xB0, 0x8F, 0xE6, 0xB0, 0x94, 0xE6, 0xB0, 0xB4,
		0xE7, 0x81, 0xAB, 0xE7, 0x88, 0xAA, 0xE7, 0x88,
		0xB6, 0xE7, 0x88, 0xBB, 0xE7, 0x88, 0xBF, 0xE7,
		0x89, 0x87, 0xE7, 0x89, 0x99, 0xE7, 0x89, 0x9B,
		0xE7, 0x8A, 0xAC, 0xE7, 0x8E, 0x84, 0xE7, 0x8E,
		0x89, 0xE7, 0x93, 0x9C, 0xE7, 0x93, 0xA6, 0xE7,
		0x94, 0x98, 0xE7, 0x94, 0x9F, 0xE7, 0x94, 0xA8,
		0xE7, 0x94, 0xB0, 0xE7, 0x96, 0x8B, 0xE7, 0x96,
		0x92, 0xE7, 0x99, 0xB6, 0xE7, 0x99, 0xBD, 0xE7,
		0x9A, 0xAE, 0xE7, 0x9A, 0xBF, 0xE7, 0x9B, 0xAE,
		0xE7, 0x9F, 0x9B, 0xE7, 0x9F, 0xA2, 0xE7, 0x9F,
		0xB3, 0xE7, 0xA4, 0xBA, 0xE7, 0xA6, 0xB8, 0xE7,
		0xA6, 0xBE, 0xE7, 0xA9, 0xB4, 0xE7, 0xAB, 0x8B,
		0xE7, 0xAB, 0xB9, 0xE7, 0xB1, 0xB3, 0xE7, 0xB3,
		0xB8, 0xE7, 0xBC, 0xB6, 0xE7, 0xBD, 0x91, 0xE7,
		0xBE, 0x8A, 0xE7, 0xBE, 0xBD, 0xE8, 0x80, 0x81,
		0xE8, 0x80, 0x8C, 0xE8, 0x80, 0x92, 0xE8, 0x80,
		0xB3, 0xE8, 0x81, 0xBF, 0xE8, 0x82, 0x89, 0xE8,
		0x87, 0xA3, 0xE8, 0x87, 0xAA, 0xE8, 0x87, 0xB3,
		0xE8, 0x87, 0xBC, 0xE8, 0x88, 0x8C, 0xE8, 0x88,
		0x9B, 0xE8, 0x88, 0x9F, 0xE8, 0x89, 0xAE, 0xE8,
		0x89, 0xB2, 0xE8, 0x89, 0xB8, 0xE8, 0x99, 0x8D,
		0xE8, 0x99, 0xAB, 0xE8, 0xA1, 0x80, 0xE8, 0xA1,
		0x8C, 0xE8, 0xA1, 0xA3, 0xE8, 0xA5, 0xBE, 0xE8,
		0xA6, 0x8B, 0xE8, 0xA7, 0x92, 0xE8, 0xA8, 0x80,
		0xE8, 0xB0, 0xB7, 0xE8, 0xB1, 0x86, 0xE8, 0xB1,
		0x95, 0xE8, 0xB1, 0xB8, 0xE8, 0xB2, 0x9D, 0xE8,
		0xB5, 0xA4, 0xE8, 0xB5, 0xB0, 0xE8, 0xB6, 0xB3,
		0xE8, 0xBA, 0xAB, 0xE8, 0xBB, 0x8A, 0xE8, 0xBE,
		0x9B, 0xE8, 0xBE, 0xB0, 0xE8, 0xBE, 0xB5, 0xE9,
		0x82, 0x91, 0xE9, 0x85, 0x89, 0xE9, 0x87, 0x86,
		0xE9, 0x87, 0x8C, 0xE9, 0x87, 0x91, 0xE9, 0x95,
		0xB7, 0xE9, 0x96, 0x80, 0xE9, 0x98, 0x9C, 0xE9,
		0x9A, 0xB6, 0xE9, 0x9A, 0xB9, 0xE9, 0x9B, 0xA8,
		0xE9, 0x9D, 0x91, 0xE9, 0x9D, 0x9E, 0xE9, 0x9D,
		0xA2, 0xE9, 0x9D, 0xA9, 0xE9, 0x9F, 0x8B, 0xE9,
		0x9F, 0xAD, 0xE9, 0x9F, 0xB3, 0xE9, 0xA0, 0x81,
		0xE9, 0xA2, 0xA8, 0xE9, 0xA3, 0x9B, 0xE9, 0xA3,
		0x9F, 0xE9, 0xA6, 0x96, 0xE9, 0xA6, 0x99, 0xE9,
		0xA6, 0xAC, 0xE9, 0xAA, 0xA8, 0xE9, 0xAB, 0x98,
		0xE9, 0xAB, 0x9F, 0xE9, 0xAC, 0xA5, 0xE9, 0xAC,
		0xAF, 0xE9, 0xAC, 0xB2, 0xE9, 0xAC, 0xBC, 0xE9,
		0xAD, 0x9A, 0xE9, 0xB3, 0xA5, 0xE9, 0xB9, 0xB5,
		0xE9, 0xB9, 0xBF, 0xE9, 0xBA, 0xA5, 0xE9, 0xBA,
		0xBB, 0xE9, 0xBB, 0x83, 0xE9, 0xBB, 0x8D, 0xE9,
		0xBB, 0x91, 0xE9, 0xBB, 0xB9, 0xE9, 0xBB, 0xBD,
		0xE9, 0xBC, 0x8E, 0xE9, 0xBC, 0x93, 0xE9, 0xBC,
		0xA0, 0xE9, 0xBC, 0xBB, 0xE9, 0xBD, 0x8A, 0xE9,
		0xBD, 0x92, 0xE9, 0xBE, 0x8D, 0xE9, 0xBE, 0x9C,
		0xE9, 0xBE, 0xA0, 0x20, 0xE3, 0x80, 0x92, 0xE5,
		0x8D, 0x81, 0xE5, 0x8D, 0x84, 0xE5, 0x8D, 0x85,
		0xF6, 0xE3, 0x81, 0x8B, 0xE3, 0x82, 0x99, 0xF6,
		0xE3, 0x81, 0x8D, 0xE3, 0x82, 0x99, 0xF6, 0xE3,
		0x81, 0x8F, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x81,
		0x91, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x81, 0x93,
		0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x81, 0x95, 0xE3,
		0x82, 0x99, 0xF6, 0xE3, 0x81, 0x97, 0xE3, 0x82,
		0x99, 0xF6, 0xE3, 0x81, 0x99, 0xE3, 0x82, 0x99,
		0xF6, 0xE3, 0x81, 0x9B, 0xE3, 0x82, 0x99, 0xF6,
		0xE3, 0x81, 0x9D, 0xE3, 0x82, 0x99, 0xF6, 0xE3,
		0x81, 0x9F, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x81,
		0xA1, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x81, 0xA4,
		0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x81, 0xA6, 0xE3,
		0x82, 0x99, 0xF6, 0xE3, 0x81, 0xA8, 0xE3, 0x82,
		0x99, 0xF6, 0xE3, 0x81, 0xAF, 0xE3, 0x82, 0x99,
		0xF6, 0xE3, 0x81, 0xAF, 0xE3, 0x82, 0x9A, 0xF6,
		0xE3, 0x81, 0xB2, 0xE3, 0x82, 0x99, 0xF6, 0xE3,
		0x81, 0xB2, 0xE3, 0x82, 0x9A, 0xF6, 0xE3, 0x81,
		0xB5, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x81, 0xB5,
		0xE3, 0x82, 0x9A, 0xF6, 0xE3, 0x81, 0xB8, 0xE3,
		0x82, 0x99, 0xF6, 0xE3, 0x81, 0xB8, 0xE3, 0x82,
		0x9A, 0xF6, 0xE3, 0x81, 0xBB, 0xE3, 0x82, 0x99,
		0xF6, 0xE3, 0x81, 0xBB, 0xE3, 0x82, 0x9A, 0xF6,
		0xE3, 0x81, 0x86, 0xE3, 0x82, 0x99, 0x20, 0xE3,
		0x82, 0x99, 0x20, 0xE3, 0x82, 0x9A, 0xF6, 0xE3,
		0x82, 0x9D, 0xE3, 0x82, 0x99, 0xE3, 0x82, 0x88,
		0xE3, 0x82, 0x8A, 0xF6, 0xE3, 0x82, 0xAB, 0xE3,
		0x82, 0x99, 0xF6, 0xE3, 0x82, 0xAD, 0xE3, 0x82,
		0x99, 0xF6, 0xE3, 0x82, 0xAF, 0xE3, 0x82, 0x99,
		0xF6, 0xE3, 0x82, 0xB1, 0xE3, 0x82, 0x99, 0xF6,
		0xE3, 0x82, 0xB3, 0xE3, 0x82, 0x99, 0xF6, 0xE3,
		0x82, 0xB5, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x82,
		0xB7, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x82, 0xB9,
		0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x82, 0xBB, 0xE3,
		0x82, 0x99, 0xF6, 0xE3, 0x82, 0xBD, 0xE3, 0x82,
		0x99, 0xF6, 0xE3, 0x82, 0xBF, 0xE3, 0x82, 0x99,
		0xF6, 0xE3, 0x83, 0x81, 0xE3, 0x82, 0x99, 0xF6,
		0xE3, 0x83, 0x84, 0xE3, 0x82, 0x99, 0xF6, 0xE3,
		0x83, 0x86, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x83,
		0x88, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x83, 0x8F,
		0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x83, 0x8F, 0xE3,
		0x82, 0x9A, 0xF6, 0xE3, 0x83, 0x92, 0xE3, 0x82,
		0x99, 0xF6, 0xE3, 0x83, 0x92, 0xE3, 0x82, 0x9A,
		0xF6, 0xE3, 0x83, 0x95, 0xE3, 0x82, 0x99, 0xF6,
		0xE3, 0x83, 0x95, 0xE3, 0x82, 0x9A, 0xF6, 0xE3,
		0x83, 0x98, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x83,
		0x98, 0xE3, 0x82, 0x9A, 0xF6, 0xE3, 0x83, 0x9B,
		0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x83, 0x9B, 0xE3,
		0x82, 0x9A, 0xF6, 0xE3, 0x82, 0xA6, 0xE3, 0x82,
		0x99, 0xF6, 0xE3, 0x83, 0xAF, 0xE3, 0x82, 0x99,
		0xF6, 0xE3, 0x83, 0xB0, 0xE3, 0x82, 0x99, 0xF6,
		0xE3, 0x83, 0xB1, 0xE3, 0x82, 0x99, 0xF6, 0xE3,
		0x83, 0xB2, 0xE3, 0x82, 0x99, 0xF6, 0xE3, 0x83,
		0xBD, 0xE3, 0x82, 0x99, 0xE3, 0x82, 0xB3, 0xE3,
		0x83, 0x88, 0xE1, 0x84, 0x80, 0xE1, 0x84, 0x81,
		0xE1, 0x86, 0xAA, 0xE1, 0x84, 0x82, 0xE1, 0x86,
		0xAC, 0xE1, 0x86, 0xAD, 0xE1, 0x84, 0x83, 0xE1,
		0x84, 0x84, 0xE1, 0x84, 0x85, 0xE1, 0x86, 0xB0,
		0xE1, 0x86, 0xB1, 0xE1, 0x86, 0xB2, 0xE1, 0x86,
		0xB3, 0xE1, 0x86, 0xB4, 0xE1, 0x86, 0xB5, 0xE1,
		0x84, 0x9A, 0xE1, 0x84, 0x86, 0xE1, 0x84, 0x87,
		0xE1, 0x84, 0x88, 0xE1, 0x84, 0xA1, 0xE1, 0x84,
		0x89, 0xE1, 0x84, 0x8A, 0xE1, 0x84, 0x8B, 0xE1,
		0x84, 0x8C, 0xE1, 0x84, 0x8D, 0xE1, 0x84, 0x8E,
		0xE1, 0x84, 0x8F, 0xE1, 0x84, 0x90, 0xE1, 0x84,
		0x91, 0xE1, 0x84, 0x92, 0xE1, 0x85, 0xA1, 0xE1,
		0x85, 0xA2, 0xE1, 0x85, 0xA3, 0xE1, 0x85, 0xA4,
		0xE1, 0x85, 0xA5, 0xE1, 0x85, 0xA6, 0xE1, 0x85,
		0xA7, 0xE1, 0x85, 0xA8, 0xE1, 0x85, 0xA9, 0xE1,
		0x85, 0xAA, 0xE1, 0x85, 0xAB, 0xE1, 0x85, 0xAC,
		0xE1, 0x85, 0xAD, 0xE1, 0x85, 0xAE, 0xE1, 0x85,
		0xAF, 0xE1, 0x85, 0xB0, 0xE1, 0x85, 0xB1, 0xE1,
		0x85, 0xB2, 0xE1, 0x85, 0xB3, 0xE1, 0x85, 0xB4,
		0xE1, 0x85, 0xB5, 0xE1, 0x85, 0xA0, 0xE1, 0x84,
		0x94, 0xE1, 0x84, 0x95, 0xE1, 0x87, 0x87, 0xE1,
		0x87, 0x88, 0xE1, 0x87, 0x8C, 0xE1, 0x87, 0x8E,
		0xE1, 0x87, 0x93, 0xE1, 0x87, 0x97, 0xE1, 0x87,
		0x99, 0xE1, 0x84, 0x9C, 0xE1, 0x87, 0x9D, 0xE1,
		0x87, 0x9F, 0xE1, 0x84, 0x9D, 0xE1, 0x84, 0x9E,
		0xE1, 0x84, 0xA0, 0xE1, 0x84, 0xA2, 0xE1, 0x84,
		0xA3, 0xE1, 0x84, 0xA7, 0xE1, 0x84, 0xA9, 0xE1,
		0x84, 0xAB, 0xE1, 0x84, 0xAC, 0xE1, 0x84, 0xAD,
		0xE1, 0x84, 0xAE, 0xE1, 0x84, 0xAF, 0xE1, 0x84,
		0xB2, 0xE1, 0x84, 0xB6, 0xE1, 0x85, 0x80, 0xE1,
		0x85, 0x87, 0xE1, 0x85, 0x8C, 0xE1, 0x87, 0xB1,
		0xE1, 0x87, 0xB2, 0xE1, 0x85, 0x97, 0xE1, 0x85,
		0x98, 0xE1, 0x85, 0x99, 0xE1, 0x86, 0x84, 0xE1,
		0x86, 0x85, 0xE1, 0x86, 0x88, 0xE1, 0x86, 0x91,
		0xE1, 0x86, 0x92, 0xE1, 0x86, 0x94, 0xE1, 0x86,
		0x9E, 0xE1, 0x86, 0xA1, 0xE4, 0xB8, 0x80, 0xE4,
		0xBA, 0x8C, 0xE4, 0xB8, 0x89, 0xE5, 0x9B, 0x9B,
		0xE4, 0xB8, 0x8A, 0xE4, 0xB8, 0xAD, 0xE4, 0xB8,
		0x8B, 0xE7, 0x94, 0xB2, 0xE4, 0xB9, 0x99, 0xE4,
		0xB8, 0x99, 0xE4, 0xB8, 0x81, 0xE5, 0xA4, 0xA9,
		0xE5, 0x9C, 0xB0, 0xE4, 0xBA, 0xBA, 0x28, 0xE1,
		0x84, 0x80, 0x29, 0x28, 0xE1, 0x84, 0x82, 0x29,
		0x28, 0xE1, 0x84, 0x83, 0x29, 0x28, 0xE1, 0x84,
		0x85, 0x29, 0x28, 0xE1, 0x84, 0x86, 0x29, 0x28,
		0xE1, 0x84, 0x87, 0x29, 0x28, 0xE1, 0x84, 0x89,
		0x29, 0x28, 0xE1, 0x84, 0x8B, 0x29, 0x28, 0xE1,
		0x84, 0x8C, 0x29, 0x28, 0xE1, 0x84, 0x8E, 0x29,
		0x28, 0xE1, 0x84, 0x8F, 0x29, 0x28, 0xE1, 0x84,
		0x90, 0x29, 0x28, 0xE1, 0x84, 0x91, 0x29, 0x28,
		0xE1, 0x84, 0x92, 0x29, 0x28, 0xE1, 0x84, 0x80,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x82,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x83,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x85,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x86,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x87,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x89,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x8B,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x8C,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x8E,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x8F,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x90,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x91,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x92,
		0xE1, 0x85, 0xA1, 0x29, 0x28, 0xE1, 0x84, 0x8C,
		0xE1, 0x85, 0xAE, 0x29, 0x28, 0xE1, 0x84, 0x8B,
		0xE1, 0x85, 0xA9, 0xE1, 0x84, 0x8C, 0xE1, 0x85,
		0xA5, 0xE1, 0x86, 0xAB, 0x29, 0x28, 0xE1, 0x84,
		0x8B, 0xE1, 0x85, 0xA9, 0xE1, 0x84, 0x92, 0xE1,
		0x85, 0xAE, 0x29, 0x28, 0xE4, 0xB8, 0x80, 0x29,
		0x28, 0xE4, 0xBA, 0x8C, 0x29, 0x28, 0xE4, 0xB8,
		0x89, 0x29, 0x28, 0xE5, 0x9B, 0x9B, 0x29, 0x28,
		0xE4, 0xBA, 0x94, 0x29, 0x28, 0xE5, 0x85, 0xAD,
		0x29, 0x28, 0xE4, 0xB8, 0x83, 0x29, 0x28, 0xE5,
		0x85, 0xAB, 0x29, 0x28, 0xE4, 0xB9, 0x9D, 0x29,
		0x28, 0xE5, 0x8D, 0x81, 0x29, 0x28, 0xE6, 0x9C,
		0x88, 0x29, 0x28, 0xE7, 0x81, 0xAB, 0x29, 0x28,
		0xE6, 0xB0, 0xB4, 0x29, 0x28, 0xE6, 0x9C, 0xA8,
		0x29, 0x28, 0xE9, 0x87, 0x91, 0x29, 0x28, 0xE5,
		0x9C, 0x9F, 0x29, 0x28, 0xE6, 0x97, 0xA5, 0x29,
		0x28, 0xE6, 0xA0, 0xAA, 0x29, 0x28, 0xE6, 0x9C,
		0x89, 0x29, 0x28, 0xE7, 0xA4, 0xBE, 0x29, 0x28,
		0xE5, 0x90, 0x8D, 0x29, 0x28, 0xE7, 0x89, 0xB9,
		0x29, 0x28, 0xE8, 0xB2, 0xA1, 0x29, 0x28, 0xE7,
		0xA5, 0x9D, 0x29, 0x28, 0xE5, 0x8A, 0xB4, 0x29,
		0x28, 0xE4, 0xBB, 0xA3, 0x29, 0x28, 0xE5, 0x91,
		0xBC, 0x29, 0x28, 0xE5, 0xAD, 0xA6, 0x29, 0x28,
		0xE7, 0x9B, 0xA3, 0x29, 0x28, 0xE4, 0xBC, 0x81,
		0x29, 0x28, 0xE8, 0xB3, 0x87, 0x29, 0x28, 0xE5,
		0x8D, 0x94, 0x29, 0x28, 0xE7, 0xA5, 0xAD, 0x29,
		0x28, 0xE4, 0xBC, 0x91, 0x29, 0x28, 0xE8, 0x87,
		0xAA, 0x29, 0x28, 0xE8, 0x87, 0xB3, 0x29, 0x50,
		0x54, 0x45, 0x32, 0x31, 0x32, 0x32, 0x32, 0x33,
		0x32, 0x34, 0x32, 0x35, 0x32, 0x36, 0x32, 0x37,
		0x32, 0x38, 0x32, 0x39, 0x33, 0x30, 0x33, 0x31,
		0x33, 0x32, 0x33, 0x33, 0x33, 0x34, 0x33, 0x35,
		0xE1, 0x84, 0x80, 0xE1, 0x84, 0x82, 0xE1, 0x84,
		0x83, 0xE1, 0x84, 0x85, 0xE1, 0x84, 0x86, 0xE1,
		0x84, 0x87, 0xE1, 0x84, 0x89, 0xE1, 0x84, 0x8B,
		0xE1, 0x84, 0x8C, 0xE1, 0x84, 0x8E, 0xE1, 0x84,
		0x8F, 0xE1, 0x84, 0x90, 0xE1, 0x84, 0x91, 0xE1,
		0x84, 0x92, 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xA1,
		0xE1, 0x84, 0x82, 0xE1, 0x85, 0xA1, 0xE1, 0x84,
		0x83, 0xE1, 0x85, 0xA1, 0xE1, 0x84, 0x85, 0xE1,
		0x85, 0xA1, 0xE1, 0x84, 0x86, 0xE1, 0x85, 0xA1,
		0xE1, 0x84, 0x87, 0xE1, 0x85, 0xA1, 0xE1, 0x84,
		0x89, 0xE1, 0x85, 0xA1, 0xE1, 0x84, 0x8B, 0xE1,
		0x85, 0xA1, 0xE1, 0x84, 0x8C, 0xE1, 0x85, 0xA1,
		0xE1, 0x84, 0x8E, 0xE1, 0x85, 0xA1, 0xE1, 0x84,
		0x8F, 0xE1, 0x85, 0xA1, 0xE1, 0x84, 0x90, 0xE1,
		0x85, 0xA1, 0xE1, 0x84, 0x91, 0xE1, 0x85, 0xA1,
		0xE1, 0x84, 0x92, 0xE1, 0x85, 0xA1, 0xE1, 0x84,
		0x8E, 0xE1, 0x85, 0xA1, 0xE1, 0x86, 0xB7, 0xE1,
		0x84, 0x80, 0xE1, 0x85, 0xA9, 0xE1, 0x84, 0x8C,
		0xE1, 0x85, 0xAE, 0xE1, 0x84, 0x8B, 0xE1, 0x85,
		0xB4, 0xE1, 0x84, 0x8B, 0xE1, 0x85, 0xAE, 0xE4,
		0xB8, 0x80, 0xE4, 0xBA, 0x8C, 0xE4, 0xB8, 0x89,
		0xE5, 0x9B, 0x9B, 0xE4, 0xBA, 0x94, 0xE5, 0x85,
		0xAD, 0xE4, 0xB8, 0x83, 0xE5, 0x85, 0xAB, 0xE4,
		0xB9, 0x9D, 0xE5, 0x8D, 0x81, 0xE6, 0x9C, 0x88,
		0xE7, 0x81, 0xAB, 0xE6, 0xB0, 0xB4, 0xE6, 0x9C,
		0xA8, 0xE9, 0x87, 0x91, 0xE5, 0x9C, 0x9F, 0xE6,
		0x97, 0xA5, 0xE6, 0xA0, 0xAA, 0xE6, 0x9C, 0x89,
		0xE7, 0xA4, 0xBE, 0xE5, 0x90, 0x8D, 0xE7, 0x89,
		0xB9, 0xE8, 0xB2, 0xA1, 0xE7, 0xA5, 0x9D, 0xE5,
		0x8A, 0xB4, 0xE7, 0xA7, 0x98, 0xE7, 0x94, 0xB7,
		0xE5, 0xA5, 0xB3, 0xE9, 0x81, 0xA9, 0xE5, 0x84,
		0xAA, 0xE5, 0x8D, 0xB0, 0xE6, 0xB3, 0xA8, 0xE9,
		0xA0, 0x85, 0xE4, 0xBC, 0x91, 0xE5, 0x86, 0x99,
		0xE6, 0xAD, 0xA3, 0xE4, 0xB8, 0x8A, 0xE4, 0xB8,
		0xAD, 0xE4, 0xB8, 0x8B, 0xE5, 0xB7, 0xA6, 0xE5,
		0x8F, 0xB3, 0xE5, 0x8C, 0xBB, 0xE5, 0xAE, 0x97,
		0xE5, 0xAD, 0xA6, 0xE7, 0x9B, 0xA3, 0xE4, 0xBC,
		0x81, 0xE8, 0xB3, 0x87, 0xE5, 0x8D, 0x94, 0xE5,
		0xA4, 0x9C, 0x33, 0x36, 0x33, 0x37, 0x33, 0x38,
		0x33, 0x39, 0x34, 0x30, 0x34, 0x31, 0x34, 0x32,
		0x34, 0x33, 0x34, 0x34, 0x34, 0x35, 0x34, 0x36,
		0x34, 0x37, 0x34, 0x38, 0x34, 0x39, 0x35, 0x30,
		0x31, 0xE6, 0x9C, 0x88, 0x32, 0xE6, 0x9C, 0x88,
		0x33, 0xE6, 0x9C, 0x88, 0x34, 0xE6, 0x9C, 0x88,
		0x35, 0xE6, 0x9C, 0x88, 0x36, 0xE6, 0x9C, 0x88,
		0x37, 0xE6, 0x9C, 0x88, 0x38, 0xE6, 0x9C, 0x88,
		0x39, 0xE6, 0x9C, 0x88, 0x31, 0x30, 0xE6, 0x9C,
		0x88, 0x31, 0x31, 0xE6, 0x9C, 0x88, 0x31, 0x32,
		0xE6, 0x9C, 0x88, 0x48, 0x67, 0x65, 0x72, 0x67,
		0x65, 0x56, 0x4C, 0x54, 0x44, 0xE3, 0x82, 0xA2,
		0xE3, 0x82, 0xA4, 0xE3, 0x82, 0xA6, 0xE3, 0x82,
		0xA8, 0xE3, 0x82, 0xAA, 0xE3, 0x82, 0xAB, 0xE3,
		0x82, 0xAD, 0xE3, 0x82, 0xAF, 0xE3, 0x82, 0xB1,
		0xE3, 0x82, 0xB3, 0xE3, 0x82, 0xB5, 0xE3, 0x82,
		0xB7, 0xE3, 0x82, 0xB9, 0xE3, 0x82, 0xBB, 0xE3,
		0x82, 0xBD, 0xE3, 0x82, 0xBF, 0xE3, 0x83, 0x81,
		0xE3, 0x83, 0x84, 0xE3, 0x83, 0x86, 0xE3, 0x83,
		0x88, 0xE3, 0x83, 0x8A, 0xE3, 0x83, 0x8B, 0xE3,
		0x83, 0x8C, 0xE3, 0x83, 0x8D, 0xE3, 0x83, 0x8E,
		0xE3, 0x83, 0x8F, 0xE3, 0x83, 0x92, 0xE3, 0x83,
		0x95, 0xE3, 0x83, 0x98, 0xE3, 0x83, 0x9B, 0xE3,
		0x83, 0x9E, 0xE3, 0x83, 0x9F, 0xE3, 0x83, 0xA0,
		0xE3, 0x83, 0xA1, 0xE3, 0x83, 0xA2, 0xE3, 0x83,
		0xA4, 0xE3, 0x83, 0xA6, 0xE3, 0x83, 0xA8, 0xE3,
		0x83, 0xA9, 0xE3, 0x83, 0xAA, 0xE3, 0x83, 0xAB,
		0xE3, 0x83, 0xAC, 0xE3, 0x83, 0xAD, 0xE3, 0x83,
		0xAF, 0xE3, 0x83, 0xB0, 0xE3, 0x83, 0xB1, 0xE3,
		0x83, 0xB2, 0xE3, 0x82, 0xA2, 0xE3, 0x83, 0x8F,
		0xE3, 0x82, 0x9A, 0xE3, 0x83, 0xBC, 0xE3, 0x83,
		0x88, 0xE3, 0x82, 0xA2, 0xE3, 0x83, 0xAB, 0xE3,
		0x83, 0x95, 0xE3, 0x82, 0xA1, 0xE3, 0x82, 0xA2,
		0xE3, 0x83, 0xB3, 0xE3, 0x83, 0x98, 0xE3, 0x82,
		0x9A, 0xE3, 0x82, 0xA2, 0xE3, 0x82, 0xA2, 0xE3,
		0x83, 0xBC, 0xE3, 0x83, 0xAB, 0xE3, 0x82, 0xA4,
		0xE3, 0x83, 0x8B, 0xE3, 0x83, 0xB3, 0xE3, 0x82,
		0xAF, 0xE3, 0x82, 0x99, 0xE3, 0x82, 0xA4, 0xE3,
		0x83, 0xB3, 0xE3, 0x83, 0x81, 0xE3, 0x82, 0xA6,
		0xE3, 0x82, 0xA9, 0xE3, 0x83, 0xB3, 0xE3, 0x82,
		0xA8, 0xE3, 0x82, 0xB9, 0xE3, 0x82, 0xAF, 0xE3,
		0x83, 0xBC, 0xE3, 0x83, 0x88, 0xE3, 0x82, 0x99,
		0xE3, 0x82, 0xA8, 0xE3, 0x83, 0xBC, 0xE3, 0x82,
		0xAB, 0xE3, 0x83, 0xBC, 0xE3, 0x82, 0xAA, 0xE3,
		0x83, 0xB3, 0xE3, 0x82, 0xB9, 0xE3, 0x82, 0xAA,
		0xE3, 0x83, 0xBC, 0xE3, 0x83, 0xA0, 0xE3, 0x82,
		0xAB, 0xE3, 0x82, 0xA4, 0xE3, 0x83, 0xAA, 0xE3,
		0x82, 0xAB, 0xE3, 0x83, 0xA9, 0xE3, 0x83, 0x83,
		0xE3, 0x83, 0x88, 0xE3, 0x82, 0xAB, 0xE3, 0x83,
		0xAD, 0xE3, 0x83, 0xAA, 0xE3, 0x83, 0xBC, 0xE3,
		0x82, 0xAB, 0xE3, 0x82, 0x99, 0xE3, 0x83, 0xAD,
		0xE3, 0x83, 0xB3, 0xE3, 0x82, 0xAB, 0xE3, 0x82,
		0x99, 0xE3, 0x83, 0xB3, 0xE3, 0x83, 0x9E, 0xE3,
		0x82, 0xAD, 0xE3, 0x82, 0x99, 0xE3, 0x82, 0xAB,
		0xE3, 0x82, 0x99, 0xE3, 0x82, 0xAD, 0xE3, 0x82,
		0x99, 0xE3, 0x83, 0x8B, 0xE3, 0x83, 0xBC, 0xE3,
		0x82, 0xAD, 0xE3, 0x83, 0xA5, 0xE3, 0x83, 0xAA,
		0xE3, 0x83, 0xBC, 0xE3, 0x82, 0xAD, 0xE3, 0x82,
		0x99, 0xE3, 0x83, 0xAB, 0xE3, 0x82, 0xBF, 0xE3,
		0x82, 0x99, 0xE3, 0x83, 0xBC, 0xE3, 0x82, 0xAD,
		0xE3, 0x83, 0xAD, 0xE3, 0x82, 0xAD, 0xE3, 0x83,
		0xAD, 0xE3, 0x82, 0xAF, 0xE3, 0x82, 0x99, 0xE3,
		0x83, 0xA9, 0xE3, 0x83, 0xA0, 0xE3, 0x82, 0xAD,
		0xE3, 0x83, 0xAD, 0xE3, 0x83, 0xA1, 0xE3, 0x83,
		0xBC, 0xE3, 0x83, 0x88, 0xE3, 0x83, 0xAB, 0xE3,
		0x82, 0xAD, 0xE3, 0x83, 0xAD, 0xE3, 0x83, 0xAF,
		0xE3, 0x83, 0x83, 0xE3, 0x83, 0x88, 0xE3, 0x82,
		0xAF, 0xE3, 0x82, 0x99, 0xE3, 0x83, 0xA9, 0xE3,
		0x83, 0xA0, 0xE3, 0x82, 0xAF, 0xE3, 0x82, 0x99,
		0xE3, 0x83, 0xA9, 0xE3, 0x83, 0xA0, 0xE3, 0x83,
		0x88, 0xE3, 0x83, 0xB3, 0xE3, 0x82, 0xAF, 0xE3,
		0x83, 0xAB, 0xE3, 0x82, 0xBB, 0xE3, 0x82, 0x99,
		0xE3, 0x82, 0xA4, 0xE3, 0x83, 0xAD, 0xE3, 0x82,
		0xAF, 0xE3, 0x83, 0xAD, 0xE3, 0x83, 0xBC, 0xE3,
		0x83, 0x8D, 0xE3, 0x82, 0xB1, 0xE3, 0x83, 0xBC,
		0xE3, 0x82, 0xB9, 0xE3, 0x82, 0xB3, 0xE3, 0x83,
		0xAB, 0xE3, 0x83, 0x8A, 0xE3, 0x82, 0xB3, 0xE3,
		0x83, 0xBC, 0xE3, 0x83, 0x9B, 0xE3, 0x82, 0x9A,
		0xE3, 0x82, 0xB5, 0xE3, 0x82, 0xA4, 0xE3, 0x82,
		0xAF, 0xE3, 0x83, 0xAB, 0xE3, 0x82, 0xB5, 0xE3,
		0x83, 0xB3, 0xE3, 0x83, 0x81, 0xE3, 0x83, 0xBC,
		0xE3, 0x83, 0xA0, 0xE3, 0x82, 0xB7, 0xE3, 0x83,
		0xAA, 0xE3, 0x83, 0xB3, 0xE3, 0x82, 0xAF, 0xE3,
		0x82, 0x99, 0xE3, 0x82, 0xBB, 0xE3, 0x83, 0xB3,
		0xE3, 0x83, 0x81, 0xE3, 0x82, 0xBB, 0xE3, 0x83,
		0xB3, 0xE3, 0x83, 0x88, 0xE3, 0x82, 0xBF, 0xE3,
		0x82, 0x99, 0xE3, 0x83, 0xBC, 0xE3, 0x82, 0xB9,
		0xE3, 0x83, 0x86, 0xE3, 0x82, 0x99, 0xE3, 0x82,
		0xB7, 0xE3, 0x83, 0x88, 0xE3, 0x82, 0x99, 0xE3,
		0x83, 0xAB, 0xE3, 0x83, 0x88, 0xE3, 0x83, 0xB3,
		0xE3, 0x83, 0x8A, 0xE3, 0x83, 0x8E, 0xE3, 0x83,
		0x8E, 0xE3, 0x83, 0x83, 0xE3, 0x83, 0x88, 0xE3,
		0x83, 0x8F, 0xE3, 0x82, 0xA4, 0xE3, 0x83, 0x84,
		0xE3, 0x83, 0x8F, 0xE3, 0x82, 0x9A, 0xE3, 0x83,
		0xBC, 0xE3, 0x82, 0xBB, 0xE3, 0x83, 0xB3, 0xE3,
		0x83, 0x88, 0xE3, 0x83, 0x8F, 0xE3, 0x82, 0x9A,
		0xE3, 0x83, 0xBC, 0xE3, 0x83, 0x84, 0xE3, 0x83,
		0x8F, 0xE3, 0x82, 0x99, 0xE3, 0x83, 0xBC, 0xE3,
		0x83, 0xAC, 0xE3, 0x83, 0xAB, 0xE3, 0x83, 0x92,
		0xE3, 0x82, 0x9A, 0xE3, 0x82, 0xA2, 0xE3, 0x82,
		0xB9, 0xE3, 0x83, 0x88, 0xE3, 0x83, 0xAB, 0xE3,
		0x83, 0x92, 0xE3, 0x82, 0x9A, 0xE3, 0x82, 0xAF,
		0xE3, 0x83, 0xAB, 0xE3, 0x83, 0x92, 0xE3, 0x82,
		0x9A, 0xE3, 0x82, 0xB3, 0xE3, 0x83, 0x92, 0xE3,
		0x82, 0x99, 0xE3, 0x83, 0xAB, 0xE3, 0x83, 0x95,
		0xE3, 0x82, 0xA1, 0xE3, 0x83, 0xA9, 0xE3, 0x83,
		0x83, 0xE3, 0x83, 0x88, 0xE3, 0x82, 0x99, 0xE3,
		0x83, 0x95, 0xE3, 0x82, 0xA3, 0xE3, 0x83, 0xBC,
		0xE3, 0x83, 0x88, 0xE3, 0x83, 0x95, 0xE3, 0x82,
		0x99, 0xE3, 0x83, 0x83, 0xE3, 0x82, 0xB7, 0xE3,
		0x82, 0xA7, 0xE3, 0x83, 0xAB, 0xE3, 0x83, 0x95,
		0xE3, 0x83, 0xA9, 0xE3, 0x83, 0xB3, 0xE3, 0x83,
		0x98, 0xE3, 0x82, 0xAF, 0xE3, 0x82, 0xBF, 0xE3,
		0x83, 0xBC, 0xE3, 0x83, 0xAB, 0xE3, 0x83, 0x98,
		0xE3, 0x82, 0x9A, 0xE3, 0x82, 0xBD, 0xE3, 0x83,
		0x98, 0xE3, 0x82, 0x9A, 0xE3, 0x83, 0x8B, 0xE3,
		0x83, 0x92, 0xE3, 0x83, 0x98, 0xE3, 0x83, 0xAB,
		0xE3, 0x83, 0x84, 0xE3, 0x83, 0x98, 0xE3, 0x82,
		0x9A, 0xE3, 0x83, 0xB3, 0xE3, 0x82, 0xB9, 0xE3,
		0x83, 0x98, 0xE3, 0x82, 0x9A, 0xE3, 0x83, 0xBC,
		0xE3, 0x82, 0xB7, 0xE3, 0x82, 0x99, 0xE3, 0x83,
		0x98, 0xE3, 0x82, 0x99, 0xE3, 0x83, 0xBC, 0xE3,
		0x82, 0xBF, 0xE3, 0x83, 0x9B, 0xE3, 0x82, 0x9A,
		0xE3, 0x82, 0xA4, 0xE3, 0x83, 0xB3, 0xE3, 0x83,
		0x88, 0xE3, 0x83, 0x9B, 0xE3, 0x82, 0x99, 0xE3,
		0x83, 0xAB, 0xE3, 0x83, 0x88, 0xE3, 0x83, 0x9B,
		0xE3, 0x83, 0xB3, 0xE3, 0x83, 0x9B, 0xE3, 0x82,
		0x9A, 0xE3, 0x83, 0xB3, 0xE3, 0x83, 0x88, 0xE3,
		0x82, 0x99, 0xE3, 0x83, 0x9B, 0xE3, 0x83, 0xBC,
		0xE3, 0x83, 0xAB, 0xE3, 0x83, 0x9B, 0xE3, 0x83,
		0xBC, 0xE3, 0x83, 0xB3, 0xE3, 0x83, 0x9E, 0xE3,
		0x82, 0xA4, 0xE3, 0x82, 0xAF, 0xE3, 0x83, 0xAD,
		0xE3, 0x83, 0x9E, 0xE3, 0x82, 0xA4, 0xE3, 0x83,
		0xAB, 0xE3, 0x83, 0x9E, 0xE3, 0x83, 0x83, 0xE3,
		0x83, 0x8F, 0xE3, 0x83, 0x9E, 0xE3, 0x83, 0xAB,
		0xE3, 0x82, 0xAF, 0xE3, 0x83, 0x9E, 0xE3, 0x83,
		0xB3, 0xE3, 0x82, 0xB7, 0xE3, 0x83, 0xA7, 0xE3,
		0x83, 0xB3, 0xE3, 0x83, 0x9F, 0xE3, 0x82, 0xAF,
		0xE3, 0x83, 0xAD, 0xE3, 0x83, 0xB3, 0xE3, 0x83,
		0x9F, 0xE3, 0x83, 0xAA, 0xE3, 0x83, 0x9F, 0xE3,
		0x83, 0xAA, 0xE3, 0x83, 0x8F, 0xE3, 0x82, 0x99,
		0xE3, 0x83, 0xBC, 0xE3, 0x83, 0xAB, 0xE3, 0x83,
		0xA1, 0xE3, 0x82, 0xAB, 0xE3, 0x82, 0x99, 0xE3,
		0x83, 0xA1, 0xE3, 0x82, 0xAB, 0xE3, 0x82, 0x99,
		0xE3, 0x83, 0x88, 0xE3, 0x83, 0xB3, 0xE3, 0x83,
		0xA1, 0xE3, 0x83, 0xBC, 0xE3, 0x83, 0x88, 0xE3,
		0x83, 0xAB, 0xE3, 0x83, 0xA4, 0xE3, 0x83, 0xBC,
		0xE3, 0x83, 0x88, 0xE3, 0x82, 0x99, 0xE3, 0x83,
		0xA4, 0xE3, 0x83, 0xBC, 0xE3, 0x83, 0xAB, 0xE3,
		0x83, 0xA6, 0xE3, 0x82, 0xA2, 0xE3, 0x83, 0xB3,
		0xE3, 0x83, 0xAA, 0xE3, 0x83, 0x83, 0xE3, 0x83,
		0x88, 0xE3, 0x83, 0xAB, 0xE3, 0x83, 0xAA, 0xE3,
		0x83, 0xA9, 0xE3, 0x83, 0xAB, 0xE3, 0x83, 0x92,
		0xE3, 0x82, 0x9A, 0xE3, 0x83, 0xBC, 0xE3, 0x83,
		0xAB, 0xE3, 0x83, 0xBC, 0xE3, 0x83, 0x95, 0xE3,
		0x82, 0x99, 0xE3, 0x83, 0xAB, 0xE3, 0x83, 0xAC,
		0xE3, 0x83, 0xA0, 0xE3, 0x83, 0xAC, 0xE3, 0x83,
		0xB3, 0xE3, 0x83, 0x88, 0xE3, 0x82, 0xB1, 0xE3,
		0x82, 0x99, 0xE3, 0x83, 0xB3, 0xE3, 0x83, 0xAF,
		0xE3, 0x83, 0x83, 0xE3, 0x83, 0x88, 0x30, 0xE7,
		0x82, 0xB9, 0x31, 0xE7, 0x82, 0xB9, 0x32, 0xE7,
		0x82, 0xB9, 0x33, 0xE7, 0x82, 0xB9, 0x34, 0xE7,
		0x82, 0xB9, 0x35, 0xE7, 0x82, 0xB9, 0x36, 0xE7,
		0x82, 0xB9, 0x37, 0xE7, 0x82, 0xB9, 0x38, 0xE7,
		0x82, 0xB9, 0x39, 0xE7, 0x82, 0xB9, 0x31, 0x30,
		0xE7, 0x82, 0xB9, 0x31, 0x31, 0xE7, 0x82, 0xB9,
		0x31, 0x32, 0xE7, 0x82, 0xB9, 0x31, 0x33, 0xE7,
		0x82, 0xB9, 0x31, 0x34, 0xE7, 0x82, 0xB9, 0x31,
		0x35, 0xE7, 0x82, 0xB9, 0x31, 0x36, 0xE7, 0x82,
		0xB9, 0x31, 0x37, 0xE7, 0x82, 0xB9, 0x31, 0x38,
		0xE7, 0x82, 0xB9, 0x31, 0x39, 0xE7, 0x82, 0xB9,
		0x32, 0x30, 0xE7, 0x82, 0xB9, 0x32, 0x31, 0xE7,
		0x82, 0xB9, 0x32, 0x32, 0xE7, 0x82, 0xB9, 0x32,
		0x33, 0xE7, 0x82, 0xB9, 0x32, 0x34, 0xE7, 0x82,
		0xB9, 0x68, 0x50, 0x61, 0x64, 0x61, 0x41, 0x55,
		0x62, 0x61, 0x72, 0x6F, 0x56, 0x70, 0x63, 0x64,
		0x6D, 0x64, 0x6D, 0x32, 0x64, 0x6D, 0x33, 0x49,
		0x55, 0xE5, 0xB9, 0xB3, 0xE6, 0x88, 0x90, 0xE6,
		0x98, 0xAD, 0xE5, 0x92, 0x8C, 0xE5, 0xA4, 0xA7,
		0xE6, 0xAD, 0xA3, 0xE6, 0x98, 0x8E, 0xE6, 0xB2,
		0xBB, 0xE6, 0xA0, 0xAA, 0xE5, 0xBC, 0x8F, 0xE4,
		0xBC, 0x9A, 0xE7, 0xA4, 0xBE, 0x70, 0x41, 0x6E,
		0x41, 0xCE, 0xBC, 0x41, 0x6D, 0x41, 0x6B, 0x41,
		0x4B, 0x42, 0x4D, 0x42, 0x47, 0x42, 0x63, 0x61,
		0x6C, 0x6B, 0x63, 0x61, 0x6C, 0x70, 0x46, 0x6E,
		0x46, 0xCE, 0xBC, 0x46, 0xCE, 0xBC, 0x67, 0x6D,
		0x67, 0x6B, 0x67, 0x48, 0x7A, 0x6B, 0x48, 0x7A,
		0x4D, 0x48, 0x7A, 0x47, 0x48, 0x7A, 0x54, 0x48,
		0x7A, 0xCE, 0xBC, 0x6C, 0x6D, 0x6C, 0x64, 0x6C,
		0x6B, 0x6C, 0x66, 0x6D, 0x6E, 0x6D, 0xCE, 0xBC,
		0x6D, 0x6D, 0x6D, 0x63, 0x6D, 0x6B, 0x6D, 0x6D,
		0x6D, 0x32, 0x63, 0x6D, 0x32, 0x6D, 0x32, 0x6B,
		0x6D, 0x32, 0x6D, 0x6D, 0x33, 0x63, 0x6D, 0x33,
		0x6D, 0x33, 0x6B, 0x6D, 0x33, 0x6D, 0xE2, 0x88,
		0x95, 0x73, 0x6D, 0xE2, 0x88, 0x95, 0x73, 0x32,
		0x50, 0x61, 0x6B, 0x50, 0x61, 0x4D, 0x50, 0x61,
		0x47, 0x50, 0x61, 0x72, 0x61, 0x64, 0x72, 0x61,
		0x64, 0xE2, 0x88, 0x95, 0x73, 0x72, 0x61, 0x64,
		0xE2, 0x88, 0x95, 0x73, 0x32, 0x70, 0x73, 0x6E,
		0x73, 0xCE, 0xBC, 0x73, 0x6D, 0x73, 0x70, 0x56,
		0x6E, 0x56, 0xCE, 0xBC, 0x56, 0x6D, 0x56, 0x6B,
		0x56, 0x4D, 0x56, 0x70, 0x57, 0x6E, 0x57, 0xCE,
		0xBC, 0x57, 0x6D, 0x57, 0x6B, 0x57, 0x4D, 0x57,
		0x6B, 0xCE, 0xA9, 0x4D, 0xCE, 0xA9, 0x61, 0x2E,
		0x6D, 0x2E, 0x42, 0x71, 0x63, 0x63, 0x63, 0x64,
		0x43, 0xE2, 0x88, 0x95, 0x6B, 0x67, 0x43, 0x6F,
		0x2E, 0x64, 0x42, 0x47, 0x79, 0x68, 0x61, 0x48,
		0x50, 0x69, 0x6E, 0x4B, 0x4B, 0x4B, 0x4D, 0x6B,
		0x74, 0x6C, 0x6D, 0x6C, 0x6E, 0x6C, 0x6F, 0x67,
		0x6C, 0x78, 0x6D, 0x62, 0x6D, 0x69, 0x6C, 0x6D,
		0x6F, 0x6C, 0x50, 0x48, 0x70, 0x2E, 0x6D, 0x2E,
		0x50, 0x50, 0x4D, 0x50, 0x52, 0x73, 0x72, 0x53,
		0x76, 0x57, 0x62, 0x56, 0xE2, 0x88, 0x95, 0x6D,
		0x41, 0xE2, 0x88, 0x95, 0x6D, 0x31, 0xE6, 0x97,
		0xA5, 0x32, 0xE6, 0x97, 0xA5, 0x33, 0xE6, 0x97,
		0xA5, 0x34, 0xE6, 0x97, 0xA5, 0x35, 0xE6, 0x97,
		0xA5, 0x36, 0xE6, 0x97, 0xA5, 0x37, 0xE6, 0x97,
		0xA5, 0x38, 0xE6, 0x97, 0xA5, 0x39, 0xE6, 0x97,
		0xA5, 0x31, 0x30, 0xE6, 0x97, 0xA5, 0x31, 0x31,
		0xE6, 0x97, 0xA5, 0x31, 0x32, 0xE6, 0x97, 0xA5,
		0x31, 0x33, 0xE6, 0x97, 0xA5, 0x31, 0x34, 0xE6,
		0x97, 0xA5, 0x31, 0x35, 0xE6, 0x97, 0xA5, 0x31,
		0x36, 0xE6, 0x97, 0xA5, 0x31, 0x37, 0xE6, 0x97,
		0xA5, 0x31, 0x38, 0xE6, 0x97, 0xA5, 0x31, 0x39,
		0xE6, 0x97, 0xA5, 0x32, 0x30, 0xE6, 0x97, 0xA5,
		0x32, 0x31, 0xE6, 0x97, 0xA5, 0x32, 0x32, 0xE6,
		0x97, 0xA5, 0x32, 0x33, 0xE6, 0x97, 0xA5, 0x32,
		0x34, 0xE6, 0x97, 0xA5, 0x32, 0x35, 0xE6, 0x97,
		0xA5, 0x32, 0x36, 0xE6, 0x97, 0xA5, 0x32, 0x37,
		0xE6, 0x97, 0xA5, 0x32, 0x38, 0xE6, 0x97, 0xA5,
		0x32, 0x39, 0xE6, 0x97, 0xA5, 0x33, 0x30, 0xE6,
		0x97, 0xA5, 0x33, 0x31, 0xE6, 0x97, 0xA5, 0x67,
		0x61, 0x6C, 0xF6, 0xE8, 0xB1, 0x88, 0xF6, 0xE6,
		0x9B, 0xB4, 0xF6, 0xE8, 0xBB, 0x8A, 0xF6, 0xE8,
		0xB3, 0x88, 0xF6, 0xE6, 0xBB, 0x91, 0xF6, 0xE4,
		0xB8, 0xB2, 0xF6, 0xE5, 0x8F, 0xA5, 0xF6, 0xE9,
		0xBE, 0x9C, 0xF6, 0xE9, 0xBE, 0x9C, 0xF6, 0xE5,
		0xA5, 0x91, 0xF6, 0xE9, 0x87, 0x91, 0xF6, 0xE5,
		0x96, 0x87, 0xF6, 0xE5, 0xA5, 0x88, 0xF6, 0xE6,
		0x87, 0xB6, 0xF6, 0xE7, 0x99, 0xA9, 0xF6, 0xE7,
		0xBE, 0x85, 0xF6, 0xE8, 0x98, 0xBF, 0xF6, 0xE8,
		0x9E, 0xBA, 0xF6, 0xE8, 0xA3, 0xB8, 0xF6, 0xE9,
		0x82, 0x8F, 0xF6, 0xE6, 0xA8, 0x82, 0xF6, 0xE6,
		0xB4, 0x9B, 0xF6, 0xE7, 0x83, 0x99, 0xF6, 0xE7,
		0x8F, 0x9E, 0xF6, 0xE8, 0x90, 0xBD, 0xF6, 0xE9,
		0x85, 0xAA, 0xF6, 0xE9, 0xA7, 0xB1, 0xF6, 0xE4,
		0xBA, 0x82, 0xF6, 0xE5, 0x8D, 0xB5, 0xF6, 0xE6,
		0xAC, 0x84, 0xF6, 0xE7, 0x88, 0x9B, 0xF6, 0xE8,
		0x98, 0xAD, 0xF6, 0xE9, 0xB8, 0x9E, 0xF6, 0xE5,
		0xB5, 0x90, 0xF6, 0xE6, 0xBF, 0xAB, 0xF6, 0xE8,
		0x97, 0x8D, 0xF6, 0xE8, 0xA5, 0xA4, 0xF6, 0xE6,
		0x8B, 0x89, 0xF6, 0xE8, 0x87, 0x98, 0xF6, 0xE8,
		0xA0, 0x9F, 0xF6, 0xE5, 0xBB, 0x8A, 0xF6, 0xE6,
		0x9C, 0x97, 0xF6, 0xE6, 0xB5, 0xAA, 0xF6, 0xE7,
		0x8B, 0xBC, 0xF6, 0xE9, 0x83, 0x8E, 0xF6, 0xE4,
		0xBE, 0x86, 0xF6, 0xE5, 0x86, 0xB7, 0xF6, 0xE5,
		0x8B, 0x9E, 0xF6, 0xE6, 0x93, 0x84, 0xF6, 0xE6,
		0xAB, 0x93, 0xF6, 0xE7, 0x88, 0x90, 0xF6, 0xE7,
		0x9B, 0xA7, 0xF6, 0xE8, 0x80, 0x81, 0xF6, 0xE8,
		0x98, 0x86, 0xF6, 0xE8, 0x99, 0x9C, 0xF6, 0xE8,
		0xB7, 0xAF, 0xF6, 0xE9, 0x9C, 0xB2, 0xF6, 0xE9,
		0xAD, 0xAF, 0xF6, 0xE9, 0xB7, 0xBA, 0xF6, 0xE7,
		0xA2, 0x8C, 0xF6, 0xE7, 0xA5, 0xBF, 0xF6, 0xE7,
		0xB6, 0xA0, 0xF6, 0xE8, 0x8F, 0x89, 0xF6, 0xE9,
		0x8C, 0x84, 0xF6, 0xE9, 0xB9, 0xBF, 0xF6, 0xE8,
		0xAB, 0x96, 0xF6, 0xE5, 0xA3, 0x9F, 0xF6, 0xE5,
		0xBC, 0x84, 0xF6, 0xE7, 0xB1, 0xA0, 0xF6, 0xE8,
		0x81, 0xBE, 0xF6, 0xE7, 0x89, 0xA2, 0xF6, 0xE7,
		0xA3, 0x8A, 0xF6, 0xE8, 0xB3, 0x82, 0xF6, 0xE9,
		0x9B, 0xB7, 0xF6, 0xE5, 0xA3, 0x98, 0xF6, 0xE5,
		0xB1, 0xA2, 0xF6, 0xE6, 0xA8, 0x93, 0xF6, 0xE6,
		0xB7, 0x9A, 0xF6, 0xE6, 0xBC, 0x8F, 0xF6, 0xE7,
		0xB4, 0xAF, 0xF6, 0xE7, 0xB8, 0xB7, 0xF6, 0xE9,
		0x99, 0x8B, 0xF6, 0xE5, 0x8B, 0x92, 0xF6, 0xE8,
		0x82, 0x8B, 0xF6, 0xE5, 0x87, 0x9C, 0xF6, 0xE5,
		0x87, 0x8C, 0xF6, 0xE7, 0xA8, 0x9C, 0xF6, 0xE7,
		0xB6, 0xBE, 0xF6, 0xE8, 0x8F, 0xB1, 0xF6, 0xE9,
		0x99, 0xB5, 0xF6, 0xE8, 0xAE, 0x80, 0xF6, 0xE6,
		0x8B, 0x8F, 0xF6, 0xE6, 0xA8, 0x82, 0xF6, 0xE8,
		0xAB, 0xBE, 0xF6, 0xE4, 0xB8, 0xB9, 0xF6, 0xE5,
		0xAF, 0xA7, 0xF6, 0xE6, 0x80, 0x92, 0xF6, 0xE7,
		0x8E, 0x87, 0xF6, 0xE7, 0x95, 0xB0, 0xF6, 0xE5,
		0x8C, 0x97, 0xF6, 0xE7, 0xA3, 0xBB, 0xF6, 0xE4,
		0xBE, 0xBF, 0xF6, 0xE5, 0xBE, 0xA9, 0xF6, 0xE4,
		0xB8, 0x8D, 0xF6, 0xE6, 0xB3, 0x8C, 0xF6, 0xE6,
		0x95, 0xB8, 0xF6, 0xE7, 0xB4, 0xA2, 0xF6, 0xE5,
		0x8F, 0x83, 0xF6, 0xE5, 0xA1, 0x9E, 0xF6, 0xE7,
		0x9C, 0x81, 0xF6, 0xE8, 0x91, 0x89, 0xF6, 0xE8,
		0xAA, 0xAA, 0xF6, 0xE6, 0xAE, 0xBA, 0xF6, 0xE8,
		0xBE, 0xB0, 0xF6, 0xE6, 0xB2, 0x88, 0xF6, 0xE6,
		0x8B, 0xBE, 0xF6, 0xE8, 0x8B, 0xA5, 0xF6, 0xE6,
		0x8E, 0xA0, 0xF6, 0xE7, 0x95, 0xA5, 0xF6, 0xE4,
		0xBA, 0xAE, 0xF6, 0xE5, 0x85, 0xA9, 0xF6, 0xE5,
		0x87, 0x89, 0xF6, 0xE6, 0xA2, 0x81, 0xF6, 0xE7,
		0xB3, 0xA7, 0xF6, 0xE8, 0x89, 0xAF, 0xF6, 0xE8,
		0xAB, 0x92, 0xF6, 0xE9, 0x87, 0x8F, 0xF6, 0xE5,
		0x8B, 0xB5, 0xF6, 0xE5, 0x91, 0x82, 0xF6, 0xE5,
		0xA5, 0xB3, 0xF6, 0xE5, 0xBB, 0xAC, 0xF6, 0xE6,
		0x97, 0x85, 0xF6, 0xE6, 0xBF, 0xBE, 0xF6, 0xE7,
		0xA4, 0xAA, 0xF6, 0xE9, 0x96, 0xAD, 0xF6, 0xE9,
		0xA9, 0xAA, 0xF6, 0xE9, 0xBA, 0x97, 0xF6, 0xE9,
		0xBB, 0x8E, 0xF6, 0xE5, 0x8A, 0x9B, 0xF6, 0xE6,
		0x9B, 0x86, 0xF6, 0xE6, 0xAD, 0xB7, 0xF6, 0xE8,
		0xBD, 0xA2, 0xF6, 0xE5, 0xB9, 0xB4, 0xF6, 0xE6,
		0x86, 0x90, 0xF6, 0xE6, 0x88, 0x80, 0xF6, 0xE6,
		0x92, 0x9A, 0xF6, 0xE6, 0xBC, 0xA3, 0xF6, 0xE7,
		0x85, 0x89, 0xF6, 0xE7, 0x92, 0x89, 0xF6, 0xE7,
		0xA7, 0x8A, 0xF6, 0xE7, 0xB7, 0xB4, 0xF6, 0xE8,
		0x81, 0xAF, 0xF6, 0xE8, 0xBC, 0xA6, 0xF6, 0xE8,
		0x93, 0xAE, 0xF6, 0xE9, 0x80, 0xA3, 0xF6, 0xE9,
		0x8D, 0x8A, 0xF6, 0xE5, 0x88, 0x97, 0xF6, 0xE5,
		0x8A, 0xA3, 0xF6, 0xE5, 0x92, 0xBD, 0xF6, 0xE7,
		0x83, 0x88, 0xF6, 0xE8, 0xA3, 0x82, 0xF6, 0xE8,
		0xAA, 0xAA, 0xF6, 0xE5, 0xBB, 0x89, 0xF6, 0xE5,
		0xBF, 0xB5, 0xF6, 0xE6, 0x8D, 0xBB, 0xF6, 0xE6,
		0xAE, 0xAE, 0xF6, 0xE7, 0xB0, 0xBE, 0xF6, 0xE7,
		0x8D, 0xB5, 0xF6, 0xE4, 0xBB, 0xA4, 0xF6, 0xE5,
		0x9B, 0xB9, 0xF6, 0xE5, 0xAF, 0xA7, 0xF6, 0xE5,
		0xB6, 0xBA, 0xF6, 0xE6, 0x80, 0x9C, 0xF6, 0xE7,
		0x8E, 0xB2, 0xF6, 0xE7, 0x91, 0xA9, 0xF6, 0xE7,
		0xBE, 0x9A, 0xF6, 0xE8, 0x81, 0x86, 0xF6, 0xE9,
		0x88, 0xB4, 0xF6, 0xE9, 0x9B, 0xB6, 0xF6, 0xE9,
		0x9D, 0x88, 0xF6, 0xE9, 0xA0, 0x98, 0xF6, 0xE4,
		0xBE, 0x8B, 0xF6, 0xE7, 0xA6, 0xAE, 0xF6, 0xE9,
		0x86, 0xB4, 0xF6, 0xE9, 0x9A, 0xB8, 0xF6, 0xE6,
		0x83, 0xA1, 0xF6, 0xE4, 0xBA, 0x86, 0xF6, 0xE5,
		0x83, 0x9A, 0xF6, 0xE5, 0xAF, 0xAE, 0xF6, 0xE5,
		0xB0, 0xBF, 0xF6, 0xE6, 0x96, 0x99, 0xF6, 0xE6,
		0xA8, 0x82, 0xF6, 0xE7, 0x87, 0x8E, 0xF6, 0xE7,
		0x99, 0x82, 0xF6, 0xE8, 0x93, 0xBC, 0xF6, 0xE9,
		0x81, 0xBC, 0xF6, 0xE9, 0xBE, 0x8D, 0xF6, 0xE6,
		0x9A, 0x88, 0xF6, 0xE9, 0x98, 0xAE, 0xF6, 0xE5,
		0x8A, 0x89, 0xF6, 0xE6, 0x9D, 0xBB, 0xF6, 0xE6,
		0x9F, 0xB3, 0xF6, 0xE6, 0xB5, 0x81, 0xF6, 0xE6,
		0xBA, 0x9C, 0xF6, 0xE7, 0x90, 0x89, 0xF6, 0xE7,
		0x95, 0x99, 0xF6, 0xE7, 0xA1, 0xAB, 0xF6, 0xE7,
		0xB4, 0x90, 0xF6, 0xE9, 0xA1, 0x9E, 0xF6, 0xE5,
		0x85, 0xAD, 0xF6, 0xE6, 0x88, 0xAE, 0xF6, 0xE9,
		0x99, 0xB8, 0xF6, 0xE5, 0x80, 0xAB, 0xF6, 0xE5,
		0xB4, 0x99, 0xF6, 0xE6, 0xB7, 0xAA, 0xF6, 0xE8,
		0xBC, 0xAA, 0xF6, 0xE5, 0xBE, 0x8B, 0xF6, 0xE6,
		0x85, 0x84, 0xF6, 0xE6, 0xA0, 0x97, 0xF6, 0xE7,
		0x8E, 0x87, 0xF6, 0xE9, 0x9A, 0x86, 0xF6, 0xE5,
		0x88, 0xA9, 0xF6, 0xE5, 0x90, 0x8F, 0xF6, 0xE5,
		0xB1, 0xA5, 0xF6, 0xE6, 0x98, 0x93, 0xF6, 0xE6,
		0x9D, 0x8E, 0xF6, 0xE6, 0xA2, 0xA8, 0xF6, 0xE6,
		0xB3, 0xA5, 0xF6, 0xE7, 0x90, 0x86, 0xF6, 0xE7,
		0x97, 0xA2, 0xF6, 0xE7, 0xBD, 0xB9, 0xF6, 0xE8,
		0xA3, 0x8F, 0xF6, 0xE8, 0xA3, 0xA1, 0xF6, 0xE9,
		0x87, 0x8C, 0xF6, 0xE9, 0x9B, 0xA2, 0xF6, 0xE5,
		0x8C, 0xBF, 0xF6, 0xE6, 0xBA, 0xBA, 0xF6, 0xE5,
		0x90, 0x9D, 0xF6, 0xE7, 0x87, 0x90, 0xF6, 0xE7,
		0x92, 0x98, 0xF6, 0xE8, 0x97, 0xBA, 0xF6, 0xE9,
		0x9A, 0xA3, 0xF6, 0xE9, 0xB1, 0x97, 0xF6, 0xE9,
		0xBA, 0x9F, 0xF6, 0xE6, 0x9E, 0x97, 0xF6, 0xE6,
		0xB7, 0x8B, 0xF6, 0xE8, 0x87, 0xA8, 0xF6, 0xE7,
		0xAB, 0x8B, 0xF6, 0xE7, 0xAC, 0xA0, 0xF6, 0xE7,
		0xB2, 0x92, 0xF6, 0xE7, 0x8B, 0x80, 0xF6, 0xE7,
		0x82, 0x99, 0xF6, 0xE8, 0xAD, 0x98, 0xF6, 0xE4,
		0xBB, 0x80, 0xF6, 0xE8, 0x8C, 0xB6, 0xF6, 0xE5,
		0x88, 0xBA, 0xF6, 0xE5, 0x88, 0x87, 0xF6, 0xE5,
		0xBA, 0xA6, 0xF6, 0xE6, 0x8B, 0x93, 0xF6, 0xE7,
		0xB3, 0x96, 0xF6, 0xE5, 0xAE, 0x85, 0xF6, 0xE6,
		0xB4, 0x9E, 0xF6, 0xE6, 0x9A, 0xB4, 0xF6, 0xE8,
		0xBC, 0xBB, 0xF6, 0xE8, 0xA1, 0x8C, 0xF6, 0xE9,
		0x99, 0x8D, 0xF6, 0xE8, 0xA6, 0x8B, 0xF6, 0xE5,
		0xBB, 0x93, 0xF6, 0xE5, 0x85, 0x80, 0xF6, 0xE5,
		0x97, 0x80, 0xF6, 0xE5, 0xA1, 0x9A, 0xF6, 0xE6,
		0x99, 0xB4, 0xF6, 0xE5, 0x87, 0x9E, 0xF6, 0xE7,
		0x8C, 0xAA, 0xF6, 0xE7, 0x9B, 0x8A, 0xF6, 0xE7,
		0xA4, 0xBC, 0xF6, 0xE7, 0xA5, 0x9E, 0xF6, 0xE7,
		0xA5, 0xA5, 0xF6, 0xE7, 0xA6, 0x8F, 0xF6, 0xE9,
		0x9D, 0x96, 0xF6, 0xE7, 0xB2, 0xBE, 0xF6, 0xE7,
		0xBE, 0xBD, 0xF6, 0xE8, 0x98, 0x92, 0xF6, 0xE8,
		0xAB, 0xB8, 0xF6, 0xE9, 0x80, 0xB8, 0xF6, 0xE9,
		0x83, 0xBD, 0xF6, 0xE9, 0xA3, 0xAF, 0xF6, 0xE9,
		0xA3, 0xBC, 0xF6, 0xE9, 0xA4, 0xA8, 0xF6, 0xE9,
		0xB6, 0xB4, 0xF6, 0xE4, 0xBE, 0xAE, 0xF6, 0xE5,
		0x83, 0xA7, 0xF6, 0xE5, 0x85, 0x8D, 0xF6, 0xE5,
		0x8B, 0x89, 0xF6, 0xE5, 0x8B, 0xA4, 0xF6, 0xE5,
		0x8D, 0x91, 0xF6, 0xE5, 0x96, 0x9D, 0xF6, 0xE5,
		0x98, 0x86, 0xF6, 0xE5, 0x99, 0xA8, 0xF6, 0xE5,
		0xA1, 0x80, 0xF6, 0xE5, 0xA2, 0xA8, 0xF6, 0xE5,
		0xB1, 0xA4, 0xF6, 0xE5, 0xB1, 0xAE, 0xF6, 0xE6,
		0x82, 0x94, 0xF6, 0xE6, 0x85, 0xA8, 0xF6, 0xE6,
		0x86, 0x8E, 0xF6, 0xE6, 0x87, 0xB2, 0xF6, 0xE6,
		0x95, 0x8F, 0xF6, 0xE6, 0x97, 0xA2, 0xF6, 0xE6,
		0x9A, 0x91, 0xF6, 0xE6, 0xA2, 0x85, 0xF6, 0xE6,
		0xB5, 0xB7, 0xF6, 0xE6, 0xB8, 0x9A, 0xF6, 0xE6,
		0xBC, 0xA2, 0xF6, 0xE7, 0x85, 0xAE, 0xF6, 0xE7,
		0x88, 0xAB, 0xF6, 0xE7, 0x90, 0xA2, 0xF6, 0xE7,
		0xA2, 0x91, 0xF6, 0xE7, 0xA4, 0xBE, 0xF6, 0xE7,
		0xA5, 0x89, 0xF6, 0xE7, 0xA5, 0x88, 0xF6, 0xE7,
		0xA5, 0x90, 0xF6, 0xE7, 0xA5, 0x96, 0xF6, 0xE7,
		0xA5, 0x9D, 0xF6, 0xE7, 0xA6, 0x8D, 0xF6, 0xE7,
		0xA6, 0x8E, 0xF6, 0xE7, 0xA9, 0x80, 0xF6, 0xE7,
		0xAA, 0x81, 0xF6, 0xE7, 0xAF, 0x80, 0xF6, 0xE7,
		0xB7, 0xB4, 0xF6, 0xE7, 0xB8, 0x89, 0xF6, 0xE7,
		0xB9, 0x81, 0xF6, 0xE7, 0xBD, 0xB2, 0xF6, 0xE8,
		0x80, 0x85, 0xF6, 0xE8, 0x87, 0xAD, 0xF6, 0xE8,
		0x89, 0xB9, 0xF6, 0xE8, 0x89, 0xB9, 0xF6, 0xE8,
		0x91, 0x97, 0xF6, 0xE8, 0xA4, 0x90, 0xF6, 0xE8,
		0xA6, 0x96, 0xF6, 0xE8, 0xAC, 0x81, 0xF6, 0xE8,
		0xAC, 0xB9, 0xF6, 0xE8, 0xB3, 0x93, 0xF6, 0xE8,
		0xB4, 0x88, 0xF6, 0xE8, 0xBE, 0xB6, 0xF6, 0xE9,
		0x80, 0xB8, 0xF6, 0xE9, 0x9B, 0xA3, 0xF6, 0xE9,
		0x9F, 0xBF, 0xF6, 0xE9, 0xA0, 0xBB, 0xF6, 0xE4,
		0xB8, 0xA6, 0xF6, 0xE5, 0x86, 0xB5, 0xF6, 0xE5,
		0x85, 0xA8, 0xF6, 0xE4, 0xBE, 0x80, 0xF6, 0xE5,
		0x85, 0x85, 0xF6, 0xE5, 0x86, 0x80, 0xF6, 0xE5,
		0x8B, 0x87, 0xF6, 0xE5, 0x8B, 0xBA, 0xF6, 0xE5,
		0x96, 0x9D, 0xF6, 0xE5, 0x95, 0x95, 0xF6, 0xE5,
		0x96, 0x99, 0xF6, 0xE5, 0x97, 0xA2, 0xF6, 0xE5,
		0xA1, 0x9A, 0xF6, 0xE5, 0xA2, 0xB3, 0xF6, 0xE5,
		0xA5, 0x84, 0xF6, 0xE5, 0xA5, 0x94, 0xF6, 0xE5,
		0xA9, 0xA2, 0xF6, 0xE5, 0xAC, 0xA8, 0xF6, 0xE5,
		0xBB, 0x92, 0xF6, 0xE5, 0xBB, 0x99, 0xF6, 0xE5,
		0xBD, 0xA9, 0xF6, 0xE5, 0xBE, 0xAD, 0xF6, 0xE6,
		0x83, 0x98, 0xF6, 0xE6, 0x85, 0x8E, 0xF6, 0xE6,
		0x84, 0x88, 0xF6, 0xE6, 0x86, 0x8E, 0xF6, 0xE6,
		0x85, 0xA0, 0xF6, 0xE6, 0x87, 0xB2, 0xF6, 0xE6,
		0x88, 0xB4, 0xF6, 0xE6, 0x8F, 0x84, 0xF6, 0xE6,
		0x90, 0x9C, 0xF6, 0xE6, 0x91, 0x92, 0xF6, 0xE6,
		0x95, 0x96, 0xF6, 0xE6, 0x99, 0xB4, 0xF6, 0xE6,
		0x9C, 0x97, 0xF6, 0xE6, 0x9C, 0x9B, 0xF6, 0xE6,
		0x9D, 0x96, 0xF6, 0xE6, 0xAD, 0xB9, 0xF6, 0xE6,
		0xAE, 0xBA, 0xF6, 0xE6, 0xB5, 0x81, 0xF6, 0xE6,
		0xBB, 0x9B, 0xF6, 0xE6, 0xBB, 0x8B, 0xF6, 0xE6,
		0xBC, 0xA2, 0xF6, 0xE7, 0x80, 0x9E, 0xF6, 0xE7,
		0x85, 0xAE, 0xF6, 0xE7, 0x9E, 0xA7, 0xF6, 0xE7,
		0x88, 0xB5, 0xF6, 0xE7, 0x8A, 0xAF, 0xF6, 0xE7,
		0x8C, 0xAA, 0xF6, 0xE7, 0x91, 0xB1, 0xF6, 0xE7,
		0x94, 0x86, 0xF6, 0xE7, 0x94, 0xBB, 0xF6, 0xE7,
		0x98, 0x9D, 0xF6, 0xE7, 0x98, 0x9F, 0xF6, 0xE7,
		0x9B, 0x8A, 0xF6, 0xE7, 0x9B, 0x9B, 0xF6, 0xE7,
		0x9B, 0xB4, 0xF6, 0xE7, 0x9D, 0x8A, 0xF6, 0xE7,
		0x9D, 0x80, 0xF6, 0xE7, 0xA3, 0x8C, 0xF6, 0xE7,
		0xAA, 0xB1, 0xF6, 0xE7, 0xAF, 0x80, 0xF6, 0xE7,
		0xB1, 0xBB, 0xF6, 0xE7, 0xB5, 0x9B, 0xF6, 0xE7,
		0xB7, 0xB4, 0xF6, 0xE7, 0xBC, 0xBE, 0xF6, 0xE8,
		0x80, 0x85, 0xF6, 0xE8, 0x8D, 0x92, 0xF6, 0xE8,
		0x8F, 0xAF, 0xF6, 0xE8, 0x9D, 0xB9, 0xF6, 0xE8,
		0xA5, 0x81, 0xF6, 0xE8, 0xA6, 0x86, 0xF6, 0xE8,
		0xA6, 0x96, 0xF6, 0xE8, 0xAA, 0xBF, 0xF6, 0xE8,
		0xAB, 0xB8, 0xF6, 0xE8, 0xAB, 0x8B, 0xF6, 0xE8,
		0xAC, 0x81, 0xF6, 0xE8, 0xAB, 0xBE, 0xF6, 0xE8,
		0xAB, 0xAD, 0xF6, 0xE8, 0xAC, 0xB9, 0xF6, 0xE8,
		0xAE, 0x8A, 0xF6, 0xE8, 0xB4, 0x88, 0xF6, 0xE8,
		0xBC, 0xB8, 0xF6, 0xE9, 0x81, 0xB2, 0xF6, 0xE9,
		0x86, 0x99, 0xF6, 0xE9, 0x89, 0xB6, 0xF6, 0xE9,
		0x99, 0xBC, 0xF6, 0xE9, 0x9B, 0xA3, 0xF6, 0xE9,
		0x9D, 0x96, 0xF6, 0xE9, 0x9F, 0x9B, 0xF6, 0xE9,
		0x9F, 0xBF, 0xF6, 0xE9, 0xA0, 0x8B, 0xF6, 0xE9,
		0xA0, 0xBB, 0xF6, 0xE9, 0xAC, 0x92, 0xF6, 0xE9,
		0xBE, 0x9C, 0xF6, 0xF0, 0xA2, 0xA1, 0x8A, 0xF6,
		0xF0, 0xA2, 0xA1, 0x84, 0xF6, 0xF0, 0xA3, 0x8F,
		0x95, 0xF6, 0xE3, 0xAE, 0x9D, 0xF6, 0xE4, 0x80,
		0x98, 0xF6, 0xE4, 0x80, 0xB9, 0xF6, 0xF0, 0xA5,
		0x89, 0x89, 0xF6, 0xF0, 0xA5, 0xB3, 0x90, 0xF6,
		0xF0, 0xA7, 0xBB, 0x93, 0xF6, 0xE9, 0xBD, 0x83,
		0xF6, 0xE9, 0xBE, 0x8E, 0x66, 0x66, 0x66, 0x69,
		0x66, 0x6C, 0x66, 0x66, 0x69, 0x66, 0x66, 0x6C,
		0x73, 0x74, 0x73, 0x74, 0xD5, 0xB4, 0xD5, 0xB6,
		0xD5, 0xB4, 0xD5, 0xA5, 0xD5, 0xB4, 0xD5, 0xAB,
		0xD5, 0xBE, 0xD5, 0xB6, 0xD5, 0xB4, 0xD5, 0xAD,
		0xF6, 0xD7, 0x99, 0xD6, 0xB4, 0xF6, 0xD7, 0xB2,
		0xD6, 0xB7, 0xD7, 0xA2, 0xD7, 0x90, 0xD7, 0x93,
		0xD7, 0x94, 0xD7, 0x9B, 0xD7, 0x9C, 0xD7, 0x9D,
		0xD7, 0xA8, 0xD7, 0xAA, 0x2B, 0xF6, 0xD7, 0xA9,
		0xD7, 0x81, 0xF6, 0xD7, 0xA9, 0xD7, 0x82, 0xF6,
		0xD7, 0xA9, 0xD6, 0xBC, 0xD7, 0x81, 0xF6, 0xD7,
		0xA9, 0xD6, 0xBC, 0xD7, 0x82, 0xF6, 0xD7, 0x90,
		0xD6, 0xB7, 0xF6, 0xD7, 0x90, 0xD6, 0xB8, 0xF6,
		0xD7, 0x90, 0xD6, 0xBC, 0xF6, 0xD7, 0x91, 0xD6,
		0xBC, 0xF6, 0xD7, 0x92, 0xD6, 0xBC, 0xF6, 0xD7,
		0x93, 0xD6, 0xBC, 0xF6, 0xD7, 0x94, 0xD6, 0xBC,
		0xF6, 0xD7, 0x95, 0xD6, 0xBC, 0xF6, 0xD7, 0x96,
		0xD6, 0xBC, 0xF6, 0xD7, 0x98, 0xD6, 0xBC, 0xF6,
		0xD7, 0x99, 0xD6, 0xBC, 0xF6, 0xD7, 0x9A, 0xD6,
		0xBC, 0xF6, 0xD7, 0x9B, 0xD6, 0xBC, 0xF6, 0xD7,
		0x9C, 0xD6, 0xBC, 0xF6, 0xD7, 0x9E, 0xD6, 0xBC,
		0xF6, 0xD7, 0xA0, 0xD6, 0xBC, 0xF6, 0xD7, 0xA1,
		0xD6, 0xBC, 0xF6, 0xD7, 0xA3, 0xD6, 0xBC, 0xF6,
		0xD7, 0xA4, 0xD6, 0xBC, 0xF6, 0xD7, 0xA6, 0xD6,
		0xBC, 0xF6, 0xD7, 0xA7, 0xD6, 0xBC, 0xF6, 0xD7,
		0xA8, 0xD6, 0xBC, 0xF6, 0xD7, 0xA9, 0xD6, 0xBC,
		0xF6, 0xD7, 0xAA, 0xD6, 0xBC, 0xF6, 0xD7, 0x95,
		0xD6, 0xB9, 0xF6, 0xD7, 0x91, 0xD6, 0xBF, 0xF6,
		0xD7, 0x9B, 0xD6, 0xBF, 0xF6, 0xD7, 0xA4, 0xD6,
		0xBF, 0xD7, 0x90, 0xD7, 0x9C, 0xD9, 0xB1, 0xD9,
		0xB1, 0xD9, 0xBB, 0xD9, 0xBB, 0xD9, 0xBB, 0xD9,
		0xBB, 0xD9, 0xBE, 0xD9, 0xBE, 0xD9, 0xBE, 0xD9,
		0xBE, 0xDA, 0x80, 0xDA, 0x80, 0xDA, 0x80, 0xDA,
		0x80, 0xD9, 0xBA, 0xD9, 0xBA, 0xD9, 0xBA, 0xD9,
		0xBA, 0xD9, 0xBF, 0xD9, 0xBF, 0xD9, 0xBF, 0xD9,
		0xBF, 0xD9, 0xB9, 0xD9, 0xB9, 0xD9, 0xB9, 0xD9,
		0xB9, 0xDA, 0xA4, 0xDA, 0xA4, 0xDA, 0xA4, 0xDA,
		0xA4, 0xDA, 0xA6, 0xDA, 0xA6, 0xDA, 0xA6, 0xDA,
		0xA6, 0xDA, 0x84, 0xDA, 0x84, 0xDA, 0x84, 0xDA,
		0x84, 0xDA, 0x83, 0xDA, 0x83, 0xDA, 0x83, 0xDA,
		0x83, 0xDA, 0x86, 0xDA, 0x86, 0xDA, 0x86, 0xDA,
		0x86, 0xDA, 0x87, 0xDA, 0x87, 0xDA, 0x87, 0xDA,
		0x87, 0xDA, 0x8D, 0xDA, 0x8D, 0xDA, 0x8C, 0xDA,
		0x8C, 0xDA, 0x8E, 0xDA, 0x8E, 0xDA, 0x88, 0xDA,
		0x88, 0xDA, 0x98, 0xDA, 0x98, 0xDA, 0x91, 0xDA,
		0x91, 0xDA, 0xA9, 0xDA, 0xA9, 0xDA, 0xA9, 0xDA,
		0xA9, 0xDA, 0xAF, 0xDA, 0xAF, 0xDA, 0xAF, 0xDA,
		0xAF, 0xDA, 0xB3, 0xDA, 0xB3, 0xDA, 0xB3, 0xDA,
		0xB3, 0xDA, 0xB1, 0xDA, 0xB1, 0xDA, 0xB1, 0xDA,
		0xB1, 0xDA, 0xBA, 0xDA, 0xBA, 0xDA, 0xBB, 0xDA,
		0xBB, 0xDA, 0xBB, 0xDA, 0xBB, 0xDB, 0x95, 0xD9,
		0x94, 0xDB, 0x95, 0xD9, 0x94, 0xDB, 0x81, 0xDB,
		0x81, 0xDB, 0x81, 0xDB, 0x81, 0xDA, 0xBE, 0xDA,
		0xBE, 0xDA, 0xBE, 0xDA, 0xBE, 0xDB, 0x92, 0xDB,
		0x92, 0xDB, 0x92, 0xD9, 0x94, 0xDB, 0x92, 0xD9,
		0x94, 0xDA, 0xAD, 0xDA, 0xAD, 0xDA, 0xAD, 0xDA,
		0xAD, 0xDB, 0x87, 0xDB, 0x87, 0xDB, 0x86, 0xDB,
		0x86, 0xDB, 0x88, 0xDB, 0x88, 0xDB, 0x87, 0xD9,
		0xB4, 0xDB, 0x8B, 0xDB, 0x8B, 0xDB, 0x85, 0xDB,
		0x85, 0xDB, 0x89, 0xDB, 0x89, 0xDB, 0x90, 0xDB,
		0x90, 0xDB, 0x90, 0xDB, 0x90, 0xD9, 0x89, 0xD9,
		0x89, 0xD9, 0x8A, 0xD9, 0x94, 0xD8, 0xA7, 0xD9,
		0x8A, 0xD9, 0x94, 0xD8, 0xA7, 0xD9, 0x8A, 0xD9,
		0x94, 0xDB, 0x95, 0xD9, 0x8A, 0xD9, 0x94, 0xDB,
		0x95, 0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x88, 0xD9,
		0x8A, 0xD9, 0x94, 0xD9, 0x88, 0xD9, 0x8A, 0xD9,
		0x94, 0xDB, 0x87, 0xD9, 0x8A, 0xD9, 0x94, 0xDB,
		0x87, 0xD9, 0x8A, 0xD9, 0x94, 0xDB, 0x86, 0xD9,
		0x8A, 0xD9, 0x94, 0xDB, 0x86, 0xD9, 0x8A, 0xD9,
		0x94, 0xDB, 0x88, 0xD9, 0x8A, 0xD9, 0x94, 0xDB,
		0x88, 0xD9, 0x8A, 0xD9, 0x94, 0xDB, 0x90, 0xD9,
		0x8A, 0xD9, 0x94, 0xDB, 0x90, 0xD9, 0x8A, 0xD9,
		0x94, 0xDB, 0x90, 0xD9, 0x8A, 0xD9, 0x94, 0xD9,
		0x89, 0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x89, 0xD9,
		0x8A, 0xD9, 0x94, 0xD9, 0x89, 0xDB, 0x8C, 0xDB,
		0x8C, 0xDB, 0x8C, 0xDB, 0x8C, 0xD9, 0x8A, 0xD9,
		0x94, 0xD8, 0xAC, 0xD9, 0x8A, 0xD9, 0x94, 0xD8,
		0xAD, 0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x85, 0xD9,
		0x8A, 0xD9, 0x94, 0xD9, 0x89, 0xD9, 0x8A, 0xD9,
		0x94, 0xD9, 0x8A, 0xD8, 0xA8, 0xD8, 0xAC, 0xD8,
		0xA8, 0xD8, 0xAD, 0xD8, 0xA8, 0xD8, 0xAE, 0xD8,
		0xA8, 0xD9, 0x85, 0xD8, 0xA8, 0xD9, 0x89, 0xD8,
		0xA8, 0xD9, 0x8A, 0xD8, 0xAA, 0xD8, 0xAC, 0xD8,
		0xAA, 0xD8, 0xAD, 0xD8, 0xAA, 0xD8, 0xAE, 0xD8,
		0xAA, 0xD9, 0x85, 0xD8, 0xAA, 0xD9, 0x89, 0xD8,
		0xAA, 0xD9, 0x8A, 0xD8, 0xAB, 0xD8, 0xAC, 0xD8,
		0xAB, 0xD9, 0x85, 0xD8, 0xAB, 0xD9, 0x89, 0xD8,
		0xAB, 0xD9, 0x8A, 0xD8, 0xAC, 0xD8, 0xAD, 0xD8,
		0xAC, 0xD9, 0x85, 0xD8, 0xAD, 0xD8, 0xAC, 0xD8,
		0xAD, 0xD9, 0x85, 0xD8, 0xAE, 0xD8, 0xAC, 0xD8,
		0xAE, 0xD8, 0xAD, 0xD8, 0xAE, 0xD9, 0x85, 0xD8,
		0xB3, 0xD8, 0xAC, 0xD8, 0xB3, 0xD8, 0xAD, 0xD8,
		0xB3, 0xD8, 0xAE, 0xD8, 0xB3, 0xD9, 0x85, 0xD8,
		0xB5, 0xD8, 0xAD, 0xD8, 0xB5, 0xD9, 0x85, 0xD8,
		0xB6, 0xD8, 0xAC, 0xD8, 0xB6, 0xD8, 0xAD, 0xD8,
		0xB6, 0xD8, 0xAE, 0xD8, 0xB6, 0xD9, 0x85, 0xD8,
		0xB7, 0xD8, 0xAD, 0xD8, 0xB7, 0xD9, 0x85, 0xD8,
		0xB8, 0xD9, 0x85, 0xD8, 0xB9, 0xD8, 0xAC, 0xD8,
		0xB9, 0xD9, 0x85, 0xD8, 0xBA, 0xD8, 0xAC, 0xD8,
		0xBA, 0xD9, 0x85, 0xD9, 0x81, 0xD8, 0xAC, 0xD9,
		0x81, 0xD8, 0xAD, 0xD9, 0x81, 0xD8, 0xAE, 0xD9,
		0x81, 0xD9, 0x85, 0xD9, 0x81, 0xD9, 0x89, 0xD9,
		0x81, 0xD9, 0x8A, 0xD9, 0x82, 0xD8, 0xAD, 0xD9,
		0x82, 0xD9, 0x85, 0xD9, 0x82, 0xD9, 0x89, 0xD9,
		0x82, 0xD9, 0x8A, 0xD9, 0x83, 0xD8, 0xA7, 0xD9,
		0x83, 0xD8, 0xAC, 0xD9, 0x83, 0xD8, 0xAD, 0xD9,
		0x83, 0xD8, 0xAE, 0xD9, 0x83, 0xD9, 0x84, 0xD9,
		0x83, 0xD9, 0x85, 0xD9, 0x83, 0xD9, 0x89, 0xD9,
		0x83, 0xD9, 0x8A, 0xD9, 0x84, 0xD8, 0xAC, 0xD9,
		0x84, 0xD8, 0xAD, 0xD9, 0x84, 0xD8, 0xAE, 0xD9,
		0x84, 0xD9, 0x85, 0xD9, 0x84, 0xD9, 0x89, 0xD9,
		0x84, 0xD9, 0x8A, 0xD9, 0x85, 0xD8, 0xAC, 0xD9,
		0x85, 0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAE, 0xD9,
		0x85, 0xD9, 0x85, 0xD9, 0x85, 0xD9, 0x89, 0xD9,
		0x85, 0xD9, 0x8A, 0xD9, 0x86, 0xD8, 0xAC, 0xD9,
		0x86, 0xD8, 0xAD, 0xD9, 0x86, 0xD8, 0xAE, 0xD9,
		0x86, 0xD9, 0x85, 0xD9, 0x86, 0xD9, 0x89, 0xD9,
		0x86, 0xD9, 0x8A, 0xD9, 0x87, 0xD8, 0xAC, 0xD9,
		0x87, 0xD9, 0x85, 0xD9, 0x87, 0xD9, 0x89, 0xD9,
		0x87, 0xD9, 0x8A, 0xD9, 0x8A, 0xD8, 0xAC, 0xD9,
		0x8A, 0xD8, 0xAD, 0xD9, 0x8A, 0xD8, 0xAE, 0xD9,
		0x8A, 0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x89, 0xD9,
		0x8A, 0xD9, 0x8A, 0xD8, 0xB0, 0xD9, 0xB0, 0xD8,
		0xB1, 0xD9, 0xB0, 0xD9, 0x89, 0xD9, 0xB0, 0x20,
		0xD9, 0x8C, 0xD9, 0x91, 0x20, 0xD9, 0x8D, 0xD9,
		0x91, 0x20, 0xD9, 0x8E, 0xD9, 0x91, 0x20, 0xD9,
		0x8F, 0xD9, 0x91, 0x20, 0xD9, 0x90, 0xD9, 0x91,
		0x20, 0xD9, 0x91, 0xD9, 0xB0, 0xD9, 0x8A, 0xD9,
		0x94, 0xD8, 0xB1, 0xD9, 0x8A, 0xD9, 0x94, 0xD8,
		0xB2, 0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x85, 0xD9,
		0x8A, 0xD9, 0x94, 0xD9, 0x86, 0xD9, 0x8A, 0xD9,
		0x94, 0xD9, 0x89, 0xD9, 0x8A, 0xD9, 0x94, 0xD9,
		0x8A, 0xD8, 0xA8, 0xD8, 0xB1, 0xD8, 0xA8, 0xD8,
		0xB2, 0xD8, 0xA8, 0xD9, 0x85, 0xD8, 0xA8, 0xD9,
		0x86, 0xD8, 0xA8, 0xD9, 0x89, 0xD8, 0xA8, 0xD9,
		0x8A, 0xD8, 0xAA, 0xD8, 0xB1, 0xD8, 0xAA, 0xD8,
		0xB2, 0xD8, 0xAA, 0xD9, 0x85, 0xD8, 0xAA, 0xD9,
		0x86, 0xD8, 0xAA, 0xD9, 0x89, 0xD8, 0xAA, 0xD9,
		0x8A, 0xD8, 0xAB, 0xD8, 0xB1, 0xD8, 0xAB, 0xD8,
		0xB2, 0xD8, 0xAB, 0xD9, 0x85, 0xD8, 0xAB, 0xD9,
		0x86, 0xD8, 0xAB, 0xD9, 0x89, 0xD8, 0xAB, 0xD9,
		0x8A, 0xD9, 0x81, 0xD9, 0x89, 0xD9, 0x81, 0xD9,
		0x8A, 0xD9, 0x82, 0xD9, 0x89, 0xD9, 0x82, 0xD9,
		0x8A, 0xD9, 0x83, 0xD8, 0xA7, 0xD9, 0x83, 0xD9,
		0x84, 0xD9, 0x83, 0xD9, 0x85, 0xD9, 0x83, 0xD9,
		0x89, 0xD9, 0x83, 0xD9, 0x8A, 0xD9, 0x84, 0xD9,
		0x85, 0xD9, 0x84, 0xD9, 0x89, 0xD9, 0x84, 0xD9,
		0x8A, 0xD9, 0x85, 0xD8, 0xA7, 0xD9, 0x85, 0xD9,
		0x85, 0xD9, 0x86, 0xD8, 0xB1, 0xD9, 0x86, 0xD8,
		0xB2, 0xD9, 0x86, 0xD9, 0x85, 0xD9, 0x86, 0xD9,
		0x86, 0xD9, 0x86, 0xD9, 0x89, 0xD9, 0x86, 0xD9,
		0x8A, 0xD9, 0x89, 0xD9, 0xB0, 0xD9, 0x8A, 0xD8,
		0xB1, 0xD9, 0x8A, 0xD8, 0xB2, 0xD9, 0x8A, 0xD9,
		0x85, 0xD9, 0x8A, 0xD9, 0x86, 0xD9, 0x8A, 0xD9,
		0x89, 0xD9, 0x8A, 0xD9, 0x8A, 0xD9, 0x8A, 0xD9,
		0x94, 0xD8, 0xAC, 0xD9, 0x8A, 0xD9, 0x94, 0xD8,
		0xAD, 0xD9, 0x8A, 0xD9, 0x94, 0xD8, 0xAE, 0xD9,
		0x8A, 0xD9, 0x94, 0xD9, 0x85, 0xD9, 0x8A, 0xD9,
		0x94, 0xD9, 0x87, 0xD8, 0xA8, 0xD8, 0xAC, 0xD8,
		0xA8, 0xD8, 0xAD, 0xD8, 0xA8, 0xD8, 0xAE, 0xD8,
		0xA8, 0xD9, 0x85, 0xD8, 0xA8, 0xD9, 0x87, 0xD8,
		0xAA, 0xD8, 0xAC, 0xD8, 0xAA, 0xD8, 0xAD, 0xD8,
		0xAA, 0xD8, 0xAE, 0xD8, 0xAA, 0xD9, 0x85, 0xD8,
		0xAA, 0xD9, 0x87, 0xD8, 0xAB, 0xD9, 0x85, 0xD8,
		0xAC, 0xD8, 0xAD, 0xD8, 0xAC, 0xD9, 0x85, 0xD8,
		0xAD, 0xD8, 0xAC, 0xD8, 0xAD, 0xD9, 0x85, 0xD8,
		0xAE, 0xD8, 0xAC, 0xD8, 0xAE, 0xD9, 0x85, 0xD8,
		0xB3, 0xD8, 0xAC, 0xD8, 0xB3, 0xD8, 0xAD, 0xD8,
		0xB3, 0xD8, 0xAE, 0xD8, 0xB3, 0xD9, 0x85, 0xD8,
		0xB5, 0xD8, 0xAD, 0xD8, 0xB5, 0xD8, 0xAE, 0xD8,
		0xB5, 0xD9, 0x85, 0xD8, 0xB6, 0xD8, 0xAC, 0xD8,
		0xB6, 0xD8, 0xAD, 0xD8, 0xB6, 0xD8, 0xAE, 0xD8,
		0xB6, 0xD9, 0x85, 0xD8, 0xB7, 0xD8, 0xAD, 0xD8,
		0xB8, 0xD9, 0x85, 0xD8, 0xB9, 0xD8, 0xAC, 0xD8,
		0xB9, 0xD9, 0x85, 0xD8, 0xBA, 0xD8, 0xAC, 0xD8,
		0xBA, 0xD9, 0x85, 0xD9, 0x81, 0xD8, 0xAC, 0xD9,
		0x81, 0xD8, 0xAD, 0xD9, 0x81, 0xD8, 0xAE, 0xD9,
		0x81, 0xD9, 0x85, 0xD9, 0x82, 0xD8, 0xAD, 0xD9,
		0x82, 0xD9, 0x85, 0xD9, 0x83, 0xD8, 0xAC, 0xD9,
		0x83, 0xD8, 0xAD, 0xD9, 0x83, 0xD8, 0xAE, 0xD9,
		0x83, 0xD9, 0x84, 0xD9, 0x83, 0xD9, 0x85, 0xD9,
		0x84, 0xD8, 0xAC, 0xD9, 0x84, 0xD8, 0xAD, 0xD9,
		0x84, 0xD8, 0xAE, 0xD9, 0x84, 0xD9, 0x85, 0xD9,
		0x84, 0xD9, 0x87, 0xD9, 0x85, 0xD8, 0xAC, 0xD9,
		0x85, 0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAE, 0xD9,
		0x85, 0xD9, 0x85, 0xD9, 0x86, 0xD8, 0xAC, 0xD9,
		0x86, 0xD8, 0xAD, 0xD9, 0x86, 0xD8, 0xAE, 0xD9,
		0x86, 0xD9, 0x85, 0xD9, 0x86, 0xD9, 0x87, 0xD9,
		0x87, 0xD8, 0xAC, 0xD9, 0x87, 0xD9, 0x85, 0xD9,
		0x87, 0xD9, 0xB0, 0xD9, 0x8A, 0xD8, 0xAC, 0xD9,
		0x8A, 0xD8, 0xAD, 0xD9, 0x8A, 0xD8, 0xAE, 0xD9,
		0x8A, 0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x87, 0xD9,
		0x8A, 0xD9, 0x94, 0xD9, 0x85, 0xD9, 0x8A, 0xD9,
		0x94, 0xD9, 0x87, 0xD8, 0xA8, 0xD9, 0x85, 0xD8,
		0xA8, 0xD9, 0x87, 0xD8, 0xAA, 0xD9, 0x85, 0xD8,
		0xAA, 0xD9, 0x87, 0xD8, 0xAB, 0xD9, 0x85, 0xD8,
		0xAB, 0xD9, 0x87, 0xD8, 0xB3, 0xD9, 0x85, 0xD8,
		0xB3, 0xD9, 0x87, 0xD8, 0xB4, 0xD9, 0x85, 0xD8,
		0xB4, 0xD9, 0x87, 0xD9, 0x83, 0xD9, 0x84, 0xD9,
		0x83, 0xD9, 0x85, 0xD9, 0x84, 0xD9, 0x85, 0xD9,
		0x86, 0xD9, 0x85, 0xD9, 0x86, 0xD9, 0x87, 0xD9,
		0x8A, 0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x87, 0xD9,
		0x80, 0xD9, 0x8E, 0xD9, 0x91, 0xD9, 0x80, 0xD9,
		0x8F, 0xD9, 0x91, 0xD9, 0x80, 0xD9, 0x90, 0xD9,
		0x91, 0xD8, 0xB7, 0xD9, 0x89, 0xD8, 0xB7, 0xD9,
		0x8A, 0xD8, 0xB9, 0xD9, 0x89, 0xD8, 0xB9, 0xD9,
		0x8A, 0xD8, 0xBA, 0xD9, 0x89, 0xD8, 0xBA, 0xD9,
		0x8A, 0xD8, 0xB3, 0xD9, 0x89, 0xD8, 0xB3, 0xD9,
		0x8A, 0xD8, 0xB4, 0xD9, 0x89, 0xD8, 0xB4, 0xD9,
		0x8A, 0xD8, 0xAD, 0xD9, 0x89, 0xD8, 0xAD, 0xD9,
		0x8A, 0xD8, 0xAC, 0xD9, 0x89, 0xD8, 0xAC, 0xD9,
		0x8A, 0xD8, 0xAE, 0xD9, 0x89, 0xD8, 0xAE, 0xD9,
		0x8A, 0xD8, 0xB5, 0xD9, 0x89, 0xD8, 0xB5, 0xD9,
		0x8A, 0xD8, 0xB6, 0xD9, 0x89, 0xD8, 0xB6, 0xD9,
		0x8A, 0xD8, 0xB4, 0xD8, 0xAC, 0xD8, 0xB4, 0xD8,
		0xAD, 0xD8, 0xB4, 0xD8, 0xAE, 0xD8, 0xB4, 0xD9,
		0x85, 0xD8, 0xB4, 0xD8, 0xB1, 0xD8, 0xB3, 0xD8,
		0xB1, 0xD8, 0xB5, 0xD8, 0xB1, 0xD8, 0xB6, 0xD8,
		0xB1, 0xD8, 0xB7, 0xD9, 0x89, 0xD8, 0xB7, 0xD9,
		0x8A, 0xD8, 0xB9, 0xD9, 0x89, 0xD8, 0xB9, 0xD9,
		0x8A, 0xD8, 0xBA, 0xD9, 0x89, 0xD8, 0xBA, 0xD9,
		0x8A, 0xD8, 0xB3, 0xD9, 0x89, 0xD8, 0xB3, 0xD9,
		0x8A, 0xD8, 0xB4, 0xD9, 0x89, 0xD8, 0xB4, 0xD9,
		0x8A, 0xD8, 0xAD, 0xD9, 0x89, 0xD8, 0xAD, 0xD9,
		0x8A, 0xD8, 0xAC, 0xD9, 0x89, 0xD8, 0xAC, 0xD9,
		0x8A, 0xD8, 0xAE, 0xD9, 0x89, 0xD8, 0xAE, 0xD9,
		0x8A, 0xD8, 0xB5, 0xD9, 0x89, 0xD8, 0xB5, 0xD9,
		0x8A, 0xD8, 0xB6, 0xD9, 0x89, 0xD8, 0xB6, 0xD9,
		0x8A, 0xD8, 0xB4, 0xD8, 0xAC, 0xD8, 0xB4, 0xD8,
		0xAD, 0xD8, 0xB4, 0xD8, 0xAE, 0xD8, 0xB4, 0xD9,
		0x85, 0xD8, 0xB4, 0xD8, 0xB1, 0xD8, 0xB3, 0xD8,
		0xB1, 0xD8, 0xB5, 0xD8, 0xB1, 0xD8, 0xB6, 0xD8,
		0xB1, 0xD8, 0xB4, 0xD8, 0xAC, 0xD8, 0xB4, 0xD8,
		0xAD, 0xD8, 0xB4, 0xD8, 0xAE, 0xD8, 0xB4, 0xD9,
		0x85, 0xD8, 0xB3, 0xD9, 0x87, 0xD8, 0xB4, 0xD9,
		0x87, 0xD8, 0xB7, 0xD9, 0x85, 0xD8, 0xB3, 0xD8,
		0xAC, 0xD8, 0xB3, 0xD8, 0xAD, 0xD8, 0xB3, 0xD8,
		0xAE, 0xD8, 0xB4, 0xD8, 0xAC, 0xD8, 0xB4, 0xD8,
		0xAD, 0xD8, 0xB4, 0xD8, 0xAE, 0xD8, 0xB7, 0xD9,
		0x85, 0xD8, 0xB8, 0xD9, 0x85, 0xD8, 0xA7, 0xD9,
		0x8B, 0xD8, 0xA7, 0xD9, 0x8B, 0xD8, 0xAA, 0xD8,
		0xAC, 0xD9, 0x85, 0xD8, 0xAA, 0xD8, 0xAD, 0xD8,
		0xAC, 0xD8, 0xAA, 0xD8, 0xAD, 0xD8, 0xAC, 0xD8,
		0xAA, 0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAA, 0xD8,
		0xAE, 0xD9, 0x85, 0xD8, 0xAA, 0xD9, 0x85, 0xD8,
		0xAC, 0xD8, 0xAA, 0xD9, 0x85, 0xD8, 0xAD, 0xD8,
		0xAA, 0xD9, 0x85, 0xD8, 0xAE, 0xD8, 0xAC, 0xD9,
		0x85, 0xD8, 0xAD, 0xD8, 0xAC, 0xD9, 0x85, 0xD8,
		0xAD, 0xD8, 0xAD, 0xD9, 0x85, 0xD9, 0x8A, 0xD8,
		0xAD, 0xD9, 0x85, 0xD9, 0x89, 0xD8, 0xB3, 0xD8,
		0xAD, 0xD8, 0xAC, 0xD8, 0xB3, 0xD8, 0xAC, 0xD8,
		0xAD, 0xD8, 0xB3, 0xD8, 0xAC, 0xD9, 0x89, 0xD8,
		0xB3, 0xD9, 0x85, 0xD8, 0xAD, 0xD8, 0xB3, 0xD9,
		0x85, 0xD8, 0xAD, 0xD8, 0xB3, 0xD9, 0x85, 0xD8,
		0xAC, 0xD8, 0xB3, 0xD9, 0x85, 0xD9, 0x85, 0xD8,
		0xB3, 0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB5, 0xD8,
		0xAD, 0xD8, 0xAD, 0xD8, 0xB5, 0xD8, 0xAD, 0xD8,
		0xAD, 0xD8, 0xB5, 0xD9, 0x85, 0xD9, 0x85, 0xD8,
		0xB4, 0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xB4, 0xD8,
		0xAD, 0xD9, 0x85, 0xD8, 0xB4, 0xD8, 0xAC, 0xD9,
		0x8A, 0xD8, 0xB4, 0xD9, 0x85, 0xD8, 0xAE, 0xD8,
		0xB4, 0xD9, 0x85, 0xD8, 0xAE, 0xD8, 0xB4, 0xD9,
		0x85, 0xD9, 0x85, 0xD8, 0xB4, 0xD9, 0x85, 0xD9,
		0x85, 0xD8, 0xB6, 0xD8, 0xAD, 0xD9, 0x89, 0xD8,
		0xB6, 0xD8, 0xAE, 0xD9, 0x85, 0xD8, 0xB6, 0xD8,
		0xAE, 0xD9, 0x85, 0xD8, 0xB7, 0xD9, 0x85, 0xD8,
		0xAD, 0xD8, 0xB7, 0xD9, 0x85, 0xD8, 0xAD, 0xD8,
		0xB7, 0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB7, 0xD9,
		0x85, 0xD9, 0x8A, 0xD8, 0xB9, 0xD8, 0xAC, 0xD9,
		0x85, 0xD8, 0xB9, 0xD9, 0x85, 0xD9, 0x85, 0xD8,
		0xB9, 0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB9, 0xD9,
		0x85, 0xD9, 0x89, 0xD8, 0xBA, 0xD9, 0x85, 0xD9,
		0x85, 0xD8, 0xBA, 0xD9, 0x85, 0xD9, 0x8A, 0xD8,
		0xBA, 0xD9, 0x85, 0xD9, 0x89, 0xD9, 0x81, 0xD8,
		0xAE, 0xD9, 0x85, 0xD9, 0x81, 0xD8, 0xAE, 0xD9,
		0x85, 0xD9, 0x82, 0xD9, 0x85, 0xD8, 0xAD, 0xD9,
		0x82, 0xD9, 0x85, 0xD9, 0x85, 0xD9, 0x84, 0xD8,
		0xAD, 0xD9, 0x85, 0xD9, 0x84, 0xD8, 0xAD, 0xD9,
		0x8A, 0xD9, 0x84, 0xD8, 0xAD, 0xD9, 0x89, 0xD9,
		0x84, 0xD8, 0xAC, 0xD8, 0xAC, 0xD9, 0x84, 0xD8,
		0xAC, 0xD8, 0xAC, 0xD9, 0x84, 0xD8, 0xAE, 0xD9,
		0x85, 0xD9, 0x84, 0xD8, 0xAE, 0xD9, 0x85, 0xD9,
		0x84, 0xD9, 0x85, 0xD8, 0xAD, 0xD9, 0x84, 0xD9,
		0x85, 0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAD, 0xD8,
		0xAC, 0xD9, 0x85, 0xD8, 0xAD, 0xD9, 0x85, 0xD9,
		0x85, 0xD8, 0xAD, 0xD9, 0x8A, 0xD9, 0x85, 0xD8,
		0xAC, 0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xAC, 0xD9,
		0x85, 0xD9, 0x85, 0xD8, 0xAE, 0xD8, 0xAC, 0xD9,
		0x85, 0xD8, 0xAE, 0xD9, 0x85, 0xD9, 0x85, 0xD8,
		0xAC, 0xD8, 0xAE, 0xD9, 0x87, 0xD9, 0x85, 0xD8,
		0xAC, 0xD9, 0x87, 0xD9, 0x85, 0xD9, 0x85, 0xD9,
		0x86, 0xD8, 0xAD, 0xD9, 0x85, 0xD9, 0x86, 0xD8,
		0xAD, 0xD9, 0x89, 0xD9, 0x86, 0xD8, 0xAC, 0xD9,
		0x85, 0xD9, 0x86, 0xD8, 0xAC, 0xD9, 0x85, 0xD9,
		0x86, 0xD8, 0xAC, 0xD9, 0x89, 0xD9, 0x86, 0xD9,
		0x85, 0xD9, 0x8A, 0xD9, 0x86, 0xD9, 0x85, 0xD9,
		0x89, 0xD9, 0x8A, 0xD9, 0x85, 0xD9, 0x85, 0xD9,
		0x8A, 0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xA8, 0xD8,
		0xAE, 0xD9, 0x8A, 0xD8, 0xAA, 0xD8, 0xAC, 0xD9,
		0x8A, 0xD8, 0xAA, 0xD8, 0xAC, 0xD9, 0x89, 0xD8,
		0xAA, 0xD8, 0xAE, 0xD9, 0x8A, 0xD8, 0xAA, 0xD8,
		0xAE, 0xD9, 0x89, 0xD8, 0xAA, 0xD9, 0x85, 0xD9,
		0x8A, 0xD8, 0xAA, 0xD9, 0x85, 0xD9, 0x89, 0xD8,
		0xAC, 0xD9, 0x85, 0xD9, 0x8A, 0xD8, 0xAC, 0xD8,
		0xAD, 0xD9, 0x89, 0xD8, 0xAC, 0xD9, 0x85, 0xD9,
		0x89, 0xD8, 0xB3, 0xD8, 0xAE, 0xD9, 0x89, 0xD8,
		0xB5, 0xD8, 0xAD, 0xD9, 0x8A, 0xD8, 0xB4, 0xD8,
		0xAD, 0xD9, 0x8A, 0xD8, 0xB6, 0xD8, 0xAD, 0xD9,
		0x8A, 0xD9, 0x84, 0xD8, 0xAC, 0xD9, 0x8A, 0xD9,
		0x84, 0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x8A, 0xD8,
		0xAD, 0xD9, 0x8A, 0xD9, 0x8A, 0xD8, 0xAC, 0xD9,
		0x8A, 0xD9, 0x8A, 0xD9, 0x85, 0xD9, 0x8A, 0xD9,
		0x85, 0xD9, 0x85, 0xD9, 0x8A, 0xD9, 0x82, 0xD9,
		0x85, 0xD9, 0x8A, 0xD9, 0x86, 0xD8, 0xAD, 0xD9,
		0x8A, 0xD9, 0x82, 0xD9, 0x85, 0xD8, 0xAD, 0xD9,
		0x84, 0xD8, 0xAD, 0xD9, 0x85, 0xD8, 0xB9, 0xD9,
		0x85, 0xD9, 0x8A, 0xD9, 0x83, 0xD9, 0x85, 0xD9,
		0x8A, 0xD9, 0x86, 0xD8, 0xAC, 0xD8, 0xAD, 0xD9,
		0x85, 0xD8, 0xAE, 0xD9, 0x8A, 0xD9, 0x84, 0xD8,
		0xAC, 0xD9, 0x85, 0xD9, 0x83, 0xD9, 0x85, 0xD9,
		0x85, 0xD9, 0x84, 0xD8, 0xAC, 0xD9, 0x85, 0xD9,
		0x86, 0xD8, 0xAC, 0xD8, 0xAD, 0xD8, 0xAC, 0xD8,
		0xAD, 0xD9, 0x8A, 0xD8, 0xAD, 0xD8, 0xAC, 0xD9,
		0x8A, 0xD9, 0x85, 0xD8, 0xAC, 0xD9, 0x8A, 0xD9,
		0x81, 0xD9, 0x85, 0xD9, 0x8A, 0xD8, 0xA8, 0xD8,
		0xAD, 0xD9, 0x8A, 0xD9, 0x83, 0xD9, 0x85, 0xD9,
		0x85, 0xD8, 0xB9, 0xD8, 0xAC, 0xD9, 0x85, 0xD8,
		0xB5, 0xD9, 0x85, 0xD9, 0x85, 0xD8, 0xB3, 0xD8,
		0xAE, 0xD9, 0x8A, 0xD9, 0x86, 0xD8, 0xAC, 0xD9,
		0x8A, 0xD8, 0xB5, 0xD9, 0x84, 0xDB, 0x92, 0xD9,
		0x82, 0xD9, 0x84, 0xDB, 0x92, 0xD8, 0xA7, 0xD9,
		0x84, 0xD9, 0x84, 0xD9, 0x87, 0xD8, 0xA7, 0xD9,
		0x83, 0xD8, 0xA8, 0xD8, 0xB1, 0xD9, 0x85, 0xD8,
		0xAD, 0xD9, 0x85, 0xD8, 0xAF, 0xD8, 0xB5, 0xD9,
		0x84, 0xD8, 0xB9, 0xD9, 0x85, 0xD8, 0xB1, 0xD8,
		0xB3, 0xD9, 0x88, 0xD9, 0x84, 0xD8, 0xB9, 0xD9,
		0x84, 0xD9, 0x8A, 0xD9, 0x87, 0xD9, 0x88, 0xD8,
		0xB3, 0xD9, 0x84, 0xD9, 0x85, 0xD8, 0xB5, 0xD9,
		0x84, 0xD9, 0x89, 0xD8, 0xB5, 0xD9, 0x84, 0xD9,
		0x89, 0x20, 0xD8, 0xA7, 0xD9, 0x84, 0xD9, 0x84,
		0xD9, 0x87, 0x20, 0xD8, 0xB9, 0xD9, 0x84, 0xD9,
		0x8A, 0xD9, 0x87, 0x20, 0xD9, 0x88, 0xD8, 0xB3,
		0xD9, 0x84, 0xD9, 0x85, 0xD8, 0xAC, 0xD9, 0x84,
		0x20, 0xD8, 0xAC, 0xD9, 0x84, 0xD8, 0xA7, 0xD9,
		0x84, 0xD9, 0x87, 0xD8, 0xB1, 0xDB, 0x8C, 0xD8,
		0xA7, 0xD9, 0x84, 0x2C, 0xE3, 0x80, 0x81, 0xE3,
		0x80, 0x82, 0x3A, 0x3B, 0x21, 0x3F, 0xE3, 0x80,
		0x96, 0xE3, 0x80, 0x97, 0x2E, 0x2E, 0x2E, 0x2E,
		0x2E, 0xE2, 0x80, 0x94, 0xE2, 0x80, 0x93, 0x5F,
		0x5F, 0x28, 0x29, 0x7B, 0x7D, 0xE3, 0x80, 0x94,
		0xE3, 0x80, 0x95, 0xE3, 0x80, 0x90, 0xE3, 0x80,
		0x91, 0xE3, 0x80, 0x8A, 0xE3, 0x80, 0x8B, 0xE3,
		0x80, 0x88, 0xE3, 0x80, 0x89, 0xE3, 0x80, 0x8C,
		0xE3, 0x80, 0x8D, 0xE3, 0x80, 0x8E, 0xE3, 0x80,
		0x8F, 0x5B, 0x5D, 0x20, 0xCC, 0x85, 0x20, 0xCC,
		0x85, 0x20, 0xCC, 0x85, 0x20, 0xCC, 0x85, 0x5F,
		0x5F, 0x5F, 0x2C, 0xE3, 0x80, 0x81, 0x2E, 0x3B,
		0x3A, 0x3F, 0x21, 0xE2, 0x80, 0x94, 0x28, 0x29,
		0x7B, 0x7D, 0xE3, 0x80, 0x94, 0xE3, 0x80, 0x95,
		0x23, 0x26, 0x2A, 0x2B, 0x2D, 0x3C, 0x3E, 0x3D,
		0x5C, 0x24, 0x25, 0x40, 0x20, 0xD9, 0x8B, 0xD9,
		0x80, 0xD9, 0x8B, 0x20, 0xD9, 0x8C, 0x20, 0xD9,
		0x8D, 0x20, 0xD9, 0x8E, 0xD9, 0x80, 0xD9, 0x8E,
		0x20, 0xD9, 0x8F, 0xD9, 0x80, 0xD9, 0x8F, 0x20,
		0xD9, 0x90, 0xD9, 0x80, 0xD9, 0x90, 0x20, 0xD9,
		0x91, 0xD9, 0x80, 0xD9, 0x91, 0x20, 0xD9, 0x92,
		0xD9, 0x80, 0xD9, 0x92, 0xD8, 0xA1, 0xD8, 0xA7,
		0xD9, 0x93, 0xD8, 0xA7, 0xD9, 0x93, 0xD8, 0xA7,
		0xD9, 0x94, 0xD8, 0xA7, 0xD9, 0x94, 0xD9, 0x88,
		0xD9, 0x94, 0xD9, 0x88, 0xD9, 0x94, 0xD8, 0xA7,
		0xD9, 0x95, 0xD8, 0xA7, 0xD9, 0x95, 0xD9, 0x8A,
		0xD9, 0x94, 0xD9, 0x8A, 0xD9, 0x94, 0xD9, 0x8A,
		0xD9, 0x94, 0xD9, 0x8A, 0xD9, 0x94, 0xD8, 0xA7,
		0xD8, 0xA7, 0xD8, 0xA8, 0xD8, 0xA8, 0xD8, 0xA8,
		0xD8, 0xA8, 0xD8, 0xA9, 0xD8, 0xA9, 0xD8, 0xAA,
		0xD8, 0xAA, 0xD8, 0xAA, 0xD8, 0xAA, 0xD8, 0xAB,
		0xD8, 0xAB, 0xD8, 0xAB, 0xD8, 0xAB, 0xD8, 0xAC,
		0xD8, 0xAC, 0xD8, 0xAC, 0xD8, 0xAC, 0xD8, 0xAD,
		0xD8, 0xAD, 0xD8, 0xAD, 0xD8, 0xAD, 0xD8, 0xAE,
		0xD8, 0xAE, 0xD8, 0xAE, 0xD8, 0xAE, 0xD8, 0xAF,
		0xD8, 0xAF, 0xD8, 0xB0, 0xD8, 0xB0, 0xD8, 0xB1,
		0xD8, 0xB1, 0xD8, 0xB2, 0xD8, 0xB2, 0xD8, 0xB3,
		0xD8, 0xB3, 0xD8, 0xB3, 0xD8, 0xB3, 0xD8, 0xB4,
		0xD8, 0xB4, 0xD8, 0xB4, 0xD8, 0xB4, 0xD8, 0xB5,
		0xD8, 0xB5, 0xD8, 0xB5, 0xD8, 0xB5, 0xD8, 0xB6,
		0xD8, 0xB6, 0xD8, 0xB6, 0xD8, 0xB6, 0xD8, 0xB7,
		0xD8, 0xB7, 0xD8, 0xB7, 0xD8, 0xB7, 0xD8, 0xB8,
		0xD8, 0xB8, 0xD8, 0xB8, 0xD8, 0xB8, 0xD8, 0xB9,
		0xD8, 0xB9, 0xD8, 0xB9, 0xD8, 0xB9, 0xD8, 0xBA,
		0xD8, 0xBA, 0xD8, 0xBA, 0xD8, 0xBA, 0xD9, 0x81,
		0xD9, 0x81, 0xD9, 0x81, 0xD9, 0x81, 0xD9, 0x82,
		0xD9, 0x82, 0xD9, 0x82, 0xD9, 0x82, 0xD9, 0x83,
		0xD9, 0x83, 0xD9, 0x83, 0xD9, 0x83, 0xD9, 0x84,
		0xD9, 0x84, 0xD9, 0x84, 0xD9, 0x84, 0xD9, 0x85,
		0xD9, 0x85, 0xD9, 0x85, 0xD9, 0x85, 0xD9, 0x86,
		0xD9, 0x86, 0xD9, 0x86, 0xD9, 0x86, 0xD9, 0x87,
		0xD9, 0x87, 0xD9, 0x87, 0xD9, 0x87, 0xD9, 0x88,
		0xD9, 0x88, 0xD9, 0x89, 0xD9, 0x89, 0xD9, 0x8A,
		0xD9, 0x8A, 0xD9, 0x8A, 0xD9, 0x8A, 0xD9, 0x84,
		0xD8, 0xA7, 0xD9, 0x93, 0xD9, 0x84, 0xD8, 0xA7,
		0xD9, 0x93, 0xD9, 0x84, 0xD8, 0xA7, 0xD9, 0x94,
		0xD9, 0x84, 0xD8, 0xA7, 0xD9, 0x94, 0xD9, 0x84,
		0xD8, 0xA7, 0xD9, 0x95, 0xD9, 0x84, 0xD8, 0xA7,
		0xD9, 0x95, 0xD9, 0x84, 0xD8, 0xA7, 0xD9, 0x84,
		0xD8, 0xA7, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
		0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E,
		0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E,
		0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
		0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E,
		0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
		0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E,
		0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
		0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
		0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
		0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E,
		0xE2, 0xA6, 0x85, 0xE2, 0xA6, 0x86, 0xE3, 0x80,
		0x82, 0xE3, 0x80, 0x8C, 0xE3, 0x80, 0x8D, 0xE3,
		0x80, 0x81, 0xE3, 0x83, 0xBB, 0xE3, 0x83, 0xB2,
		0xE3, 0x82, 0xA1, 0xE3, 0x82, 0xA3, 0xE3, 0x82,
		0xA5, 0xE3, 0x82, 0xA7, 0xE3, 0x82, 0xA9, 0xE3,
		0x83, 0xA3, 0xE3, 0x83, 0xA5, 0xE3, 0x83, 0xA7,
		0xE3, 0x83, 0x83, 0xE3, 0x83, 0xBC, 0xE3, 0x82,
		0xA2, 0xE3, 0x82, 0xA4, 0xE3, 0x82, 0xA6, 0xE3,
		0x82, 0xA8, 0xE3, 0x82, 0xAA, 0xE3, 0x82, 0xAB,
		0xE3, 0x82, 0xAD, 0xE3, 0x82, 0xAF, 0xE3, 0x82,
		0xB1, 0xE3, 0x82, 0xB3, 0xE3, 0x82, 0xB5, 0xE3,
		0x82, 0xB7, 0xE3, 0x82, 0xB9, 0xE3, 0x82, 0xBB,
		0xE3, 0x82, 0xBD, 0xE3, 0x82, 0xBF, 0xE3, 0x83,
		0x81, 0xE3, 0x83, 0x84, 0xE3, 0x83, 0x86, 0xE3,
		0x83, 0x88, 0xE3, 0x83, 0x8A, 0xE3, 0x83, 0x8B,
		0xE3, 0x83, 0x8C, 0xE3, 0x83, 0x8D, 0xE3, 0x83,
		0x8E, 0xE3, 0x83, 0x8F, 0xE3, 0x83, 0x92, 0xE3,
		0x83, 0x95, 0xE3, 0x83, 0x98, 0xE3, 0x83, 0x9B,
		0xE3, 0x83, 0x9E, 0xE3, 0x83, 0x9F, 0xE3, 0x83,
		0xA0, 0xE3, 0x83, 0xA1, 0xE3, 0x83, 0xA2, 0xE3,
		0x83, 0xA4, 0xE3, 0x83, 0xA6, 0xE3, 0x83, 0xA8,
		0xE3, 0x83, 0xA9, 0xE3, 0x83, 0xAA, 0xE3, 0x83,
		0xAB, 0xE3, 0x83, 0xAC, 0xE3, 0x83, 0xAD, 0xE3,
		0x83, 0xAF, 0xE3, 0x83, 0xB3, 0xE3, 0x82, 0x99,
		0xE3, 0x82, 0x9A, 0xE1, 0x85, 0xA0, 0xE1, 0x84,
		0x80, 0xE1, 0x84, 0x81, 0xE1, 0x86, 0xAA, 0xE1,
		0x84, 0x82, 0xE1, 0x86, 0xAC, 0xE1, 0x86, 0xAD,
		0xE1, 0x84, 0x83, 0xE1, 0x84, 0x84, 0xE1, 0x84,
		0x85, 0xE1, 0x86, 0xB0, 0xE1, 0x86, 0xB1, 0xE1,
		0x86, 0xB2, 0xE1, 0x86, 0xB3, 0xE1, 0x86, 0xB4,
		0xE1, 0x86, 0xB5, 0xE1, 0x84, 0x9A, 0xE1, 0x84,
		0x86, 0xE1, 0x84, 0x87, 0xE1, 0x84, 0x88, 0xE1,
		0x84, 0xA1, 0xE1, 0x84, 0x89, 0xE1, 0x84, 0x8A,
		0xE1, 0x84, 0x8B, 0xE1, 0x84, 0x8C, 0xE1, 0x84,
		0x8D, 0xE1, 0x84, 0x8E, 0xE1, 0x84, 0x8F, 0xE1,
		0x84, 0x90, 0xE1, 0x84, 0x91, 0xE1, 0x84, 0x92,
		0xE1, 0x85, 0xA1, 0xE1, 0x85, 0xA2, 0xE1, 0x85,
		0xA3, 0xE1, 0x85, 0xA4, 0xE1, 0x85, 0xA5, 0xE1,
		0x85, 0xA6, 0xE1, 0x85, 0xA7, 0xE1, 0x85, 0xA8,
		0xE1, 0x85, 0xA9, 0xE1, 0x85, 0xAA, 0xE1, 0x85,
		0xAB, 0xE1, 0x85, 0xAC, 0xE1, 0x85, 0xAD, 0xE1,
		0x85, 0xAE, 0xE1, 0x85, 0xAF, 0xE1, 0x85, 0xB0,
		0xE1, 0x85, 0xB1, 0xE1, 0x85, 0xB2, 0xE1, 0x85,
		0xB3, 0xE1, 0x85, 0xB4, 0xE1, 0x85, 0xB5, 0xC2,
		0xA2, 0xC2, 0xA3, 0xC2, 0xAC, 0x20, 0xCC, 0x84,
		0xC2, 0xA6, 0xC2, 0xA5, 0xE2, 0x82, 0xA9, 0xE2,
		0x94, 0x82, 0xE2, 0x86, 0x90, 0xE2, 0x86, 0x91,
		0xE2, 0x86, 0x92, 0xE2, 0x86, 0x93, 0xE2, 0x96,
		0xA0, 0xE2, 0x97, 0x8B, 0xF6, 0xF0, 0x9D, 0x85,
		0x97, 0xF0, 0x9D, 0x85, 0xA5, 0xF6, 0xF0, 0x9D,
		0x85, 0x98, 0xF0, 0x9D, 0x85, 0xA5, 0xF6, 0xF0,
		0x9D, 0x85, 0x98, 0xF0, 0x9D, 0x85, 0xA5, 0xF0,
		0x9D, 0x85, 0xAE, 0xF6, 0xF0, 0x9D, 0x85, 0x98,
		0xF0, 0x9D, 0x85, 0xA5, 0xF0, 0x9D, 0x85, 0xAF,
		0xF6, 0xF0, 0x9D, 0x85, 0x98, 0xF0, 0x9D, 0x85,
		0xA5, 0xF0, 0x9D, 0x85, 0xB0, 0xF6, 0xF0, 0x9D,
		0x85, 0x98, 0xF0, 0x9D, 0x85, 0xA5, 0xF0, 0x9D,
		0x85, 0xB1, 0xF6, 0xF0, 0x9D, 0x85, 0x98, 0xF0,
		0x9D, 0x85, 0xA5, 0xF0, 0x9D, 0x85, 0xB2, 0xF6,
		0xF0, 0x9D, 0x86, 0xB9, 0xF0, 0x9D, 0x85, 0xA5,
		0xF6, 0xF0, 0x9D, 0x86, 0xBA, 0xF0, 0x9D, 0x85,
		0xA5, 0xF6, 0xF0, 0x9D, 0x86, 0xB9, 0xF0, 0x9D,
		0x85, 0xA5, 0xF0, 0x9D, 0x85, 0xAE, 0xF6, 0xF0,
		0x9D, 0x86, 0xBA, 0xF0, 0x9D, 0x85, 0xA5, 0xF0,
		0x9D, 0x85, 0xAE, 0xF6, 0xF0, 0x9D, 0x86, 0xB9,
		0xF0, 0x9D, 0x85, 0xA5, 0xF0, 0x9D, 0x85, 0xAF,
		0xF6, 0xF0, 0x9D, 0x86, 0xBA, 0xF0, 0x9D, 0x85,
		0xA5, 0xF0, 0x9D, 0x85, 0xAF, 0x41, 0x42, 0x43,
		0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B,
		0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53,
		0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61,
		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
		0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
		0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x43, 0x44,
		0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
		0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,
		0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62,
		0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
		0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
		0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
		0x41, 0x43, 0x44, 0x47, 0x4A, 0x4B, 0x4E, 0x4F,
		0x50, 0x51, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
		0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x66, 0x68,
		0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x44,
		0x45, 0x46, 0x47, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E,
		0x4F, 0x50, 0x51, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
		0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
		0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
		0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x44, 0x45,
		0x46, 0x47, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4F,
		0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x61,
		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x43,
		0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B,
		0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53,
		0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61,
		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x43,
		0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B,
		0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53,
		0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61,
		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65,
		0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
		0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
		0x76, 0x77, 0x78, 0x79, 0x7A, 0x41, 0x42, 0x43,
		0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B,
		0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53,
		0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61,
		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
		0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0xC4, 0xB1, 0xC8, 0xB7, 0xCE, 0x91, 0xCE,
		0x92, 0xCE, 0x93, 0xCE, 0x94, 0xCE, 0x95, 0xCE,
		0x96, 0xCE, 0x97, 0xCE, 0x98, 0xCE, 0x99, 0xCE,
		0x9A, 0xCE, 0x9B, 0xCE, 0x9C, 0xCE, 0x9D, 0xCE,
		0x9E, 0xCE, 0x9F, 0xCE, 0xA0, 0xCE, 0xA1, 0xCE,
		0x98, 0xCE, 0xA3, 0xCE, 0xA4, 0xCE, 0xA5, 0xCE,
		0xA6, 0xCE, 0xA7, 0xCE, 0xA8, 0xCE, 0xA9, 0xE2,
		0x88, 0x87, 0xCE, 0xB1, 0xCE, 0xB2, 0xCE, 0xB3,
		0xCE, 0xB4, 0xCE, 0xB5, 0xCE, 0xB6, 0xCE, 0xB7,
		0xCE, 0xB8, 0xCE, 0xB9, 0xCE, 0xBA, 0xCE, 0xBB,
		0xCE, 0xBC, 0xCE, 0xBD, 0xCE, 0xBE, 0xCE, 0xBF,
		0xCF, 0x80, 0xCF, 0x81, 0xCF, 0x82, 0xCF, 0x83,
		0xCF, 0x84, 0xCF, 0x85, 0xCF, 0x86, 0xCF, 0x87,
		0xCF, 0x88, 0xCF, 0x89, 0xE2, 0x88, 0x82, 0xCE,
		0xB5, 0xCE, 0xB8, 0xCE, 0xBA, 0xCF, 0x86, 0xCF,
		0x81, 0xCF, 0x80, 0xCE, 0x91, 0xCE, 0x92, 0xCE,
		0x93, 0xCE, 0x94, 0xCE, 0x95, 0xCE, 0x96, 0xCE,
		0x97, 0xCE, 0x98, 0xCE, 0x99, 0xCE, 0x9A, 0xCE,
		0x9B, 0xCE, 0x9C, 0xCE, 0x9D, 0xCE, 0x9E, 0xCE,
		0x9F, 0xCE, 0xA0, 0xCE, 0xA1, 0xCE, 0x98, 0xCE,
		0xA3, 0xCE, 0xA4, 0xCE, 0xA5, 0xCE, 0xA6, 0xCE,
		0xA7, 0xCE, 0xA8, 0xCE, 0xA9, 0xE2, 0x88, 0x87,
		0xCE, 0xB1, 0xCE, 0xB2, 0xCE, 0xB3, 0xCE, 0xB4,
		0xCE, 0xB5, 0xCE, 0xB6, 0xCE, 0xB7, 0xCE, 0xB8,
		0xCE, 0xB9, 0xCE, 0xBA, 0xCE, 0xBB, 0xCE, 0xBC,
		0xCE, 0xBD, 0xCE, 0xBE, 0xCE, 0xBF, 0xCF, 0x80,
		0xCF, 0x81, 0xCF, 0x82, 0xCF, 0x83, 0xCF, 0x84,
		0xCF, 0x85, 0xCF, 0x86, 0xCF, 0x87, 0xCF, 0x88,
		0xCF, 0x89, 0xE2, 0x88, 0x82, 0xCE, 0xB5, 0xCE,
		0xB8, 0xCE, 0xBA, 0xCF, 0x86, 0xCF, 0x81, 0xCF,
		0x80, 0xCE, 0x91, 0xCE, 0x92, 0xCE, 0x93, 0xCE,
		0x94, 0xCE, 0x95, 0xCE, 0x96, 0xCE, 0x97, 0xCE,
		0x98, 0xCE, 0x99, 0xCE, 0x9A, 0xCE, 0x9B, 0xCE,
		0x9C, 0xCE, 0x9D, 0xCE, 0x9E, 0xCE, 0x9F, 0xCE,
		0xA0, 0xCE, 0xA1, 0xCE, 0x98, 0xCE, 0xA3, 0xCE,
		0xA4, 0xCE, 0xA5, 0xCE, 0xA6, 0xCE, 0xA7, 0xCE,
		0xA8, 0xCE, 0xA9, 0xE2, 0x88, 0x87, 0xCE, 0xB1,
		0xCE, 0xB2, 0xCE, 0xB3, 0xCE, 0xB4, 0xCE, 0xB5,
		0xCE, 0xB6, 0xCE, 0xB7, 0xCE, 0xB8, 0xCE, 0xB9,
		0xCE, 0xBA, 0xCE, 0xBB, 0xCE, 0xBC, 0xCE, 0xBD,
		0xCE, 0xBE, 0xCE, 0xBF, 0xCF, 0x80, 0xCF, 0x81,
		0xCF, 0x82, 0xCF, 0x83, 0xCF, 0x84, 0xCF, 0x85,
		0xCF, 0x86, 0xCF, 0x87, 0xCF, 0x88, 0xCF, 0x89,
		0xE2, 0x88, 0x82, 0xCE, 0xB5, 0xCE, 0xB8, 0xCE,
		0xBA, 0xCF, 0x86, 0xCF, 0x81, 0xCF, 0x80, 0xCE,
		0x91, 0xCE, 0x92, 0xCE, 0x93, 0xCE, 0x94, 0xCE,
		0x95, 0xCE, 0x96, 0xCE, 0x97, 0xCE, 0x98, 0xCE,
		0x99, 0xCE, 0x9A, 0xCE, 0x9B, 0xCE, 0x9C, 0xCE,
		0x9D, 0xCE, 0x9E, 0xCE, 0x9F, 0xCE, 0xA0, 0xCE,
		0xA1, 0xCE, 0x98, 0xCE, 0xA3, 0xCE, 0xA4, 0xCE,
		0xA5, 0xCE, 0xA6, 0xCE, 0xA7, 0xCE, 0xA8, 0xCE,
		0xA9, 0xE2, 0x88, 0x87, 0xCE, 0xB1, 0xCE, 0xB2,
		0xCE, 0xB3, 0xCE, 0xB4, 0xCE, 0xB5, 0xCE, 0xB6,
		0xCE, 0xB7, 0xCE, 0xB8, 0xCE, 0xB9, 0xCE, 0xBA,
		0xCE, 0xBB, 0xCE, 0xBC, 0xCE, 0xBD, 0xCE, 0xBE,
		0xCE, 0xBF, 0xCF, 0x80, 0xCF, 0x81, 0xCF, 0x82,
		0xCF, 0x83, 0xCF, 0x84, 0xCF, 0x85, 0xCF, 0x86,
		0xCF, 0x87, 0xCF, 0x88, 0xCF, 0x89, 0xE2, 0x88,
		0x82, 0xCE, 0xB5, 0xCE, 0xB8, 0xCE, 0xBA, 0xCF,
		0x86, 0xCF, 0x81, 0xCF, 0x80, 0xCE, 0x91, 0xCE,
		0x92, 0xCE, 0x93, 0xCE, 0x94, 0xCE, 0x95, 0xCE,
		0x96, 0xCE, 0x97, 0xCE, 0x98, 0xCE, 0x99, 0xCE,
		0x9A, 0xCE, 0x9B, 0xCE, 0x9C, 0xCE, 0x9D, 0xCE,
		0x9E, 0xCE, 0x9F, 0xCE, 0xA0, 0xCE, 0xA1, 0xCE,
		0x98, 0xCE, 0xA3, 0xCE, 0xA4, 0xCE, 0xA5, 0xCE,
		0xA6, 0xCE, 0xA7, 0xCE, 0xA8, 0xCE, 0xA9, 0xE2,
		0x88, 0x87, 0xCE, 0xB1, 0xCE, 0xB2, 0xCE, 0xB3,
		0xCE, 0xB4, 0xCE, 0xB5, 0xCE, 0xB6, 0xCE, 0xB7,
		0xCE, 0xB8, 0xCE, 0xB9, 0xCE, 0xBA, 0xCE, 0xBB,
		0xCE, 0xBC, 0xCE, 0xBD, 0xCE, 0xBE, 0xCE, 0xBF,
		0xCF, 0x80, 0xCF, 0x81, 0xCF, 0x82, 0xCF, 0x83,
		0xCF, 0x84, 0xCF, 0x85, 0xCF, 0x86, 0xCF, 0x87,
		0xCF, 0x88, 0xCF, 0x89, 0xE2, 0x88, 0x82, 0xCE,
		0xB5, 0xCE, 0xB8, 0xCE, 0xBA, 0xCF, 0x86, 0xCF,
		0x81, 0xCF, 0x80, 0xCF, 0x9C, 0xCF, 0x9D, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
		0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34,
		0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32,
		0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
		0x39, 0xF6, 0xE4, 0xB8, 0xBD, 0xF6, 0xE4, 0xB8,
		0xB8, 0xF6, 0xE4, 0xB9, 0x81, 0xF6, 0xF0, 0xA0,
		0x84, 0xA2, 0xF6, 0xE4, 0xBD, 0xA0, 0xF6, 0xE4,
		0xBE, 0xAE, 0xF6, 0xE4, 0xBE, 0xBB, 0xF6, 0xE5,
		0x80, 0x82, 0xF6, 0xE5, 0x81, 0xBA, 0xF6, 0xE5,
		0x82, 0x99, 0xF6, 0xE5, 0x83, 0xA7, 0xF6, 0xE5,
		0x83, 0x8F, 0xF6, 0xE3, 0x92, 0x9E, 0xF6, 0xF0,
		0xA0, 0x98, 0xBA, 0xF6, 0xE5, 0x85, 0x8D, 0xF6,
		0xE5, 0x85, 0x94, 0xF6, 0xE5, 0x85, 0xA4, 0xF6,
		0xE5, 0x85, 0xB7, 0xF6, 0xF0, 0xA0, 0x94, 0x9C,
		0xF6, 0xE3, 0x92, 0xB9, 0xF6, 0xE5, 0x85, 0xA7,
		0xF6, 0xE5, 0x86, 0x8D, 0xF6, 0xF0, 0xA0, 0x95,
		0x8B, 0xF6, 0xE5, 0x86, 0x97, 0xF6, 0xE5, 0x86,
		0xA4, 0xF6, 0xE4, 0xBB, 0x8C, 0xF6, 0xE5, 0x86,
		0xAC, 0xF6, 0xE5, 0x86, 0xB5, 0xF6, 0xF0, 0xA9,
		0x87, 0x9F, 0xF6, 0xE5, 0x87, 0xB5, 0xF6, 0xE5,
		0x88, 0x83, 0xF6, 0xE3, 0x93, 0x9F, 0xF6, 0xE5,
		0x88, 0xBB, 0xF6, 0xE5, 0x89, 0x86, 0xF6, 0xE5,
		0x89, 0xB2, 0xF6, 0xE5, 0x89, 0xB7, 0xF6, 0xE3,
		0x94, 0x95, 0xF6, 0xE5, 0x8B, 0x87, 0xF6, 0xE5,
		0x8B, 0x89, 0xF6, 0xE5, 0x8B, 0xA4, 0xF6, 0xE5,
		0x8B, 0xBA, 0xF6, 0xE5, 0x8C, 0x85, 0xF6, 0xE5,
		0x8C, 0x86, 0xF6, 0xE5, 0x8C, 0x97, 0xF6, 0xE5,
		0x8D, 0x89, 0xF6, 0xE5, 0x8D, 0x91, 0xF6, 0xE5,
		0x8D, 0x9A, 0xF6, 0xE5, 0x8D, 0xB3, 0xF6, 0xE5,
		0x8D, 0xBD, 0xF6, 0xE5, 0x8D, 0xBF, 0xF6, 0xE5,
		0x8D, 0xBF, 0xF6, 0xE5, 0x8D, 0xBF, 0xF6, 0xF0,
		0xA0, 0xA8, 0xAC, 0xF6, 0xE7, 0x81, 0xB0, 0xF6,
		0xE5, 0x8F, 0x8A, 0xF6, 0xE5, 0x8F, 0x9F, 0xF6,
		0xF0, 0xA0, 0xAD, 0xA3, 0xF6, 0xE5, 0x8F, 0xAB,
		0xF6, 0xE5, 0x8F, 0xB1, 0xF6, 0xE5, 0x90, 0x86,
		0xF6, 0xE5, 0x92, 0x9E, 0xF6, 0xE5, 0x90, 0xB8,
		0xF6, 0xE5, 0x91, 0x88, 0xF6, 0xE5, 0x91, 0xA8,
		0xF6, 0xE5, 0x92, 0xA2, 0xF6, 0xE5, 0x93, 0xB6,
		0xF6, 0xE5, 0x94, 0x90, 0xF6, 0xE5, 0x95, 0x93,
		0xF6, 0xE5, 0x95, 0xA3, 0xF6, 0xE5, 0x96, 0x84,
		0xF6, 0xE5, 0x96, 0x84, 0xF6, 0xE5, 0x96, 0x99,
		0xF6, 0xE5, 0x96, 0xAB, 0xF6, 0xE5, 0x96, 0xB3,
		0xF6, 0xE5, 0x97, 0x82, 0xF6, 0xE5, 0x9C, 0x96,
		0xF6, 0xE5, 0x98, 0x86, 0xF6, 0xE5, 0x9C, 0x97,
		0xF6, 0xE5, 0x99, 0x91, 0xF6, 0xE5, 0x99, 0xB4,
		0xF6, 0xE5, 0x88, 0x87, 0xF6, 0xE5, 0xA3, 0xAE,
		0xF6, 0xE5, 0x9F, 0x8E, 0xF6, 0xE5, 0x9F, 0xB4,
		0xF6, 0xE5, 0xA0, 0x8D, 0xF6, 0xE5, 0x9E, 0x8B,
		0xF6, 0xE5, 0xA0, 0xB2, 0xF6, 0xE5, 0xA0, 0xB1,
		0xF6, 0xE5, 0xA2, 0xAC, 0xF6, 0xF0, 0xA1, 0x93,
		0xA4, 0xF6, 0xE5, 0xA3, 0xB2, 0xF6, 0xE5, 0xA3,
		0xB7, 0xF6, 0xE5, 0xA4, 0x86, 0xF6, 0xE5, 0xA4,
		0x9A, 0xF6, 0xE5, 0xA4, 0xA2, 0xF6, 0xE5, 0xA5,
		0xA2, 0xF6, 0xF0, 0xA1, 0x9A, 0xA8, 0xF6, 0xF0,
		0xA1, 0x9B, 0xAA, 0xF6, 0xE5, 0xA7, 0xAC, 0xF6,
		0xE5, 0xA8, 0x9B, 0xF6, 0xE5, 0xA8, 0xA7, 0xF6,
		0xE5, 0xA7, 0x98, 0xF6, 0xE5, 0xA9, 0xA6, 0xF6,
		0xE3, 0x9B, 0xAE, 0xF6, 0xE3, 0x9B, 0xBC, 0xF6,
		0xE5, 0xAC, 0x88, 0xF6, 0xE5, 0xAC, 0xBE, 0xF6,
		0xE5, 0xAC, 0xBE, 0xF6, 0xF0, 0xA1, 0xA7, 0x88,
		0xF6, 0xE5, 0xAF, 0x83, 0xF6, 0xE5, 0xAF, 0x98,
		0xF6, 0xE5, 0xAF, 0xA7, 0xF6, 0xE5, 0xAF, 0xB3,
		0xF6, 0xF0, 0xA1, 0xAC, 0x98, 0xF6, 0xE5, 0xAF,
		0xBF, 0xF6, 0xE5, 0xB0, 0x86, 0xF6, 0xE5, 0xBD,
		0x93, 0xF6, 0xE5, 0xB0, 0xA2, 0xF6, 0xE3, 0x9E,
		0x81, 0xF6, 0xE5, 0xB1, 0xA0, 0xF6, 0xE5, 0xB1,
		0xAE, 0xF6, 0xE5, 0xB3, 0x80, 0xF6, 0xE5, 0xB2,
		0x8D, 0xF6, 0xF0, 0xA1, 0xB7, 0xA4, 0xF6, 0xE5,
		0xB5, 0x83, 0xF6, 0xF0, 0xA1, 0xB7, 0xA6, 0xF6,
		0xE5, 0xB5, 0xAE, 0xF6, 0xE5, 0xB5, 0xAB, 0xF6,
		0xE5, 0xB5, 0xBC, 0xF6, 0xE5, 0xB7, 0xA1, 0xF6,
		0xE5, 0xB7, 0xA2, 0xF6, 0xE3, 0xA0, 0xAF, 0xF6,
		0xE5, 0xB7, 0xBD, 0xF6, 0xE5, 0xB8, 0xA8, 0xF6,
		0xE5, 0xB8, 0xBD, 0xF6, 0xE5, 0xB9, 0xA9, 0xF6,
		0xE3, 0xA1, 0xA2, 0xF6, 0xF0, 0xA2, 0x86, 0x83,
		0xF6, 0xE3, 0xA1, 0xBC, 0xF6, 0xE5, 0xBA, 0xB0,
		0xF6, 0xE5, 0xBA, 0xB3, 0xF6, 0xE5, 0xBA, 0xB6,
		0xF6, 0xE5, 0xBB, 0x8A, 0xF6, 0xF0, 0xAA, 0x8E,
		0x92, 0xF6, 0xE5, 0xBB, 0xBE, 0xF6, 0xF0, 0xA2,
		0x8C, 0xB1, 0xF6, 0xF0, 0xA2, 0x8C, 0xB1, 0xF6,
		0xE8, 0x88, 0x81, 0xF6, 0xE5, 0xBC, 0xA2, 0xF6,
		0xE5, 0xBC, 0xA2, 0xF6, 0xE3, 0xA3, 0x87, 0xF6,
		0xF0, 0xA3, 0x8A, 0xB8, 0xF6, 0xF0, 0xA6, 0x87,
		0x9A, 0xF6, 0xE5, 0xBD, 0xA2, 0xF6, 0xE5, 0xBD,
		0xAB, 0xF6, 0xE3, 0xA3, 0xA3, 0xF6, 0xE5, 0xBE,
		0x9A, 0xF6, 0xE5, 0xBF, 0x8D, 0xF6, 0xE5, 0xBF,
		0x97, 0xF6, 0xE5, 0xBF, 0xB9, 0xF6, 0xE6, 0x82,
		0x81, 0xF6, 0xE3, 0xA4, 0xBA, 0xF6, 0xE3, 0xA4,
		0x9C, 0xF6, 0xE6, 0x82, 0x94, 0xF6, 0xF0, 0xA2,
		0x9B, 0x94, 0xF6, 0xE6, 0x83, 0x87, 0xF6, 0xE6,
		0x85, 0x88, 0xF6, 0xE6, 0x85, 0x8C, 0xF6, 0xE6,
		0x85, 0x8E, 0xF6, 0xE6, 0x85, 0x8C, 0xF6, 0xE6,
		0x85, 0xBA, 0xF6, 0xE6, 0x86, 0x8E, 0xF6, 0xE6,
		0x86, 0xB2, 0xF6, 0xE6, 0x86, 0xA4, 0xF6, 0xE6,
		0x86, 0xAF, 0xF6, 0xE6, 0x87, 0x9E, 0xF6, 0xE6,
		0x87, 0xB2, 0xF6, 0xE6, 0x87, 0xB6, 0xF6, 0xE6,
		0x88, 0x90, 0xF6, 0xE6, 0x88, 0x9B, 0xF6, 0xE6,
		0x89, 0x9D, 0xF6, 0xE6, 0x8A, 0xB1, 0xF6, 0xE6,
		0x8B, 0x94, 0xF6, 0xE6, 0x8D, 0x90, 0xF6, 0xF0,
		0xA2, 0xAC, 0x8C, 0xF6, 0xE6, 0x8C, 0xBD, 0xF6,
		0xE6, 0x8B, 0xBC, 0xF6, 0xE6, 0x8D, 0xA8, 0xF6,
		0xE6, 0x8E, 0x83, 0xF6, 0xE6, 0x8F, 0xA4, 0xF6,
		0xF0, 0xA2, 0xAF, 0xB1, 0xF6, 0xE6, 0x90, 0xA2,
		0xF6, 0xE6, 0x8F, 0x85, 0xF6, 0xE6, 0x8E, 0xA9,
		0xF6, 0xE3, 0xA8, 0xAE, 0xF6, 0xE6, 0x91, 0xA9,
		0xF6, 0xE6, 0x91, 0xBE, 0xF6, 0xE6, 0x92, 0x9D,
		0xF6, 0xE6, 0x91, 0xB7, 0xF6, 0xE3, 0xA9, 0xAC,
		0xF6, 0xE6, 0x95, 0x8F, 0xF6, 0xE6, 0x95, 0xAC,
		0xF6, 0xF0, 0xA3, 0x80, 0x8A, 0xF6, 0xE6, 0x97,
		0xA3, 0xF6, 0xE6, 0x9B, 0xB8, 0xF6, 0xE6, 0x99,
		0x89, 0xF6, 0xE3, 0xAC, 0x99, 0xF6, 0xE6, 0x9A,
		0x91, 0xF6, 0xE3, 0xAC, 0x88, 0xF6, 0xE3, 0xAB,
		0xA4, 0xF6, 0xE5, 0x86, 0x92, 0xF6, 0xE5, 0x86,
		0x95, 0xF6, 0xE6, 0x9C, 0x80, 0xF6, 0xE6, 0x9A,
		0x9C, 0xF6, 0xE8, 0x82, 0xAD, 0xF6, 0xE4, 0x8F,
		0x99, 0xF6, 0xE6, 0x9C, 0x97, 0xF6, 0xE6, 0x9C,
		0x9B, 0xF6, 0xE6, 0x9C, 0xA1, 0xF6, 0xE6, 0x9D,
		0x9E, 0xF6, 0xE6, 0x9D, 0x93, 0xF6, 0xF0, 0xA3,
		0x8F, 0x83, 0xF6, 0xE3, 0xAD, 0x89, 0xF6, 0xE6,
		0x9F, 0xBA, 0xF6, 0xE6, 0x9E, 0x85, 0xF6, 0xE6,
		0xA1, 0x92, 0xF6, 0xE6, 0xA2, 0x85, 0xF6, 0xF0,
		0xA3, 0x91, 0xAD, 0xF6, 0xE6, 0xA2, 0x8E, 0xF6,
		0xE6, 0xA0, 0x9F, 0xF6, 0xE6, 0xA4, 0x94, 0xF6,
		0xE3, 0xAE, 0x9D, 0xF6, 0xE6, 0xA5, 0x82, 0xF6,
		0xE6, 0xA6, 0xA3, 0xF6, 0xE6, 0xA7, 0xAA, 0xF6,
		0xE6, 0xAA, 0xA8, 0xF6, 0xF0, 0xA3, 0x9A, 0xA3,
		0xF6, 0xE6, 0xAB, 0x9B, 0xF6, 0xE3, 0xB0, 0x98,
		0xF6, 0xE6, 0xAC, 0xA1, 0xF6, 0xF0, 0xA3, 0xA2,
		0xA7, 0xF6, 0xE6, 0xAD, 0x94, 0xF6, 0xE3, 0xB1,
		0x8E, 0xF6, 0xE6, 0xAD, 0xB2, 0xF6, 0xE6, 0xAE,
		0x9F, 0xF6, 0xE6, 0xAE, 0xBA, 0xF6, 0xE6, 0xAE,
		0xBB, 0xF6, 0xF0, 0xA3, 0xAA, 0x8D, 0xF6, 0xF0,
		0xA1, 0xB4, 0x8B, 0xF6, 0xF0, 0xA3, 0xAB, 0xBA,
		0xF6, 0xE6, 0xB1, 0x8E, 0xF6, 0xF0, 0xA3, 0xB2,
		0xBC, 0xF6, 0xE6, 0xB2, 0xBF, 0xF6, 0xE6, 0xB3,
		0x8D, 0xF6, 0xE6, 0xB1, 0xA7, 0xF6, 0xE6, 0xB4,
		0x96, 0xF6, 0xE6, 0xB4, 0xBE, 0xF6, 0xE6, 0xB5,
		0xB7, 0xF6, 0xE6, 0xB5, 0x81, 0xF6, 0xE6, 0xB5,
		0xA9, 0xF6, 0xE6, 0xB5, 0xB8, 0xF6, 0xE6, 0xB6,
		0x85, 0xF6, 0xF0, 0xA3, 0xB4, 0x9E, 0xF6, 0xE6,
		0xB4, 0xB4, 0xF6, 0xE6, 0xB8, 0xAF, 0xF6, 0xE6,
		0xB9, 0xAE, 0xF6, 0xE3, 0xB4, 0xB3, 0xF6, 0xE6,
		0xBB, 0x8B, 0xF6, 0xE6, 0xBB, 0x87, 0xF6, 0xF0,
		0xA3, 0xBB, 0x91, 0xF6, 0xE6, 0xB7, 0xB9, 0xF6,
		0xE6, 0xBD, 0xAE, 0xF6, 0xF0, 0xA3, 0xBD, 0x9E,
		0xF6, 0xF0, 0xA3, 0xBE, 0x8E, 0xF6, 0xE6, 0xBF,
		0x86, 0xF6, 0xE7, 0x80, 0xB9, 0xF6, 0xE7, 0x80,
		0x9E, 0xF6, 0xE7, 0x80, 0x9B, 0xF6, 0xE3, 0xB6,
		0x96, 0xF6, 0xE7, 0x81, 0x8A, 0xF6, 0xE7, 0x81,
		0xBD, 0xF6, 0xE7, 0x81, 0xB7, 0xF6, 0xE7, 0x82,
		0xAD, 0xF6, 0xF0, 0xA0, 0x94, 0xA5, 0xF6, 0xE7,
		0x85, 0x85, 0xF6, 0xF0, 0xA4, 0x89, 0xA3, 0xF6,
		0xE7, 0x86, 0x9C, 0xF6, 0xF0, 0xA4, 0x8E, 0xAB,
		0xF6, 0xE7, 0x88, 0xA8, 0xF6, 0xE7, 0x88, 0xB5,
		0xF6, 0xE7, 0x89, 0x90, 0xF6, 0xF0, 0xA4, 0x98,
		0x88, 0xF6, 0xE7, 0x8A, 0x80, 0xF6, 0xE7, 0x8A,
		0x95, 0xF6, 0xF0, 0xA4, 0x9C, 0xB5, 0xF6, 0xF0,
		0xA4, 0xA0, 0x94, 0xF6, 0xE7, 0x8D, 0xBA, 0xF6,
		0xE7, 0x8E, 0x8B, 0xF6, 0xE3, 0xBA, 0xAC, 0xF6,
		0xE7, 0x8E, 0xA5, 0xF6, 0xE3, 0xBA, 0xB8, 0xF6,
		0xE3, 0xBA, 0xB8, 0xF6, 0xE7, 0x91, 0x87, 0xF6,
		0xE7, 0x91, 0x9C, 0xF6, 0xE7, 0x91, 0xB1, 0xF6,
		0xE7, 0x92, 0x85, 0xF6, 0xE7, 0x93, 0x8A, 0xF6,
		0xE3, 0xBC, 0x9B, 0xF6, 0xE7, 0x94, 0xA4, 0xF6,
		0xF0, 0xA4, 0xB0, 0xB6, 0xF6, 0xE7, 0x94, 0xBE,
		0xF6, 0xF0, 0xA4, 0xB2, 0x92, 0xF6, 0xE7, 0x95,
		0xB0, 0xF6, 0xF0, 0xA2, 0x86, 0x9F, 0xF6, 0xE7,
		0x98, 0x90, 0xF6, 0xF0, 0xA4, 0xBE, 0xA1, 0xF6,
		0xF0, 0xA4, 0xBE, 0xB8, 0xF6, 0xF0, 0xA5, 0x81,
		0x84, 0xF6, 0xE3, 0xBF, 0xBC, 0xF6, 0xE4, 0x80,
		0x88, 0xF6, 0xE7, 0x9B, 0xB4, 0xF6, 0xF0, 0xA5,
		0x83, 0xB3, 0xF6, 0xF0, 0xA5, 0x83, 0xB2, 0xF6,
		0xF0, 0xA5, 0x84, 0x99, 0xF6, 0xF0, 0xA5, 0x84,
		0xB3, 0xF6, 0xE7, 0x9C, 0x9E, 0xF6, 0xE7, 0x9C,
		0x9F, 0xF6, 0xE7, 0x9C, 0x9F, 0xF6, 0xE7, 0x9D,
		0x8A, 0xF6, 0xE4, 0x80, 0xB9, 0xF6, 0xE7, 0x9E,
		0x8B, 0xF6, 0xE4, 0x81, 0x86, 0xF6, 0xE4, 0x82,
		0x96, 0xF6, 0xF0, 0xA5, 0x90, 0x9D, 0xF6, 0xE7,
		0xA1, 0x8E, 0xF6, 0xE7, 0xA2, 0x8C, 0xF6, 0xE7,
		0xA3, 0x8C, 0xF6, 0xE4, 0x83, 0xA3, 0xF6, 0xF0,
		0xA5, 0x98, 0xA6, 0xF6, 0xE7, 0xA5, 0x96, 0xF6,
		0xF0, 0xA5, 0x9A, 0x9A, 0xF6, 0xF0, 0xA5, 0x9B,
		0x85, 0xF6, 0xE7, 0xA6, 0x8F, 0xF6, 0xE7, 0xA7,
		0xAB, 0xF6, 0xE4, 0x84, 0xAF, 0xF6, 0xE7, 0xA9,
		0x80, 0xF6, 0xE7, 0xA9, 0x8A, 0xF6, 0xE7, 0xA9,
		0x8F, 0xF6, 0xF0, 0xA5, 0xA5, 0xBC, 0xF6, 0xF0,
		0xA5, 0xAA, 0xA7, 0xF6, 0xF0, 0xA5, 0xAA, 0xA7,
		0xF6, 0xE7, 0xAB, 0xAE, 0xF6, 0xE4, 0x88, 0x82,
		0xF6, 0xF0, 0xA5, 0xAE, 0xAB, 0xF6, 0xE7, 0xAF,
		0x86, 0xF6, 0xE7, 0xAF, 0x89, 0xF6, 0xE4, 0x88,
		0xA7, 0xF6, 0xF0, 0xA5, 0xB2, 0x80, 0xF6, 0xE7,
		0xB3, 0x92, 0xF6, 0xE4, 0x8A, 0xA0, 0xF6, 0xE7,
		0xB3, 0xA8, 0xF6, 0xE7, 0xB3, 0xA3, 0xF6, 0xE7,
		0xB4, 0x80, 0xF6, 0xF0, 0xA5, 0xBE, 0x86, 0xF6,
		0xE7, 0xB5, 0xA3, 0xF6, 0xE4, 0x8C, 0x81, 0xF6,
		0xE7, 0xB7, 0x87, 0xF6, 0xE7, 0xB8, 0x82, 0xF6,
		0xE7, 0xB9, 0x85, 0xF6, 0xE4, 0x8C, 0xB4, 0xF6,
		0xF0, 0xA6, 0x88, 0xA8, 0xF6, 0xF0, 0xA6, 0x89,
		0x87, 0xF6, 0xE4, 0x8D, 0x99, 0xF6, 0xF0, 0xA6,
		0x8B, 0x99, 0xF6, 0xE7, 0xBD, 0xBA, 0xF6, 0xF0,
		0xA6, 0x8C, 0xBE, 0xF6, 0xE7, 0xBE, 0x95, 0xF6,
		0xE7, 0xBF, 0xBA, 0xF6, 0xE8, 0x80, 0x85, 0xF6,
		0xF0, 0xA6, 0x93, 0x9A, 0xF6, 0xF0, 0xA6, 0x94,
		0xA3, 0xF6, 0xE8, 0x81, 0xA0, 0xF6, 0xF0, 0xA6,
		0x96, 0xA8, 0xF6, 0xE8, 0x81, 0xB0, 0xF6, 0xF0,
		0xA3, 0x8D, 0x9F, 0xF6, 0xE4, 0x8F, 0x95, 0xF6,
		0xE8, 0x82, 0xB2, 0xF6, 0xE8, 0x84, 0x83, 0xF6,
		0xE4, 0x90, 0x8B, 0xF6, 0xE8, 0x84, 0xBE, 0xF6,
		0xE5, 0xAA, 0xB5, 0xF6, 0xF0, 0xA6, 0x9E, 0xA7,
		0xF6, 0xF0, 0xA6, 0x9E, 0xB5, 0xF6, 0xF0, 0xA3,
		0x8E, 0x93, 0xF6, 0xF0, 0xA3, 0x8E, 0x9C, 0xF6,
		0xE8, 0x88, 0x81, 0xF6, 0xE8, 0x88, 0x84, 0xF6,
		0xE8, 0xBE, 0x9E, 0xF6, 0xE4, 0x91, 0xAB, 0xF6,
		0xE8, 0x8A, 0x91, 0xF6, 0xE8, 0x8A, 0x8B, 0xF6,
		0xE8, 0x8A, 0x9D, 0xF6, 0xE5, 0x8A, 0xB3, 0xF6,
		0xE8, 0x8A, 0xB1, 0xF6, 0xE8, 0x8A, 0xB3, 0xF6,
		0xE8, 0x8A, 0xBD, 0xF6, 0xE8, 0x8B, 0xA6, 0xF6,
		0xF0, 0xA6, 0xAC, 0xBC, 0xF6, 0xE8, 0x8B, 0xA5,
		0xF6, 0xE8, 0x8C, 0x9D, 0xF6, 0xE8, 0x8D, 0xA3,
		0xF6, 0xE8, 0x8E, 0xAD, 0xF6, 0xE8, 0x8C, 0xA3,
		0xF6, 0xE8, 0x8E, 0xBD, 0xF6, 0xE8, 0x8F, 0xA7,
		0xF6, 0xE8, 0x91, 0x97, 0xF6, 0xE8, 0x8D, 0x93,
		0xF6, 0xE8, 0x8F, 0x8A, 0xF6, 0xE8, 0x8F, 0x8C,
		0xF6, 0xE8, 0x8F, 0x9C, 0xF6, 0xF0, 0xA6, 0xB0,
		0xB6, 0xF6, 0xF0, 0xA6, 0xB5, 0xAB, 0xF6, 0xF0,
		0xA6, 0xB3, 0x95, 0xF6, 0xE4, 0x94, 0xAB, 0xF6,
		0xE8, 0x93, 0xB1, 0xF6, 0xE8, 0x93, 0xB3, 0xF6,
		0xE8, 0x94, 0x96, 0xF6, 0xF0, 0xA7, 0x8F, 0x8A,
		0xF6, 0xE8, 0x95, 0xA4, 0xF6, 0xF0, 0xA6, 0xBC,
		0xAC, 0xF6, 0xE4, 0x95, 0x9D, 0xF6, 0xE4, 0x95,
		0xA1, 0xF6, 0xF0, 0xA6, 0xBE, 0xB1, 0xF6, 0xF0,
		0xA7, 0x83, 0x92, 0xF6, 0xE4, 0x95, 0xAB, 0xF6,
		0xE8, 0x99, 0x90, 0xF6, 0xE8, 0x99, 0x9C, 0xF6,
		0xE8, 0x99, 0xA7, 0xF6, 0xE8, 0x99, 0xA9, 0xF6,
		0xE8, 0x9A, 0xA9, 0xF6, 0xE8, 0x9A, 0x88, 0xF6,
		0xE8, 0x9C, 0x8E, 0xF6, 0xE8, 0x9B, 0xA2, 0xF6,
		0xE8, 0x9D, 0xB9, 0xF6, 0xE8, 0x9C, 0xA8, 0xF6,
		0xE8, 0x9D, 0xAB, 0xF6, 0xE8, 0x9E, 0x86, 0xF6,
		0xE4, 0x97, 0x97, 0xF6, 0xE8, 0x9F, 0xA1, 0xF6,
		0xE8, 0xA0, 0x81, 0xF6, 0xE4, 0x97, 0xB9, 0xF6,
		0xE8, 0xA1, 0xA0, 0xF6, 0xE8, 0xA1, 0xA3, 0xF6,
		0xF0, 0xA7, 0x99, 0xA7, 0xF6, 0xE8, 0xA3, 0x97,
		0xF6, 0xE8, 0xA3, 0x9E, 0xF6, 0xE4, 0x98, 0xB5,
		0xF6, 0xE8, 0xA3, 0xBA, 0xF6, 0xE3, 0x92, 0xBB,
		0xF6, 0xF0, 0xA7, 0xA2, 0xAE, 0xF6, 0xF0, 0xA7,
		0xA5, 0xA6, 0xF6, 0xE4, 0x9A, 0xBE, 0xF6, 0xE4,
		0x9B, 0x87, 0xF6, 0xE8, 0xAA, 0xA0, 0xF6, 0xE8,
		0xAB, 0xAD, 0xF6, 0xE8, 0xAE, 0x8A, 0xF6, 0xE8,
		0xB1, 0x95, 0xF6, 0xF0, 0xA7, 0xB2, 0xA8, 0xF6,
		0xE8, 0xB2, 0xAB, 0xF6, 0xE8, 0xB3, 0x81, 0xF6,
		0xE8, 0xB4, 0x9B, 0xF6, 0xE8, 0xB5, 0xB7, 0xF6,
		0xF0, 0xA7, 0xBC, 0xAF, 0xF6, 0xF0, 0xA0, 0xA0,
		0x84, 0xF6, 0xE8, 0xB7, 0x8B, 0xF6, 0xE8, 0xB6,
		0xBC, 0xF6, 0xE8, 0xB7, 0xB0, 0xF6, 0xF0, 0xA0,
		0xA3, 0x9E, 0xF6, 0xE8, 0xBB, 0x94, 0xF6, 0xE8,
		0xBC, 0xB8, 0xF6, 0xF0, 0xA8, 0x97, 0x92, 0xF6,
		0xF0, 0xA8, 0x97, 0xAD, 0xF6, 0xE9, 0x82, 0x94,
		0xF6, 0xE9, 0x83, 0xB1, 0xF6, 0xE9, 0x84, 0x91,
		0xF6, 0xF0, 0xA8, 0x9C, 0xAE, 0xF6, 0xE9, 0x84,
		0x9B, 0xF6, 0xE9, 0x88, 0xB8, 0xF6, 0xE9, 0x8B,
		0x97, 0xF6, 0xE9, 0x8B, 0x98, 0xF6, 0xE9, 0x89,
		0xBC, 0xF6, 0xE9, 0x8F, 0xB9, 0xF6, 0xE9, 0x90,
		0x95, 0xF6, 0xF0, 0xA8, 0xAF, 0xBA, 0xF6, 0xE9,
		0x96, 0x8B, 0xF6, 0xE4, 0xA6, 0x95, 0xF6, 0xE9,
		0x96, 0xB7, 0xF6, 0xF0, 0xA8, 0xB5, 0xB7, 0xF6,
		0xE4, 0xA7, 0xA6, 0xF6, 0xE9, 0x9B, 0x83, 0xF6,
		0xE5, 0xB6, 0xB2, 0xF6, 0xE9, 0x9C, 0xA3, 0xF6,
		0xF0, 0xA9, 0x85, 0x85, 0xF6, 0xF0, 0xA9, 0x88,
		0x9A, 0xF6, 0xE4, 0xA9, 0xAE, 0xF6, 0xE4, 0xA9,
		0xB6, 0xF6, 0xE9, 0x9F, 0xA0, 0xF6, 0xF0, 0xA9,
		0x90, 0x8A, 0xF6, 0xE4, 0xAA, 0xB2, 0xF6, 0xF0,
		0xA9, 0x92, 0x96, 0xF6, 0xE9, 0xA0, 0x8B, 0xF6,
		0xE9, 0xA0, 0x8B, 0xF6, 0xE9, 0xA0, 0xA9, 0xF6,
		0xF0, 0xA9, 0x96, 0xB6, 0xF6, 0xE9, 0xA3, 0xA2,
		0xF6, 0xE4, 0xAC, 0xB3, 0xF6, 0xE9, 0xA4, 0xA9,
		0xF6, 0xE9, 0xA6, 0xA7, 0xF6, 0xE9, 0xA7, 0x82,
		0xF6, 0xE9, 0xA7, 0xBE, 0xF6, 0xE4, 0xAF, 0x8E,
		0xF6, 0xF0, 0xA9, 0xAC, 0xB0, 0xF6, 0xE9, 0xAC,
		0x92, 0xF6, 0xE9, 0xB1, 0x80, 0xF6, 0xE9, 0xB3,
		0xBD, 0xF6, 0xE4, 0xB3, 0x8E, 0xF6, 0xE4, 0xB3,
		0xAD, 0xF6, 0xE9, 0xB5, 0xA7, 0xF6, 0xF0, 0xAA,
		0x83, 0x8E, 0xF6, 0xE4, 0xB3, 0xB8, 0xF6, 0xF0,
		0xAA, 0x84, 0x85, 0xF6, 0xF0, 0xAA, 0x88, 0x8E,
		0xF6, 0xF0, 0xAA, 0x8A, 0x91, 0xF6, 0xE9, 0xBA,
		0xBB, 0xF6, 0xE4, 0xB5, 0x96, 0xF6, 0xE9, 0xBB,
		0xB9, 0xF6, 0xE9, 0xBB, 0xBE, 0xF6, 0xE9, 0xBC,
		0x85, 0xF6, 0xE9, 0xBC, 0x8F, 0xF6, 0xE9, 0xBC,
		0x96, 0xF6, 0xE9, 0xBC, 0xBB, 0xF6, 0xF0, 0xAA,
		0x98, 0x80,
	},
};

static const uchar_t u8_case_common_b2_tbl[2][2][256] = {
	{
		{
			0,  N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, 1,  2,  N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, 3,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
		},
		{
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			4,  N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
		},

	},
	{
		{
			0,  N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, 1,  2,  N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, 3,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
		},
		{
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			4,  N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
			N_, N_, N_, N_, N_, N_, N_, N_,
		},

	},

};

static const u8_displacement_t u8_tolower_b3_tbl[2][5][256] = {
	{
		{	/* Third byte table 0. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { 0, 0 },
			{ 1, 60 }, { 2, 123 }, { 3, 185 }, { 4, 257 },
			{ 5, 321 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { 6, 373 }, { 7, 439 },
			{ 8, 465 }, { 9, 561 }, { 10, 593 }, { 11, 649 },
			{ 12, 703 }, { 13, 749 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 1. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 14, 795 }, { 15, 891 }, { 16, 987 }, { 17, 1068 },
			{ 18, 1155 }, { 19, 1245 }, { 20, 1299 }, { 21, 1386 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 2. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 22, 1443 }, { 23, 1448 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { 24, 1496 }, { 25, 1526 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 3. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 26, 1574 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 4. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 27, 1652 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
	},
	{
		{	/* Third byte table 0. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { 0, 0 },
			{ 1, 60 }, { 2, 123 }, { 3, 185 }, { 4, 257 },
			{ 5, 321 }, { 6, 383 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { 7, 401 }, { 8, 467 },
			{ 9, 505 }, { 10, 601 }, { 11, 633 }, { 12, 689 },
			{ 13, 753 }, { 14, 803 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 1. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { 15, 849 }, { 16, 945 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 17, 963 }, { 18, 1059 }, { 19, 1155 }, { 20, 1236 },
			{ 21, 1323 }, { 22, 1413 }, { 23, 1467 }, { 24, 1554 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 2. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 25, 1611 }, { 26, 1619 }, { 27, 1667 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { 28, 1670 }, { 29, 1700 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 30, 1748 }, { 31, 1889 }, { 32, 1911 }, { 33, 2007 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 3. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 34, 2061 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 4. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 35, 2139 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
	},
};

static const uchar_t u8_tolower_b4_tbl[2][36][257] = {
	{
		{	/* Fourth byte table 0. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  34,  36,  38,  40,  42,  44,  46,
			46,  48,  50,  52,  54,  56,  58,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,
		},
		{	/* Fourth byte table 1. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  26,  26,  28,  28,  30,  30,  32,
			32,  34,  34,  36,  36,  38,  38,  40,
			40,  42,  42,  44,  44,  46,  46,  48,
			48,  49,  49,  51,  51,  53,  53,  55,
			55,  55,  57,  57,  59,  59,  61,  61,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,
		},
		{	/* Fourth byte table 2. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   4,   4,   6,   6,
			8,   8,   8,   10,  10,  12,  12,  14,
			14,  16,  16,  18,  18,  20,  20,  22,
			22,  24,  24,  26,  26,  28,  28,  30,
			30,  32,  32,  34,  34,  36,  36,  38,
			38,  40,  40,  42,  42,  44,  44,  46,
			46,  48,  48,  50,  50,  52,  52,  54,
			54,  56,  58,  58,  60,  60,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,
		},
		{	/* Fourth byte table 3. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   4,   4,   6,   6,   8,
			10,  10,  12,  14,  16,  16,  16,  18,
			20,  22,  24,  24,  26,  28,  28,  30,
			32,  34,  34,  34,  34,  36,  38,  38,
			40,  42,  42,  44,  44,  46,  46,  48,
			50,  50,  52,  52,  52,  54,  54,  56,
			58,  58,  60,  62,  64,  64,  66,  66,
			68,  70,  70,  70,  70,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,
		},
		{	/* Fourth byte table 4. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   2,   4,   4,
			6,   8,   8,   10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  28,  30,
			30,  32,  32,  34,  34,  36,  36,  38,
			38,  40,  40,  42,  42,  44,  44,  46,
			46,  46,  48,  50,  50,  52,  52,  54,
			56,  58,  58,  60,  60,  62,  62,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,
		},
		{	/* Fourth byte table 5. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  26,  26,  28,  28,  30,  30,  32,
			32,  34,  34,  36,  36,  38,  38,  40,
			40,  42,  42,  44,  44,  46,  46,  48,
			48,  50,  50,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,
		},
		{	/* Fourth byte table 6. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   2,
			2,   4,   6,   8,   8,   10,  10,  12,
			14,  14,  16,  18,  20,  22,  24,  26,
			28,  30,  32,  34,  36,  38,  40,  42,
			44,  46,  48,  48,  50,  52,  54,  56,
			58,  60,  62,  64,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,
		},
		{	/* Fourth byte table 7. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  24,  24,  24,  24,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,
		},
		{	/* Fourth byte table 8. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  34,  36,  38,  40,  42,  44,  46,
			48,  50,  52,  54,  56,  58,  60,  62,
			64,  66,  68,  70,  72,  74,  76,  78,
			80,  82,  84,  86,  88,  90,  92,  94,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 9. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  26,  26,  28,  28,  30,  30,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,
		},
		{	/* Fourth byte table 10. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  26,  26,  28,  28,  30,  30,  32,
			32,  34,  34,  36,  36,  38,  38,  40,
			40,  42,  42,  44,  44,  46,  46,  48,
			48,  50,  50,  52,  52,  54,  54,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,
		},
		{	/* Fourth byte table 11. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   4,   4,   6,   6,
			8,   8,   10,  10,  12,  12,  14,  14,
			14,  16,  16,  18,  18,  20,  20,  22,
			22,  24,  24,  26,  26,  28,  28,  30,
			30,  32,  32,  34,  34,  36,  36,  38,
			38,  40,  40,  42,  42,  44,  44,  46,
			46,  48,  48,  50,  50,  52,  52,  52,
			52,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,
		},
		{	/* Fourth byte table 12. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  18,  20,  22,  24,  26,  28,
			30,  32,  34,  36,  38,  40,  42,  44,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,
		},
		{	/* Fourth byte table 13. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  34,  36,  38,  40,  42,  44,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,
		},
		{	/* Fourth byte table 14. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   6,   6,   9,   9,   12,
			12,  15,  15,  18,  18,  21,  21,  24,
			24,  27,  27,  30,  30,  33,  33,  36,
			36,  39,  39,  42,  42,  45,  45,  48,
			48,  51,  51,  54,  54,  57,  57,  60,
			60,  63,  63,  66,  66,  69,  69,  72,
			72,  75,  75,  78,  78,  81,  81,  84,
			84,  87,  87,  90,  90,  93,  93,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 15. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   6,   6,   9,   9,   12,
			12,  15,  15,  18,  18,  21,  21,  24,
			24,  27,  27,  30,  30,  33,  33,  36,
			36,  39,  39,  42,  42,  45,  45,  48,
			48,  51,  51,  54,  54,  57,  57,  60,
			60,  63,  63,  66,  66,  69,  69,  72,
			72,  75,  75,  78,  78,  81,  81,  84,
			84,  87,  87,  90,  90,  93,  93,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 16. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   6,   6,   9,   9,   12,
			12,  15,  15,  18,  18,  21,  21,  24,
			24,  27,  27,  30,  30,  33,  33,  33,
			33,  33,  33,  33,  33,  33,  33,  33,
			33,  36,  36,  39,  39,  42,  42,  45,
			45,  48,  48,  51,  51,  54,  54,  57,
			57,  60,  60,  63,  63,  66,  66,  69,
			69,  72,  72,  75,  75,  78,  78,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,
		},
		{	/* Fourth byte table 17. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   6,   6,   9,   9,   12,
			12,  15,  15,  18,  18,  21,  21,  24,
			24,  27,  27,  30,  30,  33,  33,  36,
			36,  39,  39,  42,  42,  45,  45,  48,
			48,  51,  51,  54,  54,  57,  57,  60,
			60,  63,  63,  66,  66,  69,  69,  72,
			72,  75,  75,  78,  78,  81,  81,  84,
			84,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,
		},
		{	/* Fourth byte table 18. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  24,  24,  24,  24,  24,  24,  24,
			24,  27,  30,  33,  36,  39,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  45,  48,  51,  54,  57,  60,  63,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  69,  72,  75,  78,  81,  84,  87,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,
		},
		{	/* Fourth byte table 19. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  21,  21,  24,  24,  27,  27,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  33,  36,  39,  42,  45,  48,  51,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,
		},
		{	/* Fourth byte table 20. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  24,  24,  24,  24,  24,  24,  24,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  51,  54,  57,  60,  63,  66,  69,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  75,  78,  81,  84,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,
		},
		{	/* Fourth byte table 21. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  15,  15,
			15,  15,  15,  15,  15,  15,  15,  15,
			15,  18,  21,  24,  27,  27,  27,  27,
			27,  27,  27,  27,  27,  27,  27,  27,
			27,  30,  33,  36,  39,  42,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  45,  48,  51,  54,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,
		},
		{	/* Fourth byte table 22. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   2,
			2,   2,   2,   3,   5,   5,   5,   5,
			5,   5,   5,   5,   5,   5,   5,   5,
			5,   5,   5,   5,   5,   5,   5,   5,
			5,   5,   5,   5,   5,   5,   5,   5,
			5,   5,   5,   5,   5,   5,   5,   5,
			5,   5,   5,   5,   5,   5,   5,   5,
			5,   5,   5,   5,   5,   5,   5,   5,
			5,   5,   5,   5,   5,   5,   5,   5,
			5,   5,   5,   5,   5,   5,   5,   5,
			5,   5,   5,   5,   5,   5,   5,   5,
			5,   5,   5,   5,   5,   5,   5,   5,
			5,
		},
		{	/* Fourth byte table 23. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,
		},
		{	/* Fourth byte table 24. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   3,
			6,   9,   12,  15,  18,  21,  24,  27,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,
		},
		{	/* Fourth byte table 25. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,
		},
		{	/* Fourth byte table 26. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   6,   9,   12,  15,  18,
			21,  24,  27,  30,  33,  36,  39,  42,
			45,  48,  51,  54,  57,  60,  63,  66,
			69,  72,  75,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,
		},
		{	/* Fourth byte table 27. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   4,   8,   12,  16,  20,  24,  28,
			32,  36,  40,  44,  48,  52,  56,  60,
			64,  68,  72,  76,  80,  84,  88,  92,
			96,  100, 104, 108, 112, 116, 120, 124,
			128, 132, 136, 140, 144, 148, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152, 152, 152, 152, 152, 152, 152, 152,
			152,
		},
		{	/* Fourth byte table 28. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 29. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 30. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 31. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 32. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 33. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 34. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 35. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
	},
	{
		{	/* Fourth byte table 0. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  34,  36,  38,  40,  42,  44,  46,
			46,  48,  50,  52,  54,  56,  58,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,  60,  60,  60,  60,  60,  60,  60,
			60,
		},
		{	/* Fourth byte table 1. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  26,  26,  28,  28,  30,  30,  32,
			32,  34,  34,  36,  36,  38,  38,  40,
			40,  42,  42,  44,  44,  46,  46,  48,
			48,  49,  49,  51,  51,  53,  53,  55,
			55,  55,  57,  57,  59,  59,  61,  61,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,
		},
		{	/* Fourth byte table 2. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   4,   4,   6,   6,
			8,   8,   8,   10,  10,  12,  12,  14,
			14,  16,  16,  18,  18,  20,  20,  22,
			22,  24,  24,  26,  26,  28,  28,  30,
			30,  32,  32,  34,  34,  36,  36,  38,
			38,  40,  40,  42,  42,  44,  44,  46,
			46,  48,  48,  50,  50,  52,  52,  54,
			54,  56,  58,  58,  60,  60,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,
		},
		{	/* Fourth byte table 3. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   4,   4,   6,   6,   8,
			10,  10,  12,  14,  16,  16,  16,  18,
			20,  22,  24,  24,  26,  28,  28,  30,
			32,  34,  34,  34,  34,  36,  38,  38,
			40,  42,  42,  44,  44,  46,  46,  48,
			50,  50,  52,  52,  52,  54,  54,  56,
			58,  58,  60,  62,  64,  64,  66,  66,
			68,  70,  70,  70,  70,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,
		},
		{	/* Fourth byte table 4. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   2,   4,   4,
			6,   8,   8,   10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  28,  30,
			30,  32,  32,  34,  34,  36,  36,  38,
			38,  40,  40,  42,  42,  44,  44,  46,
			46,  46,  48,  50,  50,  52,  52,  54,
			56,  58,  58,  60,  60,  62,  62,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,
		},
		{	/* Fourth byte table 5. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  26,  26,  28,  28,  30,  30,  32,
			32,  34,  34,  36,  36,  38,  38,  40,
			40,  42,  42,  44,  44,  46,  46,  48,
			48,  50,  50,  52,  52,  52,  52,  52,
			52,  52,  52,  55,  57,  57,  59,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,
		},
		{	/* Fourth byte table 6. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   4,   6,   8,   10,
			10,  12,  12,  14,  14,  16,  16,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,
		},
		{	/* Fourth byte table 7. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   2,
			2,   4,   6,   8,   8,   10,  10,  12,
			14,  14,  16,  18,  20,  22,  24,  26,
			28,  30,  32,  34,  36,  38,  40,  42,
			44,  46,  48,  48,  50,  52,  54,  56,
			58,  60,  62,  64,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,
		},
		{	/* Fourth byte table 8. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  24,  24,  24,  24,  26,  26,  26,
			28,  28,  30,  32,  32,  32,  34,  36,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,
		},
		{	/* Fourth byte table 9. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  34,  36,  38,  40,  42,  44,  46,
			48,  50,  52,  54,  56,  58,  60,  62,
			64,  66,  68,  70,  72,  74,  76,  78,
			80,  82,  84,  86,  88,  90,  92,  94,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 10. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  26,  26,  28,  28,  30,  30,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,
		},
		{	/* Fourth byte table 11. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  26,  26,  28,  28,  30,  30,  32,
			32,  34,  34,  36,  36,  38,  38,  40,
			40,  42,  42,  44,  44,  46,  46,  48,
			48,  50,  50,  52,  52,  54,  54,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,
		},
		{	/* Fourth byte table 12. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   4,   6,   6,   8,   8,
			10,  10,  12,  12,  14,  14,  16,  16,
			16,  18,  18,  20,  20,  22,  22,  24,
			24,  26,  26,  28,  28,  30,  30,  32,
			32,  34,  34,  36,  36,  38,  38,  40,
			40,  42,  42,  44,  44,  46,  46,  48,
			48,  50,  50,  52,  52,  54,  54,  56,
			56,  58,  58,  60,  60,  62,  62,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,
		},
		{	/* Fourth byte table 13. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  12,  12,  14,  14,  16,
			16,  18,  18,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  22,  24,  26,  28,  30,  32,
			34,  36,  38,  40,  42,  44,  46,  48,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,
		},
		{	/* Fourth byte table 14. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  34,  36,  38,  40,  42,  44,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,  46,  46,  46,  46,  46,  46,  46,
			46,
		},
		{	/* Fourth byte table 15. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  51,  54,  57,  60,  63,  66,  69,
			72,  75,  78,  81,  84,  87,  90,  93,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 16. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,
		},
		{	/* Fourth byte table 17. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   6,   6,   9,   9,   12,
			12,  15,  15,  18,  18,  21,  21,  24,
			24,  27,  27,  30,  30,  33,  33,  36,
			36,  39,  39,  42,  42,  45,  45,  48,
			48,  51,  51,  54,  54,  57,  57,  60,
			60,  63,  63,  66,  66,  69,  69,  72,
			72,  75,  75,  78,  78,  81,  81,  84,
			84,  87,  87,  90,  90,  93,  93,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 18. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   6,   6,   9,   9,   12,
			12,  15,  15,  18,  18,  21,  21,  24,
			24,  27,  27,  30,  30,  33,  33,  36,
			36,  39,  39,  42,  42,  45,  45,  48,
			48,  51,  51,  54,  54,  57,  57,  60,
			60,  63,  63,  66,  66,  69,  69,  72,
			72,  75,  75,  78,  78,  81,  81,  84,
			84,  87,  87,  90,  90,  93,  93,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 19. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   6,   6,   9,   9,   12,
			12,  15,  15,  18,  18,  21,  21,  24,
			24,  27,  27,  30,  30,  33,  33,  33,
			33,  33,  33,  33,  33,  33,  33,  33,
			33,  36,  36,  39,  39,  42,  42,  45,
			45,  48,  48,  51,  51,  54,  54,  57,
			57,  60,  60,  63,  63,  66,  66,  69,
			69,  72,  72,  75,  75,  78,  78,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  81,
			81,
		},
		{	/* Fourth byte table 20. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   6,   6,   9,   9,   12,
			12,  15,  15,  18,  18,  21,  21,  24,
			24,  27,  27,  30,  30,  33,  33,  36,
			36,  39,  39,  42,  42,  45,  45,  48,
			48,  51,  51,  54,  54,  57,  57,  60,
			60,  63,  63,  66,  66,  69,  69,  72,
			72,  75,  75,  78,  78,  81,  81,  84,
			84,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,
		},
		{	/* Fourth byte table 21. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  24,  24,  24,  24,  24,  24,  24,
			24,  27,  30,  33,  36,  39,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  45,  48,  51,  54,  57,  60,  63,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  69,  72,  75,  78,  81,  84,  87,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,
		},
		{	/* Fourth byte table 22. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  21,  21,  24,  24,  27,  27,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  33,  36,  39,  42,  45,  48,  51,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,
		},
		{	/* Fourth byte table 23. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  24,  24,  24,  24,  24,  24,  24,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  51,  54,  57,  60,  63,  66,  69,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  75,  78,  81,  84,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,
		},
		{	/* Fourth byte table 24. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  15,  15,
			15,  15,  15,  15,  15,  15,  15,  15,
			15,  18,  21,  24,  27,  27,  27,  27,
			27,  27,  27,  27,  27,  27,  27,  27,
			27,  30,  33,  36,  39,  42,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  45,  48,  51,  54,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,  57,  57,  57,  57,  57,  57,  57,
			57,
		},
		{	/* Fourth byte table 25. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   2,
			2,   2,   2,   3,   5,   5,   5,   5,
			5,   5,   5,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,
		},
		{	/* Fourth byte table 26. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,
		},
		{	/* Fourth byte table 27. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,
		},
		{	/* Fourth byte table 28. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   3,
			6,   9,   12,  15,  18,  21,  24,  27,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,
		},
		{	/* Fourth byte table 29. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,
		},
		{	/* Fourth byte table 30. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  51,  54,  57,  60,  63,  66,  69,
			72,  75,  78,  81,  84,  87,  90,  93,
			96,  99,  102, 105, 108, 111, 114, 117,
			120, 123, 126, 129, 132, 135, 138, 141,
			141, 141, 141, 141, 141, 141, 141, 141,
			141, 141, 141, 141, 141, 141, 141, 141,
			141, 141, 141, 141, 141, 141, 141, 141,
			141, 141, 141, 141, 141, 141, 141, 141,
			141, 141, 141, 141, 141, 141, 141, 141,
			141, 141, 141, 141, 141, 141, 141, 141,
			141, 141, 141, 141, 141, 141, 141, 141,
			141, 141, 141, 141, 141, 141, 141, 141,
			141, 141, 141, 141, 141, 141, 141, 141,
			141, 141, 141, 141, 141, 141, 141, 141,
			141,
		},
		{	/* Fourth byte table 31. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   5,   8,   10,  10,  10,
			13,  13,  16,  16,  19,  19,  19,  19,
			19,  19,  19,  19,  19,  19,  22,  22,
			22,  22,  22,  22,  22,  22,  22,  22,
			22,  22,  22,  22,  22,  22,  22,  22,
			22,  22,  22,  22,  22,  22,  22,  22,
			22,  22,  22,  22,  22,  22,  22,  22,
			22,  22,  22,  22,  22,  22,  22,  22,
			22,  22,  22,  22,  22,  22,  22,  22,
			22,  22,  22,  22,  22,  22,  22,  22,
			22,  22,  22,  22,  22,  22,  22,  22,
			22,  22,  22,  22,  22,  22,  22,  22,
			22,
		},
		{	/* Fourth byte table 32. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   6,   6,   9,   9,   12,
			12,  15,  15,  18,  18,  21,  21,  24,
			24,  27,  27,  30,  30,  33,  33,  36,
			36,  39,  39,  42,  42,  45,  45,  48,
			48,  51,  51,  54,  54,  57,  57,  60,
			60,  63,  63,  66,  66,  69,  69,  72,
			72,  75,  75,  78,  78,  81,  81,  84,
			84,  87,  87,  90,  90,  93,  93,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 33. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   3,   6,   6,   9,   9,   12,
			12,  15,  15,  18,  18,  21,  21,  24,
			24,  27,  27,  30,  30,  33,  33,  36,
			36,  39,  39,  42,  42,  45,  45,  48,
			48,  51,  51,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,
		},
		{	/* Fourth byte table 34. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   6,   9,   12,  15,  18,
			21,  24,  27,  30,  33,  36,  39,  42,
			45,  48,  51,  54,  57,  60,  63,  66,
			69,  72,  75,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,
		},
		{	/* Fourth byte table 35. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   4,   8,   12,  16,  20,  24,  28,
			32,  36,  40,  44,  48,  52,  56,  60,
			64,  68,  72,  76,  80,  84,  88,  92,
			96,  100, 104, 108, 112, 116, 120, 124,
			128, 132, 136, 140, 144, 148, 152, 156,
			160, 160, 160, 160, 160, 160, 160, 160,
			160, 160, 160, 160, 160, 160, 160, 160,
			160, 160, 160, 160, 160, 160, 160, 160,
			160, 160, 160, 160, 160, 160, 160, 160,
			160, 160, 160, 160, 160, 160, 160, 160,
			160, 160, 160, 160, 160, 160, 160, 160,
			160, 160, 160, 160, 160, 160, 160, 160,
			160, 160, 160, 160, 160, 160, 160, 160,
			160, 160, 160, 160, 160, 160, 160, 160,
			160, 160, 160, 160, 160, 160, 160, 160,
			160, 160, 160, 160, 160, 160, 160, 160,
			160,
		},
	},
};

static const uchar_t u8_tolower_final_tbl[2][2299] = {
	{
		0xC3, 0xA0, 0xC3, 0xA1, 0xC3, 0xA2, 0xC3, 0xA3,
		0xC3, 0xA4, 0xC3, 0xA5, 0xC3, 0xA6, 0xC3, 0xA7,
		0xC3, 0xA8, 0xC3, 0xA9, 0xC3, 0xAA, 0xC3, 0xAB,
		0xC3, 0xAC, 0xC3, 0xAD, 0xC3, 0xAE, 0xC3, 0xAF,
		0xC3, 0xB0, 0xC3, 0xB1, 0xC3, 0xB2, 0xC3, 0xB3,
		0xC3, 0xB4, 0xC3, 0xB5, 0xC3, 0xB6, 0xC3, 0xB8,
		0xC3, 0xB9, 0xC3, 0xBA, 0xC3, 0xBB, 0xC3, 0xBC,
		0xC3, 0xBD, 0xC3, 0xBE, 0xC4, 0x81, 0xC4, 0x83,
		0xC4, 0x85, 0xC4, 0x87, 0xC4, 0x89, 0xC4, 0x8B,
		0xC4, 0x8D, 0xC4, 0x8F, 0xC4, 0x91, 0xC4, 0x93,
		0xC4, 0x95, 0xC4, 0x97, 0xC4, 0x99, 0xC4, 0x9B,
		0xC4, 0x9D, 0xC4, 0x9F, 0xC4, 0xA1, 0xC4, 0xA3,
		0xC4, 0xA5, 0xC4, 0xA7, 0xC4, 0xA9, 0xC4, 0xAB,
		0xC4, 0xAD, 0xC4, 0xAF, 0x69, 0xC4, 0xB3, 0xC4,
		0xB5, 0xC4, 0xB7, 0xC4, 0xBA, 0xC4, 0xBC, 0xC4,
		0xBE, 0xC5, 0x80, 0xC5, 0x82, 0xC5, 0x84, 0xC5,
		0x86, 0xC5, 0x88, 0xC5, 0x8B, 0xC5, 0x8D, 0xC5,
		0x8F, 0xC5, 0x91, 0xC5, 0x93, 0xC5, 0x95, 0xC5,
		0x97, 0xC5, 0x99, 0xC5, 0x9B, 0xC5, 0x9D, 0xC5,
		0x9F, 0xC5, 0xA1, 0xC5, 0xA3, 0xC5, 0xA5, 0xC5,
		0xA7, 0xC5, 0xA9, 0xC5, 0xAB, 0xC5, 0xAD, 0xC5,
		0xAF, 0xC5, 0xB1, 0xC5, 0xB3, 0xC5, 0xB5, 0xC5,
		0xB7, 0xC3, 0xBF, 0xC5, 0xBA, 0xC5, 0xBC, 0xC5,
		0xBE, 0xC9, 0x93, 0xC6, 0x83, 0xC6, 0x85, 0xC9,
		0x94, 0xC6, 0x88, 0xC9, 0x96, 0xC9, 0x97, 0xC6,
		0x8C, 0xC7, 0x9D, 0xC9, 0x99, 0xC9, 0x9B, 0xC6,
		0x92, 0xC9, 0xA0, 0xC9, 0xA3, 0xC9, 0xA9, 0xC9,
		0xA8, 0xC6, 0x99, 0xC9, 0xAF, 0xC9, 0xB2, 0xC9,
		0xB5, 0xC6, 0xA1, 0xC6, 0xA3, 0xC6, 0xA5, 0xCA,
		0x80, 0xC6, 0xA8, 0xCA, 0x83, 0xC6, 0xAD, 0xCA,
		0x88, 0xC6, 0xB0, 0xCA, 0x8A, 0xCA, 0x8B, 0xC6,
		0xB4, 0xC6, 0xB6, 0xCA, 0x92, 0xC6, 0xB9, 0xC6,
		0xBD, 0xC7, 0x86, 0xC7, 0x86, 0xC7, 0x89, 0xC7,
		0x89, 0xC7, 0x8C, 0xC7, 0x8C, 0xC7, 0x8E, 0xC7,
		0x90, 0xC7, 0x92, 0xC7, 0x94, 0xC7, 0x96, 0xC7,
		0x98, 0xC7, 0x9A, 0xC7, 0x9C, 0xC7, 0x9F, 0xC7,
		0xA1, 0xC7, 0xA3, 0xC7, 0xA5, 0xC7, 0xA7, 0xC7,
		0xA9, 0xC7, 0xAB, 0xC7, 0xAD, 0xC7, 0xAF, 0xC7,
		0xB3, 0xC7, 0xB3, 0xC7, 0xB5, 0xC6, 0x95, 0xC6,
		0xBF, 0xC7, 0xB9, 0xC7, 0xBB, 0xC7, 0xBD, 0xC7,
		0xBF, 0xC8, 0x81, 0xC8, 0x83, 0xC8, 0x85, 0xC8,
		0x87, 0xC8, 0x89, 0xC8, 0x8B, 0xC8, 0x8D, 0xC8,
		0x8F, 0xC8, 0x91, 0xC8, 0x93, 0xC8, 0x95, 0xC8,
		0x97, 0xC8, 0x99, 0xC8, 0x9B, 0xC8, 0x9D, 0xC8,
		0x9F, 0xC6, 0x9E, 0xC8, 0xA3, 0xC8, 0xA5, 0xC8,
		0xA7, 0xC8, 0xA9, 0xC8, 0xAB, 0xC8, 0xAD, 0xC8,
		0xAF, 0xC8, 0xB1, 0xC8, 0xB3, 0xCE, 0xAC, 0xCE,
		0xAD, 0xCE, 0xAE, 0xCE, 0xAF, 0xCF, 0x8C, 0xCF,
		0x8D, 0xCF, 0x8E, 0xCE, 0xB1, 0xCE, 0xB2, 0xCE,
		0xB3, 0xCE, 0xB4, 0xCE, 0xB5, 0xCE, 0xB6, 0xCE,
		0xB7, 0xCE, 0xB8, 0xCE, 0xB9, 0xCE, 0xBA, 0xCE,
		0xBB, 0xCE, 0xBC, 0xCE, 0xBD, 0xCE, 0xBE, 0xCE,
		0xBF, 0xCF, 0x80, 0xCF, 0x81, 0xCF, 0x83, 0xCF,
		0x84, 0xCF, 0x85, 0xCF, 0x86, 0xCF, 0x87, 0xCF,
		0x88, 0xCF, 0x89, 0xCF, 0x8A, 0xCF, 0x8B, 0xCF,
		0x99, 0xCF, 0x9B, 0xCF, 0x9D, 0xCF, 0x9F, 0xCF,
		0xA1, 0xCF, 0xA3, 0xCF, 0xA5, 0xCF, 0xA7, 0xCF,
		0xA9, 0xCF, 0xAB, 0xCF, 0xAD, 0xCF, 0xAF, 0xCE,
		0xB8, 0xD1, 0x90, 0xD1, 0x91, 0xD1, 0x92, 0xD1,
		0x93, 0xD1, 0x94, 0xD1, 0x95, 0xD1, 0x96, 0xD1,
		0x97, 0xD1, 0x98, 0xD1, 0x99, 0xD1, 0x9A, 0xD1,
		0x9B, 0xD1, 0x9C, 0xD1, 0x9D, 0xD1, 0x9E, 0xD1,
		0x9F, 0xD0, 0xB0, 0xD0, 0xB1, 0xD0, 0xB2, 0xD0,
		0xB3, 0xD0, 0xB4, 0xD0, 0xB5, 0xD0, 0xB6, 0xD0,
		0xB7, 0xD0, 0xB8, 0xD0, 0xB9, 0xD0, 0xBA, 0xD0,
		0xBB, 0xD0, 0xBC, 0xD0, 0xBD, 0xD0, 0xBE, 0xD0,
		0xBF, 0xD1, 0x80, 0xD1, 0x81, 0xD1, 0x82, 0xD1,
		0x83, 0xD1, 0x84, 0xD1, 0x85, 0xD1, 0x86, 0xD1,
		0x87, 0xD1, 0x88, 0xD1, 0x89, 0xD1, 0x8A, 0xD1,
		0x8B, 0xD1, 0x8C, 0xD1, 0x8D, 0xD1, 0x8E, 0xD1,
		0x8F, 0xD1, 0xA1, 0xD1, 0xA3, 0xD1, 0xA5, 0xD1,
		0xA7, 0xD1, 0xA9, 0xD1, 0xAB, 0xD1, 0xAD, 0xD1,
		0xAF, 0xD1, 0xB1, 0xD1, 0xB3, 0xD1, 0xB5, 0xD1,
		0xB7, 0xD1, 0xB9, 0xD1, 0xBB, 0xD1, 0xBD, 0xD1,
		0xBF, 0xD2, 0x81, 0xD2, 0x8B, 0xD2, 0x8D, 0xD2,
		0x8F, 0xD2, 0x91, 0xD2, 0x93, 0xD2, 0x95, 0xD2,
		0x97, 0xD2, 0x99, 0xD2, 0x9B, 0xD2, 0x9D, 0xD2,
		0x9F, 0xD2, 0xA1, 0xD2, 0xA3, 0xD2, 0xA5, 0xD2,
		0xA7, 0xD2, 0xA9, 0xD2, 0xAB, 0xD2, 0xAD, 0xD2,
		0xAF, 0xD2, 0xB1, 0xD2, 0xB3, 0xD2, 0xB5, 0xD2,
		0xB7, 0xD2, 0xB9, 0xD2, 0xBB, 0xD2, 0xBD, 0xD2,
		0xBF, 0xD3, 0x82, 0xD3, 0x84, 0xD3, 0x86, 0xD3,
		0x88, 0xD3, 0x8A, 0xD3, 0x8C, 0xD3, 0x8E, 0xD3,
		0x91, 0xD3, 0x93, 0xD3, 0x95, 0xD3, 0x97, 0xD3,
		0x99, 0xD3, 0x9B, 0xD3, 0x9D, 0xD3, 0x9F, 0xD3,
		0xA1, 0xD3, 0xA3, 0xD3, 0xA5, 0xD3, 0xA7, 0xD3,
		0xA9, 0xD3, 0xAB, 0xD3, 0xAD, 0xD3, 0xAF, 0xD3,
		0xB1, 0xD3, 0xB3, 0xD3, 0xB5, 0xD3, 0xB9, 0xD4,
		0x81, 0xD4, 0x83, 0xD4, 0x85, 0xD4, 0x87, 0xD4,
		0x89, 0xD4, 0x8B, 0xD4, 0x8D, 0xD4, 0x8F, 0xD5,
		0xA1, 0xD5, 0xA2, 0xD5, 0xA3, 0xD5, 0xA4, 0xD5,
		0xA5, 0xD5, 0xA6, 0xD5, 0xA7, 0xD5, 0xA8, 0xD5,
		0xA9, 0xD5, 0xAA, 0xD5, 0xAB, 0xD5, 0xAC, 0xD5,
		0xAD, 0xD5, 0xAE, 0xD5, 0xAF, 0xD5, 0xB0, 0xD5,
		0xB1, 0xD5, 0xB2, 0xD5, 0xB3, 0xD5, 0xB4, 0xD5,
		0xB5, 0xD5, 0xB6, 0xD5, 0xB7, 0xD5, 0xB8, 0xD5,
		0xB9, 0xD5, 0xBA, 0xD5, 0xBB, 0xD5, 0xBC, 0xD5,
		0xBD, 0xD5, 0xBE, 0xD5, 0xBF, 0xD6, 0x80, 0xD6,
		0x81, 0xD6, 0x82, 0xD6, 0x83, 0xD6, 0x84, 0xD6,
		0x85, 0xD6, 0x86, 0xE1, 0xB8, 0x81, 0xE1, 0xB8,
		0x83, 0xE1, 0xB8, 0x85, 0xE1, 0xB8, 0x87, 0xE1,
		0xB8, 0x89, 0xE1, 0xB8, 0x8B, 0xE1, 0xB8, 0x8D,
		0xE1, 0xB8, 0x8F, 0xE1, 0xB8, 0x91, 0xE1, 0xB8,
		0x93, 0xE1, 0xB8, 0x95, 0xE1, 0xB8, 0x97, 0xE1,
		0xB8, 0x99, 0xE1, 0xB8, 0x9B, 0xE1, 0xB8, 0x9D,
		0xE1, 0xB8, 0x9F, 0xE1, 0xB8, 0xA1, 0xE1, 0xB8,
		0xA3, 0xE1, 0xB8, 0xA5, 0xE1, 0xB8, 0xA7, 0xE1,
		0xB8, 0xA9, 0xE1, 0xB8, 0xAB, 0xE1, 0xB8, 0xAD,
		0xE1, 0xB8, 0xAF, 0xE1, 0xB8, 0xB1, 0xE1, 0xB8,
		0xB3, 0xE1, 0xB8, 0xB5, 0xE1, 0xB8, 0xB7, 0xE1,
		0xB8, 0xB9, 0xE1, 0xB8, 0xBB, 0xE1, 0xB8, 0xBD,
		0xE1, 0xB8, 0xBF, 0xE1, 0xB9, 0x81, 0xE1, 0xB9,
		0x83, 0xE1, 0xB9, 0x85, 0xE1, 0xB9, 0x87, 0xE1,
		0xB9, 0x89, 0xE1, 0xB9, 0x8B, 0xE1, 0xB9, 0x8D,
		0xE1, 0xB9, 0x8F, 0xE1, 0xB9, 0x91, 0xE1, 0xB9,
		0x93, 0xE1, 0xB9, 0x95, 0xE1, 0xB9, 0x97, 0xE1,
		0xB9, 0x99, 0xE1, 0xB9, 0x9B, 0xE1, 0xB9, 0x9D,
		0xE1, 0xB9, 0x9F, 0xE1, 0xB9, 0xA1, 0xE1, 0xB9,
		0xA3, 0xE1, 0xB9, 0xA5, 0xE1, 0xB9, 0xA7, 0xE1,
		0xB9, 0xA9, 0xE1, 0xB9, 0xAB, 0xE1, 0xB9, 0xAD,
		0xE1, 0xB9, 0xAF, 0xE1, 0xB9, 0xB1, 0xE1, 0xB9,
		0xB3, 0xE1, 0xB9, 0xB5, 0xE1, 0xB9, 0xB7, 0xE1,
		0xB9, 0xB9, 0xE1, 0xB9, 0xBB, 0xE1, 0xB9, 0xBD,
		0xE1, 0xB9, 0xBF, 0xE1, 0xBA, 0x81, 0xE1, 0xBA,
		0x83, 0xE1, 0xBA, 0x85, 0xE1, 0xBA, 0x87, 0xE1,
		0xBA, 0x89, 0xE1, 0xBA, 0x8B, 0xE1, 0xBA, 0x8D,
		0xE1, 0xBA, 0x8F, 0xE1, 0xBA, 0x91, 0xE1, 0xBA,
		0x93, 0xE1, 0xBA, 0x95, 0xE1, 0xBA, 0xA1, 0xE1,
		0xBA, 0xA3, 0xE1, 0xBA, 0xA5, 0xE1, 0xBA, 0xA7,
		0xE1, 0xBA, 0xA9, 0xE1, 0xBA, 0xAB, 0xE1, 0xBA,
		0xAD, 0xE1, 0xBA, 0xAF, 0xE1, 0xBA, 0xB1, 0xE1,
		0xBA, 0xB3, 0xE1, 0xBA, 0xB5, 0xE1, 0xBA, 0xB7,
		0xE1, 0xBA, 0xB9, 0xE1, 0xBA, 0xBB, 0xE1, 0xBA,
		0xBD, 0xE1, 0xBA, 0xBF, 0xE1, 0xBB, 0x81, 0xE1,
		0xBB, 0x83, 0xE1, 0xBB, 0x85, 0xE1, 0xBB, 0x87,
		0xE1, 0xBB, 0x89, 0xE1, 0xBB, 0x8B, 0xE1, 0xBB,
		0x8D, 0xE1, 0xBB, 0x8F, 0xE1, 0xBB, 0x91, 0xE1,
		0xBB, 0x93, 0xE1, 0xBB, 0x95, 0xE1, 0xBB, 0x97,
		0xE1, 0xBB, 0x99, 0xE1, 0xBB, 0x9B, 0xE1, 0xBB,
		0x9D, 0xE1, 0xBB, 0x9F, 0xE1, 0xBB, 0xA1, 0xE1,
		0xBB, 0xA3, 0xE1, 0xBB, 0xA5, 0xE1, 0xBB, 0xA7,
		0xE1, 0xBB, 0xA9, 0xE1, 0xBB, 0xAB, 0xE1, 0xBB,
		0xAD, 0xE1, 0xBB, 0xAF, 0xE1, 0xBB, 0xB1, 0xE1,
		0xBB, 0xB3, 0xE1, 0xBB, 0xB5, 0xE1, 0xBB, 0xB7,
		0xE1, 0xBB, 0xB9, 0xE1, 0xBC, 0x80, 0xE1, 0xBC,
		0x81, 0xE1, 0xBC, 0x82, 0xE1, 0xBC, 0x83, 0xE1,
		0xBC, 0x84, 0xE1, 0xBC, 0x85, 0xE1, 0xBC, 0x86,
		0xE1, 0xBC, 0x87, 0xE1, 0xBC, 0x90, 0xE1, 0xBC,
		0x91, 0xE1, 0xBC, 0x92, 0xE1, 0xBC, 0x93, 0xE1,
		0xBC, 0x94, 0xE1, 0xBC, 0x95, 0xE1, 0xBC, 0xA0,
		0xE1, 0xBC, 0xA1, 0xE1, 0xBC, 0xA2, 0xE1, 0xBC,
		0xA3, 0xE1, 0xBC, 0xA4, 0xE1, 0xBC, 0xA5, 0xE1,
		0xBC, 0xA6, 0xE1, 0xBC, 0xA7, 0xE1, 0xBC, 0xB0,
		0xE1, 0xBC, 0xB1, 0xE1, 0xBC, 0xB2, 0xE1, 0xBC,
		0xB3, 0xE1, 0xBC, 0xB4, 0xE1, 0xBC, 0xB5, 0xE1,
		0xBC, 0xB6, 0xE1, 0xBC, 0xB7, 0xE1, 0xBD, 0x80,
		0xE1, 0xBD, 0x81, 0xE1, 0xBD, 0x82, 0xE1, 0xBD,
		0x83, 0xE1, 0xBD, 0x84, 0xE1, 0xBD, 0x85, 0xE1,
		0xBD, 0x91, 0xE1, 0xBD, 0x93, 0xE1, 0xBD, 0x95,
		0xE1, 0xBD, 0x97, 0xE1, 0xBD, 0xA0, 0xE1, 0xBD,
		0xA1, 0xE1, 0xBD, 0xA2, 0xE1, 0xBD, 0xA3, 0xE1,
		0xBD, 0xA4, 0xE1, 0xBD, 0xA5, 0xE1, 0xBD, 0xA6,
		0xE1, 0xBD, 0xA7, 0xE1, 0xBE, 0x80, 0xE1, 0xBE,
		0x81, 0xE1, 0xBE, 0x82, 0xE1, 0xBE, 0x83, 0xE1,
		0xBE, 0x84, 0xE1, 0xBE, 0x85, 0xE1, 0xBE, 0x86,
		0xE1, 0xBE, 0x87, 0xE1, 0xBE, 0x90, 0xE1, 0xBE,
		0x91, 0xE1, 0xBE, 0x92, 0xE1, 0xBE, 0x93, 0xE1,
		0xBE, 0x94, 0xE1, 0xBE, 0x95, 0xE1, 0xBE, 0x96,
		0xE1, 0xBE, 0x97, 0xE1, 0xBE, 0xA0, 0xE1, 0xBE,
		0xA1, 0xE1, 0xBE, 0xA2, 0xE1, 0xBE, 0xA3, 0xE1,
		0xBE, 0xA4, 0xE1, 0xBE, 0xA5, 0xE1, 0xBE, 0xA6,
		0xE1, 0xBE, 0xA7, 0xE1, 0xBE, 0xB0, 0xE1, 0xBE,
		0xB1, 0xE1, 0xBD, 0xB0, 0xE1, 0xBD, 0xB1, 0xE1,
		0xBE, 0xB3, 0xE1, 0xBD, 0xB2, 0xE1, 0xBD, 0xB3,
		0xE1, 0xBD, 0xB4, 0xE1, 0xBD, 0xB5, 0xE1, 0xBF,
		0x83, 0xE1, 0xBF, 0x90, 0xE1, 0xBF, 0x91, 0xE1,
		0xBD, 0xB6, 0xE1, 0xBD, 0xB7, 0xE1, 0xBF, 0xA0,
		0xE1, 0xBF, 0xA1, 0xE1, 0xBD, 0xBA, 0xE1, 0xBD,
		0xBB, 0xE1, 0xBF, 0xA5, 0xE1, 0xBD, 0xB8, 0xE1,
		0xBD, 0xB9, 0xE1, 0xBD, 0xBC, 0xE1, 0xBD, 0xBD,
		0xE1, 0xBF, 0xB3, 0xCF, 0x89, 0x6B, 0xC3, 0xA5,
		0xE2, 0x85, 0xB0, 0xE2, 0x85, 0xB1, 0xE2, 0x85,
		0xB2, 0xE2, 0x85, 0xB3, 0xE2, 0x85, 0xB4, 0xE2,
		0x85, 0xB5, 0xE2, 0x85, 0xB6, 0xE2, 0x85, 0xB7,
		0xE2, 0x85, 0xB8, 0xE2, 0x85, 0xB9, 0xE2, 0x85,
		0xBA, 0xE2, 0x85, 0xBB, 0xE2, 0x85, 0xBC, 0xE2,
		0x85, 0xBD, 0xE2, 0x85, 0xBE, 0xE2, 0x85, 0xBF,
		0xE2, 0x93, 0x90, 0xE2, 0x93, 0x91, 0xE2, 0x93,
		0x92, 0xE2, 0x93, 0x93, 0xE2, 0x93, 0x94, 0xE2,
		0x93, 0x95, 0xE2, 0x93, 0x96, 0xE2, 0x93, 0x97,
		0xE2, 0x93, 0x98, 0xE2, 0x93, 0x99, 0xE2, 0x93,
		0x9A, 0xE2, 0x93, 0x9B, 0xE2, 0x93, 0x9C, 0xE2,
		0x93, 0x9D, 0xE2, 0x93, 0x9E, 0xE2, 0x93, 0x9F,
		0xE2, 0x93, 0xA0, 0xE2, 0x93, 0xA1, 0xE2, 0x93,
		0xA2, 0xE2, 0x93, 0xA3, 0xE2, 0x93, 0xA4, 0xE2,
		0x93, 0xA5, 0xE2, 0x93, 0xA6, 0xE2, 0x93, 0xA7,
		0xE2, 0x93, 0xA8, 0xE2, 0x93, 0xA9, 0xEF, 0xBD,
		0x81, 0xEF, 0xBD, 0x82, 0xEF, 0xBD, 0x83, 0xEF,
		0xBD, 0x84, 0xEF, 0xBD, 0x85, 0xEF, 0xBD, 0x86,
		0xEF, 0xBD, 0x87, 0xEF, 0xBD, 0x88, 0xEF, 0xBD,
		0x89, 0xEF, 0xBD, 0x8A, 0xEF, 0xBD, 0x8B, 0xEF,
		0xBD, 0x8C, 0xEF, 0xBD, 0x8D, 0xEF, 0xBD, 0x8E,
		0xEF, 0xBD, 0x8F, 0xEF, 0xBD, 0x90, 0xEF, 0xBD,
		0x91, 0xEF, 0xBD, 0x92, 0xEF, 0xBD, 0x93, 0xEF,
		0xBD, 0x94, 0xEF, 0xBD, 0x95, 0xEF, 0xBD, 0x96,
		0xEF, 0xBD, 0x97, 0xEF, 0xBD, 0x98, 0xEF, 0xBD,
		0x99, 0xEF, 0xBD, 0x9A, 0xF0, 0x90, 0x90, 0xA8,
		0xF0, 0x90, 0x90, 0xA9, 0xF0, 0x90, 0x90, 0xAA,
		0xF0, 0x90, 0x90, 0xAB, 0xF0, 0x90, 0x90, 0xAC,
		0xF0, 0x90, 0x90, 0xAD, 0xF0, 0x90, 0x90, 0xAE,
		0xF0, 0x90, 0x90, 0xAF, 0xF0, 0x90, 0x90, 0xB0,
		0xF0, 0x90, 0x90, 0xB1, 0xF0, 0x90, 0x90, 0xB2,
		0xF0, 0x90, 0x90, 0xB3, 0xF0, 0x90, 0x90, 0xB4,
		0xF0, 0x90, 0x90, 0xB5, 0xF0, 0x90, 0x90, 0xB6,
		0xF0, 0x90, 0x90, 0xB7, 0xF0, 0x90, 0x90, 0xB8,
		0xF0, 0x90, 0x90, 0xB9, 0xF0, 0x90, 0x90, 0xBA,
		0xF0, 0x90, 0x90, 0xBB, 0xF0, 0x90, 0x90, 0xBC,
		0xF0, 0x90, 0x90, 0xBD, 0xF0, 0x90, 0x90, 0xBE,
		0xF0, 0x90, 0x90, 0xBF, 0xF0, 0x90, 0x91, 0x80,
		0xF0, 0x90, 0x91, 0x81, 0xF0, 0x90, 0x91, 0x82,
		0xF0, 0x90, 0x91, 0x83, 0xF0, 0x90, 0x91, 0x84,
		0xF0, 0x90, 0x91, 0x85, 0xF0, 0x90, 0x91, 0x86,
		0xF0, 0x90, 0x91, 0x87, 0xF0, 0x90, 0x91, 0x88,
		0xF0, 0x90, 0x91, 0x89, 0xF0, 0x90, 0x91, 0x8A,
		0xF0, 0x90, 0x91, 0x8B, 0xF0, 0x90, 0x91, 0x8C,
		0xF0, 0x90, 0x91, 0x8D, 0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,
	},
	{
		0xC3, 0xA0, 0xC3, 0xA1, 0xC3, 0xA2, 0xC3, 0xA3,
		0xC3, 0xA4, 0xC3, 0xA5, 0xC3, 0xA6, 0xC3, 0xA7,
		0xC3, 0xA8, 0xC3, 0xA9, 0xC3, 0xAA, 0xC3, 0xAB,
		0xC3, 0xAC, 0xC3, 0xAD, 0xC3, 0xAE, 0xC3, 0xAF,
		0xC3, 0xB0, 0xC3, 0xB1, 0xC3, 0xB2, 0xC3, 0xB3,
		0xC3, 0xB4, 0xC3, 0xB5, 0xC3, 0xB6, 0xC3, 0xB8,
		0xC3, 0xB9, 0xC3, 0xBA, 0xC3, 0xBB, 0xC3, 0xBC,
		0xC3, 0xBD, 0xC3, 0xBE, 0xC4, 0x81, 0xC4, 0x83,
		0xC4, 0x85, 0xC4, 0x87, 0xC4, 0x89, 0xC4, 0x8B,
		0xC4, 0x8D, 0xC4, 0x8F, 0xC4, 0x91, 0xC4, 0x93,
		0xC4, 0x95, 0xC4, 0x97, 0xC4, 0x99, 0xC4, 0x9B,
		0xC4, 0x9D, 0xC4, 0x9F, 0xC4, 0xA1, 0xC4, 0xA3,
		0xC4, 0xA5, 0xC4, 0xA7, 0xC4, 0xA9, 0xC4, 0xAB,
		0xC4, 0xAD, 0xC4, 0xAF, 0x69, 0xC4, 0xB3, 0xC4,
		0xB5, 0xC4, 0xB7, 0xC4, 0xBA, 0xC4, 0xBC, 0xC4,
		0xBE, 0xC5, 0x80, 0xC5, 0x82, 0xC5, 0x84, 0xC5,
		0x86, 0xC5, 0x88, 0xC5, 0x8B, 0xC5, 0x8D, 0xC5,
		0x8F, 0xC5, 0x91, 0xC5, 0x93, 0xC5, 0x95, 0xC5,
		0x97, 0xC5, 0x99, 0xC5, 0x9B, 0xC5, 0x9D, 0xC5,
		0x9F, 0xC5, 0xA1, 0xC5, 0xA3, 0xC5, 0xA5, 0xC5,
		0xA7, 0xC5, 0xA9, 0xC5, 0xAB, 0xC5, 0xAD, 0xC5,
		0xAF, 0xC5, 0xB1, 0xC5, 0xB3, 0xC5, 0xB5, 0xC5,
		0xB7, 0xC3, 0xBF, 0xC5, 0xBA, 0xC5, 0xBC, 0xC5,
		0xBE, 0xC9, 0x93, 0xC6, 0x83, 0xC6, 0x85, 0xC9,
		0x94, 0xC6, 0x88, 0xC9, 0x96, 0xC9, 0x97, 0xC6,
		0x8C, 0xC7, 0x9D, 0xC9, 0x99, 0xC9, 0x9B, 0xC6,
		0x92, 0xC9, 0xA0, 0xC9, 0xA3, 0xC9, 0xA9, 0xC9,
		0xA8, 0xC6, 0x99, 0xC9, 0xAF, 0xC9, 0xB2, 0xC9,
		0xB5, 0xC6, 0xA1, 0xC6, 0xA3, 0xC6, 0xA5, 0xCA,
		0x80, 0xC6, 0xA8, 0xCA, 0x83, 0xC6, 0xAD, 0xCA,
		0x88, 0xC6, 0xB0, 0xCA, 0x8A, 0xCA, 0x8B, 0xC6,
		0xB4, 0xC6, 0xB6, 0xCA, 0x92, 0xC6, 0xB9, 0xC6,
		0xBD, 0xC7, 0x86, 0xC7, 0x86, 0xC7, 0x89, 0xC7,
		0x89, 0xC7, 0x8C, 0xC7, 0x8C, 0xC7, 0x8E, 0xC7,
		0x90, 0xC7, 0x92, 0xC7, 0x94, 0xC7, 0x96, 0xC7,
		0x98, 0xC7, 0x9A, 0xC7, 0x9C, 0xC7, 0x9F, 0xC7,
		0xA1, 0xC7, 0xA3, 0xC7, 0xA5, 0xC7, 0xA7, 0xC7,
		0xA9, 0xC7, 0xAB, 0xC7, 0xAD, 0xC7, 0xAF, 0xC7,
		0xB3, 0xC7, 0xB3, 0xC7, 0xB5, 0xC6, 0x95, 0xC6,
		0xBF, 0xC7, 0xB9, 0xC7, 0xBB, 0xC7, 0xBD, 0xC7,
		0xBF, 0xC8, 0x81, 0xC8, 0x83, 0xC8, 0x85, 0xC8,
		0x87, 0xC8, 0x89, 0xC8, 0x8B, 0xC8, 0x8D, 0xC8,
		0x8F, 0xC8, 0x91, 0xC8, 0x93, 0xC8, 0x95, 0xC8,
		0x97, 0xC8, 0x99, 0xC8, 0x9B, 0xC8, 0x9D, 0xC8,
		0x9F, 0xC6, 0x9E, 0xC8, 0xA3, 0xC8, 0xA5, 0xC8,
		0xA7, 0xC8, 0xA9, 0xC8, 0xAB, 0xC8, 0xAD, 0xC8,
		0xAF, 0xC8, 0xB1, 0xC8, 0xB3, 0xE2, 0xB1, 0xA5,
		0xC8, 0xBC, 0xC6, 0x9A, 0xE2, 0xB1, 0xA6, 0xC9,
		0x82, 0xC6, 0x80, 0xCA, 0x89, 0xCA, 0x8C, 0xC9,
		0x87, 0xC9, 0x89, 0xC9, 0x8B, 0xC9, 0x8D, 0xC9,
		0x8F, 0xCE, 0xAC, 0xCE, 0xAD, 0xCE, 0xAE, 0xCE,
		0xAF, 0xCF, 0x8C, 0xCF, 0x8D, 0xCF, 0x8E, 0xCE,
		0xB1, 0xCE, 0xB2, 0xCE, 0xB3, 0xCE, 0xB4, 0xCE,
		0xB5, 0xCE, 0xB6, 0xCE, 0xB7, 0xCE, 0xB8, 0xCE,
		0xB9, 0xCE, 0xBA, 0xCE, 0xBB, 0xCE, 0xBC, 0xCE,
		0xBD, 0xCE, 0xBE, 0xCE, 0xBF, 0xCF, 0x80, 0xCF,
		0x81, 0xCF, 0x83, 0xCF, 0x84, 0xCF, 0x85, 0xCF,
		0x86, 0xCF, 0x87, 0xCF, 0x88, 0xCF, 0x89, 0xCF,
		0x8A, 0xCF, 0x8B, 0xCF, 0x99, 0xCF, 0x9B, 0xCF,
		0x9D, 0xCF, 0x9F, 0xCF, 0xA1, 0xCF, 0xA3, 0xCF,
		0xA5, 0xCF, 0xA7, 0xCF, 0xA9, 0xCF, 0xAB, 0xCF,
		0xAD, 0xCF, 0xAF, 0xCE, 0xB8, 0xCF, 0xB8, 0xCF,
		0xB2, 0xCF, 0xBB, 0xCD, 0xBB, 0xCD, 0xBC, 0xCD,
		0xBD, 0xD1, 0x90, 0xD1, 0x91, 0xD1, 0x92, 0xD1,
		0x93, 0xD1, 0x94, 0xD1, 0x95, 0xD1, 0x96, 0xD1,
		0x97, 0xD1, 0x98, 0xD1, 0x99, 0xD1, 0x9A, 0xD1,
		0x9B, 0xD1, 0x9C, 0xD1, 0x9D, 0xD1, 0x9E, 0xD1,
		0x9F, 0xD0, 0xB0, 0xD0, 0xB1, 0xD0, 0xB2, 0xD0,
		0xB3, 0xD0, 0xB4, 0xD0, 0xB5, 0xD0, 0xB6, 0xD0,
		0xB7, 0xD0, 0xB8, 0xD0, 0xB9, 0xD0, 0xBA, 0xD0,
		0xBB, 0xD0, 0xBC, 0xD0, 0xBD, 0xD0, 0xBE, 0xD0,
		0xBF, 0xD1, 0x80, 0xD1, 0x81, 0xD1, 0x82, 0xD1,
		0x83, 0xD1, 0x84, 0xD1, 0x85, 0xD1, 0x86, 0xD1,
		0x87, 0xD1, 0x88, 0xD1, 0x89, 0xD1, 0x8A, 0xD1,
		0x8B, 0xD1, 0x8C, 0xD1, 0x8D, 0xD1, 0x8E, 0xD1,
		0x8F, 0xD1, 0xA1, 0xD1, 0xA3, 0xD1, 0xA5, 0xD1,
		0xA7, 0xD1, 0xA9, 0xD1, 0xAB, 0xD1, 0xAD, 0xD1,
		0xAF, 0xD1, 0xB1, 0xD1, 0xB3, 0xD1, 0xB5, 0xD1,
		0xB7, 0xD1, 0xB9, 0xD1, 0xBB, 0xD1, 0xBD, 0xD1,
		0xBF, 0xD2, 0x81, 0xD2, 0x8B, 0xD2, 0x8D, 0xD2,
		0x8F, 0xD2, 0x91, 0xD2, 0x93, 0xD2, 0x95, 0xD2,
		0x97, 0xD2, 0x99, 0xD2, 0x9B, 0xD2, 0x9D, 0xD2,
		0x9F, 0xD2, 0xA1, 0xD2, 0xA3, 0xD2, 0xA5, 0xD2,
		0xA7, 0xD2, 0xA9, 0xD2, 0xAB, 0xD2, 0xAD, 0xD2,
		0xAF, 0xD2, 0xB1, 0xD2, 0xB3, 0xD2, 0xB5, 0xD2,
		0xB7, 0xD2, 0xB9, 0xD2, 0xBB, 0xD2, 0xBD, 0xD2,
		0xBF, 0xD3, 0x8F, 0xD3, 0x82, 0xD3, 0x84, 0xD3,
		0x86, 0xD3, 0x88, 0xD3, 0x8A, 0xD3, 0x8C, 0xD3,
		0x8E, 0xD3, 0x91, 0xD3, 0x93, 0xD3, 0x95, 0xD3,
		0x97, 0xD3, 0x99, 0xD3, 0x9B, 0xD3, 0x9D, 0xD3,
		0x9F, 0xD3, 0xA1, 0xD3, 0xA3, 0xD3, 0xA5, 0xD3,
		0xA7, 0xD3, 0xA9, 0xD3, 0xAB, 0xD3, 0xAD, 0xD3,
		0xAF, 0xD3, 0xB1, 0xD3, 0xB3, 0xD3, 0xB5, 0xD3,
		0xB7, 0xD3, 0xB9, 0xD3, 0xBB, 0xD3, 0xBD, 0xD3,
		0xBF, 0xD4, 0x81, 0xD4, 0x83, 0xD4, 0x85, 0xD4,
		0x87, 0xD4, 0x89, 0xD4, 0x8B, 0xD4, 0x8D, 0xD4,
		0x8F, 0xD4, 0x91, 0xD4, 0x93, 0xD5, 0xA1, 0xD5,
		0xA2, 0xD5, 0xA3, 0xD5, 0xA4, 0xD5, 0xA5, 0xD5,
		0xA6, 0xD5, 0xA7, 0xD5, 0xA8, 0xD5, 0xA9, 0xD5,
		0xAA, 0xD5, 0xAB, 0xD5, 0xAC, 0xD5, 0xAD, 0xD5,
		0xAE, 0xD5, 0xAF, 0xD5, 0xB0, 0xD5, 0xB1, 0xD5,
		0xB2, 0xD5, 0xB3, 0xD5, 0xB4, 0xD5, 0xB5, 0xD5,
		0xB6, 0xD5, 0xB7, 0xD5, 0xB8, 0xD5, 0xB9, 0xD5,
		0xBA, 0xD5, 0xBB, 0xD5, 0xBC, 0xD5, 0xBD, 0xD5,
		0xBE, 0xD5, 0xBF, 0xD6, 0x80, 0xD6, 0x81, 0xD6,
		0x82, 0xD6, 0x83, 0xD6, 0x84, 0xD6, 0x85, 0xD6,
		0x86, 0xE2, 0xB4, 0x80, 0xE2, 0xB4, 0x81, 0xE2,
		0xB4, 0x82, 0xE2, 0xB4, 0x83, 0xE2, 0xB4, 0x84,
		0xE2, 0xB4, 0x85, 0xE2, 0xB4, 0x86, 0xE2, 0xB4,
		0x87, 0xE2, 0xB4, 0x88, 0xE2, 0xB4, 0x89, 0xE2,
		0xB4, 0x8A, 0xE2, 0xB4, 0x8B, 0xE2, 0xB4, 0x8C,
		0xE2, 0xB4, 0x8D, 0xE2, 0xB4, 0x8E, 0xE2, 0xB4,
		0x8F, 0xE2, 0xB4, 0x90, 0xE2, 0xB4, 0x91, 0xE2,
		0xB4, 0x92, 0xE2, 0xB4, 0x93, 0xE2, 0xB4, 0x94,
		0xE2, 0xB4, 0x95, 0xE2, 0xB4, 0x96, 0xE2, 0xB4,
		0x97, 0xE2, 0xB4, 0x98, 0xE2, 0xB4, 0x99, 0xE2,
		0xB4, 0x9A, 0xE2, 0xB4, 0x9B, 0xE2, 0xB4, 0x9C,
		0xE2, 0xB4, 0x9D, 0xE2, 0xB4, 0x9E, 0xE2, 0xB4,
		0x9F, 0xE2, 0xB4, 0xA0, 0xE2, 0xB4, 0xA1, 0xE2,
		0xB4, 0xA2, 0xE2, 0xB4, 0xA3, 0xE2, 0xB4, 0xA4,
		0xE2, 0xB4, 0xA5, 0xE1, 0xB8, 0x81, 0xE1, 0xB8,
		0x83, 0xE1, 0xB8, 0x85, 0xE1, 0xB8, 0x87, 0xE1,
		0xB8, 0x89, 0xE1, 0xB8, 0x8B, 0xE1, 0xB8, 0x8D,
		0xE1, 0xB8, 0x8F, 0xE1, 0xB8, 0x91, 0xE1, 0xB8,
		0x93, 0xE1, 0xB8, 0x95, 0xE1, 0xB8, 0x97, 0xE1,
		0xB8, 0x99, 0xE1, 0xB8, 0x9B, 0xE1, 0xB8, 0x9D,
		0xE1, 0xB8, 0x9F, 0xE1, 0xB8, 0xA1, 0xE1, 0xB8,
		0xA3, 0xE1, 0xB8, 0xA5, 0xE1, 0xB8, 0xA7, 0xE1,
		0xB8, 0xA9, 0xE1, 0xB8, 0xAB, 0xE1, 0xB8, 0xAD,
		0xE1, 0xB8, 0xAF, 0xE1, 0xB8, 0xB1, 0xE1, 0xB8,
		0xB3, 0xE1, 0xB8, 0xB5, 0xE1, 0xB8, 0xB7, 0xE1,
		0xB8, 0xB9, 0xE1, 0xB8, 0xBB, 0xE1, 0xB8, 0xBD,
		0xE1, 0xB8, 0xBF, 0xE1, 0xB9, 0x81, 0xE1, 0xB9,
		0x83, 0xE1, 0xB9, 0x85, 0xE1, 0xB9, 0x87, 0xE1,
		0xB9, 0x89, 0xE1, 0xB9, 0x8B, 0xE1, 0xB9, 0x8D,
		0xE1, 0xB9, 0x8F, 0xE1, 0xB9, 0x91, 0xE1, 0xB9,
		0x93, 0xE1, 0xB9, 0x95, 0xE1, 0xB9, 0x97, 0xE1,
		0xB9, 0x99, 0xE1, 0xB9, 0x9B, 0xE1, 0xB9, 0x9D,
		0xE1, 0xB9, 0x9F, 0xE1, 0xB9, 0xA1, 0xE1, 0xB9,
		0xA3, 0xE1, 0xB9, 0xA5, 0xE1, 0xB9, 0xA7, 0xE1,
		0xB9, 0xA9, 0xE1, 0xB9, 0xAB, 0xE1, 0xB9, 0xAD,
		0xE1, 0xB9, 0xAF, 0xE1, 0xB9, 0xB1, 0xE1, 0xB9,
		0xB3, 0xE1, 0xB9, 0xB5, 0xE1, 0xB9, 0xB7, 0xE1,
		0xB9, 0xB9, 0xE1, 0xB9, 0xBB, 0xE1, 0xB9, 0xBD,
		0xE1, 0xB9, 0xBF, 0xE1, 0xBA, 0x81, 0xE1, 0xBA,
		0x83, 0xE1, 0xBA, 0x85, 0xE1, 0xBA, 0x87, 0xE1,
		0xBA, 0x89, 0xE1, 0xBA, 0x8B, 0xE1, 0xBA, 0x8D,
		0xE1, 0xBA, 0x8F, 0xE1, 0xBA, 0x91, 0xE1, 0xBA,
		0x93, 0xE1, 0xBA, 0x95, 0xE1, 0xBA, 0xA1, 0xE1,
		0xBA, 0xA3, 0xE1, 0xBA, 0xA5, 0xE1, 0xBA, 0xA7,
		0xE1, 0xBA, 0xA9, 0xE1, 0xBA, 0xAB, 0xE1, 0xBA,
		0xAD, 0xE1, 0xBA, 0xAF, 0xE1, 0xBA, 0xB1, 0xE1,
		0xBA, 0xB3, 0xE1, 0xBA, 0xB5, 0xE1, 0xBA, 0xB7,
		0xE1, 0xBA, 0xB9, 0xE1, 0xBA, 0xBB, 0xE1, 0xBA,
		0xBD, 0xE1, 0xBA, 0xBF, 0xE1, 0xBB, 0x81, 0xE1,
		0xBB, 0x83, 0xE1, 0xBB, 0x85, 0xE1, 0xBB, 0x87,
		0xE1, 0xBB, 0x89, 0xE1, 0xBB, 0x8B, 0xE1, 0xBB,
		0x8D, 0xE1, 0xBB, 0x8F, 0xE1, 0xBB, 0x91, 0xE1,
		0xBB, 0x93, 0xE1, 0xBB, 0x95, 0xE1, 0xBB, 0x97,
		0xE1, 0xBB, 0x99, 0xE1, 0xBB, 0x9B, 0xE1, 0xBB,
		0x9D, 0xE1, 0xBB, 0x9F, 0xE1, 0xBB, 0xA1, 0xE1,
		0xBB, 0xA3, 0xE1, 0xBB, 0xA5, 0xE1, 0xBB, 0xA7,
		0xE1, 0xBB, 0xA9, 0xE1, 0xBB, 0xAB, 0xE1, 0xBB,
		0xAD, 0xE1, 0xBB, 0xAF, 0xE1, 0xBB, 0xB1, 0xE1,
		0xBB, 0xB3, 0xE1, 0xBB, 0xB5, 0xE1, 0xBB, 0xB7,
		0xE1, 0xBB, 0xB9, 0xE1, 0xBC, 0x80, 0xE1, 0xBC,
		0x81, 0xE1, 0xBC, 0x82, 0xE1, 0xBC, 0x83, 0xE1,
		0xBC, 0x84, 0xE1, 0xBC, 0x85, 0xE1, 0xBC, 0x86,
		0xE1, 0xBC, 0x87, 0xE1, 0xBC, 0x90, 0xE1, 0xBC,
		0x91, 0xE1, 0xBC, 0x92, 0xE1, 0xBC, 0x93, 0xE1,
		0xBC, 0x94, 0xE1, 0xBC, 0x95, 0xE1, 0xBC, 0xA0,
		0xE1, 0xBC, 0xA1, 0xE1, 0xBC, 0xA2, 0xE1, 0xBC,
		0xA3, 0xE1, 0xBC, 0xA4, 0xE1, 0xBC, 0xA5, 0xE1,
		0xBC, 0xA6, 0xE1, 0xBC, 0xA7, 0xE1, 0xBC, 0xB0,
		0xE1, 0xBC, 0xB1, 0xE1, 0xBC, 0xB2, 0xE1, 0xBC,
		0xB3, 0xE1, 0xBC, 0xB4, 0xE1, 0xBC, 0xB5, 0xE1,
		0xBC, 0xB6, 0xE1, 0xBC, 0xB7, 0xE1, 0xBD, 0x80,
		0xE1, 0xBD, 0x81, 0xE1, 0xBD, 0x82, 0xE1, 0xBD,
		0x83, 0xE1, 0xBD, 0x84, 0xE1, 0xBD, 0x85, 0xE1,
		0xBD, 0x91, 0xE1, 0xBD, 0x93, 0xE1, 0xBD, 0x95,
		0xE1, 0xBD, 0x97, 0xE1, 0xBD, 0xA0, 0xE1, 0xBD,
		0xA1, 0xE1, 0xBD, 0xA2, 0xE1, 0xBD, 0xA3, 0xE1,
		0xBD, 0xA4, 0xE1, 0xBD, 0xA5, 0xE1, 0xBD, 0xA6,
		0xE1, 0xBD, 0xA7, 0xE1, 0xBE, 0x80, 0xE1, 0xBE,
		0x81, 0xE1, 0xBE, 0x82, 0xE1, 0xBE, 0x83, 0xE1,
		0xBE, 0x84, 0xE1, 0xBE, 0x85, 0xE1, 0xBE, 0x86,
		0xE1, 0xBE, 0x87, 0xE1, 0xBE, 0x90, 0xE1, 0xBE,
		0x91, 0xE1, 0xBE, 0x92, 0xE1, 0xBE, 0x93, 0xE1,
		0xBE, 0x94, 0xE1, 0xBE, 0x95, 0xE1, 0xBE, 0x96,
		0xE1, 0xBE, 0x97, 0xE1, 0xBE, 0xA0, 0xE1, 0xBE,
		0xA1, 0xE1, 0xBE, 0xA2, 0xE1, 0xBE, 0xA3, 0xE1,
		0xBE, 0xA4, 0xE1, 0xBE, 0xA5, 0xE1, 0xBE, 0xA6,
		0xE1, 0xBE, 0xA7, 0xE1, 0xBE, 0xB0, 0xE1, 0xBE,
		0xB1, 0xE1, 0xBD, 0xB0, 0xE1, 0xBD, 0xB1, 0xE1,
		0xBE, 0xB3, 0xE1, 0xBD, 0xB2, 0xE1, 0xBD, 0xB3,
		0xE1, 0xBD, 0xB4, 0xE1, 0xBD, 0xB5, 0xE1, 0xBF,
		0x83, 0xE1, 0xBF, 0x90, 0xE1, 0xBF, 0x91, 0xE1,
		0xBD, 0xB6, 0xE1, 0xBD, 0xB7, 0xE1, 0xBF, 0xA0,
		0xE1, 0xBF, 0xA1, 0xE1, 0xBD, 0xBA, 0xE1, 0xBD,
		0xBB, 0xE1, 0xBF, 0xA5, 0xE1, 0xBD, 0xB8, 0xE1,
		0xBD, 0xB9, 0xE1, 0xBD, 0xBC, 0xE1, 0xBD, 0xBD,
		0xE1, 0xBF, 0xB3, 0xCF, 0x89, 0x6B, 0xC3, 0xA5,
		0xE2, 0x85, 0x8E, 0xE2, 0x85, 0xB0, 0xE2, 0x85,
		0xB1, 0xE2, 0x85, 0xB2, 0xE2, 0x85, 0xB3, 0xE2,
		0x85, 0xB4, 0xE2, 0x85, 0xB5, 0xE2, 0x85, 0xB6,
		0xE2, 0x85, 0xB7, 0xE2, 0x85, 0xB8, 0xE2, 0x85,
		0xB9, 0xE2, 0x85, 0xBA, 0xE2, 0x85, 0xBB, 0xE2,
		0x85, 0xBC, 0xE2, 0x85, 0xBD, 0xE2, 0x85, 0xBE,
		0xE2, 0x85, 0xBF, 0xE2, 0x86, 0x84, 0xE2, 0x93,
		0x90, 0xE2, 0x93, 0x91, 0xE2, 0x93, 0x92, 0xE2,
		0x93, 0x93, 0xE2, 0x93, 0x94, 0xE2, 0x93, 0x95,
		0xE2, 0x93, 0x96, 0xE2, 0x93, 0x97, 0xE2, 0x93,
		0x98, 0xE2, 0x93, 0x99, 0xE2, 0x93, 0x9A, 0xE2,
		0x93, 0x9B, 0xE2, 0x93, 0x9C, 0xE2, 0x93, 0x9D,
		0xE2, 0x93, 0x9E, 0xE2, 0x93, 0x9F, 0xE2, 0x93,
		0xA0, 0xE2, 0x93, 0xA1, 0xE2, 0x93, 0xA2, 0xE2,
		0x93, 0xA3, 0xE2, 0x93, 0xA4, 0xE2, 0x93, 0xA5,
		0xE2, 0x93, 0xA6, 0xE2, 0x93, 0xA7, 0xE2, 0x93,
		0xA8, 0xE2, 0x93, 0xA9, 0xE2, 0xB0, 0xB0, 0xE2,
		0xB0, 0xB1, 0xE2, 0xB0, 0xB2, 0xE2, 0xB0, 0xB3,
		0xE2, 0xB0, 0xB4, 0xE2, 0xB0, 0xB5, 0xE2, 0xB0,
		0xB6, 0xE2, 0xB0, 0xB7, 0xE2, 0xB0, 0xB8, 0xE2,
		0xB0, 0xB9, 0xE2, 0xB0, 0xBA, 0xE2, 0xB0, 0xBB,
		0xE2, 0xB0, 0xBC, 0xE2, 0xB0, 0xBD, 0xE2, 0xB0,
		0xBE, 0xE2, 0xB0, 0xBF, 0xE2, 0xB1, 0x80, 0xE2,
		0xB1, 0x81, 0xE2, 0xB1, 0x82, 0xE2, 0xB1, 0x83,
		0xE2, 0xB1, 0x84, 0xE2, 0xB1, 0x85, 0xE2, 0xB1,
		0x86, 0xE2, 0xB1, 0x87, 0xE2, 0xB1, 0x88, 0xE2,
		0xB1, 0x89, 0xE2, 0xB1, 0x8A, 0xE2, 0xB1, 0x8B,
		0xE2, 0xB1, 0x8C, 0xE2, 0xB1, 0x8D, 0xE2, 0xB1,
		0x8E, 0xE2, 0xB1, 0x8F, 0xE2, 0xB1, 0x90, 0xE2,
		0xB1, 0x91, 0xE2, 0xB1, 0x92, 0xE2, 0xB1, 0x93,
		0xE2, 0xB1, 0x94, 0xE2, 0xB1, 0x95, 0xE2, 0xB1,
		0x96, 0xE2, 0xB1, 0x97, 0xE2, 0xB1, 0x98, 0xE2,
		0xB1, 0x99, 0xE2, 0xB1, 0x9A, 0xE2, 0xB1, 0x9B,
		0xE2, 0xB1, 0x9C, 0xE2, 0xB1, 0x9D, 0xE2, 0xB1,
		0x9E, 0xE2, 0xB1, 0xA1, 0xC9, 0xAB, 0xE1, 0xB5,
		0xBD, 0xC9, 0xBD, 0xE2, 0xB1, 0xA8, 0xE2, 0xB1,
		0xAA, 0xE2, 0xB1, 0xAC, 0xE2, 0xB1, 0xB6, 0xE2,
		0xB2, 0x81, 0xE2, 0xB2, 0x83, 0xE2, 0xB2, 0x85,
		0xE2, 0xB2, 0x87, 0xE2, 0xB2, 0x89, 0xE2, 0xB2,
		0x8B, 0xE2, 0xB2, 0x8D, 0xE2, 0xB2, 0x8F, 0xE2,
		0xB2, 0x91, 0xE2, 0xB2, 0x93, 0xE2, 0xB2, 0x95,
		0xE2, 0xB2, 0x97, 0xE2, 0xB2, 0x99, 0xE2, 0xB2,
		0x9B, 0xE2, 0xB2, 0x9D, 0xE2, 0xB2, 0x9F, 0xE2,
		0xB2, 0xA1, 0xE2, 0xB2, 0xA3, 0xE2, 0xB2, 0xA5,
		0xE2, 0xB2, 0xA7, 0xE2, 0xB2, 0xA9, 0xE2, 0xB2,
		0xAB, 0xE2, 0xB2, 0xAD, 0xE2, 0xB2, 0xAF, 0xE2,
		0xB2, 0xB1, 0xE2, 0xB2, 0xB3, 0xE2, 0xB2, 0xB5,
		0xE2, 0xB2, 0xB7, 0xE2, 0xB2, 0xB9, 0xE2, 0xB2,
		0xBB, 0xE2, 0xB2, 0xBD, 0xE2, 0xB2, 0xBF, 0xE2,
		0xB3, 0x81, 0xE2, 0xB3, 0x83, 0xE2, 0xB3, 0x85,
		0xE2, 0xB3, 0x87, 0xE2, 0xB3, 0x89, 0xE2, 0xB3,
		0x8B, 0xE2, 0xB3, 0x8D, 0xE2, 0xB3, 0x8F, 0xE2,
		0xB3, 0x91, 0xE2, 0xB3, 0x93, 0xE2, 0xB3, 0x95,
		0xE2, 0xB3, 0x97, 0xE2, 0xB3, 0x99, 0xE2, 0xB3,
		0x9B, 0xE2, 0xB3, 0x9D, 0xE2, 0xB3, 0x9F, 0xE2,
		0xB3, 0xA1, 0xE2, 0xB3, 0xA3, 0xEF, 0xBD, 0x81,
		0xEF, 0xBD, 0x82, 0xEF, 0xBD, 0x83, 0xEF, 0xBD,
		0x84, 0xEF, 0xBD, 0x85, 0xEF, 0xBD, 0x86, 0xEF,
		0xBD, 0x87, 0xEF, 0xBD, 0x88, 0xEF, 0xBD, 0x89,
		0xEF, 0xBD, 0x8A, 0xEF, 0xBD, 0x8B, 0xEF, 0xBD,
		0x8C, 0xEF, 0xBD, 0x8D, 0xEF, 0xBD, 0x8E, 0xEF,
		0xBD, 0x8F, 0xEF, 0xBD, 0x90, 0xEF, 0xBD, 0x91,
		0xEF, 0xBD, 0x92, 0xEF, 0xBD, 0x93, 0xEF, 0xBD,
		0x94, 0xEF, 0xBD, 0x95, 0xEF, 0xBD, 0x96, 0xEF,
		0xBD, 0x97, 0xEF, 0xBD, 0x98, 0xEF, 0xBD, 0x99,
		0xEF, 0xBD, 0x9A, 0xF0, 0x90, 0x90, 0xA8, 0xF0,
		0x90, 0x90, 0xA9, 0xF0, 0x90, 0x90, 0xAA, 0xF0,
		0x90, 0x90, 0xAB, 0xF0, 0x90, 0x90, 0xAC, 0xF0,
		0x90, 0x90, 0xAD, 0xF0, 0x90, 0x90, 0xAE, 0xF0,
		0x90, 0x90, 0xAF, 0xF0, 0x90, 0x90, 0xB0, 0xF0,
		0x90, 0x90, 0xB1, 0xF0, 0x90, 0x90, 0xB2, 0xF0,
		0x90, 0x90, 0xB3, 0xF0, 0x90, 0x90, 0xB4, 0xF0,
		0x90, 0x90, 0xB5, 0xF0, 0x90, 0x90, 0xB6, 0xF0,
		0x90, 0x90, 0xB7, 0xF0, 0x90, 0x90, 0xB8, 0xF0,
		0x90, 0x90, 0xB9, 0xF0, 0x90, 0x90, 0xBA, 0xF0,
		0x90, 0x90, 0xBB, 0xF0, 0x90, 0x90, 0xBC, 0xF0,
		0x90, 0x90, 0xBD, 0xF0, 0x90, 0x90, 0xBE, 0xF0,
		0x90, 0x90, 0xBF, 0xF0, 0x90, 0x91, 0x80, 0xF0,
		0x90, 0x91, 0x81, 0xF0, 0x90, 0x91, 0x82, 0xF0,
		0x90, 0x91, 0x83, 0xF0, 0x90, 0x91, 0x84, 0xF0,
		0x90, 0x91, 0x85, 0xF0, 0x90, 0x91, 0x86, 0xF0,
		0x90, 0x91, 0x87, 0xF0, 0x90, 0x91, 0x88, 0xF0,
		0x90, 0x91, 0x89, 0xF0, 0x90, 0x91, 0x8A, 0xF0,
		0x90, 0x91, 0x8B, 0xF0, 0x90, 0x91, 0x8C, 0xF0,
		0x90, 0x91, 0x8D, 0xF0, 0x90, 0x91, 0x8E, 0xF0,
		0x90, 0x91, 0x8F,
	},
};

static const u8_displacement_t u8_toupper_b3_tbl[2][5][256] = {
	{
		{	/* Third byte table 0. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { 0, 0 }, { 1, 2 },
			{ 2, 64 }, { 3, 125 }, { 4, 188 }, { 5, 226 },
			{ 6, 288 }, { 7, 338 }, { 8, 364 }, { N_, 0 },
			{ N_, 0 }, { 9, 376 }, { 10, 378 }, { 11, 416 },
			{ 12, 486 }, { 13, 518 }, { 14, 614 }, { 15, 670 },
			{ 16, 724 }, { 17, 740 }, { 18, 802 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 1. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 19, 816 }, { 20, 912 }, { 21, 1008 }, { 22, 1092 },
			{ 23, 1179 }, { 24, 1269 }, { 25, 1365 }, { 26, 1448 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 2. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { 27, 1469 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { 28, 1517 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 3. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { 29, 1595 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 4. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 30, 1673 }, { 31, 1769 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
	},
	{
		{	/* Third byte table 0. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { 0, 0 }, { 1, 2 },
			{ 2, 64 }, { 3, 125 }, { 4, 188 }, { 5, 230 },
			{ 6, 292 }, { 7, 344 }, { 8, 388 }, { N_, 0 },
			{ N_, 0 }, { 9, 404 }, { 10, 412 }, { 11, 450 },
			{ 12, 524 }, { 13, 556 }, { 14, 652 }, { 15, 708 },
			{ 16, 772 }, { 17, 792 }, { 18, 854 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 1. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { 19, 868 }, { N_, 0 }, { N_, 0 },
			{ 20, 871 }, { 21, 967 }, { 22, 1063 }, { 23, 1147 },
			{ 24, 1234 }, { 25, 1324 }, { 26, 1420 }, { 27, 1503 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 2. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { 28, 1524 }, { 29, 1575 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { 30, 1578 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 31, 1656 }, { 32, 1704 }, { 33, 1816 }, { 34, 1912 },
			{ 35, 1966 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 3. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { 36, 2080 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
		{	/* Third byte table 4. */
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ 37, 2158 }, { 38, 2254 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
			{ N_, 0 }, { N_, 0 }, { N_, 0 }, { N_, 0 },
		},
	},
};

static const uchar_t u8_toupper_b4_tbl[2][39][257] = {
	{
		{	/* Fourth byte table 0. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,
		},
		{	/* Fourth byte table 1. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  34,  36,  38,  40,  42,  44,  46,
			46,  48,  50,  52,  54,  56,  58,  60,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,
		},
		{	/* Fourth byte table 2. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   4,   4,   6,   6,
			8,   8,   10,  10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  30,  30,
			32,  32,  34,  34,  36,  36,  38,  38,
			40,  40,  42,  42,  44,  44,  46,  46,
			48,  48,  49,  49,  51,  51,  53,  53,
			55,  55,  55,  57,  57,  59,  59,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,
		},
		{	/* Fourth byte table 3. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  30,  30,
			32,  32,  34,  34,  36,  36,  38,  38,
			40,  40,  42,  42,  44,  44,  46,  46,
			48,  48,  50,  50,  52,  52,  54,  54,
			56,  56,  56,  58,  58,  60,  60,  62,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,
		},
		{	/* Fourth byte table 4. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   2,   2,   4,   4,
			4,   6,   6,   6,   6,   8,   8,   8,
			8,   8,   8,   10,  10,  10,  12,  12,
			12,  12,  14,  14,  14,  14,  14,  16,
			16,  16,  18,  18,  20,  20,  22,  22,
			22,  24,  24,  24,  24,  24,  26,  26,
			26,  28,  28,  28,  28,  30,  30,  32,
			32,  32,  34,  34,  34,  34,  36,  36,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,
		},
		{	/* Fourth byte table 5. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   2,   4,
			4,   6,   8,   8,   10,  12,  12,  14,
			14,  16,  16,  18,  18,  20,  20,  22,
			22,  24,  24,  26,  26,  28,  30,  30,
			32,  32,  34,  34,  36,  36,  38,  38,
			40,  40,  42,  42,  44,  44,  46,  46,
			48,  48,  48,  50,  52,  52,  54,  54,
			54,  54,  56,  56,  58,  58,  60,  60,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,
		},
		{	/* Fourth byte table 6. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   4,   4,   6,   6,
			8,   8,   10,  10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  30,  30,
			32,  32,  32,  32,  34,  34,  36,  36,
			38,  38,  40,  40,  42,  42,  44,  44,
			46,  46,  48,  48,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  50,  50,  50,
			50,
		},
		{	/* Fourth byte table 7. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   2,   4,   4,   6,
			8,   8,   10,  10,  12,  12,  12,  12,
			12,  14,  14,  14,  16,  16,  16,  16,
			16,  18,  20,  20,  20,  20,  20,  20,
			22,  22,  22,  24,  24,  24,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,  26,  26,  26,  26,  26,  26,  26,
			26,
		},
		{	/* Fourth byte table 8. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   2,   4,   4,   4,   4,
			4,   6,   6,   8,   10,  10,  10,  10,
			10,  10,  10,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,  12,  12,  12,  12,  12,  12,  12,
			12,
		},
		{	/* Fourth byte table 9. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,
		},
		{	/* Fourth byte table 10. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   2,   4,   6,
			8,   8,   10,  12,  14,  16,  18,  20,
			22,  24,  26,  28,  30,  32,  34,  36,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,
		},
		{	/* Fourth byte table 11. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			30,  32,  34,  34,  34,  34,  36,  38,
			38,  38,  40,  40,  42,  42,  44,  44,
			46,  46,  48,  48,  50,  50,  52,  52,
			54,  54,  56,  56,  58,  58,  60,  60,
			62,  64,  66,  68,  68,  68,  70,  70,
			70,  70,  70,  70,  70,  70,  70,  70,
			70,  70,  70,  70,  70,  70,  70,  70,
			70,  70,  70,  70,  70,  70,  70,  70,
			70,  70,  70,  70,  70,  70,  70,  70,
			70,  70,  70,  70,  70,  70,  70,  70,
			70,  70,  70,  70,  70,  70,  70,  70,
			70,  70,  70,  70,  70,  70,  70,  70,
			70,  70,  70,  70,  70,  70,  70,  70,
			70,  70,  70,  70,  70,  70,  70,  70,
			70,
		},
		{	/* Fourth byte table 12. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,
		},
		{	/* Fourth byte table 13. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  34,  36,  38,  40,  42,  44,  46,
			48,  50,  52,  54,  56,  58,  60,  62,
			64,  64,  66,  66,  68,  68,  70,  70,
			72,  72,  74,  74,  76,  76,  78,  78,
			80,  80,  82,  82,  84,  84,  86,  86,
			88,  88,  90,  90,  92,  92,  94,  94,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 14. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   4,   4,   6,   6,
			8,   8,   10,  10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  30,  30,
			32,  32,  34,  34,  36,  36,  38,  38,
			40,  40,  42,  42,  44,  44,  46,  46,
			48,  48,  50,  50,  52,  52,  54,  54,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,
		},
		{	/* Fourth byte table 15. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   2,   2,   4,   4,   6,
			6,   8,   8,   10,  10,  12,  12,  14,
			14,  14,  16,  16,  18,  18,  20,  20,
			22,  22,  24,  24,  26,  26,  28,  28,
			30,  30,  32,  32,  34,  34,  36,  36,
			38,  38,  40,  40,  42,  42,  44,  44,
			46,  46,  48,  48,  50,  50,  52,  52,
			52,  52,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,
		},
		{	/* Fourth byte table 16. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   4,   4,   6,   6,
			8,   8,   10,  10,  12,  12,  14,  14,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,
		},
		{	/* Fourth byte table 17. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   4,   6,   8,   10,  12,
			14,  16,  18,  20,  22,  24,  26,  28,
			30,  32,  34,  36,  38,  40,  42,  44,
			46,  48,  50,  52,  54,  56,  58,  60,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,
		},
		{	/* Fourth byte table 18. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,
		},
		{	/* Fourth byte table 19. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   3,   6,   6,   9,   9,
			12,  12,  15,  15,  18,  18,  21,  21,
			24,  24,  27,  27,  30,  30,  33,  33,
			36,  36,  39,  39,  42,  42,  45,  45,
			48,  48,  51,  51,  54,  54,  57,  57,
			60,  60,  63,  63,  66,  66,  69,  69,
			72,  72,  75,  75,  78,  78,  81,  81,
			84,  84,  87,  87,  90,  90,  93,  93,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 20. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   3,   6,   6,   9,   9,
			12,  12,  15,  15,  18,  18,  21,  21,
			24,  24,  27,  27,  30,  30,  33,  33,
			36,  36,  39,  39,  42,  42,  45,  45,
			48,  48,  51,  51,  54,  54,  57,  57,
			60,  60,  63,  63,  66,  66,  69,  69,
			72,  72,  75,  75,  78,  78,  81,  81,
			84,  84,  87,  87,  90,  90,  93,  93,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 21. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   3,   6,   6,   9,   9,
			12,  12,  15,  15,  18,  18,  21,  21,
			24,  24,  27,  27,  30,  30,  33,  33,
			33,  33,  33,  33,  36,  36,  36,  36,
			36,  36,  39,  39,  42,  42,  45,  45,
			48,  48,  51,  51,  54,  54,  57,  57,
			60,  60,  63,  63,  66,  66,  69,  69,
			72,  72,  75,  75,  78,  78,  81,  81,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,
		},
		{	/* Fourth byte table 22. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   3,   6,   6,   9,   9,
			12,  12,  15,  15,  18,  18,  21,  21,
			24,  24,  27,  27,  30,  30,  33,  33,
			36,  36,  39,  39,  42,  42,  45,  45,
			48,  48,  51,  51,  54,  54,  57,  57,
			60,  60,  63,  63,  66,  66,  69,  69,
			72,  72,  75,  75,  78,  78,  81,  81,
			84,  84,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,
		},
		{	/* Fourth byte table 23. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  24,  24,  24,  24,  24,  24,  24,
			24,  27,  30,  33,  36,  39,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  45,  48,  51,  54,  57,  60,  63,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  69,  72,  75,  78,  81,  84,  87,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,
		},
		{	/* Fourth byte table 24. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  21,  21,  24,  24,  27,  27,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  33,  36,  39,  42,  45,  48,  51,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  57,  60,  63,  66,  69,  72,  75,
			78,  81,  84,  87,  90,  93,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 25. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  24,  24,  24,  24,  24,  24,  24,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  51,  54,  57,  60,  63,  66,  69,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  75,  78,  78,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,
		},
		{	/* Fourth byte table 26. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   6,   9,   9,   9,   9,   9,   9,
			9,   9,   9,   9,   9,   9,   9,   9,
			9,   12,  15,  15,  15,  15,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,
		},
		{	/* Fourth byte table 27. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,
		},
		{	/* Fourth byte table 28. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  51,  54,  57,  60,  63,  66,  69,
			72,  75,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,
		},
		{	/* Fourth byte table 29. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   6,   9,   12,  15,  18,
			21,  24,  27,  30,  33,  36,  39,  42,
			45,  48,  51,  54,  57,  60,  63,  66,
			69,  72,  75,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,
		},
		{	/* Fourth byte table 30. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   4,   8,   12,  16,  20,  24,  28,
			32,  36,  40,  44,  48,  52,  56,  60,
			64,  68,  72,  76,  80,  84,  88,  92,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 31. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   4,   8,   12,  16,  20,  24,  28,
			32,  36,  40,  44,  48,  52,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,
		},
		{	/* Fourth byte table 32. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 33. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 34. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 35. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 36. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 37. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
		{	/* Fourth byte table 38. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,
		},
	},
	{
		{	/* Fourth byte table 0. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,
		},
		{	/* Fourth byte table 1. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  34,  36,  38,  40,  42,  44,  46,
			46,  48,  50,  52,  54,  56,  58,  60,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,
		},
		{	/* Fourth byte table 2. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   4,   4,   6,   6,
			8,   8,   10,  10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  30,  30,
			32,  32,  34,  34,  36,  36,  38,  38,
			40,  40,  42,  42,  44,  44,  46,  46,
			48,  48,  49,  49,  51,  51,  53,  53,
			55,  55,  55,  57,  57,  59,  59,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,  61,  61,  61,  61,  61,  61,  61,
			61,
		},
		{	/* Fourth byte table 3. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   4,   4,   6,   6,   8,
			8,   10,  10,  10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  30,  30,
			32,  32,  34,  34,  36,  36,  38,  38,
			40,  40,  42,  42,  44,  44,  46,  46,
			48,  48,  50,  50,  52,  52,  54,  54,
			56,  56,  56,  58,  58,  60,  60,  62,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,  63,  63,  63,  63,  63,  63,  63,
			63,
		},
		{	/* Fourth byte table 4. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   2,   4,   4,   6,   6,
			6,   8,   8,   8,   8,   10,  10,  10,
			10,  10,  10,  12,  12,  12,  14,  14,
			14,  14,  16,  18,  18,  18,  18,  20,
			20,  20,  22,  22,  24,  24,  26,  26,
			26,  28,  28,  28,  28,  28,  30,  30,
			30,  32,  32,  32,  32,  34,  34,  36,
			36,  36,  38,  38,  38,  38,  40,  40,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,
		},
		{	/* Fourth byte table 5. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   2,   4,
			4,   6,   8,   8,   10,  12,  12,  14,
			14,  16,  16,  18,  18,  20,  20,  22,
			22,  24,  24,  26,  26,  28,  30,  30,
			32,  32,  34,  34,  36,  36,  38,  38,
			40,  40,  42,  42,  44,  44,  46,  46,
			48,  48,  48,  50,  52,  52,  54,  54,
			54,  54,  56,  56,  58,  58,  60,  60,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,
		},
		{	/* Fourth byte table 6. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   4,   4,   6,   6,
			8,   8,   10,  10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  30,  30,
			32,  32,  32,  32,  34,  34,  36,  36,
			38,  38,  40,  40,  42,  42,  44,  44,
			46,  46,  48,  48,  50,  50,  50,  50,
			50,  50,  50,  50,  50,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,  52,  52,  52,  52,  52,  52,  52,
			52,
		},
		{	/* Fourth byte table 7. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   2,   2,   2,   2,   2,
			4,   4,   6,   6,   8,   8,   10,  10,
			12,  12,  12,  12,  14,  16,  16,  18,
			20,  20,  22,  22,  24,  24,  24,  24,
			24,  26,  26,  26,  28,  28,  28,  28,
			28,  30,  32,  32,  35,  35,  35,  35,
			37,  37,  37,  39,  39,  39,  41,  41,
			41,  41,  41,  41,  41,  41,  44,  44,
			44,  44,  44,  44,  44,  44,  44,  44,
			44,  44,  44,  44,  44,  44,  44,  44,
			44,  44,  44,  44,  44,  44,  44,  44,
			44,  44,  44,  44,  44,  44,  44,  44,
			44,  44,  44,  44,  44,  44,  44,  44,
			44,  44,  44,  44,  44,  44,  44,  44,
			44,  44,  44,  44,  44,  44,  44,  44,
			44,  44,  44,  44,  44,  44,  44,  44,
			44,
		},
		{	/* Fourth byte table 8. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   2,   2,   4,   4,   4,   4,
			4,   6,   8,   10,  12,  14,  14,  14,
			14,  14,  14,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,  16,  16,  16,  16,  16,  16,  16,
			16,
		},
		{	/* Fourth byte table 9. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   4,   6,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,   8,   8,   8,   8,   8,   8,   8,
			8,
		},
		{	/* Fourth byte table 10. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   2,   4,   6,
			8,   8,   10,  12,  14,  16,  18,  20,
			22,  24,  26,  28,  30,  32,  34,  36,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,  38,  38,  38,  38,  38,  38,  38,
			38,
		},
		{	/* Fourth byte table 11. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			30,  32,  34,  34,  34,  34,  36,  38,
			38,  38,  40,  40,  42,  42,  44,  44,
			46,  46,  48,  48,  50,  50,  52,  52,
			54,  54,  56,  56,  58,  58,  60,  60,
			62,  64,  66,  68,  68,  68,  70,  70,
			70,  72,  72,  72,  74,  74,  74,  74,
			74,  74,  74,  74,  74,  74,  74,  74,
			74,  74,  74,  74,  74,  74,  74,  74,
			74,  74,  74,  74,  74,  74,  74,  74,
			74,  74,  74,  74,  74,  74,  74,  74,
			74,  74,  74,  74,  74,  74,  74,  74,
			74,  74,  74,  74,  74,  74,  74,  74,
			74,  74,  74,  74,  74,  74,  74,  74,
			74,  74,  74,  74,  74,  74,  74,  74,
			74,
		},
		{	/* Fourth byte table 12. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,  32,  32,  32,  32,  32,  32,  32,
			32,
		},
		{	/* Fourth byte table 13. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			16,  18,  20,  22,  24,  26,  28,  30,
			32,  34,  36,  38,  40,  42,  44,  46,
			48,  50,  52,  54,  56,  58,  60,  62,
			64,  64,  66,  66,  68,  68,  70,  70,
			72,  72,  74,  74,  76,  76,  78,  78,
			80,  80,  82,  82,  84,  84,  86,  86,
			88,  88,  90,  90,  92,  92,  94,  94,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 14. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   2,   2,   2,   2,
			2,   2,   2,   2,   4,   4,   6,   6,
			8,   8,   10,  10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  30,  30,
			32,  32,  34,  34,  36,  36,  38,  38,
			40,  40,  42,  42,  44,  44,  46,  46,
			48,  48,  50,  50,  52,  52,  54,  54,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,  56,  56,  56,  56,  56,  56,  56,
			56,
		},
		{	/* Fourth byte table 15. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   2,   2,   4,   4,   6,
			6,   8,   8,   10,  10,  12,  12,  14,
			16,  16,  18,  18,  20,  20,  22,  22,
			24,  24,  26,  26,  28,  28,  30,  30,
			32,  32,  34,  34,  36,  36,  38,  38,
			40,  40,  42,  42,  44,  44,  46,  46,
			48,  48,  50,  50,  52,  52,  54,  54,
			56,  56,  58,  58,  60,  60,  62,  62,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,
		},
		{	/* Fourth byte table 16. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   2,   4,   4,   6,   6,
			8,   8,   10,  10,  12,  12,  14,  14,
			16,  16,  18,  18,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,  20,  20,  20,  20,  20,  20,  20,
			20,
		},
		{	/* Fourth byte table 17. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   2,   4,   6,   8,   10,  12,
			14,  16,  18,  20,  22,  24,  26,  28,
			30,  32,  34,  36,  38,  40,  42,  44,
			46,  48,  50,  52,  54,  56,  58,  60,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,  62,  62,  62,  62,  62,  62,  62,
			62,
		},
		{	/* Fourth byte table 18. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   2,   4,   6,   8,   10,  12,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,  14,  14,  14,  14,  14,  14,  14,
			14,
		},
		{	/* Fourth byte table 19. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,
		},
		{	/* Fourth byte table 20. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   3,   6,   6,   9,   9,
			12,  12,  15,  15,  18,  18,  21,  21,
			24,  24,  27,  27,  30,  30,  33,  33,
			36,  36,  39,  39,  42,  42,  45,  45,
			48,  48,  51,  51,  54,  54,  57,  57,
			60,  60,  63,  63,  66,  66,  69,  69,
			72,  72,  75,  75,  78,  78,  81,  81,
			84,  84,  87,  87,  90,  90,  93,  93,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 21. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   3,   6,   6,   9,   9,
			12,  12,  15,  15,  18,  18,  21,  21,
			24,  24,  27,  27,  30,  30,  33,  33,
			36,  36,  39,  39,  42,  42,  45,  45,
			48,  48,  51,  51,  54,  54,  57,  57,
			60,  60,  63,  63,  66,  66,  69,  69,
			72,  72,  75,  75,  78,  78,  81,  81,
			84,  84,  87,  87,  90,  90,  93,  93,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 22. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   3,   6,   6,   9,   9,
			12,  12,  15,  15,  18,  18,  21,  21,
			24,  24,  27,  27,  30,  30,  33,  33,
			33,  33,  33,  33,  36,  36,  36,  36,
			36,  36,  39,  39,  42,  42,  45,  45,
			48,  48,  51,  51,  54,  54,  57,  57,
			60,  60,  63,  63,  66,  66,  69,  69,
			72,  72,  75,  75,  78,  78,  81,  81,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,  84,  84,  84,  84,  84,  84,  84,
			84,
		},
		{	/* Fourth byte table 23. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   3,   6,   6,   9,   9,
			12,  12,  15,  15,  18,  18,  21,  21,
			24,  24,  27,  27,  30,  30,  33,  33,
			36,  36,  39,  39,  42,  42,  45,  45,
			48,  48,  51,  51,  54,  54,  57,  57,
			60,  60,  63,  63,  66,  66,  69,  69,
			72,  72,  75,  75,  78,  78,  81,  81,
			84,  84,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,  87,  87,  87,  87,  87,  87,  87,
			87,
		},
		{	/* Fourth byte table 24. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  24,  24,  24,  24,  24,  24,  24,
			24,  27,  30,  33,  36,  39,  42,  42,
			42,  42,  42,  42,  42,  42,  42,  42,
			42,  45,  48,  51,  54,  57,  60,  63,
			66,  66,  66,  66,  66,  66,  66,  66,
			66,  69,  72,  75,  78,  81,  84,  87,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,  90,  90,  90,  90,  90,  90,  90,
			90,
		},
		{	/* Fourth byte table 25. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  21,  21,  24,  24,  27,  27,
			30,  30,  30,  30,  30,  30,  30,  30,
			30,  33,  36,  39,  42,  45,  48,  51,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  57,  60,  63,  66,  69,  72,  75,
			78,  81,  84,  87,  90,  93,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 26. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  24,  24,  24,  24,  24,  24,  24,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  51,  54,  57,  60,  63,  66,  69,
			72,  72,  72,  72,  72,  72,  72,  72,
			72,  75,  78,  78,  81,  81,  81,  81,
			81,  81,  81,  81,  81,  81,  81,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,  83,  83,  83,  83,  83,  83,  83,
			83,
		},
		{	/* Fourth byte table 27. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   6,   9,   9,   9,   9,   9,   9,
			9,   9,   9,   9,   9,   9,   9,   9,
			9,   12,  15,  15,  15,  15,  18,  18,
			18,  18,  18,  18,  18,  18,  18,  18,
			18,  18,  18,  18,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,  21,  21,  21,  21,  21,  21,  21,
			21,
		},
		{	/* Fourth byte table 28. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   6,   9,   12,  15,  18,  21,  24,
			27,  30,  33,  36,  39,  42,  45,  48,
			51,  51,  51,  51,  51,  51,  51,  51,
			51,  51,  51,  51,  51,  51,  51,  51,
			51,  51,  51,  51,  51,  51,  51,  51,
			51,  51,  51,  51,  51,  51,  51,  51,
			51,  51,  51,  51,  51,  51,  51,  51,
			51,  51,  51,  51,  51,  51,  51,  51,
			51,  51,  51,  51,  51,  51,  51,  51,
			51,  51,  51,  51,  51,  51,  51,  51,
			51,
		},
		{	/* Fourth byte table 29. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,   3,   3,   3,   3,   3,   3,   3,
			3,
		},
		{	/* Fourth byte table 30. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  51,  54,  57,  60,  63,  66,  69,
			72,  75,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,
		},
		{	/* Fourth byte table 31. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,  48,  48,  48,  48,  48,  48,  48,
			48,
		},
		{	/* Fourth byte table 32. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  51,  54,  57,  60,  63,  66,  69,
			72,  75,  78,  81,  84,  87,  90,  93,
			93,  93,  96,  96,  96,  96,  98,  100,
			100, 103, 103, 106, 106, 109, 109, 109,
			109, 109, 109, 109, 109, 109, 109, 112,
			112, 112, 112, 112, 112, 112, 112, 112,
			112, 112, 112, 112, 112, 112, 112, 112,
			112, 112, 112, 112, 112, 112, 112, 112,
			112, 112, 112, 112, 112, 112, 112, 112,
			112, 112, 112, 112, 112, 112, 112, 112,
			112, 112, 112, 112, 112, 112, 112, 112,
			112, 112, 112, 112, 112, 112, 112, 112,
			112, 112, 112, 112, 112, 112, 112, 112,
			112, 112, 112, 112, 112, 112, 112, 112,
			112,
		},
		{	/* Fourth byte table 33. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   3,   6,   6,   9,   9,
			12,  12,  15,  15,  18,  18,  21,  21,
			24,  24,  27,  27,  30,  30,  33,  33,
			36,  36,  39,  39,  42,  42,  45,  45,
			48,  48,  51,  51,  54,  54,  57,  57,
			60,  60,  63,  63,  66,  66,  69,  69,
			72,  72,  75,  75,  78,  78,  81,  81,
			84,  84,  87,  87,  90,  90,  93,  93,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 34. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   3,   6,   6,   9,   9,
			12,  12,  15,  15,  18,  18,  21,  21,
			24,  24,  27,  27,  30,  30,  33,  33,
			36,  36,  39,  39,  42,  42,  45,  45,
			48,  48,  51,  51,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,  54,  54,  54,  54,  54,  54,  54,
			54,
		},
		{	/* Fourth byte table 35. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   3,   6,   9,   12,  15,  18,  21,
			24,  27,  30,  33,  36,  39,  42,  45,
			48,  51,  54,  57,  60,  63,  66,  69,
			72,  75,  78,  81,  84,  87,  90,  93,
			96,  99,  102, 105, 108, 111, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114, 114, 114, 114, 114, 114, 114, 114,
			114,
		},
		{	/* Fourth byte table 36. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   3,   6,   9,   12,  15,  18,
			21,  24,  27,  30,  33,  36,  39,  42,
			45,  48,  51,  54,  57,  60,  63,  66,
			69,  72,  75,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,  78,  78,  78,  78,  78,  78,  78,
			78,
		},
		{	/* Fourth byte table 37. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   4,   8,   12,  16,  20,  24,  28,
			32,  36,  40,  44,  48,  52,  56,  60,
			64,  68,  72,  76,  80,  84,  88,  92,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,  96,  96,  96,  96,  96,  96,  96,
			96,
		},
		{	/* Fourth byte table 38. */
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   0,   0,
			0,   4,   8,   12,  16,  20,  24,  28,
			32,  36,  40,  44,  48,  52,  56,  60,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,  64,  64,  64,  64,  64,  64,  64,
			64,
		},
	},
};

static const uchar_t u8_toupper_final_tbl[2][2318] = {
	{
		0xCE, 0x9C, 0xC3, 0x80, 0xC3, 0x81, 0xC3, 0x82,
		0xC3, 0x83, 0xC3, 0x84, 0xC3, 0x85, 0xC3, 0x86,
		0xC3, 0x87, 0xC3, 0x88, 0xC3, 0x89, 0xC3, 0x8A,
		0xC3, 0x8B, 0xC3, 0x8C, 0xC3, 0x8D, 0xC3, 0x8E,
		0xC3, 0x8F, 0xC3, 0x90, 0xC3, 0x91, 0xC3, 0x92,
		0xC3, 0x93, 0xC3, 0x94, 0xC3, 0x95, 0xC3, 0x96,
		0xC3, 0x98, 0xC3, 0x99, 0xC3, 0x9A, 0xC3, 0x9B,
		0xC3, 0x9C, 0xC3, 0x9D, 0xC3, 0x9E, 0xC5, 0xB8,
		0xC4, 0x80, 0xC4, 0x82, 0xC4, 0x84, 0xC4, 0x86,
		0xC4, 0x88, 0xC4, 0x8A, 0xC4, 0x8C, 0xC4, 0x8E,
		0xC4, 0x90, 0xC4, 0x92, 0xC4, 0x94, 0xC4, 0x96,
		0xC4, 0x98, 0xC4, 0x9A, 0xC4, 0x9C, 0xC4, 0x9E,
		0xC4, 0xA0, 0xC4, 0xA2, 0xC4, 0xA4, 0xC4, 0xA6,
		0xC4, 0xA8, 0xC4, 0xAA, 0xC4, 0xAC, 0xC4, 0xAE,
		0x49, 0xC4, 0xB2, 0xC4, 0xB4, 0xC4, 0xB6, 0xC4,
		0xB9, 0xC4, 0xBB, 0xC4, 0xBD, 0xC4, 0xBF, 0xC5,
		0x81, 0xC5, 0x83, 0xC5, 0x85, 0xC5, 0x87, 0xC5,
		0x8A, 0xC5, 0x8C, 0xC5, 0x8E, 0xC5, 0x90, 0xC5,
		0x92, 0xC5, 0x94, 0xC5, 0x96, 0xC5, 0x98, 0xC5,
		0x9A, 0xC5, 0x9C, 0xC5, 0x9E, 0xC5, 0xA0, 0xC5,
		0xA2, 0xC5, 0xA4, 0xC5, 0xA6, 0xC5, 0xA8, 0xC5,
		0xAA, 0xC5, 0xAC, 0xC5, 0xAE, 0xC5, 0xB0, 0xC5,
		0xB2, 0xC5, 0xB4, 0xC5, 0xB6, 0xC5, 0xB9, 0xC5,
		0xBB, 0xC5, 0xBD, 0x53, 0xC6, 0x82, 0xC6, 0x84,
		0xC6, 0x87, 0xC6, 0x8B, 0xC6, 0x91, 0xC7, 0xB6,
		0xC6, 0x98, 0xC8, 0xA0, 0xC6, 0xA0, 0xC6, 0xA2,
		0xC6, 0xA4, 0xC6, 0xA7, 0xC6, 0xAC, 0xC6, 0xAF,
		0xC6, 0xB3, 0xC6, 0xB5, 0xC6, 0xB8, 0xC6, 0xBC,
		0xC7, 0xB7, 0xC7, 0x84, 0xC7, 0x84, 0xC7, 0x87,
		0xC7, 0x87, 0xC7, 0x8A, 0xC7, 0x8A, 0xC7, 0x8D,
		0xC7, 0x8F, 0xC7, 0x91, 0xC7, 0x93, 0xC7, 0x95,
		0xC7, 0x97, 0xC7, 0x99, 0xC7, 0x9B, 0xC6, 0x8E,
		0xC7, 0x9E, 0xC7, 0xA0, 0xC7, 0xA2, 0xC7, 0xA4,
		0xC7, 0xA6, 0xC7, 0xA8, 0xC7, 0xAA, 0xC7, 0xAC,
		0xC7, 0xAE, 0xC7, 0xB1, 0xC7, 0xB1, 0xC7, 0xB4,
		0xC7, 0xB8, 0xC7, 0xBA, 0xC7, 0xBC, 0xC7, 0xBE,
		0xC8, 0x80, 0xC8, 0x82, 0xC8, 0x84, 0xC8, 0x86,
		0xC8, 0x88, 0xC8, 0x8A, 0xC8, 0x8C, 0xC8, 0x8E,
		0xC8, 0x90, 0xC8, 0x92, 0xC8, 0x94, 0xC8, 0x96,
		0xC8, 0x98, 0xC8, 0x9A, 0xC8, 0x9C, 0xC8, 0x9E,
		0xC8, 0xA2, 0xC8, 0xA4, 0xC8, 0xA6, 0xC8, 0xA8,
		0xC8, 0xAA, 0xC8, 0xAC, 0xC8, 0xAE, 0xC8, 0xB0,
		0xC8, 0xB2, 0xC6, 0x81, 0xC6, 0x86, 0xC6, 0x89,
		0xC6, 0x8A, 0xC6, 0x8F, 0xC6, 0x90, 0xC6, 0x93,
		0xC6, 0x94, 0xC6, 0x97, 0xC6, 0x96, 0xC6, 0x9C,
		0xC6, 0x9D, 0xC6, 0x9F, 0xC6, 0xA6, 0xC6, 0xA9,
		0xC6, 0xAE, 0xC6, 0xB1, 0xC6, 0xB2, 0xC6, 0xB7,
		0xCE, 0x99, 0xCE, 0x86, 0xCE, 0x88, 0xCE, 0x89,
		0xCE, 0x8A, 0xCE, 0x91, 0xCE, 0x92, 0xCE, 0x93,
		0xCE, 0x94, 0xCE, 0x95, 0xCE, 0x96, 0xCE, 0x97,
		0xCE, 0x98, 0xCE, 0x99, 0xCE, 0x9A, 0xCE, 0x9B,
		0xCE, 0x9C, 0xCE, 0x9D, 0xCE, 0x9E, 0xCE, 0x9F,
		0xCE, 0xA0, 0xCE, 0xA1, 0xCE, 0xA3, 0xCE, 0xA3,
		0xCE, 0xA4, 0xCE, 0xA5, 0xCE, 0xA6, 0xCE, 0xA7,
		0xCE, 0xA8, 0xCE, 0xA9, 0xCE, 0xAA, 0xCE, 0xAB,
		0xCE, 0x8C, 0xCE, 0x8E, 0xCE, 0x8F, 0xCE, 0x92,
		0xCE, 0x98, 0xCE, 0xA6, 0xCE, 0xA0, 0xCF, 0x98,
		0xCF, 0x9A, 0xCF, 0x9C, 0xCF, 0x9E, 0xCF, 0xA0,
		0xCF, 0xA2, 0xCF, 0xA4, 0xCF, 0xA6, 0xCF, 0xA8,
		0xCF, 0xAA, 0xCF, 0xAC, 0xCF, 0xAE, 0xCE, 0x9A,
		0xCE, 0xA1, 0xCE, 0xA3, 0xCE, 0x95, 0xD0, 0x90,
		0xD0, 0x91, 0xD0, 0x92, 0xD0, 0x93, 0xD0, 0x94,
		0xD0, 0x95, 0xD0, 0x96, 0xD0, 0x97, 0xD0, 0x98,
		0xD0, 0x99, 0xD0, 0x9A, 0xD0, 0x9B, 0xD0, 0x9C,
		0xD0, 0x9D, 0xD0, 0x9E, 0xD0, 0x9F, 0xD0, 0xA0,
		0xD0, 0xA1, 0xD0, 0xA2, 0xD0, 0xA3, 0xD0, 0xA4,
		0xD0, 0xA5, 0xD0, 0xA6, 0xD0, 0xA7, 0xD0, 0xA8,
		0xD0, 0xA9, 0xD0, 0xAA, 0xD0, 0xAB, 0xD0, 0xAC,
		0xD0, 0xAD, 0xD0, 0xAE, 0xD0, 0xAF, 0xD0, 0x80,
		0xD0, 0x81, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0x84,
		0xD0, 0x85, 0xD0, 0x86, 0xD0, 0x87, 0xD0, 0x88,
		0xD0, 0x89, 0xD0, 0x8A, 0xD0, 0x8B, 0xD0, 0x8C,
		0xD0, 0x8D, 0xD0, 0x8E, 0xD0, 0x8F, 0xD1, 0xA0,
		0xD1, 0xA2, 0xD1, 0xA4, 0xD1, 0xA6, 0xD1, 0xA8,
		0xD1, 0xAA, 0xD1, 0xAC, 0xD1, 0xAE, 0xD1, 0xB0,
		0xD1, 0xB2, 0xD1, 0xB4, 0xD1, 0xB6, 0xD1, 0xB8,
		0xD1, 0xBA, 0xD1, 0xBC, 0xD1, 0xBE, 0xD2, 0x80,
		0xD2, 0x8A, 0xD2, 0x8C, 0xD2, 0x8E, 0xD2, 0x90,
		0xD2, 0x92, 0xD2, 0x94, 0xD2, 0x96, 0xD2, 0x98,
		0xD2, 0x9A, 0xD2, 0x9C, 0xD2, 0x9E, 0xD2, 0xA0,
		0xD2, 0xA2, 0xD2, 0xA4, 0xD2, 0xA6, 0xD2, 0xA8,
		0xD2, 0xAA, 0xD2, 0xAC, 0xD2, 0xAE, 0xD2, 0xB0,
		0xD2, 0xB2, 0xD2, 0xB4, 0xD2, 0xB6, 0xD2, 0xB8,
		0xD2, 0xBA, 0xD2, 0xBC, 0xD2, 0xBE, 0xD3, 0x81,
		0xD3, 0x83, 0xD3, 0x85, 0xD3, 0x87, 0xD3, 0x89,
		0xD3, 0x8B, 0xD3, 0x8D, 0xD3, 0x90, 0xD3, 0x92,
		0xD3, 0x94, 0xD3, 0x96, 0xD3, 0x98, 0xD3, 0x9A,
		0xD3, 0x9C, 0xD3, 0x9E, 0xD3, 0xA0, 0xD3, 0xA2,
		0xD3, 0xA4, 0xD3, 0xA6, 0xD3, 0xA8, 0xD3, 0xAA,
		0xD3, 0xAC, 0xD3, 0xAE, 0xD3, 0xB0, 0xD3, 0xB2,
		0xD3, 0xB4, 0xD3, 0xB8, 0xD4, 0x80, 0xD4, 0x82,
		0xD4, 0x84, 0xD4, 0x86, 0xD4, 0x88, 0xD4, 0x8A,
		0xD4, 0x8C, 0xD4, 0x8E, 0xD4, 0xB1, 0xD4, 0xB2,
		0xD4, 0xB3, 0xD4, 0xB4, 0xD4, 0xB5, 0xD4, 0xB6,
		0xD4, 0xB7, 0xD4, 0xB8, 0xD4, 0xB9, 0xD4, 0xBA,
		0xD4, 0xBB, 0xD4, 0xBC, 0xD4, 0xBD, 0xD4, 0xBE,
		0xD4, 0xBF, 0xD5, 0x80, 0xD5, 0x81, 0xD5, 0x82,
		0xD5, 0x83, 0xD5, 0x84, 0xD5, 0x85, 0xD5, 0x86,
		0xD5, 0x87, 0xD5, 0x88, 0xD5, 0x89, 0xD5, 0x8A,
		0xD5, 0x8B, 0xD5, 0x8C, 0xD5, 0x8D, 0xD5, 0x8E,
		0xD5, 0x8F, 0xD5, 0x90, 0xD5, 0x91, 0xD5, 0x92,
		0xD5, 0x93, 0xD5, 0x94, 0xD5, 0x95, 0xD5, 0x96,
		0xE1, 0xB8, 0x80, 0xE1, 0xB8, 0x82, 0xE1, 0xB8,
		0x84, 0xE1, 0xB8, 0x86, 0xE1, 0xB8, 0x88, 0xE1,
		0xB8, 0x8A, 0xE1, 0xB8, 0x8C, 0xE1, 0xB8, 0x8E,
		0xE1, 0xB8, 0x90, 0xE1, 0xB8, 0x92, 0xE1, 0xB8,
		0x94, 0xE1, 0xB8, 0x96, 0xE1, 0xB8, 0x98, 0xE1,
		0xB8, 0x9A, 0xE1, 0xB8, 0x9C, 0xE1, 0xB8, 0x9E,
		0xE1, 0xB8, 0xA0, 0xE1, 0xB8, 0xA2, 0xE1, 0xB8,
		0xA4, 0xE1, 0xB8, 0xA6, 0xE1, 0xB8, 0xA8, 0xE1,
		0xB8, 0xAA, 0xE1, 0xB8, 0xAC, 0xE1, 0xB8, 0xAE,
		0xE1, 0xB8, 0xB0, 0xE1, 0xB8, 0xB2, 0xE1, 0xB8,
		0xB4, 0xE1, 0xB8, 0xB6, 0xE1, 0xB8, 0xB8, 0xE1,
		0xB8, 0xBA, 0xE1, 0xB8, 0xBC, 0xE1, 0xB8, 0xBE,
		0xE1, 0xB9, 0x80, 0xE1, 0xB9, 0x82, 0xE1, 0xB9,
		0x84, 0xE1, 0xB9, 0x86, 0xE1, 0xB9, 0x88, 0xE1,
		0xB9, 0x8A, 0xE1, 0xB9, 0x8C, 0xE1, 0xB9, 0x8E,
		0xE1, 0xB9, 0x90, 0xE1, 0xB9, 0x92, 0xE1, 0xB9,
		0x94, 0xE1, 0xB9, 0x96, 0xE1, 0xB9, 0x98, 0xE1,
		0xB9, 0x9A, 0xE1, 0xB9, 0x9C, 0xE1, 0xB9, 0x9E,
		0xE1, 0xB9, 0xA0, 0xE1, 0xB9, 0xA2, 0xE1, 0xB9,
		0xA4, 0xE1, 0xB9, 0xA6, 0xE1, 0xB9, 0xA8, 0xE1,
		0xB9, 0xAA, 0xE1, 0xB9, 0xAC, 0xE1, 0xB9, 0xAE,
		0xE1, 0xB9, 0xB0, 0xE1, 0xB9, 0xB2, 0xE1, 0xB9,
		0xB4, 0xE1, 0xB9, 0xB6, 0xE1, 0xB9, 0xB8, 0xE1,
		0xB9, 0xBA, 0xE1, 0xB9, 0xBC, 0xE1, 0xB9, 0xBE,
		0xE1, 0xBA, 0x80, 0xE1, 0xBA, 0x82, 0xE1, 0xBA,
		0x84, 0xE1, 0xBA, 0x86, 0xE1, 0xBA, 0x88, 0xE1,
		0xBA, 0x8A, 0xE1, 0xBA, 0x8C, 0xE1, 0xBA, 0x8E,
		0xE1, 0xBA, 0x90, 0xE1, 0xBA, 0x92, 0xE1, 0xBA,
		0x94, 0xE1, 0xB9, 0xA0, 0xE1, 0xBA, 0xA0, 0xE1,
		0xBA, 0xA2, 0xE1, 0xBA, 0xA4, 0xE1, 0xBA, 0xA6,
		0xE1, 0xBA, 0xA8, 0xE1, 0xBA, 0xAA, 0xE1, 0xBA,
		0xAC, 0xE1, 0xBA, 0xAE, 0xE1, 0xBA, 0xB0, 0xE1,
		0xBA, 0xB2, 0xE1, 0xBA, 0xB4, 0xE1, 0xBA, 0xB6,
		0xE1, 0xBA, 0xB8, 0xE1, 0xBA, 0xBA, 0xE1, 0xBA,
		0xBC, 0xE1, 0xBA, 0xBE, 0xE1, 0xBB, 0x80, 0xE1,
		0xBB, 0x82, 0xE1, 0xBB, 0x84, 0xE1, 0xBB, 0x86,
		0xE1, 0xBB, 0x88, 0xE1, 0xBB, 0x8A, 0xE1, 0xBB,
		0x8C, 0xE1, 0xBB, 0x8E, 0xE1, 0xBB, 0x90, 0xE1,
		0xBB, 0x92, 0xE1, 0xBB, 0x94, 0xE1, 0xBB, 0x96,
		0xE1, 0xBB, 0x98, 0xE1, 0xBB, 0x9A, 0xE1, 0xBB,
		0x9C, 0xE1, 0xBB, 0x9E, 0xE1, 0xBB, 0xA0, 0xE1,
		0xBB, 0xA2, 0xE1, 0xBB, 0xA4, 0xE1, 0xBB, 0xA6,
		0xE1, 0xBB, 0xA8, 0xE1, 0xBB, 0xAA, 0xE1, 0xBB,
		0xAC, 0xE1, 0xBB, 0xAE, 0xE1, 0xBB, 0xB0, 0xE1,
		0xBB, 0xB2, 0xE1, 0xBB, 0xB4, 0xE1, 0xBB, 0xB6,
		0xE1, 0xBB, 0xB8, 0xE1, 0xBC, 0x88, 0xE1, 0xBC,
		0x89, 0xE1, 0xBC, 0x8A, 0xE1, 0xBC, 0x8B, 0xE1,
		0xBC, 0x8C, 0xE1, 0xBC, 0x8D, 0xE1, 0xBC, 0x8E,
		0xE1, 0xBC, 0x8F, 0xE1, 0xBC, 0x98, 0xE1, 0xBC,
		0x99, 0xE1, 0xBC, 0x9A, 0xE1, 0xBC, 0x9B, 0xE1,
		0xBC, 0x9C, 0xE1, 0xBC, 0x9D, 0xE1, 0xBC, 0xA8,
		0xE1, 0xBC, 0xA9, 0xE1, 0xBC, 0xAA, 0xE1, 0xBC,
		0xAB, 0xE1, 0xBC, 0xAC, 0xE1, 0xBC, 0xAD, 0xE1,
		0xBC, 0xAE, 0xE1, 0xBC, 0xAF, 0xE1, 0xBC, 0xB8,
		0xE1, 0xBC, 0xB9, 0xE1, 0xBC, 0xBA, 0xE1, 0xBC,
		0xBB, 0xE1, 0xBC, 0xBC, 0xE1, 0xBC, 0xBD, 0xE1,
		0xBC, 0xBE, 0xE1, 0xBC, 0xBF, 0xE1, 0xBD, 0x88,
		0xE1, 0xBD, 0x89, 0xE1, 0xBD, 0x8A, 0xE1, 0xBD,
		0x8B, 0xE1, 0xBD, 0x8C, 0xE1, 0xBD, 0x8D, 0xE1,
		0xBD, 0x99, 0xE1, 0xBD, 0x9B, 0xE1, 0xBD, 0x9D,
		0xE1, 0xBD, 0x9F, 0xE1, 0xBD, 0xA8, 0xE1, 0xBD,
		0xA9, 0xE1, 0xBD, 0xAA, 0xE1, 0xBD, 0xAB, 0xE1,
		0xBD, 0xAC, 0xE1, 0xBD, 0xAD, 0xE1, 0xBD, 0xAE,
		0xE1, 0xBD, 0xAF, 0xE1, 0xBE, 0xBA, 0xE1, 0xBE,
		0xBB, 0xE1, 0xBF, 0x88, 0xE1, 0xBF, 0x89, 0xE1,
		0xBF, 0x8A, 0xE1, 0xBF, 0x8B, 0xE1, 0xBF, 0x9A,
		0xE1, 0xBF, 0x9B, 0xE1, 0xBF, 0xB8, 0xE1, 0xBF,
		0xB9, 0xE1, 0xBF, 0xAA, 0xE1, 0xBF, 0xAB, 0xE1,
		0xBF, 0xBA, 0xE1, 0xBF, 0xBB, 0xE1, 0xBE, 0x88,
		0xE1, 0xBE, 0x89, 0xE1, 0xBE, 0x8A, 0xE1, 0xBE,
		0x8B, 0xE1, 0xBE, 0x8C, 0xE1, 0xBE, 0x8D, 0xE1,
		0xBE, 0x8E, 0xE1, 0xBE, 0x8F, 0xE1, 0xBE, 0x98,
		0xE1, 0xBE, 0x99, 0xE1, 0xBE, 0x9A, 0xE1, 0xBE,
		0x9B, 0xE1, 0xBE, 0x9C, 0xE1, 0xBE, 0x9D, 0xE1,
		0xBE, 0x9E, 0xE1, 0xBE, 0x9F, 0xE1, 0xBE, 0xA8,
		0xE1, 0xBE, 0xA9, 0xE1, 0xBE, 0xAA, 0xE1, 0xBE,
		0xAB, 0xE1, 0xBE, 0xAC, 0xE1, 0xBE, 0xAD, 0xE1,
		0xBE, 0xAE, 0xE1, 0xBE, 0xAF, 0xE1, 0xBE, 0xB8,
		0xE1, 0xBE, 0xB9, 0xE1, 0xBE, 0xBC, 0xCE, 0x99,
		0xE1, 0xBF, 0x8C, 0xE1, 0xBF, 0x98, 0xE1, 0xBF,
		0x99, 0xE1, 0xBF, 0xA8, 0xE1, 0xBF, 0xA9, 0xE1,
		0xBF, 0xAC, 0xE1, 0xBF, 0xBC, 0xE2, 0x85, 0xA0,
		0xE2, 0x85, 0xA1, 0xE2, 0x85, 0xA2, 0xE2, 0x85,
		0xA3, 0xE2, 0x85, 0xA4, 0xE2, 0x85, 0xA5, 0xE2,
		0x85, 0xA6, 0xE2, 0x85, 0xA7, 0xE2, 0x85, 0xA8,
		0xE2, 0x85, 0xA9, 0xE2, 0x85, 0xAA, 0xE2, 0x85,
		0xAB, 0xE2, 0x85, 0xAC, 0xE2, 0x85, 0xAD, 0xE2,
		0x85, 0xAE, 0xE2, 0x85, 0xAF, 0xE2, 0x92, 0xB6,
		0xE2, 0x92, 0xB7, 0xE2, 0x92, 0xB8, 0xE2, 0x92,
		0xB9, 0xE2, 0x92, 0xBA, 0xE2, 0x92, 0xBB, 0xE2,
		0x92, 0xBC, 0xE2, 0x92, 0xBD, 0xE2, 0x92, 0xBE,
		0xE2, 0x92, 0xBF, 0xE2, 0x93, 0x80, 0xE2, 0x93,
		0x81, 0xE2, 0x93, 0x82, 0xE2, 0x93, 0x83, 0xE2,
		0x93, 0x84, 0xE2, 0x93, 0x85, 0xE2, 0x93, 0x86,
		0xE2, 0x93, 0x87, 0xE2, 0x93, 0x88, 0xE2, 0x93,
		0x89, 0xE2, 0x93, 0x8A, 0xE2, 0x93, 0x8B, 0xE2,
		0x93, 0x8C, 0xE2, 0x93, 0x8D, 0xE2, 0x93, 0x8E,
		0xE2, 0x93, 0x8F, 0xEF, 0xBC, 0xA1, 0xEF, 0xBC,
		0xA2, 0xEF, 0xBC, 0xA3, 0xEF, 0xBC, 0xA4, 0xEF,
		0xBC, 0xA5, 0xEF, 0xBC, 0xA6, 0xEF, 0xBC, 0xA7,
		0xEF, 0xBC, 0xA8, 0xEF, 0xBC, 0xA9, 0xEF, 0xBC,
		0xAA, 0xEF, 0xBC, 0xAB, 0xEF, 0xBC, 0xAC, 0xEF,
		0xBC, 0xAD, 0xEF, 0xBC, 0xAE, 0xEF, 0xBC, 0xAF,
		0xEF, 0xBC, 0xB0, 0xEF, 0xBC, 0xB1, 0xEF, 0xBC,
		0xB2, 0xEF, 0xBC, 0xB3, 0xEF, 0xBC, 0xB4, 0xEF,
		0xBC, 0xB5, 0xEF, 0xBC, 0xB6, 0xEF, 0xBC, 0xB7,
		0xEF, 0xBC, 0xB8, 0xEF, 0xBC, 0xB9, 0xEF, 0xBC,
		0xBA, 0xF0, 0x90, 0x90, 0x80, 0xF0, 0x90, 0x90,
		0x81, 0xF0, 0x90, 0x90, 0x82, 0xF0, 0x90, 0x90,
		0x83, 0xF0, 0x90, 0x90, 0x84, 0xF0, 0x90, 0x90,
		0x85, 0xF0, 0x90, 0x90, 0x86, 0xF0, 0x90, 0x90,
		0x87, 0xF0, 0x90, 0x90, 0x88, 0xF0, 0x90, 0x90,
		0x89, 0xF0, 0x90, 0x90, 0x8A, 0xF0, 0x90, 0x90,
		0x8B, 0xF0, 0x90, 0x90, 0x8C, 0xF0, 0x90, 0x90,
		0x8D, 0xF0, 0x90, 0x90, 0x8E, 0xF0, 0x90, 0x90,
		0x8F, 0xF0, 0x90, 0x90, 0x90, 0xF0, 0x90, 0x90,
		0x91, 0xF0, 0x90, 0x90, 0x92, 0xF0, 0x90, 0x90,
		0x93, 0xF0, 0x90, 0x90, 0x94, 0xF0, 0x90, 0x90,
		0x95, 0xF0, 0x90, 0x90, 0x96, 0xF0, 0x90, 0x90,
		0x97, 0xF0, 0x90, 0x90, 0x98, 0xF0, 0x90, 0x90,
		0x99, 0xF0, 0x90, 0x90, 0x9A, 0xF0, 0x90, 0x90,
		0x9B, 0xF0, 0x90, 0x90, 0x9C, 0xF0, 0x90, 0x90,
		0x9D, 0xF0, 0x90, 0x90, 0x9E, 0xF0, 0x90, 0x90,
		0x9F, 0xF0, 0x90, 0x90, 0xA0, 0xF0, 0x90, 0x90,
		0xA1, 0xF0, 0x90, 0x90, 0xA2, 0xF0, 0x90, 0x90,
		0xA3, 0xF0, 0x90, 0x90, 0xA4, 0xF0, 0x90, 0x90,
		0xA5, 0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,    0,    0,
		0,    0,    0,    0,    0,    0,
	},
	{
		0xCE, 0x9C, 0xC3, 0x80, 0xC3, 0x81, 0xC3, 0x82,
		0xC3, 0x83, 0xC3, 0x84, 0xC3, 0x85, 0xC3, 0x86,
		0xC3, 0x87, 0xC3, 0x88, 0xC3, 0x89, 0xC3, 0x8A,
		0xC3, 0x8B, 0xC3, 0x8C, 0xC3, 0x8D, 0xC3, 0x8E,
		0xC3, 0x8F, 0xC3, 0x90, 0xC3, 0x91, 0xC3, 0x92,
		0xC3, 0x93, 0xC3, 0x94, 0xC3, 0x95, 0xC3, 0x96,
		0xC3, 0x98, 0xC3, 0x99, 0xC3, 0x9A, 0xC3, 0x9B,
		0xC3, 0x9C, 0xC3, 0x9D, 0xC3, 0x9E, 0xC5, 0xB8,
		0xC4, 0x80, 0xC4, 0x82, 0xC4, 0x84, 0xC4, 0x86,
		0xC4, 0x88, 0xC4, 0x8A, 0xC4, 0x8C, 0xC4, 0x8E,
		0xC4, 0x90, 0xC4, 0x92, 0xC4, 0x94, 0xC4, 0x96,
		0xC4, 0x98, 0xC4, 0x9A, 0xC4, 0x9C, 0xC4, 0x9E,
		0xC4, 0xA0, 0xC4, 0xA2, 0xC4, 0xA4, 0xC4, 0xA6,
		0xC4, 0xA8, 0xC4, 0xAA, 0xC4, 0xAC, 0xC4, 0xAE,
		0x49, 0xC4, 0xB2, 0xC4, 0xB4, 0xC4, 0xB6, 0xC4,
		0xB9, 0xC4, 0xBB, 0xC4, 0xBD, 0xC4, 0xBF, 0xC5,
		0x81, 0xC5, 0x83, 0xC5, 0x85, 0xC5, 0x87, 0xC5,
		0x8A, 0xC5, 0x8C, 0xC5, 0x8E, 0xC5, 0x90, 0xC5,
		0x92, 0xC5, 0x94, 0xC5, 0x96, 0xC5, 0x98, 0xC5,
		0x9A, 0xC5, 0x9C, 0xC5, 0x9E, 0xC5, 0xA0, 0xC5,
		0xA2, 0xC5, 0xA4, 0xC5, 0xA6, 0xC5, 0xA8, 0xC5,
		0xAA, 0xC5, 0xAC, 0xC5, 0xAE, 0xC5, 0xB0, 0xC5,
		0xB2, 0xC5, 0xB4, 0xC5, 0xB6, 0xC5, 0xB9, 0xC5,
		0xBB, 0xC5, 0xBD, 0x53, 0xC9, 0x83, 0xC6, 0x82,
		0xC6, 0x84, 0xC6, 0x87, 0xC6, 0x8B, 0xC6, 0x91,
		0xC7, 0xB6, 0xC6, 0x98, 0xC8, 0xBD, 0xC8, 0xA0,
		0xC6, 0xA0, 0xC6, 0xA2, 0xC6, 0xA4, 0xC6, 0xA7,
		0xC6, 0xAC, 0xC6, 0xAF, 0xC6, 0xB3, 0xC6, 0xB5,
		0xC6, 0xB8, 0xC6, 0xBC, 0xC7, 0xB7, 0xC7, 0x84,
		0xC7, 0x84, 0xC7, 0x87, 0xC7, 0x87, 0xC7, 0x8A,
		0xC7, 0x8A, 0xC7, 0x8D, 0xC7, 0x8F, 0xC7, 0x91,
		0xC7, 0x93, 0xC7, 0x95, 0xC7, 0x97, 0xC7, 0x99,
		0xC7, 0x9B, 0xC6, 0x8E, 0xC7, 0x9E, 0xC7, 0xA0,
		0xC7, 0xA2, 0xC7, 0xA4, 0xC7, 0xA6, 0xC7, 0xA8,
		0xC7, 0xAA, 0xC7, 0xAC, 0xC7, 0xAE, 0xC7, 0xB1,
		0xC7, 0xB1, 0xC7, 0xB4, 0xC7, 0xB8, 0xC7, 0xBA,
		0xC7, 0xBC, 0xC7, 0xBE, 0xC8, 0x80, 0xC8, 0x82,
		0xC8, 0x84, 0xC8, 0x86, 0xC8, 0x88, 0xC8, 0x8A,
		0xC8, 0x8C, 0xC8, 0x8E, 0xC8, 0x90, 0xC8, 0x92,
		0xC8, 0x94, 0xC8, 0x96, 0xC8, 0x98, 0xC8, 0x9A,
		0xC8, 0x9C, 0xC8, 0x9E, 0xC8, 0xA2, 0xC8, 0xA4,
		0xC8, 0xA6, 0xC8, 0xA8, 0xC8, 0xAA, 0xC8, 0xAC,
		0xC8, 0xAE, 0xC8, 0xB0, 0xC8, 0xB2, 0xC8, 0xBB,
		0xC9, 0x81, 0xC9, 0x86, 0xC9, 0x88, 0xC9, 0x8A,
		0xC9, 0x8C, 0xC9, 0x8E, 0xC6, 0x81, 0xC6, 0x86,
		0xC6, 0x89, 0xC6, 0x8A, 0xC6, 0x8F, 0xC6, 0x90,
		0xC6, 0x93, 0xC6, 0x94, 0xC6, 0x97, 0xC6, 0x96,
		0xE2, 0xB1, 0xA2, 0xC6, 0x9C, 0xC6, 0x9D, 0xC6,
		0x9F, 0xE2, 0xB1, 0xA4, 0xC6, 0xA6, 0xC6, 0xA9,
		0xC6, 0xAE, 0xC9, 0x84, 0xC6, 0xB1, 0xC6, 0xB2,
		0xC9, 0x85, 0xC6, 0xB7, 0xCE, 0x99, 0xCF, 0xBD,
		0xCF, 0xBE, 0xCF, 0xBF, 0xCE, 0x86, 0xCE, 0x88,
		0xCE, 0x89, 0xCE, 0x8A, 0xCE, 0x91, 0xCE, 0x92,
		0xCE, 0x93, 0xCE, 0x94, 0xCE, 0x95, 0xCE, 0x96,
		0xCE, 0x97, 0xCE, 0x98, 0xCE, 0x99, 0xCE, 0x9A,
		0xCE, 0x9B, 0xCE, 0x9C, 0xCE, 0x9D, 0xCE, 0x9E,
		0xCE, 0x9F, 0xCE, 0xA0, 0xCE, 0xA1, 0xCE, 0xA3,
		0xCE, 0xA3, 0xCE, 0xA4, 0xCE, 0xA5, 0xCE, 0xA6,
		0xCE, 0xA7, 0xCE, 0xA8, 0xCE, 0xA9, 0xCE, 0xAA,
		0xCE, 0xAB, 0xCE, 0x8C, 0xCE, 0x8E, 0xCE, 0x8F,
		0xCE, 0x92, 0xCE, 0x98, 0xCE, 0xA6, 0xCE, 0xA0,
		0xCF, 0x98, 0xCF, 0x9A, 0xCF, 0x9C, 0xCF, 0x9E,
		0xCF, 0xA0, 0xCF, 0xA2, 0xCF, 0xA4, 0xCF, 0xA6,
		0xCF, 0xA8, 0xCF, 0xAA, 0xCF, 0xAC, 0xCF, 0xAE,
		0xCE, 0x9A, 0xCE, 0xA1, 0xCF, 0xB9, 0xCE, 0x95,
		0xCF, 0xB7, 0xCF, 0xBA, 0xD0, 0x90, 0xD0, 0x91,
		0xD0, 0x92, 0xD0, 0x93, 0xD0, 0x94, 0xD0, 0x95,
		0xD0, 0x96, 0xD0, 0x97, 0xD0, 0x98, 0xD0, 0x99,
		0xD0, 0x9A, 0xD0, 0x9B, 0xD0, 0x9C, 0xD0, 0x9D,
		0xD0, 0x9E, 0xD0, 0x9F, 0xD0, 0xA0, 0xD0, 0xA1,
		0xD0, 0xA2, 0xD0, 0xA3, 0xD0, 0xA4, 0xD0, 0xA5,
		0xD0, 0xA6, 0xD0, 0xA7, 0xD0, 0xA8, 0xD0, 0xA9,
		0xD0, 0xAA, 0xD0, 0xAB, 0xD0, 0xAC, 0xD0, 0xAD,
		0xD0, 0xAE, 0xD0, 0xAF, 0xD0, 0x80, 0xD0, 0x81,
		0xD0, 0x82, 0xD0, 0x83, 0xD0, 0x84, 0xD0, 0x85,
		0xD0, 0x86, 0xD0, 0x87, 0xD0, 0x88, 0xD0, 0x89,
		0xD0, 0x8A, 0xD0, 0x8B, 0xD0, 0x8C, 0xD0, 0x8D,
		0xD0, 0x8E, 0xD0, 0x8F, 0xD1, 0xA0, 0xD1, 0xA2,
		0xD1, 0xA4, 0xD1, 0xA6, 0xD1, 0xA8, 0xD1, 0xAA,
		0xD1, 0xAC, 0xD1, 0xAE, 0xD1, 0xB0, 0xD1, 0xB2,
		0xD1, 0xB4, 0xD1, 0xB6, 0xD1, 0xB8, 0xD1, 0xBA,
		0xD1, 0xBC, 0xD1, 0xBE, 0xD2, 0x80, 0xD2, 0x8A,
		0xD2, 0x8C, 0xD2, 0x8E, 0xD2, 0x90, 0xD2, 0x92,
		0xD2, 0x94, 0xD2, 0x96, 0xD2, 0x98, 0xD2, 0x9A,
		0xD2, 0x9C, 0xD2, 0x9E, 0xD2, 0xA0, 0xD2, 0xA2,
		0xD2, 0xA4, 0xD2, 0xA6, 0xD2, 0xA8, 0xD2, 0xAA,
		0xD2, 0xAC, 0xD2, 0xAE, 0xD2, 0xB0, 0xD2, 0xB2,
		0xD2, 0xB4, 0xD2, 0xB6, 0xD2, 0xB8, 0xD2, 0xBA,
		0xD2, 0xBC, 0xD2, 0xBE, 0xD3, 0x81, 0xD3, 0x83,
		0xD3, 0x85, 0xD3, 0x87, 0xD3, 0x89, 0xD3, 0x8B,
		0xD3, 0x8D, 0xD3, 0x80, 0xD3, 0x90, 0xD3, 0x92,
		0xD3, 0x94, 0xD3, 0x96, 0xD3, 0x98, 0xD3, 0x9A,
		0xD3, 0x9C, 0xD3, 0x9E, 0xD3, 0xA0, 0xD3, 0xA2,
		0xD3, 0xA4, 0xD3, 0xA6, 0xD3, 0xA8, 0xD3, 0xAA,
		0xD3, 0xAC, 0xD3, 0xAE, 0xD3, 0xB0, 0xD3, 0xB2,
		0xD3, 0xB4, 0xD3, 0xB6, 0xD3, 0xB8, 0xD3, 0xBA,
		0xD3, 0xBC, 0xD3, 0xBE, 0xD4, 0x80, 0xD4, 0x82,
		0xD4, 0x84, 0xD4, 0x86, 0xD4, 0x88, 0xD4, 0x8A,
		0xD4, 0x8C, 0xD4, 0x8E, 0xD4, 0x90, 0xD4, 0x92,
		0xD4, 0xB1, 0xD4, 0xB2, 0xD4, 0xB3, 0xD4, 0xB4,
		0xD4, 0xB5, 0xD4, 0xB6, 0xD4, 0xB7, 0xD4, 0xB8,
		0xD4, 0xB9, 0xD4, 0xBA, 0xD4, 0xBB, 0xD4, 0xBC,
		0xD4, 0xBD, 0xD4, 0xBE, 0xD4, 0xBF, 0xD5, 0x80,
		0xD5, 0x81, 0xD5, 0x82, 0xD5, 0x83, 0xD5, 0x84,
		0xD5, 0x85, 0xD5, 0x86, 0xD5, 0x87, 0xD5, 0x88,
		0xD5, 0x89, 0xD5, 0x8A, 0xD5, 0x8B, 0xD5, 0x8C,
		0xD5, 0x8D, 0xD5, 0x8E, 0xD5, 0x8F, 0xD5, 0x90,
		0xD5, 0x91, 0xD5, 0x92, 0xD5, 0x93, 0xD5, 0x94,
		0xD5, 0x95, 0xD5, 0x96, 0xE2, 0xB1, 0xA3, 0xE1,
		0xB8, 0x80, 0xE1, 0xB8, 0x82, 0xE1, 0xB8, 0x84,
		0xE1, 0xB8, 0x86, 0xE1, 0xB8, 0x88, 0xE1, 0xB8,
		0x8A, 0xE1, 0xB8, 0x8C, 0xE1, 0xB8, 0x8E, 0xE1,
		0xB8, 0x90, 0xE1, 0xB8, 0x92, 0xE1, 0xB8, 0x94,
		0xE1, 0xB8, 0x96, 0xE1, 0xB8, 0x98, 0xE1, 0xB8,
		0x9A, 0xE1, 0xB8, 0x9C, 0xE1, 0xB8, 0x9E, 0xE1,
		0xB8, 0xA0, 0xE1, 0xB8, 0xA2, 0xE1, 0xB8, 0xA4,
		0xE1, 0xB8, 0xA6, 0xE1, 0xB8, 0xA8, 0xE1, 0xB8,
		0xAA, 0xE1, 0xB8, 0xAC, 0xE1, 0xB8, 0xAE, 0xE1,
		0xB8, 0xB0, 0xE1, 0xB8, 0xB2, 0xE1, 0xB8, 0xB4,
		0xE1, 0xB8, 0xB6, 0xE1, 0xB8, 0xB8, 0xE1, 0xB8,
		0xBA, 0xE1, 0xB8, 0xBC, 0xE1, 0xB8, 0xBE, 0xE1,
		0xB9, 0x80, 0xE1, 0xB9, 0x82, 0xE1, 0xB9, 0x84,
		0xE1, 0xB9, 0x86, 0xE1, 0xB9, 0x88, 0xE1, 0xB9,
		0x8A, 0xE1, 0xB9, 0x8C, 0xE1, 0xB9, 0x8E, 0xE1,
		0xB9, 0x90, 0xE1, 0xB9, 0x92, 0xE1, 0xB9, 0x94,
		0xE1, 0xB9, 0x96, 0xE1, 0xB9, 0x98, 0xE1, 0xB9,
		0x9A, 0xE1, 0xB9, 0x9C, 0xE1, 0xB9, 0x9E, 0xE1,
		0xB9, 0xA0, 0xE1, 0xB9, 0xA2, 0xE1, 0xB9, 0xA4,
		0xE1, 0xB9, 0xA6, 0xE1, 0xB9, 0xA8, 0xE1, 0xB9,
		0xAA, 0xE1, 0xB9, 0xAC, 0xE1, 0xB9, 0xAE, 0xE1,
		0xB9, 0xB0, 0xE1, 0xB9, 0xB2, 0xE1, 0xB9, 0xB4,
		0xE1, 0xB9, 0xB6, 0xE1, 0xB9, 0xB8, 0xE1, 0xB9,
		0xBA, 0xE1, 0xB9, 0xBC, 0xE1, 0xB9, 0xBE, 0xE1,
		0xBA, 0x80, 0xE1, 0xBA, 0x82, 0xE1, 0xBA, 0x84,
		0xE1, 0xBA, 0x86, 0xE1, 0xBA, 0x88, 0xE1, 0xBA,
		0x8A, 0xE1, 0xBA, 0x8C, 0xE1, 0xBA, 0x8E, 0xE1,
		0xBA, 0x90, 0xE1, 0xBA, 0x92, 0xE1, 0xBA, 0x94,
		0xE1, 0xB9, 0xA0, 0xE1, 0xBA, 0xA0, 0xE1, 0xBA,
		0xA2, 0xE1, 0xBA, 0xA4, 0xE1, 0xBA, 0xA6, 0xE1,
		0xBA, 0xA8, 0xE1, 0xBA, 0xAA, 0xE1, 0xBA, 0xAC,
		0xE1, 0xBA, 0xAE, 0xE1, 0xBA, 0xB0, 0xE1, 0xBA,
		0xB2, 0xE1, 0xBA, 0xB4, 0xE1, 0xBA, 0xB6, 0xE1,
		0xBA, 0xB8, 0xE1, 0xBA, 0xBA, 0xE1, 0xBA, 0xBC,
		0xE1, 0xBA, 0xBE, 0xE1, 0xBB, 0x80, 0xE1, 0xBB,
		0x82, 0xE1, 0xBB, 0x84, 0xE1, 0xBB, 0x86, 0xE1,
		0xBB, 0x88, 0xE1, 0xBB, 0x8A, 0xE1, 0xBB, 0x8C,
		0xE1, 0xBB, 0x8E, 0xE1, 0xBB, 0x90, 0xE1, 0xBB,
		0x92, 0xE1, 0xBB, 0x94, 0xE1, 0xBB, 0x96, 0xE1,
		0xBB, 0x98, 0xE1, 0xBB, 0x9A, 0xE1, 0xBB, 0x9C,
		0xE1, 0xBB, 0x9E, 0xE1, 0xBB, 0xA0, 0xE1, 0xBB,
		0xA2, 0xE1, 0xBB, 0xA4, 0xE1, 0xBB, 0xA6, 0xE1,
		0xBB, 0xA8, 0xE1, 0xBB, 0xAA, 0xE1, 0xBB, 0xAC,
		0xE1, 0xBB, 0xAE, 0xE1, 0xBB, 0xB0, 0xE1, 0xBB,
		0xB2, 0xE1, 0xBB, 0xB4, 0xE1, 0xBB, 0xB6, 0xE1,
		0xBB, 0xB8, 0xE1, 0xBC, 0x88, 0xE1, 0xBC, 0x89,
		0xE1, 0xBC, 0x8A, 0xE1, 0xBC, 0x8B, 0xE1, 0xBC,
		0x8C, 0xE1, 0xBC, 0x8D, 0xE1, 0xBC, 0x8E, 0xE1,
		0xBC, 0x8F, 0xE1, 0xBC, 0x98, 0xE1, 0xBC, 0x99,
		0xE1, 0xBC, 0x9A, 0xE1, 0xBC, 0x9B, 0xE1, 0xBC,
		0x9C, 0xE1, 0xBC, 0x9D, 0xE1, 0xBC, 0xA8, 0xE1,
		0xBC, 0xA9, 0xE1, 0xBC, 0xAA, 0xE1, 0xBC, 0xAB,
		0xE1, 0xBC, 0xAC, 0xE1, 0xBC, 0xAD, 0xE1, 0xBC,
		0xAE, 0xE1, 0xBC, 0xAF, 0xE1, 0xBC, 0xB8, 0xE1,
		0xBC, 0xB9, 0xE1, 0xBC, 0xBA, 0xE1, 0xBC, 0xBB,
		0xE1, 0xBC, 0xBC, 0xE1, 0xBC, 0xBD, 0xE1, 0xBC,
		0xBE, 0xE1, 0xBC, 0xBF, 0xE1, 0xBD, 0x88, 0xE1,
		0xBD, 0x89, 0xE1, 0xBD, 0x8A, 0xE1, 0xBD, 0x8B,
		0xE1, 0xBD, 0x8C, 0xE1, 0xBD, 0x8D, 0xE1, 0xBD,
		0x99, 0xE1, 0xBD, 0x9B, 0xE1, 0xBD, 0x9D, 0xE1,
		0xBD, 0x9F, 0xE1, 0xBD, 0xA8, 0xE1, 0xBD, 0xA9,
		0xE1, 0xBD, 0xAA, 0xE1, 0xBD, 0xAB, 0xE1, 0xBD,
		0xAC, 0xE1, 0xBD, 0xAD, 0xE1, 0xBD, 0xAE, 0xE1,
		0xBD, 0xAF, 0xE1, 0xBE, 0xBA, 0xE1, 0xBE, 0xBB,
		0xE1, 0xBF, 0x88, 0xE1, 0xBF, 0x89, 0xE1, 0xBF,
		0x8A, 0xE1, 0xBF, 0x8B, 0xE1, 0xBF, 0x9A, 0xE1,
		0xBF, 0x9B, 0xE1, 0xBF, 0xB8, 0xE1, 0xBF, 0xB9,
		0xE1, 0xBF, 0xAA, 0xE1, 0xBF, 0xAB, 0xE1, 0xBF,
		0xBA, 0xE1, 0xBF, 0xBB, 0xE1, 0xBE, 0x88, 0xE1,
		0xBE, 0x89, 0xE1, 0xBE, 0x8A, 0xE1, 0xBE, 0x8B,
		0xE1, 0xBE, 0x8C, 0xE1, 0xBE, 0x8D, 0xE1, 0xBE,
		0x8E, 0xE1, 0xBE, 0x8F, 0xE1, 0xBE, 0x98, 0xE1,
		0xBE, 0x99, 0xE1, 0xBE, 0x9A, 0xE1, 0xBE, 0x9B,
		0xE1, 0xBE, 0x9C, 0xE1, 0xBE, 0x9D, 0xE1, 0xBE,
		0x9E, 0xE1, 0xBE, 0x9F, 0xE1, 0xBE, 0xA8, 0xE1,
		0xBE, 0xA9, 0xE1, 0xBE, 0xAA, 0xE1, 0xBE, 0xAB,
		0xE1, 0xBE, 0xAC, 0xE1, 0xBE, 0xAD, 0xE1, 0xBE,
		0xAE, 0xE1, 0xBE, 0xAF, 0xE1, 0xBE, 0xB8, 0xE1,
		0xBE, 0xB9, 0xE1, 0xBE, 0xBC, 0xCE, 0x99, 0xE1,
		0xBF, 0x8C, 0xE1, 0xBF, 0x98, 0xE1, 0xBF, 0x99,
		0xE1, 0xBF, 0xA8, 0xE1, 0xBF, 0xA9, 0xE1, 0xBF,
		0xAC, 0xE1, 0xBF, 0xBC, 0xE2, 0x84, 0xB2, 0xE2,
		0x85, 0xA0, 0xE2, 0x85, 0xA1, 0xE2, 0x85, 0xA2,
		0xE2, 0x85, 0xA3, 0xE2, 0x85, 0xA4, 0xE2, 0x85,
		0xA5, 0xE2, 0x85, 0xA6, 0xE2, 0x85, 0xA7, 0xE2,
		0x85, 0xA8, 0xE2, 0x85, 0xA9, 0xE2, 0x85, 0xAA,
		0xE2, 0x85, 0xAB, 0xE2, 0x85, 0xAC, 0xE2, 0x85,
		0xAD, 0xE2, 0x85, 0xAE, 0xE2, 0x85, 0xAF, 0xE2,
		0x86, 0x83, 0xE2, 0x92, 0xB6, 0xE2, 0x92, 0xB7,
		0xE2, 0x92, 0xB8, 0xE2, 0x92, 0xB9, 0xE2, 0x92,
		0xBA, 0xE2, 0x92, 0xBB, 0xE2, 0x92, 0xBC, 0xE2,
		0x92, 0xBD, 0xE2, 0x92, 0xBE, 0xE2, 0x92, 0xBF,
		0xE2, 0x93, 0x80, 0xE2, 0x93, 0x81, 0xE2, 0x93,
		0x82, 0xE2, 0x93, 0x83, 0xE2, 0x93, 0x84, 0xE2,
		0x93, 0x85, 0xE2, 0x93, 0x86, 0xE2, 0x93, 0x87,
		0xE2, 0x93, 0x88, 0xE2, 0x93, 0x89, 0xE2, 0x93,
		0x8A, 0xE2, 0x93, 0x8B, 0xE2, 0x93, 0x8C, 0xE2,
		0x93, 0x8D, 0xE2, 0x93, 0x8E, 0xE2, 0x93, 0x8F,
		0xE2, 0xB0, 0x80, 0xE2, 0xB0, 0x81, 0xE2, 0xB0,
		0x82, 0xE2, 0xB0, 0x83, 0xE2, 0xB0, 0x84, 0xE2,
		0xB0, 0x85, 0xE2, 0xB0, 0x86, 0xE2, 0xB0, 0x87,
		0xE2, 0xB0, 0x88, 0xE2, 0xB0, 0x89, 0xE2, 0xB0,
		0x8A, 0xE2, 0xB0, 0x8B, 0xE2, 0xB0, 0x8C, 0xE2,
		0xB0, 0x8D, 0xE2, 0xB0, 0x8E, 0xE2, 0xB0, 0x8F,
		0xE2, 0xB0, 0x90, 0xE2, 0xB0, 0x91, 0xE2, 0xB0,
		0x92, 0xE2, 0xB0, 0x93, 0xE2, 0xB0, 0x94, 0xE2,
		0xB0, 0x95, 0xE2, 0xB0, 0x96, 0xE2, 0xB0, 0x97,
		0xE2, 0xB0, 0x98, 0xE2, 0xB0, 0x99, 0xE2, 0xB0,
		0x9A, 0xE2, 0xB0, 0x9B, 0xE2, 0xB0, 0x9C, 0xE2,
		0xB0, 0x9D, 0xE2, 0xB0, 0x9E, 0xE2, 0xB0, 0x9F,
		0xE2, 0xB0, 0xA0, 0xE2, 0xB0, 0xA1, 0xE2, 0xB0,
		0xA2, 0xE2, 0xB0, 0xA3, 0xE2, 0xB0, 0xA4, 0xE2,
		0xB0, 0xA5, 0xE2, 0xB0, 0xA6, 0xE2, 0xB0, 0xA7,
		0xE2, 0xB0, 0xA8, 0xE2, 0xB0, 0xA9, 0xE2, 0xB0,
		0xAA, 0xE2, 0xB0, 0xAB, 0xE2, 0xB0, 0xAC, 0xE2,
		0xB0, 0xAD, 0xE2, 0xB0, 0xAE, 0xE2, 0xB1, 0xA0,
		0xC8, 0xBA, 0xC8, 0xBE, 0xE2, 0xB1, 0xA7, 0xE2,
		0xB1, 0xA9, 0xE2, 0xB1, 0xAB, 0xE2, 0xB1, 0xB5,
		0xE2, 0xB2, 0x80, 0xE2, 0xB2, 0x82, 0xE2, 0xB2,
		0x84, 0xE2, 0xB2, 0x86, 0xE2, 0xB2, 0x88, 0xE2,
		0xB2, 0x8A, 0xE2, 0xB2, 0x8C, 0xE2, 0xB2, 0x8E,
		0xE2, 0xB2, 0x90, 0xE2, 0xB2, 0x92, 0xE2, 0xB2,
		0x94, 0xE2, 0xB2, 0x96, 0xE2, 0xB2, 0x98, 0xE2,
		0xB2, 0x9A, 0xE2, 0xB2, 0x9C, 0xE2, 0xB2, 0x9E,
		0xE2, 0xB2, 0xA0, 0xE2, 0xB2, 0xA2, 0xE2, 0xB2,
		0xA4, 0xE2, 0xB2, 0xA6, 0xE2, 0xB2, 0xA8, 0xE2,
		0xB2, 0xAA, 0xE2, 0xB2, 0xAC, 0xE2, 0xB2, 0xAE,
		0xE2, 0xB2, 0xB0, 0xE2, 0xB2, 0xB2, 0xE2, 0xB2,
		0xB4, 0xE2, 0xB2, 0xB6, 0xE2, 0xB2, 0xB8, 0xE2,
		0xB2, 0xBA, 0xE2, 0xB2, 0xBC, 0xE2, 0xB2, 0xBE,
		0xE2, 0xB3, 0x80, 0xE2, 0xB3, 0x82, 0xE2, 0xB3,
		0x84, 0xE2, 0xB3, 0x86, 0xE2, 0xB3, 0x88, 0xE2,
		0xB3, 0x8A, 0xE2, 0xB3, 0x8C, 0xE2, 0xB3, 0x8E,
		0xE2, 0xB3, 0x90, 0xE2, 0xB3, 0x92, 0xE2, 0xB3,
		0x94, 0xE2, 0xB3, 0x96, 0xE2, 0xB3, 0x98, 0xE2,
		0xB3, 0x9A, 0xE2, 0xB3, 0x9C, 0xE2, 0xB3, 0x9E,
		0xE2, 0xB3, 0xA0, 0xE2, 0xB3, 0xA2, 0xE1, 0x82,
		0xA0, 0xE1, 0x82, 0xA1, 0xE1, 0x82, 0xA2, 0xE1,
		0x82, 0xA3, 0xE1, 0x82, 0xA4, 0xE1, 0x82, 0xA5,
		0xE1, 0x82, 0xA6, 0xE1, 0x82, 0xA7, 0xE1, 0x82,
		0xA8, 0xE1, 0x82, 0xA9, 0xE1, 0x82, 0xAA, 0xE1,
		0x82, 0xAB, 0xE1, 0x82, 0xAC, 0xE1, 0x82, 0xAD,
		0xE1, 0x82, 0xAE, 0xE1, 0x82, 0xAF, 0xE1, 0x82,
		0xB0, 0xE1, 0x82, 0xB1, 0xE1, 0x82, 0xB2, 0xE1,
		0x82, 0xB3, 0xE1, 0x82, 0xB4, 0xE1, 0x82, 0xB5,
		0xE1, 0x82, 0xB6, 0xE1, 0x82, 0xB7, 0xE1, 0x82,
		0xB8, 0xE1, 0x82, 0xB9, 0xE1, 0x82, 0xBA, 0xE1,
		0x82, 0xBB, 0xE1, 0x82, 0xBC, 0xE1, 0x82, 0xBD,
		0xE1, 0x82, 0xBE, 0xE1, 0x82, 0xBF, 0xE1, 0x83,
		0x80, 0xE1, 0x83, 0x81, 0xE1, 0x83, 0x82, 0xE1,
		0x83, 0x83, 0xE1, 0x83, 0x84, 0xE1, 0x83, 0x85,
		0xEF, 0xBC, 0xA1, 0xEF, 0xBC, 0xA2, 0xEF, 0xBC,
		0xA3, 0xEF, 0xBC, 0xA4, 0xEF, 0xBC, 0xA5, 0xEF,
		0xBC, 0xA6, 0xEF, 0xBC, 0xA7, 0xEF, 0xBC, 0xA8,
		0xEF, 0xBC, 0xA9, 0xEF, 0xBC, 0xAA, 0xEF, 0xBC,
		0xAB, 0xEF, 0xBC, 0xAC, 0xEF, 0xBC, 0xAD, 0xEF,
		0xBC, 0xAE, 0xEF, 0xBC, 0xAF, 0xEF, 0xBC, 0xB0,
		0xEF, 0xBC, 0xB1, 0xEF, 0xBC, 0xB2, 0xEF, 0xBC,
		0xB3, 0xEF, 0xBC, 0xB4, 0xEF, 0xBC, 0xB5, 0xEF,
		0xBC, 0xB6, 0xEF, 0xBC, 0xB7, 0xEF, 0xBC, 0xB8,
		0xEF, 0xBC, 0xB9, 0xEF, 0xBC, 0xBA, 0xF0, 0x90,
		0x90, 0x80, 0xF0, 0x90, 0x90, 0x81, 0xF0, 0x90,
		0x90, 0x82, 0xF0, 0x90, 0x90, 0x83, 0xF0, 0x90,
		0x90, 0x84, 0xF0, 0x90, 0x90, 0x85, 0xF0, 0x90,
		0x90, 0x86, 0xF0, 0x90, 0x90, 0x87, 0xF0, 0x90,
		0x90, 0x88, 0xF0, 0x90, 0x90, 0x89, 0xF0, 0x90,
		0x90, 0x8A, 0xF0, 0x90, 0x90, 0x8B, 0xF0, 0x90,
		0x90, 0x8C, 0xF0, 0x90, 0x90, 0x8D, 0xF0, 0x90,
		0x90, 0x8E, 0xF0, 0x90, 0x90, 0x8F, 0xF0, 0x90,
		0x90, 0x90, 0xF0, 0x90, 0x90, 0x91, 0xF0, 0x90,
		0x90, 0x92, 0xF0, 0x90, 0x90, 0x93, 0xF0, 0x90,
		0x90, 0x94, 0xF0, 0x90, 0x90, 0x95, 0xF0, 0x90,
		0x90, 0x96, 0xF0, 0x90, 0x90, 0x97, 0xF0, 0x90,
		0x90, 0x98, 0xF0, 0x90, 0x90, 0x99, 0xF0, 0x90,
		0x90, 0x9A, 0xF0, 0x90, 0x90, 0x9B, 0xF0, 0x90,
		0x90, 0x9C, 0xF0, 0x90, 0x90, 0x9D, 0xF0, 0x90,
		0x90, 0x9E, 0xF0, 0x90, 0x90, 0x9F, 0xF0, 0x90,
		0x90, 0xA0, 0xF0, 0x90, 0x90, 0xA1, 0xF0, 0x90,
		0x90, 0xA2, 0xF0, 0x90, 0x90, 0xA3, 0xF0, 0x90,
		0x90, 0xA4, 0xF0, 0x90, 0x90, 0xA5, 0xF0, 0x90,
		0x90, 0xA6, 0xF0, 0x90, 0x90, 0xA7,
	},
};

#undef	N_
#undef	FIL_

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_U8_TEXTPREP_DATA_H */
                                                                                                                                                                                                                                                                                                                                                                                                               usr/src/zfs-0.6.5.9/include/sys/uberblock.h                                                         0100644 0000000 0000000 00000002516 13045171016 016646  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */
/*
 * Copyright (c) 2014 by Delphix. All rights reserved.
 */

#ifndef _SYS_UBERBLOCK_H
#define	_SYS_UBERBLOCK_H

#include <sys/spa.h>
#include <sys/vdev.h>
#include <sys/zio.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef struct uberblock uberblock_t;

extern int uberblock_verify(uberblock_t *);
extern boolean_t uberblock_update(uberblock_t *, vdev_t *, uint64_t);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_UBERBLOCK_H */
                                                                                                                                                                                  usr/src/zfs-0.6.5.9/include/sys/uberblock_impl.h                                                    0100644 0000000 0000000 00000004044 13045171016 017665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef _SYS_UBERBLOCK_IMPL_H
#define	_SYS_UBERBLOCK_IMPL_H

#include <sys/uberblock.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * The uberblock version is incremented whenever an incompatible on-disk
 * format change is made to the SPA, DMU, or ZAP.
 *
 * Note: the first two fields should never be moved.  When a storage pool
 * is opened, the uberblock must be read off the disk before the version
 * can be checked.  If the ub_version field is moved, we may not detect
 * version mismatch.  If the ub_magic field is moved, applications that
 * expect the magic number in the first word won't work.
 */
#define	UBERBLOCK_MAGIC		0x00bab10c		/* oo-ba-bloc!	*/
#define	UBERBLOCK_SHIFT		10			/* up to 1K	*/

struct uberblock {
	uint64_t	ub_magic;	/* UBERBLOCK_MAGIC		*/
	uint64_t	ub_version;	/* SPA_VERSION			*/
	uint64_t	ub_txg;		/* txg of last sync		*/
	uint64_t	ub_guid_sum;	/* sum of all vdev guids	*/
	uint64_t	ub_timestamp;	/* UTC time of last sync	*/
	blkptr_t	ub_rootbp;	/* MOS objset_phys_t		*/

	/* highest SPA_VERSION supported by software that wrote this txg */
	uint64_t	ub_software_version;
};

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_UBERBLOCK_IMPL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/uio_impl.h                                                          0100644 0000000 0000000 00000003130 13045171016 016504  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved	*/

/*
 * University Copyright- Copyright (c) 1982, 1986, 1988
 * The Regents of the University of California
 * All Rights Reserved
 *
 * University Acknowledgment- Portions of this document are derived from
 * software developed by the University of California, Berkeley, and its
 * contributors.
 */

#ifndef _SYS_UIO_IMPL_H
#define	_SYS_UIO_IMPL_H

#include <sys/uio.h>

extern int uiomove(void *, size_t, enum uio_rw, uio_t *);
extern void uio_prefaultpages(ssize_t, uio_t *);
extern int uiocopy(void *, size_t, enum uio_rw, uio_t *, size_t *);
extern void uioskip(uio_t *, size_t);

#endif	/* _SYS_UIO_IMPL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/sys/unique.h                                                            0100644 0000000 0000000 00000003073 13045171016 016203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_SYS_UNIQUE_H
#define	_SYS_UNIQUE_H

#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

/* The number of significant bits in each unique value. */
#define	UNIQUE_BITS	56

void unique_init(void);
void unique_fini(void);

/*
 * Return a new unique value (which will not be uniquified against until
 * it is unique_insert()-ed).
 */
uint64_t unique_create(void);

/* Return a unique value, which equals the one passed in if possible. */
uint64_t unique_insert(uint64_t value);

/* Indicate that this value no longer needs to be uniquified against. */
void unique_remove(uint64_t value);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_UNIQUE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/src/zfs-0.6.5.9/include/sys/uuid.h                                                              0100644 0000000 0000000 00000005544 13045171016 015650  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_SYS_UUID_H
#define	_SYS_UUID_H

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * The copyright in this file is taken from the original Leach
 * & Salz UUID specification, from which this implementation
 * is derived.
 */

/*
 * Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
 * Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
 * Digital Equipment Corporation, Maynard, Mass.  Copyright (c) 1998
 * Microsoft.  To anyone who acknowledges that this file is provided
 * "AS IS" without any express or implied warranty: permission to use,
 * copy, modify, and distribute this file for any purpose is hereby
 * granted without fee, provided that the above copyright notices and
 * this notice appears in all source code copies, and that none of the
 * names of Open Software Foundation, Inc., Hewlett-Packard Company,
 * or Digital Equipment Corporation be used in advertising or
 * publicity pertaining to distribution of the software without
 * specific, written prior permission.  Neither Open Software
 * Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital
 * Equipment Corporation makes any representations about the
 * suitability of this software for any purpose.
 */

#include <sys/types.h>
#include <sys/byteorder.h>

typedef struct {
	uint8_t		nodeID[6];
} uuid_node_t;

/*
 * The uuid type used throughout when referencing uuids themselves
 */
struct uuid {
	uint32_t	time_low;
	uint16_t	time_mid;
	uint16_t	time_hi_and_version;
	uint8_t		clock_seq_hi_and_reserved;
	uint8_t		clock_seq_low;
	uint8_t		node_addr[6];
};

#define	UUID_PRINTABLE_STRING_LENGTH 37

/*
 * Convert a uuid to/from little-endian format
 */
#define	UUID_LE_CONVERT(dest, src)					\
{									\
	(dest) = (src);							\
	(dest).time_low = LE_32((dest).time_low);			\
	(dest).time_mid = LE_16((dest).time_mid);			\
	(dest).time_hi_and_version = LE_16((dest).time_hi_and_version);	\
}

#ifdef __cplusplus
}
#endif

#endif /* _SYS_UUID_H */
                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/vdev.h                                                              0100644 0000000 0000000 00000013217 13045171016 015642  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef _SYS_VDEV_H
#define	_SYS_VDEV_H

#include <sys/spa.h>
#include <sys/zio.h>
#include <sys/dmu.h>
#include <sys/space_map.h>
#include <sys/fs/zfs.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef enum vdev_dtl_type {
	DTL_MISSING,	/* 0% replication: no copies of the data */
	DTL_PARTIAL,	/* less than 100% replication: some copies missing */
	DTL_SCRUB,	/* unable to fully repair during scrub/resilver */
	DTL_OUTAGE,	/* temporarily missing (used to attempt detach) */
	DTL_TYPES
} vdev_dtl_type_t;

extern int zfs_nocacheflush;

extern int vdev_open(vdev_t *);
extern void vdev_open_children(vdev_t *);
extern int vdev_validate(vdev_t *, boolean_t);
extern void vdev_close(vdev_t *);
extern int vdev_create(vdev_t *, uint64_t txg, boolean_t isreplace);
extern void vdev_reopen(vdev_t *);
extern int vdev_validate_aux(vdev_t *vd);
extern zio_t *vdev_probe(vdev_t *vd, zio_t *pio);

extern boolean_t vdev_is_bootable(vdev_t *vd);
extern vdev_t *vdev_lookup_top(spa_t *spa, uint64_t vdev);
extern vdev_t *vdev_lookup_by_guid(vdev_t *vd, uint64_t guid);
extern int vdev_count_leaves(spa_t *spa);
extern void vdev_dtl_dirty(vdev_t *vd, vdev_dtl_type_t d,
    uint64_t txg, uint64_t size);
extern boolean_t vdev_dtl_contains(vdev_t *vd, vdev_dtl_type_t d,
    uint64_t txg, uint64_t size);
extern boolean_t vdev_dtl_empty(vdev_t *vd, vdev_dtl_type_t d);
extern void vdev_dtl_reassess(vdev_t *vd, uint64_t txg, uint64_t scrub_txg,
    int scrub_done);
extern boolean_t vdev_dtl_required(vdev_t *vd);
extern boolean_t vdev_resilver_needed(vdev_t *vd,
    uint64_t *minp, uint64_t *maxp);

extern void vdev_hold(vdev_t *);
extern void vdev_rele(vdev_t *);

extern int vdev_metaslab_init(vdev_t *vd, uint64_t txg);
extern void vdev_metaslab_fini(vdev_t *vd);
extern void vdev_metaslab_set_size(vdev_t *);
extern void vdev_expand(vdev_t *vd, uint64_t txg);
extern void vdev_split(vdev_t *vd);
extern void vdev_deadman(vdev_t *vd);


extern void vdev_get_stats(vdev_t *vd, vdev_stat_t *vs);
extern void vdev_clear_stats(vdev_t *vd);
extern void vdev_stat_update(zio_t *zio, uint64_t psize);
extern void vdev_scan_stat_init(vdev_t *vd);
extern void vdev_propagate_state(vdev_t *vd);
extern void vdev_set_state(vdev_t *vd, boolean_t isopen, vdev_state_t state,
    vdev_aux_t aux);

extern void vdev_space_update(vdev_t *vd,
    int64_t alloc_delta, int64_t defer_delta, int64_t space_delta);

extern uint64_t vdev_psize_to_asize(vdev_t *vd, uint64_t psize);

extern int vdev_fault(spa_t *spa, uint64_t guid, vdev_aux_t aux);
extern int vdev_degrade(spa_t *spa, uint64_t guid, vdev_aux_t aux);
extern int vdev_online(spa_t *spa, uint64_t guid, uint64_t flags,
    vdev_state_t *);
extern int vdev_offline(spa_t *spa, uint64_t guid, uint64_t flags);
extern void vdev_clear(spa_t *spa, vdev_t *vd);

extern boolean_t vdev_is_dead(vdev_t *vd);
extern boolean_t vdev_readable(vdev_t *vd);
extern boolean_t vdev_writeable(vdev_t *vd);
extern boolean_t vdev_allocatable(vdev_t *vd);
extern boolean_t vdev_accessible(vdev_t *vd, zio_t *zio);

extern void vdev_cache_init(vdev_t *vd);
extern void vdev_cache_fini(vdev_t *vd);
extern boolean_t vdev_cache_read(zio_t *zio);
extern void vdev_cache_write(zio_t *zio);
extern void vdev_cache_purge(vdev_t *vd);

extern void vdev_queue_init(vdev_t *vd);
extern void vdev_queue_fini(vdev_t *vd);
extern zio_t *vdev_queue_io(zio_t *zio);
extern void vdev_queue_io_done(zio_t *zio);

extern void vdev_config_dirty(vdev_t *vd);
extern void vdev_config_clean(vdev_t *vd);
extern int vdev_config_sync(vdev_t **svd, int svdcount, uint64_t txg,
    boolean_t);

extern void vdev_state_dirty(vdev_t *vd);
extern void vdev_state_clean(vdev_t *vd);

typedef enum vdev_config_flag {
	VDEV_CONFIG_SPARE = 1 << 0,
	VDEV_CONFIG_L2CACHE = 1 << 1,
	VDEV_CONFIG_REMOVING = 1 << 2
} vdev_config_flag_t;

extern void vdev_top_config_generate(spa_t *spa, nvlist_t *config);
extern nvlist_t *vdev_config_generate(spa_t *spa, vdev_t *vd,
    boolean_t getstats, vdev_config_flag_t flags);

/*
 * Label routines
 */
struct uberblock;
extern uint64_t vdev_label_offset(uint64_t psize, int l, uint64_t offset);
extern int vdev_label_number(uint64_t psise, uint64_t offset);
extern nvlist_t *vdev_label_read_config(vdev_t *vd, uint64_t txg);
extern void vdev_uberblock_load(vdev_t *, struct uberblock *, nvlist_t **);

typedef enum {
	VDEV_LABEL_CREATE,	/* create/add a new device */
	VDEV_LABEL_REPLACE,	/* replace an existing device */
	VDEV_LABEL_SPARE,	/* add a new hot spare */
	VDEV_LABEL_REMOVE,	/* remove an existing device */
	VDEV_LABEL_L2CACHE,	/* add an L2ARC cache device */
	VDEV_LABEL_SPLIT	/* generating new label for split-off dev */
} vdev_labeltype_t;

extern int vdev_label_init(vdev_t *vd, uint64_t txg, vdev_labeltype_t reason);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_VDEV_H */
                                                                                                                                                                                                                                                                                                                                                                                 usr/src/zfs-0.6.5.9/include/sys/vdev_disk.h                                                         0100644 0000000 0000000 00000002427 13045171016 016655  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (C) 2008-2010 Lawrence Livermore National Security, LLC.
 * Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
 * Written by Brian Behlendorf <behlendorf1@llnl.gov>.
 * LLNL-CODE-403049.
 */

#ifndef _SYS_VDEV_DISK_H
#define	_SYS_VDEV_DISK_H

#ifdef _KERNEL
#include <sys/vdev.h>

typedef struct vdev_disk {
	ddi_devid_t		vd_devid;
	char			*vd_minor;
	struct block_device	*vd_bdev;
} vdev_disk_t;

#endif /* _KERNEL */
#endif /* _SYS_VDEV_DISK_H */
                                                                                                                                                                                                                                         usr/src/zfs-0.6.5.9/include/sys/vdev_file.h                                                         0100644 0000000 0000000 00000002242 13045171016 016635  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef _SYS_VDEV_FILE_H
#define	_SYS_VDEV_FILE_H

#include <sys/vdev.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef struct vdev_file {
	vnode_t		*vf_vnode;
} vdev_file_t;

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_VDEV_FILE_H */
                                                                                                                                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/include/sys/vdev_impl.h                                                         0100644 0000000 0000000 00000027305 13045171016 016666  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2011, 2015 by Delphix. All rights reserved.
 */

#ifndef _SYS_VDEV_IMPL_H
#define	_SYS_VDEV_IMPL_H

#include <sys/avl.h>
#include <sys/dmu.h>
#include <sys/metaslab.h>
#include <sys/nvpair.h>
#include <sys/space_map.h>
#include <sys/vdev.h>
#include <sys/dkio.h>
#include <sys/uberblock_impl.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * Virtual device descriptors.
 *
 * All storage pool operations go through the virtual device framework,
 * which provides data replication and I/O scheduling.
 */

/*
 * Forward declarations that lots of things need.
 */
typedef struct vdev_queue vdev_queue_t;
typedef struct vdev_cache vdev_cache_t;
typedef struct vdev_cache_entry vdev_cache_entry_t;

/*
 * Virtual device operations
 */
typedef int	vdev_open_func_t(vdev_t *vd, uint64_t *size, uint64_t *max_size,
    uint64_t *ashift);
typedef void	vdev_close_func_t(vdev_t *vd);
typedef uint64_t vdev_asize_func_t(vdev_t *vd, uint64_t psize);
typedef void	vdev_io_start_func_t(zio_t *zio);
typedef void	vdev_io_done_func_t(zio_t *zio);
typedef void	vdev_state_change_func_t(vdev_t *vd, int, int);
typedef void	vdev_hold_func_t(vdev_t *vd);
typedef void	vdev_rele_func_t(vdev_t *vd);

typedef const struct vdev_ops {
	vdev_open_func_t		*vdev_op_open;
	vdev_close_func_t		*vdev_op_close;
	vdev_asize_func_t		*vdev_op_asize;
	vdev_io_start_func_t		*vdev_op_io_start;
	vdev_io_done_func_t		*vdev_op_io_done;
	vdev_state_change_func_t	*vdev_op_state_change;
	vdev_hold_func_t		*vdev_op_hold;
	vdev_rele_func_t		*vdev_op_rele;
	char				vdev_op_type[16];
	boolean_t			vdev_op_leaf;
} vdev_ops_t;

/*
 * Virtual device properties
 */
struct vdev_cache_entry {
	char		*ve_data;
	uint64_t	ve_offset;
	clock_t		ve_lastused;
	avl_node_t	ve_offset_node;
	avl_node_t	ve_lastused_node;
	uint32_t	ve_hits;
	uint16_t	ve_missed_update;
	zio_t		*ve_fill_io;
};

struct vdev_cache {
	avl_tree_t	vc_offset_tree;
	avl_tree_t	vc_lastused_tree;
	kmutex_t	vc_lock;
};

typedef struct vdev_queue_class {
	uint32_t	vqc_active;

	/*
	 * Sorted by offset or timestamp, depending on if the queue is
	 * LBA-ordered vs FIFO.
	 */
	avl_tree_t	vqc_queued_tree;
} vdev_queue_class_t;

struct vdev_queue {
	vdev_t		*vq_vdev;
	vdev_queue_class_t vq_class[ZIO_PRIORITY_NUM_QUEUEABLE];
	avl_tree_t	vq_active_tree;
	avl_tree_t	vq_read_offset_tree;
	avl_tree_t	vq_write_offset_tree;
	uint64_t	vq_last_offset;
	hrtime_t	vq_io_complete_ts; /* time last i/o completed */
	hrtime_t	vq_io_delta_ts;
	zio_t		vq_io_search; /* used as local for stack reduction */
	kmutex_t	vq_lock;
};

/*
 * Virtual device descriptor
 */
struct vdev {
	/*
	 * Common to all vdev types.
	 */
	uint64_t	vdev_id;	/* child number in vdev parent	*/
	uint64_t	vdev_guid;	/* unique ID for this vdev	*/
	uint64_t	vdev_guid_sum;	/* self guid + all child guids	*/
	uint64_t	vdev_orig_guid;	/* orig. guid prior to remove	*/
	uint64_t	vdev_asize;	/* allocatable device capacity	*/
	uint64_t	vdev_min_asize;	/* min acceptable asize		*/
	uint64_t	vdev_max_asize;	/* max acceptable asize		*/
	uint64_t	vdev_ashift;	/* block alignment shift	*/
	uint64_t	vdev_state;	/* see VDEV_STATE_* #defines	*/
	uint64_t	vdev_prevstate;	/* used when reopening a vdev	*/
	vdev_ops_t	*vdev_ops;	/* vdev operations		*/
	spa_t		*vdev_spa;	/* spa for this vdev		*/
	void		*vdev_tsd;	/* type-specific data		*/
	vnode_t		*vdev_name_vp;	/* vnode for pathname		*/
	vnode_t		*vdev_devid_vp;	/* vnode for devid		*/
	vdev_t		*vdev_top;	/* top-level vdev		*/
	vdev_t		*vdev_parent;	/* parent vdev			*/
	vdev_t		**vdev_child;	/* array of children		*/
	uint64_t	vdev_children;	/* number of children		*/
	vdev_stat_t	vdev_stat;	/* virtual device statistics	*/
	boolean_t	vdev_expanding;	/* expand the vdev?		*/
	boolean_t	vdev_reopening;	/* reopen in progress?		*/
	boolean_t	vdev_nonrot;	/* true if solid state		*/
	int		vdev_open_error; /* error on last open		*/
	kthread_t	*vdev_open_thread; /* thread opening children	*/
	uint64_t	vdev_crtxg;	/* txg when top-level was added */

	/*
	 * Top-level vdev state.
	 */
	uint64_t	vdev_ms_array;	/* metaslab array object	*/
	uint64_t	vdev_ms_shift;	/* metaslab size shift		*/
	uint64_t	vdev_ms_count;	/* number of metaslabs		*/
	metaslab_group_t *vdev_mg;	/* metaslab group		*/
	metaslab_t	**vdev_ms;	/* metaslab array		*/
	uint64_t	vdev_pending_fastwrite; /* allocated fastwrites */
	txg_list_t	vdev_ms_list;	/* per-txg dirty metaslab lists	*/
	txg_list_t	vdev_dtl_list;	/* per-txg dirty DTL lists	*/
	txg_node_t	vdev_txg_node;	/* per-txg dirty vdev linkage	*/
	boolean_t	vdev_remove_wanted; /* async remove wanted?	*/
	boolean_t	vdev_probe_wanted; /* async probe wanted?	*/
	list_node_t	vdev_config_dirty_node; /* config dirty list	*/
	list_node_t	vdev_state_dirty_node; /* state dirty list	*/
	uint64_t	vdev_deflate_ratio; /* deflation ratio (x512)	*/
	uint64_t	vdev_islog;	/* is an intent log device	*/
	uint64_t	vdev_removing;	/* device is being removed?	*/
	boolean_t	vdev_ishole;	/* is a hole in the namespace 	*/

	/*
	 * Leaf vdev state.
	 */
	range_tree_t	*vdev_dtl[DTL_TYPES]; /* dirty time logs	*/
	space_map_t	*vdev_dtl_sm;	/* dirty time log space map	*/
	txg_node_t	vdev_dtl_node;	/* per-txg dirty DTL linkage	*/
	uint64_t	vdev_dtl_object; /* DTL object			*/
	uint64_t	vdev_psize;	/* physical device capacity	*/
	uint64_t	vdev_wholedisk;	/* true if this is a whole disk */
	uint64_t	vdev_offline;	/* persistent offline state	*/
	uint64_t	vdev_faulted;	/* persistent faulted state	*/
	uint64_t	vdev_degraded;	/* persistent degraded state	*/
	uint64_t	vdev_removed;	/* persistent removed state	*/
	uint64_t	vdev_resilver_txg; /* persistent resilvering state */
	uint64_t	vdev_nparity;	/* number of parity devices for raidz */
	char		*vdev_path;	/* vdev path (if any)		*/
	char		*vdev_devid;	/* vdev devid (if any)		*/
	char		*vdev_physpath;	/* vdev device path (if any)	*/
	char		*vdev_fru;	/* physical FRU location	*/
	uint64_t	vdev_not_present; /* not present during import	*/
	uint64_t	vdev_unspare;	/* unspare when resilvering done */
	boolean_t	vdev_nowritecache; /* true if flushwritecache failed */
	boolean_t	vdev_checkremove; /* temporary online test	*/
	boolean_t	vdev_forcefault; /* force online fault		*/
	boolean_t	vdev_splitting;	/* split or repair in progress  */
	boolean_t	vdev_delayed_close; /* delayed device close?	*/
	boolean_t	vdev_tmpoffline; /* device taken offline temporarily? */
	boolean_t	vdev_detached;	/* device detached?		*/
	boolean_t	vdev_cant_read;	/* vdev is failing all reads	*/
	boolean_t	vdev_cant_write; /* vdev is failing all writes	*/
	boolean_t	vdev_isspare;	/* was a hot spare		*/
	boolean_t	vdev_isl2cache;	/* was a l2cache device		*/
	vdev_queue_t	vdev_queue;	/* I/O deadline schedule queue	*/
	vdev_cache_t	vdev_cache;	/* physical block cache		*/
	spa_aux_vdev_t	*vdev_aux;	/* for l2cache and spares vdevs	*/
	zio_t		*vdev_probe_zio; /* root of current probe	*/
	vdev_aux_t	vdev_label_aux;	/* on-disk aux state		*/

	/*
	 * For DTrace to work in userland (libzpool) context, these fields must
	 * remain at the end of the structure.  DTrace will use the kernel's
	 * CTF definition for 'struct vdev', and since the size of a kmutex_t is
	 * larger in userland, the offsets for the rest of the fields would be
	 * incorrect.
	 */
	kmutex_t	vdev_dtl_lock;	/* vdev_dtl_{map,resilver}	*/
	kmutex_t	vdev_stat_lock;	/* vdev_stat			*/
	kmutex_t	vdev_probe_lock; /* protects vdev_probe_zio	*/
};

#define	VDEV_RAIDZ_MAXPARITY	3

#define	VDEV_PAD_SIZE		(8 << 10)
/* 2 padding areas (vl_pad1 and vl_pad2) to skip */
#define	VDEV_SKIP_SIZE		VDEV_PAD_SIZE * 2
#define	VDEV_PHYS_SIZE		(112 << 10)
#define	VDEV_UBERBLOCK_RING	(128 << 10)

/* The largest uberblock we support is 8k. */
#define	MAX_UBERBLOCK_SHIFT (13)
#define	VDEV_UBERBLOCK_SHIFT(vd)	\
	MIN(MAX((vd)->vdev_top->vdev_ashift, UBERBLOCK_SHIFT), \
	    MAX_UBERBLOCK_SHIFT)
#define	VDEV_UBERBLOCK_COUNT(vd)	\
	(VDEV_UBERBLOCK_RING >> VDEV_UBERBLOCK_SHIFT(vd))
#define	VDEV_UBERBLOCK_OFFSET(vd, n)	\
	offsetof(vdev_label_t, vl_uberblock[(n) << VDEV_UBERBLOCK_SHIFT(vd)])
#define	VDEV_UBERBLOCK_SIZE(vd)		(1ULL << VDEV_UBERBLOCK_SHIFT(vd))

typedef struct vdev_phys {
	char		vp_nvlist[VDEV_PHYS_SIZE - sizeof (zio_eck_t)];
	zio_eck_t	vp_zbt;
} vdev_phys_t;

typedef struct vdev_label {
	char		vl_pad1[VDEV_PAD_SIZE];			/*  8K */
	char		vl_pad2[VDEV_PAD_SIZE];			/*  8K */
	vdev_phys_t	vl_vdev_phys;				/* 112K	*/
	char		vl_uberblock[VDEV_UBERBLOCK_RING];	/* 128K	*/
} vdev_label_t;							/* 256K total */

/*
 * vdev_dirty() flags
 */
#define	VDD_METASLAB	0x01
#define	VDD_DTL		0x02

/* Offset of embedded boot loader region on each label */
#define	VDEV_BOOT_OFFSET	(2 * sizeof (vdev_label_t))
/*
 * Size of embedded boot loader region on each label.
 * The total size of the first two labels plus the boot area is 4MB.
 */
#define	VDEV_BOOT_SIZE		(7ULL << 19)			/* 3.5M */

/*
 * Size of label regions at the start and end of each leaf device.
 */
#define	VDEV_LABEL_START_SIZE	(2 * sizeof (vdev_label_t) + VDEV_BOOT_SIZE)
#define	VDEV_LABEL_END_SIZE	(2 * sizeof (vdev_label_t))
#define	VDEV_LABELS		4
#define	VDEV_BEST_LABEL		VDEV_LABELS

#define	VDEV_ALLOC_LOAD		0
#define	VDEV_ALLOC_ADD		1
#define	VDEV_ALLOC_SPARE	2
#define	VDEV_ALLOC_L2CACHE	3
#define	VDEV_ALLOC_ROOTPOOL	4
#define	VDEV_ALLOC_SPLIT	5
#define	VDEV_ALLOC_ATTACH	6

/*
 * Allocate or free a vdev
 */
extern vdev_t *vdev_alloc_common(spa_t *spa, uint_t id, uint64_t guid,
    vdev_ops_t *ops);
extern int vdev_alloc(spa_t *spa, vdev_t **vdp, nvlist_t *config,
    vdev_t *parent, uint_t id, int alloctype);
extern void vdev_free(vdev_t *vd);

/*
 * Add or remove children and parents
 */
extern void vdev_add_child(vdev_t *pvd, vdev_t *cvd);
extern void vdev_remove_child(vdev_t *pvd, vdev_t *cvd);
extern void vdev_compact_children(vdev_t *pvd);
extern vdev_t *vdev_add_parent(vdev_t *cvd, vdev_ops_t *ops);
extern void vdev_remove_parent(vdev_t *cvd);

/*
 * vdev sync load and sync
 */
extern void vdev_load_log_state(vdev_t *nvd, vdev_t *ovd);
extern boolean_t vdev_log_state_valid(vdev_t *vd);
extern void vdev_load(vdev_t *vd);
extern int vdev_dtl_load(vdev_t *vd);
extern void vdev_sync(vdev_t *vd, uint64_t txg);
extern void vdev_sync_done(vdev_t *vd, uint64_t txg);
extern void vdev_dirty(vdev_t *vd, int flags, void *arg, uint64_t txg);
extern void vdev_dirty_leaves(vdev_t *vd, int flags, uint64_t txg);

/*
 * Available vdev types.
 */
extern vdev_ops_t vdev_root_ops;
extern vdev_ops_t vdev_mirror_ops;
extern vdev_ops_t vdev_replacing_ops;
extern vdev_ops_t vdev_raidz_ops;
extern vdev_ops_t vdev_disk_ops;
extern vdev_ops_t vdev_file_ops;
extern vdev_ops_t vdev_missing_ops;
extern vdev_ops_t vdev_hole_ops;
extern vdev_ops_t vdev_spare_ops;

/*
 * Common size functions
 */
extern uint64_t vdev_default_asize(vdev_t *vd, uint64_t psize);
extern uint64_t vdev_get_min_asize(vdev_t *vd);
extern void vdev_set_min_asize(vdev_t *vd);

/*
 * Global variables
 */
/* zdb uses this tunable, so it must be declared here to make lint happy. */
extern int zfs_vdev_cache_size;

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_VDEV_IMPL_H */
                                                                                                                                                                                                                                                                                                                           usr/src/zfs-0.6.5.9/include/sys/xvattr.h                                                            0100644 0000000 0000000 00000031367 13045171016 016234  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
 */

/*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*
 * University Copyright- Copyright (c) 1982, 1986, 1988
 * The Regents of the University of California
 * All Rights Reserved
 *
 * University Acknowledgment- Portions of this document are derived from
 * software developed by the University of California, Berkeley, and its
 * contributors.
 */

#ifndef _SYS_XVATTR_H
#define	_SYS_XVATTR_H

#include <sys/vnode.h>

#define	AV_SCANSTAMP_SZ	32		/* length of anti-virus scanstamp */

/*
 * Structure of all optional attributes.
 */
typedef struct xoptattr {
	timestruc_t	xoa_createtime;	/* Create time of file */
	uint8_t		xoa_archive;
	uint8_t		xoa_system;
	uint8_t		xoa_readonly;
	uint8_t		xoa_hidden;
	uint8_t		xoa_nounlink;
	uint8_t		xoa_immutable;
	uint8_t		xoa_appendonly;
	uint8_t		xoa_nodump;
	uint8_t		xoa_opaque;
	uint8_t		xoa_av_quarantined;
	uint8_t		xoa_av_modified;
	uint8_t		xoa_av_scanstamp[AV_SCANSTAMP_SZ];
	uint8_t		xoa_reparse;
	uint64_t	xoa_generation;
	uint8_t		xoa_offline;
	uint8_t		xoa_sparse;
} xoptattr_t;

/*
 * The xvattr structure is really a variable length structure that
 * is made up of:
 * - The classic vattr_t (xva_vattr)
 * - a 32 bit quantity (xva_mapsize) that specifies the size of the
 *   attribute bitmaps in 32 bit words.
 * - A pointer to the returned attribute bitmap (needed because the
 *   previous element, the requested attribute bitmap) is variable lenth.
 * - The requested attribute bitmap, which is an array of 32 bit words.
 *   Callers use the XVA_SET_REQ() macro to set the bits corresponding to
 *   the attributes that are being requested.
 * - The returned attribute bitmap, which is an array of 32 bit words.
 *   File systems that support optional attributes use the XVA_SET_RTN()
 *   macro to set the bits corresponding to the attributes that are being
 *   returned.
 * - The xoptattr_t structure which contains the attribute values
 *
 * xva_mapsize determines how many words in the attribute bitmaps.
 * Immediately following the attribute bitmaps is the xoptattr_t.
 * xva_getxoptattr() is used to get the pointer to the xoptattr_t
 * section.
 */

#define	XVA_MAPSIZE	3		/* Size of attr bitmaps */
#define	XVA_MAGIC	0x78766174	/* Magic # for verification */

/*
 * The xvattr structure is an extensible structure which permits optional
 * attributes to be requested/returned.  File systems may or may not support
 * optional attributes.  They do so at their own discretion but if they do
 * support optional attributes, they must register the VFSFT_XVATTR feature
 * so that the optional attributes can be set/retrived.
 *
 * The fields of the xvattr structure are:
 *
 * xva_vattr - The first element of an xvattr is a legacy vattr structure
 * which includes the common attributes.  If AT_XVATTR is set in the va_mask
 * then the entire structure is treated as an xvattr.  If AT_XVATTR is not
 * set, then only the xva_vattr structure can be used.
 *
 * xva_magic - 0x78766174 (hex for "xvat"). Magic number for verification.
 *
 * xva_mapsize - Size of requested and returned attribute bitmaps.
 *
 * xva_rtnattrmapp - Pointer to xva_rtnattrmap[].  We need this since the
 * size of the array before it, xva_reqattrmap[], could change which means
 * the location of xva_rtnattrmap[] could change.  This will allow unbundled
 * file systems to find the location of xva_rtnattrmap[] when the sizes change.
 *
 * xva_reqattrmap[] - Array of requested attributes.  Attributes are
 * represented by a specific bit in a specific element of the attribute
 * map array.  Callers set the bits corresponding to the attributes
 * that the caller wants to get/set.
 *
 * xva_rtnattrmap[] - Array of attributes that the file system was able to
 * process.  Not all file systems support all optional attributes.  This map
 * informs the caller which attributes the underlying file system was able
 * to set/get.  (Same structure as the requested attributes array in terms
 * of each attribute  corresponding to specific bits and array elements.)
 *
 * xva_xoptattrs - Structure containing values of optional attributes.
 * These values are only valid if the corresponding bits in xva_reqattrmap
 * are set and the underlying file system supports those attributes.
 */
typedef struct xvattr {
	vattr_t		xva_vattr;	/* Embedded vattr structure */
	uint32_t	xva_magic;	/* Magic Number */
	uint32_t	xva_mapsize;	/* Size of attr bitmap (32-bit words) */
	uint32_t	*xva_rtnattrmapp;	/* Ptr to xva_rtnattrmap[] */
	uint32_t	xva_reqattrmap[XVA_MAPSIZE];	/* Requested attrs */
	uint32_t	xva_rtnattrmap[XVA_MAPSIZE];	/* Returned attrs */
	xoptattr_t	xva_xoptattrs;	/* Optional attributes */
} xvattr_t;

/*
 * Attribute bits used in the extensible attribute's (xva's) attribute
 * bitmaps.  Note that the bitmaps are made up of a variable length number
 * of 32-bit words.  The convention is to use XAT{n}_{attrname} where "n"
 * is the element in the bitmap (starting at 1).  This convention is for
 * the convenience of the maintainer to keep track of which element each
 * attribute belongs to.
 *
 * NOTE THAT CONSUMERS MUST *NOT* USE THE XATn_* DEFINES DIRECTLY.  CONSUMERS
 * MUST USE THE XAT_* DEFINES.
 */
#define	XAT0_INDEX	0LL		/* Index into bitmap for XAT0 attrs */
#define	XAT0_CREATETIME	0x00000001	/* Create time of file */
#define	XAT0_ARCHIVE	0x00000002	/* Archive */
#define	XAT0_SYSTEM	0x00000004	/* System */
#define	XAT0_READONLY	0x00000008	/* Readonly */
#define	XAT0_HIDDEN	0x00000010	/* Hidden */
#define	XAT0_NOUNLINK	0x00000020	/* Nounlink */
#define	XAT0_IMMUTABLE	0x00000040	/* immutable */
#define	XAT0_APPENDONLY	0x00000080	/* appendonly */
#define	XAT0_NODUMP	0x00000100	/* nodump */
#define	XAT0_OPAQUE	0x00000200	/* opaque */
#define	XAT0_AV_QUARANTINED	0x00000400	/* anti-virus quarantine */
#define	XAT0_AV_MODIFIED	0x00000800	/* anti-virus modified */
#define	XAT0_AV_SCANSTAMP	0x00001000	/* anti-virus scanstamp */
#define	XAT0_REPARSE	0x00002000	/* FS reparse point */
#define	XAT0_GEN	0x00004000	/* object generation number */
#define	XAT0_OFFLINE	0x00008000	/* offline */
#define	XAT0_SPARSE	0x00010000	/* sparse */

#define	XAT0_ALL_ATTRS	(XAT0_CREATETIME|XAT0_ARCHIVE|XAT0_SYSTEM| \
    XAT0_READONLY|XAT0_HIDDEN|XAT0_NOUNLINK|XAT0_IMMUTABLE|XAT0_APPENDONLY| \
    XAT0_NODUMP|XAT0_OPAQUE|XAT0_AV_QUARANTINED|  XAT0_AV_MODIFIED| \
    XAT0_AV_SCANSTAMP|XAT0_REPARSE|XATO_GEN|XAT0_OFFLINE|XAT0_SPARSE)

/* Support for XAT_* optional attributes */
#define	XVA_MASK		0xffffffff	/* Used to mask off 32 bits */
#define	XVA_SHFT		32		/* Used to shift index */

/*
 * Used to pry out the index and attribute bits from the XAT_* attributes
 * defined below.  Note that we're masking things down to 32 bits then
 * casting to uint32_t.
 */
#define	XVA_INDEX(attr)		((uint32_t)(((attr) >> XVA_SHFT) & XVA_MASK))
#define	XVA_ATTRBIT(attr)	((uint32_t)((attr) & XVA_MASK))

/*
 * The following defines present a "flat namespace" so that consumers don't
 * need to keep track of which element belongs to which bitmap entry.
 *
 * NOTE THAT THESE MUST NEVER BE OR-ed TOGETHER
 */
#define	XAT_CREATETIME		((XAT0_INDEX << XVA_SHFT) | XAT0_CREATETIME)
#define	XAT_ARCHIVE		((XAT0_INDEX << XVA_SHFT) | XAT0_ARCHIVE)
#define	XAT_SYSTEM		((XAT0_INDEX << XVA_SHFT) | XAT0_SYSTEM)
#define	XAT_READONLY		((XAT0_INDEX << XVA_SHFT) | XAT0_READONLY)
#define	XAT_HIDDEN		((XAT0_INDEX << XVA_SHFT) | XAT0_HIDDEN)
#define	XAT_NOUNLINK		((XAT0_INDEX << XVA_SHFT) | XAT0_NOUNLINK)
#define	XAT_IMMUTABLE		((XAT0_INDEX << XVA_SHFT) | XAT0_IMMUTABLE)
#define	XAT_APPENDONLY		((XAT0_INDEX << XVA_SHFT) | XAT0_APPENDONLY)
#define	XAT_NODUMP		((XAT0_INDEX << XVA_SHFT) | XAT0_NODUMP)
#define	XAT_OPAQUE		((XAT0_INDEX << XVA_SHFT) | XAT0_OPAQUE)
#define	XAT_AV_QUARANTINED	((XAT0_INDEX << XVA_SHFT) | XAT0_AV_QUARANTINED)
#define	XAT_AV_MODIFIED		((XAT0_INDEX << XVA_SHFT) | XAT0_AV_MODIFIED)
#define	XAT_AV_SCANSTAMP	((XAT0_INDEX << XVA_SHFT) | XAT0_AV_SCANSTAMP)
#define	XAT_REPARSE		((XAT0_INDEX << XVA_SHFT) | XAT0_REPARSE)
#define	XAT_GEN			((XAT0_INDEX << XVA_SHFT) | XAT0_GEN)
#define	XAT_OFFLINE		((XAT0_INDEX << XVA_SHFT) | XAT0_OFFLINE)
#define	XAT_SPARSE		((XAT0_INDEX << XVA_SHFT) | XAT0_SPARSE)

/*
 * The returned attribute map array (xva_rtnattrmap[]) is located past the
 * requested attribute map array (xva_reqattrmap[]).  Its location changes
 * when the array sizes change.  We use a separate pointer in a known location
 * (xva_rtnattrmapp) to hold the location of xva_rtnattrmap[].  This is
 * set in xva_init()
 */
#define	XVA_RTNATTRMAP(xvap)	((xvap)->xva_rtnattrmapp)

/*
 * XVA_SET_REQ() sets an attribute bit in the proper element in the bitmap
 * of requested attributes (xva_reqattrmap[]).
 */
#define	XVA_SET_REQ(xvap, attr)					\
	ASSERT((xvap)->xva_vattr.va_mask & AT_XVATTR);		\
	ASSERT((xvap)->xva_magic == XVA_MAGIC);			\
	(xvap)->xva_reqattrmap[XVA_INDEX(attr)] |= XVA_ATTRBIT(attr)
/*
 * XVA_CLR_REQ() clears an attribute bit in the proper element in the bitmap
 * of requested attributes (xva_reqattrmap[]).
 */
#define	XVA_CLR_REQ(xvap, attr)					\
	ASSERT((xvap)->xva_vattr.va_mask & AT_XVATTR);		\
	ASSERT((xvap)->xva_magic == XVA_MAGIC);			\
	(xvap)->xva_reqattrmap[XVA_INDEX(attr)] &= ~XVA_ATTRBIT(attr)

/*
 * XVA_SET_RTN() sets an attribute bit in the proper element in the bitmap
 * of returned attributes (xva_rtnattrmap[]).
 */
#define	XVA_SET_RTN(xvap, attr)					\
	ASSERT((xvap)->xva_vattr.va_mask & AT_XVATTR);		\
	ASSERT((xvap)->xva_magic == XVA_MAGIC);			\
	(XVA_RTNATTRMAP(xvap))[XVA_INDEX(attr)] |= XVA_ATTRBIT(attr)

/*
 * XVA_ISSET_REQ() checks the requested attribute bitmap (xva_reqattrmap[])
 * to see of the corresponding attribute bit is set.  If so, returns non-zero.
 */
#define	XVA_ISSET_REQ(xvap, attr)					\
	((((xvap)->xva_vattr.va_mask & AT_XVATTR) &&			\
		((xvap)->xva_magic == XVA_MAGIC) &&			\
		((xvap)->xva_mapsize > XVA_INDEX(attr))) ?		\
	((xvap)->xva_reqattrmap[XVA_INDEX(attr)] & XVA_ATTRBIT(attr)) :	0)

/*
 * XVA_ISSET_RTN() checks the returned attribute bitmap (xva_rtnattrmap[])
 * to see of the corresponding attribute bit is set.  If so, returns non-zero.
 */
#define	XVA_ISSET_RTN(xvap, attr)					\
	((((xvap)->xva_vattr.va_mask & AT_XVATTR) &&			\
		((xvap)->xva_magic == XVA_MAGIC) &&			\
		((xvap)->xva_mapsize > XVA_INDEX(attr))) ?		\
	((XVA_RTNATTRMAP(xvap))[XVA_INDEX(attr)] & XVA_ATTRBIT(attr)) : 0)

/*
 * Zero out the structure, set the size of the requested/returned bitmaps,
 * set AT_XVATTR in the embedded vattr_t's va_mask, and set up the pointer
 * to the returned attributes array.
 */
static inline void
xva_init(xvattr_t *xvap)
{
	bzero(xvap, sizeof (xvattr_t));
	xvap->xva_mapsize = XVA_MAPSIZE;
	xvap->xva_magic = XVA_MAGIC;
	xvap->xva_vattr.va_mask = ATTR_XVATTR;
	xvap->xva_rtnattrmapp = &(xvap->xva_rtnattrmap)[0];
}

/*
 * If AT_XVATTR is set, returns a pointer to the embedded xoptattr_t
 * structure.  Otherwise, returns NULL.
 */
static inline xoptattr_t *
xva_getxoptattr(xvattr_t *xvap)
{
	xoptattr_t *xoap = NULL;
	if (xvap->xva_vattr.va_mask & AT_XVATTR)
			xoap = &xvap->xva_xoptattrs;
	return (xoap);
}

#define	MODEMASK	07777		/* mode bits plus permission bits */
#define	PERMMASK	00777		/* permission bits */

/*
 * VOP_ACCESS flags
 */
#define	V_ACE_MASK	0x1	/* mask represents  NFSv4 ACE permissions */
#define	V_APPEND	0x2	/* want to do append only check */

/*
 * Structure used on VOP_GETSECATTR and VOP_SETSECATTR operations
 */

typedef struct vsecattr {
	uint_t		vsa_mask;	/* See below */
	int		vsa_aclcnt;	/* ACL entry count */
	void		*vsa_aclentp;	/* pointer to ACL entries */
	int		vsa_dfaclcnt;	/* default ACL entry count */
	void		*vsa_dfaclentp;	/* pointer to default ACL entries */
	size_t		vsa_aclentsz;	/* ACE size in bytes of vsa_aclentp */
	uint_t		vsa_aclflags;	/* ACE ACL flags */
} vsecattr_t;

/* vsa_mask values */
#define	VSA_ACL			0x0001
#define	VSA_ACLCNT		0x0002
#define	VSA_DFACL		0x0004
#define	VSA_DFACLCNT		0x0008
#define	VSA_ACE			0x0010
#define	VSA_ACECNT		0x0020
#define	VSA_ACE_ALLTYPES	0x0040
#define	VSA_ACE_ACLFLAGS	0x0080	/* get/set ACE ACL flags */

#endif /* _SYS_XVATTR_H */
                                                                                                                                                                                                                                                                         usr/src/zfs-0.6.5.9/include/sys/zap.h                                                               0100644 0000000 0000000 00000042531 13045171016 015471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef	_SYS_ZAP_H
#define	_SYS_ZAP_H

/*
 * ZAP - ZFS Attribute Processor
 *
 * The ZAP is a module which sits on top of the DMU (Data Management
 * Unit) and implements a higher-level storage primitive using DMU
 * objects.  Its primary consumer is the ZPL (ZFS Posix Layer).
 *
 * A "zapobj" is a DMU object which the ZAP uses to stores attributes.
 * Users should use only zap routines to access a zapobj - they should
 * not access the DMU object directly using DMU routines.
 *
 * The attributes stored in a zapobj are name-value pairs.  The name is
 * a zero-terminated string of up to ZAP_MAXNAMELEN bytes (including
 * terminating NULL).  The value is an array of integers, which may be
 * 1, 2, 4, or 8 bytes long.  The total space used by the array (number
 * of integers * integer length) can be up to ZAP_MAXVALUELEN bytes.
 * Note that an 8-byte integer value can be used to store the location
 * (object number) of another dmu object (which may be itself a zapobj).
 * Note that you can use a zero-length attribute to store a single bit
 * of information - the attribute is present or not.
 *
 * The ZAP routines are thread-safe.  However, you must observe the
 * DMU's restriction that a transaction may not be operated on
 * concurrently.
 *
 * Any of the routines that return an int may return an I/O error (EIO
 * or ECHECKSUM).
 *
 *
 * Implementation / Performance Notes:
 *
 * The ZAP is intended to operate most efficiently on attributes with
 * short (49 bytes or less) names and single 8-byte values, for which
 * the microzap will be used.  The ZAP should be efficient enough so
 * that the user does not need to cache these attributes.
 *
 * The ZAP's locking scheme makes its routines thread-safe.  Operations
 * on different zapobjs will be processed concurrently.  Operations on
 * the same zapobj which only read data will be processed concurrently.
 * Operations on the same zapobj which modify data will be processed
 * concurrently when there are many attributes in the zapobj (because
 * the ZAP uses per-block locking - more than 128 * (number of cpus)
 * small attributes will suffice).
 */

/*
 * We're using zero-terminated byte strings (ie. ASCII or UTF-8 C
 * strings) for the names of attributes, rather than a byte string
 * bounded by an explicit length.  If some day we want to support names
 * in character sets which have embedded zeros (eg. UTF-16, UTF-32),
 * we'll have to add routines for using length-bounded strings.
 */

#include <sys/dmu.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * Specifies matching criteria for ZAP lookups.
 */
typedef enum matchtype
{
	/* Only find an exact match (non-normalized) */
	MT_EXACT,
	/*
	 * If there is an exact match, find that, otherwise find the
	 * first normalized match.
	 */
	MT_BEST,
	/*
	 * Find the "first" normalized (case and Unicode form) match;
	 * the designated "first" match will not change as long as the
	 * set of entries with this normalization doesn't change.
	 */
	MT_FIRST
} matchtype_t;

typedef enum zap_flags {
	/* Use 64-bit hash value (serialized cursors will always use 64-bits) */
	ZAP_FLAG_HASH64 = 1 << 0,
	/* Key is binary, not string (zap_add_uint64() can be used) */
	ZAP_FLAG_UINT64_KEY = 1 << 1,
	/*
	 * First word of key (which must be an array of uint64) is
	 * already randomly distributed.
	 */
	ZAP_FLAG_PRE_HASHED_KEY = 1 << 2,
} zap_flags_t;

/*
 * Create a new zapobj with no attributes and return its object number.
 * MT_EXACT will cause the zap object to only support MT_EXACT lookups,
 * otherwise any matchtype can be used for lookups.
 *
 * normflags specifies what normalization will be done.  values are:
 * 0: no normalization (legacy on-disk format, supports MT_EXACT matching
 *     only)
 * U8_TEXTPREP_TOLOWER: case normalization will be performed.
 *     MT_FIRST/MT_BEST matching will find entries that match without
 *     regard to case (eg. looking for "foo" can find an entry "Foo").
 * Eventually, other flags will permit unicode normalization as well.
 */
uint64_t zap_create(objset_t *ds, dmu_object_type_t ot,
    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx);
uint64_t zap_create_norm(objset_t *ds, int normflags, dmu_object_type_t ot,
    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx);
uint64_t zap_create_flags(objset_t *os, int normflags, zap_flags_t flags,
    dmu_object_type_t ot, int leaf_blockshift, int indirect_blockshift,
    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx);
uint64_t zap_create_link(objset_t *os, dmu_object_type_t ot,
    uint64_t parent_obj, const char *name, dmu_tx_t *tx);

/*
 * Initialize an already-allocated object.
 */
void mzap_create_impl(objset_t *os, uint64_t obj, int normflags,
    zap_flags_t flags, dmu_tx_t *tx);

/*
 * Create a new zapobj with no attributes from the given (unallocated)
 * object number.
 */
int zap_create_claim(objset_t *ds, uint64_t obj, dmu_object_type_t ot,
    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx);
int zap_create_claim_norm(objset_t *ds, uint64_t obj,
    int normflags, dmu_object_type_t ot,
    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx);

/*
 * The zapobj passed in must be a valid ZAP object for all of the
 * following routines.
 */

/*
 * Destroy this zapobj and all its attributes.
 *
 * Frees the object number using dmu_object_free.
 */
int zap_destroy(objset_t *ds, uint64_t zapobj, dmu_tx_t *tx);

/*
 * Manipulate attributes.
 *
 * 'integer_size' is in bytes, and must be 1, 2, 4, or 8.
 */

/*
 * Retrieve the contents of the attribute with the given name.
 *
 * If the requested attribute does not exist, the call will fail and
 * return ENOENT.
 *
 * If 'integer_size' is smaller than the attribute's integer size, the
 * call will fail and return EINVAL.
 *
 * If 'integer_size' is equal to or larger than the attribute's integer
 * size, the call will succeed and return 0.
 *
 * When converting to a larger integer size, the integers will be treated as
 * unsigned (ie. no sign-extension will be performed).
 *
 * 'num_integers' is the length (in integers) of 'buf'.
 *
 * If the attribute is longer than the buffer, as many integers as will
 * fit will be transferred to 'buf'.  If the entire attribute was not
 * transferred, the call will return EOVERFLOW.
 */
int zap_lookup(objset_t *ds, uint64_t zapobj, const char *name,
    uint64_t integer_size, uint64_t num_integers, void *buf);

/*
 * If rn_len is nonzero, realname will be set to the name of the found
 * entry (which may be different from the requested name if matchtype is
 * not MT_EXACT).
 *
 * If normalization_conflictp is not NULL, it will be set if there is
 * another name with the same case/unicode normalized form.
 */
int zap_lookup_norm(objset_t *ds, uint64_t zapobj, const char *name,
    uint64_t integer_size, uint64_t num_integers, void *buf,
    matchtype_t mt, char *realname, int rn_len,
    boolean_t *normalization_conflictp);
int zap_lookup_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,
    int key_numints, uint64_t integer_size, uint64_t num_integers, void *buf);
int zap_contains(objset_t *ds, uint64_t zapobj, const char *name);
int zap_prefetch(objset_t *os, uint64_t zapobj, const char *name);
int zap_prefetch_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,
    int key_numints);

int zap_count_write(objset_t *os, uint64_t zapobj, const char *name,
    int add, uint64_t *towrite, uint64_t *tooverwrite);

/*
 * Create an attribute with the given name and value.
 *
 * If an attribute with the given name already exists, the call will
 * fail and return EEXIST.
 */
int zap_add(objset_t *ds, uint64_t zapobj, const char *key,
    int integer_size, uint64_t num_integers,
    const void *val, dmu_tx_t *tx);
int zap_add_uint64(objset_t *ds, uint64_t zapobj, const uint64_t *key,
    int key_numints, int integer_size, uint64_t num_integers,
    const void *val, dmu_tx_t *tx);

/*
 * Set the attribute with the given name to the given value.  If an
 * attribute with the given name does not exist, it will be created.  If
 * an attribute with the given name already exists, the previous value
 * will be overwritten.  The integer_size may be different from the
 * existing attribute's integer size, in which case the attribute's
 * integer size will be updated to the new value.
 */
int zap_update(objset_t *ds, uint64_t zapobj, const char *name,
    int integer_size, uint64_t num_integers, const void *val, dmu_tx_t *tx);
int zap_update_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,
    int key_numints,
    int integer_size, uint64_t num_integers, const void *val, dmu_tx_t *tx);

/*
 * Get the length (in integers) and the integer size of the specified
 * attribute.
 *
 * If the requested attribute does not exist, the call will fail and
 * return ENOENT.
 */
int zap_length(objset_t *ds, uint64_t zapobj, const char *name,
    uint64_t *integer_size, uint64_t *num_integers);
int zap_length_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,
    int key_numints, uint64_t *integer_size, uint64_t *num_integers);

/*
 * Remove the specified attribute.
 *
 * If the specified attribute does not exist, the call will fail and
 * return ENOENT.
 */
int zap_remove(objset_t *ds, uint64_t zapobj, const char *name, dmu_tx_t *tx);
int zap_remove_norm(objset_t *ds, uint64_t zapobj, const char *name,
    matchtype_t mt, dmu_tx_t *tx);
int zap_remove_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,
    int key_numints, dmu_tx_t *tx);

/*
 * Returns (in *count) the number of attributes in the specified zap
 * object.
 */
int zap_count(objset_t *ds, uint64_t zapobj, uint64_t *count);

/*
 * Returns (in name) the name of the entry whose (value & mask)
 * (za_first_integer) is value, or ENOENT if not found.  The string
 * pointed to by name must be at least 256 bytes long.  If mask==0, the
 * match must be exact (ie, same as mask=-1ULL).
 */
int zap_value_search(objset_t *os, uint64_t zapobj,
    uint64_t value, uint64_t mask, char *name);

/*
 * Transfer all the entries from fromobj into intoobj.  Only works on
 * int_size=8 num_integers=1 values.  Fails if there are any duplicated
 * entries.
 */
int zap_join(objset_t *os, uint64_t fromobj, uint64_t intoobj, dmu_tx_t *tx);

/* Same as zap_join, but set the values to 'value'. */
int zap_join_key(objset_t *os, uint64_t fromobj, uint64_t intoobj,
    uint64_t value, dmu_tx_t *tx);

/* Same as zap_join, but add together any duplicated entries. */
int zap_join_increment(objset_t *os, uint64_t fromobj, uint64_t intoobj,
    dmu_tx_t *tx);

/*
 * Manipulate entries where the name + value are the "same" (the name is
 * a stringified version of the value).
 */
int zap_add_int(objset_t *os, uint64_t obj, uint64_t value, dmu_tx_t *tx);
int zap_remove_int(objset_t *os, uint64_t obj, uint64_t value, dmu_tx_t *tx);
int zap_lookup_int(objset_t *os, uint64_t obj, uint64_t value);
int zap_increment_int(objset_t *os, uint64_t obj, uint64_t key, int64_t delta,
    dmu_tx_t *tx);

/* Here the key is an int and the value is a different int. */
int zap_add_int_key(objset_t *os, uint64_t obj,
    uint64_t key, uint64_t value, dmu_tx_t *tx);
int zap_update_int_key(objset_t *os, uint64_t obj,
    uint64_t key, uint64_t value, dmu_tx_t *tx);
int zap_lookup_int_key(objset_t *os, uint64_t obj,
    uint64_t key, uint64_t *valuep);

int zap_increment(objset_t *os, uint64_t obj, const char *name, int64_t delta,
    dmu_tx_t *tx);

struct zap;
struct zap_leaf;
typedef struct zap_cursor {
	/* This structure is opaque! */
	objset_t *zc_objset;
	struct zap *zc_zap;
	struct zap_leaf *zc_leaf;
	uint64_t zc_zapobj;
	uint64_t zc_serialized;
	uint64_t zc_hash;
	uint32_t zc_cd;
} zap_cursor_t;

typedef struct {
	int za_integer_length;
	/*
	 * za_normalization_conflict will be set if there are additional
	 * entries with this normalized form (eg, "foo" and "Foo").
	 */
	boolean_t za_normalization_conflict;
	uint64_t za_num_integers;
	uint64_t za_first_integer;	/* no sign extension for <8byte ints */
	char za_name[MAXNAMELEN];
} zap_attribute_t;

/*
 * The interface for listing all the attributes of a zapobj can be
 * thought of as cursor moving down a list of the attributes one by
 * one.  The cookie returned by the zap_cursor_serialize routine is
 * persistent across system calls (and across reboot, even).
 */

/*
 * Initialize a zap cursor, pointing to the "first" attribute of the
 * zapobj.  You must _fini the cursor when you are done with it.
 */
void zap_cursor_init(zap_cursor_t *zc, objset_t *ds, uint64_t zapobj);
void zap_cursor_fini(zap_cursor_t *zc);

/*
 * Get the attribute currently pointed to by the cursor.  Returns
 * ENOENT if at the end of the attributes.
 */
int zap_cursor_retrieve(zap_cursor_t *zc, zap_attribute_t *za);

/*
 * Advance the cursor to the next attribute.
 */
void zap_cursor_advance(zap_cursor_t *zc);

/*
 * Get a persistent cookie pointing to the current position of the zap
 * cursor.  The low 4 bits in the cookie are always zero, and thus can
 * be used as to differentiate a serialized cookie from a different type
 * of value.  The cookie will be less than 2^32 as long as there are
 * fewer than 2^22 (4.2 million) entries in the zap object.
 */
uint64_t zap_cursor_serialize(zap_cursor_t *zc);

/*
 * Initialize a zap cursor pointing to the position recorded by
 * zap_cursor_serialize (in the "serialized" argument).  You can also
 * use a "serialized" argument of 0 to start at the beginning of the
 * zapobj (ie.  zap_cursor_init_serialized(..., 0) is equivalent to
 * zap_cursor_init(...).)
 */
void zap_cursor_init_serialized(zap_cursor_t *zc, objset_t *ds,
    uint64_t zapobj, uint64_t serialized);


#define	ZAP_HISTOGRAM_SIZE 10

typedef struct zap_stats {
	/*
	 * Size of the pointer table (in number of entries).
	 * This is always a power of 2, or zero if it's a microzap.
	 * In general, it should be considerably greater than zs_num_leafs.
	 */
	uint64_t zs_ptrtbl_len;

	uint64_t zs_blocksize;		/* size of zap blocks */

	/*
	 * The number of blocks used.  Note that some blocks may be
	 * wasted because old ptrtbl's and large name/value blocks are
	 * not reused.  (Although their space is reclaimed, we don't
	 * reuse those offsets in the object.)
	 */
	uint64_t zs_num_blocks;

	/*
	 * Pointer table values from zap_ptrtbl in the zap_phys_t
	 */
	uint64_t zs_ptrtbl_nextblk;	  /* next (larger) copy start block */
	uint64_t zs_ptrtbl_blks_copied;   /* number source blocks copied */
	uint64_t zs_ptrtbl_zt_blk;	  /* starting block number */
	uint64_t zs_ptrtbl_zt_numblks;    /* number of blocks */
	uint64_t zs_ptrtbl_zt_shift;	  /* bits to index it */

	/*
	 * Values of the other members of the zap_phys_t
	 */
	uint64_t zs_block_type;		/* ZBT_HEADER */
	uint64_t zs_magic;		/* ZAP_MAGIC */
	uint64_t zs_num_leafs;		/* The number of leaf blocks */
	uint64_t zs_num_entries;	/* The number of zap entries */
	uint64_t zs_salt;		/* salt to stir into hash function */

	/*
	 * Histograms.  For all histograms, the last index
	 * (ZAP_HISTOGRAM_SIZE-1) includes any values which are greater
	 * than what can be represented.  For example
	 * zs_leafs_with_n5_entries[ZAP_HISTOGRAM_SIZE-1] is the number
	 * of leafs with more than 45 entries.
	 */

	/*
	 * zs_leafs_with_n_pointers[n] is the number of leafs with
	 * 2^n pointers to it.
	 */
	uint64_t zs_leafs_with_2n_pointers[ZAP_HISTOGRAM_SIZE];

	/*
	 * zs_leafs_with_n_entries[n] is the number of leafs with
	 * [n*5, (n+1)*5) entries.  In the current implementation, there
	 * can be at most 55 entries in any block, but there may be
	 * fewer if the name or value is large, or the block is not
	 * completely full.
	 */
	uint64_t zs_blocks_with_n5_entries[ZAP_HISTOGRAM_SIZE];

	/*
	 * zs_leafs_n_tenths_full[n] is the number of leafs whose
	 * fullness is in the range [n/10, (n+1)/10).
	 */
	uint64_t zs_blocks_n_tenths_full[ZAP_HISTOGRAM_SIZE];

	/*
	 * zs_entries_using_n_chunks[n] is the number of entries which
	 * consume n 24-byte chunks.  (Note, large names/values only use
	 * one chunk, but contribute to zs_num_blocks_large.)
	 */
	uint64_t zs_entries_using_n_chunks[ZAP_HISTOGRAM_SIZE];

	/*
	 * zs_buckets_with_n_entries[n] is the number of buckets (each
	 * leaf has 64 buckets) with n entries.
	 * zs_buckets_with_n_entries[1] should be very close to
	 * zs_num_entries.
	 */
	uint64_t zs_buckets_with_n_entries[ZAP_HISTOGRAM_SIZE];
} zap_stats_t;

/*
 * Get statistics about a ZAP object.  Note: you need to be aware of the
 * internal implementation of the ZAP to correctly interpret some of the
 * statistics.  This interface shouldn't be relied on unless you really
 * know what you're doing.
 */
int zap_get_stats(objset_t *ds, uint64_t zapobj, zap_stats_t *zs);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_ZAP_H */
                                                                                                                                                                       usr/src/zfs-0.6.5.9/include/sys/zap_impl.h                                                          0100644 0000000 0000000 00000015317 13045171016 016514  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 */

#ifndef	_SYS_ZAP_IMPL_H
#define	_SYS_ZAP_IMPL_H

#include <sys/zap.h>
#include <sys/zfs_context.h>
#include <sys/avl.h>

#ifdef	__cplusplus
extern "C" {
#endif

extern int fzap_default_block_shift;

#define	ZAP_MAGIC 0x2F52AB2ABULL

#define	FZAP_BLOCK_SHIFT(zap)	((zap)->zap_f.zap_block_shift)

#define	MZAP_ENT_LEN		64
#define	MZAP_NAME_LEN		(MZAP_ENT_LEN - 8 - 4 - 2)
#define	MZAP_MAX_BLKSZ		SPA_OLD_MAXBLOCKSIZE

#define	ZAP_NEED_CD		(-1U)

typedef struct mzap_ent_phys {
	uint64_t mze_value;
	uint32_t mze_cd;
	uint16_t mze_pad;	/* in case we want to chain them someday */
	char mze_name[MZAP_NAME_LEN];
} mzap_ent_phys_t;

typedef struct mzap_phys {
	uint64_t mz_block_type;	/* ZBT_MICRO */
	uint64_t mz_salt;
	uint64_t mz_normflags;
	uint64_t mz_pad[5];
	mzap_ent_phys_t mz_chunk[1];
	/* actually variable size depending on block size */
} mzap_phys_t;

typedef struct mzap_ent {
	avl_node_t mze_node;
	int mze_chunkid;
	uint64_t mze_hash;
	uint32_t mze_cd; /* copy from mze_phys->mze_cd */
} mzap_ent_t;

#define	MZE_PHYS(zap, mze) \
	(&zap_m_phys(zap)->mz_chunk[(mze)->mze_chunkid])

/*
 * The (fat) zap is stored in one object. It is an array of
 * 1<<FZAP_BLOCK_SHIFT byte blocks. The layout looks like one of:
 *
 * ptrtbl fits in first block:
 * 	[zap_phys_t zap_ptrtbl_shift < 6] [zap_leaf_t] ...
 *
 * ptrtbl too big for first block:
 * 	[zap_phys_t zap_ptrtbl_shift >= 6] [zap_leaf_t] [ptrtbl] ...
 *
 */

struct dmu_buf;
struct zap_leaf;

#define	ZBT_LEAF		((1ULL << 63) + 0)
#define	ZBT_HEADER		((1ULL << 63) + 1)
#define	ZBT_MICRO		((1ULL << 63) + 3)
/* any other values are ptrtbl blocks */

/*
 * the embedded pointer table takes up half a block:
 * block size / entry size (2^3) / 2
 */
#define	ZAP_EMBEDDED_PTRTBL_SHIFT(zap) (FZAP_BLOCK_SHIFT(zap) - 3 - 1)

/*
 * The embedded pointer table starts half-way through the block.  Since
 * the pointer table itself is half the block, it starts at (64-bit)
 * word number (1<<ZAP_EMBEDDED_PTRTBL_SHIFT(zap)).
 */
#define	ZAP_EMBEDDED_PTRTBL_ENT(zap, idx) \
	((uint64_t *)zap_f_phys(zap)) \
	[(idx) + (1<<ZAP_EMBEDDED_PTRTBL_SHIFT(zap))]

/*
 * TAKE NOTE:
 * If zap_phys_t is modified, zap_byteswap() must be modified.
 */
typedef struct zap_phys {
	uint64_t zap_block_type;	/* ZBT_HEADER */
	uint64_t zap_magic;		/* ZAP_MAGIC */

	struct zap_table_phys {
		uint64_t zt_blk;	/* starting block number */
		uint64_t zt_numblks;	/* number of blocks */
		uint64_t zt_shift;	/* bits to index it */
		uint64_t zt_nextblk;	/* next (larger) copy start block */
		uint64_t zt_blks_copied; /* number source blocks copied */
	} zap_ptrtbl;

	uint64_t zap_freeblk;		/* the next free block */
	uint64_t zap_num_leafs;		/* number of leafs */
	uint64_t zap_num_entries;	/* number of entries */
	uint64_t zap_salt;		/* salt to stir into hash function */
	uint64_t zap_normflags;		/* flags for u8_textprep_str() */
	uint64_t zap_flags;		/* zap_flags_t */
	/*
	 * This structure is followed by padding, and then the embedded
	 * pointer table.  The embedded pointer table takes up second
	 * half of the block.  It is accessed using the
	 * ZAP_EMBEDDED_PTRTBL_ENT() macro.
	 */
} zap_phys_t;

typedef struct zap_table_phys zap_table_phys_t;

typedef struct zap {
	dmu_buf_user_t zap_dbu;
	objset_t *zap_objset;
	uint64_t zap_object;
	struct dmu_buf *zap_dbuf;
	krwlock_t zap_rwlock;
	boolean_t zap_ismicro;
	int zap_normflags;
	uint64_t zap_salt;
	union {
		struct {
			/*
			 * zap_num_entries_mtx protects
			 * zap_num_entries
			 */
			kmutex_t zap_num_entries_mtx;
			int zap_block_shift;
		} zap_fat;
		struct {
			int16_t zap_num_entries;
			int16_t zap_num_chunks;
			int16_t zap_alloc_next;
			avl_tree_t zap_avl;
		} zap_micro;
	} zap_u;
} zap_t;

static inline zap_phys_t *
zap_f_phys(zap_t *zap)
{
	return (zap->zap_dbuf->db_data);
}

static inline mzap_phys_t *
zap_m_phys(zap_t *zap)
{
	return (zap->zap_dbuf->db_data);
}

typedef struct zap_name {
	zap_t *zn_zap;
	int zn_key_intlen;
	const void *zn_key_orig;
	int zn_key_orig_numints;
	const void *zn_key_norm;
	int zn_key_norm_numints;
	uint64_t zn_hash;
	matchtype_t zn_matchtype;
	char zn_normbuf[ZAP_MAXNAMELEN];
} zap_name_t;

#define	zap_f	zap_u.zap_fat
#define	zap_m	zap_u.zap_micro

boolean_t zap_match(zap_name_t *zn, const char *matchname);
int zap_lockdir(objset_t *os, uint64_t obj, dmu_tx_t *tx,
    krw_t lti, boolean_t fatreader, boolean_t adding, zap_t **zapp);
void zap_unlockdir(zap_t *zap);
void zap_evict(void *dbu);
zap_name_t *zap_name_alloc(zap_t *zap, const char *key, matchtype_t mt);
void zap_name_free(zap_name_t *zn);
int zap_hashbits(zap_t *zap);
uint32_t zap_maxcd(zap_t *zap);
uint64_t zap_getflags(zap_t *zap);

#define	ZAP_HASH_IDX(hash, n) (((n) == 0) ? 0 : ((hash) >> (64 - (n))))

void fzap_byteswap(void *buf, size_t size);
int fzap_count(zap_t *zap, uint64_t *count);
int fzap_lookup(zap_name_t *zn,
    uint64_t integer_size, uint64_t num_integers, void *buf,
    char *realname, int rn_len, boolean_t *normalization_conflictp);
void fzap_prefetch(zap_name_t *zn);
int fzap_count_write(zap_name_t *zn, int add, uint64_t *towrite,
    uint64_t *tooverwrite);
int fzap_add(zap_name_t *zn, uint64_t integer_size, uint64_t num_integers,
    const void *val, dmu_tx_t *tx);
int fzap_update(zap_name_t *zn,
    int integer_size, uint64_t num_integers, const void *val, dmu_tx_t *tx);
int fzap_length(zap_name_t *zn,
    uint64_t *integer_size, uint64_t *num_integers);
int fzap_remove(zap_name_t *zn, dmu_tx_t *tx);
int fzap_cursor_retrieve(zap_t *zap, zap_cursor_t *zc, zap_attribute_t *za);
void fzap_get_stats(zap_t *zap, zap_stats_t *zs);
void zap_put_leaf(struct zap_leaf *l);

int fzap_add_cd(zap_name_t *zn,
    uint64_t integer_size, uint64_t num_integers,
    const void *val, uint32_t cd, dmu_tx_t *tx);
void fzap_upgrade(zap_t *zap, dmu_tx_t *tx, zap_flags_t flags);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_ZAP_IMPL_H */
                                                                                                                                                                                                                                                                                                                 usr/src/zfs-0.6.5.9/include/sys/zap_leaf.h                                                          0100644 0000000 0000000 00000017050 13045171016 016456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
 */

#ifndef	_SYS_ZAP_LEAF_H
#define	_SYS_ZAP_LEAF_H

#include <sys/zap.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct zap;
struct zap_name;
struct zap_stats;

#define	ZAP_LEAF_MAGIC 0x2AB1EAF

/* chunk size = 24 bytes */
#define	ZAP_LEAF_CHUNKSIZE 24

/*
 * The amount of space available for chunks is:
 * block size (1<<l->l_bs) - hash entry size (2) * number of hash
 * entries - header space (2*chunksize)
 */
#define	ZAP_LEAF_NUMCHUNKS(l) \
	(((1<<(l)->l_bs) - 2*ZAP_LEAF_HASH_NUMENTRIES(l)) / \
	ZAP_LEAF_CHUNKSIZE - 2)

/*
 * The amount of space within the chunk available for the array is:
 * chunk size - space for type (1) - space for next pointer (2)
 */
#define	ZAP_LEAF_ARRAY_BYTES (ZAP_LEAF_CHUNKSIZE - 3)

#define	ZAP_LEAF_ARRAY_NCHUNKS(bytes) \
	(((bytes)+ZAP_LEAF_ARRAY_BYTES-1)/ZAP_LEAF_ARRAY_BYTES)

/*
 * Low water mark:  when there are only this many chunks free, start
 * growing the ptrtbl.  Ideally, this should be larger than a
 * "reasonably-sized" entry.  20 chunks is more than enough for the
 * largest directory entry (MAXNAMELEN (256) byte name, 8-byte value),
 * while still being only around 3% for 16k blocks.
 */
#define	ZAP_LEAF_LOW_WATER (20)

/*
 * The leaf hash table has block size / 2^5 (32) number of entries,
 * which should be more than enough for the maximum number of entries,
 * which is less than block size / CHUNKSIZE (24) / minimum number of
 * chunks per entry (3).
 */
#define	ZAP_LEAF_HASH_SHIFT(l) ((l)->l_bs - 5)
#define	ZAP_LEAF_HASH_NUMENTRIES(l) (1 << ZAP_LEAF_HASH_SHIFT(l))

/*
 * The chunks start immediately after the hash table.  The end of the
 * hash table is at l_hash + HASH_NUMENTRIES, which we simply cast to a
 * chunk_t.
 */
#define	ZAP_LEAF_CHUNK(l, idx) \
	((zap_leaf_chunk_t *) \
	(zap_leaf_phys(l)->l_hash + ZAP_LEAF_HASH_NUMENTRIES(l)))[idx]
#define	ZAP_LEAF_ENTRY(l, idx) (&ZAP_LEAF_CHUNK(l, idx).l_entry)

typedef enum zap_chunk_type {
	ZAP_CHUNK_FREE = 253,
	ZAP_CHUNK_ENTRY = 252,
	ZAP_CHUNK_ARRAY = 251,
	ZAP_CHUNK_TYPE_MAX = 250
} zap_chunk_type_t;

#define	ZLF_ENTRIES_CDSORTED (1<<0)

/*
 * TAKE NOTE:
 * If zap_leaf_phys_t is modified, zap_leaf_byteswap() must be modified.
 */
typedef struct zap_leaf_phys {
	struct zap_leaf_header {
		/* Public to ZAP */
		uint64_t lh_block_type;		/* ZBT_LEAF */
		uint64_t lh_pad1;
		uint64_t lh_prefix;		/* hash prefix of this leaf */
		uint32_t lh_magic;		/* ZAP_LEAF_MAGIC */
		uint16_t lh_nfree;		/* number free chunks */
		uint16_t lh_nentries;		/* number of entries */
		uint16_t lh_prefix_len;		/* num bits used to id this */

		/* Private to zap_leaf */
		uint16_t lh_freelist;		/* chunk head of free list */
		uint8_t lh_flags;		/* ZLF_* flags */
		uint8_t lh_pad2[11];
	} l_hdr; /* 2 24-byte chunks */

	/*
	 * The header is followed by a hash table with
	 * ZAP_LEAF_HASH_NUMENTRIES(zap) entries.  The hash table is
	 * followed by an array of ZAP_LEAF_NUMCHUNKS(zap)
	 * zap_leaf_chunk structures.  These structures are accessed
	 * with the ZAP_LEAF_CHUNK() macro.
	 */

	uint16_t l_hash[1];
} zap_leaf_phys_t;

typedef union zap_leaf_chunk {
	struct zap_leaf_entry {
		uint8_t le_type; 		/* always ZAP_CHUNK_ENTRY */
		uint8_t le_value_intlen;	/* size of value's ints */
		uint16_t le_next;		/* next entry in hash chain */
		uint16_t le_name_chunk;		/* first chunk of the name */
		uint16_t le_name_numints;	/* ints in name (incl null) */
		uint16_t le_value_chunk;	/* first chunk of the value */
		uint16_t le_value_numints;	/* value length in ints */
		uint32_t le_cd;			/* collision differentiator */
		uint64_t le_hash;		/* hash value of the name */
	} l_entry;
	struct zap_leaf_array {
		uint8_t la_type;		/* always ZAP_CHUNK_ARRAY */
		uint8_t la_array[ZAP_LEAF_ARRAY_BYTES];
		uint16_t la_next;		/* next blk or CHAIN_END */
	} l_array;
	struct zap_leaf_free {
		uint8_t lf_type;		/* always ZAP_CHUNK_FREE */
		uint8_t lf_pad[ZAP_LEAF_ARRAY_BYTES];
		uint16_t lf_next;	/* next in free list, or CHAIN_END */
	} l_free;
} zap_leaf_chunk_t;

typedef struct zap_leaf {
	dmu_buf_user_t l_dbu;
	krwlock_t l_rwlock;
	uint64_t l_blkid;		/* 1<<ZAP_BLOCK_SHIFT byte block off */
	int l_bs;			/* block size shift */
	dmu_buf_t *l_dbuf;
} zap_leaf_t;

static inline zap_leaf_phys_t *
zap_leaf_phys(zap_leaf_t *l)
{
	return (l->l_dbuf->db_data);
}

typedef struct zap_entry_handle {
	/* Set by zap_leaf and public to ZAP */
	uint64_t zeh_num_integers;
	uint64_t zeh_hash;
	uint32_t zeh_cd;
	uint8_t zeh_integer_size;

	/* Private to zap_leaf */
	uint16_t zeh_fakechunk;
	uint16_t *zeh_chunkp;
	zap_leaf_t *zeh_leaf;
} zap_entry_handle_t;

/*
 * Return a handle to the named entry, or ENOENT if not found.  The hash
 * value must equal zap_hash(name).
 */
extern int zap_leaf_lookup(zap_leaf_t *l,
    struct zap_name *zn, zap_entry_handle_t *zeh);

/*
 * Return a handle to the entry with this hash+cd, or the entry with the
 * next closest hash+cd.
 */
extern int zap_leaf_lookup_closest(zap_leaf_t *l,
    uint64_t hash, uint32_t cd, zap_entry_handle_t *zeh);

/*
 * Read the first num_integers in the attribute.  Integer size
 * conversion will be done without sign extension.  Return EINVAL if
 * integer_size is too small.  Return EOVERFLOW if there are more than
 * num_integers in the attribute.
 */
extern int zap_entry_read(const zap_entry_handle_t *zeh,
    uint8_t integer_size, uint64_t num_integers, void *buf);

extern int zap_entry_read_name(struct zap *zap, const zap_entry_handle_t *zeh,
    uint16_t buflen, char *buf);

/*
 * Replace the value of an existing entry.
 *
 * May fail if it runs out of space (ENOSPC).
 */
extern int zap_entry_update(zap_entry_handle_t *zeh,
    uint8_t integer_size, uint64_t num_integers, const void *buf);

/*
 * Remove an entry.
 */
extern void zap_entry_remove(zap_entry_handle_t *zeh);

/*
 * Create an entry. An equal entry must not exist, and this entry must
 * belong in this leaf (according to its hash value).  Fills in the
 * entry handle on success.  Returns 0 on success or ENOSPC on failure.
 */
extern int zap_entry_create(zap_leaf_t *l, struct zap_name *zn, uint32_t cd,
    uint8_t integer_size, uint64_t num_integers, const void *buf,
    zap_entry_handle_t *zeh);

/* Determine whether there is another entry with the same normalized form. */
extern boolean_t zap_entry_normalization_conflict(zap_entry_handle_t *zeh,
    struct zap_name *zn, const char *name, struct zap *zap);

/*
 * Other stuff.
 */

extern void zap_leaf_init(zap_leaf_t *l, boolean_t sort);
extern void zap_leaf_byteswap(zap_leaf_phys_t *buf, int len);
extern void zap_leaf_split(zap_leaf_t *l, zap_leaf_t *nl, boolean_t sort);
extern void zap_leaf_stats(struct zap *zap, zap_leaf_t *l,
    struct zap_stats *zs);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_ZAP_LEAF_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/sys/zfeature.h                                                          0100644 0000000 0000000 00000004655 13045171016 016531  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef _SYS_ZFEATURE_H
#define	_SYS_ZFEATURE_H

#include <sys/nvpair.h>
#include <sys/txg.h>
#include "zfeature_common.h"

#ifdef	__cplusplus
extern "C" {
#endif

#define	VALID_FEATURE_FID(fid)	((fid) >= 0 && (fid) < SPA_FEATURES)
#define	VALID_FEATURE_OR_NONE(fid)	((fid) == SPA_FEATURE_NONE ||	\
    VALID_FEATURE_FID(fid))

struct spa;
struct dmu_tx;
struct objset;

extern void spa_feature_create_zap_objects(struct spa *, struct dmu_tx *);
extern void spa_feature_enable(struct spa *, spa_feature_t,
    struct dmu_tx *);
extern void spa_feature_incr(struct spa *, spa_feature_t, struct dmu_tx *);
extern void spa_feature_decr(struct spa *, spa_feature_t, struct dmu_tx *);
extern boolean_t spa_feature_is_enabled(struct spa *, spa_feature_t);
extern boolean_t spa_feature_is_active(struct spa *, spa_feature_t);
extern boolean_t spa_feature_enabled_txg(spa_t *spa, spa_feature_t fid,
    uint64_t *txg);
extern uint64_t spa_feature_refcount(spa_t *, spa_feature_t, uint64_t);
extern boolean_t spa_features_check(spa_t *, boolean_t, nvlist_t *, nvlist_t *);

/*
 * These functions are only exported for zhack and zdb; normal callers should
 * use the above interfaces.
 */
extern int feature_get_refcount(struct spa *, zfeature_info_t *, uint64_t *);
extern int feature_get_refcount_from_disk(spa_t *spa, zfeature_info_t *feature,
    uint64_t *res);
extern void feature_enable_sync(struct spa *, zfeature_info_t *,
    struct dmu_tx *);
extern void feature_sync(struct spa *, zfeature_info_t *, uint64_t,
    struct dmu_tx *);

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_ZFEATURE_H */
                                                                                   usr/src/zfs-0.6.5.9/include/sys/zfs_acl.h                                                           0100644 0000000 0000000 00000017772 13045171016 016331  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_FS_ZFS_ACL_H
#define	_SYS_FS_ZFS_ACL_H

#ifdef _KERNEL
#include <sys/isa_defs.h>
#include <sys/types32.h>
#include <sys/xvattr.h>
#endif
#include <sys/acl.h>
#include <sys/dmu.h>
#include <sys/zfs_fuid.h>
#include <sys/sa.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct znode_phys;

#define	ACE_SLOT_CNT	6
#define	ZFS_ACL_VERSION_INITIAL 0ULL
#define	ZFS_ACL_VERSION_FUID	1ULL
#define	ZFS_ACL_VERSION		ZFS_ACL_VERSION_FUID

/*
 * ZFS ACLs (Access Control Lists) are stored in various forms.
 *
 * Files created with ACL version ZFS_ACL_VERSION_INITIAL
 * will all be created with fixed length ACEs of type
 * zfs_oldace_t.
 *
 * Files with ACL version ZFS_ACL_VERSION_FUID will be created
 * with various sized ACEs.  The abstraction entries will utilize
 * zfs_ace_hdr_t, normal user/group entries will use zfs_ace_t
 * and some specialized CIFS ACEs will use zfs_object_ace_t.
 */

/*
 * All ACEs have a common hdr.  For
 * owner@, group@, and everyone@ this is all
 * thats needed.
 */
typedef struct zfs_ace_hdr {
	uint16_t z_type;
	uint16_t z_flags;
	uint32_t z_access_mask;
} zfs_ace_hdr_t;

typedef zfs_ace_hdr_t zfs_ace_abstract_t;

/*
 * Standard ACE
 */
typedef struct zfs_ace {
	zfs_ace_hdr_t	z_hdr;
	uint64_t	z_fuid;
} zfs_ace_t;

/*
 * The following type only applies to ACE_ACCESS_ALLOWED|DENIED_OBJECT_ACE_TYPE
 * and will only be set/retrieved in a CIFS context.
 */

typedef struct zfs_object_ace {
	zfs_ace_t	z_ace;
	uint8_t		z_object_type[16]; /* object type */
	uint8_t		z_inherit_type[16]; /* inherited object type */
} zfs_object_ace_t;

typedef struct zfs_oldace {
	uint32_t	z_fuid;		/* "who" */
	uint32_t	z_access_mask;  /* access mask */
	uint16_t	z_flags;	/* flags, i.e inheritance */
	uint16_t	z_type;		/* type of entry allow/deny */
} zfs_oldace_t;

typedef struct zfs_acl_phys_v0 {
	uint64_t	z_acl_extern_obj;	/* ext acl pieces */
	uint32_t	z_acl_count;		/* Number of ACEs */
	uint16_t	z_acl_version;		/* acl version */
	uint16_t	z_acl_pad;		/* pad */
	zfs_oldace_t	z_ace_data[ACE_SLOT_CNT]; /* 6 standard ACEs */
} zfs_acl_phys_v0_t;

#define	ZFS_ACE_SPACE	(sizeof (zfs_oldace_t) * ACE_SLOT_CNT)

/*
 * Size of ACL count is always 2 bytes.
 * Necessary to for dealing with both V0 ACL and V1 ACL layout
 */
#define	ZFS_ACL_COUNT_SIZE	(sizeof (uint16_t))

typedef struct zfs_acl_phys {
	uint64_t	z_acl_extern_obj;	  /* ext acl pieces */
	uint32_t	z_acl_size;		  /* Number of bytes in ACL */
	uint16_t	z_acl_version;		  /* acl version */
	uint16_t	z_acl_count;		  /* ace count */
	uint8_t	z_ace_data[ZFS_ACE_SPACE]; /* space for embedded ACEs */
} zfs_acl_phys_t;

typedef struct acl_ops {
	uint32_t	(*ace_mask_get) (void *acep); /* get  access mask */
	void 		(*ace_mask_set) (void *acep,
			    uint32_t mask); /* set access mask */
	uint16_t	(*ace_flags_get) (void *acep);	/* get flags */
	void		(*ace_flags_set) (void *acep,
			    uint16_t flags); /* set flags */
	uint16_t	(*ace_type_get)(void *acep); /* get type */
	void		(*ace_type_set)(void *acep,
			    uint16_t type); /* set type */
	uint64_t	(*ace_who_get)(void *acep); /* get who/fuid */
	void		(*ace_who_set)(void *acep,
			    uint64_t who); /* set who/fuid */
	size_t		(*ace_size)(void *acep); /* how big is this ace */
	size_t		(*ace_abstract_size)(void); /* sizeof abstract entry */
	int		(*ace_mask_off)(void); /* off of access mask in ace */
	/* ptr to data if any */
	int		(*ace_data)(void *acep, void **datap);
} acl_ops_t;

/*
 * A zfs_acl_t structure is composed of a list of zfs_acl_node_t's.
 * Each node will have one or more ACEs associated with it.  You will
 * only have multiple nodes during a chmod operation.   Normally only
 * one node is required.
 */
typedef struct zfs_acl_node {
	list_node_t	z_next;		/* Next chunk of ACEs */
	void		*z_acldata;	/* pointer into actual ACE(s) */
	void		*z_allocdata;	/* pointer to kmem allocated memory */
	size_t		z_allocsize;	/* Size of blob in bytes */
	size_t		z_size;		/* length of ACL data */
	uint64_t	z_ace_count;	/* number of ACEs in this acl node */
	int		z_ace_idx;	/* ace iterator positioned on */
} zfs_acl_node_t;

typedef struct zfs_acl {
	uint64_t	z_acl_count;	/* Number of ACEs */
	size_t		z_acl_bytes;	/* Number of bytes in ACL */
	uint_t		z_version;	/* version of ACL */
	void		*z_next_ace;	/* pointer to next ACE */
	uint64_t	z_hints;	/* ACL hints (ZFS_INHERIT_ACE ...) */
	zfs_acl_node_t	*z_curr_node;	/* current node iterator is handling */
	list_t		z_acl;		/* chunks of ACE data */
	acl_ops_t	*z_ops;		/* ACL operations */
} zfs_acl_t;

typedef struct acl_locator_cb {
	zfs_acl_t *cb_aclp;
	zfs_acl_node_t *cb_acl_node;
} zfs_acl_locator_cb_t;

#define	ACL_DATA_ALLOCED	0x1
#define	ZFS_ACL_SIZE(aclcnt)	(sizeof (ace_t) * (aclcnt))

struct zfs_fuid_info;

typedef struct zfs_acl_ids {
	uint64_t		z_fuid;		/* file owner fuid */
	uint64_t		z_fgid;		/* file group owner fuid */
	uint64_t		z_mode;		/* mode to set on create */
	zfs_acl_t		*z_aclp;	/* ACL to create with file */
	struct zfs_fuid_info 	*z_fuidp;	/* for tracking fuids for log */
} zfs_acl_ids_t;

/*
 * Property values for acl_mode and acl_inherit.
 *
 * acl_mode can take discard, noallow, groupmask and passthrough.
 * whereas acl_inherit has secure instead of groupmask.
 */

#define	ZFS_ACL_DISCARD		0
#define	ZFS_ACL_NOALLOW		1
#define	ZFS_ACL_GROUPMASK	2
#define	ZFS_ACL_PASSTHROUGH	3
#define	ZFS_ACL_RESTRICTED	4
#define	ZFS_ACL_PASSTHROUGH_X	5

struct znode;
struct zfs_sb;

#ifdef _KERNEL
int zfs_acl_ids_create(struct znode *, int, vattr_t *,
    cred_t *, vsecattr_t *, zfs_acl_ids_t *);
void zfs_acl_ids_free(zfs_acl_ids_t *);
boolean_t zfs_acl_ids_overquota(struct zfs_sb *, zfs_acl_ids_t *);
int zfs_getacl(struct znode *, vsecattr_t *, boolean_t, cred_t *);
int zfs_setacl(struct znode *, vsecattr_t *, boolean_t, cred_t *);
void zfs_acl_rele(void *);
void zfs_oldace_byteswap(ace_t *, int);
void zfs_ace_byteswap(void *, size_t, boolean_t);
extern boolean_t zfs_has_access(struct znode *zp, cred_t *cr);
extern int zfs_zaccess(struct znode *, int, int, boolean_t, cred_t *);
int zfs_fastaccesschk_execute(struct znode *, cred_t *);
extern int zfs_zaccess_rwx(struct znode *, mode_t, int, cred_t *);
extern int zfs_zaccess_unix(struct znode *, mode_t, cred_t *);
extern int zfs_acl_access(struct znode *, int, cred_t *);
void zfs_acl_chmod_setattr(struct znode *, zfs_acl_t **, uint64_t);
int zfs_zaccess_delete(struct znode *, struct znode *, cred_t *);
int zfs_zaccess_rename(struct znode *, struct znode *,
    struct znode *, struct znode *, cred_t *cr);
void zfs_acl_free(zfs_acl_t *);
int zfs_vsec_2_aclp(struct zfs_sb *, umode_t, vsecattr_t *, cred_t *,
    struct zfs_fuid_info **, zfs_acl_t **);
int zfs_aclset_common(struct znode *, zfs_acl_t *, cred_t *, dmu_tx_t *);
uint64_t zfs_external_acl(struct znode *);
int zfs_znode_acl_version(struct znode *);
int zfs_acl_size(struct znode *, int *);
zfs_acl_t *zfs_acl_alloc(int);
zfs_acl_node_t *zfs_acl_node_alloc(size_t);
void zfs_acl_xform(struct znode *, zfs_acl_t *, cred_t *);
void zfs_acl_data_locator(void **, uint32_t *, uint32_t, boolean_t, void *);
uint64_t zfs_mode_compute(uint64_t, zfs_acl_t *,
    uint64_t *, uint64_t, uint64_t);
int zfs_acl_chown_setattr(struct znode *);

#endif

#ifdef	__cplusplus
}
#endif
#endif	/* _SYS_FS_ZFS_ACL_H */
      usr/src/zfs-0.6.5.9/include/sys/zfs_context.h                                                       0100644 0000000 0000000 00000051232 13045171016 017243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */
/*
 * Copyright 2011 Nexenta Systems, Inc. All rights reserved.
 * Copyright (c) 2012, Joyent, Inc. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 */

#ifndef _SYS_ZFS_CONTEXT_H
#define	_SYS_ZFS_CONTEXT_H

#ifdef __KERNEL__

#include <sys/note.h>
#include <sys/types.h>
#include <sys/t_lock.h>
#include <sys/atomic.h>
#include <sys/sysmacros.h>
#include <sys/bitmap.h>
#include <sys/cmn_err.h>
#include <sys/kmem.h>
#include <sys/kmem_cache.h>
#include <sys/vmem.h>
#include <sys/taskq.h>
#include <sys/buf.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/cpuvar.h>
#include <sys/kobj.h>
#include <sys/conf.h>
#include <sys/disp.h>
#include <sys/debug.h>
#include <sys/random.h>
#include <sys/byteorder.h>
#include <sys/systm.h>
#include <sys/list.h>
#include <sys/uio_impl.h>
#include <sys/dirent.h>
#include <sys/time.h>
#include <vm/seg_kmem.h>
#include <sys/zone.h>
#include <sys/sdt.h>
#include <sys/zfs_debug.h>
#include <sys/zfs_delay.h>
#include <sys/fm/fs/zfs.h>
#include <sys/sunddi.h>
#include <sys/ctype.h>
#include <sys/disp.h>
#include <sys/trace.h>
#include <linux/dcache_compat.h>
#include <linux/utsname_compat.h>

#else /* _KERNEL */

#define	_SYS_MUTEX_H
#define	_SYS_RWLOCK_H
#define	_SYS_CONDVAR_H
#define	_SYS_SYSTM_H
#define	_SYS_T_LOCK_H
#define	_SYS_VNODE_H
#define	_SYS_VFS_H
#define	_SYS_SUNDDI_H
#define	_SYS_CALLB_H

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdarg.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <strings.h>
#include <pthread.h>
#include <synch.h>
#include <assert.h>
#include <alloca.h>
#include <umem.h>
#include <limits.h>
#include <atomic.h>
#include <dirent.h>
#include <time.h>
#include <ctype.h>
#include <signal.h>
#include <sys/mman.h>
#include <sys/note.h>
#include <sys/types.h>
#include <sys/cred.h>
#include <sys/sysmacros.h>
#include <sys/bitmap.h>
#include <sys/resource.h>
#include <sys/byteorder.h>
#include <sys/list.h>
#include <sys/uio.h>
#include <sys/zfs_debug.h>
#include <sys/sdt.h>
#include <sys/kstat.h>
#include <sys/u8_textprep.h>
#include <sys/fm/fs/zfs.h>
#include <sys/sunddi.h>
#include <sys/debug.h>
#include <sys/utsname.h>

/*
 * Stack
 */

#define	noinline	__attribute__((noinline))

/*
 * Debugging
 */

/*
 * Note that we are not using the debugging levels.
 */

#define	CE_CONT		0	/* continuation		*/
#define	CE_NOTE		1	/* notice		*/
#define	CE_WARN		2	/* warning		*/
#define	CE_PANIC	3	/* panic		*/
#define	CE_IGNORE	4	/* print nothing	*/

/*
 * ZFS debugging
 */

extern void dprintf_setup(int *argc, char **argv);

extern void cmn_err(int, const char *, ...);
extern void vcmn_err(int, const char *, va_list);
extern void panic(const char *, ...);
extern void vpanic(const char *, va_list);

#define	fm_panic	panic

extern int aok;

/*
 * DTrace SDT probes have different signatures in userland than they do in
 * kernel.  If they're being used in kernel code, re-define them out of
 * existence for their counterparts in libzpool.
 */

#ifdef DTRACE_PROBE
#undef	DTRACE_PROBE
#endif	/* DTRACE_PROBE */
#define	DTRACE_PROBE(a) \
	ZFS_PROBE0(#a)

#ifdef DTRACE_PROBE1
#undef	DTRACE_PROBE1
#endif	/* DTRACE_PROBE1 */
#define	DTRACE_PROBE1(a, b, c) \
	ZFS_PROBE1(#a, (unsigned long)c)

#ifdef DTRACE_PROBE2
#undef	DTRACE_PROBE2
#endif	/* DTRACE_PROBE2 */
#define	DTRACE_PROBE2(a, b, c, d, e) \
	ZFS_PROBE2(#a, (unsigned long)c, (unsigned long)e)

#ifdef DTRACE_PROBE3
#undef	DTRACE_PROBE3
#endif	/* DTRACE_PROBE3 */
#define	DTRACE_PROBE3(a, b, c, d, e, f, g) \
	ZFS_PROBE3(#a, (unsigned long)c, (unsigned long)e, (unsigned long)g)

#ifdef DTRACE_PROBE4
#undef	DTRACE_PROBE4
#endif	/* DTRACE_PROBE4 */
#define	DTRACE_PROBE4(a, b, c, d, e, f, g, h, i) \
	ZFS_PROBE4(#a, (unsigned long)c, (unsigned long)e, (unsigned long)g, \
	(unsigned long)i)

/*
 * We use the comma operator so that this macro can be used without much
 * additional code.  For example, "return (EINVAL);" becomes
 * "return (SET_ERROR(EINVAL));".  Note that the argument will be evaluated
 * twice, so it should not have side effects (e.g. something like:
 * "return (SET_ERROR(log_error(EINVAL, info)));" would log the error twice).
 */
#define	SET_ERROR(err) (ZFS_SET_ERROR(err), err)

/*
 * Threads.  TS_STACK_MIN is dictated by the minimum allowed pthread stack
 * size.  While TS_STACK_MAX is somewhat arbitrary, it was selected to be
 * large enough for the expected stack depth while small enough to avoid
 * exhausting address space with high thread counts.
 */
#define	TS_MAGIC		0x72f158ab4261e538ull
#define	TS_RUN			0x00000002
#define	TS_STACK_MIN		PTHREAD_STACK_MIN
#define	TS_STACK_MAX		(256 * 1024)

/* in libzpool, p0 exists only to have its address taken */
typedef struct proc {
	uintptr_t	this_is_never_used_dont_dereference_it;
} proc_t;

extern struct proc p0;
#define	curproc		(&p0)

typedef void (*thread_func_t)(void *);
typedef void (*thread_func_arg_t)(void *);
typedef pthread_t kt_did_t;

#define	kpreempt(x)	((void)0)

typedef struct kthread {
	kt_did_t	t_tid;
	thread_func_t	t_func;
	void *		t_arg;
	pri_t		t_pri;
} kthread_t;

#define	curthread			zk_thread_current()
#define	getcomm()			"unknown"
#define	thread_exit			zk_thread_exit
#define	thread_create(stk, stksize, func, arg, len, pp, state, pri)	\
	zk_thread_create(stk, stksize, (thread_func_t)func, arg,	\
	    len, NULL, state, pri, PTHREAD_CREATE_DETACHED)
#define	thread_join(t)			zk_thread_join(t)
#define	newproc(f, a, cid, pri, ctp, pid)	(ENOSYS)

extern kthread_t *zk_thread_current(void);
extern void zk_thread_exit(void);
extern kthread_t *zk_thread_create(caddr_t stk, size_t  stksize,
	thread_func_t func, void *arg, size_t len,
	proc_t *pp, int state, pri_t pri, int detachstate);
extern void zk_thread_join(kt_did_t tid);

#define	kpreempt_disable()	((void)0)
#define	kpreempt_enable()	((void)0)

#define	PS_NONE		-1

#define	issig(why)	(FALSE)
#define	ISSIG(thr, why)	(FALSE)

/*
 * Mutexes
 */
#define	MTX_MAGIC	0x9522f51362a6e326ull
#define	MTX_INIT	((void *)NULL)
#define	MTX_DEST	((void *)-1UL)

typedef struct kmutex {
	void		*m_owner;
	uint64_t	m_magic;
	pthread_mutex_t	m_lock;
} kmutex_t;

#define	MUTEX_DEFAULT	0
#define	MUTEX_HELD(m)	((m)->m_owner == curthread)
#define	MUTEX_NOT_HELD(m) (!MUTEX_HELD(m))

extern void mutex_init(kmutex_t *mp, char *name, int type, void *cookie);
extern void mutex_destroy(kmutex_t *mp);
extern void mutex_enter(kmutex_t *mp);
extern void mutex_exit(kmutex_t *mp);
extern int mutex_tryenter(kmutex_t *mp);
extern void *mutex_owner(kmutex_t *mp);
extern int mutex_held(kmutex_t *mp);

/*
 * RW locks
 */
#define	RW_MAGIC	0x4d31fb123648e78aull
#define	RW_INIT		((void *)NULL)
#define	RW_DEST		((void *)-1UL)

typedef struct krwlock {
	void			*rw_owner;
	void			*rw_wr_owner;
	uint64_t		rw_magic;
	pthread_rwlock_t	rw_lock;
	uint_t			rw_readers;
} krwlock_t;

typedef int krw_t;

#define	RW_READER	0
#define	RW_WRITER	1
#define	RW_DEFAULT	RW_READER

#define	RW_READ_HELD(x)		((x)->rw_readers > 0)
#define	RW_WRITE_HELD(x)	((x)->rw_wr_owner == curthread)
#define	RW_LOCK_HELD(x)		(RW_READ_HELD(x) || RW_WRITE_HELD(x))

#undef RW_LOCK_HELD
#define	RW_LOCK_HELD(x)		(RW_READ_HELD(x) || RW_WRITE_HELD(x))

#undef RW_LOCK_HELD
#define	RW_LOCK_HELD(x)		(RW_READ_HELD(x) || RW_WRITE_HELD(x))

extern void rw_init(krwlock_t *rwlp, char *name, int type, void *arg);
extern void rw_destroy(krwlock_t *rwlp);
extern void rw_enter(krwlock_t *rwlp, krw_t rw);
extern int rw_tryenter(krwlock_t *rwlp, krw_t rw);
extern int rw_tryupgrade(krwlock_t *rwlp);
extern void rw_exit(krwlock_t *rwlp);
#define	rw_downgrade(rwlp) do { } while (0)

extern uid_t crgetuid(cred_t *cr);
extern uid_t crgetruid(cred_t *cr);
extern gid_t crgetgid(cred_t *cr);
extern int crgetngroups(cred_t *cr);
extern gid_t *crgetgroups(cred_t *cr);

/*
 * Condition variables
 */
#define	CV_MAGIC	0xd31ea9a83b1b30c4ull

typedef struct kcondvar {
	uint64_t		cv_magic;
	pthread_cond_t		cv;
} kcondvar_t;

#define	CV_DEFAULT	0

extern void cv_init(kcondvar_t *cv, char *name, int type, void *arg);
extern void cv_destroy(kcondvar_t *cv);
extern void cv_wait(kcondvar_t *cv, kmutex_t *mp);
extern clock_t cv_timedwait(kcondvar_t *cv, kmutex_t *mp, clock_t abstime);
extern clock_t cv_timedwait_hires(kcondvar_t *cvp, kmutex_t *mp, hrtime_t tim,
    hrtime_t res, int flag);
extern void cv_signal(kcondvar_t *cv);
extern void cv_broadcast(kcondvar_t *cv);
#define	cv_timedwait_sig(cv, mp, at)		cv_timedwait(cv, mp, at)
#define	cv_wait_sig(cv, mp)			cv_wait(cv, mp)
#define	cv_wait_io(cv, mp)			cv_wait(cv, mp)

/*
 * Thread-specific data
 */
#define	tsd_get(k) pthread_getspecific(k)
#define	tsd_set(k, v) pthread_setspecific(k, v)
#define	tsd_create(kp, d) pthread_key_create(kp, d)
#define	tsd_destroy(kp) /* nothing */

/*
 * Thread-specific data
 */
#define	tsd_get(k) pthread_getspecific(k)
#define	tsd_set(k, v) pthread_setspecific(k, v)
#define	tsd_create(kp, d) pthread_key_create(kp, d)
#define	tsd_destroy(kp) /* nothing */

/*
 * kstat creation, installation and deletion
 */
extern kstat_t *kstat_create(const char *, int,
    const char *, const char *, uchar_t, ulong_t, uchar_t);
extern void kstat_install(kstat_t *);
extern void kstat_delete(kstat_t *);
extern void kstat_waitq_enter(kstat_io_t *);
extern void kstat_waitq_exit(kstat_io_t *);
extern void kstat_runq_enter(kstat_io_t *);
extern void kstat_runq_exit(kstat_io_t *);
extern void kstat_waitq_to_runq(kstat_io_t *);
extern void kstat_runq_back_to_waitq(kstat_io_t *);
extern void kstat_set_raw_ops(kstat_t *ksp,
    int (*headers)(char *buf, size_t size),
    int (*data)(char *buf, size_t size, void *data),
    void *(*addr)(kstat_t *ksp, loff_t index));

/*
 * Kernel memory
 */
#define	KM_SLEEP		UMEM_NOFAIL
#define	KM_PUSHPAGE		KM_SLEEP
#define	KM_NOSLEEP		UMEM_DEFAULT
#define	KMC_NODEBUG		UMC_NODEBUG
#define	KMC_KMEM		0x0
#define	KMC_VMEM		0x0
#define	kmem_alloc(_s, _f)	umem_alloc(_s, _f)
#define	kmem_zalloc(_s, _f)	umem_zalloc(_s, _f)
#define	kmem_free(_b, _s)	umem_free(_b, _s)
#define	vmem_alloc(_s, _f)	kmem_alloc(_s, _f)
#define	vmem_zalloc(_s, _f)	kmem_zalloc(_s, _f)
#define	vmem_free(_b, _s)	kmem_free(_b, _s)
#define	kmem_cache_create(_a, _b, _c, _d, _e, _f, _g, _h, _i) \
	umem_cache_create(_a, _b, _c, _d, _e, _f, _g, _h, _i)
#define	kmem_cache_destroy(_c)	umem_cache_destroy(_c)
#define	kmem_cache_alloc(_c, _f) umem_cache_alloc(_c, _f)
#define	kmem_cache_free(_c, _b)	umem_cache_free(_c, _b)
#define	kmem_debugging()	0
#define	kmem_cache_reap_now(_c)	umem_cache_reap_now(_c);
#define	kmem_cache_set_move(_c, _cb)	/* nothing */
#define	vmem_qcache_reap(_v)		/* nothing */
#define	POINTER_INVALIDATE(_pp)		/* nothing */
#define	POINTER_IS_VALID(_p)	0

extern vmem_t *zio_arena;

typedef umem_cache_t kmem_cache_t;

typedef enum kmem_cbrc {
	KMEM_CBRC_YES,
	KMEM_CBRC_NO,
	KMEM_CBRC_LATER,
	KMEM_CBRC_DONT_NEED,
	KMEM_CBRC_DONT_KNOW
} kmem_cbrc_t;

/*
 * Task queues
 */
typedef struct taskq taskq_t;
typedef uintptr_t taskqid_t;
typedef void (task_func_t)(void *);

typedef struct taskq_ent {
	struct taskq_ent	*tqent_next;
	struct taskq_ent	*tqent_prev;
	task_func_t		*tqent_func;
	void			*tqent_arg;
	uintptr_t		tqent_flags;
} taskq_ent_t;

#define	TQENT_FLAG_PREALLOC	0x1	/* taskq_dispatch_ent used */

#define	TASKQ_PREPOPULATE	0x0001
#define	TASKQ_CPR_SAFE		0x0002	/* Use CPR safe protocol */
#define	TASKQ_DYNAMIC		0x0004	/* Use dynamic thread scheduling */
#define	TASKQ_THREADS_CPU_PCT	0x0008	/* Scale # threads by # cpus */
#define	TASKQ_DC_BATCH		0x0010	/* Mark threads as batch */

#define	TQ_SLEEP	KM_SLEEP	/* Can block for memory */
#define	TQ_NOSLEEP	KM_NOSLEEP	/* cannot block for memory; may fail */
#define	TQ_NOQUEUE	0x02		/* Do not enqueue if can't dispatch */
#define	TQ_FRONT	0x08		/* Queue in front */

extern taskq_t *system_taskq;

extern taskq_t	*taskq_create(const char *, int, pri_t, int, int, uint_t);
#define	taskq_create_proc(a, b, c, d, e, p, f) \
	    (taskq_create(a, b, c, d, e, f))
#define	taskq_create_sysdc(a, b, d, e, p, dc, f) \
	    (taskq_create(a, b, maxclsyspri, d, e, f))
extern taskqid_t taskq_dispatch(taskq_t *, task_func_t, void *, uint_t);
extern taskqid_t taskq_dispatch_delay(taskq_t *, task_func_t, void *, uint_t,
    clock_t);
extern void	taskq_dispatch_ent(taskq_t *, task_func_t, void *, uint_t,
    taskq_ent_t *);
extern int	taskq_empty_ent(taskq_ent_t *);
extern void	taskq_init_ent(taskq_ent_t *);
extern void	taskq_destroy(taskq_t *);
extern void	taskq_wait(taskq_t *);
extern void	taskq_wait_id(taskq_t *, taskqid_t);
extern void	taskq_wait_outstanding(taskq_t *, taskqid_t);
extern int	taskq_member(taskq_t *, kthread_t *);
extern int	taskq_cancel_id(taskq_t *, taskqid_t);
extern void	system_taskq_init(void);
extern void	system_taskq_fini(void);

#define	XVA_MAPSIZE	3
#define	XVA_MAGIC	0x78766174

/*
 * vnodes
 */
typedef struct vnode {
	uint64_t	v_size;
	int		v_fd;
	char		*v_path;
} vnode_t;

#define	AV_SCANSTAMP_SZ	32		/* length of anti-virus scanstamp */

typedef struct xoptattr {
	timestruc_t	xoa_createtime;	/* Create time of file */
	uint8_t		xoa_archive;
	uint8_t		xoa_system;
	uint8_t		xoa_readonly;
	uint8_t		xoa_hidden;
	uint8_t		xoa_nounlink;
	uint8_t		xoa_immutable;
	uint8_t		xoa_appendonly;
	uint8_t		xoa_nodump;
	uint8_t		xoa_settable;
	uint8_t		xoa_opaque;
	uint8_t		xoa_av_quarantined;
	uint8_t		xoa_av_modified;
	uint8_t		xoa_av_scanstamp[AV_SCANSTAMP_SZ];
	uint8_t		xoa_reparse;
	uint8_t		xoa_offline;
	uint8_t		xoa_sparse;
} xoptattr_t;

typedef struct vattr {
	uint_t		va_mask;	/* bit-mask of attributes */
	u_offset_t	va_size;	/* file size in bytes */
} vattr_t;


typedef struct xvattr {
	vattr_t		xva_vattr;	/* Embedded vattr structure */
	uint32_t	xva_magic;	/* Magic Number */
	uint32_t	xva_mapsize;	/* Size of attr bitmap (32-bit words) */
	uint32_t	*xva_rtnattrmapp;	/* Ptr to xva_rtnattrmap[] */
	uint32_t	xva_reqattrmap[XVA_MAPSIZE];	/* Requested attrs */
	uint32_t	xva_rtnattrmap[XVA_MAPSIZE];	/* Returned attrs */
	xoptattr_t	xva_xoptattrs;	/* Optional attributes */
} xvattr_t;

typedef struct vsecattr {
	uint_t		vsa_mask;	/* See below */
	int		vsa_aclcnt;	/* ACL entry count */
	void		*vsa_aclentp;	/* pointer to ACL entries */
	int		vsa_dfaclcnt;	/* default ACL entry count */
	void		*vsa_dfaclentp;	/* pointer to default ACL entries */
	size_t		vsa_aclentsz;	/* ACE size in bytes of vsa_aclentp */
} vsecattr_t;

#define	AT_TYPE		0x00001
#define	AT_MODE		0x00002
#define	AT_UID		0x00004
#define	AT_GID		0x00008
#define	AT_FSID		0x00010
#define	AT_NODEID	0x00020
#define	AT_NLINK	0x00040
#define	AT_SIZE		0x00080
#define	AT_ATIME	0x00100
#define	AT_MTIME	0x00200
#define	AT_CTIME	0x00400
#define	AT_RDEV		0x00800
#define	AT_BLKSIZE	0x01000
#define	AT_NBLOCKS	0x02000
#define	AT_SEQ		0x08000
#define	AT_XVATTR	0x10000

#define	CRCREAT		0

extern int fop_getattr(vnode_t *vp, vattr_t *vap);

#define	VOP_CLOSE(vp, f, c, o, cr, ct)	vn_close(vp)
#define	VOP_PUTPAGE(vp, of, sz, fl, cr, ct)	0
#define	VOP_GETATTR(vp, vap, fl, cr, ct)  fop_getattr((vp), (vap));

#define	VOP_FSYNC(vp, f, cr, ct)	fsync((vp)->v_fd)

#define	VN_RELE(vp)	vn_close(vp)

extern int vn_open(char *path, int x1, int oflags, int mode, vnode_t **vpp,
    int x2, int x3);
extern int vn_openat(char *path, int x1, int oflags, int mode, vnode_t **vpp,
    int x2, int x3, vnode_t *vp, int fd);
extern int vn_rdwr(int uio, vnode_t *vp, void *addr, ssize_t len,
    offset_t offset, int x1, int x2, rlim64_t x3, void *x4, ssize_t *residp);
extern void vn_close(vnode_t *vp);

#define	vn_remove(path, x1, x2)		remove(path)
#define	vn_rename(from, to, seg)	rename((from), (to))
#define	vn_is_readonly(vp)		B_FALSE

extern vnode_t *rootdir;

#include <sys/file.h>		/* for FREAD, FWRITE, etc */

/*
 * Random stuff
 */
#define	ddi_get_lbolt()		(gethrtime() >> 23)
#define	ddi_get_lbolt64()	(gethrtime() >> 23)
#define	hz	119	/* frequency when using gethrtime() >> 23 for lbolt */

#define	ddi_time_before(a, b)		(a < b)
#define	ddi_time_after(a, b)		ddi_time_before(b, a)
#define	ddi_time_before_eq(a, b)	(!ddi_time_after(a, b))
#define	ddi_time_after_eq(a, b)		ddi_time_before_eq(b, a)

#define	ddi_time_before64(a, b)		(a < b)
#define	ddi_time_after64(a, b)		ddi_time_before64(b, a)
#define	ddi_time_before_eq64(a, b)	(!ddi_time_after64(a, b))
#define	ddi_time_after_eq64(a, b)	ddi_time_before_eq64(b, a)

extern void delay(clock_t ticks);

#define	SEC_TO_TICK(sec)	((sec) * hz)
#define	MSEC_TO_TICK(msec)	((msec) / (MILLISEC / hz))
#define	USEC_TO_TICK(usec)	((usec) / (MICROSEC / hz))
#define	NSEC_TO_TICK(usec)	((usec) / (NANOSEC / hz))

#define	gethrestime_sec() time(NULL)
#define	gethrestime(t) \
	do {\
		(t)->tv_sec = gethrestime_sec();\
		(t)->tv_nsec = 0;\
	} while (0);

#define	max_ncpus	64
#define	boot_ncpus	(sysconf(_SC_NPROCESSORS_ONLN))

/*
 * Process priorities as defined by setpriority(2) and getpriority(2).
 */
#define	minclsyspri	19
#define	maxclsyspri	-20
#define	defclsyspri	0

#define	CPU_SEQID	(pthread_self() & (max_ncpus - 1))

#define	kcred		NULL
#define	CRED()		NULL

#define	ptob(x)		((x) * PAGESIZE)

extern uint64_t physmem;

extern int highbit64(uint64_t i);
extern int random_get_bytes(uint8_t *ptr, size_t len);
extern int random_get_pseudo_bytes(uint8_t *ptr, size_t len);

extern void kernel_init(int);
extern void kernel_fini(void);

struct spa;
extern void nicenum(uint64_t num, char *buf);
extern void show_pool_stats(struct spa *);

typedef struct callb_cpr {
	kmutex_t	*cc_lockp;
} callb_cpr_t;

#define	CALLB_CPR_INIT(cp, lockp, func, name)	{		\
	(cp)->cc_lockp = lockp;					\
}

#define	CALLB_CPR_SAFE_BEGIN(cp) {				\
	ASSERT(MUTEX_HELD((cp)->cc_lockp));			\
}

#define	CALLB_CPR_SAFE_END(cp, lockp) {				\
	ASSERT(MUTEX_HELD((cp)->cc_lockp));			\
}

#define	CALLB_CPR_EXIT(cp) {					\
	ASSERT(MUTEX_HELD((cp)->cc_lockp));			\
	mutex_exit((cp)->cc_lockp);				\
}

#define	zone_dataset_visible(x, y)	(1)
#define	INGLOBALZONE(z)			(1)

extern char *kmem_vasprintf(const char *fmt, va_list adx);
extern char *kmem_asprintf(const char *fmt, ...);
#define	strfree(str) kmem_free((str), strlen(str) + 1)

/*
 * Hostname information
 */
extern char hw_serial[];	/* for userland-emulated hostid access */
extern int ddi_strtoul(const char *str, char **nptr, int base,
    unsigned long *result);

extern int ddi_strtoull(const char *str, char **nptr, int base,
    u_longlong_t *result);

typedef struct utsname	utsname_t;
extern utsname_t *utsname(void);

/* ZFS Boot Related stuff. */

struct _buf {
	intptr_t	_fd;
};

struct bootstat {
	uint64_t st_size;
};

typedef struct ace_object {
	uid_t		a_who;
	uint32_t	a_access_mask;
	uint16_t	a_flags;
	uint16_t	a_type;
	uint8_t		a_obj_type[16];
	uint8_t		a_inherit_obj_type[16];
} ace_object_t;


#define	ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE	0x05
#define	ACE_ACCESS_DENIED_OBJECT_ACE_TYPE	0x06
#define	ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE	0x07
#define	ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE	0x08

extern struct _buf *kobj_open_file(char *name);
extern int kobj_read_file(struct _buf *file, char *buf, unsigned size,
    unsigned off);
extern void kobj_close_file(struct _buf *file);
extern int kobj_get_filesize(struct _buf *file, uint64_t *size);
extern int zfs_secpolicy_snapshot_perms(const char *name, cred_t *cr);
extern int zfs_secpolicy_rename_perms(const char *from, const char *to,
    cred_t *cr);
extern int zfs_secpolicy_destroy_perms(const char *name, cred_t *cr);
extern zoneid_t getzoneid(void);

/* SID stuff */
typedef struct ksiddomain {
	uint_t	kd_ref;
	uint_t	kd_len;
	char	*kd_name;
} ksiddomain_t;

ksiddomain_t *ksid_lookupdomain(const char *);
void ksiddomain_rele(ksiddomain_t *);

#define	DDI_SLEEP	KM_SLEEP
#define	ddi_log_sysevent(_a, _b, _c, _d, _e, _f, _g) \
	sysevent_post_event(_c, _d, _b, "libzpool", _e, _f)

#define	zfs_sleep_until(wakeup)						\
	do {								\
		hrtime_t delta = wakeup - gethrtime();			\
		struct timespec ts;					\
		ts.tv_sec = delta / NANOSEC;				\
		ts.tv_nsec = delta % NANOSEC;				\
		(void) nanosleep(&ts, NULL);				\
	} while (0)

typedef int fstrans_cookie_t;

extern fstrans_cookie_t spl_fstrans_mark(void);
extern void spl_fstrans_unmark(fstrans_cookie_t);
extern int spl_fstrans_check(void);

#endif /* _KERNEL */
#endif	/* _SYS_ZFS_CONTEXT_H */
                                                                                                                                                                                                                                                                                                                                                                      usr/src/zfs-0.6.5.9/include/sys/zfs_ctldir.h                                                        0100644 0000000 0000000 00000007535 13045171016 017047  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (C) 2011 Lawrence Livermore National Security, LLC.
 * Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
 * LLNL-CODE-403049.
 * Rewritten for Linux by:
 *   Rohan Puri <rohan.puri15@gmail.com>
 *   Brian Behlendorf <behlendorf1@llnl.gov>
 */

#ifndef	_ZFS_CTLDIR_H
#define	_ZFS_CTLDIR_H

#include <sys/vnode.h>
#include <sys/pathname.h>
#include <sys/zfs_vfsops.h>
#include <sys/zfs_znode.h>

#define	ZFS_CTLDIR_NAME		".zfs"
#define	ZFS_SNAPDIR_NAME	"snapshot"
#define	ZFS_SHAREDIR_NAME	"shares"

#define	zfs_has_ctldir(zdp)	\
	((zdp)->z_id == ZTOZSB(zdp)->z_root && \
	(ZTOZSB(zdp)->z_ctldir != NULL))
#define	zfs_show_ctldir(zdp)	\
	(zfs_has_ctldir(zdp) && \
	(ZTOZSB(zdp)->z_show_ctldir))

extern int zfs_expire_snapshot;

/* zfsctl generic functions */
extern int zfsctl_create(zfs_sb_t *zsb);
extern void zfsctl_destroy(zfs_sb_t *zsb);
extern struct inode *zfsctl_root(znode_t *zp);
extern void zfsctl_init(void);
extern void zfsctl_fini(void);
extern boolean_t zfsctl_is_node(struct inode *ip);
extern boolean_t zfsctl_is_snapdir(struct inode *ip);
extern int zfsctl_fid(struct inode *ip, fid_t *fidp);

/* zfsctl '.zfs' functions */
extern int zfsctl_root_lookup(struct inode *dip, char *name,
    struct inode **ipp, int flags, cred_t *cr, int *direntflags,
    pathname_t *realpnp);

/* zfsctl '.zfs/snapshot' functions */
extern int zfsctl_snapdir_lookup(struct inode *dip, char *name,
    struct inode **ipp, int flags, cred_t *cr, int *direntflags,
    pathname_t *realpnp);
extern int zfsctl_snapdir_rename(struct inode *sdip, char *sname,
    struct inode *tdip, char *tname, cred_t *cr, int flags);
extern int zfsctl_snapdir_remove(struct inode *dip, char *name, cred_t *cr,
    int flags);
extern int zfsctl_snapdir_mkdir(struct inode *dip, char *dirname, vattr_t *vap,
    struct inode **ipp, cred_t *cr, int flags);
extern void zfsctl_snapdir_inactive(struct inode *ip);
extern int zfsctl_snapshot_mount(struct path *path, int flags);
extern int zfsctl_snapshot_unmount(char *snapname, int flags);
extern int zfsctl_snapshot_unmount_delay(spa_t *spa, uint64_t objsetid,
    int delay);
extern int zfsctl_lookup_objset(struct super_block *sb, uint64_t objsetid,
    zfs_sb_t **zsb);

/* zfsctl '.zfs/shares' functions */
extern int zfsctl_shares_lookup(struct inode *dip, char *name,
    struct inode **ipp, int flags, cred_t *cr, int *direntflags,
    pathname_t *realpnp);

/*
 * These inodes numbers are reserved for the .zfs control directory.
 * It is important that they be no larger that 48-bits because only
 * 6 bytes are reserved in the NFS file handle for the object number.
 * However, they should be as large as possible to avoid conflicts
 * with the objects which are assigned monotonically by the dmu.
 */
#define	ZFSCTL_INO_ROOT		0x0000FFFFFFFFFFFFULL
#define	ZFSCTL_INO_SHARES	0x0000FFFFFFFFFFFEULL
#define	ZFSCTL_INO_SNAPDIR	0x0000FFFFFFFFFFFDULL
#define	ZFSCTL_INO_SNAPDIRS	0x0000FFFFFFFFFFFCULL

#define	ZFSCTL_EXPIRE_SNAPSHOT	300

#endif	/* _ZFS_CTLDIR_H */
                                                                                                                                                                   usr/src/zfs-0.6.5.9/include/sys/zfs_debug.h                                                         0100644 0000000 0000000 00000004175 13045171016 016651  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 */

#ifndef _SYS_ZFS_DEBUG_H
#define	_SYS_ZFS_DEBUG_H

#ifdef	__cplusplus
extern "C" {
#endif

#ifndef TRUE
#define	TRUE 1
#endif

#ifndef FALSE
#define	FALSE 0
#endif

extern int zfs_flags;
extern int zfs_recover;
extern int zfs_free_leak_on_eio;

#define	ZFS_DEBUG_DPRINTF		(1<<0)
#define	ZFS_DEBUG_DBUF_VERIFY		(1<<1)
#define	ZFS_DEBUG_DNODE_VERIFY		(1<<2)
#define	ZFS_DEBUG_SNAPNAMES		(1<<3)
#define	ZFS_DEBUG_MODIFY		(1<<4)
#define	ZFS_DEBUG_SPA			(1<<5)
#define	ZFS_DEBUG_ZIO_FREE		(1<<6)
#define	ZFS_DEBUG_HISTOGRAM_VERIFY	(1<<7)

extern void __dprintf(const char *file, const char *func,
    int line, const char *fmt, ...);
#define	dprintf(...) \
	__dprintf(__FILE__, __func__, __LINE__, __VA_ARGS__)
#define	zfs_dbgmsg(...) \
	__dprintf(__FILE__, __func__, __LINE__, __VA_ARGS__)

extern void zfs_panic_recover(const char *fmt, ...);

typedef struct zfs_dbgmsg {
	list_node_t zdm_node;
	time_t zdm_timestamp;
	int zdm_size;
	char zdm_msg[1]; /* variable length allocation */
} zfs_dbgmsg_t;

extern void zfs_dbgmsg_init(void);
extern void zfs_dbgmsg_fini(void);

#ifndef _KERNEL
extern int dprintf_find_string(const char *string);
#endif

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_ZFS_DEBUG_H */
                                                                                                                                                                                                                                                                                                                                                                                                   usr/src/zfs-0.6.5.9/include/sys/zfs_delay.h                                                         0100644 0000000 0000000 00000002404 13045171016 016652  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

#ifndef	_SYS_FS_ZFS_DELAY_H
#define	_SYS_FS_ZFS_DELAY_H

#include <linux/delay_compat.h>

/*
 * Generic wrapper to sleep until a given time.
 */
#define	zfs_sleep_until(wakeup)						\
	do {								\
		hrtime_t delta = wakeup - gethrtime();			\
									\
		if (delta > 0) {					\
			unsigned long delta_us;				\
			delta_us = delta / (NANOSEC / MICROSEC);	\
			usleep_range(delta_us, delta_us + 100);		\
		}							\
	} while (0)

#endif	/* _SYS_FS_ZFS_DELAY_H */
                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/zfs_dir.h                                                           0100644 0000000 0000000 00000005317 13045171016 016340  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_SYS_FS_ZFS_DIR_H
#define	_SYS_FS_ZFS_DIR_H

#include <sys/pathname.h>
#include <sys/dmu.h>
#include <sys/zfs_znode.h>

#ifdef	__cplusplus
extern "C" {
#endif

/* zfs_dirent_lock() flags */
#define	ZNEW		0x0001		/* entry should not exist */
#define	ZEXISTS		0x0002		/* entry should exist */
#define	ZSHARED		0x0004		/* shared access (zfs_dirlook()) */
#define	ZXATTR		0x0008		/* we want the xattr dir */
#define	ZRENAMING	0x0010		/* znode is being renamed */
#define	ZCILOOK		0x0020		/* case-insensitive lookup requested */
#define	ZCIEXACT	0x0040		/* c-i requires c-s match (rename) */
#define	ZHAVELOCK	0x0080		/* z_name_lock is already held */

/* mknode flags */
#define	IS_ROOT_NODE	0x01		/* create a root node */
#define	IS_XATTR	0x02		/* create an extended attribute node */

extern int zfs_dirent_lock(zfs_dirlock_t **, znode_t *, char *, znode_t **,
    int, int *, pathname_t *);
extern void zfs_dirent_unlock(zfs_dirlock_t *);
extern int zfs_link_create(zfs_dirlock_t *, znode_t *, dmu_tx_t *, int);
extern int zfs_link_destroy(zfs_dirlock_t *, znode_t *, dmu_tx_t *, int,
    boolean_t *);
extern int zfs_dirlook(znode_t *, char *, struct inode **, int, int *,
    pathname_t *);
extern void zfs_mknode(znode_t *, vattr_t *, dmu_tx_t *, cred_t *,
    uint_t, znode_t **, zfs_acl_ids_t *);
extern void zfs_rmnode(znode_t *);
extern void zfs_dl_name_switch(zfs_dirlock_t *dl, char *new, char **old);
extern boolean_t zfs_dirempty(znode_t *);
extern void zfs_unlinked_add(znode_t *, dmu_tx_t *);
extern void zfs_unlinked_drain(zfs_sb_t *);
extern int zfs_sticky_remove_access(znode_t *, znode_t *, cred_t *cr);
extern int zfs_get_xattrdir(znode_t *, struct inode **, cred_t *, int);
extern int zfs_make_xattrdir(znode_t *, vattr_t *, struct inode **, cred_t *);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_FS_ZFS_DIR_H */
                                                                                                                                                                                                                                                                                                                 usr/src/zfs-0.6.5.9/include/sys/zfs_fuid.h                                                          0100644 0000000 0000000 00000010264 13045171016 016506  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_SYS_FS_ZFS_FUID_H
#define	_SYS_FS_ZFS_FUID_H

#ifdef _KERNEL
#include <sys/kidmap.h>
#include <sys/sid.h>
#include <sys/dmu.h>
#include <sys/zfs_vfsops.h>
#endif
#include <sys/avl.h>
#include <sys/list.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef enum {
	ZFS_OWNER,
	ZFS_GROUP,
	ZFS_ACE_USER,
	ZFS_ACE_GROUP
} zfs_fuid_type_t;

/*
 * Estimate space needed for one more fuid table entry.
 * for now assume its current size + 1K
 */
#define	FUID_SIZE_ESTIMATE(z) ((z)->z_fuid_size + (SPA_MINBLOCKSIZE << 1))

#define	FUID_INDEX(x)	((x) >> 32)
#define	FUID_RID(x)	((x) & 0xffffffff)
#define	FUID_ENCODE(idx, rid) (((uint64_t)(idx) << 32) | (rid))
/*
 * FUIDs cause problems for the intent log
 * we need to replay the creation of the FUID,
 * but we can't count on the idmapper to be around
 * and during replay the FUID index may be different than
 * before.  Also, if an ACL has 100 ACEs and 12 different
 * domains we don't want to log 100 domain strings, but rather
 * just the unique 12.
 */

/*
 * The FUIDs in the log will index into
 * domain string table and the bottom half will be the rid.
 * Used for mapping ephemeral uid/gid during ACL setting to FUIDs
 */
typedef struct zfs_fuid {
	list_node_t 	z_next;
	uint64_t 	z_id;		/* uid/gid being converted to fuid */
	uint64_t	z_domidx;	/* index in AVL domain table */
	uint64_t	z_logfuid;	/* index for domain in log */
} zfs_fuid_t;

/* list of unique domains */
typedef struct zfs_fuid_domain {
	list_node_t	z_next;
	uint64_t	z_domidx;	/* AVL tree idx */
	const char	*z_domain;	/* domain string */
} zfs_fuid_domain_t;

/*
 * FUID information necessary for logging create, setattr, and setacl.
 */
typedef struct zfs_fuid_info {
	list_t	z_fuids;
	list_t	z_domains;
	uint64_t z_fuid_owner;
	uint64_t z_fuid_group;
	char **z_domain_table;  /* Used during replay */
	uint32_t z_fuid_cnt;	/* How many fuids in z_fuids */
	uint32_t z_domain_cnt;	/* How many domains */
	size_t	z_domain_str_sz; /* len of domain strings z_domain list */
} zfs_fuid_info_t;

#ifdef _KERNEL
struct znode;
extern uid_t zfs_fuid_map_id(zfs_sb_t *, uint64_t, cred_t *, zfs_fuid_type_t);
extern void zfs_fuid_node_add(zfs_fuid_info_t **, const char *, uint32_t,
    uint64_t, uint64_t, zfs_fuid_type_t);
extern void zfs_fuid_destroy(zfs_sb_t *);
extern uint64_t zfs_fuid_create_cred(zfs_sb_t *, zfs_fuid_type_t,
    cred_t *, zfs_fuid_info_t **);
extern uint64_t zfs_fuid_create(zfs_sb_t *, uint64_t, cred_t *, zfs_fuid_type_t,
    zfs_fuid_info_t **);
extern void zfs_fuid_map_ids(struct znode *zp, cred_t *cr,
    uid_t *uid, uid_t *gid);
extern zfs_fuid_info_t *zfs_fuid_info_alloc(void);
extern void zfs_fuid_info_free(zfs_fuid_info_t *);
extern boolean_t zfs_groupmember(zfs_sb_t *, uint64_t, cred_t *);
void zfs_fuid_sync(zfs_sb_t *, dmu_tx_t *);
extern int zfs_fuid_find_by_domain(zfs_sb_t *, const char *domain,
    char **retdomain, boolean_t addok);
extern const char *zfs_fuid_find_by_idx(zfs_sb_t *zsb, uint32_t idx);
extern void zfs_fuid_txhold(zfs_sb_t *zsb, dmu_tx_t *tx);
#endif

char *zfs_fuid_idx_domain(avl_tree_t *, uint32_t);
void zfs_fuid_avl_tree_create(avl_tree_t *, avl_tree_t *);
uint64_t zfs_fuid_table_load(objset_t *, uint64_t, avl_tree_t *, avl_tree_t *);
void zfs_fuid_table_destroy(avl_tree_t *, avl_tree_t *);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_FS_ZFS_FUID_H */
                                                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/zfs_ioctl.h                                                         0100644 0000000 0000000 00000026515 13045171016 016677  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef	_SYS_ZFS_IOCTL_H
#define	_SYS_ZFS_IOCTL_H

#include <sys/cred.h>
#include <sys/dmu.h>
#include <sys/zio.h>
#include <sys/dsl_deleg.h>
#include <sys/spa.h>
#include <sys/zfs_stat.h>

#ifdef _KERNEL
#include <sys/nvpair.h>
#endif	/* _KERNEL */

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * The structures in this file are passed between userland and the
 * kernel.  Userland may be running a 32-bit process, while the kernel
 * is 64-bit.  Therefore, these structures need to compile the same in
 * 32-bit and 64-bit.  This means not using type "long", and adding
 * explicit padding so that the 32-bit structure will not be packed more
 * tightly than the 64-bit structure (which requires 64-bit alignment).
 */

/*
 * Property values for snapdir
 */
#define	ZFS_SNAPDIR_HIDDEN		0
#define	ZFS_SNAPDIR_VISIBLE		1

/*
 * Property values for snapdev
 */
#define	ZFS_SNAPDEV_HIDDEN		0
#define	ZFS_SNAPDEV_VISIBLE		1
/*
 * Property values for acltype
 */
#define	ZFS_ACLTYPE_OFF			0
#define	ZFS_ACLTYPE_POSIXACL		1

/*
 * Field manipulation macros for the drr_versioninfo field of the
 * send stream header.
 */

/*
 * Header types for zfs send streams.
 */
typedef enum drr_headertype {
	DMU_SUBSTREAM = 0x1,
	DMU_COMPOUNDSTREAM = 0x2
} drr_headertype_t;

#define	DMU_GET_STREAM_HDRTYPE(vi)	BF64_GET((vi), 0, 2)
#define	DMU_SET_STREAM_HDRTYPE(vi, x)	BF64_SET((vi), 0, 2, x)

#define	DMU_GET_FEATUREFLAGS(vi)	BF64_GET((vi), 2, 30)
#define	DMU_SET_FEATUREFLAGS(vi, x)	BF64_SET((vi), 2, 30, x)

/*
 * Feature flags for zfs send streams (flags in drr_versioninfo)
 */

#define	DMU_BACKUP_FEATURE_DEDUP		(1<<0)
#define	DMU_BACKUP_FEATURE_DEDUPPROPS		(1<<1)
#define	DMU_BACKUP_FEATURE_SA_SPILL		(1<<2)
/* flags #3 - #15 are reserved for incompatible closed-source implementations */
#define	DMU_BACKUP_FEATURE_EMBED_DATA		(1<<16)
#define	DMU_BACKUP_FEATURE_EMBED_DATA_LZ4	(1<<17)
/* flag #18 is reserved for a Delphix feature */
#define	DMU_BACKUP_FEATURE_LARGE_BLOCKS		(1<<19)

/*
 * Mask of all supported backup features
 */
#define	DMU_BACKUP_FEATURE_MASK	(DMU_BACKUP_FEATURE_DEDUP | \
    DMU_BACKUP_FEATURE_DEDUPPROPS | DMU_BACKUP_FEATURE_SA_SPILL | \
    DMU_BACKUP_FEATURE_EMBED_DATA | DMU_BACKUP_FEATURE_EMBED_DATA_LZ4 | \
    DMU_BACKUP_FEATURE_LARGE_BLOCKS)

/* Are all features in the given flag word currently supported? */
#define	DMU_STREAM_SUPPORTED(x)	(!((x) & ~DMU_BACKUP_FEATURE_MASK))

/*
 * The drr_versioninfo field of the dmu_replay_record has the
 * following layout:
 *
 *	64	56	48	40	32	24	16	8	0
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 *  	|		reserved	|        feature-flags	    |C|S|
 *	+-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * The low order two bits indicate the header type: SUBSTREAM (0x1)
 * or COMPOUNDSTREAM (0x2).  Using two bits for this is historical:
 * this field used to be a version number, where the two version types
 * were 1 and 2.  Using two bits for this allows earlier versions of
 * the code to be able to recognize send streams that don't use any
 * of the features indicated by feature flags.
 */

#define	DMU_BACKUP_MAGIC 0x2F5bacbacULL

#define	DRR_FLAG_CLONE		(1<<0)
#define	DRR_FLAG_CI_DATA	(1<<1)

/*
 * flags in the drr_checksumflags field in the DRR_WRITE and
 * DRR_WRITE_BYREF blocks
 */
#define	DRR_CHECKSUM_DEDUP	(1<<0)

#define	DRR_IS_DEDUP_CAPABLE(flags)	((flags) & DRR_CHECKSUM_DEDUP)

/*
 * zfs ioctl command structure
 */
typedef struct dmu_replay_record {
	enum {
		DRR_BEGIN, DRR_OBJECT, DRR_FREEOBJECTS,
		DRR_WRITE, DRR_FREE, DRR_END, DRR_WRITE_BYREF,
		DRR_SPILL, DRR_WRITE_EMBEDDED, DRR_NUMTYPES
	} drr_type;
	uint32_t drr_payloadlen;
	union {
		struct drr_begin {
			uint64_t drr_magic;
			uint64_t drr_versioninfo; /* was drr_version */
			uint64_t drr_creation_time;
			dmu_objset_type_t drr_type;
			uint32_t drr_flags;
			uint64_t drr_toguid;
			uint64_t drr_fromguid;
			char drr_toname[MAXNAMELEN];
		} drr_begin;
		struct drr_end {
			zio_cksum_t drr_checksum;
			uint64_t drr_toguid;
		} drr_end;
		struct drr_object {
			uint64_t drr_object;
			dmu_object_type_t drr_type;
			dmu_object_type_t drr_bonustype;
			uint32_t drr_blksz;
			uint32_t drr_bonuslen;
			uint8_t drr_checksumtype;
			uint8_t drr_compress;
			uint8_t drr_pad[6];
			uint64_t drr_toguid;
			/* bonus content follows */
		} drr_object;
		struct drr_freeobjects {
			uint64_t drr_firstobj;
			uint64_t drr_numobjs;
			uint64_t drr_toguid;
		} drr_freeobjects;
		struct drr_write {
			uint64_t drr_object;
			dmu_object_type_t drr_type;
			uint32_t drr_pad;
			uint64_t drr_offset;
			uint64_t drr_length;
			uint64_t drr_toguid;
			uint8_t drr_checksumtype;
			uint8_t drr_checksumflags;
			uint8_t drr_pad2[6];
			ddt_key_t drr_key; /* deduplication key */
			/* content follows */
		} drr_write;
		struct drr_free {
			uint64_t drr_object;
			uint64_t drr_offset;
			uint64_t drr_length;
			uint64_t drr_toguid;
		} drr_free;
		struct drr_write_byref {
			/* where to put the data */
			uint64_t drr_object;
			uint64_t drr_offset;
			uint64_t drr_length;
			uint64_t drr_toguid;
			/* where to find the prior copy of the data */
			uint64_t drr_refguid;
			uint64_t drr_refobject;
			uint64_t drr_refoffset;
			/* properties of the data */
			uint8_t drr_checksumtype;
			uint8_t drr_checksumflags;
			uint8_t drr_pad2[6];
			ddt_key_t drr_key; /* deduplication key */
		} drr_write_byref;
		struct drr_spill {
			uint64_t drr_object;
			uint64_t drr_length;
			uint64_t drr_toguid;
			uint64_t drr_pad[4]; /* needed for crypto */
			/* spill data follows */
		} drr_spill;
		struct drr_write_embedded {
			uint64_t drr_object;
			uint64_t drr_offset;
			/* logical length, should equal blocksize */
			uint64_t drr_length;
			uint64_t drr_toguid;
			uint8_t drr_compression;
			uint8_t drr_etype;
			uint8_t drr_pad[6];
			uint32_t drr_lsize; /* uncompressed size of payload */
			uint32_t drr_psize; /* compr. (real) size of payload */
			/* (possibly compressed) content follows */
		} drr_write_embedded;
	} drr_u;
} dmu_replay_record_t;

/* diff record range types */
typedef enum diff_type {
	DDR_NONE = 0x1,
	DDR_INUSE = 0x2,
	DDR_FREE = 0x4
} diff_type_t;

/*
 * The diff reports back ranges of free or in-use objects.
 */
typedef struct dmu_diff_record {
	uint64_t ddr_type;
	uint64_t ddr_first;
	uint64_t ddr_last;
} dmu_diff_record_t;

typedef struct zinject_record {
	uint64_t	zi_objset;
	uint64_t	zi_object;
	uint64_t	zi_start;
	uint64_t	zi_end;
	uint64_t	zi_guid;
	uint32_t	zi_level;
	uint32_t	zi_error;
	uint64_t	zi_type;
	uint32_t	zi_freq;
	uint32_t	zi_failfast;
	char		zi_func[MAXNAMELEN];
	uint32_t	zi_iotype;
	int32_t		zi_duration;
	uint64_t	zi_timer;
	uint32_t	zi_cmd;
	uint32_t	zi_pad;
} zinject_record_t;

#define	ZINJECT_NULL		0x1
#define	ZINJECT_FLUSH_ARC	0x2
#define	ZINJECT_UNLOAD_SPA	0x4

#define	ZEVENT_NONE		0x0
#define	ZEVENT_NONBLOCK		0x1
#define	ZEVENT_SIZE		1024

#define	ZEVENT_SEEK_START	0
#define	ZEVENT_SEEK_END		UINT64_MAX

typedef enum zinject_type {
	ZINJECT_UNINITIALIZED,
	ZINJECT_DATA_FAULT,
	ZINJECT_DEVICE_FAULT,
	ZINJECT_LABEL_FAULT,
	ZINJECT_IGNORED_WRITES,
	ZINJECT_PANIC,
	ZINJECT_DELAY_IO,
} zinject_type_t;

typedef struct zfs_share {
	uint64_t	z_exportdata;
	uint64_t	z_sharedata;
	uint64_t	z_sharetype;	/* 0 = share, 1 = unshare */
	uint64_t	z_sharemax;  /* max length of share string */
} zfs_share_t;

/*
 * ZFS file systems may behave the usual, POSIX-compliant way, where
 * name lookups are case-sensitive.  They may also be set up so that
 * all the name lookups are case-insensitive, or so that only some
 * lookups, the ones that set an FIGNORECASE flag, are case-insensitive.
 */
typedef enum zfs_case {
	ZFS_CASE_SENSITIVE,
	ZFS_CASE_INSENSITIVE,
	ZFS_CASE_MIXED
} zfs_case_t;

typedef struct zfs_cmd {
	char		zc_name[MAXPATHLEN];	/* name of pool or dataset */
	uint64_t	zc_nvlist_src;		/* really (char *) */
	uint64_t	zc_nvlist_src_size;
	uint64_t	zc_nvlist_dst;		/* really (char *) */
	uint64_t	zc_nvlist_dst_size;
	boolean_t	zc_nvlist_dst_filled;	/* put an nvlist in dst? */
	int		zc_pad2;

	/*
	 * The following members are for legacy ioctls which haven't been
	 * converted to the new method.
	 */
	uint64_t	zc_history;		/* really (char *) */
	char		zc_value[MAXPATHLEN * 2];
	char		zc_string[MAXNAMELEN];
	uint64_t	zc_guid;
	uint64_t	zc_nvlist_conf;		/* really (char *) */
	uint64_t	zc_nvlist_conf_size;
	uint64_t	zc_cookie;
	uint64_t	zc_objset_type;
	uint64_t	zc_perm_action;
	uint64_t	zc_history_len;
	uint64_t	zc_history_offset;
	uint64_t	zc_obj;
	uint64_t	zc_iflags;		/* internal to zfs(7fs) */
	zfs_share_t	zc_share;
	dmu_objset_stats_t zc_objset_stats;
	struct drr_begin zc_begin_record;
	zinject_record_t zc_inject_record;
	uint32_t	zc_defer_destroy;
	uint32_t	zc_flags;
	uint64_t	zc_action_handle;
	int		zc_cleanup_fd;
	uint8_t		zc_simple;
	uint8_t		zc_pad[3];		/* alignment */
	uint64_t	zc_sendobj;
	uint64_t	zc_fromobj;
	uint64_t	zc_createtxg;
	zfs_stat_t	zc_stat;
} zfs_cmd_t;

typedef struct zfs_useracct {
	char zu_domain[256];
	uid_t zu_rid;
	uint32_t zu_pad;
	uint64_t zu_space;
} zfs_useracct_t;

#define	ZFSDEV_MAX_MINOR	(1 << 16)
#define	ZFS_MIN_MINOR	(ZFSDEV_MAX_MINOR + 1)

#define	ZPOOL_EXPORT_AFTER_SPLIT 0x1

#ifdef _KERNEL

typedef struct zfs_creat {
	nvlist_t	*zct_zplprops;
	nvlist_t	*zct_props;
} zfs_creat_t;

extern int zfs_secpolicy_snapshot_perms(const char *name, cred_t *cr);
extern int zfs_secpolicy_rename_perms(const char *from,
    const char *to, cred_t *cr);
extern int zfs_secpolicy_destroy_perms(const char *name, cred_t *cr);
extern int zfs_unmount_snap(const char *);
extern void zfs_destroy_unmount_origin(const char *);

extern boolean_t dataset_name_hidden(const char *name);

enum zfsdev_state_type {
	ZST_ONEXIT,
	ZST_ZEVENT,
	ZST_ALL,
};

/*
 * The zfsdev_state_t structure is managed as a singly-linked list
 * from which items are never deleted.  This allows for lock-free
 * reading of the list so long as assignments to the zs_next and
 * reads from zs_minor are performed atomically.  Empty items are
 * indicated by storing -1 into zs_minor.
 */
typedef struct zfsdev_state {
	struct zfsdev_state	*zs_next;	/* next zfsdev_state_t link */
	struct file		*zs_file;	/* associated file struct */
	minor_t			zs_minor;	/* made up minor number */
	void			*zs_onexit;	/* onexit data */
	void			*zs_zevent;	/* zevent data */
} zfsdev_state_t;

extern void *zfsdev_get_state(minor_t minor, enum zfsdev_state_type which);
extern int zfsdev_getminor(struct file *filp, minor_t *minorp);
extern minor_t zfsdev_minor_alloc(void);

#endif	/* _KERNEL */

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_ZFS_IOCTL_H */
                                                                                                                                                                                   usr/src/zfs-0.6.5.9/include/sys/zfs_onexit.h                                                        0100644 0000000 0000000 00000003422 13045171016 017063  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_ZFS_ONEXIT_H
#define	_SYS_ZFS_ONEXIT_H

#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

#ifdef _KERNEL

typedef struct zfs_onexit {
	kmutex_t	zo_lock;
	list_t		zo_actions;
} zfs_onexit_t;

typedef struct zfs_onexit_action_node {
	list_node_t	za_link;
	void		(*za_func)(void *);
	void		*za_data;
} zfs_onexit_action_node_t;

extern void zfs_onexit_init(zfs_onexit_t **zo);
extern void zfs_onexit_destroy(zfs_onexit_t *zo);

#endif

extern int zfs_onexit_fd_hold(int fd, minor_t *minorp);
extern void zfs_onexit_fd_rele(int fd);
extern int zfs_onexit_add_cb(minor_t minor, void (*func)(void *), void *data,
    uint64_t *action_handle);
extern int zfs_onexit_del_cb(minor_t minor, uint64_t action_handle,
    boolean_t fire);
extern int zfs_onexit_cb_data(minor_t minor, uint64_t action_handle,
    void **data);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_ZFS_ONEXIT_H */
                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/include/sys/zfs_rlock.h                                                         0100644 0000000 0000000 00000006435 13045171016 016676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_SYS_FS_ZFS_RLOCK_H
#define	_SYS_FS_ZFS_RLOCK_H

#ifdef	__cplusplus
extern "C" {
#endif

#ifdef _KERNEL

#include <sys/list.h>
#include <sys/avl.h>
#include <sys/condvar.h>

typedef enum {
	RL_READER,
	RL_WRITER,
	RL_APPEND
} rl_type_t;

typedef struct zfs_rlock {
	kmutex_t zr_mutex;	/* protects changes to zr_avl */
	avl_tree_t zr_avl;	/* avl tree of range locks */
	uint64_t *zr_size;	/* points to znode->z_size */
	uint_t *zr_blksz;	/* points to znode->z_blksz */
	uint64_t *zr_max_blksz; /* points to zsb->z_max_blksz */
} zfs_rlock_t;

typedef struct rl {
	zfs_rlock_t *r_zrl;
	avl_node_t r_node;	/* avl node link */
	uint64_t r_off;		/* file range offset */
	uint64_t r_len;		/* file range length */
	uint_t r_cnt;		/* range reference count in tree */
	rl_type_t r_type;	/* range type */
	kcondvar_t r_wr_cv;	/* cv for waiting writers */
	kcondvar_t r_rd_cv;	/* cv for waiting readers */
	uint8_t r_proxy;	/* acting for original range */
	uint8_t r_write_wanted;	/* writer wants to lock this range */
	uint8_t r_read_wanted;	/* reader wants to lock this range */
	list_node_t rl_node;	/* used for deferred release */
} rl_t;

/*
 * Lock a range (offset, length) as either shared (RL_READER)
 * or exclusive (RL_WRITER or RL_APPEND).  RL_APPEND is a special type that
 * is converted to RL_WRITER that specified to lock from the start of the
 * end of file.  Returns the range lock structure.
 */
rl_t *zfs_range_lock(zfs_rlock_t *zrl, uint64_t off, uint64_t len,
    rl_type_t type);

/* Unlock range and destroy range lock structure. */
void zfs_range_unlock(rl_t *rl);

/*
 * Reduce range locked as RW_WRITER from whole file to specified range.
 * Asserts the whole file was previously locked.
 */
void zfs_range_reduce(rl_t *rl, uint64_t off, uint64_t len);

/*
 * AVL comparison function used to order range locks
 * Locks are ordered on the start offset of the range.
 */
int zfs_range_compare(const void *arg1, const void *arg2);

static inline void
zfs_rlock_init(zfs_rlock_t *zrl)
{
	mutex_init(&zrl->zr_mutex, NULL, MUTEX_DEFAULT, NULL);
	avl_create(&zrl->zr_avl, zfs_range_compare,
	    sizeof (rl_t), offsetof(rl_t, r_node));
	zrl->zr_size = NULL;
	zrl->zr_blksz = NULL;
	zrl->zr_max_blksz = NULL;
}

static inline void
zfs_rlock_destroy(zfs_rlock_t *zrl)
{
	avl_destroy(&zrl->zr_avl);
	mutex_destroy(&zrl->zr_mutex);
}
#endif /* _KERNEL */

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_FS_ZFS_RLOCK_H */
                                                                                                                                                                                                                                   usr/src/zfs-0.6.5.9/include/sys/zfs_sa.h                                                            0100644 0000000 0000000 00000010475 13045171016 016166  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_SYS_ZFS_SA_H
#define	_SYS_ZFS_SA_H

#ifdef _KERNEL
#include <sys/types32.h>
#include <sys/list.h>
#include <sys/dmu.h>
#include <sys/zfs_acl.h>
#include <sys/zfs_znode.h>
#include <sys/sa.h>
#include <sys/zil.h>


#endif

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * This is the list of known attributes
 * to the ZPL.  The values of the actual
 * attributes are not defined by the order
 * the enums.  It is controlled by the attribute
 * registration mechanism.  Two different file system
 * could have different numeric values for the same
 * attributes.  this list is only used for dereferencing
 * into the table that will hold the actual numeric value.
 */
typedef enum zpl_attr {
	ZPL_ATIME,
	ZPL_MTIME,
	ZPL_CTIME,
	ZPL_CRTIME,
	ZPL_GEN,
	ZPL_MODE,
	ZPL_SIZE,
	ZPL_PARENT,
	ZPL_LINKS,
	ZPL_XATTR,
	ZPL_RDEV,
	ZPL_FLAGS,
	ZPL_UID,
	ZPL_GID,
	ZPL_PAD,
	ZPL_ZNODE_ACL,
	ZPL_DACL_COUNT,
	ZPL_SYMLINK,
	ZPL_SCANSTAMP,
	ZPL_DACL_ACES,
	ZPL_DXATTR,
	ZPL_END
} zpl_attr_t;

#define	ZFS_OLD_ZNODE_PHYS_SIZE	0x108
#define	ZFS_SA_BASE_ATTR_SIZE	(ZFS_OLD_ZNODE_PHYS_SIZE - \
    sizeof (zfs_acl_phys_t))

#define	SA_MODE_OFFSET		0
#define	SA_SIZE_OFFSET		8
#define	SA_GEN_OFFSET		16
#define	SA_UID_OFFSET		24
#define	SA_GID_OFFSET		32
#define	SA_PARENT_OFFSET	40

extern sa_attr_reg_t zfs_attr_table[ZPL_END + 1];
extern sa_attr_reg_t zfs_legacy_attr_table[ZPL_END + 1];

/*
 * This is a deprecated data structure that only exists for
 * dealing with file systems create prior to ZPL version 5.
 */
typedef struct znode_phys {
	uint64_t zp_atime[2];		/*  0 - last file access time */
	uint64_t zp_mtime[2];		/* 16 - last file modification time */
	uint64_t zp_ctime[2];		/* 32 - last file change time */
	uint64_t zp_crtime[2];		/* 48 - creation time */
	uint64_t zp_gen;		/* 64 - generation (txg of creation) */
	uint64_t zp_mode;		/* 72 - file mode bits */
	uint64_t zp_size;		/* 80 - size of file */
	uint64_t zp_parent;		/* 88 - directory parent (`..') */
	uint64_t zp_links;		/* 96 - number of links to file */
	uint64_t zp_xattr;		/* 104 - DMU object for xattrs */
	uint64_t zp_rdev;		/* 112 - dev_t for VBLK & VCHR files */
	uint64_t zp_flags;		/* 120 - persistent flags */
	uint64_t zp_uid;		/* 128 - file owner */
	uint64_t zp_gid;		/* 136 - owning group */
	uint64_t zp_zap;		/* 144 - extra attributes */
	uint64_t zp_pad[3];		/* 152 - future */
	zfs_acl_phys_t zp_acl;		/* 176 - 263 ACL */
	/*
	 * Data may pad out any remaining bytes in the znode buffer, eg:
	 *
	 * |<---------------------- dnode_phys (512) ------------------------>|
	 * |<-- dnode (192) --->|<----------- "bonus" buffer (320) ---------->|
	 *			|<---- znode (264) ---->|<---- data (56) ---->|
	 *
	 * At present, we use this space for the following:
	 *  - symbolic links
	 *  - 32-byte anti-virus scanstamp (regular files only)
	 */
} znode_phys_t;

#ifdef _KERNEL

#define	DXATTR_MAX_ENTRY_SIZE	(32768)
#define	DXATTR_MAX_SA_SIZE	(SPA_OLD_MAXBLOCKSIZE >> 1)

int zfs_sa_readlink(struct znode *, uio_t *);
void zfs_sa_symlink(struct znode *, char *link, int len, dmu_tx_t *);
void zfs_sa_get_scanstamp(struct znode *, xvattr_t *);
void zfs_sa_set_scanstamp(struct znode *, xvattr_t *, dmu_tx_t *);
int zfs_sa_get_xattr(struct znode *);
int zfs_sa_set_xattr(struct znode *);
void zfs_sa_upgrade(struct sa_handle  *, dmu_tx_t *);
void zfs_sa_upgrade_txholds(dmu_tx_t *, struct znode *);
void zfs_sa_init(void);
void zfs_sa_fini(void);
#endif

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_ZFS_SA_H */
                                                                                                                                                                                                   usr/src/zfs-0.6.5.9/include/sys/zfs_stat.h                                                          0100644 0000000 0000000 00000002720 13045171016 016530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_FS_ZFS_STAT_H
#define	_SYS_FS_ZFS_STAT_H

#ifdef _KERNEL
#include <sys/isa_defs.h>
#include <sys/types32.h>
#include <sys/dmu.h>
#endif

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * A limited number of zpl level stats are retrievable
 * with an ioctl.  zfs diff is the current consumer.
 */
typedef struct zfs_stat {
	uint64_t	zs_gen;
	uint64_t	zs_mode;
	uint64_t	zs_links;
	uint64_t	zs_ctime[2];
} zfs_stat_t;

extern int zfs_obj_to_stats(objset_t *osp, uint64_t obj, zfs_stat_t *sb,
    char *buf, int len);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_FS_ZFS_STAT_H */
                                                usr/src/zfs-0.6.5.9/include/sys/zfs_vfsops.h                                                        0100644 0000000 0000000 00000020530 13045171016 017074  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_FS_ZFS_VFSOPS_H
#define	_SYS_FS_ZFS_VFSOPS_H

#include <sys/isa_defs.h>
#include <sys/types32.h>
#include <sys/list.h>
#include <sys/vfs.h>
#include <sys/zil.h>
#include <sys/sa.h>
#include <sys/rrwlock.h>
#include <sys/zfs_ioctl.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct zfs_sb;
struct znode;

typedef struct zfs_mntopts {
	char		*z_osname;	/* Objset name */
	char		*z_mntpoint;	/* Primary mount point */
	uint64_t	z_xattr;
	boolean_t	z_readonly;
	boolean_t	z_do_readonly;
	boolean_t	z_setuid;
	boolean_t	z_do_setuid;
	boolean_t	z_exec;
	boolean_t	z_do_exec;
	boolean_t	z_devices;
	boolean_t	z_do_devices;
	boolean_t	z_do_xattr;
	boolean_t	z_atime;
	boolean_t	z_do_atime;
	boolean_t	z_relatime;
	boolean_t	z_do_relatime;
	boolean_t	z_nbmand;
	boolean_t	z_do_nbmand;
} zfs_mntopts_t;

typedef struct zfs_sb {
	struct super_block *z_sb;	/* generic super_block */
	struct backing_dev_info z_bdi;	/* generic backing dev info */
	struct zfs_sb	*z_parent;	/* parent fs */
	objset_t	*z_os;		/* objset reference */
	zfs_mntopts_t	*z_mntopts;	/* passed mount options */
	uint64_t	z_flags;	/* super_block flags */
	uint64_t	z_root;		/* id of root znode */
	uint64_t	z_unlinkedobj;	/* id of unlinked zapobj */
	uint64_t	z_max_blksz;	/* maximum block size for files */
	uint64_t	z_fuid_obj;	/* fuid table object number */
	uint64_t	z_fuid_size;	/* fuid table size */
	avl_tree_t	z_fuid_idx;	/* fuid tree keyed by index */
	avl_tree_t	z_fuid_domain;	/* fuid tree keyed by domain */
	krwlock_t	z_fuid_lock;	/* fuid lock */
	boolean_t	z_fuid_loaded;	/* fuid tables are loaded */
	boolean_t	z_fuid_dirty;   /* need to sync fuid table ? */
	struct zfs_fuid_info	*z_fuid_replay; /* fuid info for replay */
	zilog_t		*z_log;		/* intent log pointer */
	uint_t		z_acl_inherit;	/* acl inheritance behavior */
	uint_t		z_acl_type;	/* type of ACL usable on this FS */
	zfs_case_t	z_case;		/* case-sense */
	boolean_t	z_utf8;		/* utf8-only */
	int		z_norm;		/* normalization flags */
	boolean_t	z_atime;	/* enable atimes mount option */
	boolean_t	z_relatime;	/* enable relatime mount option */
	boolean_t	z_unmounted;	/* unmounted */
	rrmlock_t	z_teardown_lock;
	krwlock_t	z_teardown_inactive_lock;
	list_t		z_all_znodes;	/* all znodes in the fs */
	uint64_t	z_nr_znodes;	/* number of znodes in the fs */
	unsigned long	z_rollback_time; /* last online rollback time */
	unsigned long	z_snap_defer_time; /* last snapshot unmount deferal */
	kmutex_t	z_znodes_lock;	/* lock for z_all_znodes */
	arc_prune_t	*z_arc_prune;	/* called by ARC to prune caches */
	struct inode	*z_ctldir;	/* .zfs directory inode */
	boolean_t	z_show_ctldir;	/* expose .zfs in the root dir */
	boolean_t	z_issnap;	/* true if this is a snapshot */
	boolean_t	z_vscan;	/* virus scan on/off */
	boolean_t	z_use_fuids;	/* version allows fuids */
	boolean_t	z_replay;	/* set during ZIL replay */
	boolean_t	z_use_sa;	/* version allow system attributes */
	boolean_t	z_xattr_sa;	/* allow xattrs to be stores as SA */
	uint64_t	z_version;	/* ZPL version */
	uint64_t	z_shares_dir;	/* hidden shares dir */
	kmutex_t	z_lock;
	uint64_t	z_userquota_obj;
	uint64_t	z_groupquota_obj;
	uint64_t	z_replay_eof;	/* New end of file - replay only */
	sa_attr_type_t	*z_attr_table;	/* SA attr mapping->id */
	uint64_t	z_hold_size;	/* znode hold array size */
	avl_tree_t	*z_hold_trees;	/* znode hold trees */
	kmutex_t	*z_hold_locks;	/* znode hold locks */
} zfs_sb_t;

#define	ZFS_SUPER_MAGIC	0x2fc12fc1

#define	ZSB_XATTR	0x0001		/* Enable user xattrs */

/*
 * Allow a maximum number of links.  While ZFS does not internally limit
 * this the inode->i_nlink member is defined as an unsigned int.  To be
 * safe we use 2^31-1 as the limit.
 */
#define	ZFS_LINK_MAX		((1U << 31) - 1U)

/*
 * Normal filesystems (those not under .zfs/snapshot) have a total
 * file ID size limited to 12 bytes (including the length field) due to
 * NFSv2 protocol's limitation of 32 bytes for a filehandle.  For historical
 * reasons, this same limit is being imposed by the Solaris NFSv3 implementation
 * (although the NFSv3 protocol actually permits a maximum of 64 bytes).  It
 * is not possible to expand beyond 12 bytes without abandoning support
 * of NFSv2.
 *
 * For normal filesystems, we partition up the available space as follows:
 *	2 bytes		fid length (required)
 *	6 bytes		object number (48 bits)
 *	4 bytes		generation number (32 bits)
 *
 * We reserve only 48 bits for the object number, as this is the limit
 * currently defined and imposed by the DMU.
 */
typedef struct zfid_short {
	uint16_t	zf_len;
	uint8_t		zf_object[6];		/* obj[i] = obj >> (8 * i) */
	uint8_t		zf_gen[4];		/* gen[i] = gen >> (8 * i) */
} zfid_short_t;

/*
 * Filesystems under .zfs/snapshot have a total file ID size of 22 bytes
 * (including the length field).  This makes files under .zfs/snapshot
 * accessible by NFSv3 and NFSv4, but not NFSv2.
 *
 * For files under .zfs/snapshot, we partition up the available space
 * as follows:
 *	2 bytes		fid length (required)
 *	6 bytes		object number (48 bits)
 *	4 bytes		generation number (32 bits)
 *	6 bytes		objset id (48 bits)
 *	4 bytes		currently just zero (32 bits)
 *
 * We reserve only 48 bits for the object number and objset id, as these are
 * the limits currently defined and imposed by the DMU.
 */
typedef struct zfid_long {
	zfid_short_t	z_fid;
	uint8_t		zf_setid[6];		/* obj[i] = obj >> (8 * i) */
	uint8_t		zf_setgen[4];		/* gen[i] = gen >> (8 * i) */
} zfid_long_t;

#define	SHORT_FID_LEN	(sizeof (zfid_short_t) - sizeof (uint16_t))
#define	LONG_FID_LEN	(sizeof (zfid_long_t) - sizeof (uint16_t))

extern uint_t zfs_fsyncer_key;

extern int zfs_suspend_fs(zfs_sb_t *zsb);
extern int zfs_resume_fs(zfs_sb_t *zsb, const char *osname);
extern int zfs_userspace_one(zfs_sb_t *zsb, zfs_userquota_prop_t type,
    const char *domain, uint64_t rid, uint64_t *valuep);
extern int zfs_userspace_many(zfs_sb_t *zsb, zfs_userquota_prop_t type,
    uint64_t *cookiep, void *vbuf, uint64_t *bufsizep);
extern int zfs_set_userquota(zfs_sb_t *zsb, zfs_userquota_prop_t type,
    const char *domain, uint64_t rid, uint64_t quota);
extern boolean_t zfs_owner_overquota(zfs_sb_t *zsb, struct znode *,
    boolean_t isgroup);
extern boolean_t zfs_fuid_overquota(zfs_sb_t *zsb, boolean_t isgroup,
    uint64_t fuid);
extern int zfs_set_version(zfs_sb_t *zsb, uint64_t newvers);
extern int zfs_get_zplprop(objset_t *os, zfs_prop_t prop,
    uint64_t *value);
extern zfs_mntopts_t *zfs_mntopts_alloc(void);
extern void zfs_mntopts_free(zfs_mntopts_t *zmo);
extern int zfs_sb_create(const char *name, zfs_mntopts_t *zmo,
    zfs_sb_t **zsbp);
extern int zfs_sb_setup(zfs_sb_t *zsb, boolean_t mounting);
extern void zfs_sb_free(zfs_sb_t *zsb);
extern int zfs_sb_prune(struct super_block *sb, unsigned long nr_to_scan,
    int *objects);
extern int zfs_sb_teardown(zfs_sb_t *zsb, boolean_t unmounting);
extern int zfs_check_global_label(const char *dsname, const char *hexsl);
extern boolean_t zfs_is_readonly(zfs_sb_t *zsb);

extern int zfs_register_callbacks(zfs_sb_t *zsb);
extern void zfs_unregister_callbacks(zfs_sb_t *zsb);
extern int zfs_domount(struct super_block *sb, zfs_mntopts_t *zmo, int silent);
extern void zfs_preumount(struct super_block *sb);
extern int zfs_umount(struct super_block *sb);
extern int zfs_remount(struct super_block *sb, int *flags, zfs_mntopts_t *zmo);
extern int zfs_root(zfs_sb_t *zsb, struct inode **ipp);
extern int zfs_statvfs(struct dentry *dentry, struct kstatfs *statp);
extern int zfs_vget(struct super_block *sb, struct inode **ipp, fid_t *fidp);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_FS_ZFS_VFSOPS_H */
                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/sys/zfs_vnops.h                                                         0100644 0000000 0000000 00000007367 13045171016 016736  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_FS_ZFS_VNOPS_H
#define	_SYS_FS_ZFS_VNOPS_H

#include <sys/vnode.h>
#include <sys/xvattr.h>
#include <sys/uio.h>
#include <sys/cred.h>
#include <sys/fcntl.h>
#include <sys/pathname.h>
#include <sys/zpl.h>

#ifdef	__cplusplus
extern "C" {
#endif

extern int zfs_open(struct inode *ip, int mode, int flag, cred_t *cr);
extern int zfs_close(struct inode *ip, int flag, cred_t *cr);
extern int zfs_holey(struct inode *ip, int cmd, loff_t *off);
extern int zfs_read(struct inode *ip, uio_t *uio, int ioflag, cred_t *cr);
extern int zfs_write(struct inode *ip, uio_t *uio, int ioflag, cred_t *cr);
extern int zfs_access(struct inode *ip, int mode, int flag, cred_t *cr);
extern int zfs_lookup(struct inode *dip, char *nm, struct inode **ipp,
    int flags, cred_t *cr, int *direntflags, pathname_t *realpnp);
extern int zfs_create(struct inode *dip, char *name, vattr_t *vap, int excl,
    int mode, struct inode **ipp, cred_t *cr, int flag, vsecattr_t *vsecp);
extern int zfs_remove(struct inode *dip, char *name, cred_t *cr);
extern int zfs_mkdir(struct inode *dip, char *dirname, vattr_t *vap,
    struct inode **ipp, cred_t *cr, int flags, vsecattr_t *vsecp);
extern int zfs_rmdir(struct inode *dip, char *name, struct inode *cwd,
    cred_t *cr, int flags);
extern int zfs_readdir(struct inode *ip, struct dir_context *ctx, cred_t *cr);
extern int zfs_fsync(struct inode *ip, int syncflag, cred_t *cr);
extern int zfs_getattr(struct inode *ip, vattr_t *vap, int flag, cred_t *cr);
extern int zfs_getattr_fast(struct inode *ip, struct kstat *sp);
extern int zfs_setattr(struct inode *ip, vattr_t *vap, int flag, cred_t *cr);
extern int zfs_rename(struct inode *sdip, char *snm, struct inode *tdip,
    char *tnm, cred_t *cr, int flags);
extern int zfs_symlink(struct inode *dip, char *name, vattr_t *vap,
    char *link, struct inode **ipp, cred_t *cr, int flags);
extern int zfs_follow_link(struct dentry *dentry, struct nameidata *nd);
extern int zfs_readlink(struct inode *ip, uio_t *uio, cred_t *cr);
extern int zfs_link(struct inode *tdip, struct inode *sip,
    char *name, cred_t *cr);
extern void zfs_inactive(struct inode *ip);
extern int zfs_space(struct inode *ip, int cmd, flock64_t *bfp, int flag,
    offset_t offset, cred_t *cr);
extern int zfs_fid(struct inode *ip, fid_t *fidp);
extern int zfs_getsecattr(struct inode *ip, vsecattr_t *vsecp, int flag,
    cred_t *cr);
extern int zfs_setsecattr(struct inode *ip, vsecattr_t *vsecp, int flag,
    cred_t *cr);
extern int zfs_getpage(struct inode *ip, struct page *pl[], int nr_pages);
extern int zfs_putpage(struct inode *ip, struct page *pp,
    struct writeback_control *wbc);
extern int zfs_dirty_inode(struct inode *ip, int flags);
extern int zfs_map(struct inode *ip, offset_t off, caddr_t *addrp,
    size_t len, unsigned long vm_flags);
extern void zfs_iput_async(struct inode *ip);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_FS_ZFS_VNOPS_H */
                                                                                                                                                                                                                                                                         usr/src/zfs-0.6.5.9/include/sys/zfs_znode.h                                                         0100644 0000000 0000000 00000032767 13045171016 016712  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012 by Delphix. All rights reserved.
 */

#ifndef	_SYS_FS_ZFS_ZNODE_H
#define	_SYS_FS_ZFS_ZNODE_H

#ifdef _KERNEL
#include <sys/isa_defs.h>
#include <sys/types32.h>
#include <sys/attr.h>
#include <sys/list.h>
#include <sys/dmu.h>
#include <sys/sa.h>
#include <sys/zfs_vfsops.h>
#include <sys/rrwlock.h>
#include <sys/zfs_sa.h>
#include <sys/zfs_stat.h>
#include <sys/zfs_rlock.h>
#endif
#include <sys/zfs_acl.h>
#include <sys/zil.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * Additional file level attributes, that are stored
 * in the upper half of zp_flags
 */
#define	ZFS_READONLY		0x0000000100000000ull
#define	ZFS_HIDDEN		0x0000000200000000ull
#define	ZFS_SYSTEM		0x0000000400000000ull
#define	ZFS_ARCHIVE		0x0000000800000000ull
#define	ZFS_IMMUTABLE		0x0000001000000000ull
#define	ZFS_NOUNLINK		0x0000002000000000ull
#define	ZFS_APPENDONLY		0x0000004000000000ull
#define	ZFS_NODUMP		0x0000008000000000ull
#define	ZFS_OPAQUE		0x0000010000000000ull
#define	ZFS_AV_QUARANTINED	0x0000020000000000ull
#define	ZFS_AV_MODIFIED		0x0000040000000000ull
#define	ZFS_REPARSE		0x0000080000000000ull
#define	ZFS_OFFLINE		0x0000100000000000ull
#define	ZFS_SPARSE		0x0000200000000000ull

#define	ZFS_ATTR_SET(zp, attr, value, pflags, tx) \
{ \
	if (value) \
		pflags |= attr; \
	else \
		pflags &= ~attr; \
	VERIFY(0 == sa_update(zp->z_sa_hdl, SA_ZPL_FLAGS(ZTOZSB(zp)), \
	    &pflags, sizeof (pflags), tx)); \
}

/*
 * Define special zfs pflags
 */
#define	ZFS_XATTR		0x1		/* is an extended attribute */
#define	ZFS_INHERIT_ACE		0x2		/* ace has inheritable ACEs */
#define	ZFS_ACL_TRIVIAL		0x4		/* files ACL is trivial */
#define	ZFS_ACL_OBJ_ACE		0x8		/* ACL has CMPLX Object ACE */
#define	ZFS_ACL_PROTECTED	0x10		/* ACL protected */
#define	ZFS_ACL_DEFAULTED	0x20		/* ACL should be defaulted */
#define	ZFS_ACL_AUTO_INHERIT	0x40		/* ACL should be inherited */
#define	ZFS_BONUS_SCANSTAMP	0x80		/* Scanstamp in bonus area */
#define	ZFS_NO_EXECS_DENIED	0x100		/* exec was given to everyone */

#define	SA_ZPL_ATIME(z)		z->z_attr_table[ZPL_ATIME]
#define	SA_ZPL_MTIME(z)		z->z_attr_table[ZPL_MTIME]
#define	SA_ZPL_CTIME(z)		z->z_attr_table[ZPL_CTIME]
#define	SA_ZPL_CRTIME(z)	z->z_attr_table[ZPL_CRTIME]
#define	SA_ZPL_GEN(z)		z->z_attr_table[ZPL_GEN]
#define	SA_ZPL_DACL_ACES(z)	z->z_attr_table[ZPL_DACL_ACES]
#define	SA_ZPL_XATTR(z)		z->z_attr_table[ZPL_XATTR]
#define	SA_ZPL_SYMLINK(z)	z->z_attr_table[ZPL_SYMLINK]
#define	SA_ZPL_RDEV(z)		z->z_attr_table[ZPL_RDEV]
#define	SA_ZPL_SCANSTAMP(z)	z->z_attr_table[ZPL_SCANSTAMP]
#define	SA_ZPL_UID(z)		z->z_attr_table[ZPL_UID]
#define	SA_ZPL_GID(z)		z->z_attr_table[ZPL_GID]
#define	SA_ZPL_PARENT(z)	z->z_attr_table[ZPL_PARENT]
#define	SA_ZPL_LINKS(z)		z->z_attr_table[ZPL_LINKS]
#define	SA_ZPL_MODE(z)		z->z_attr_table[ZPL_MODE]
#define	SA_ZPL_DACL_COUNT(z)	z->z_attr_table[ZPL_DACL_COUNT]
#define	SA_ZPL_FLAGS(z)		z->z_attr_table[ZPL_FLAGS]
#define	SA_ZPL_SIZE(z)		z->z_attr_table[ZPL_SIZE]
#define	SA_ZPL_ZNODE_ACL(z)	z->z_attr_table[ZPL_ZNODE_ACL]
#define	SA_ZPL_DXATTR(z)	z->z_attr_table[ZPL_DXATTR]
#define	SA_ZPL_PAD(z)		z->z_attr_table[ZPL_PAD]

/*
 * Is ID ephemeral?
 */
#define	IS_EPHEMERAL(x)		(x > MAXUID)

/*
 * Should we use FUIDs?
 */
#define	USE_FUIDS(version, os)	(version >= ZPL_VERSION_FUID && \
    spa_version(dmu_objset_spa(os)) >= SPA_VERSION_FUID)
#define	USE_SA(version, os) (version >= ZPL_VERSION_SA && \
    spa_version(dmu_objset_spa(os)) >= SPA_VERSION_SA)

#define	MASTER_NODE_OBJ	1

/*
 * Special attributes for master node.
 * "userquota@" and "groupquota@" are also valid (from
 * zfs_userquota_prop_prefixes[]).
 */
#define	ZFS_FSID		"FSID"
#define	ZFS_UNLINKED_SET	"DELETE_QUEUE"
#define	ZFS_ROOT_OBJ		"ROOT"
#define	ZPL_VERSION_STR		"VERSION"
#define	ZFS_FUID_TABLES		"FUID"
#define	ZFS_SHARES_DIR		"SHARES"
#define	ZFS_SA_ATTRS		"SA_ATTRS"

/*
 * Path component length
 *
 * The generic fs code uses MAXNAMELEN to represent
 * what the largest component length is.  Unfortunately,
 * this length includes the terminating NULL.  ZFS needs
 * to tell the users via pathconf() and statvfs() what the
 * true maximum length of a component is, excluding the NULL.
 */
#define	ZFS_MAXNAMELEN	(MAXNAMELEN - 1)

/*
 * Convert mode bits (zp_mode) to BSD-style DT_* values for storing in
 * the directory entries.  On Linux systems this value is already
 * defined correctly as part of the /usr/include/dirent.h header file.
 */
#ifndef IFTODT
#define	IFTODT(mode) (((mode) & S_IFMT) >> 12)
#endif

/*
 * The directory entry has the type (currently unused on Solaris) in the
 * top 4 bits, and the object number in the low 48 bits.  The "middle"
 * 12 bits are unused.
 */
#define	ZFS_DIRENT_TYPE(de) BF64_GET(de, 60, 4)
#define	ZFS_DIRENT_OBJ(de) BF64_GET(de, 0, 48)

/*
 * Directory entry locks control access to directory entries.
 * They are used to protect creates, deletes, and renames.
 * Each directory znode has a mutex and a list of locked names.
 */
#ifdef _KERNEL
typedef struct zfs_dirlock {
	char		*dl_name;	/* directory entry being locked */
	uint32_t	dl_sharecnt;	/* 0 if exclusive, > 0 if shared */
	uint8_t		dl_namelock;	/* 1 if z_name_lock is NOT held */
	uint16_t	dl_namesize;	/* set if dl_name was allocated */
	kcondvar_t	dl_cv;		/* wait for entry to be unlocked */
	struct znode	*dl_dzp;	/* directory znode */
	struct zfs_dirlock *dl_next;	/* next in z_dirlocks list */
} zfs_dirlock_t;

typedef struct znode {
	uint64_t	z_id;		/* object ID for this znode */
	kmutex_t	z_lock;		/* znode modification lock */
	krwlock_t	z_parent_lock;	/* parent lock for directories */
	krwlock_t	z_name_lock;	/* "master" lock for dirent locks */
	zfs_dirlock_t	*z_dirlocks;	/* directory entry lock list */
	zfs_rlock_t	z_range_lock;	/* file range lock */
	uint8_t		z_unlinked;	/* file has been unlinked */
	uint8_t		z_atime_dirty;	/* atime needs to be synced */
	uint8_t		z_zn_prefetch;	/* Prefetch znodes? */
	uint8_t		z_moved;	/* Has this znode been moved? */
	uint_t		z_blksz;	/* block size in bytes */
	uint_t		z_seq;		/* modification sequence number */
	uint64_t	z_mapcnt;	/* number of pages mapped to file */
	uint64_t	z_gen;		/* generation (cached) */
	uint64_t	z_size;		/* file size (cached) */
	uint64_t	z_links;	/* file links (cached) */
	uint64_t	z_pflags;	/* pflags (cached) */
	uint64_t	z_uid;		/* uid fuid (cached) */
	uint64_t	z_gid;		/* gid fuid (cached) */
	uint32_t	z_sync_cnt;	/* synchronous open count */
	mode_t		z_mode;		/* mode (cached) */
	kmutex_t	z_acl_lock;	/* acl data lock */
	zfs_acl_t	*z_acl_cached;	/* cached acl */
	krwlock_t	z_xattr_lock;	/* xattr data lock */
	nvlist_t	*z_xattr_cached; /* cached xattrs */
	list_node_t	z_link_node;	/* all znodes in fs link */
	sa_handle_t	*z_sa_hdl;	/* handle to sa data */
	boolean_t	z_is_sa;	/* are we native sa? */
	boolean_t	z_is_mapped;	/* are we mmap'ed */
	boolean_t	z_is_ctldir;	/* are we .zfs entry */
	boolean_t	z_is_stale;	/* are we stale due to rollback? */
	struct inode	z_inode;	/* generic vfs inode */
} znode_t;

typedef struct znode_hold {
	uint64_t	zh_obj;		/* object id */
	kmutex_t	zh_lock;	/* lock serializing object access */
	avl_node_t	zh_node;	/* avl tree linkage */
	refcount_t	zh_refcount;	/* active consumer reference count */
} znode_hold_t;

/*
 * Range locking rules
 * --------------------
 * 1. When truncating a file (zfs_create, zfs_setattr, zfs_space) the whole
 *    file range needs to be locked as RL_WRITER. Only then can the pages be
 *    freed etc and zp_size reset. zp_size must be set within range lock.
 * 2. For writes and punching holes (zfs_write & zfs_space) just the range
 *    being written or freed needs to be locked as RL_WRITER.
 *    Multiple writes at the end of the file must coordinate zp_size updates
 *    to ensure data isn't lost. A compare and swap loop is currently used
 *    to ensure the file size is at least the offset last written.
 * 3. For reads (zfs_read, zfs_get_data & zfs_putapage) just the range being
 *    read needs to be locked as RL_READER. A check against zp_size can then
 *    be made for reading beyond end of file.
 */

/*
 * Convert between znode pointers and inode pointers
 */
#define	ZTOI(znode)	(&((znode)->z_inode))
#define	ITOZ(inode)	(container_of((inode), znode_t, z_inode))
#define	ZTOZSB(znode)	((zfs_sb_t *)(ZTOI(znode)->i_sb->s_fs_info))
#define	ITOZSB(inode)	((zfs_sb_t *)((inode)->i_sb->s_fs_info))

#define	S_ISDEV(mode)	(S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode))

/* Called on entry to each ZFS vnode and vfs operation  */
#define	ZFS_ENTER(zsb) \
	{ \
		rrm_enter_read(&(zsb)->z_teardown_lock, FTAG); \
		if ((zsb)->z_unmounted) { \
			ZFS_EXIT(zsb); \
			return (EIO); \
		} \
	}

/* Must be called before exiting the vop */
#define	ZFS_EXIT(zsb) \
	{ \
		rrm_exit(&(zsb)->z_teardown_lock, FTAG); \
	}

/* Verifies the znode is valid */
#define	ZFS_VERIFY_ZP(zp) \
	if ((zp)->z_sa_hdl == NULL) { \
		ZFS_EXIT(ZTOZSB(zp)); \
		return (EIO); \
	}

/*
 * Macros for dealing with dmu_buf_hold
 */
#define	ZFS_OBJ_MTX_SZ		64
#define	ZFS_OBJ_MTX_MAX		(1024 * 1024)
#define	ZFS_OBJ_HASH(zsb, obj)	((obj) & ((zsb->z_hold_size) - 1))

extern unsigned int zfs_object_mutex_size;

/* Encode ZFS stored time values from a struct timespec */
#define	ZFS_TIME_ENCODE(tp, stmp)		\
{						\
	(stmp)[0] = (uint64_t)(tp)->tv_sec;	\
	(stmp)[1] = (uint64_t)(tp)->tv_nsec;	\
}

/* Decode ZFS stored time values to a struct timespec */
#define	ZFS_TIME_DECODE(tp, stmp)		\
{						\
	(tp)->tv_sec = (time_t)(stmp)[0];		\
	(tp)->tv_nsec = (long)(stmp)[1];		\
}

/*
 * Timestamp defines
 */
#define	ACCESSED		(ATTR_ATIME)
#define	STATE_CHANGED		(ATTR_CTIME)
#define	CONTENT_MODIFIED	(ATTR_MTIME | ATTR_CTIME)

extern int	zfs_init_fs(zfs_sb_t *, znode_t **);
extern void	zfs_set_dataprop(objset_t *);
extern void	zfs_create_fs(objset_t *os, cred_t *cr, nvlist_t *,
    dmu_tx_t *tx);
extern void	zfs_tstamp_update_setup(znode_t *, uint_t, uint64_t [2],
    uint64_t [2]);
extern void	zfs_grow_blocksize(znode_t *, uint64_t, dmu_tx_t *);
extern int	zfs_freesp(znode_t *, uint64_t, uint64_t, int, boolean_t);
extern void	zfs_znode_init(void);
extern void	zfs_znode_fini(void);
extern int	zfs_znode_hold_compare(const void *, const void *);
extern int	zfs_zget(zfs_sb_t *, uint64_t, znode_t **);
extern int	zfs_rezget(znode_t *);
extern void	zfs_zinactive(znode_t *);
extern void	zfs_znode_delete(znode_t *, dmu_tx_t *);
extern void	zfs_remove_op_tables(void);
extern int	zfs_create_op_tables(void);
extern int	zfs_sync(struct super_block *, int, cred_t *);
extern dev_t	zfs_cmpldev(uint64_t);
extern int	zfs_get_zplprop(objset_t *os, zfs_prop_t prop, uint64_t *value);
extern int	zfs_get_stats(objset_t *os, nvlist_t *nv);
extern void	zfs_znode_dmu_fini(znode_t *);
extern int	zfs_inode_alloc(struct super_block *, struct inode **ip);
extern void	zfs_inode_destroy(struct inode *);
extern void	zfs_inode_update(znode_t *);
extern void	zfs_mark_inode_dirty(struct inode *);

extern void zfs_log_create(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,
    znode_t *dzp, znode_t *zp, char *name, vsecattr_t *, zfs_fuid_info_t *,
    vattr_t *vap);
extern int zfs_log_create_txtype(zil_create_t, vsecattr_t *vsecp,
    vattr_t *vap);
extern void zfs_log_remove(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,
    znode_t *dzp, char *name, uint64_t foid);
#define	ZFS_NO_OBJECT	0	/* no object id */
extern void zfs_log_link(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,
    znode_t *dzp, znode_t *zp, char *name);
extern void zfs_log_symlink(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,
    znode_t *dzp, znode_t *zp, char *name, char *link);
extern void zfs_log_rename(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,
    znode_t *sdzp, char *sname, znode_t *tdzp, char *dname, znode_t *szp);
extern void zfs_log_write(zilog_t *zilog, dmu_tx_t *tx, int txtype,
    znode_t *zp, offset_t off, ssize_t len, int ioflag,
    zil_callback_t callback, void *callback_data);
extern void zfs_log_truncate(zilog_t *zilog, dmu_tx_t *tx, int txtype,
    znode_t *zp, uint64_t off, uint64_t len);
extern void zfs_log_setattr(zilog_t *zilog, dmu_tx_t *tx, int txtype,
    znode_t *zp, vattr_t *vap, uint_t mask_applied, zfs_fuid_info_t *fuidp);
extern void zfs_log_acl(zilog_t *zilog, dmu_tx_t *tx, znode_t *zp,
    vsecattr_t *vsecp, zfs_fuid_info_t *fuidp);
extern void zfs_xvattr_set(znode_t *zp, xvattr_t *xvap, dmu_tx_t *tx);
extern void zfs_upgrade(zfs_sb_t *zsb, dmu_tx_t *tx);
extern int zfs_create_share_dir(zfs_sb_t *zsb, dmu_tx_t *tx);

#if defined(HAVE_UIO_RW)
extern caddr_t zfs_map_page(page_t *, enum seg_rw);
extern void zfs_unmap_page(page_t *, caddr_t);
#endif /* HAVE_UIO_RW */

extern zil_get_data_t zfs_get_data;
extern zil_replay_func_t zfs_replay_vector[TX_MAX_TYPE];
extern int zfsfstype;

#endif /* _KERNEL */

extern int zfs_obj_to_path(objset_t *osp, uint64_t obj, char *buf, int len);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_FS_ZFS_ZNODE_H */
         usr/src/zfs-0.6.5.9/include/sys/zil.h                                                               0100644 0000000 0000000 00000041430 13045171016 015472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012 by Delphix. All rights reserved.
 */

/* Portions Copyright 2010 Robert Milkowski */

#ifndef	_SYS_ZIL_H
#define	_SYS_ZIL_H

#include <sys/types.h>
#include <sys/spa.h>
#include <sys/zio.h>
#include <sys/dmu.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct dsl_pool;
struct dsl_dataset;

/*
 * Intent log format:
 *
 * Each objset has its own intent log.  The log header (zil_header_t)
 * for objset N's intent log is kept in the Nth object of the SPA's
 * intent_log objset.  The log header points to a chain of log blocks,
 * each of which contains log records (i.e., transactions) followed by
 * a log block trailer (zil_trailer_t).  The format of a log record
 * depends on the record (or transaction) type, but all records begin
 * with a common structure that defines the type, length, and txg.
 */

/*
 * Intent log header - this on disk structure holds fields to manage
 * the log.  All fields are 64 bit to easily handle cross architectures.
 */
typedef struct zil_header {
	uint64_t zh_claim_txg;	/* txg in which log blocks were claimed */
	uint64_t zh_replay_seq;	/* highest replayed sequence number */
	blkptr_t zh_log;	/* log chain */
	uint64_t zh_claim_blk_seq; /* highest claimed block sequence number */
	uint64_t zh_flags;	/* header flags */
	uint64_t zh_claim_lr_seq; /* highest claimed lr sequence number */
	uint64_t zh_pad[3];
} zil_header_t;

/*
 * zh_flags bit settings
 */
#define	ZIL_REPLAY_NEEDED	0x1	/* replay needed - internal only */
#define	ZIL_CLAIM_LR_SEQ_VALID	0x2	/* zh_claim_lr_seq field is valid */

/*
 * Log block chaining.
 *
 * Log blocks are chained together. Originally they were chained at the
 * end of the block. For performance reasons the chain was moved to the
 * beginning of the block which allows writes for only the data being used.
 * The older position is supported for backwards compatability.
 *
 * The zio_eck_t contains a zec_cksum which for the intent log is
 * the sequence number of this log block. A seq of 0 is invalid.
 * The zec_cksum is checked by the SPA against the sequence
 * number passed in the blk_cksum field of the blkptr_t
 */
typedef struct zil_chain {
	uint64_t zc_pad;
	blkptr_t zc_next_blk;	/* next block in chain */
	uint64_t zc_nused;	/* bytes in log block used */
	zio_eck_t zc_eck;	/* block trailer */
} zil_chain_t;

#define	ZIL_MIN_BLKSZ	4096ULL

/*
 * The words of a log block checksum.
 */
#define	ZIL_ZC_GUID_0	0
#define	ZIL_ZC_GUID_1	1
#define	ZIL_ZC_OBJSET	2
#define	ZIL_ZC_SEQ	3

typedef enum zil_create {
	Z_FILE,
	Z_DIR,
	Z_XATTRDIR,
} zil_create_t;

/*
 * size of xvattr log section.
 * its composed of lr_attr_t + xvattr bitmap + 2 64 bit timestamps
 * for create time and a single 64 bit integer for all of the attributes,
 * and 4 64 bit integers (32 bytes) for the scanstamp.
 *
 */

#define	ZIL_XVAT_SIZE(mapsize) \
	sizeof (lr_attr_t) + (sizeof (uint32_t) * (mapsize - 1)) + \
	(sizeof (uint64_t) * 7)

/*
 * Size of ACL in log.  The ACE data is padded out to properly align
 * on 8 byte boundary.
 */

#define	ZIL_ACE_LENGTH(x)	(roundup(x, sizeof (uint64_t)))

/*
 * Intent log transaction types and record structures
 */
#define	TX_CREATE		1	/* Create file */
#define	TX_MKDIR		2	/* Make directory */
#define	TX_MKXATTR		3	/* Make XATTR directory */
#define	TX_SYMLINK		4	/* Create symbolic link to a file */
#define	TX_REMOVE		5	/* Remove file */
#define	TX_RMDIR		6	/* Remove directory */
#define	TX_LINK			7	/* Create hard link to a file */
#define	TX_RENAME		8	/* Rename a file */
#define	TX_WRITE		9	/* File write */
#define	TX_TRUNCATE		10	/* Truncate a file */
#define	TX_SETATTR		11	/* Set file attributes */
#define	TX_ACL_V0		12	/* Set old formatted ACL */
#define	TX_ACL			13	/* Set ACL */
#define	TX_CREATE_ACL		14	/* create with ACL */
#define	TX_CREATE_ATTR		15	/* create + attrs */
#define	TX_CREATE_ACL_ATTR 	16	/* create with ACL + attrs */
#define	TX_MKDIR_ACL		17	/* mkdir with ACL */
#define	TX_MKDIR_ATTR		18	/* mkdir with attr */
#define	TX_MKDIR_ACL_ATTR	19	/* mkdir with ACL + attrs */
#define	TX_WRITE2		20	/* dmu_sync EALREADY write */
#define	TX_MAX_TYPE		21	/* Max transaction type */

/*
 * The transactions for mkdir, symlink, remove, rmdir, link, and rename
 * may have the following bit set, indicating the original request
 * specified case-insensitive handling of names.
 */
#define	TX_CI	((uint64_t)0x1 << 63) /* case-insensitive behavior requested */

/*
 * Transactions for write, truncate, setattr, acl_v0, and acl can be logged
 * out of order.  For convenience in the code, all such records must have
 * lr_foid at the same offset.
 */
#define	TX_OOO(txtype)			\
	((txtype) == TX_WRITE ||	\
	(txtype) == TX_TRUNCATE ||	\
	(txtype) == TX_SETATTR ||	\
	(txtype) == TX_ACL_V0 ||	\
	(txtype) == TX_ACL ||		\
	(txtype) == TX_WRITE2)

/*
 * Format of log records.
 * The fields are carefully defined to allow them to be aligned
 * and sized the same on sparc & intel architectures.
 * Each log record has a common structure at the beginning.
 *
 * The log record on disk (lrc_seq) holds the sequence number of all log
 * records which is used to ensure we don't replay the same record.
 */
typedef struct {			/* common log record header */
	uint64_t	lrc_txtype;	/* intent log transaction type */
	uint64_t	lrc_reclen;	/* transaction record length */
	uint64_t	lrc_txg;	/* dmu transaction group number */
	uint64_t	lrc_seq;	/* see comment above */
} lr_t;

/*
 * Common start of all out-of-order record types (TX_OOO() above).
 */
typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_foid;	/* object id */
} lr_ooo_t;

/*
 * Handle option extended vattr attributes.
 *
 * Whenever new attributes are added the version number
 * will need to be updated as will code in
 * zfs_log.c and zfs_replay.c
 */
typedef struct {
	uint32_t	lr_attr_masksize; /* number of elements in array */
	uint32_t	lr_attr_bitmap; /* First entry of array */
	/* remainder of array and any additional fields */
} lr_attr_t;

/*
 * log record for creates without optional ACL.
 * This log record does support optional xvattr_t attributes.
 */
typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_doid;	/* object id of directory */
	uint64_t	lr_foid;	/* object id of created file object */
	uint64_t	lr_mode;	/* mode of object */
	uint64_t	lr_uid;		/* uid of object */
	uint64_t	lr_gid;		/* gid of object */
	uint64_t	lr_gen;		/* generation (txg of creation) */
	uint64_t	lr_crtime[2];	/* creation time */
	uint64_t	lr_rdev;	/* rdev of object to create */
	/* name of object to create follows this */
	/* for symlinks, link content follows name */
	/* for creates with xvattr data, the name follows the xvattr info */
} lr_create_t;

/*
 * FUID ACL record will be an array of ACEs from the original ACL.
 * If this array includes ephemeral IDs, the record will also include
 * an array of log-specific FUIDs to replace the ephemeral IDs.
 * Only one copy of each unique domain will be present, so the log-specific
 * FUIDs will use an index into a compressed domain table.  On replay this
 * information will be used to construct real FUIDs (and bypass idmap,
 * since it may not be available).
 */

/*
 * Log record for creates with optional ACL
 * This log record is also used for recording any FUID
 * information needed for replaying the create.  If the
 * file doesn't have any actual ACEs then the lr_aclcnt
 * would be zero.
 *
 * After lr_acl_flags, there are a lr_acl_bytes number of variable sized ace's.
 * If create is also setting xvattr's, then acl data follows xvattr.
 * If ACE FUIDs are needed then they will follow the xvattr_t.  Following
 * the FUIDs will be the domain table information.  The FUIDs for the owner
 * and group will be in lr_create.  Name follows ACL data.
 */
typedef struct {
	lr_create_t	lr_create;	/* common create portion */
	uint64_t	lr_aclcnt;	/* number of ACEs in ACL */
	uint64_t	lr_domcnt;	/* number of unique domains */
	uint64_t	lr_fuidcnt;	/* number of real fuids */
	uint64_t	lr_acl_bytes;	/* number of bytes in ACL */
	uint64_t	lr_acl_flags;	/* ACL flags */
} lr_acl_create_t;

typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_doid;	/* obj id of directory */
	/* name of object to remove follows this */
} lr_remove_t;

typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_doid;	/* obj id of directory */
	uint64_t	lr_link_obj;	/* obj id of link */
	/* name of object to link follows this */
} lr_link_t;

typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_sdoid;	/* obj id of source directory */
	uint64_t	lr_tdoid;	/* obj id of target directory */
	/* 2 strings: names of source and destination follow this */
} lr_rename_t;

typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_foid;	/* file object to write */
	uint64_t	lr_offset;	/* offset to write to */
	uint64_t	lr_length;	/* user data length to write */
	uint64_t	lr_blkoff;	/* no longer used */
	blkptr_t	lr_blkptr;	/* spa block pointer for replay */
	/* write data will follow for small writes */
} lr_write_t;

typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_foid;	/* object id of file to truncate */
	uint64_t	lr_offset;	/* offset to truncate from */
	uint64_t	lr_length;	/* length to truncate */
} lr_truncate_t;

typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_foid;	/* file object to change attributes */
	uint64_t	lr_mask;	/* mask of attributes to set */
	uint64_t	lr_mode;	/* mode to set */
	uint64_t	lr_uid;		/* uid to set */
	uint64_t	lr_gid;		/* gid to set */
	uint64_t	lr_size;	/* size to set */
	uint64_t	lr_atime[2];	/* access time */
	uint64_t	lr_mtime[2];	/* modification time */
	/* optional attribute lr_attr_t may be here */
} lr_setattr_t;

typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_foid;	/* obj id of file */
	uint64_t	lr_aclcnt;	/* number of acl entries */
	/* lr_aclcnt number of ace_t entries follow this */
} lr_acl_v0_t;

typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_foid;	/* obj id of file */
	uint64_t	lr_aclcnt;	/* number of ACEs in ACL */
	uint64_t	lr_domcnt;	/* number of unique domains */
	uint64_t	lr_fuidcnt;	/* number of real fuids */
	uint64_t	lr_acl_bytes;	/* number of bytes in ACL */
	uint64_t	lr_acl_flags;	/* ACL flags */
	/* lr_acl_bytes number of variable sized ace's follows */
} lr_acl_t;

/*
 * ZIL structure definitions, interface function prototype and globals.
 */

/*
 * Writes are handled in three different ways:
 *
 * WR_INDIRECT:
 *    In this mode, if we need to commit the write later, then the block
 *    is immediately written into the file system (using dmu_sync),
 *    and a pointer to the block is put into the log record.
 *    When the txg commits the block is linked in.
 *    This saves additionally writing the data into the log record.
 *    There are a few requirements for this to occur:
 *	- write is greater than zfs/zvol_immediate_write_sz
 *	- not using slogs (as slogs are assumed to always be faster
 *	  than writing into the main pool)
 *	- the write occupies only one block
 * WR_COPIED:
 *    If we know we'll immediately be committing the
 *    transaction (FSYNC or FDSYNC), the we allocate a larger
 *    log record here for the data and copy the data in.
 * WR_NEED_COPY:
 *    Otherwise we don't allocate a buffer, and *if* we need to
 *    flush the write later then a buffer is allocated and
 *    we retrieve the data using the dmu.
 */
typedef enum {
	WR_INDIRECT,	/* indirect - a large write (dmu_sync() data */
			/* and put blkptr in log, rather than actual data) */
	WR_COPIED,	/* immediate - data is copied into lr_write_t */
	WR_NEED_COPY,	/* immediate - data needs to be copied if pushed */
	WR_NUM_STATES	/* number of states */
} itx_wr_state_t;

typedef void (*zil_callback_t)(void *data);

typedef struct itx {
	list_node_t	itx_node;	/* linkage on zl_itx_list */
	void		*itx_private;	/* type-specific opaque data */
	itx_wr_state_t	itx_wr_state;	/* write state */
	uint8_t		itx_sync;	/* synchronous transaction */
	zil_callback_t	itx_callback;   /* Called when the itx is persistent */
	void		*itx_callback_data; /* User data for the callback */
	uint64_t	itx_sod;	/* record size on disk */
	uint64_t	itx_oid;	/* object id */
	lr_t		itx_lr;		/* common part of log record */
	/* followed by type-specific part of lr_xx_t and its immediate data */
} itx_t;

/*
 * Used for zil kstat.
 */
typedef struct zil_stats {
	/*
	 * Number of times a ZIL commit (e.g. fsync) has been requested.
	 */
	kstat_named_t zil_commit_count;

	/*
	 * Number of times the ZIL has been flushed to stable storage.
	 * This is less than zil_commit_count when commits are "merged"
	 * (see the documentation above zil_commit()).
	 */
	kstat_named_t zil_commit_writer_count;

	/*
	 * Number of transactions (reads, writes, renames, etc.)
	 * that have been commited.
	 */
	kstat_named_t zil_itx_count;

	/*
	 * See the documentation for itx_wr_state_t above.
	 * Note that "bytes" accumulates the length of the transactions
	 * (i.e. data), not the actual log record sizes.
	 */
	kstat_named_t zil_itx_indirect_count;
	kstat_named_t zil_itx_indirect_bytes;
	kstat_named_t zil_itx_copied_count;
	kstat_named_t zil_itx_copied_bytes;
	kstat_named_t zil_itx_needcopy_count;
	kstat_named_t zil_itx_needcopy_bytes;

	/*
	 * Transactions which have been allocated to the "normal"
	 * (i.e. not slog) storage pool. Note that "bytes" accumulate
	 * the actual log record sizes - which do not include the actual
	 * data in case of indirect writes.
	 */
	kstat_named_t zil_itx_metaslab_normal_count;
	kstat_named_t zil_itx_metaslab_normal_bytes;

	/*
	 * Transactions which have been allocated to the "slog" storage pool.
	 * If there are no separate log devices, this is the same as the
	 * "normal" pool.
	 */
	kstat_named_t zil_itx_metaslab_slog_count;
	kstat_named_t zil_itx_metaslab_slog_bytes;
} zil_stats_t;

extern zil_stats_t zil_stats;

#define	ZIL_STAT_INCR(stat, val) \
    atomic_add_64(&zil_stats.stat.value.ui64, (val));
#define	ZIL_STAT_BUMP(stat) \
    ZIL_STAT_INCR(stat, 1);

typedef int zil_parse_blk_func_t(zilog_t *zilog, blkptr_t *bp, void *arg,
    uint64_t txg);
typedef int zil_parse_lr_func_t(zilog_t *zilog, lr_t *lr, void *arg,
    uint64_t txg);
typedef int (*const zil_replay_func_t)(void *, char *, boolean_t);
typedef int zil_get_data_t(void *arg, lr_write_t *lr, char *dbuf, zio_t *zio);

extern int zil_parse(zilog_t *zilog, zil_parse_blk_func_t *parse_blk_func,
    zil_parse_lr_func_t *parse_lr_func, void *arg, uint64_t txg);

extern void	zil_init(void);
extern void	zil_fini(void);

extern zilog_t	*zil_alloc(objset_t *os, zil_header_t *zh_phys);
extern void	zil_free(zilog_t *zilog);

extern zilog_t	*zil_open(objset_t *os, zil_get_data_t *get_data);
extern void	zil_close(zilog_t *zilog);

extern void	zil_replay(objset_t *os, void *arg,
    zil_replay_func_t replay_func[TX_MAX_TYPE]);
extern boolean_t zil_replaying(zilog_t *zilog, dmu_tx_t *tx);
extern void	zil_destroy(zilog_t *zilog, boolean_t keep_first);
extern void	zil_destroy_sync(zilog_t *zilog, dmu_tx_t *tx);

extern itx_t	*zil_itx_create(uint64_t txtype, size_t lrsize);
extern void	zil_itx_destroy(itx_t *itx);
extern void	zil_itx_assign(zilog_t *zilog, itx_t *itx, dmu_tx_t *tx);

extern void	zil_commit(zilog_t *zilog, uint64_t oid);

extern int	zil_vdev_offline(const char *osname, void *txarg);
extern int	zil_claim(struct dsl_pool *dp,
    struct dsl_dataset *ds, void *txarg);
extern int 	zil_check_log_chain(struct dsl_pool *dp,
    struct dsl_dataset *ds, void *tx);
extern void	zil_sync(zilog_t *zilog, dmu_tx_t *tx);
extern void	zil_clean(zilog_t *zilog, uint64_t synced_txg);

extern int	zil_suspend(const char *osname, void **cookiep);
extern void	zil_resume(void *cookie);

extern void	zil_add_block(zilog_t *zilog, const blkptr_t *bp);
extern int	zil_bp_tree_add(zilog_t *zilog, const blkptr_t *bp);

extern void	zil_set_sync(zilog_t *zilog, uint64_t syncval);

extern void	zil_set_logbias(zilog_t *zilog, uint64_t slogval);

extern int zil_replay_disable;

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_ZIL_H */
                                                                                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/sys/zil_impl.h                                                          0100644 0000000 0000000 00000013012 13045171016 016506  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012 by Delphix. All rights reserved.
 */

/* Portions Copyright 2010 Robert Milkowski */

#ifndef	_SYS_ZIL_IMPL_H
#define	_SYS_ZIL_IMPL_H

#include <sys/zil.h>
#include <sys/dmu_objset.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * Log write buffer.
 */
typedef struct lwb {
	zilog_t		*lwb_zilog;	/* back pointer to log struct */
	blkptr_t	lwb_blk;	/* on disk address of this log blk */
	boolean_t	lwb_fastwrite;	/* is blk marked for fastwrite? */
	int		lwb_nused;	/* # used bytes in buffer */
	int		lwb_sz;		/* size of block and buffer */
	char		*lwb_buf;	/* log write buffer */
	zio_t		*lwb_zio;	/* zio for this buffer */
	dmu_tx_t	*lwb_tx;	/* tx for log block allocation */
	uint64_t	lwb_max_txg;	/* highest txg in this lwb */
	list_node_t	lwb_node;	/* zilog->zl_lwb_list linkage */
} lwb_t;

/*
 * Intent log transaction lists
 */
typedef struct itxs {
	list_t		i_sync_list;	/* list of synchronous itxs */
	avl_tree_t	i_async_tree;	/* tree of foids for async itxs */
} itxs_t;

typedef struct itxg {
	kmutex_t	itxg_lock;	/* lock for this structure */
	uint64_t	itxg_txg;	/* txg for this chain */
	uint64_t	itxg_sod;	/* total size on disk for this txg */
	itxs_t		*itxg_itxs;	/* sync and async itxs */
} itxg_t;

/* for async nodes we build up an AVL tree of lists of async itxs per file */
typedef struct itx_async_node {
	uint64_t	ia_foid;	/* file object id */
	list_t		ia_list;	/* list of async itxs for this foid */
	avl_node_t	ia_node;	/* AVL tree linkage */
} itx_async_node_t;

/*
 * Vdev flushing: during a zil_commit(), we build up an AVL tree of the vdevs
 * we've touched so we know which ones need a write cache flush at the end.
 */
typedef struct zil_vdev_node {
	uint64_t	zv_vdev;	/* vdev to be flushed */
	avl_node_t	zv_node;	/* AVL tree linkage */
} zil_vdev_node_t;

#define	ZIL_PREV_BLKS 16

/*
 * Stable storage intent log management structure.  One per dataset.
 */
struct zilog {
	kmutex_t	zl_lock;	/* protects most zilog_t fields */
	struct dsl_pool	*zl_dmu_pool;	/* DSL pool */
	spa_t		*zl_spa;	/* handle for read/write log */
	const zil_header_t *zl_header;	/* log header buffer */
	objset_t	*zl_os;		/* object set we're logging */
	zil_get_data_t	*zl_get_data;	/* callback to get object content */
	zio_t		*zl_root_zio;	/* log writer root zio */
	uint64_t	zl_lr_seq;	/* on-disk log record sequence number */
	uint64_t	zl_commit_lr_seq; /* last committed on-disk lr seq */
	uint64_t	zl_destroy_txg;	/* txg of last zil_destroy() */
	uint64_t	zl_replayed_seq[TXG_SIZE]; /* last replayed rec seq */
	uint64_t	zl_replaying_seq; /* current replay seq number */
	uint32_t	zl_suspend;	/* log suspend count */
	kcondvar_t	zl_cv_writer;	/* log writer thread completion */
	kcondvar_t	zl_cv_suspend;	/* log suspend completion */
	uint8_t		zl_suspending;	/* log is currently suspending */
	uint8_t		zl_keep_first;	/* keep first log block in destroy */
	uint8_t		zl_replay;	/* replaying records while set */
	uint8_t		zl_stop_sync;	/* for debugging */
	uint8_t		zl_writer;	/* boolean: write setup in progress */
	uint8_t		zl_logbias;	/* latency or throughput */
	uint8_t		zl_sync;	/* synchronous or asynchronous */
	int		zl_parse_error;	/* last zil_parse() error */
	uint64_t	zl_parse_blk_seq; /* highest blk seq on last parse */
	uint64_t	zl_parse_lr_seq; /* highest lr seq on last parse */
	uint64_t	zl_parse_blk_count; /* number of blocks parsed */
	uint64_t	zl_parse_lr_count; /* number of log records parsed */
	uint64_t	zl_next_batch;	/* next batch number */
	uint64_t	zl_com_batch;	/* committed batch number */
	kcondvar_t	zl_cv_batch[2];	/* batch condition variables */
	itxg_t		zl_itxg[TXG_SIZE]; /* intent log txg chains */
	list_t		zl_itx_commit_list; /* itx list to be committed */
	uint64_t	zl_itx_list_sz;	/* total size of records on list */
	uint64_t	zl_cur_used;	/* current commit log size used */
	list_t		zl_lwb_list;	/* in-flight log write list */
	kmutex_t	zl_vdev_lock;	/* protects zl_vdev_tree */
	avl_tree_t	zl_vdev_tree;	/* vdevs to flush in zil_commit() */
	taskq_t		*zl_clean_taskq; /* runs lwb and itx clean tasks */
	avl_tree_t	zl_bp_tree;	/* track bps during log parse */
	clock_t		zl_replay_time;	/* lbolt of when replay started */
	uint64_t	zl_replay_blks;	/* number of log blocks replayed */
	zil_header_t	zl_old_header;	/* debugging aid */
	uint_t		zl_prev_blks[ZIL_PREV_BLKS]; /* size - sector rounded */
	uint_t		zl_prev_rotor;	/* rotor for zl_prev[] */
	txg_node_t	zl_dirty_link;	/* protected by dp_dirty_zilogs list */
};

typedef struct zil_bp_node {
	dva_t		zn_dva;
	avl_node_t	zn_node;
} zil_bp_node_t;

#define	ZIL_MAX_LOG_DATA (SPA_OLD_MAXBLOCKSIZE - sizeof (zil_chain_t) - \
    sizeof (lr_write_t))

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_ZIL_IMPL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/src/zfs-0.6.5.9/include/sys/zio.h                                                               0100644 0000000 0000000 00000043661 13045171016 015505  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2011 Nexenta Systems, Inc. All rights reserved.
 * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
 * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
 */

#ifndef _ZIO_H
#define	_ZIO_H

#include <sys/zfs_context.h>
#include <sys/spa.h>
#include <sys/txg.h>
#include <sys/avl.h>
#include <sys/fs/zfs.h>
#include <sys/zio_impl.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * Embedded checksum
 */
#define	ZEC_MAGIC	0x210da7ab10c7a11ULL

typedef struct zio_eck {
	uint64_t	zec_magic;	/* for validation, endianness	*/
	zio_cksum_t	zec_cksum;	/* 256-bit checksum		*/
} zio_eck_t;

/*
 * Gang block headers are self-checksumming and contain an array
 * of block pointers.
 */
#define	SPA_GANGBLOCKSIZE	SPA_MINBLOCKSIZE
#define	SPA_GBH_NBLKPTRS	((SPA_GANGBLOCKSIZE - \
	sizeof (zio_eck_t)) / sizeof (blkptr_t))
#define	SPA_GBH_FILLER		((SPA_GANGBLOCKSIZE - \
	sizeof (zio_eck_t) - \
	(SPA_GBH_NBLKPTRS * sizeof (blkptr_t))) /\
	sizeof (uint64_t))

typedef struct zio_gbh {
	blkptr_t		zg_blkptr[SPA_GBH_NBLKPTRS];
	uint64_t		zg_filler[SPA_GBH_FILLER];
	zio_eck_t		zg_tail;
} zio_gbh_phys_t;

enum zio_checksum {
	ZIO_CHECKSUM_INHERIT = 0,
	ZIO_CHECKSUM_ON,
	ZIO_CHECKSUM_OFF,
	ZIO_CHECKSUM_LABEL,
	ZIO_CHECKSUM_GANG_HEADER,
	ZIO_CHECKSUM_ZILOG,
	ZIO_CHECKSUM_FLETCHER_2,
	ZIO_CHECKSUM_FLETCHER_4,
	ZIO_CHECKSUM_SHA256,
	ZIO_CHECKSUM_ZILOG2,
	ZIO_CHECKSUM_FUNCTIONS
};

/*
 * The number of "legacy" compression functions which can be set on individual
 * objects.
 */
#define	ZIO_CHECKSUM_LEGACY_FUNCTIONS ZIO_CHECKSUM_ZILOG2

#define	ZIO_CHECKSUM_ON_VALUE	ZIO_CHECKSUM_FLETCHER_4
#define	ZIO_CHECKSUM_DEFAULT	ZIO_CHECKSUM_ON

#define	ZIO_CHECKSUM_MASK	0xffULL
#define	ZIO_CHECKSUM_VERIFY	(1 << 8)

#define	ZIO_DEDUPCHECKSUM	ZIO_CHECKSUM_SHA256
#define	ZIO_DEDUPDITTO_MIN	100

enum zio_compress {
	ZIO_COMPRESS_INHERIT = 0,
	ZIO_COMPRESS_ON,
	ZIO_COMPRESS_OFF,
	ZIO_COMPRESS_LZJB,
	ZIO_COMPRESS_EMPTY,
	ZIO_COMPRESS_GZIP_1,
	ZIO_COMPRESS_GZIP_2,
	ZIO_COMPRESS_GZIP_3,
	ZIO_COMPRESS_GZIP_4,
	ZIO_COMPRESS_GZIP_5,
	ZIO_COMPRESS_GZIP_6,
	ZIO_COMPRESS_GZIP_7,
	ZIO_COMPRESS_GZIP_8,
	ZIO_COMPRESS_GZIP_9,
	ZIO_COMPRESS_ZLE,
	ZIO_COMPRESS_LZ4,
	ZIO_COMPRESS_FUNCTIONS
};

/*
 * The number of "legacy" compression functions which can be set on individual
 * objects.
 */
#define	ZIO_COMPRESS_LEGACY_FUNCTIONS ZIO_COMPRESS_LZ4

/*
 * The meaning of "compress = on" selected by the compression features enabled
 * on a given pool.
 */
#define	ZIO_COMPRESS_LEGACY_ON_VALUE	ZIO_COMPRESS_LZJB
#define	ZIO_COMPRESS_LZ4_ON_VALUE	ZIO_COMPRESS_LZ4

#define	ZIO_COMPRESS_DEFAULT		ZIO_COMPRESS_OFF

#define	BOOTFS_COMPRESS_VALID(compress)			\
	((compress) == ZIO_COMPRESS_LZJB ||		\
	(compress) == ZIO_COMPRESS_LZ4 ||		\
	(compress) == ZIO_COMPRESS_ON ||		\
	(compress) == ZIO_COMPRESS_OFF)

/*
 * Default Linux timeout for a sd device.
 */
#define	ZIO_DELAY_MAX			(30 * MILLISEC)

#define	ZIO_FAILURE_MODE_WAIT		0
#define	ZIO_FAILURE_MODE_CONTINUE	1
#define	ZIO_FAILURE_MODE_PANIC		2

typedef enum zio_priority {
	ZIO_PRIORITY_SYNC_READ,
	ZIO_PRIORITY_SYNC_WRITE,	/* ZIL */
	ZIO_PRIORITY_ASYNC_READ,	/* prefetch */
	ZIO_PRIORITY_ASYNC_WRITE,	/* spa_sync() */
	ZIO_PRIORITY_SCRUB,		/* asynchronous scrub/resilver reads */
	ZIO_PRIORITY_NUM_QUEUEABLE,

	ZIO_PRIORITY_NOW		/* non-queued i/os (e.g. free) */
} zio_priority_t;

enum zio_flag {
	/*
	 * Flags inherited by gang, ddt, and vdev children,
	 * and that must be equal for two zios to aggregate
	 */
	ZIO_FLAG_DONT_AGGREGATE	= 1 << 0,
	ZIO_FLAG_IO_REPAIR	= 1 << 1,
	ZIO_FLAG_SELF_HEAL	= 1 << 2,
	ZIO_FLAG_RESILVER	= 1 << 3,
	ZIO_FLAG_SCRUB		= 1 << 4,
	ZIO_FLAG_SCAN_THREAD	= 1 << 5,
	ZIO_FLAG_PHYSICAL	= 1 << 6,

#define	ZIO_FLAG_AGG_INHERIT	(ZIO_FLAG_CANFAIL - 1)

	/*
	 * Flags inherited by ddt, gang, and vdev children.
	 */
	ZIO_FLAG_CANFAIL	= 1 << 7,	/* must be first for INHERIT */
	ZIO_FLAG_SPECULATIVE	= 1 << 8,
	ZIO_FLAG_CONFIG_WRITER	= 1 << 9,
	ZIO_FLAG_DONT_RETRY	= 1 << 10,
	ZIO_FLAG_DONT_CACHE	= 1 << 11,
	ZIO_FLAG_NODATA		= 1 << 12,
	ZIO_FLAG_INDUCE_DAMAGE	= 1 << 13,

#define	ZIO_FLAG_DDT_INHERIT	(ZIO_FLAG_IO_RETRY - 1)
#define	ZIO_FLAG_GANG_INHERIT	(ZIO_FLAG_IO_RETRY - 1)

	/*
	 * Flags inherited by vdev children.
	 */
	ZIO_FLAG_IO_RETRY	= 1 << 14,	/* must be first for INHERIT */
	ZIO_FLAG_PROBE		= 1 << 15,
	ZIO_FLAG_TRYHARD	= 1 << 16,
	ZIO_FLAG_OPTIONAL	= 1 << 17,

#define	ZIO_FLAG_VDEV_INHERIT	(ZIO_FLAG_DONT_QUEUE - 1)

	/*
	 * Flags not inherited by any children.
	 */
	ZIO_FLAG_DONT_QUEUE	= 1 << 18,	/* must be first for INHERIT */
	ZIO_FLAG_DONT_PROPAGATE	= 1 << 19,
	ZIO_FLAG_IO_BYPASS	= 1 << 20,
	ZIO_FLAG_IO_REWRITE	= 1 << 21,
	ZIO_FLAG_RAW		= 1 << 22,
	ZIO_FLAG_GANG_CHILD	= 1 << 23,
	ZIO_FLAG_DDT_CHILD	= 1 << 24,
	ZIO_FLAG_GODFATHER	= 1 << 25,
	ZIO_FLAG_NOPWRITE	= 1 << 26,
	ZIO_FLAG_REEXECUTED	= 1 << 27,
	ZIO_FLAG_DELEGATED	= 1 << 28,
	ZIO_FLAG_FASTWRITE	= 1 << 29,
};

#define	ZIO_FLAG_MUSTSUCCEED		0

#define	ZIO_DDT_CHILD_FLAGS(zio)				\
	(((zio)->io_flags & ZIO_FLAG_DDT_INHERIT) |		\
	ZIO_FLAG_DDT_CHILD | ZIO_FLAG_CANFAIL)

#define	ZIO_GANG_CHILD_FLAGS(zio)				\
	(((zio)->io_flags & ZIO_FLAG_GANG_INHERIT) |		\
	ZIO_FLAG_GANG_CHILD | ZIO_FLAG_CANFAIL)

#define	ZIO_VDEV_CHILD_FLAGS(zio)				\
	(((zio)->io_flags & ZIO_FLAG_VDEV_INHERIT) |		\
	ZIO_FLAG_CANFAIL)

enum zio_child {
	ZIO_CHILD_VDEV = 0,
	ZIO_CHILD_GANG,
	ZIO_CHILD_DDT,
	ZIO_CHILD_LOGICAL,
	ZIO_CHILD_TYPES
};

enum zio_wait_type {
	ZIO_WAIT_READY = 0,
	ZIO_WAIT_DONE,
	ZIO_WAIT_TYPES
};

/*
 * We'll take the unused errnos, 'EBADE' and 'EBADR' (from the Convergent
 * graveyard) to indicate checksum errors and fragmentation.
 */
#define	ECKSUM	EBADE
#define	EFRAGS	EBADR

typedef void zio_done_func_t(zio_t *zio);

extern const char *zio_type_name[ZIO_TYPES];

/*
 * A bookmark is a four-tuple <objset, object, level, blkid> that uniquely
 * identifies any block in the pool.  By convention, the meta-objset (MOS)
 * is objset 0, and the meta-dnode is object 0.  This covers all blocks
 * except root blocks and ZIL blocks, which are defined as follows:
 *
 * Root blocks (objset_phys_t) are object 0, level -1:  <objset, 0, -1, 0>.
 * ZIL blocks are bookmarked <objset, 0, -2, blkid == ZIL sequence number>.
 * dmu_sync()ed ZIL data blocks are bookmarked <objset, object, -2, blkid>.
 *
 * Note: this structure is called a bookmark because its original purpose
 * was to remember where to resume a pool-wide traverse.
 *
 * Note: this structure is passed between userland and the kernel, and is
 * stored on disk (by virtue of being incorporated into other on-disk
 * structures, e.g. dsl_scan_phys_t).
 */
struct zbookmark_phys {
	uint64_t	zb_objset;
	uint64_t	zb_object;
	int64_t		zb_level;
	uint64_t	zb_blkid;
};

#define	SET_BOOKMARK(zb, objset, object, level, blkid)  \
{                                                       \
	(zb)->zb_objset = objset;                       \
	(zb)->zb_object = object;                       \
	(zb)->zb_level = level;                         \
	(zb)->zb_blkid = blkid;                         \
}

#define	ZB_DESTROYED_OBJSET	(-1ULL)

#define	ZB_ROOT_OBJECT		(0ULL)
#define	ZB_ROOT_LEVEL		(-1LL)
#define	ZB_ROOT_BLKID		(0ULL)

#define	ZB_ZIL_OBJECT		(0ULL)
#define	ZB_ZIL_LEVEL		(-2LL)

#define	ZB_IS_ZERO(zb)						\
	((zb)->zb_objset == 0 && (zb)->zb_object == 0 &&	\
	(zb)->zb_level == 0 && (zb)->zb_blkid == 0)
#define	ZB_IS_ROOT(zb)				\
	((zb)->zb_object == ZB_ROOT_OBJECT &&	\
	(zb)->zb_level == ZB_ROOT_LEVEL &&	\
	(zb)->zb_blkid == ZB_ROOT_BLKID)

typedef struct zio_prop {
	enum zio_checksum	zp_checksum;
	enum zio_compress	zp_compress;
	dmu_object_type_t	zp_type;
	uint8_t			zp_level;
	uint8_t			zp_copies;
	boolean_t		zp_dedup;
	boolean_t		zp_dedup_verify;
	boolean_t		zp_nopwrite;
} zio_prop_t;

typedef struct zio_cksum_report zio_cksum_report_t;

typedef void zio_cksum_finish_f(zio_cksum_report_t *rep,
    const void *good_data);
typedef void zio_cksum_free_f(void *cbdata, size_t size);

struct zio_bad_cksum;				/* defined in zio_checksum.h */
struct dnode_phys;

struct zio_cksum_report {
	struct zio_cksum_report *zcr_next;
	nvlist_t		*zcr_ereport;
	nvlist_t		*zcr_detector;
	void			*zcr_cbdata;
	size_t			zcr_cbinfo;	/* passed to zcr_free() */
	uint64_t		zcr_align;
	uint64_t		zcr_length;
	zio_cksum_finish_f	*zcr_finish;
	zio_cksum_free_f	*zcr_free;

	/* internal use only */
	struct zio_bad_cksum	*zcr_ckinfo;	/* information from failure */
};

typedef void zio_vsd_cksum_report_f(zio_t *zio, zio_cksum_report_t *zcr,
    void *arg);

zio_vsd_cksum_report_f	zio_vsd_default_cksum_report;

typedef struct zio_vsd_ops {
	zio_done_func_t		*vsd_free;
	zio_vsd_cksum_report_f	*vsd_cksum_report;
} zio_vsd_ops_t;

typedef struct zio_gang_node {
	zio_gbh_phys_t		*gn_gbh;
	struct zio_gang_node	*gn_child[SPA_GBH_NBLKPTRS];
} zio_gang_node_t;

typedef zio_t *zio_gang_issue_func_t(zio_t *zio, blkptr_t *bp,
    zio_gang_node_t *gn, void *data);

typedef void zio_transform_func_t(zio_t *zio, void *data, uint64_t size);

typedef struct zio_transform {
	void			*zt_orig_data;
	uint64_t		zt_orig_size;
	uint64_t		zt_bufsize;
	zio_transform_func_t	*zt_transform;
	struct zio_transform	*zt_next;
} zio_transform_t;

typedef int zio_pipe_stage_t(zio_t *zio);

/*
 * The io_reexecute flags are distinct from io_flags because the child must
 * be able to propagate them to the parent.  The normal io_flags are local
 * to the zio, not protected by any lock, and not modifiable by children;
 * the reexecute flags are protected by io_lock, modifiable by children,
 * and always propagated -- even when ZIO_FLAG_DONT_PROPAGATE is set.
 */
#define	ZIO_REEXECUTE_NOW	0x01
#define	ZIO_REEXECUTE_SUSPEND	0x02

typedef struct zio_link {
	zio_t		*zl_parent;
	zio_t		*zl_child;
	list_node_t	zl_parent_node;
	list_node_t	zl_child_node;
} zio_link_t;

struct zio {
	/* Core information about this I/O */
	zbookmark_phys_t	io_bookmark;
	zio_prop_t	io_prop;
	zio_type_t	io_type;
	enum zio_child	io_child_type;
	int		io_cmd;
	zio_priority_t	io_priority;
	uint8_t		io_reexecute;
	uint8_t		io_state[ZIO_WAIT_TYPES];
	uint64_t	io_txg;
	spa_t		*io_spa;
	blkptr_t	*io_bp;
	blkptr_t	*io_bp_override;
	blkptr_t	io_bp_copy;
	list_t		io_parent_list;
	list_t		io_child_list;
	zio_link_t	*io_walk_link;
	zio_t		*io_logical;
	zio_transform_t *io_transform_stack;

	/* Callback info */
	zio_done_func_t *io_ready;
	zio_done_func_t	*io_physdone;
	zio_done_func_t	*io_done;
	void		*io_private;
	int64_t		io_prev_space_delta;	/* DMU private */
	blkptr_t	io_bp_orig;

	/* Data represented by this I/O */
	void		*io_data;
	void		*io_orig_data;
	uint64_t	io_size;
	uint64_t	io_orig_size;

	/* Stuff for the vdev stack */
	vdev_t		*io_vd;
	void		*io_vsd;
	const zio_vsd_ops_t *io_vsd_ops;

	uint64_t	io_offset;
	hrtime_t	io_timestamp;	/* submitted at */
	hrtime_t	io_delta;	/* vdev queue service delta */
	uint64_t	io_delay;	/* vdev disk service delta (ticks) */
	avl_node_t	io_queue_node;
	avl_node_t	io_offset_node;

	/* Internal pipeline state */
	enum zio_flag	io_flags;
	enum zio_stage	io_stage;
	enum zio_stage	io_pipeline;
	enum zio_flag	io_orig_flags;
	enum zio_stage	io_orig_stage;
	enum zio_stage	io_orig_pipeline;
	int		io_error;
	int		io_child_error[ZIO_CHILD_TYPES];
	uint64_t	io_children[ZIO_CHILD_TYPES][ZIO_WAIT_TYPES];
	uint64_t	io_child_count;
	uint64_t	io_phys_children;
	uint64_t	io_parent_count;
	uint64_t	*io_stall;
	zio_t		*io_gang_leader;
	zio_gang_node_t	*io_gang_tree;
	void		*io_executor;
	void		*io_waiter;
	kmutex_t	io_lock;
	kcondvar_t	io_cv;

	/* FMA state */
	zio_cksum_report_t *io_cksum_report;
	uint64_t	io_ena;

	/* Taskq dispatching state */
	taskq_ent_t	io_tqent;
};

extern zio_t *zio_null(zio_t *pio, spa_t *spa, vdev_t *vd,
    zio_done_func_t *done, void *private, enum zio_flag flags);

extern zio_t *zio_root(spa_t *spa,
    zio_done_func_t *done, void *private, enum zio_flag flags);

extern zio_t *zio_read(zio_t *pio, spa_t *spa, const blkptr_t *bp, void *data,
    uint64_t size, zio_done_func_t *done, void *private,
    zio_priority_t priority, enum zio_flag flags, const zbookmark_phys_t *zb);

extern zio_t *zio_write(zio_t *pio, spa_t *spa, uint64_t txg, blkptr_t *bp,
    void *data, uint64_t size, const zio_prop_t *zp,
    zio_done_func_t *ready, zio_done_func_t *physdone, zio_done_func_t *done,
    void *private,
    zio_priority_t priority, enum zio_flag flags, const zbookmark_phys_t *zb);

extern zio_t *zio_rewrite(zio_t *pio, spa_t *spa, uint64_t txg, blkptr_t *bp,
    void *data, uint64_t size, zio_done_func_t *done, void *private,
    zio_priority_t priority, enum zio_flag flags, zbookmark_phys_t *zb);

extern void zio_write_override(zio_t *zio, blkptr_t *bp, int copies,
    boolean_t nopwrite);

extern void zio_free(spa_t *spa, uint64_t txg, const blkptr_t *bp);

extern zio_t *zio_claim(zio_t *pio, spa_t *spa, uint64_t txg,
    const blkptr_t *bp,
    zio_done_func_t *done, void *private, enum zio_flag flags);

extern zio_t *zio_ioctl(zio_t *pio, spa_t *spa, vdev_t *vd, int cmd,
    zio_done_func_t *done, void *private, enum zio_flag flags);

extern zio_t *zio_read_phys(zio_t *pio, vdev_t *vd, uint64_t offset,
    uint64_t size, void *data, int checksum,
    zio_done_func_t *done, void *private, zio_priority_t priority,
    enum zio_flag flags, boolean_t labels);

extern zio_t *zio_write_phys(zio_t *pio, vdev_t *vd, uint64_t offset,
    uint64_t size, void *data, int checksum,
    zio_done_func_t *done, void *private, zio_priority_t priority,
    enum zio_flag flags, boolean_t labels);

extern zio_t *zio_free_sync(zio_t *pio, spa_t *spa, uint64_t txg,
    const blkptr_t *bp, enum zio_flag flags);

extern int zio_alloc_zil(spa_t *spa, uint64_t txg, blkptr_t *new_bp,
    uint64_t size, boolean_t use_slog);
extern void zio_free_zil(spa_t *spa, uint64_t txg, blkptr_t *bp);
extern void zio_flush(zio_t *zio, vdev_t *vd);
extern void zio_shrink(zio_t *zio, uint64_t size);

extern int zio_wait(zio_t *zio);
extern void zio_nowait(zio_t *zio);
extern void zio_execute(zio_t *zio);
extern void zio_interrupt(zio_t *zio);

extern zio_t *zio_walk_parents(zio_t *cio);
extern zio_t *zio_walk_children(zio_t *pio);
extern zio_t *zio_unique_parent(zio_t *cio);
extern void zio_add_child(zio_t *pio, zio_t *cio);

extern void *zio_buf_alloc(size_t size);
extern void zio_buf_free(void *buf, size_t size);
extern void *zio_data_buf_alloc(size_t size);
extern void zio_data_buf_free(void *buf, size_t size);
extern void *zio_buf_alloc_flags(size_t size, int flags);

extern void zio_resubmit_stage_async(void *);

extern zio_t *zio_vdev_child_io(zio_t *zio, blkptr_t *bp, vdev_t *vd,
    uint64_t offset, void *data, uint64_t size, int type,
    zio_priority_t priority, enum zio_flag flags,
    zio_done_func_t *done, void *private);

extern zio_t *zio_vdev_delegated_io(vdev_t *vd, uint64_t offset,
    void *data, uint64_t size, int type, zio_priority_t priority,
    enum zio_flag flags, zio_done_func_t *done, void *private);

extern void zio_vdev_io_bypass(zio_t *zio);
extern void zio_vdev_io_reissue(zio_t *zio);
extern void zio_vdev_io_redone(zio_t *zio);

extern void zio_checksum_verified(zio_t *zio);
extern int zio_worst_error(int e1, int e2);

extern enum zio_checksum zio_checksum_select(enum zio_checksum child,
    enum zio_checksum parent);
extern enum zio_checksum zio_checksum_dedup_select(spa_t *spa,
    enum zio_checksum child, enum zio_checksum parent);
extern enum zio_compress zio_compress_select(spa_t *spa,
    enum zio_compress child, enum zio_compress parent);

extern void zio_suspend(spa_t *spa, zio_t *zio);
extern int zio_resume(spa_t *spa);
extern void zio_resume_wait(spa_t *spa);

/*
 * Initial setup and teardown.
 */
extern void zio_init(void);
extern void zio_fini(void);

/*
 * Fault injection
 */
struct zinject_record;
extern uint32_t zio_injection_enabled;
extern int zio_inject_fault(char *name, int flags, int *id,
    struct zinject_record *record);
extern int zio_inject_list_next(int *id, char *name, size_t buflen,
    struct zinject_record *record);
extern int zio_clear_fault(int id);
extern void zio_handle_panic_injection(spa_t *spa, char *tag, uint64_t type);
extern int zio_handle_fault_injection(zio_t *zio, int error);
extern int zio_handle_device_injection(vdev_t *vd, zio_t *zio, int error);
extern int zio_handle_label_injection(zio_t *zio, int error);
extern void zio_handle_ignored_writes(zio_t *zio);
extern uint64_t zio_handle_io_delay(zio_t *zio);

/*
 * Checksum ereport functions
 */
extern void zfs_ereport_start_checksum(spa_t *spa, vdev_t *vd, struct zio *zio,
    uint64_t offset, uint64_t length, void *arg, struct zio_bad_cksum *info);
extern void zfs_ereport_finish_checksum(zio_cksum_report_t *report,
    const void *good_data, const void *bad_data, boolean_t drop_if_identical);

extern void zfs_ereport_send_interim_checksum(zio_cksum_report_t *report);
extern void zfs_ereport_free_checksum(zio_cksum_report_t *report);

/* If we have the good data in hand, this function can be used */
extern void zfs_ereport_post_checksum(spa_t *spa, vdev_t *vd,
    struct zio *zio, uint64_t offset, uint64_t length,
    const void *good_data, const void *bad_data, struct zio_bad_cksum *info);

/* Called from spa_sync(), but primarily an injection handler */
extern void spa_handle_ignored_writes(spa_t *spa);

/* zbookmark_phys functions */
boolean_t zbookmark_is_before(const struct dnode_phys *dnp,
    const zbookmark_phys_t *zb1, const zbookmark_phys_t *zb2);

#ifdef	__cplusplus
}
#endif

#endif	/* _ZIO_H */
                                                                               usr/src/zfs-0.6.5.9/include/sys/zio_checksum.h                                                      0100644 0000000 0000000 00000004244 13045171016 017361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef _SYS_ZIO_CHECKSUM_H
#define	_SYS_ZIO_CHECKSUM_H

#include <sys/zio.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * Signature for checksum functions.
 */
typedef void zio_checksum_t(const void *data, uint64_t size, zio_cksum_t *zcp);

/*
 * Information about each checksum function.
 */
typedef const struct zio_checksum_info {
	zio_checksum_t	*ci_func[2]; /* checksum function for each byteorder */
	int		ci_correctable;	/* number of correctable bits	*/
	int		ci_eck;		/* uses zio embedded checksum? */
	int		ci_dedup;	/* strong enough for dedup? */
	char		*ci_name;	/* descriptive name */
} zio_checksum_info_t;

typedef struct zio_bad_cksum {
	zio_cksum_t		zbc_expected;
	zio_cksum_t		zbc_actual;
	const char		*zbc_checksum_name;
	uint8_t			zbc_byteswapped;
	uint8_t			zbc_injected;
	uint8_t			zbc_has_cksum;	/* expected/actual valid */
} zio_bad_cksum_t;

extern zio_checksum_info_t zio_checksum_table[ZIO_CHECKSUM_FUNCTIONS];

/*
 * Checksum routines.
 */
extern zio_checksum_t zio_checksum_SHA256;

extern void zio_checksum_compute(zio_t *zio, enum zio_checksum checksum,
    void *data, uint64_t size);
extern int zio_checksum_error(zio_t *zio, zio_bad_cksum_t *out);
extern enum zio_checksum spa_dedup_checksum(spa_t *spa);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_ZIO_CHECKSUM_H */
                                                                                                                                                                                                                                                                                                                                                            usr/src/zfs-0.6.5.9/include/sys/zio_compress.h                                                      0100644 0000000 0000000 00000005602 13045171016 017411  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef _SYS_ZIO_COMPRESS_H
#define	_SYS_ZIO_COMPRESS_H

#include <sys/zio.h>

#ifdef	__cplusplus
extern "C" {
#endif

/* Common signature for all zio compress functions. */
typedef size_t zio_compress_func_t(void *src, void *dst,
    size_t s_len, size_t d_len, int);
/* Common signature for all zio decompress functions. */
typedef int zio_decompress_func_t(void *src, void *dst,
    size_t s_len, size_t d_len, int);

/*
 * Information about each compression function.
 */
typedef const struct zio_compress_info {
	zio_compress_func_t	*ci_compress;	/* compression function */
	zio_decompress_func_t	*ci_decompress;	/* decompression function */
	int			ci_level;	/* level parameter */
	char			*ci_name;	/* algorithm name */
} zio_compress_info_t;

extern zio_compress_info_t zio_compress_table[ZIO_COMPRESS_FUNCTIONS];

/*
 * lz4 compression init & free
 */
extern void lz4_init(void);
extern void lz4_fini(void);

/*
 * Compression routines.
 */
extern size_t lzjb_compress(void *src, void *dst, size_t s_len, size_t d_len,
    int level);
extern int lzjb_decompress(void *src, void *dst, size_t s_len, size_t d_len,
    int level);
extern size_t gzip_compress(void *src, void *dst, size_t s_len, size_t d_len,
    int level);
extern int gzip_decompress(void *src, void *dst, size_t s_len, size_t d_len,
    int level);
extern size_t zle_compress(void *src, void *dst, size_t s_len, size_t d_len,
    int level);
extern int zle_decompress(void *src, void *dst, size_t s_len, size_t d_len,
    int level);
extern size_t lz4_compress_zfs(void *src, void *dst, size_t s_len, size_t d_len,
    int level);
extern int lz4_decompress_zfs(void *src, void *dst, size_t s_len, size_t d_len,
    int level);

/*
 * Compress and decompress data if necessary.
 */
extern size_t zio_compress_data(enum zio_compress c, void *src, void *dst,
    size_t s_len);
extern int zio_decompress_data(enum zio_compress c, void *src, void *dst,
    size_t s_len, size_t d_len);

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_ZIO_COMPRESS_H */
                                                                                                                              usr/src/zfs-0.6.5.9/include/sys/zio_impl.h                                                          0100644 0000000 0000000 00000016314 13045171016 016521  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef _ZIO_IMPL_H
#define	_ZIO_IMPL_H

#include <sys/zfs_context.h>
#include <sys/zio.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * XXX -- Describe ZFS I/O pipeline here. Fill in as needed.
 *
 * The ZFS I/O pipeline is comprised of various stages which are defined
 * in the zio_stage enum below. The individual stages are used to construct
 * these basic I/O operations: Read, Write, Free, Claim, and Ioctl.
 *
 * I/O operations: (XXX - provide detail for each of the operations)
 *
 * Read:
 * Write:
 * Free:
 * Claim:
 * Ioctl:
 *
 * Although the most common pipeline are used by the basic I/O operations
 * above, there are some helper pipelines (one could consider them
 * sub-pipelines) which are used internally by the ZIO module and are
 * explained below:
 *
 * Interlock Pipeline:
 * The interlock pipeline is the most basic pipeline and is used by all
 * of the I/O operations. The interlock pipeline does not perform any I/O
 * and is used to coordinate the dependencies between I/Os that are being
 * issued (i.e. the parent/child relationship).
 *
 * Vdev child Pipeline:
 * The vdev child pipeline is responsible for performing the physical I/O.
 * It is in this pipeline where the I/O are queued and possibly cached.
 *
 * In addition to performing I/O, the pipeline is also responsible for
 * data transformations. The transformations performed are based on the
 * specific properties that user may have selected and modify the
 * behavior of the pipeline. Examples of supported transformations are
 * compression, dedup, and nop writes. Transformations will either modify
 * the data or the pipeline. This list below further describes each of
 * the supported transformations:
 *
 * Compression:
 * ZFS supports three different flavors of compression -- gzip, lzjb, and
 * zle. Compression occurs as part of the write pipeline and is performed
 * in the ZIO_STAGE_WRITE_BP_INIT stage.
 *
 * Dedup:
 * Dedup reads are handled by the ZIO_STAGE_DDT_READ_START and
 * ZIO_STAGE_DDT_READ_DONE stages. These stages are added to an existing
 * read pipeline if the dedup bit is set on the block pointer.
 * Writing a dedup block is performed by the ZIO_STAGE_DDT_WRITE stage
 * and added to a write pipeline if a user has enabled dedup on that
 * particular dataset.
 *
 * NOP Write:
 * The NOP write feature is performed by the ZIO_STAGE_NOP_WRITE stage
 * and is added to an existing write pipeline if a crypographically
 * secure checksum (i.e. SHA256) is enabled and compression is turned on.
 * The NOP write stage will compare the checksums of the current data
 * on-disk (level-0 blocks only) and the data that is currently being written.
 * If the checksum values are identical then the pipeline is converted to
 * an interlock pipeline skipping block allocation and bypassing the
 * physical I/O.  The nop write feature can handle writes in either
 * syncing or open context (i.e. zil writes) and as a result is mutually
 * exclusive with dedup.
 */

/*
 * zio pipeline stage definitions
 */
enum zio_stage {
	ZIO_STAGE_OPEN			= 1 << 0,	/* RWFCI */

	ZIO_STAGE_READ_BP_INIT		= 1 << 1,	/* R---- */
	ZIO_STAGE_FREE_BP_INIT		= 1 << 2,	/* --F-- */
	ZIO_STAGE_ISSUE_ASYNC		= 1 << 3,	/* RWF-- */
	ZIO_STAGE_WRITE_BP_INIT		= 1 << 4,	/* -W--- */

	ZIO_STAGE_CHECKSUM_GENERATE	= 1 << 5,	/* -W--- */

	ZIO_STAGE_NOP_WRITE		= 1 << 6,	/* -W--- */

	ZIO_STAGE_DDT_READ_START	= 1 << 7,	/* R---- */
	ZIO_STAGE_DDT_READ_DONE		= 1 << 8,	/* R---- */
	ZIO_STAGE_DDT_WRITE		= 1 << 9,	/* -W--- */
	ZIO_STAGE_DDT_FREE		= 1 << 10,	/* --F-- */

	ZIO_STAGE_GANG_ASSEMBLE		= 1 << 11,	/* RWFC- */
	ZIO_STAGE_GANG_ISSUE		= 1 << 12,	/* RWFC- */

	ZIO_STAGE_DVA_ALLOCATE		= 1 << 13,	/* -W--- */
	ZIO_STAGE_DVA_FREE		= 1 << 14,	/* --F-- */
	ZIO_STAGE_DVA_CLAIM		= 1 << 15,	/* ---C- */

	ZIO_STAGE_READY			= 1 << 16,	/* RWFCI */

	ZIO_STAGE_VDEV_IO_START		= 1 << 17,	/* RW--I */
	ZIO_STAGE_VDEV_IO_DONE		= 1 << 18,	/* RW--I */
	ZIO_STAGE_VDEV_IO_ASSESS	= 1 << 19,	/* RW--I */

	ZIO_STAGE_CHECKSUM_VERIFY	= 1 << 20,	/* R---- */

	ZIO_STAGE_DONE			= 1 << 21	/* RWFCI */
};

#define	ZIO_INTERLOCK_STAGES			\
	(ZIO_STAGE_READY |			\
	ZIO_STAGE_DONE)

#define	ZIO_INTERLOCK_PIPELINE			\
	ZIO_INTERLOCK_STAGES

#define	ZIO_VDEV_IO_STAGES			\
	(ZIO_STAGE_VDEV_IO_START |		\
	ZIO_STAGE_VDEV_IO_DONE |		\
	ZIO_STAGE_VDEV_IO_ASSESS)

#define	ZIO_VDEV_CHILD_PIPELINE			\
	(ZIO_VDEV_IO_STAGES |			\
	ZIO_STAGE_DONE)

#define	ZIO_READ_COMMON_STAGES			\
	(ZIO_INTERLOCK_STAGES |			\
	ZIO_VDEV_IO_STAGES |			\
	ZIO_STAGE_CHECKSUM_VERIFY)

#define	ZIO_READ_PHYS_PIPELINE			\
	ZIO_READ_COMMON_STAGES

#define	ZIO_READ_PIPELINE			\
	(ZIO_READ_COMMON_STAGES |		\
	ZIO_STAGE_READ_BP_INIT)

#define	ZIO_DDT_CHILD_READ_PIPELINE		\
	ZIO_READ_COMMON_STAGES

#define	ZIO_DDT_READ_PIPELINE			\
	(ZIO_INTERLOCK_STAGES |			\
	ZIO_STAGE_READ_BP_INIT |		\
	ZIO_STAGE_DDT_READ_START |		\
	ZIO_STAGE_DDT_READ_DONE)

#define	ZIO_WRITE_COMMON_STAGES			\
	(ZIO_INTERLOCK_STAGES |			\
	ZIO_VDEV_IO_STAGES |			\
	ZIO_STAGE_ISSUE_ASYNC |			\
	ZIO_STAGE_CHECKSUM_GENERATE)

#define	ZIO_WRITE_PHYS_PIPELINE			\
	ZIO_WRITE_COMMON_STAGES

#define	ZIO_REWRITE_PIPELINE			\
	(ZIO_WRITE_COMMON_STAGES |		\
	ZIO_STAGE_WRITE_BP_INIT)

#define	ZIO_WRITE_PIPELINE			\
	(ZIO_WRITE_COMMON_STAGES |		\
	ZIO_STAGE_WRITE_BP_INIT |		\
	ZIO_STAGE_DVA_ALLOCATE)

#define	ZIO_DDT_CHILD_WRITE_PIPELINE		\
	(ZIO_INTERLOCK_STAGES |			\
	ZIO_VDEV_IO_STAGES |			\
	ZIO_STAGE_DVA_ALLOCATE)

#define	ZIO_DDT_WRITE_PIPELINE			\
	(ZIO_INTERLOCK_STAGES |			\
	ZIO_STAGE_ISSUE_ASYNC |			\
	ZIO_STAGE_WRITE_BP_INIT |		\
	ZIO_STAGE_CHECKSUM_GENERATE |		\
	ZIO_STAGE_DDT_WRITE)

#define	ZIO_GANG_STAGES				\
	(ZIO_STAGE_GANG_ASSEMBLE |		\
	ZIO_STAGE_GANG_ISSUE)

#define	ZIO_FREE_PIPELINE			\
	(ZIO_INTERLOCK_STAGES |			\
	ZIO_STAGE_FREE_BP_INIT |		\
	ZIO_STAGE_DVA_FREE)

#define	ZIO_DDT_FREE_PIPELINE			\
	(ZIO_INTERLOCK_STAGES |			\
	ZIO_STAGE_FREE_BP_INIT |		\
	ZIO_STAGE_ISSUE_ASYNC |			\
	ZIO_STAGE_DDT_FREE)

#define	ZIO_CLAIM_PIPELINE			\
	(ZIO_INTERLOCK_STAGES |			\
	ZIO_STAGE_DVA_CLAIM)

#define	ZIO_IOCTL_PIPELINE			\
	(ZIO_INTERLOCK_STAGES |			\
	ZIO_STAGE_VDEV_IO_START |		\
	ZIO_STAGE_VDEV_IO_ASSESS)

#define	ZIO_BLOCKING_STAGES			\
	(ZIO_STAGE_DVA_ALLOCATE |		\
	ZIO_STAGE_DVA_CLAIM |			\
	ZIO_STAGE_VDEV_IO_START)

extern void zio_inject_init(void);
extern void zio_inject_fini(void);

#ifdef	__cplusplus
}
#endif

#endif	/* _ZIO_IMPL_H */
                                                                                                                                                                                                                                                                                                                    usr/src/zfs-0.6.5.9/include/sys/zpl.h                                                               0100644 0000000 0000000 00000013130 13045171016 015475  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2011, Lawrence Livermore National Security, LLC.
 */

#ifndef	_SYS_ZPL_H
#define	_SYS_ZPL_H

#include <sys/mntent.h>
#include <sys/vfs.h>
#include <linux/aio.h>
#include <linux/dcache_compat.h>
#include <linux/exportfs.h>
#include <linux/falloc.h>
#include <linux/file_compat.h>
#include <linux/parser.h>
#include <linux/task_io_accounting_ops.h>
#include <linux/vfs_compat.h>
#include <linux/writeback.h>
#include <linux/xattr_compat.h>

/* zpl_inode.c */
extern void zpl_vap_init(vattr_t *vap, struct inode *dir,
    zpl_umode_t mode, cred_t *cr);

extern const struct inode_operations zpl_inode_operations;
extern const struct inode_operations zpl_dir_inode_operations;
extern const struct inode_operations zpl_symlink_inode_operations;
extern const struct inode_operations zpl_special_inode_operations;
extern dentry_operations_t zpl_dentry_operations;

/* zpl_file.c */
extern ssize_t zpl_read_common(struct inode *ip, const char *buf,
    size_t len, loff_t *ppos, uio_seg_t segment, int flags,
    cred_t *cr);
extern ssize_t zpl_write_common(struct inode *ip, const char *buf,
    size_t len, loff_t *ppos, uio_seg_t segment, int flags,
    cred_t *cr);
#if defined(HAVE_FILE_FALLOCATE) || defined(HAVE_INODE_FALLOCATE)
extern long zpl_fallocate_common(struct inode *ip, int mode,
    loff_t offset, loff_t len);
#endif /* defined(HAVE_FILE_FALLOCATE) || defined(HAVE_INODE_FALLOCATE) */

extern const struct address_space_operations zpl_address_space_operations;
extern const struct file_operations zpl_file_operations;
extern const struct file_operations zpl_dir_file_operations;

/* zpl_super.c */
extern void zpl_prune_sb(int64_t nr_to_scan, void *arg);

extern const struct super_operations zpl_super_operations;
extern const struct export_operations zpl_export_operations;
extern struct file_system_type zpl_fs_type;

/* zpl_xattr.c */
extern ssize_t zpl_xattr_list(struct dentry *dentry, char *buf, size_t size);
extern int zpl_xattr_security_init(struct inode *ip, struct inode *dip,
    const struct qstr *qstr);
#if defined(CONFIG_FS_POSIX_ACL)
extern int zpl_set_acl(struct inode *ip, struct posix_acl *acl, int type);
extern struct posix_acl *zpl_get_acl(struct inode *ip, int type);
#if !defined(HAVE_GET_ACL)
#if defined(HAVE_CHECK_ACL_WITH_FLAGS)
extern int zpl_check_acl(struct inode *inode, int mask, unsigned int flags);
#elif defined(HAVE_CHECK_ACL)
extern int zpl_check_acl(struct inode *inode, int mask);
#elif defined(HAVE_PERMISSION_WITH_NAMEIDATA)
extern int zpl_permission(struct inode *ip, int mask, struct nameidata *nd);
#elif defined(HAVE_PERMISSION)
extern int zpl_permission(struct inode *ip, int mask);
#endif /*  HAVE_CHECK_ACL | HAVE_PERMISSION */
#endif /* HAVE_GET_ACL */

extern int zpl_init_acl(struct inode *ip, struct inode *dir);
extern int zpl_chmod_acl(struct inode *ip);
#else
static inline int
zpl_init_acl(struct inode *ip, struct inode *dir)
{
	return (0);
}

static inline int
zpl_chmod_acl(struct inode *ip)
{
	return (0);
}
#endif /* CONFIG_FS_POSIX_ACL */

extern xattr_handler_t *zpl_xattr_handlers[];

/* zpl_ctldir.c */
extern const struct file_operations zpl_fops_root;
extern const struct inode_operations zpl_ops_root;

extern const struct file_operations zpl_fops_snapdir;
extern const struct inode_operations zpl_ops_snapdir;
#ifdef HAVE_AUTOMOUNT
extern const struct dentry_operations zpl_dops_snapdirs;
#else
extern const struct inode_operations zpl_ops_snapdirs;
#endif /* HAVE_AUTOMOUNT */

extern const struct file_operations zpl_fops_shares;
extern const struct inode_operations zpl_ops_shares;

#if defined(HAVE_VFS_ITERATE) || defined(HAVE_VFS_ITERATE_SHARED)

#define	DIR_CONTEXT_INIT(_dirent, _actor, _pos) {	\
	.actor = _actor,				\
	.pos = _pos,					\
}

#else

typedef struct dir_context {
	void *dirent;
	const filldir_t actor;
	loff_t pos;
} dir_context_t;

#define	DIR_CONTEXT_INIT(_dirent, _actor, _pos) {	\
	.dirent = _dirent,				\
	.actor = _actor,				\
	.pos = _pos,					\
}

static inline bool
dir_emit(struct dir_context *ctx, const char *name, int namelen,
    uint64_t ino, unsigned type)
{
	return (ctx->actor(ctx->dirent, name, namelen, ctx->pos, ino, type)
		== 0);
}

static inline bool
dir_emit_dot(struct file *file, struct dir_context *ctx)
{
	return (ctx->actor(ctx->dirent, ".", 1, ctx->pos,
	    file->f_path.dentry->d_inode->i_ino, DT_DIR) == 0);
}

static inline bool
dir_emit_dotdot(struct file *file, struct dir_context *ctx)
{
	return (ctx->actor(ctx->dirent, "..", 2, ctx->pos,
	    parent_ino(file->f_path.dentry), DT_DIR) == 0);
}

static inline bool
dir_emit_dots(struct file *file, struct dir_context *ctx)
{
	if (ctx->pos == 0) {
		if (!dir_emit_dot(file, ctx))
			return (false);
		ctx->pos = 1;
	}
	if (ctx->pos == 1) {
		if (!dir_emit_dotdot(file, ctx))
			return (false);
		ctx->pos = 2;
	}
	return (true);
}
#endif /* HAVE_VFS_ITERATE */

#endif	/* _SYS_ZPL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/src/zfs-0.6.5.9/include/sys/zrlock.h                                                            0100644 0000000 0000000 00000003326 13045171016 016202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 */

#ifndef	_SYS_ZRLOCK_H
#define	_SYS_ZRLOCK_H

#include <sys/zfs_context.h>

#ifdef	__cplusplus
extern "C" {
#endif

typedef struct zrlock {
	kmutex_t zr_mtx;
	volatile int32_t zr_refcount;
	kcondvar_t zr_cv;
	uint16_t zr_pad;
#ifdef	ZFS_DEBUG
	kthread_t *zr_owner;
	const char *zr_caller;
#endif
} zrlock_t;

extern void zrl_init(zrlock_t *);
extern void zrl_destroy(zrlock_t *);
#ifdef	ZFS_DEBUG
#define	zrl_add(_z)	zrl_add_debug((_z), __func__)
extern void zrl_add_debug(zrlock_t *, const char *);
#else
extern void zrl_add(zrlock_t *);
#endif
extern void zrl_remove(zrlock_t *);
extern int zrl_tryenter(zrlock_t *);
extern void zrl_exit(zrlock_t *);
extern int zrl_is_zero(zrlock_t *);
extern int zrl_is_locked(zrlock_t *);
#ifdef	ZFS_DEBUG
extern kthread_t *zrl_owner(zrlock_t *);
#endif

#ifdef	__cplusplus
}
#endif

#endif /* _SYS_ZRLOCK_H */
                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/include/sys/zvol.h                                                              0100644 0000000 0000000 00000003672 13045171016 015674  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2016 Actifio, Inc. All rights reserved.
 */

#ifndef	_SYS_ZVOL_H
#define	_SYS_ZVOL_H

#include <sys/zfs_context.h>

#define	ZVOL_OBJ		1ULL
#define	ZVOL_ZAP_OBJ		2ULL

extern void zvol_create_minors(spa_t *spa, const char *name, boolean_t async);
extern void zvol_remove_minors(spa_t *spa, const char *name, boolean_t async);
extern void zvol_rename_minors(spa_t *spa, const char *oldname,
    const char *newname, boolean_t async);

#ifdef _KERNEL
extern int zvol_check_volsize(uint64_t volsize, uint64_t blocksize);
extern int zvol_check_volblocksize(const char *name, uint64_t volblocksize);
extern int zvol_get_stats(objset_t *os, nvlist_t *nv);
extern boolean_t zvol_is_zvol(const char *);
extern void zvol_create_cb(objset_t *os, void *arg, cred_t *cr, dmu_tx_t *tx);
extern int zvol_set_volsize(const char *, uint64_t);
extern int zvol_set_volblocksize(const char *, uint64_t);
extern int zvol_set_snapdev(const char *, zprop_source_t, uint64_t);

extern int zvol_init(void);
extern void zvol_fini(void);
#endif /* _KERNEL */
#endif /* _SYS_ZVOL_H */
                                                                      usr/src/zfs-0.6.5.9/include/zfeature_common.h                                                       0100644 0000000 0000000 00000005060 13045171016 017252  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2013 by Delphix. All rights reserved.
 * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
 */

#ifndef _ZFEATURE_COMMON_H
#define	_ZFEATURE_COMMON_H

#include <sys/fs/zfs.h>
#include <sys/inttypes.h>
#include <sys/types.h>

#ifdef	__cplusplus
extern "C" {
#endif

struct zfeature_info;

typedef enum spa_feature {
	SPA_FEATURE_NONE = -1,
	SPA_FEATURE_ASYNC_DESTROY,
	SPA_FEATURE_EMPTY_BPOBJ,
	SPA_FEATURE_LZ4_COMPRESS,
	SPA_FEATURE_SPACEMAP_HISTOGRAM,
	SPA_FEATURE_ENABLED_TXG,
	SPA_FEATURE_HOLE_BIRTH,
	SPA_FEATURE_EXTENSIBLE_DATASET,
	SPA_FEATURE_EMBEDDED_DATA,
	SPA_FEATURE_BOOKMARKS,
	SPA_FEATURE_FS_SS_LIMIT,
	SPA_FEATURE_LARGE_BLOCKS,
	SPA_FEATURES
} spa_feature_t;

#define	SPA_FEATURE_DISABLED	(-1ULL)

typedef struct zfeature_info {
	spa_feature_t fi_feature;
	const char *fi_uname;	/* User-facing feature name */
	const char *fi_guid;	/* On-disk feature identifier */
	const char *fi_desc;	/* Feature description */
	boolean_t fi_can_readonly; /* Can open pool readonly w/o support? */
	boolean_t fi_mos;	/* Is the feature necessary to read the MOS? */
	/* Activate this feature at the same time it is enabled */
	boolean_t fi_activate_on_enable;
	/* array of dependencies, terminated by SPA_FEATURE_NONE */
	const spa_feature_t *fi_depends;
} zfeature_info_t;

typedef int (zfeature_func_t)(zfeature_info_t *, void *);

#define	ZFS_FEATURE_DEBUG

extern zfeature_info_t spa_feature_table[SPA_FEATURES];

extern boolean_t zfeature_is_valid_guid(const char *);

extern boolean_t zfeature_is_supported(const char *);
extern int zfeature_lookup_name(const char *, spa_feature_t *);
extern boolean_t zfeature_depends_on(spa_feature_t, spa_feature_t);

extern void zpool_feature_init(void);

#ifdef	__cplusplus
}
#endif

#endif	/* _ZFEATURE_COMMON_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/src/zfs-0.6.5.9/include/zfs_comutil.h                                                           0100644 0000000 0000000 00000002730 13045171016 016414  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012 by Delphix. All rights reserved.
 */

#ifndef	_ZFS_COMUTIL_H
#define	_ZFS_COMUTIL_H

#include <sys/fs/zfs.h>
#include <sys/types.h>

#ifdef	__cplusplus
extern "C" {
#endif

extern boolean_t zfs_allocatable_devs(nvlist_t *);
extern void zpool_get_rewind_policy(nvlist_t *, zpool_rewind_policy_t *);

extern int zfs_zpl_version_map(int spa_version);
extern int zfs_spa_version_map(int zpl_version);
#define	ZFS_NUM_LEGACY_HISTORY_EVENTS 41
extern const char *zfs_history_event_names[ZFS_NUM_LEGACY_HISTORY_EVENTS];

#ifdef	__cplusplus
}
#endif

#endif	/* _ZFS_COMUTIL_H */
                                        usr/src/zfs-0.6.5.9/include/zfs_deleg.h                                                             0100644 0000000 0000000 00000004555 13045171016 016027  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2010 Nexenta Systems, Inc. All rights reserved.
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef	_ZFS_DELEG_H
#define	_ZFS_DELEG_H

#include <sys/fs/zfs.h>

#ifdef	__cplusplus
extern "C" {
#endif

#define	ZFS_DELEG_SET_NAME_CHR		'@'		/* set name lead char */
#define	ZFS_DELEG_FIELD_SEP_CHR		'$'		/* field separator */

/*
 * Max name length for a delegation attribute
 */
#define	ZFS_MAX_DELEG_NAME	128

#define	ZFS_DELEG_LOCAL		'l'
#define	ZFS_DELEG_DESCENDENT	'd'
#define	ZFS_DELEG_NA		'-'

typedef enum {
	ZFS_DELEG_NOTE_CREATE,
	ZFS_DELEG_NOTE_DESTROY,
	ZFS_DELEG_NOTE_SNAPSHOT,
	ZFS_DELEG_NOTE_ROLLBACK,
	ZFS_DELEG_NOTE_CLONE,
	ZFS_DELEG_NOTE_PROMOTE,
	ZFS_DELEG_NOTE_RENAME,
	ZFS_DELEG_NOTE_SEND,
	ZFS_DELEG_NOTE_RECEIVE,
	ZFS_DELEG_NOTE_ALLOW,
	ZFS_DELEG_NOTE_USERPROP,
	ZFS_DELEG_NOTE_MOUNT,
	ZFS_DELEG_NOTE_SHARE,
	ZFS_DELEG_NOTE_USERQUOTA,
	ZFS_DELEG_NOTE_GROUPQUOTA,
	ZFS_DELEG_NOTE_USERUSED,
	ZFS_DELEG_NOTE_GROUPUSED,
	ZFS_DELEG_NOTE_HOLD,
	ZFS_DELEG_NOTE_RELEASE,
	ZFS_DELEG_NOTE_DIFF,
	ZFS_DELEG_NOTE_BOOKMARK,
	ZFS_DELEG_NOTE_NONE
} zfs_deleg_note_t;

typedef struct zfs_deleg_perm_tab {
	char *z_perm;
	zfs_deleg_note_t z_note;
} zfs_deleg_perm_tab_t;

extern zfs_deleg_perm_tab_t zfs_deleg_perm_tab[];

int zfs_deleg_verify_nvlist(nvlist_t *nvlist);
void zfs_deleg_whokey(char *attr, zfs_deleg_who_type_t type,
    char checkflag, void *data);
const char *zfs_deleg_canonicalize_perm(const char *perm);

#ifdef	__cplusplus
}
#endif

#endif	/* _ZFS_DELEG_H */
                                                                                                                                                   usr/src/zfs-0.6.5.9/include/zfs_fletcher.h                                                          0100644 0000000 0000000 00000003047 13045171016 016536  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_ZFS_FLETCHER_H
#define	_ZFS_FLETCHER_H

#include <sys/types.h>
#include <sys/spa.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * fletcher checksum functions
 */

void fletcher_2_native(const void *, uint64_t, zio_cksum_t *);
void fletcher_2_byteswap(const void *, uint64_t, zio_cksum_t *);
void fletcher_4_native(const void *, uint64_t, zio_cksum_t *);
void fletcher_4_byteswap(const void *, uint64_t, zio_cksum_t *);
void fletcher_4_incremental_native(const void *, uint64_t,
    zio_cksum_t *);
void fletcher_4_incremental_byteswap(const void *, uint64_t,
    zio_cksum_t *);

#ifdef	__cplusplus
}
#endif

#endif	/* _ZFS_FLETCHER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/src/zfs-0.6.5.9/include/zfs_namecheck.h                                                         0100644 0000000 0000000 00000004046 13045171016 016660  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */
/*
 * Copyright (c) 2013 by Delphix. All rights reserved.
 */

#ifndef	_ZFS_NAMECHECK_H
#define	_ZFS_NAMECHECK_H

#ifdef	__cplusplus
extern "C" {
#endif

typedef enum {
	NAME_ERR_LEADING_SLASH,		/* name begins with leading slash */
	NAME_ERR_EMPTY_COMPONENT,	/* name contains an empty component */
	NAME_ERR_TRAILING_SLASH,	/* name ends with a slash */
	NAME_ERR_INVALCHAR,		/* invalid character found */
	NAME_ERR_MULTIPLE_AT,		/* multiple '@' characters found */
	NAME_ERR_NOLETTER,		/* pool doesn't begin with a letter */
	NAME_ERR_RESERVED,		/* entire name is reserved */
	NAME_ERR_DISKLIKE,		/* reserved disk name (c[0-9].*) */
	NAME_ERR_TOOLONG,		/* name is too long */
	NAME_ERR_NO_AT,			/* permission set is missing '@' */
} namecheck_err_t;

#define	ZFS_PERMSET_MAXLEN	64

int pool_namecheck(const char *, namecheck_err_t *, char *);
int dataset_namecheck(const char *, namecheck_err_t *, char *);
int mountpoint_namecheck(const char *, namecheck_err_t *);
int zfs_component_namecheck(const char *, namecheck_err_t *, char *);
int permset_namecheck(const char *, namecheck_err_t *, char *);

#ifdef	__cplusplus
}
#endif

#endif	/* _ZFS_NAMECHECK_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/include/zfs_prop.h                                                              0100644 0000000 0000000 00000010355 13045171016 015722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#ifndef	_ZFS_PROP_H
#define	_ZFS_PROP_H

#include <sys/fs/zfs.h>
#include <sys/types.h>

#ifdef	__cplusplus
extern "C" {
#endif

/*
 * For index types (e.g. compression and checksum), we want the numeric value
 * in the kernel, but the string value in userland.
 */
typedef enum {
	PROP_TYPE_NUMBER,	/* numeric value */
	PROP_TYPE_STRING,	/* string value */
	PROP_TYPE_INDEX		/* numeric value indexed by string */
} zprop_type_t;

typedef enum {
	PROP_DEFAULT,
	PROP_READONLY,
	PROP_INHERIT,
	/*
	 * ONETIME properties are a sort of conglomeration of READONLY
	 * and INHERIT.  They can be set only during object creation,
	 * after that they are READONLY.  If not explicitly set during
	 * creation, they can be inherited.
	 */
	PROP_ONETIME
} zprop_attr_t;

typedef struct zfs_index {
	const char *pi_name;
	uint64_t pi_value;
} zprop_index_t;

typedef struct {
	const char *pd_name;		/* human-readable property name */
	int pd_propnum;			/* property number */
	zprop_type_t pd_proptype;	/* string, boolean, index, number */
	const char *pd_strdefault;	/* default for strings */
	uint64_t pd_numdefault;		/* for boolean / index / number */
	zprop_attr_t pd_attr;		/* default, readonly, inherit */
	int pd_types;			/* bitfield of valid dataset types */
					/* fs | vol | snap; or pool */
	const char *pd_values;		/* string telling acceptable values */
	const char *pd_colname;		/* column header for "zfs list" */
	boolean_t pd_rightalign;	/* column alignment for "zfs list" */
	boolean_t pd_visible;		/* do we list this property with the */
					/* "zfs get" help message */
	const zprop_index_t *pd_table;	/* for index properties, a table */
					/* defining the possible values */
	size_t pd_table_size;		/* number of entries in pd_table[] */
} zprop_desc_t;

/*
 * zfs dataset property functions
 */
void zfs_prop_init(void);
zprop_type_t zfs_prop_get_type(zfs_prop_t);
boolean_t zfs_prop_delegatable(zfs_prop_t prop);
zprop_desc_t *zfs_prop_get_table(void);

/*
 * zpool property functions
 */
void zpool_prop_init(void);
zprop_type_t zpool_prop_get_type(zpool_prop_t);
zprop_desc_t *zpool_prop_get_table(void);

/*
 * Common routines to initialize property tables
 */
void zprop_register_impl(int, const char *, zprop_type_t, uint64_t,
    const char *, zprop_attr_t, int, const char *, const char *,
    boolean_t, boolean_t, const zprop_index_t *);
void zprop_register_string(int, const char *, const char *,
    zprop_attr_t attr, int, const char *, const char *);
void zprop_register_number(int, const char *, uint64_t, zprop_attr_t, int,
    const char *, const char *);
void zprop_register_index(int, const char *, uint64_t, zprop_attr_t, int,
    const char *, const char *, const zprop_index_t *);
void zprop_register_hidden(int, const char *, zprop_type_t, zprop_attr_t,
    int, const char *);

/*
 * Common routines for zfs and zpool property management
 */
int zprop_iter_common(zprop_func, void *, boolean_t, boolean_t, zfs_type_t);
int zprop_name_to_prop(const char *, zfs_type_t);
int zprop_string_to_index(int, const char *, uint64_t *, zfs_type_t);
int zprop_index_to_string(int, uint64_t, const char **, zfs_type_t);
uint64_t zprop_random_value(int, uint64_t, zfs_type_t);
const char *zprop_values(int, zfs_type_t);
size_t zprop_width(int, boolean_t *, zfs_type_t);
boolean_t zprop_valid_for_type(int, zfs_type_t, boolean_t);

#ifdef	__cplusplus
}
#endif

#endif	/* _ZFS_PROP_H */
                                                                                                                                                                                                                                                                                   usr/src/zfs-0.6.5.9/include/zpios-ctl.h                                                             0100644 0000000 0000000 00000012727 13045171016 016011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 *  ZPIOS is a heavily modified version of the original PIOS test code.
 *  It is designed to have the test code running in the Linux kernel
 *  against ZFS while still being flexibly controled from user space.
 *
 *  Copyright (C) 2008-2010 Lawrence Livermore National Security, LLC.
 *  Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
 *  Written by Brian Behlendorf <behlendorf1@llnl.gov>.
 *  LLNL-CODE-403049
 *
 *  Original PIOS Test Code
 *  Copyright (C) 2004 Cluster File Systems, Inc.
 *  Written by Peter Braam <braam@clusterfs.com>
 *             Atul Vidwansa <atul@clusterfs.com>
 *             Milind Dumbare <milind@clusterfs.com>
 *
 *  This file is part of ZFS on Linux.
 *  For details, see <http://zfsonlinux.org/>.
 *
 *  ZPIOS is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or (at your
 *  option) any later version.
 *
 *  ZPIOS is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with ZPIOS.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _ZPIOS_CTL_H
#define	_ZPIOS_CTL_H

/*
 * Contains shared definitions which both the userspace
 * and kernelspace portions of zpios must agree on.
 */
#ifndef _KERNEL
#include <stdint.h>
#endif

#define	ZPIOS_NAME			"zpios"
#define	ZPIOS_DEV			"/dev/zpios"

#define	DMU_IO				0x01

#define	DMU_WRITE			0x0001
#define	DMU_READ			0x0002
#define	DMU_VERIFY			0x0004
#define	DMU_REMOVE			0x0008
#define	DMU_FPP				0x0010
#define	DMU_WRITE_ZC			0x0020 /* Incompatible w/DMU_VERIFY */
#define	DMU_READ_ZC			0x0040 /* Incompatible w/DMU_VERIFY */
#define	DMU_WRITE_NOWAIT		0x0080
#define	DMU_READ_NOPF			0x0100

#define	ZPIOS_NAME_SIZE			16
#define	ZPIOS_PATH_SIZE			128

#define	PHASE_PRE_RUN			"pre-run"
#define	PHASE_PRE_CREATE		"pre-create"
#define	PHASE_PRE_WRITE			"pre-write"
#define	PHASE_PRE_READ			"pre-read"
#define	PHASE_PRE_REMOVE		"pre-remove"
#define	PHASE_POST_RUN			"post-run"
#define	PHASE_POST_CREATE		"post-create"
#define	PHASE_POST_WRITE		"post-write"
#define	PHASE_POST_READ			"post-read"
#define	PHASE_POST_REMOVE		"post-remove"

#define	ZPIOS_CFG_MAGIC			0x87237190U
typedef struct zpios_cfg {
	uint32_t cfg_magic;		/* Unique magic */
	int32_t cfg_cmd;		/* Config command */
	int32_t cfg_arg1;		/* Config command arg 1 */
	int32_t cfg_rc1;		/* Config response 1 */
} zpios_cfg_t;

typedef struct zpios_timespec {
	uint32_t ts_sec;
	uint32_t ts_nsec;
} zpios_timespec_t;

typedef struct zpios_time {
	zpios_timespec_t start;
	zpios_timespec_t stop;
	zpios_timespec_t delta;
} zpios_time_t;

typedef struct zpios_stats {
	zpios_time_t total_time;
	zpios_time_t cr_time;
	zpios_time_t rm_time;
	zpios_time_t wr_time;
	zpios_time_t rd_time;
	uint64_t wr_data;
	uint64_t wr_chunks;
	uint64_t rd_data;
	uint64_t rd_chunks;
} zpios_stats_t;

#define	ZPIOS_CMD_MAGIC			0x49715385U
typedef struct zpios_cmd {
	uint32_t cmd_magic;		/* Unique magic */
	uint32_t cmd_id;		/* Run ID */
	char cmd_pool[ZPIOS_NAME_SIZE];	/* Pool name */
	uint64_t cmd_chunk_size;	/* Chunk size */
	uint32_t cmd_thread_count;	/* Thread count */
	uint32_t cmd_region_count;	/* Region count */
	uint64_t cmd_region_size;	/* Region size */
	uint64_t cmd_offset;		/* Region offset */
	uint32_t cmd_region_noise;	/* Region noise */
	uint32_t cmd_chunk_noise;	/* Chunk noise */
	uint32_t cmd_thread_delay;	/* Thread delay */
	uint32_t cmd_flags;		/* Test flags */
	char cmd_pre[ZPIOS_PATH_SIZE];	/* Pre-exec hook */
	char cmd_post[ZPIOS_PATH_SIZE];	/* Post-exec hook */
	char cmd_log[ZPIOS_PATH_SIZE];  /* Requested log dir */
	uint64_t cmd_data_size;		/* Opaque data size */
	char cmd_data_str[0];		/* Opaque data region */
} zpios_cmd_t;

/* Valid ioctls */
#define	ZPIOS_CFG			_IOWR('f', 101, zpios_cfg_t)
#define	ZPIOS_CMD			_IOWR('f', 102, zpios_cmd_t)

/* Valid configuration commands */
#define	ZPIOS_CFG_BUFFER_CLEAR		0x001	/* Clear text buffer */
#define	ZPIOS_CFG_BUFFER_SIZE		0x002	/* Resize text buffer */

#ifndef NSEC_PER_SEC
#define	NSEC_PER_SEC    1000000000L
#endif

static inline
void
zpios_timespec_normalize(zpios_timespec_t *ts, uint32_t sec, uint32_t nsec)
{
	while (nsec >= NSEC_PER_SEC) {
		nsec -= NSEC_PER_SEC;
		sec++;
	}
	while (nsec < 0) {
		nsec += NSEC_PER_SEC;
		sec--;
	}
	ts->ts_sec = sec;
	ts->ts_nsec = nsec;
}

static inline
zpios_timespec_t
zpios_timespec_add(zpios_timespec_t lhs, zpios_timespec_t rhs)
{
	zpios_timespec_t ts_delta;
	zpios_timespec_normalize(&ts_delta, lhs.ts_sec + rhs.ts_sec,
	    lhs.ts_nsec + rhs.ts_nsec);
	return (ts_delta);
}

static inline
zpios_timespec_t
zpios_timespec_sub(zpios_timespec_t lhs, zpios_timespec_t rhs)
{
	zpios_timespec_t ts_delta;
	zpios_timespec_normalize(&ts_delta, lhs.ts_sec - rhs.ts_sec,
	    lhs.ts_nsec - rhs.ts_nsec);
	return (ts_delta);
}

#ifdef _KERNEL

static inline
zpios_timespec_t
zpios_timespec_now(void)
{
	zpios_timespec_t zts_now;
	struct timespec ts_now;

	ts_now = current_kernel_time();
	zts_now.ts_sec  = ts_now.tv_sec;
	zts_now.ts_nsec = ts_now.tv_nsec;

	return (zts_now);
}

#else

static inline
double
zpios_timespec_to_double(zpios_timespec_t ts)
{
	return
	    ((double)(ts.ts_sec) +
	    ((double)(ts.ts_nsec) / (double)(NSEC_PER_SEC)));
}

#endif /* _KERNEL */

#endif /* _ZPIOS_CTL_H */
                                         usr/src/zfs-0.6.5.9/include/zpios-internal.h                                                        0100644 0000000 0000000 00000005532 13045171016 017037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 *  ZPIOS is a heavily modified version of the original PIOS test code.
 *  It is designed to have the test code running in the Linux kernel
 *  against ZFS while still being flexibly controled from user space.
 *
 *  Copyright (C) 2008-2010 Lawrence Livermore National Security, LLC.
 *  Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
 *  Written by Brian Behlendorf <behlendorf1@llnl.gov>.
 *  LLNL-CODE-403049
 *
 *  Original PIOS Test Code
 *  Copyright (C) 2004 Cluster File Systems, Inc.
 *  Written by Peter Braam <braam@clusterfs.com>
 *             Atul Vidwansa <atul@clusterfs.com>
 *             Milind Dumbare <milind@clusterfs.com>
 *
 *  This file is part of ZFS on Linux.
 *  For details, see <http://zfsonlinux.org/>.
 *
 *  ZPIOS is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or (at your
 *  option) any later version.
 *
 *  ZPIOS is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with ZPIOS.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _ZPIOS_INTERNAL_H
#define	_ZPIOS_INTERNAL_H

#include "zpios-ctl.h"

#define	OBJ_SIZE	64

struct run_args;

typedef struct dmu_obj {
	objset_t *os;
	uint64_t obj;
} dmu_obj_t;

/* thread doing the IO data */
typedef struct thread_data {
	struct run_args *run_args;
	int thread_no;
	int rc;
	zpios_stats_t stats;
	kmutex_t lock;
} thread_data_t;

/* region for IO data */
typedef struct zpios_region {
	__u64 wr_offset;
	__u64 rd_offset;
	__u64 init_offset;
	__u64 max_offset;
	dmu_obj_t obj;
	zpios_stats_t stats;
	kmutex_t lock;
} zpios_region_t;

/* arguments for one run */
typedef struct run_args {
	/* Config args */
	int id;
	char pool[ZPIOS_NAME_SIZE];
	__u64 chunk_size;
	__u32 thread_count;
	__u32 region_count;
	__u64 region_size;
	__u64 offset;
	__u32 region_noise;
	__u32 chunk_noise;
	__u32 thread_delay;
	__u32 flags;
	char pre[ZPIOS_PATH_SIZE];
	char post[ZPIOS_PATH_SIZE];
	char log[ZPIOS_PATH_SIZE];

	/* Control data */
	objset_t *os;
	wait_queue_head_t waitq;
	volatile uint64_t threads_done;
	kmutex_t lock_work;
	kmutex_t lock_ctl;
	__u32 region_next;

	/* Results data */
	struct file *file;
	zpios_stats_t stats;

	thread_data_t **threads;
	zpios_region_t regions[0]; /* Must be last element */
} run_args_t;

#define	ZPIOS_INFO_BUFFER_SIZE		65536
#define	ZPIOS_INFO_BUFFER_REDZONE	1024

typedef struct zpios_info {
	spinlock_t info_lock;
	int info_size;
	char *info_buffer;
	char *info_head;	/* Internal kernel use only */
} zpios_info_t;

#endif /* _ZPIOS_INTERNAL_H */
                                                                                                                                                                      usr/src/zfs-0.6.5.9/lib/                                                                            0040755 0000000 0000000 00000000000 13077704276 013050  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/Makefile.in                                                                 0100644 0000000 0000000 00000000006 13045370710 015071  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libavl/                                                                     0040755 0000000 0000000 00000000000 13077704276 014321  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libavl/Makefile.in                                                          0100644 0000000 0000000 00000000006 13045370710 016342  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libefi/                                                                     0040755 0000000 0000000 00000000000 13077704276 014302  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libefi/Makefile.in                                                          0100644 0000000 0000000 00000000006 13045370710 016323  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libnvpair/                                                                  0040755 0000000 0000000 00000000000 13077704276 015036  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libnvpair/Makefile.in                                                       0100644 0000000 0000000 00000000006 13045370710 017057  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libshare/                                                                   0040755 0000000 0000000 00000000000 13077704276 014641  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libshare/Makefile.in                                                        0100644 0000000 0000000 00000000006 13045370710 016662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/                                                                     0040755 0000000 0000000 00000000000 13077704276 014335  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/Makefile.in                                                          0100644 0000000 0000000 00000000006 13045370710 016356  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/asm-generic/                                                         0040755 0000000 0000000 00000000000 13077704276 016527  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/asm-generic/Makefile.in                                              0100644 0000000 0000000 00000000006 13045370710 020550  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/asm-i386/                                                            0040755 0000000 0000000 00000000000 13077704276 015604  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/asm-i386/Makefile.in                                                 0100644 0000000 0000000 00000000006 13045370710 017625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/asm-x86_64/                                                          0040755 0000000 0000000 00000000000 13077704276 016051  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/asm-x86_64/Makefile.in                                               0100644 0000000 0000000 00000000006 13045370710 020072  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/include/                                                             0040755 0000000 0000000 00000000000 13077704276 015760  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/include/Makefile.in                                                  0100644 0000000 0000000 00000000006 13045370707 020007  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/include/ia32/                                                        0040755 0000000 0000000 00000000000 13077704276 016516  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/include/ia32/Makefile.in                                             0100644 0000000 0000000 00000000006 13045370710 020537  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/include/ia32/sys/                                                    0040755 0000000 0000000 00000000000 13077704276 017334  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/include/ia32/sys/Makefile.in                                         0100644 0000000 0000000 00000000006 13045370710 021355  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/include/rpc/                                                         0040755 0000000 0000000 00000000000 13077704276 016544  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/include/rpc/Makefile.in                                              0100644 0000000 0000000 00000000006 13045370710 020565  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/include/sys/                                                         0040755 0000000 0000000 00000000000 13077704276 016576  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/include/sys/Makefile.in                                              0100644 0000000 0000000 00000000006 13045370707 020625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/include/sys/dktp/                                                    0040755 0000000 0000000 00000000000 13077704276 017540  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/include/sys/dktp/Makefile.in                                         0100644 0000000 0000000 00000000006 13045370710 021561  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/include/sys/sysevent/                                                0040755 0000000 0000000 00000000000 13077704276 020456  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/include/sys/sysevent/Makefile.in                                     0100644 0000000 0000000 00000000006 13045370710 022477  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libspl/include/util/                                                        0040755 0000000 0000000 00000000000 13077704276 016735  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libspl/include/util/Makefile.in                                             0100644 0000000 0000000 00000000006 13045370707 020764  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libunicode/                                                                 0040755 0000000 0000000 00000000000 13077704276 015165  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libunicode/Makefile.in                                                      0100644 0000000 0000000 00000000006 13045370710 017206  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libuutil/                                                                   0040755 0000000 0000000 00000000000 13077704276 014701  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libuutil/Makefile.in                                                        0100644 0000000 0000000 00000000006 13045370710 016722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libzfs/                                                                     0040755 0000000 0000000 00000000000 13077704276 014341  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libzfs/Makefile.in                                                          0100644 0000000 0000000 00000000006 13045370710 016362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libzfs/libzfs.pc.in                                                         0100644 0000000 0000000 00000000006 13045370710 016537  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libzfs/libzfs_core.pc.in                                                    0100644 0000000 0000000 00000000006 13045370710 017547  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libzfs_core/                                                                0040755 0000000 0000000 00000000000 13077704276 015351  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libzfs_core/Makefile.in                                                     0100644 0000000 0000000 00000000006 13045370710 017372  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/lib/libzpool/                                                                   0040755 0000000 0000000 00000000000 13077704276 014702  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/lib/libzpool/Makefile.in                                                        0100644 0000000 0000000 00000000006 13045370707 016731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/man/                                                                            0040755 0000000 0000000 00000000000 13077704276 013055  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/man/Makefile.in                                                                 0100644 0000000 0000000 00000000006 13045370710 015076  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/man/man1/                                                                       0040755 0000000 0000000 00000000000 13077704276 013711  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/man/man1/Makefile.in                                                            0100644 0000000 0000000 00000000006 13045370710 015732  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/man/man5/                                                                       0040755 0000000 0000000 00000000000 13077704276 013715  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/man/man5/Makefile.in                                                            0100644 0000000 0000000 00000000006 13045370710 015736  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/man/man8/                                                                       0040755 0000000 0000000 00000000000 13077704276 013720  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/man/man8/Makefile.in                                                            0100644 0000000 0000000 00000000006 13045370710 015741  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/man/man8/zed.8.in                                                               0100644 0000000 0000000 00000000006 13045370710 015154  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        %:
	#
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/src/zfs-0.6.5.9/module/                                                                         0040755 0000000 0000000 00000000000 13077704276 013567  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/module/Makefile.in                                                              0100644 0000000 0000000 00000004732 13045171016 015620  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        subdir-m += avl
subdir-m += nvpair
subdir-m += unicode
subdir-m += zcommon
subdir-m += zfs
subdir-m += zpios

INSTALL_MOD_DIR ?= extra

ZFS_MODULE_CFLAGS += -include @SPL_OBJ@/spl_config.h
ZFS_MODULE_CFLAGS += -include @abs_top_builddir@/zfs_config.h
ZFS_MODULE_CFLAGS += -I@abs_top_srcdir@/include -I@SPL@/include -I@SPL@
export ZFS_MODULE_CFLAGS

modules:
	@# Make the exported SPL symbols available to these modules.
	@# They may be in the root of SPL_OBJ when building against
	@# installed devel headers, or they may be in the module
	@# subdirectory when building against the spl source tree.
	@if [ -f @SPL_OBJ@/@SPL_SYMBOLS@ ]; then \
		/bin/cp @SPL_OBJ@/@SPL_SYMBOLS@ .; \
	elif [ -f @SPL_OBJ@/module/@SPL_SYMBOLS@ ]; then \
		/bin/cp @SPL_OBJ@/module/@SPL_SYMBOLS@ .; \
	else \
		echo -e "\n" \
		"*** Missing spl symbols ensure you have built the spl:\n" \
		"*** - @SPL_OBJ@/@SPL_SYMBOLS@, or\n" \
		"*** - @SPL_OBJ@/module/@SPL_SYMBOLS@\n"; \
		exit 1; \
	fi
	$(MAKE) -C @LINUX_OBJ@ SUBDIRS=`pwd` @KERNELMAKE_PARAMS@ CONFIG_ZFS=m $@

clean:
	@# Only cleanup the kernel build directories when CONFIG_KERNEL
	@# is defined.  This indicates that kernel modules should be built.
@CONFIG_KERNEL_TRUE@	$(MAKE) -C @LINUX_OBJ@ SUBDIRS=`pwd` @KERNELMAKE_PARAMS@ $@

	if [ -f @SPL_SYMBOLS@ ]; then $(RM) @SPL_SYMBOLS@; fi
	if [ -f @LINUX_SYMBOLS@ ]; then $(RM) @LINUX_SYMBOLS@; fi
	if [ -f Module.markers ]; then $(RM) Module.markers; fi

modules_install:
	@# Install the kernel modules
	$(MAKE) -C @LINUX_OBJ@ SUBDIRS=`pwd` $@ \
		INSTALL_MOD_PATH=$(DESTDIR)$(INSTALL_MOD_PATH) \
		INSTALL_MOD_DIR=$(INSTALL_MOD_DIR) \
		KERNELRELEASE=@LINUX_VERSION@
	@# Remove extraneous build products when packaging
	kmoddir=$(DESTDIR)$(INSTALL_MOD_PATH)/lib/modules/@LINUX_VERSION@; \
	if [ -n "$(DESTDIR)" ]; then \
		find $$kmoddir -name 'modules.*' | xargs $(RM); \
	fi
	sysmap=$(DESTDIR)$(INSTALL_MOD_PATH)/boot/System.map-@LINUX_VERSION@; \
	if [ -f $$sysmap ]; then \
		depmod -ae -F $$sysmap @LINUX_VERSION@; \
	fi

modules_uninstall:
	@# Uninstall the kernel modules
	kmoddir=$(DESTDIR)$(INSTALL_MOD_PATH)/lib/modules/@LINUX_VERSION@
	list='$(subdir-m)'; for subdir in $$list; do \
		$(RM) -R $$kmoddir/$(INSTALL_MOD_DIR)/$$subdir; \
	done

distdir:
	list='$(subdir-m)'; for subdir in $$list; do \
		(find @top_srcdir@/module/$$subdir -name '*.c' -o -name '*.h' |\
		xargs /bin/cp -t $$distdir/$$subdir); \
	done

distclean maintainer-clean: clean
install: modules_install
uninstall: modules_uninstall
all: modules
check:
                                      usr/src/zfs-0.6.5.9/module/avl/                                                                     0040755 0000000 0000000 00000000000 13077704276 014351  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/module/avl/Makefile.in                                                          0100644 0000000 0000000 00000000270 13045171016 016373  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        src = @abs_top_srcdir@/module/avl
obj = @abs_builddir@

MODULE := zavl

EXTRA_CFLAGS = $(ZFS_MODULE_CFLAGS) @KERNELCPPFLAGS@

obj-$(CONFIG_ZFS) := $(MODULE).o

$(MODULE)-objs += avl.o
                                                                                                                                                                                                                                                                                                                                        usr/src/zfs-0.6.5.9/module/avl/avl.c                                                                0100644 0000000 0000000 00000067604 13045370707 015302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Copyright (c) 2014 by Delphix. All rights reserved.
 */

/*
 * AVL - generic AVL tree implementation for kernel use
 *
 * A complete description of AVL trees can be found in many CS textbooks.
 *
 * Here is a very brief overview. An AVL tree is a binary search tree that is
 * almost perfectly balanced. By "almost" perfectly balanced, we mean that at
 * any given node, the left and right subtrees are allowed to differ in height
 * by at most 1 level.
 *
 * This relaxation from a perfectly balanced binary tree allows doing
 * insertion and deletion relatively efficiently. Searching the tree is
 * still a fast operation, roughly O(log(N)).
 *
 * The key to insertion and deletion is a set of tree manipulations called
 * rotations, which bring unbalanced subtrees back into the semi-balanced state.
 *
 * This implementation of AVL trees has the following peculiarities:
 *
 *	- The AVL specific data structures are physically embedded as fields
 *	  in the "using" data structures.  To maintain generality the code
 *	  must constantly translate between "avl_node_t *" and containing
 *	  data structure "void *"s by adding/subtracting the avl_offset.
 *
 *	- Since the AVL data is always embedded in other structures, there is
 *	  no locking or memory allocation in the AVL routines. This must be
 *	  provided for by the enclosing data structure's semantics. Typically,
 *	  avl_insert()/_add()/_remove()/avl_insert_here() require some kind of
 *	  exclusive write lock. Other operations require a read lock.
 *
 *      - The implementation uses iteration instead of explicit recursion,
 *	  since it is intended to run on limited size kernel stacks. Since
 *	  there is no recursion stack present to move "up" in the tree,
 *	  there is an explicit "parent" link in the avl_node_t.
 *
 *      - The left/right children pointers of a node are in an array.
 *	  In the code, variables (instead of constants) are used to represent
 *	  left and right indices.  The implementation is written as if it only
 *	  dealt with left handed manipulations.  By changing the value assigned
 *	  to "left", the code also works for right handed trees.  The
 *	  following variables/terms are frequently used:
 *
 *		int left;	// 0 when dealing with left children,
 *				// 1 for dealing with right children
 *
 *		int left_heavy;	// -1 when left subtree is taller at some node,
 *				// +1 when right subtree is taller
 *
 *		int right;	// will be the opposite of left (0 or 1)
 *		int right_heavy;// will be the opposite of left_heavy (-1 or 1)
 *
 *		int direction;  // 0 for "<" (ie. left child); 1 for ">" (right)
 *
 *	  Though it is a little more confusing to read the code, the approach
 *	  allows using half as much code (and hence cache footprint) for tree
 *	  manipulations and eliminates many conditional branches.
 *
 *	- The avl_index_t is an opaque "cookie" used to find nodes at or
 *	  adjacent to where a new value would be inserted in the tree. The value
 *	  is a modified "avl_node_t *".  The bottom bit (normally 0 for a
 *	  pointer) is set to indicate if that the new node has a value greater
 *	  than the value of the indicated "avl_node_t *".
 *
 * Note - in addition to userland (e.g. libavl and libutil) and the kernel
 * (e.g. genunix), avl.c is compiled into ld.so and kmdb's genunix module,
 * which each have their own compilation environments and subsequent
 * requirements. Each of these environments must be considered when adding
 * dependencies from avl.c.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/debug.h>
#include <sys/avl.h>
#include <sys/cmn_err.h>

/*
 * Small arrays to translate between balance (or diff) values and child indices.
 *
 * Code that deals with binary tree data structures will randomly use
 * left and right children when examining a tree.  C "if()" statements
 * which evaluate randomly suffer from very poor hardware branch prediction.
 * In this code we avoid some of the branch mispredictions by using the
 * following translation arrays. They replace random branches with an
 * additional memory reference. Since the translation arrays are both very
 * small the data should remain efficiently in cache.
 */
static const int  avl_child2balance[2]	= {-1, 1};
static const int  avl_balance2child[]	= {0, 0, 1};


/*
 * Walk from one node to the previous valued node (ie. an infix walk
 * towards the left). At any given node we do one of 2 things:
 *
 * - If there is a left child, go to it, then to it's rightmost descendant.
 *
 * - otherwise we return through parent nodes until we've come from a right
 *   child.
 *
 * Return Value:
 * NULL - if at the end of the nodes
 * otherwise next node
 */
void *
avl_walk(avl_tree_t *tree, void	*oldnode, int left)
{
	size_t off = tree->avl_offset;
	avl_node_t *node = AVL_DATA2NODE(oldnode, off);
	int right = 1 - left;
	int was_child;


	/*
	 * nowhere to walk to if tree is empty
	 */
	if (node == NULL)
		return (NULL);

	/*
	 * Visit the previous valued node. There are two possibilities:
	 *
	 * If this node has a left child, go down one left, then all
	 * the way right.
	 */
	if (node->avl_child[left] != NULL) {
		for (node = node->avl_child[left];
		    node->avl_child[right] != NULL;
		    node = node->avl_child[right])
			;
	/*
	 * Otherwise, return thru left children as far as we can.
	 */
	} else {
		for (;;) {
			was_child = AVL_XCHILD(node);
			node = AVL_XPARENT(node);
			if (node == NULL)
				return (NULL);
			if (was_child == right)
				break;
		}
	}

	return (AVL_NODE2DATA(node, off));
}

/*
 * Return the lowest valued node in a tree or NULL.
 * (leftmost child from root of tree)
 */
void *
avl_first(avl_tree_t *tree)
{
	avl_node_t *node;
	avl_node_t *prev = NULL;
	size_t off = tree->avl_offset;

	for (node = tree->avl_root; node != NULL; node = node->avl_child[0])
		prev = node;

	if (prev != NULL)
		return (AVL_NODE2DATA(prev, off));
	return (NULL);
}

/*
 * Return the highest valued node in a tree or NULL.
 * (rightmost child from root of tree)
 */
void *
avl_last(avl_tree_t *tree)
{
	avl_node_t *node;
	avl_node_t *prev = NULL;
	size_t off = tree->avl_offset;

	for (node = tree->avl_root; node != NULL; node = node->avl_child[1])
		prev = node;

	if (prev != NULL)
		return (AVL_NODE2DATA(prev, off));
	return (NULL);
}

/*
 * Access the node immediately before or after an insertion point.
 *
 * "avl_index_t" is a (avl_node_t *) with the bottom bit indicating a child
 *
 * Return value:
 *	NULL: no node in the given direction
 *	"void *"  of the found tree node
 */
void *
avl_nearest(avl_tree_t *tree, avl_index_t where, int direction)
{
	int child = AVL_INDEX2CHILD(where);
	avl_node_t *node = AVL_INDEX2NODE(where);
	void *data;
	size_t off = tree->avl_offset;

	if (node == NULL) {
		ASSERT(tree->avl_root == NULL);
		return (NULL);
	}
	data = AVL_NODE2DATA(node, off);
	if (child != direction)
		return (data);

	return (avl_walk(tree, data, direction));
}


/*
 * Search for the node which contains "value".  The algorithm is a
 * simple binary tree search.
 *
 * return value:
 *	NULL: the value is not in the AVL tree
 *		*where (if not NULL)  is set to indicate the insertion point
 *	"void *"  of the found tree node
 */
void *
avl_find(avl_tree_t *tree, const void *value, avl_index_t *where)
{
	avl_node_t *node;
	avl_node_t *prev = NULL;
	int child = 0;
	int diff;
	size_t off = tree->avl_offset;

	for (node = tree->avl_root; node != NULL;
	    node = node->avl_child[child]) {

		prev = node;

		diff = tree->avl_compar(value, AVL_NODE2DATA(node, off));
		ASSERT(-1 <= diff && diff <= 1);
		if (diff == 0) {
#ifdef DEBUG
			if (where != NULL)
				*where = 0;
#endif
			return (AVL_NODE2DATA(node, off));
		}
		child = avl_balance2child[1 + diff];

	}

	if (where != NULL)
		*where = AVL_MKINDEX(prev, child);

	return (NULL);
}


/*
 * Perform a rotation to restore balance at the subtree given by depth.
 *
 * This routine is used by both insertion and deletion. The return value
 * indicates:
 *	 0 : subtree did not change height
 *	!0 : subtree was reduced in height
 *
 * The code is written as if handling left rotations, right rotations are
 * symmetric and handled by swapping values of variables right/left[_heavy]
 *
 * On input balance is the "new" balance at "node". This value is either
 * -2 or +2.
 */
static int
avl_rotation(avl_tree_t *tree, avl_node_t *node, int balance)
{
	int left = !(balance < 0);	/* when balance = -2, left will be 0 */
	int right = 1 - left;
	int left_heavy = balance >> 1;
	int right_heavy = -left_heavy;
	avl_node_t *parent = AVL_XPARENT(node);
	avl_node_t *child = node->avl_child[left];
	avl_node_t *cright;
	avl_node_t *gchild;
	avl_node_t *gright;
	avl_node_t *gleft;
	int which_child = AVL_XCHILD(node);
	int child_bal = AVL_XBALANCE(child);

	/* BEGIN CSTYLED */
	/*
	 * case 1 : node is overly left heavy, the left child is balanced or
	 * also left heavy. This requires the following rotation.
	 *
	 *                   (node bal:-2)
	 *                    /           \
	 *                   /             \
	 *              (child bal:0 or -1)
	 *              /    \
	 *             /      \
	 *                     cright
	 *
	 * becomes:
	 *
	 *              (child bal:1 or 0)
	 *              /        \
	 *             /          \
	 *                        (node bal:-1 or 0)
	 *                         /     \
	 *                        /       \
	 *                     cright
	 *
	 * we detect this situation by noting that child's balance is not
	 * right_heavy.
	 */
	/* END CSTYLED */
	if (child_bal != right_heavy) {

		/*
		 * compute new balance of nodes
		 *
		 * If child used to be left heavy (now balanced) we reduced
		 * the height of this sub-tree -- used in "return...;" below
		 */
		child_bal += right_heavy; /* adjust towards right */

		/*
		 * move "cright" to be node's left child
		 */
		cright = child->avl_child[right];
		node->avl_child[left] = cright;
		if (cright != NULL) {
			AVL_SETPARENT(cright, node);
			AVL_SETCHILD(cright, left);
		}

		/*
		 * move node to be child's right child
		 */
		child->avl_child[right] = node;
		AVL_SETBALANCE(node, -child_bal);
		AVL_SETCHILD(node, right);
		AVL_SETPARENT(node, child);

		/*
		 * update the pointer into this subtree
		 */
		AVL_SETBALANCE(child, child_bal);
		AVL_SETCHILD(child, which_child);
		AVL_SETPARENT(child, parent);
		if (parent != NULL)
			parent->avl_child[which_child] = child;
		else
			tree->avl_root = child;

		return (child_bal == 0);
	}

	/* BEGIN CSTYLED */
	/*
	 * case 2 : When node is left heavy, but child is right heavy we use
	 * a different rotation.
	 *
	 *                   (node b:-2)
	 *                    /   \
	 *                   /     \
	 *                  /       \
	 *             (child b:+1)
	 *              /     \
	 *             /       \
	 *                   (gchild b: != 0)
	 *                     /  \
	 *                    /    \
	 *                 gleft   gright
	 *
	 * becomes:
	 *
	 *              (gchild b:0)
	 *              /       \
	 *             /         \
	 *            /           \
	 *        (child b:?)   (node b:?)
	 *         /  \          /   \
	 *        /    \        /     \
	 *            gleft   gright
	 *
	 * computing the new balances is more complicated. As an example:
	 *	 if gchild was right_heavy, then child is now left heavy
	 *		else it is balanced
	 */
	/* END CSTYLED */
	gchild = child->avl_child[right];
	gleft = gchild->avl_child[left];
	gright = gchild->avl_child[right];

	/*
	 * move gright to left child of node and
	 *
	 * move gleft to right child of node
	 */
	node->avl_child[left] = gright;
	if (gright != NULL) {
		AVL_SETPARENT(gright, node);
		AVL_SETCHILD(gright, left);
	}

	child->avl_child[right] = gleft;
	if (gleft != NULL) {
		AVL_SETPARENT(gleft, child);
		AVL_SETCHILD(gleft, right);
	}

	/*
	 * move child to left child of gchild and
	 *
	 * move node to right child of gchild and
	 *
	 * fixup parent of all this to point to gchild
	 */
	balance = AVL_XBALANCE(gchild);
	gchild->avl_child[left] = child;
	AVL_SETBALANCE(child, (balance == right_heavy ? left_heavy : 0));
	AVL_SETPARENT(child, gchild);
	AVL_SETCHILD(child, left);

	gchild->avl_child[right] = node;
	AVL_SETBALANCE(node, (balance == left_heavy ? right_heavy : 0));
	AVL_SETPARENT(node, gchild);
	AVL_SETCHILD(node, right);

	AVL_SETBALANCE(gchild, 0);
	AVL_SETPARENT(gchild, parent);
	AVL_SETCHILD(gchild, which_child);
	if (parent != NULL)
		parent->avl_child[which_child] = gchild;
	else
		tree->avl_root = gchild;

	return (1);	/* the new tree is always shorter */
}


/*
 * Insert a new node into an AVL tree at the specified (from avl_find()) place.
 *
 * Newly inserted nodes are always leaf nodes in the tree, since avl_find()
 * searches out to the leaf positions.  The avl_index_t indicates the node
 * which will be the parent of the new node.
 *
 * After the node is inserted, a single rotation further up the tree may
 * be necessary to maintain an acceptable AVL balance.
 */
void
avl_insert(avl_tree_t *tree, void *new_data, avl_index_t where)
{
	avl_node_t *node;
	avl_node_t *parent = AVL_INDEX2NODE(where);
	int old_balance;
	int new_balance;
	int which_child = AVL_INDEX2CHILD(where);
	size_t off = tree->avl_offset;

	ASSERT(tree);
#ifdef _LP64
	ASSERT(((uintptr_t)new_data & 0x7) == 0);
#endif

	node = AVL_DATA2NODE(new_data, off);

	/*
	 * First, add the node to the tree at the indicated position.
	 */
	++tree->avl_numnodes;

	node->avl_child[0] = NULL;
	node->avl_child[1] = NULL;

	AVL_SETCHILD(node, which_child);
	AVL_SETBALANCE(node, 0);
	AVL_SETPARENT(node, parent);
	if (parent != NULL) {
		ASSERT(parent->avl_child[which_child] == NULL);
		parent->avl_child[which_child] = node;
	} else {
		ASSERT(tree->avl_root == NULL);
		tree->avl_root = node;
	}
	/*
	 * Now, back up the tree modifying the balance of all nodes above the
	 * insertion point. If we get to a highly unbalanced ancestor, we
	 * need to do a rotation.  If we back out of the tree we are done.
	 * If we brought any subtree into perfect balance (0), we are also done.
	 */
	for (;;) {
		node = parent;
		if (node == NULL)
			return;

		/*
		 * Compute the new balance
		 */
		old_balance = AVL_XBALANCE(node);
		new_balance = old_balance + avl_child2balance[which_child];

		/*
		 * If we introduced equal balance, then we are done immediately
		 */
		if (new_balance == 0) {
			AVL_SETBALANCE(node, 0);
			return;
		}

		/*
		 * If both old and new are not zero we went
		 * from -1 to -2 balance, do a rotation.
		 */
		if (old_balance != 0)
			break;

		AVL_SETBALANCE(node, new_balance);
		parent = AVL_XPARENT(node);
		which_child = AVL_XCHILD(node);
	}

	/*
	 * perform a rotation to fix the tree and return
	 */
	(void) avl_rotation(tree, node, new_balance);
}

/*
 * Insert "new_data" in "tree" in the given "direction" either after or
 * before (AVL_AFTER, AVL_BEFORE) the data "here".
 *
 * Insertions can only be done at empty leaf points in the tree, therefore
 * if the given child of the node is already present we move to either
 * the AVL_PREV or AVL_NEXT and reverse the insertion direction. Since
 * every other node in the tree is a leaf, this always works.
 *
 * To help developers using this interface, we assert that the new node
 * is correctly ordered at every step of the way in DEBUG kernels.
 */
void
avl_insert_here(
	avl_tree_t *tree,
	void *new_data,
	void *here,
	int direction)
{
	avl_node_t *node;
	int child = direction;	/* rely on AVL_BEFORE == 0, AVL_AFTER == 1 */
#ifdef DEBUG
	int diff;
#endif

	ASSERT(tree != NULL);
	ASSERT(new_data != NULL);
	ASSERT(here != NULL);
	ASSERT(direction == AVL_BEFORE || direction == AVL_AFTER);

	/*
	 * If corresponding child of node is not NULL, go to the neighboring
	 * node and reverse the insertion direction.
	 */
	node = AVL_DATA2NODE(here, tree->avl_offset);

#ifdef DEBUG
	diff = tree->avl_compar(new_data, here);
	ASSERT(-1 <= diff && diff <= 1);
	ASSERT(diff != 0);
	ASSERT(diff > 0 ? child == 1 : child == 0);
#endif

	if (node->avl_child[child] != NULL) {
		node = node->avl_child[child];
		child = 1 - child;
		while (node->avl_child[child] != NULL) {
#ifdef DEBUG
			diff = tree->avl_compar(new_data,
			    AVL_NODE2DATA(node, tree->avl_offset));
			ASSERT(-1 <= diff && diff <= 1);
			ASSERT(diff != 0);
			ASSERT(diff > 0 ? child == 1 : child == 0);
#endif
			node = node->avl_child[child];
		}
#ifdef DEBUG
		diff = tree->avl_compar(new_data,
		    AVL_NODE2DATA(node, tree->avl_offset));
		ASSERT(-1 <= diff && diff <= 1);
		ASSERT(diff != 0);
		ASSERT(diff > 0 ? child == 1 : child == 0);
#endif
	}
	ASSERT(node->avl_child[child] == NULL);

	avl_insert(tree, new_data, AVL_MKINDEX(node, child));
}

/*
 * Add a new node to an AVL tree.
 */
void
avl_add(avl_tree_t *tree, void *new_node)
{
	avl_index_t where = 0;

	/*
	 * This is unfortunate.  We want to call panic() here, even for
	 * non-DEBUG kernels.  In userland, however, we can't depend on anything
	 * in libc or else the rtld build process gets confused.  So, all we can
	 * do in userland is resort to a normal ASSERT().
	 */
	if (avl_find(tree, new_node, &where) != NULL)
#ifdef _KERNEL
		panic("avl_find() succeeded inside avl_add()");
#else
		ASSERT(0);
#endif
	avl_insert(tree, new_node, where);
}

/*
 * Delete a node from the AVL tree.  Deletion is similar to insertion, but
 * with 2 complications.
 *
 * First, we may be deleting an interior node. Consider the following subtree:
 *
 *     d           c            c
 *    / \         / \          / \
 *   b   e       b   e        b   e
 *  / \	        / \          /
 * a   c       a            a
 *
 * When we are deleting node (d), we find and bring up an adjacent valued leaf
 * node, say (c), to take the interior node's place. In the code this is
 * handled by temporarily swapping (d) and (c) in the tree and then using
 * common code to delete (d) from the leaf position.
 *
 * Secondly, an interior deletion from a deep tree may require more than one
 * rotation to fix the balance. This is handled by moving up the tree through
 * parents and applying rotations as needed. The return value from
 * avl_rotation() is used to detect when a subtree did not change overall
 * height due to a rotation.
 */
void
avl_remove(avl_tree_t *tree, void *data)
{
	avl_node_t *delete;
	avl_node_t *parent;
	avl_node_t *node;
	avl_node_t tmp;
	int old_balance;
	int new_balance;
	int left;
	int right;
	int which_child;
	size_t off = tree->avl_offset;

	ASSERT(tree);

	delete = AVL_DATA2NODE(data, off);

	/*
	 * Deletion is easiest with a node that has at most 1 child.
	 * We swap a node with 2 children with a sequentially valued
	 * neighbor node. That node will have at most 1 child. Note this
	 * has no effect on the ordering of the remaining nodes.
	 *
	 * As an optimization, we choose the greater neighbor if the tree
	 * is right heavy, otherwise the left neighbor. This reduces the
	 * number of rotations needed.
	 */
	if (delete->avl_child[0] != NULL && delete->avl_child[1] != NULL) {

		/*
		 * choose node to swap from whichever side is taller
		 */
		old_balance = AVL_XBALANCE(delete);
		left = avl_balance2child[old_balance + 1];
		right = 1 - left;

		/*
		 * get to the previous value'd node
		 * (down 1 left, as far as possible right)
		 */
		for (node = delete->avl_child[left];
		    node->avl_child[right] != NULL;
		    node = node->avl_child[right])
			;

		/*
		 * create a temp placeholder for 'node'
		 * move 'node' to delete's spot in the tree
		 */
		tmp = *node;

		*node = *delete;
		if (node->avl_child[left] == node)
			node->avl_child[left] = &tmp;

		parent = AVL_XPARENT(node);
		if (parent != NULL)
			parent->avl_child[AVL_XCHILD(node)] = node;
		else
			tree->avl_root = node;
		AVL_SETPARENT(node->avl_child[left], node);
		AVL_SETPARENT(node->avl_child[right], node);

		/*
		 * Put tmp where node used to be (just temporary).
		 * It always has a parent and at most 1 child.
		 */
		delete = &tmp;
		parent = AVL_XPARENT(delete);
		parent->avl_child[AVL_XCHILD(delete)] = delete;
		which_child = (delete->avl_child[1] != 0);
		if (delete->avl_child[which_child] != NULL)
			AVL_SETPARENT(delete->avl_child[which_child], delete);
	}


	/*
	 * Here we know "delete" is at least partially a leaf node. It can
	 * be easily removed from the tree.
	 */
	ASSERT(tree->avl_numnodes > 0);
	--tree->avl_numnodes;
	parent = AVL_XPARENT(delete);
	which_child = AVL_XCHILD(delete);
	if (delete->avl_child[0] != NULL)
		node = delete->avl_child[0];
	else
		node = delete->avl_child[1];

	/*
	 * Connect parent directly to node (leaving out delete).
	 */
	if (node != NULL) {
		AVL_SETPARENT(node, parent);
		AVL_SETCHILD(node, which_child);
	}
	if (parent == NULL) {
		tree->avl_root = node;
		return;
	}
	parent->avl_child[which_child] = node;


	/*
	 * Since the subtree is now shorter, begin adjusting parent balances
	 * and performing any needed rotations.
	 */
	do {

		/*
		 * Move up the tree and adjust the balance
		 *
		 * Capture the parent and which_child values for the next
		 * iteration before any rotations occur.
		 */
		node = parent;
		old_balance = AVL_XBALANCE(node);
		new_balance = old_balance - avl_child2balance[which_child];
		parent = AVL_XPARENT(node);
		which_child = AVL_XCHILD(node);

		/*
		 * If a node was in perfect balance but isn't anymore then
		 * we can stop, since the height didn't change above this point
		 * due to a deletion.
		 */
		if (old_balance == 0) {
			AVL_SETBALANCE(node, new_balance);
			break;
		}

		/*
		 * If the new balance is zero, we don't need to rotate
		 * else
		 * need a rotation to fix the balance.
		 * If the rotation doesn't change the height
		 * of the sub-tree we have finished adjusting.
		 */
		if (new_balance == 0)
			AVL_SETBALANCE(node, new_balance);
		else if (!avl_rotation(tree, node, new_balance))
			break;
	} while (parent != NULL);
}

#define	AVL_REINSERT(tree, obj)		\
	avl_remove((tree), (obj));	\
	avl_add((tree), (obj))

boolean_t
avl_update_lt(avl_tree_t *t, void *obj)
{
	void *neighbor;

	ASSERT(((neighbor = AVL_NEXT(t, obj)) == NULL) ||
	    (t->avl_compar(obj, neighbor) <= 0));

	neighbor = AVL_PREV(t, obj);
	if ((neighbor != NULL) && (t->avl_compar(obj, neighbor) < 0)) {
		AVL_REINSERT(t, obj);
		return (B_TRUE);
	}

	return (B_FALSE);
}

boolean_t
avl_update_gt(avl_tree_t *t, void *obj)
{
	void *neighbor;

	ASSERT(((neighbor = AVL_PREV(t, obj)) == NULL) ||
	    (t->avl_compar(obj, neighbor) >= 0));

	neighbor = AVL_NEXT(t, obj);
	if ((neighbor != NULL) && (t->avl_compar(obj, neighbor) > 0)) {
		AVL_REINSERT(t, obj);
		return (B_TRUE);
	}

	return (B_FALSE);
}

boolean_t
avl_update(avl_tree_t *t, void *obj)
{
	void *neighbor;

	neighbor = AVL_PREV(t, obj);
	if ((neighbor != NULL) && (t->avl_compar(obj, neighbor) < 0)) {
		AVL_REINSERT(t, obj);
		return (B_TRUE);
	}

	neighbor = AVL_NEXT(t, obj);
	if ((neighbor != NULL) && (t->avl_compar(obj, neighbor) > 0)) {
		AVL_REINSERT(t, obj);
		return (B_TRUE);
	}

	return (B_FALSE);
}

void
avl_swap(avl_tree_t *tree1, avl_tree_t *tree2)
{
	avl_node_t *temp_node;
	ulong_t temp_numnodes;

	ASSERT3P(tree1->avl_compar, ==, tree2->avl_compar);
	ASSERT3U(tree1->avl_offset, ==, tree2->avl_offset);
	ASSERT3U(tree1->avl_size, ==, tree2->avl_size);

	temp_node = tree1->avl_root;
	temp_numnodes = tree1->avl_numnodes;
	tree1->avl_root = tree2->avl_root;
	tree1->avl_numnodes = tree2->avl_numnodes;
	tree2->avl_root = temp_node;
	tree2->avl_numnodes = temp_numnodes;
}

/*
 * initialize a new AVL tree
 */
void
avl_create(avl_tree_t *tree, int (*compar) (const void *, const void *),
    size_t size, size_t offset)
{
	ASSERT(tree);
	ASSERT(compar);
	ASSERT(size > 0);
	ASSERT(size >= offset + sizeof (avl_node_t));
#ifdef _LP64
	ASSERT((offset & 0x7) == 0);
#endif

	tree->avl_compar = compar;
	tree->avl_root = NULL;
	tree->avl_numnodes = 0;
	tree->avl_size = size;
	tree->avl_offset = offset;
}

/*
 * Delete a tree.
 */
/* ARGSUSED */
void
avl_destroy(avl_tree_t *tree)
{
	ASSERT(tree);
	ASSERT(tree->avl_numnodes == 0);
	ASSERT(tree->avl_root == NULL);
}


/*
 * Return the number of nodes in an AVL tree.
 */
ulong_t
avl_numnodes(avl_tree_t *tree)
{
	ASSERT(tree);
	return (tree->avl_numnodes);
}

boolean_t
avl_is_empty(avl_tree_t *tree)
{
	ASSERT(tree);
	return (tree->avl_numnodes == 0);
}

#define	CHILDBIT	(1L)

/*
 * Post-order tree walk used to visit all tree nodes and destroy the tree
 * in post order. This is used for destroying a tree without paying any cost
 * for rebalancing it.
 *
 * example:
 *
 *	void *cookie = NULL;
 *	my_data_t *node;
 *
 *	while ((node = avl_destroy_nodes(tree, &cookie)) != NULL)
 *		free(node);
 *	avl_destroy(tree);
 *
 * The cookie is really an avl_node_t to the current node's parent and
 * an indication of which child you looked at last.
 *
 * On input, a cookie value of CHILDBIT indicates the tree is done.
 */
void *
avl_destroy_nodes(avl_tree_t *tree, void **cookie)
{
	avl_node_t	*node;
	avl_node_t	*parent;
	int		child;
	void		*first;
	size_t		off = tree->avl_offset;

	/*
	 * Initial calls go to the first node or it's right descendant.
	 */
	if (*cookie == NULL) {
		first = avl_first(tree);

		/*
		 * deal with an empty tree
		 */
		if (first == NULL) {
			*cookie = (void *)CHILDBIT;
			return (NULL);
		}

		node = AVL_DATA2NODE(first, off);
		parent = AVL_XPARENT(node);
		goto check_right_side;
	}

	/*
	 * If there is no parent to return to we are done.
	 */
	parent = (avl_node_t *)((uintptr_t)(*cookie) & ~CHILDBIT);
	if (parent == NULL) {
		if (tree->avl_root != NULL) {
			ASSERT(tree->avl_numnodes == 1);
			tree->avl_root = NULL;
			tree->avl_numnodes = 0;
		}
		return (NULL);
	}

	/*
	 * Remove the child pointer we just visited from the parent and tree.
	 */
	child = (uintptr_t)(*cookie) & CHILDBIT;
	parent->avl_child[child] = NULL;
	ASSERT(tree->avl_numnodes > 1);
	--tree->avl_numnodes;

	/*
	 * If we just did a right child or there isn't one, go up to parent.
	 */
	if (child == 1 || parent->avl_child[1] == NULL) {
		node = parent;
		parent = AVL_XPARENT(parent);
		goto done;
	}

	/*
	 * Do parent's right child, then leftmost descendent.
	 */
	node = parent->avl_child[1];
	while (node->avl_child[0] != NULL) {
		parent = node;
		node = node->avl_child[0];
	}

	/*
	 * If here, we moved to a left child. It may have one
	 * child on the right (when balance == +1).
	 */
check_right_side:
	if (node->avl_child[1] != NULL) {
		ASSERT(AVL_XBALANCE(node) == 1);
		parent = node;
		node = node->avl_child[1];
		ASSERT(node->avl_child[0] == NULL &&
		    node->avl_child[1] == NULL);
	} else {
		ASSERT(AVL_XBALANCE(node) <= 0);
	}

done:
	if (parent == NULL) {
		*cookie = (void *)CHILDBIT;
		ASSERT(node == tree->avl_root);
	} else {
		*cookie = (void *)((uintptr_t)parent | AVL_XCHILD(node));
	}

	return (AVL_NODE2DATA(node, off));
}

#if defined(_KERNEL) && defined(HAVE_SPL)
static int __init
avl_init(void)
{
	return (0);
}

static void __exit
avl_fini(void)
{
}

module_init(avl_init);
module_exit(avl_fini);

MODULE_DESCRIPTION("Generic AVL tree implementation");
MODULE_AUTHOR(ZFS_META_AUTHOR);
MODULE_LICENSE(ZFS_META_LICENSE);
MODULE_VERSION(ZFS_META_VERSION "-" ZFS_META_RELEASE);

EXPORT_SYMBOL(avl_create);
EXPORT_SYMBOL(avl_find);
EXPORT_SYMBOL(avl_insert);
EXPORT_SYMBOL(avl_insert_here);
EXPORT_SYMBOL(avl_walk);
EXPORT_SYMBOL(avl_first);
EXPORT_SYMBOL(avl_last);
EXPORT_SYMBOL(avl_nearest);
EXPORT_SYMBOL(avl_add);
EXPORT_SYMBOL(avl_swap);
EXPORT_SYMBOL(avl_is_empty);
EXPORT_SYMBOL(avl_remove);
EXPORT_SYMBOL(avl_numnodes);
EXPORT_SYMBOL(avl_destroy_nodes);
EXPORT_SYMBOL(avl_destroy);
#endif
                                                                                                                            usr/src/zfs-0.6.5.9/module/nvpair/                                                                  0040755 0000000 0000000 00000000000 13077704276 015066  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/module/nvpair/Makefile.in                                                       0100644 0000000 0000000 00000000451 13045171016 017111  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        src = @abs_top_srcdir@/module/nvpair
obj = @abs_builddir@

MODULE := znvpair

EXTRA_CFLAGS = $(ZFS_MODULE_CFLAGS) @KERNELCPPFLAGS@

obj-$(CONFIG_ZFS) := $(MODULE).o

$(MODULE)-objs += nvpair.o
$(MODULE)-objs += fnvpair.o
$(MODULE)-objs += nvpair_alloc_spl.o
$(MODULE)-objs += nvpair_alloc_fixed.o
                                                                                                                                                                                                                       usr/src/zfs-0.6.5.9/module/nvpair/fnvpair.c                                                         0100644 0000000 0000000 00000027774 13045370707 016706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2012 by Delphix. All rights reserved.
 */

#include <sys/nvpair.h>
#include <sys/kmem.h>
#include <sys/debug.h>
#include <sys/param.h>
#ifndef _KERNEL
#include <stdlib.h>
#endif

/*
 * "Force" nvlist wrapper.
 *
 * These functions wrap the nvlist_* functions with assertions that assume
 * the operation is successful.  This allows the caller's code to be much
 * more readable, especially for the fnvlist_lookup_* and fnvpair_value_*
 * functions, which can return the requested value (rather than filling in
 * a pointer).
 *
 * These functions use NV_UNIQUE_NAME, encoding NV_ENCODE_NATIVE, and allocate
 * with KM_SLEEP.
 *
 * More wrappers should be added as needed -- for example
 * nvlist_lookup_*_array and nvpair_value_*_array.
 */

nvlist_t *
fnvlist_alloc(void)
{
	nvlist_t *nvl;
	VERIFY0(nvlist_alloc(&nvl, NV_UNIQUE_NAME, KM_SLEEP));
	return (nvl);
}

void
fnvlist_free(nvlist_t *nvl)
{
	nvlist_free(nvl);
}

size_t
fnvlist_size(nvlist_t *nvl)
{
	size_t size;
	VERIFY0(nvlist_size(nvl, &size, NV_ENCODE_NATIVE));
	return (size);
}

/*
 * Returns allocated buffer of size *sizep.  Caller must free the buffer with
 * fnvlist_pack_free().
 */
char *
fnvlist_pack(nvlist_t *nvl, size_t *sizep)
{
	char *packed = 0;
	VERIFY3U(nvlist_pack(nvl, &packed, sizep, NV_ENCODE_NATIVE,
	    KM_SLEEP), ==, 0);
	return (packed);
}

/*ARGSUSED*/
void
fnvlist_pack_free(char *pack, size_t size)
{
#ifdef _KERNEL
	kmem_free(pack, size);
#else
	free(pack);
#endif
}

nvlist_t *
fnvlist_unpack(char *buf, size_t buflen)
{
	nvlist_t *rv;
	VERIFY0(nvlist_unpack(buf, buflen, &rv, KM_SLEEP));
	return (rv);
}

nvlist_t *
fnvlist_dup(nvlist_t *nvl)
{
	nvlist_t *rv;
	VERIFY0(nvlist_dup(nvl, &rv, KM_SLEEP));
	return (rv);
}

void
fnvlist_merge(nvlist_t *dst, nvlist_t *src)
{
	VERIFY0(nvlist_merge(dst, src, KM_SLEEP));
}

size_t
fnvlist_num_pairs(nvlist_t *nvl)
{
	size_t count = 0;
	nvpair_t *pair;

	for (pair = nvlist_next_nvpair(nvl, 0); pair != NULL;
	    pair = nvlist_next_nvpair(nvl, pair))
		count++;
	return (count);
}

void
fnvlist_add_boolean(nvlist_t *nvl, const char *name)
{
	VERIFY0(nvlist_add_boolean(nvl, name));
}

void
fnvlist_add_boolean_value(nvlist_t *nvl, const char *name, boolean_t val)
{
	VERIFY0(nvlist_add_boolean_value(nvl, name, val));
}

void
fnvlist_add_byte(nvlist_t *nvl, const char *name, uchar_t val)
{
	VERIFY0(nvlist_add_byte(nvl, name, val));
}

void
fnvlist_add_int8(nvlist_t *nvl, const char *name, int8_t val)
{
	VERIFY0(nvlist_add_int8(nvl, name, val));
}

void
fnvlist_add_uint8(nvlist_t *nvl, const char *name, uint8_t val)
{
	VERIFY0(nvlist_add_uint8(nvl, name, val));
}

void
fnvlist_add_int16(nvlist_t *nvl, const char *name, int16_t val)
{
	VERIFY0(nvlist_add_int16(nvl, name, val));
}

void
fnvlist_add_uint16(nvlist_t *nvl, const char *name, uint16_t val)
{
	VERIFY0(nvlist_add_uint16(nvl, name, val));
}

void
fnvlist_add_int32(nvlist_t *nvl, const char *name, int32_t val)
{
	VERIFY0(nvlist_add_int32(nvl, name, val));
}

void
fnvlist_add_uint32(nvlist_t *nvl, const char *name, uint32_t val)
{
	VERIFY0(nvlist_add_uint32(nvl, name, val));
}

void
fnvlist_add_int64(nvlist_t *nvl, const char *name, int64_t val)
{
	VERIFY0(nvlist_add_int64(nvl, name, val));
}

void
fnvlist_add_uint64(nvlist_t *nvl, const char *name, uint64_t val)
{
	VERIFY0(nvlist_add_uint64(nvl, name, val));
}

void
fnvlist_add_string(nvlist_t *nvl, const char *name, const char *val)
{
	VERIFY0(nvlist_add_string(nvl, name, val));
}

void
fnvlist_add_nvlist(nvlist_t *nvl, const char *name, nvlist_t *val)
{
	VERIFY0(nvlist_add_nvlist(nvl, name, val));
}

void
fnvlist_add_nvpair(nvlist_t *nvl, nvpair_t *pair)
{
	VERIFY0(nvlist_add_nvpair(nvl, pair));
}

void
fnvlist_add_boolean_array(nvlist_t *nvl, const char *name,
    boolean_t *val, uint_t n)
{
	VERIFY0(nvlist_add_boolean_array(nvl, name, val, n));
}

void
fnvlist_add_byte_array(nvlist_t *nvl, const char *name, uchar_t *val, uint_t n)
{
	VERIFY0(nvlist_add_byte_array(nvl, name, val, n));
}

void
fnvlist_add_int8_array(nvlist_t *nvl, const char *name, int8_t *val, uint_t n)
{
	VERIFY0(nvlist_add_int8_array(nvl, name, val, n));
}

void
fnvlist_add_uint8_array(nvlist_t *nvl, const char *name, uint8_t *val, uint_t n)
{
	VERIFY0(nvlist_add_uint8_array(nvl, name, val, n));
}

void
fnvlist_add_int16_array(nvlist_t *nvl, const char *name, int16_t *val, uint_t n)
{
	VERIFY0(nvlist_add_int16_array(nvl, name, val, n));
}

void
fnvlist_add_uint16_array(nvlist_t *nvl, const char *name,
    uint16_t *val, uint_t n)
{
	VERIFY0(nvlist_add_uint16_array(nvl, name, val, n));
}

void
fnvlist_add_int32_array(nvlist_t *nvl, const char *name, int32_t *val, uint_t n)
{
	VERIFY0(nvlist_add_int32_array(nvl, name, val, n));
}

void
fnvlist_add_uint32_array(nvlist_t *nvl, const char *name,
    uint32_t *val, uint_t n)
{
	VERIFY0(nvlist_add_uint32_array(nvl, name, val, n));
}

void
fnvlist_add_int64_array(nvlist_t *nvl, const char *name, int64_t *val, uint_t n)
{
	VERIFY0(nvlist_add_int64_array(nvl, name, val, n));
}

void
fnvlist_add_uint64_array(nvlist_t *nvl, const char *name,
    uint64_t *val, uint_t n)
{
	VERIFY0(nvlist_add_uint64_array(nvl, name, val, n));
}

void
fnvlist_add_string_array(nvlist_t *nvl, const char *name,
    char * const *val, uint_t n)
{
	VERIFY0(nvlist_add_string_array(nvl, name, val, n));
}

void
fnvlist_add_nvlist_array(nvlist_t *nvl, const char *name,
    nvlist_t **val, uint_t n)
{
	VERIFY0(nvlist_add_nvlist_array(nvl, name, val, n));
}

void
fnvlist_remove(nvlist_t *nvl, const char *name)
{
	VERIFY0(nvlist_remove_all(nvl, name));
}

void
fnvlist_remove_nvpair(nvlist_t *nvl, nvpair_t *pair)
{
	VERIFY0(nvlist_remove_nvpair(nvl, pair));
}

nvpair_t *
fnvlist_lookup_nvpair(nvlist_t *nvl, const char *name)
{
	nvpair_t *rv;
	VERIFY0(nvlist_lookup_nvpair(nvl, name, &rv));
	return (rv);
}

/* returns B_TRUE if the entry exists */
boolean_t
fnvlist_lookup_boolean(nvlist_t *nvl, const char *name)
{
	return (nvlist_lookup_boolean(nvl, name) == 0);
}

boolean_t
fnvlist_lookup_boolean_value(nvlist_t *nvl, const char *name)
{
	boolean_t rv;
	VERIFY0(nvlist_lookup_boolean_value(nvl, name, &rv));
	return (rv);
}

uchar_t
fnvlist_lookup_byte(nvlist_t *nvl, const char *name)
{
	uchar_t rv;
	VERIFY0(nvlist_lookup_byte(nvl, name, &rv));
	return (rv);
}

int8_t
fnvlist_lookup_int8(nvlist_t *nvl, const char *name)
{
	int8_t rv;
	VERIFY0(nvlist_lookup_int8(nvl, name, &rv));
	return (rv);
}

int16_t
fnvlist_lookup_int16(nvlist_t *nvl, const char *name)
{
	int16_t rv;
	VERIFY0(nvlist_lookup_int16(nvl, name, &rv));
	return (rv);
}

int32_t
fnvlist_lookup_int32(nvlist_t *nvl, const char *name)
{
	int32_t rv;
	VERIFY0(nvlist_lookup_int32(nvl, name, &rv));
	return (rv);
}

int64_t
fnvlist_lookup_int64(nvlist_t *nvl, const char *name)
{
	int64_t rv;
	VERIFY0(nvlist_lookup_int64(nvl, name, &rv));
	return (rv);
}

uint8_t
fnvlist_lookup_uint8(nvlist_t *nvl, const char *name)
{
	uint8_t rv;
	VERIFY0(nvlist_lookup_uint8(nvl, name, &rv));
	return (rv);
}

uint16_t
fnvlist_lookup_uint16(nvlist_t *nvl, const char *name)
{
	uint16_t rv;
	VERIFY0(nvlist_lookup_uint16(nvl, name, &rv));
	return (rv);
}

uint32_t
fnvlist_lookup_uint32(nvlist_t *nvl, const char *name)
{
	uint32_t rv;
	VERIFY0(nvlist_lookup_uint32(nvl, name, &rv));
	return (rv);
}

uint64_t
fnvlist_lookup_uint64(nvlist_t *nvl, const char *name)
{
	uint64_t rv;
	VERIFY0(nvlist_lookup_uint64(nvl, name, &rv));
	return (rv);
}

char *
fnvlist_lookup_string(nvlist_t *nvl, const char *name)
{
	char *rv;
	VERIFY0(nvlist_lookup_string(nvl, name, &rv));
	return (rv);
}

nvlist_t *
fnvlist_lookup_nvlist(nvlist_t *nvl, const char *name)
{
	nvlist_t *rv;
	VERIFY0(nvlist_lookup_nvlist(nvl, name, &rv));
	return (rv);
}

boolean_t
fnvpair_value_boolean_value(nvpair_t *nvp)
{
	boolean_t rv;
	VERIFY0(nvpair_value_boolean_value(nvp, &rv));
	return (rv);
}

uchar_t
fnvpair_value_byte(nvpair_t *nvp)
{
	uchar_t rv;
	VERIFY0(nvpair_value_byte(nvp, &rv));
	return (rv);
}

int8_t
fnvpair_value_int8(nvpair_t *nvp)
{
	int8_t rv;
	VERIFY0(nvpair_value_int8(nvp, &rv));
	return (rv);
}

int16_t
fnvpair_value_int16(nvpair_t *nvp)
{
	int16_t rv;
	VERIFY0(nvpair_value_int16(nvp, &rv));
	return (rv);
}

int32_t
fnvpair_value_int32(nvpair_t *nvp)
{
	int32_t rv;
	VERIFY0(nvpair_value_int32(nvp, &rv));
	return (rv);
}

int64_t
fnvpair_value_int64(nvpair_t *nvp)
{
	int64_t rv;
	VERIFY0(nvpair_value_int64(nvp, &rv));
	return (rv);
}

uint8_t
fnvpair_value_uint8(nvpair_t *nvp)
{
	uint8_t rv;
	VERIFY0(nvpair_value_uint8(nvp, &rv));
	return (rv);
}

uint16_t
fnvpair_value_uint16(nvpair_t *nvp)
{
	uint16_t rv;
	VERIFY0(nvpair_value_uint16(nvp, &rv));
	return (rv);
}

uint32_t
fnvpair_value_uint32(nvpair_t *nvp)
{
	uint32_t rv;
	VERIFY0(nvpair_value_uint32(nvp, &rv));
	return (rv);
}

uint64_t
fnvpair_value_uint64(nvpair_t *nvp)
{
	uint64_t rv;
	VERIFY0(nvpair_value_uint64(nvp, &rv));
	return (rv);
}

char *
fnvpair_value_string(nvpair_t *nvp)
{
	char *rv;
	VERIFY0(nvpair_value_string(nvp, &rv));
	return (rv);
}

nvlist_t *
fnvpair_value_nvlist(nvpair_t *nvp)
{
	nvlist_t *rv;
	VERIFY0(nvpair_value_nvlist(nvp, &rv));
	return (rv);
}

#if defined(_KERNEL) && defined(HAVE_SPL)

EXPORT_SYMBOL(fnvlist_alloc);
EXPORT_SYMBOL(fnvlist_free);
EXPORT_SYMBOL(fnvlist_size);
EXPORT_SYMBOL(fnvlist_pack);
EXPORT_SYMBOL(fnvlist_pack_free);
EXPORT_SYMBOL(fnvlist_unpack);
EXPORT_SYMBOL(fnvlist_dup);
EXPORT_SYMBOL(fnvlist_merge);

EXPORT_SYMBOL(fnvlist_add_nvpair);
EXPORT_SYMBOL(fnvlist_add_boolean);
EXPORT_SYMBOL(fnvlist_add_boolean_value);
EXPORT_SYMBOL(fnvlist_add_byte);
EXPORT_SYMBOL(fnvlist_add_int8);
EXPORT_SYMBOL(fnvlist_add_uint8);
EXPORT_SYMBOL(fnvlist_add_int16);
EXPORT_SYMBOL(fnvlist_add_uint16);
EXPORT_SYMBOL(fnvlist_add_int32);
EXPORT_SYMBOL(fnvlist_add_uint32);
EXPORT_SYMBOL(fnvlist_add_int64);
EXPORT_SYMBOL(fnvlist_add_uint64);
EXPORT_SYMBOL(fnvlist_add_string);
EXPORT_SYMBOL(fnvlist_add_nvlist);
EXPORT_SYMBOL(fnvlist_add_boolean_array);
EXPORT_SYMBOL(fnvlist_add_byte_array);
EXPORT_SYMBOL(fnvlist_add_int8_array);
EXPORT_SYMBOL(fnvlist_add_uint8_array);
EXPORT_SYMBOL(fnvlist_add_int16_array);
EXPORT_SYMBOL(fnvlist_add_uint16_array);
EXPORT_SYMBOL(fnvlist_add_int32_array);
EXPORT_SYMBOL(fnvlist_add_uint32_array);
EXPORT_SYMBOL(fnvlist_add_int64_array);
EXPORT_SYMBOL(fnvlist_add_uint64_array);
EXPORT_SYMBOL(fnvlist_add_string_array);
EXPORT_SYMBOL(fnvlist_add_nvlist_array);

EXPORT_SYMBOL(fnvlist_remove);
EXPORT_SYMBOL(fnvlist_remove_nvpair);

EXPORT_SYMBOL(fnvlist_lookup_nvpair);
EXPORT_SYMBOL(fnvlist_lookup_boolean);
EXPORT_SYMBOL(fnvlist_lookup_boolean_value);
EXPORT_SYMBOL(fnvlist_lookup_byte);
EXPORT_SYMBOL(fnvlist_lookup_int8);
EXPORT_SYMBOL(fnvlist_lookup_uint8);
EXPORT_SYMBOL(fnvlist_lookup_int16);
EXPORT_SYMBOL(fnvlist_lookup_uint16);
EXPORT_SYMBOL(fnvlist_lookup_int32);
EXPORT_SYMBOL(fnvlist_lookup_uint32);
EXPORT_SYMBOL(fnvlist_lookup_int64);
EXPORT_SYMBOL(fnvlist_lookup_uint64);
EXPORT_SYMBOL(fnvlist_lookup_string);
EXPORT_SYMBOL(fnvlist_lookup_nvlist);

EXPORT_SYMBOL(fnvpair_value_boolean_value);
EXPORT_SYMBOL(fnvpair_value_byte);
EXPORT_SYMBOL(fnvpair_value_int8);
EXPORT_SYMBOL(fnvpair_value_uint8);
EXPORT_SYMBOL(fnvpair_value_int16);
EXPORT_SYMBOL(fnvpair_value_uint16);
EXPORT_SYMBOL(fnvpair_value_int32);
EXPORT_SYMBOL(fnvpair_value_uint32);
EXPORT_SYMBOL(fnvpair_value_int64);
EXPORT_SYMBOL(fnvpair_value_uint64);
EXPORT_SYMBOL(fnvpair_value_string);
EXPORT_SYMBOL(fnvpair_value_nvlist);
EXPORT_SYMBOL(fnvlist_num_pairs);

#endif
    usr/src/zfs-0.6.5.9/module/nvpair/nvpair.c                                                          0100644 0000000 0000000 00000233161 13045370707 016525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2015, 2016 by Delphix. All rights reserved.
 */

#include <sys/stropts.h>
#include <sys/debug.h>
#include <sys/isa_defs.h>
#include <sys/int_limits.h>
#include <sys/nvpair.h>
#include <sys/nvpair_impl.h>
#include <rpc/types.h>
#include <rpc/xdr.h>

#if defined(_KERNEL) && !defined(_BOOT)
#include <sys/varargs.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
#else
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#endif

#ifndef	offsetof
#define	offsetof(s, m)		((size_t)(&(((s *)0)->m)))
#endif
#define	skip_whitespace(p)	while ((*(p) == ' ') || (*(p) == '\t')) p++

/*
 * nvpair.c - Provides kernel & userland interfaces for manipulating
 *	name-value pairs.
 *
 * Overview Diagram
 *
 *  +--------------+
 *  |  nvlist_t    |
 *  |--------------|
 *  | nvl_version  |
 *  | nvl_nvflag   |
 *  | nvl_priv    -+-+
 *  | nvl_flag     | |
 *  | nvl_pad      | |
 *  +--------------+ |
 *                   V
 *      +--------------+      last i_nvp in list
 *      | nvpriv_t     |  +--------------------->
 *      |--------------|  |
 *   +--+- nvp_list    |  |   +------------+
 *   |  |  nvp_last   -+--+   + nv_alloc_t |
 *   |  |  nvp_curr    |      |------------|
 *   |  |  nvp_nva    -+----> | nva_ops    |
 *   |  |  nvp_stat    |      | nva_arg    |
 *   |  +--------------+      +------------+
 *   |
 *   +-------+
 *           V
 *   +---------------------+      +-------------------+
 *   |  i_nvp_t            |  +-->|  i_nvp_t          |  +-->
 *   |---------------------|  |   |-------------------|  |
 *   | nvi_next           -+--+   | nvi_next         -+--+
 *   | nvi_prev (NULL)     | <----+ nvi_prev          |
 *   | . . . . . . . . . . |      | . . . . . . . . . |
 *   | nvp (nvpair_t)      |      | nvp (nvpair_t)    |
 *   |  - nvp_size         |      |  - nvp_size       |
 *   |  - nvp_name_sz      |      |  - nvp_name_sz    |
 *   |  - nvp_value_elem   |      |  - nvp_value_elem |
 *   |  - nvp_type         |      |  - nvp_type       |
 *   |  - data ...         |      |  - data ...       |
 *   +---------------------+      +-------------------+
 *
 *
 *
 *   +---------------------+              +---------------------+
 *   |  i_nvp_t            |  +-->    +-->|  i_nvp_t (last)     |
 *   |---------------------|  |       |   |---------------------|
 *   |  nvi_next          -+--+ ... --+   | nvi_next (NULL)     |
 * <-+- nvi_prev           |<-- ...  <----+ nvi_prev            |
 *   | . . . . . . . . .   |              | . . . . . . . . .   |
 *   | nvp (nvpair_t)      |              | nvp (nvpair_t)      |
 *   |  - nvp_size         |              |  - nvp_size         |
 *   |  - nvp_name_sz      |              |  - nvp_name_sz      |
 *   |  - nvp_value_elem   |              |  - nvp_value_elem   |
 *   |  - DATA_TYPE_NVLIST |              |  - nvp_type         |
 *   |  - data (embedded)  |              |  - data ...         |
 *   |    nvlist name      |              +---------------------+
 *   |  +--------------+   |
 *   |  |  nvlist_t    |   |
 *   |  |--------------|   |
 *   |  | nvl_version  |   |
 *   |  | nvl_nvflag   |   |
 *   |  | nvl_priv   --+---+---->
 *   |  | nvl_flag     |   |
 *   |  | nvl_pad      |   |
 *   |  +--------------+   |
 *   +---------------------+
 *
 *
 * N.B. nvpair_t may be aligned on 4 byte boundary, so +4 will
 * allow value to be aligned on 8 byte boundary
 *
 * name_len is the length of the name string including the null terminator
 * so it must be >= 1
 */
#define	NVP_SIZE_CALC(name_len, data_len) \
	(NV_ALIGN((sizeof (nvpair_t)) + name_len) + NV_ALIGN(data_len))

static int i_get_value_size(data_type_t type, const void *data, uint_t nelem);
static int nvlist_add_common(nvlist_t *nvl, const char *name, data_type_t type,
    uint_t nelem, const void *data);

#define	NV_STAT_EMBEDDED	0x1
#define	EMBEDDED_NVL(nvp)	((nvlist_t *)(void *)NVP_VALUE(nvp))
#define	EMBEDDED_NVL_ARRAY(nvp)	((nvlist_t **)(void *)NVP_VALUE(nvp))

#define	NVP_VALOFF(nvp)	(NV_ALIGN(sizeof (nvpair_t) + (nvp)->nvp_name_sz))
#define	NVPAIR2I_NVP(nvp) \
	((i_nvp_t *)((size_t)(nvp) - offsetof(i_nvp_t, nvi_nvp)))

#ifdef _KERNEL
int nvpair_max_recursion = 20;
#else
int nvpair_max_recursion = 100;
#endif

int
nv_alloc_init(nv_alloc_t *nva, const nv_alloc_ops_t *nvo, /* args */ ...)
{
	va_list valist;
	int err = 0;

	nva->nva_ops = nvo;
	nva->nva_arg = NULL;

	va_start(valist, nvo);
	if (nva->nva_ops->nv_ao_init != NULL)
		err = nva->nva_ops->nv_ao_init(nva, valist);
	va_end(valist);

	return (err);
}

void
nv_alloc_reset(nv_alloc_t *nva)
{
	if (nva->nva_ops->nv_ao_reset != NULL)
		nva->nva_ops->nv_ao_reset(nva);
}

void
nv_alloc_fini(nv_alloc_t *nva)
{
	if (nva->nva_ops->nv_ao_fini != NULL)
		nva->nva_ops->nv_ao_fini(nva);
}

nv_alloc_t *
nvlist_lookup_nv_alloc(nvlist_t *nvl)
{
	nvpriv_t *priv;

	if (nvl == NULL ||
	    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)
		return (NULL);

	return (priv->nvp_nva);
}

static void *
nv_mem_zalloc(nvpriv_t *nvp, size_t size)
{
	nv_alloc_t *nva = nvp->nvp_nva;
	void *buf;

	if ((buf = nva->nva_ops->nv_ao_alloc(nva, size)) != NULL)
		bzero(buf, size);

	return (buf);
}

static void
nv_mem_free(nvpriv_t *nvp, void *buf, size_t size)
{
	nv_alloc_t *nva = nvp->nvp_nva;

	nva->nva_ops->nv_ao_free(nva, buf, size);
}

static void
nv_priv_init(nvpriv_t *priv, nv_alloc_t *nva, uint32_t stat)
{
	bzero(priv, sizeof (nvpriv_t));

	priv->nvp_nva = nva;
	priv->nvp_stat = stat;
}

static nvpriv_t *
nv_priv_alloc(nv_alloc_t *nva)
{
	nvpriv_t *priv;

	/*
	 * nv_mem_alloc() cannot called here because it needs the priv
	 * argument.
	 */
	if ((priv = nva->nva_ops->nv_ao_alloc(nva, sizeof (nvpriv_t))) == NULL)
		return (NULL);

	nv_priv_init(priv, nva, 0);

	return (priv);
}

/*
 * Embedded lists need their own nvpriv_t's.  We create a new
 * nvpriv_t using the parameters and allocator from the parent
 * list's nvpriv_t.
 */
static nvpriv_t *
nv_priv_alloc_embedded(nvpriv_t *priv)
{
	nvpriv_t *emb_priv;

	if ((emb_priv = nv_mem_zalloc(priv, sizeof (nvpriv_t))) == NULL)
		return (NULL);

	nv_priv_init(emb_priv, priv->nvp_nva, NV_STAT_EMBEDDED);

	return (emb_priv);
}

static void
nvlist_init(nvlist_t *nvl, uint32_t nvflag, nvpriv_t *priv)
{
	nvl->nvl_version = NV_VERSION;
	nvl->nvl_nvflag = nvflag & (NV_UNIQUE_NAME|NV_UNIQUE_NAME_TYPE);
	nvl->nvl_priv = (uint64_t)(uintptr_t)priv;
	nvl->nvl_flag = 0;
	nvl->nvl_pad = 0;
}

uint_t
nvlist_nvflag(nvlist_t *nvl)
{
	return (nvl->nvl_nvflag);
}

static nv_alloc_t *
nvlist_nv_alloc(int kmflag)
{
#if defined(_KERNEL) && !defined(_BOOT)
	switch (kmflag) {
	case KM_SLEEP:
		return (nv_alloc_sleep);
	case KM_PUSHPAGE:
		return (nv_alloc_pushpage);
	default:
		return (nv_alloc_nosleep);
	}
#else
	return (nv_alloc_nosleep);
#endif /* _KERNEL && !_BOOT */
}

/*
 * nvlist_alloc - Allocate nvlist.
 */
int
nvlist_alloc(nvlist_t **nvlp, uint_t nvflag, int kmflag)
{
	return (nvlist_xalloc(nvlp, nvflag, nvlist_nv_alloc(kmflag)));
}

int
nvlist_xalloc(nvlist_t **nvlp, uint_t nvflag, nv_alloc_t *nva)
{
	nvpriv_t *priv;

	if (nvlp == NULL || nva == NULL)
		return (EINVAL);

	if ((priv = nv_priv_alloc(nva)) == NULL)
		return (ENOMEM);

	if ((*nvlp = nv_mem_zalloc(priv,
	    NV_ALIGN(sizeof (nvlist_t)))) == NULL) {
		nv_mem_free(priv, priv, sizeof (nvpriv_t));
		return (ENOMEM);
	}

	nvlist_init(*nvlp, nvflag, priv);

	return (0);
}

/*
 * nvp_buf_alloc - Allocate i_nvp_t for storing a new nv pair.
 */
static nvpair_t *
nvp_buf_alloc(nvlist_t *nvl, size_t len)
{
	nvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;
	i_nvp_t *buf;
	nvpair_t *nvp;
	size_t nvsize;

	/*
	 * Allocate the buffer
	 */
	nvsize = len + offsetof(i_nvp_t, nvi_nvp);

	if ((buf = nv_mem_zalloc(priv, nvsize)) == NULL)
		return (NULL);

	nvp = &buf->nvi_nvp;
	nvp->nvp_size = len;

	return (nvp);
}

/*
 * nvp_buf_free - de-Allocate an i_nvp_t.
 */
static void
nvp_buf_free(nvlist_t *nvl, nvpair_t *nvp)
{
	nvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;
	size_t nvsize = nvp->nvp_size + offsetof(i_nvp_t, nvi_nvp);

	nv_mem_free(priv, NVPAIR2I_NVP(nvp), nvsize);
}

/*
 * nvp_buf_link - link a new nv pair into the nvlist.
 */
static void
nvp_buf_link(nvlist_t *nvl, nvpair_t *nvp)
{
	nvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;
	i_nvp_t *curr = NVPAIR2I_NVP(nvp);

	/* Put element at end of nvlist */
	if (priv->nvp_list == NULL) {
		priv->nvp_list = priv->nvp_last = curr;
	} else {
		curr->nvi_prev = priv->nvp_last;
		priv->nvp_last->nvi_next = curr;
		priv->nvp_last = curr;
	}
}

/*
 * nvp_buf_unlink - unlink an removed nvpair out of the nvlist.
 */
static void
nvp_buf_unlink(nvlist_t *nvl, nvpair_t *nvp)
{
	nvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;
	i_nvp_t *curr = NVPAIR2I_NVP(nvp);

	/*
	 * protect nvlist_next_nvpair() against walking on freed memory.
	 */
	if (priv->nvp_curr == curr)
		priv->nvp_curr = curr->nvi_next;

	if (curr == priv->nvp_list)
		priv->nvp_list = curr->nvi_next;
	else
		curr->nvi_prev->nvi_next = curr->nvi_next;

	if (curr == priv->nvp_last)
		priv->nvp_last = curr->nvi_prev;
	else
		curr->nvi_next->nvi_prev = curr->nvi_prev;
}

/*
 * take a nvpair type and number of elements and make sure the are valid
 */
static int
i_validate_type_nelem(data_type_t type, uint_t nelem)
{
	switch (type) {
	case DATA_TYPE_BOOLEAN:
		if (nelem != 0)
			return (EINVAL);
		break;
	case DATA_TYPE_BOOLEAN_VALUE:
	case DATA_TYPE_BYTE:
	case DATA_TYPE_INT8:
	case DATA_TYPE_UINT8:
	case DATA_TYPE_INT16:
	case DATA_TYPE_UINT16:
	case DATA_TYPE_INT32:
	case DATA_TYPE_UINT32:
	case DATA_TYPE_INT64:
	case DATA_TYPE_UINT64:
	case DATA_TYPE_STRING:
	case DATA_TYPE_HRTIME:
	case DATA_TYPE_NVLIST:
#if !defined(_KERNEL)
	case DATA_TYPE_DOUBLE:
#endif
		if (nelem != 1)
			return (EINVAL);
		break;
	case DATA_TYPE_BOOLEAN_ARRAY:
	case DATA_TYPE_BYTE_ARRAY:
	case DATA_TYPE_INT8_ARRAY:
	case DATA_TYPE_UINT8_ARRAY:
	case DATA_TYPE_INT16_ARRAY:
	case DATA_TYPE_UINT16_ARRAY:
	case DATA_TYPE_INT32_ARRAY:
	case DATA_TYPE_UINT32_ARRAY:
	case DATA_TYPE_INT64_ARRAY:
	case DATA_TYPE_UINT64_ARRAY:
	case DATA_TYPE_STRING_ARRAY:
	case DATA_TYPE_NVLIST_ARRAY:
		/* we allow arrays with 0 elements */
		break;
	default:
		return (EINVAL);
	}
	return (0);
}

/*
 * Verify nvp_name_sz and check the name string length.
 */
static int
i_validate_nvpair_name(nvpair_t *nvp)
{
	if ((nvp->nvp_name_sz <= 0) ||
	    (nvp->nvp_size < NVP_SIZE_CALC(nvp->nvp_name_sz, 0)))
		return (EFAULT);

	/* verify the name string, make sure its terminated */
	if (NVP_NAME(nvp)[nvp->nvp_name_sz - 1] != '\0')
		return (EFAULT);

	return (strlen(NVP_NAME(nvp)) == nvp->nvp_name_sz - 1 ? 0 : EFAULT);
}

static int
i_validate_nvpair_value(data_type_t type, uint_t nelem, const void *data)
{
	switch (type) {
	case DATA_TYPE_BOOLEAN_VALUE:
		if (*(boolean_t *)data != B_TRUE &&
		    *(boolean_t *)data != B_FALSE)
			return (EINVAL);
		break;
	case DATA_TYPE_BOOLEAN_ARRAY: {
		int i;

		for (i = 0; i < nelem; i++)
			if (((boolean_t *)data)[i] != B_TRUE &&
			    ((boolean_t *)data)[i] != B_FALSE)
				return (EINVAL);
		break;
	}
	default:
		break;
	}

	return (0);
}

/*
 * This function takes a pointer to what should be a nvpair and it's size
 * and then verifies that all the nvpair fields make sense and can be
 * trusted.  This function is used when decoding packed nvpairs.
 */
static int
i_validate_nvpair(nvpair_t *nvp)
{
	data_type_t type = NVP_TYPE(nvp);
	int size1, size2;

	/* verify nvp_name_sz, check the name string length */
	if (i_validate_nvpair_name(nvp) != 0)
		return (EFAULT);

	if (i_validate_nvpair_value(type, NVP_NELEM(nvp), NVP_VALUE(nvp)) != 0)
		return (EFAULT);

	/*
	 * verify nvp_type, nvp_value_elem, and also possibly
	 * verify string values and get the value size.
	 */
	size2 = i_get_value_size(type, NVP_VALUE(nvp), NVP_NELEM(nvp));
	size1 = nvp->nvp_size - NVP_VALOFF(nvp);
	if (size2 < 0 || size1 != NV_ALIGN(size2))
		return (EFAULT);

	return (0);
}

static int
nvlist_copy_pairs(nvlist_t *snvl, nvlist_t *dnvl)
{
	nvpriv_t *priv;
	i_nvp_t *curr;

	if ((priv = (nvpriv_t *)(uintptr_t)snvl->nvl_priv) == NULL)
		return (EINVAL);

	for (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next) {
		nvpair_t *nvp = &curr->nvi_nvp;
		int err;

		if ((err = nvlist_add_common(dnvl, NVP_NAME(nvp), NVP_TYPE(nvp),
		    NVP_NELEM(nvp), NVP_VALUE(nvp))) != 0)
			return (err);
	}

	return (0);
}

/*
 * Frees all memory allocated for an nvpair (like embedded lists) with
 * the exception of the nvpair buffer itself.
 */
static void
nvpair_free(nvpair_t *nvp)
{
	switch (NVP_TYPE(nvp)) {
	case DATA_TYPE_NVLIST:
		nvlist_free(EMBEDDED_NVL(nvp));
		break;
	case DATA_TYPE_NVLIST_ARRAY: {
		nvlist_t **nvlp = EMBEDDED_NVL_ARRAY(nvp);
		int i;

		for (i = 0; i < NVP_NELEM(nvp); i++)
			if (nvlp[i] != NULL)
				nvlist_free(nvlp[i]);
		break;
	}
	default:
		break;
	}
}

/*
 * nvlist_free - free an unpacked nvlist
 */
void
nvlist_free(nvlist_t *nvl)
{
	nvpriv_t *priv;
	i_nvp_t *curr;

	if (nvl == NULL ||
	    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)
		return;

	/*
	 * Unpacked nvlist are linked through i_nvp_t
	 */
	curr = priv->nvp_list;
	while (curr != NULL) {
		nvpair_t *nvp = &curr->nvi_nvp;
		curr = curr->nvi_next;

		nvpair_free(nvp);
		nvp_buf_free(nvl, nvp);
	}

	if (!(priv->nvp_stat & NV_STAT_EMBEDDED))
		nv_mem_free(priv, nvl, NV_ALIGN(sizeof (nvlist_t)));
	else
		nvl->nvl_priv = 0;

	nv_mem_free(priv, priv, sizeof (nvpriv_t));
}

static int
nvlist_contains_nvp(nvlist_t *nvl, nvpair_t *nvp)
{
	nvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;
	i_nvp_t *curr;

	if (nvp == NULL)
		return (0);

	for (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next)
		if (&curr->nvi_nvp == nvp)
			return (1);

	return (0);
}

/*
 * Make a copy of nvlist
 */
int
nvlist_dup(nvlist_t *nvl, nvlist_t **nvlp, int kmflag)
{
	return (nvlist_xdup(nvl, nvlp, nvlist_nv_alloc(kmflag)));
}

int
nvlist_xdup(nvlist_t *nvl, nvlist_t **nvlp, nv_alloc_t *nva)
{
	int err;
	nvlist_t *ret;

	if (nvl == NULL || nvlp == NULL)
		return (EINVAL);

	if ((err = nvlist_xalloc(&ret, nvl->nvl_nvflag, nva)) != 0)
		return (err);

	if ((err = nvlist_copy_pairs(nvl, ret)) != 0)
		nvlist_free(ret);
	else
		*nvlp = ret;

	return (err);
}

/*
 * Remove all with matching name
 */
int
nvlist_remove_all(nvlist_t *nvl, const char *name)
{
	nvpriv_t *priv;
	i_nvp_t *curr;
	int error = ENOENT;

	if (nvl == NULL || name == NULL ||
	    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)
		return (EINVAL);

	curr = priv->nvp_list;
	while (curr != NULL) {
		nvpair_t *nvp = &curr->nvi_nvp;

		curr = curr->nvi_next;
		if (strcmp(name, NVP_NAME(nvp)) != 0)
			continue;

		nvp_buf_unlink(nvl, nvp);
		nvpair_free(nvp);
		nvp_buf_free(nvl, nvp);

		error = 0;
	}

	return (error);
}

/*
 * Remove first one with matching name and type
 */
int
nvlist_remove(nvlist_t *nvl, const char *name, data_type_t type)
{
	nvpriv_t *priv;
	i_nvp_t *curr;

	if (nvl == NULL || name == NULL ||
	    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)
		return (EINVAL);

	curr = priv->nvp_list;
	while (curr != NULL) {
		nvpair_t *nvp = &curr->nvi_nvp;

		if (strcmp(name, NVP_NAME(nvp)) == 0 && NVP_TYPE(nvp) == type) {
			nvp_buf_unlink(nvl, nvp);
			nvpair_free(nvp);
			nvp_buf_free(nvl, nvp);

			return (0);
		}
		curr = curr->nvi_next;
	}

	return (ENOENT);
}

int
nvlist_remove_nvpair(nvlist_t *nvl, nvpair_t *nvp)
{
	if (nvl == NULL || nvp == NULL)
		return (EINVAL);

	nvp_buf_unlink(nvl, nvp);
	nvpair_free(nvp);
	nvp_buf_free(nvl, nvp);
	return (0);
}

/*
 * This function calculates the size of an nvpair value.
 *
 * The data argument controls the behavior in case of the data types
 * 	DATA_TYPE_STRING    	and
 *	DATA_TYPE_STRING_ARRAY
 * Is data == NULL then the size of the string(s) is excluded.
 */
static int
i_get_value_size(data_type_t type, const void *data, uint_t nelem)
{
	uint64_t value_sz;

	if (i_validate_type_nelem(type, nelem) != 0)
		return (-1);

	/* Calculate required size for holding value */
	switch (type) {
	case DATA_TYPE_BOOLEAN:
		value_sz = 0;
		break;
	case DATA_TYPE_BOOLEAN_VALUE:
		value_sz = sizeof (boolean_t);
		break;
	case DATA_TYPE_BYTE:
		value_sz = sizeof (uchar_t);
		break;
	case DATA_TYPE_INT8:
		value_sz = sizeof (int8_t);
		break;
	case DATA_TYPE_UINT8:
		value_sz = sizeof (uint8_t);
		break;
	case DATA_TYPE_INT16:
		value_sz = sizeof (int16_t);
		break;
	case DATA_TYPE_UINT16:
		value_sz = sizeof (uint16_t);
		break;
	case DATA_TYPE_INT32:
		value_sz = sizeof (int32_t);
		break;
	case DATA_TYPE_UINT32:
		value_sz = sizeof (uint32_t);
		break;
	case DATA_TYPE_INT64:
		value_sz = sizeof (int64_t);
		break;
	case DATA_TYPE_UINT64:
		value_sz = sizeof (uint64_t);
		break;
#if !defined(_KERNEL)
	case DATA_TYPE_DOUBLE:
		value_sz = sizeof (double);
		break;
#endif
	case DATA_TYPE_STRING:
		if (data == NULL)
			value_sz = 0;
		else
			value_sz = strlen(data) + 1;
		break;
	case DATA_TYPE_BOOLEAN_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (boolean_t);
		break;
	case DATA_TYPE_BYTE_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (uchar_t);
		break;
	case DATA_TYPE_INT8_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (int8_t);
		break;
	case DATA_TYPE_UINT8_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (uint8_t);
		break;
	case DATA_TYPE_INT16_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (int16_t);
		break;
	case DATA_TYPE_UINT16_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (uint16_t);
		break;
	case DATA_TYPE_INT32_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (int32_t);
		break;
	case DATA_TYPE_UINT32_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (uint32_t);
		break;
	case DATA_TYPE_INT64_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (int64_t);
		break;
	case DATA_TYPE_UINT64_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (uint64_t);
		break;
	case DATA_TYPE_STRING_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (uint64_t);

		if (data != NULL) {
			char *const *strs = data;
			uint_t i;

			/* no alignment requirement for strings */
			for (i = 0; i < nelem; i++) {
				if (strs[i] == NULL)
					return (-1);
				value_sz += strlen(strs[i]) + 1;
			}
		}
		break;
	case DATA_TYPE_HRTIME:
		value_sz = sizeof (hrtime_t);
		break;
	case DATA_TYPE_NVLIST:
		value_sz = NV_ALIGN(sizeof (nvlist_t));
		break;
	case DATA_TYPE_NVLIST_ARRAY:
		value_sz = (uint64_t)nelem * sizeof (uint64_t) +
		    (uint64_t)nelem * NV_ALIGN(sizeof (nvlist_t));
		break;
	default:
		return (-1);
	}

	return (value_sz > INT32_MAX ? -1 : (int)value_sz);
}

static int
nvlist_copy_embedded(nvlist_t *nvl, nvlist_t *onvl, nvlist_t *emb_nvl)
{
	nvpriv_t *priv;
	int err;

	if ((priv = nv_priv_alloc_embedded((nvpriv_t *)(uintptr_t)
	    nvl->nvl_priv)) == NULL)
		return (ENOMEM);

	nvlist_init(emb_nvl, onvl->nvl_nvflag, priv);

	if ((err = nvlist_copy_pairs(onvl, emb_nvl)) != 0) {
		nvlist_free(emb_nvl);
		emb_nvl->nvl_priv = 0;
	}

	return (err);
}

/*
 * nvlist_add_common - Add new <name,value> pair to nvlist
 */
static int
nvlist_add_common(nvlist_t *nvl, const char *name,
    data_type_t type, uint_t nelem, const void *data)
{
	nvpair_t *nvp;
	uint_t i;

	int nvp_sz, name_sz, value_sz;
	int err = 0;

	if (name == NULL || nvl == NULL || nvl->nvl_priv == 0)
		return (EINVAL);

	if (nelem != 0 && data == NULL)
		return (EINVAL);

	/*
	 * Verify type and nelem and get the value size.
	 * In case of data types DATA_TYPE_STRING and DATA_TYPE_STRING_ARRAY
	 * is the size of the string(s) included.
	 */
	if ((value_sz = i_get_value_size(type, data, nelem)) < 0)
		return (EINVAL);

	if (i_validate_nvpair_value(type, nelem, data) != 0)
		return (EINVAL);

	/*
	 * If we're adding an nvlist or nvlist array, ensure that we are not
	 * adding the input nvlist to itself, which would cause recursion,
	 * and ensure that no NULL nvlist pointers are present.
	 */
	switch (type) {
	case DATA_TYPE_NVLIST:
		if (data == nvl || data == NULL)
			return (EINVAL);
		break;
	case DATA_TYPE_NVLIST_ARRAY: {
		nvlist_t **onvlp = (nvlist_t **)data;
		for (i = 0; i < nelem; i++) {
			if (onvlp[i] == nvl || onvlp[i] == NULL)
				return (EINVAL);
		}
		break;
	}
	default:
		break;
	}

	/* calculate sizes of the nvpair elements and the nvpair itself */
	name_sz = strlen(name) + 1;

	nvp_sz = NVP_SIZE_CALC(name_sz, value_sz);

	if ((nvp = nvp_buf_alloc(nvl, nvp_sz)) == NULL)
		return (ENOMEM);

	ASSERT(nvp->nvp_size == nvp_sz);
	nvp->nvp_name_sz = name_sz;
	nvp->nvp_value_elem = nelem;
	nvp->nvp_type = type;
	bcopy(name, NVP_NAME(nvp), name_sz);

	switch (type) {
	case DATA_TYPE_BOOLEAN:
		break;
	case DATA_TYPE_STRING_ARRAY: {
		char *const *strs = data;
		char *buf = NVP_VALUE(nvp);
		char **cstrs = (void *)buf;

		/* skip pre-allocated space for pointer array */
		buf += nelem * sizeof (uint64_t);
		for (i = 0; i < nelem; i++) {
			int slen = strlen(strs[i]) + 1;
			bcopy(strs[i], buf, slen);
			cstrs[i] = buf;
			buf += slen;
		}
		break;
	}
	case DATA_TYPE_NVLIST: {
		nvlist_t *nnvl = EMBEDDED_NVL(nvp);
		nvlist_t *onvl = (nvlist_t *)data;

		if ((err = nvlist_copy_embedded(nvl, onvl, nnvl)) != 0) {
			nvp_buf_free(nvl, nvp);
			return (err);
		}
		break;
	}
	case DATA_TYPE_NVLIST_ARRAY: {
		nvlist_t **onvlp = (nvlist_t **)data;
		nvlist_t **nvlp = EMBEDDED_NVL_ARRAY(nvp);
		nvlist_t *embedded = (nvlist_t *)
		    ((uintptr_t)nvlp + nelem * sizeof (uint64_t));

		for (i = 0; i < nelem; i++) {
			if ((err = nvlist_copy_embedded(nvl,
			    onvlp[i], embedded)) != 0) {
				/*
				 * Free any successfully created lists
				 */
				nvpair_free(nvp);
				nvp_buf_free(nvl, nvp);
				return (err);
			}

			nvlp[i] = embedded++;
		}
		break;
	}
	default:
		bcopy(data, NVP_VALUE(nvp), value_sz);
	}

	/* if unique name, remove before add */
	if (nvl->nvl_nvflag & NV_UNIQUE_NAME)
		(void) nvlist_remove_all(nvl, name);
	else if (nvl->nvl_nvflag & NV_UNIQUE_NAME_TYPE)
		(void) nvlist_remove(nvl, name, type);

	nvp_buf_link(nvl, nvp);

	return (0);
}

int
nvlist_add_boolean(nvlist_t *nvl, const char *name)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_BOOLEAN, 0, NULL));
}

int
nvlist_add_boolean_value(nvlist_t *nvl, const char *name, boolean_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_BOOLEAN_VALUE, 1, &val));
}

int
nvlist_add_byte(nvlist_t *nvl, const char *name, uchar_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_BYTE, 1, &val));
}

int
nvlist_add_int8(nvlist_t *nvl, const char *name, int8_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_INT8, 1, &val));
}

int
nvlist_add_uint8(nvlist_t *nvl, const char *name, uint8_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_UINT8, 1, &val));
}

int
nvlist_add_int16(nvlist_t *nvl, const char *name, int16_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_INT16, 1, &val));
}

int
nvlist_add_uint16(nvlist_t *nvl, const char *name, uint16_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_UINT16, 1, &val));
}

int
nvlist_add_int32(nvlist_t *nvl, const char *name, int32_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_INT32, 1, &val));
}

int
nvlist_add_uint32(nvlist_t *nvl, const char *name, uint32_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_UINT32, 1, &val));
}

int
nvlist_add_int64(nvlist_t *nvl, const char *name, int64_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_INT64, 1, &val));
}

int
nvlist_add_uint64(nvlist_t *nvl, const char *name, uint64_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_UINT64, 1, &val));
}

#if !defined(_KERNEL)
int
nvlist_add_double(nvlist_t *nvl, const char *name, double val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_DOUBLE, 1, &val));
}
#endif

int
nvlist_add_string(nvlist_t *nvl, const char *name, const char *val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_STRING, 1, (void *)val));
}

int
nvlist_add_boolean_array(nvlist_t *nvl, const char *name,
    boolean_t *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_BOOLEAN_ARRAY, n, a));
}

int
nvlist_add_byte_array(nvlist_t *nvl, const char *name, uchar_t *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_BYTE_ARRAY, n, a));
}

int
nvlist_add_int8_array(nvlist_t *nvl, const char *name, int8_t *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_INT8_ARRAY, n, a));
}

int
nvlist_add_uint8_array(nvlist_t *nvl, const char *name, uint8_t *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_UINT8_ARRAY, n, a));
}

int
nvlist_add_int16_array(nvlist_t *nvl, const char *name, int16_t *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_INT16_ARRAY, n, a));
}

int
nvlist_add_uint16_array(nvlist_t *nvl, const char *name, uint16_t *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_UINT16_ARRAY, n, a));
}

int
nvlist_add_int32_array(nvlist_t *nvl, const char *name, int32_t *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_INT32_ARRAY, n, a));
}

int
nvlist_add_uint32_array(nvlist_t *nvl, const char *name, uint32_t *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_UINT32_ARRAY, n, a));
}

int
nvlist_add_int64_array(nvlist_t *nvl, const char *name, int64_t *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_INT64_ARRAY, n, a));
}

int
nvlist_add_uint64_array(nvlist_t *nvl, const char *name, uint64_t *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_UINT64_ARRAY, n, a));
}

int
nvlist_add_string_array(nvlist_t *nvl, const char *name,
    char *const *a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_STRING_ARRAY, n, a));
}

int
nvlist_add_hrtime(nvlist_t *nvl, const char *name, hrtime_t val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_HRTIME, 1, &val));
}

int
nvlist_add_nvlist(nvlist_t *nvl, const char *name, nvlist_t *val)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_NVLIST, 1, val));
}

int
nvlist_add_nvlist_array(nvlist_t *nvl, const char *name, nvlist_t **a, uint_t n)
{
	return (nvlist_add_common(nvl, name, DATA_TYPE_NVLIST_ARRAY, n, a));
}

/* reading name-value pairs */
nvpair_t *
nvlist_next_nvpair(nvlist_t *nvl, nvpair_t *nvp)
{
	nvpriv_t *priv;
	i_nvp_t *curr;

	if (nvl == NULL ||
	    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)
		return (NULL);

	curr = NVPAIR2I_NVP(nvp);

	/*
	 * Ensure that nvp is a valid nvpair on this nvlist.
	 * NB: nvp_curr is used only as a hint so that we don't always
	 * have to walk the list to determine if nvp is still on the list.
	 */
	if (nvp == NULL)
		curr = priv->nvp_list;
	else if (priv->nvp_curr == curr || nvlist_contains_nvp(nvl, nvp))
		curr = curr->nvi_next;
	else
		curr = NULL;

	priv->nvp_curr = curr;

	return (curr != NULL ? &curr->nvi_nvp : NULL);
}

nvpair_t *
nvlist_prev_nvpair(nvlist_t *nvl, nvpair_t *nvp)
{
	nvpriv_t *priv;
	i_nvp_t *curr;

	if (nvl == NULL ||
	    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)
		return (NULL);

	curr = NVPAIR2I_NVP(nvp);

	if (nvp == NULL)
		curr = priv->nvp_last;
	else if (priv->nvp_curr == curr || nvlist_contains_nvp(nvl, nvp))
		curr = curr->nvi_prev;
	else
		curr = NULL;

	priv->nvp_curr = curr;

	return (curr != NULL ? &curr->nvi_nvp : NULL);
}

boolean_t
nvlist_empty(nvlist_t *nvl)
{
	nvpriv_t *priv;

	if (nvl == NULL ||
	    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)
		return (B_TRUE);

	return (priv->nvp_list == NULL);
}

char *
nvpair_name(nvpair_t *nvp)
{
	return (NVP_NAME(nvp));
}

data_type_t
nvpair_type(nvpair_t *nvp)
{
	return (NVP_TYPE(nvp));
}

int
nvpair_type_is_array(nvpair_t *nvp)
{
	data_type_t type = NVP_TYPE(nvp);

	if ((type == DATA_TYPE_BYTE_ARRAY) ||
	    (type == DATA_TYPE_UINT8_ARRAY) ||
	    (type == DATA_TYPE_INT16_ARRAY) ||
	    (type == DATA_TYPE_UINT16_ARRAY) ||
	    (type == DATA_TYPE_INT32_ARRAY) ||
	    (type == DATA_TYPE_UINT32_ARRAY) ||
	    (type == DATA_TYPE_INT64_ARRAY) ||
	    (type == DATA_TYPE_UINT64_ARRAY) ||
	    (type == DATA_TYPE_BOOLEAN_ARRAY) ||
	    (type == DATA_TYPE_STRING_ARRAY) ||
	    (type == DATA_TYPE_NVLIST_ARRAY))
		return (1);
	return (0);

}

static int
nvpair_value_common(nvpair_t *nvp, data_type_t type, uint_t *nelem, void *data)
{
	if (nvp == NULL || nvpair_type(nvp) != type)
		return (EINVAL);

	/*
	 * For non-array types, we copy the data.
	 * For array types (including string), we set a pointer.
	 */
	switch (type) {
	case DATA_TYPE_BOOLEAN:
		if (nelem != NULL)
			*nelem = 0;
		break;

	case DATA_TYPE_BOOLEAN_VALUE:
	case DATA_TYPE_BYTE:
	case DATA_TYPE_INT8:
	case DATA_TYPE_UINT8:
	case DATA_TYPE_INT16:
	case DATA_TYPE_UINT16:
	case DATA_TYPE_INT32:
	case DATA_TYPE_UINT32:
	case DATA_TYPE_INT64:
	case DATA_TYPE_UINT64:
	case DATA_TYPE_HRTIME:
#if !defined(_KERNEL)
	case DATA_TYPE_DOUBLE:
#endif
		if (data == NULL)
			return (EINVAL);
		bcopy(NVP_VALUE(nvp), data,
		    (size_t)i_get_value_size(type, NULL, 1));
		if (nelem != NULL)
			*nelem = 1;
		break;

	case DATA_TYPE_NVLIST:
	case DATA_TYPE_STRING:
		if (data == NULL)
			return (EINVAL);
		*(void **)data = (void *)NVP_VALUE(nvp);
		if (nelem != NULL)
			*nelem = 1;
		break;

	case DATA_TYPE_BOOLEAN_ARRAY:
	case DATA_TYPE_BYTE_ARRAY:
	case DATA_TYPE_INT8_ARRAY:
	case DATA_TYPE_UINT8_ARRAY:
	case DATA_TYPE_INT16_ARRAY:
	case DATA_TYPE_UINT16_ARRAY:
	case DATA_TYPE_INT32_ARRAY:
	case DATA_TYPE_UINT32_ARRAY:
	case DATA_TYPE_INT64_ARRAY:
	case DATA_TYPE_UINT64_ARRAY:
	case DATA_TYPE_STRING_ARRAY:
	case DATA_TYPE_NVLIST_ARRAY:
		if (nelem == NULL || data == NULL)
			return (EINVAL);
		if ((*nelem = NVP_NELEM(nvp)) != 0)
			*(void **)data = (void *)NVP_VALUE(nvp);
		else
			*(void **)data = NULL;
		break;

	default:
		return (ENOTSUP);
	}

	return (0);
}

static int
nvlist_lookup_common(nvlist_t *nvl, const char *name, data_type_t type,
    uint_t *nelem, void *data)
{
	nvpriv_t *priv;
	nvpair_t *nvp;
	i_nvp_t *curr;

	if (name == NULL || nvl == NULL ||
	    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)
		return (EINVAL);

	if (!(nvl->nvl_nvflag & (NV_UNIQUE_NAME | NV_UNIQUE_NAME_TYPE)))
		return (ENOTSUP);

	for (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next) {
		nvp = &curr->nvi_nvp;

		if (strcmp(name, NVP_NAME(nvp)) == 0 && NVP_TYPE(nvp) == type)
			return (nvpair_value_common(nvp, type, nelem, data));
	}

	return (ENOENT);
}

int
nvlist_lookup_boolean(nvlist_t *nvl, const char *name)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_BOOLEAN, NULL, NULL));
}

int
nvlist_lookup_boolean_value(nvlist_t *nvl, const char *name, boolean_t *val)
{
	return (nvlist_lookup_common(nvl, name,
	    DATA_TYPE_BOOLEAN_VALUE, NULL, val));
}

int
nvlist_lookup_byte(nvlist_t *nvl, const char *name, uchar_t *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_BYTE, NULL, val));
}

int
nvlist_lookup_int8(nvlist_t *nvl, const char *name, int8_t *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_INT8, NULL, val));
}

int
nvlist_lookup_uint8(nvlist_t *nvl, const char *name, uint8_t *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT8, NULL, val));
}

int
nvlist_lookup_int16(nvlist_t *nvl, const char *name, int16_t *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_INT16, NULL, val));
}

int
nvlist_lookup_uint16(nvlist_t *nvl, const char *name, uint16_t *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT16, NULL, val));
}

int
nvlist_lookup_int32(nvlist_t *nvl, const char *name, int32_t *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_INT32, NULL, val));
}

int
nvlist_lookup_uint32(nvlist_t *nvl, const char *name, uint32_t *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT32, NULL, val));
}

int
nvlist_lookup_int64(nvlist_t *nvl, const char *name, int64_t *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_INT64, NULL, val));
}

int
nvlist_lookup_uint64(nvlist_t *nvl, const char *name, uint64_t *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT64, NULL, val));
}

#if !defined(_KERNEL)
int
nvlist_lookup_double(nvlist_t *nvl, const char *name, double *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_DOUBLE, NULL, val));
}
#endif

int
nvlist_lookup_string(nvlist_t *nvl, const char *name, char **val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_STRING, NULL, val));
}

int
nvlist_lookup_nvlist(nvlist_t *nvl, const char *name, nvlist_t **val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_NVLIST, NULL, val));
}

int
nvlist_lookup_boolean_array(nvlist_t *nvl, const char *name,
    boolean_t **a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name,
	    DATA_TYPE_BOOLEAN_ARRAY, n, a));
}

int
nvlist_lookup_byte_array(nvlist_t *nvl, const char *name,
    uchar_t **a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_BYTE_ARRAY, n, a));
}

int
nvlist_lookup_int8_array(nvlist_t *nvl, const char *name, int8_t **a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_INT8_ARRAY, n, a));
}

int
nvlist_lookup_uint8_array(nvlist_t *nvl, const char *name,
    uint8_t **a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT8_ARRAY, n, a));
}

int
nvlist_lookup_int16_array(nvlist_t *nvl, const char *name,
    int16_t **a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_INT16_ARRAY, n, a));
}

int
nvlist_lookup_uint16_array(nvlist_t *nvl, const char *name,
    uint16_t **a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT16_ARRAY, n, a));
}

int
nvlist_lookup_int32_array(nvlist_t *nvl, const char *name,
    int32_t **a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_INT32_ARRAY, n, a));
}

int
nvlist_lookup_uint32_array(nvlist_t *nvl, const char *name,
    uint32_t **a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT32_ARRAY, n, a));
}

int
nvlist_lookup_int64_array(nvlist_t *nvl, const char *name,
    int64_t **a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_INT64_ARRAY, n, a));
}

int
nvlist_lookup_uint64_array(nvlist_t *nvl, const char *name,
    uint64_t **a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT64_ARRAY, n, a));
}

int
nvlist_lookup_string_array(nvlist_t *nvl, const char *name,
    char ***a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_STRING_ARRAY, n, a));
}

int
nvlist_lookup_nvlist_array(nvlist_t *nvl, const char *name,
    nvlist_t ***a, uint_t *n)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_NVLIST_ARRAY, n, a));
}

int
nvlist_lookup_hrtime(nvlist_t *nvl, const char *name, hrtime_t *val)
{
	return (nvlist_lookup_common(nvl, name, DATA_TYPE_HRTIME, NULL, val));
}

int
nvlist_lookup_pairs(nvlist_t *nvl, int flag, ...)
{
	va_list ap;
	char *name;
	int noentok = (flag & NV_FLAG_NOENTOK ? 1 : 0);
	int ret = 0;

	va_start(ap, flag);
	while (ret == 0 && (name = va_arg(ap, char *)) != NULL) {
		data_type_t type;
		void *val;
		uint_t *nelem;

		switch (type = va_arg(ap, data_type_t)) {
		case DATA_TYPE_BOOLEAN:
			ret = nvlist_lookup_common(nvl, name, type, NULL, NULL);
			break;

		case DATA_TYPE_BOOLEAN_VALUE:
		case DATA_TYPE_BYTE:
		case DATA_TYPE_INT8:
		case DATA_TYPE_UINT8:
		case DATA_TYPE_INT16:
		case DATA_TYPE_UINT16:
		case DATA_TYPE_INT32:
		case DATA_TYPE_UINT32:
		case DATA_TYPE_INT64:
		case DATA_TYPE_UINT64:
		case DATA_TYPE_HRTIME:
		case DATA_TYPE_STRING:
		case DATA_TYPE_NVLIST:
#if !defined(_KERNEL)
		case DATA_TYPE_DOUBLE:
#endif
			val = va_arg(ap, void *);
			ret = nvlist_lookup_common(nvl, name, type, NULL, val);
			break;

		case DATA_TYPE_BYTE_ARRAY:
		case DATA_TYPE_BOOLEAN_ARRAY:
		case DATA_TYPE_INT8_ARRAY:
		case DATA_TYPE_UINT8_ARRAY:
		case DATA_TYPE_INT16_ARRAY:
		case DATA_TYPE_UINT16_ARRAY:
		case DATA_TYPE_INT32_ARRAY:
		case DATA_TYPE_UINT32_ARRAY:
		case DATA_TYPE_INT64_ARRAY:
		case DATA_TYPE_UINT64_ARRAY:
		case DATA_TYPE_STRING_ARRAY:
		case DATA_TYPE_NVLIST_ARRAY:
			val = va_arg(ap, void *);
			nelem = va_arg(ap, uint_t *);
			ret = nvlist_lookup_common(nvl, name, type, nelem, val);
			break;

		default:
			ret = EINVAL;
		}

		if (ret == ENOENT && noentok)
			ret = 0;
	}
	va_end(ap);

	return (ret);
}

/*
 * Find the 'name'ed nvpair in the nvlist 'nvl'. If 'name' found, the function
 * returns zero and a pointer to the matching nvpair is returned in '*ret'
 * (given 'ret' is non-NULL). If 'sep' is specified then 'name' will penitrate
 * multiple levels of embedded nvlists, with 'sep' as the separator. As an
 * example, if sep is '.', name might look like: "a" or "a.b" or "a.c[3]" or
 * "a.d[3].e[1]".  This matches the C syntax for array embed (for convience,
 * code also supports "a.d[3]e[1]" syntax).
 *
 * If 'ip' is non-NULL and the last name component is an array, return the
 * value of the "...[index]" array index in *ip. For an array reference that
 * is not indexed, *ip will be returned as -1. If there is a syntax error in
 * 'name', and 'ep' is non-NULL then *ep will be set to point to the location
 * inside the 'name' string where the syntax error was detected.
 */
static int
nvlist_lookup_nvpair_ei_sep(nvlist_t *nvl, const char *name, const char sep,
    nvpair_t **ret, int *ip, char **ep)
{
	nvpair_t	*nvp;
	const char	*np;
	char		*sepp = NULL;
	char		*idxp, *idxep;
	nvlist_t	**nva;
	long		idx = 0;
	int		n;

	if (ip)
		*ip = -1;			/* not indexed */
	if (ep)
		*ep = NULL;

	if ((nvl == NULL) || (name == NULL))
		return (EINVAL);

	/* step through components of name */
	for (np = name; np && *np; np = sepp) {
		/* ensure unique names */
		if (!(nvl->nvl_nvflag & NV_UNIQUE_NAME))
			return (ENOTSUP);

		/* skip white space */
		skip_whitespace(np);
		if (*np == 0)
			break;

		/* set 'sepp' to end of current component 'np' */
		if (sep)
			sepp = strchr(np, sep);
		else
			sepp = NULL;

		/* find start of next "[ index ]..." */
		idxp = strchr(np, '[');

		/* if sepp comes first, set idxp to NULL */
		if (sepp && idxp && (sepp < idxp))
			idxp = NULL;

		/*
		 * At this point 'idxp' is set if there is an index
		 * expected for the current component.
		 */
		if (idxp) {
			/* set 'n' to length of current 'np' name component */
			n = idxp++ - np;

			/* keep sepp up to date for *ep use as we advance */
			skip_whitespace(idxp);
			sepp = idxp;

			/* determine the index value */
#if defined(_KERNEL) && !defined(_BOOT)
			if (ddi_strtol(idxp, &idxep, 0, &idx))
				goto fail;
#else
			idx = strtol(idxp, &idxep, 0);
#endif
			if (idxep == idxp)
				goto fail;

			/* keep sepp up to date for *ep use as we advance */
			sepp = idxep;

			/* skip white space index value and check for ']' */
			skip_whitespace(sepp);
			if (*sepp++ != ']')
				goto fail;

			/* for embedded arrays, support C syntax: "a[1].b" */
			skip_whitespace(sepp);
			if (sep && (*sepp == sep))
				sepp++;
		} else if (sepp) {
			n = sepp++ - np;
		} else {
			n = strlen(np);
		}

		/* trim trailing whitespace by reducing length of 'np' */
		if (n == 0)
			goto fail;
		for (n--; (np[n] == ' ') || (np[n] == '\t'); n--)
			;
		n++;

		/* skip whitespace, and set sepp to NULL if complete */
		if (sepp) {
			skip_whitespace(sepp);
			if (*sepp == 0)
				sepp = NULL;
		}

		/*
		 * At this point:
		 * o  'n' is the length of current 'np' component.
		 * o  'idxp' is set if there was an index, and value 'idx'.
		 * o  'sepp' is set to the beginning of the next component,
		 *    and set to NULL if we have no more components.
		 *
		 * Search for nvpair with matching component name.
		 */
		for (nvp = nvlist_next_nvpair(nvl, NULL); nvp != NULL;
		    nvp = nvlist_next_nvpair(nvl, nvp)) {

			/* continue if no match on name */
			if (strncmp(np, nvpair_name(nvp), n) ||
			    (strlen(nvpair_name(nvp)) != n))
				continue;

			/* if indexed, verify type is array oriented */
			if (idxp && !nvpair_type_is_array(nvp))
				goto fail;

			/*
			 * Full match found, return nvp and idx if this
			 * was the last component.
			 */
			if (sepp == NULL) {
				if (ret)
					*ret = nvp;
				if (ip && idxp)
					*ip = (int)idx;	/* return index */
				return (0);		/* found */
			}

			/*
			 * More components: current match must be
			 * of DATA_TYPE_NVLIST or DATA_TYPE_NVLIST_ARRAY
			 * to support going deeper.
			 */
			if (nvpair_type(nvp) == DATA_TYPE_NVLIST) {
				nvl = EMBEDDED_NVL(nvp);
				break;
			} else if (nvpair_type(nvp) == DATA_TYPE_NVLIST_ARRAY) {
				(void) nvpair_value_nvlist_array(nvp,
				    &nva, (uint_t *)&n);
				if ((n < 0) || (idx >= n))
					goto fail;
				nvl = nva[idx];
				break;
			}

			/* type does not support more levels */
			goto fail;
		}
		if (nvp == NULL)
			goto fail;		/* 'name' not found */

		/* search for match of next component in embedded 'nvl' list */
	}

fail:	if (ep && sepp)
		*ep = sepp;
	return (EINVAL);
}

/*
 * Return pointer to nvpair with specified 'name'.
 */
int
nvlist_lookup_nvpair(nvlist_t *nvl, const char *name, nvpair_t **ret)
{
	return (nvlist_lookup_nvpair_ei_sep(nvl, name, 0, ret, NULL, NULL));
}

/*
 * Determine if named nvpair exists in nvlist (use embedded separator of '.'
 * and return array index).  See nvlist_lookup_nvpair_ei_sep for more detailed
 * description.
 */
int nvlist_lookup_nvpair_embedded_index(nvlist_t *nvl,
    const char *name, nvpair_t **ret, int *ip, char **ep)
{
	return (nvlist_lookup_nvpair_ei_sep(nvl, name, '.', ret, ip, ep));
}

boolean_t
nvlist_exists(nvlist_t *nvl, const char *name)
{
	nvpriv_t *priv;
	nvpair_t *nvp;
	i_nvp_t *curr;

	if (name == NULL || nvl == NULL ||
	    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)
		return (B_FALSE);

	for (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next) {
		nvp = &curr->nvi_nvp;

		if (strcmp(name, NVP_NAME(nvp)) == 0)
			return (B_TRUE);
	}

	return (B_FALSE);
}

int
nvpair_value_boolean_value(nvpair_t *nvp, boolean_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_BOOLEAN_VALUE, NULL, val));
}

int
nvpair_value_byte(nvpair_t *nvp, uchar_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_BYTE, NULL, val));
}

int
nvpair_value_int8(nvpair_t *nvp, int8_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_INT8, NULL, val));
}

int
nvpair_value_uint8(nvpair_t *nvp, uint8_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_UINT8, NULL, val));
}

int
nvpair_value_int16(nvpair_t *nvp, int16_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_INT16, NULL, val));
}

int
nvpair_value_uint16(nvpair_t *nvp, uint16_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_UINT16, NULL, val));
}

int
nvpair_value_int32(nvpair_t *nvp, int32_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_INT32, NULL, val));
}

int
nvpair_value_uint32(nvpair_t *nvp, uint32_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_UINT32, NULL, val));
}

int
nvpair_value_int64(nvpair_t *nvp, int64_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_INT64, NULL, val));
}

int
nvpair_value_uint64(nvpair_t *nvp, uint64_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_UINT64, NULL, val));
}

#if !defined(_KERNEL)
int
nvpair_value_double(nvpair_t *nvp, double *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_DOUBLE, NULL, val));
}
#endif

int
nvpair_value_string(nvpair_t *nvp, char **val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_STRING, NULL, val));
}

int
nvpair_value_nvlist(nvpair_t *nvp, nvlist_t **val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_NVLIST, NULL, val));
}

int
nvpair_value_boolean_array(nvpair_t *nvp, boolean_t **val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_BOOLEAN_ARRAY, nelem, val));
}

int
nvpair_value_byte_array(nvpair_t *nvp, uchar_t **val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_BYTE_ARRAY, nelem, val));
}

int
nvpair_value_int8_array(nvpair_t *nvp, int8_t **val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_INT8_ARRAY, nelem, val));
}

int
nvpair_value_uint8_array(nvpair_t *nvp, uint8_t **val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_UINT8_ARRAY, nelem, val));
}

int
nvpair_value_int16_array(nvpair_t *nvp, int16_t **val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_INT16_ARRAY, nelem, val));
}

int
nvpair_value_uint16_array(nvpair_t *nvp, uint16_t **val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_UINT16_ARRAY, nelem, val));
}

int
nvpair_value_int32_array(nvpair_t *nvp, int32_t **val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_INT32_ARRAY, nelem, val));
}

int
nvpair_value_uint32_array(nvpair_t *nvp, uint32_t **val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_UINT32_ARRAY, nelem, val));
}

int
nvpair_value_int64_array(nvpair_t *nvp, int64_t **val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_INT64_ARRAY, nelem, val));
}

int
nvpair_value_uint64_array(nvpair_t *nvp, uint64_t **val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_UINT64_ARRAY, nelem, val));
}

int
nvpair_value_string_array(nvpair_t *nvp, char ***val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_STRING_ARRAY, nelem, val));
}

int
nvpair_value_nvlist_array(nvpair_t *nvp, nvlist_t ***val, uint_t *nelem)
{
	return (nvpair_value_common(nvp, DATA_TYPE_NVLIST_ARRAY, nelem, val));
}

int
nvpair_value_hrtime(nvpair_t *nvp, hrtime_t *val)
{
	return (nvpair_value_common(nvp, DATA_TYPE_HRTIME, NULL, val));
}

/*
 * Add specified pair to the list.
 */
int
nvlist_add_nvpair(nvlist_t *nvl, nvpair_t *nvp)
{
	if (nvl == NULL || nvp == NULL)
		return (EINVAL);

	return (nvlist_add_common(nvl, NVP_NAME(nvp), NVP_TYPE(nvp),
	    NVP_NELEM(nvp), NVP_VALUE(nvp)));
}

/*
 * Merge the supplied nvlists and put the result in dst.
 * The merged list will contain all names specified in both lists,
 * the values are taken from nvl in the case of duplicates.
 * Return 0 on success.
 */
/*ARGSUSED*/
int
nvlist_merge(nvlist_t *dst, nvlist_t *nvl, int flag)
{
	if (nvl == NULL || dst == NULL)
		return (EINVAL);

	if (dst != nvl)
		return (nvlist_copy_pairs(nvl, dst));

	return (0);
}

/*
 * Encoding related routines
 */
#define	NVS_OP_ENCODE	0
#define	NVS_OP_DECODE	1
#define	NVS_OP_GETSIZE	2

typedef struct nvs_ops nvs_ops_t;

typedef struct {
	int		nvs_op;
	const nvs_ops_t	*nvs_ops;
	void		*nvs_private;
	nvpriv_t	*nvs_priv;
	int		nvs_recursion;
} nvstream_t;

/*
 * nvs operations are:
 *   - nvs_nvlist
 *     encoding / decoding of a nvlist header (nvlist_t)
 *     calculates the size used for header and end detection
 *
 *   - nvs_nvpair
 *     responsible for the first part of encoding / decoding of an nvpair
 *     calculates the decoded size of an nvpair
 *
 *   - nvs_nvp_op
 *     second part of encoding / decoding of an nvpair
 *
 *   - nvs_nvp_size
 *     calculates the encoding size of an nvpair
 *
 *   - nvs_nvl_fini
 *     encodes the end detection mark (zeros).
 */
struct nvs_ops {
	int (*nvs_nvlist)(nvstream_t *, nvlist_t *, size_t *);
	int (*nvs_nvpair)(nvstream_t *, nvpair_t *, size_t *);
	int (*nvs_nvp_op)(nvstream_t *, nvpair_t *);
	int (*nvs_nvp_size)(nvstream_t *, nvpair_t *, size_t *);
	int (*nvs_nvl_fini)(nvstream_t *);
};

typedef struct {
	char	nvh_encoding;	/* nvs encoding method */
	char	nvh_endian;	/* nvs endian */
	char	nvh_reserved1;	/* reserved for future use */
	char	nvh_reserved2;	/* reserved for future use */
} nvs_header_t;

static int
nvs_encode_pairs(nvstream_t *nvs, nvlist_t *nvl)
{
	nvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;
	i_nvp_t *curr;

	/*
	 * Walk nvpair in list and encode each nvpair
	 */
	for (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next)
		if (nvs->nvs_ops->nvs_nvpair(nvs, &curr->nvi_nvp, NULL) != 0)
			return (EFAULT);

	return (nvs->nvs_ops->nvs_nvl_fini(nvs));
}

static int
nvs_decode_pairs(nvstream_t *nvs, nvlist_t *nvl)
{
	nvpair_t *nvp;
	size_t nvsize;
	int err;

	/*
	 * Get decoded size of next pair in stream, alloc
	 * memory for nvpair_t, then decode the nvpair
	 */
	while ((err = nvs->nvs_ops->nvs_nvpair(nvs, NULL, &nvsize)) == 0) {
		if (nvsize == 0) /* end of list */
			break;

		/* make sure len makes sense */
		if (nvsize < NVP_SIZE_CALC(1, 0))
			return (EFAULT);

		if ((nvp = nvp_buf_alloc(nvl, nvsize)) == NULL)
			return (ENOMEM);

		if ((err = nvs->nvs_ops->nvs_nvp_op(nvs, nvp)) != 0) {
			nvp_buf_free(nvl, nvp);
			return (err);
		}

		if (i_validate_nvpair(nvp) != 0) {
			nvpair_free(nvp);
			nvp_buf_free(nvl, nvp);
			return (EFAULT);
		}

		nvp_buf_link(nvl, nvp);
	}
	return (err);
}

static int
nvs_getsize_pairs(nvstream_t *nvs, nvlist_t *nvl, size_t *buflen)
{
	nvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;
	i_nvp_t *curr;
	uint64_t nvsize = *buflen;
	size_t size;

	/*
	 * Get encoded size of nvpairs in nvlist
	 */
	for (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next) {
		if (nvs->nvs_ops->nvs_nvp_size(nvs, &curr->nvi_nvp, &size) != 0)
			return (EINVAL);

		if ((nvsize += size) > INT32_MAX)
			return (EINVAL);
	}

	*buflen = nvsize;
	return (0);
}

static int
nvs_operation(nvstream_t *nvs, nvlist_t *nvl, size_t *buflen)
{
	int err;

	if (nvl->nvl_priv == 0)
		return (EFAULT);

	/*
	 * Perform the operation, starting with header, then each nvpair
	 */
	if ((err = nvs->nvs_ops->nvs_nvlist(nvs, nvl, buflen)) != 0)
		return (err);

	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE:
		err = nvs_encode_pairs(nvs, nvl);
		break;

	case NVS_OP_DECODE:
		err = nvs_decode_pairs(nvs, nvl);
		break;

	case NVS_OP_GETSIZE:
		err = nvs_getsize_pairs(nvs, nvl, buflen);
		break;

	default:
		err = EINVAL;
	}

	return (err);
}

static int
nvs_embedded(nvstream_t *nvs, nvlist_t *embedded)
{
	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE: {
		int err;

		if (nvs->nvs_recursion >= nvpair_max_recursion)
			return (EINVAL);
		nvs->nvs_recursion++;
		err = nvs_operation(nvs, embedded, NULL);
		nvs->nvs_recursion--;
		return (err);
	}
	case NVS_OP_DECODE: {
		nvpriv_t *priv;
		int err;

		if (embedded->nvl_version != NV_VERSION)
			return (ENOTSUP);

		if ((priv = nv_priv_alloc_embedded(nvs->nvs_priv)) == NULL)
			return (ENOMEM);

		nvlist_init(embedded, embedded->nvl_nvflag, priv);

		if (nvs->nvs_recursion >= nvpair_max_recursion)
			return (EINVAL);
		nvs->nvs_recursion++;
		if ((err = nvs_operation(nvs, embedded, NULL)) != 0)
			nvlist_free(embedded);
		nvs->nvs_recursion--;
		return (err);
	}
	default:
		break;
	}

	return (EINVAL);
}

static int
nvs_embedded_nvl_array(nvstream_t *nvs, nvpair_t *nvp, size_t *size)
{
	size_t nelem = NVP_NELEM(nvp);
	nvlist_t **nvlp = EMBEDDED_NVL_ARRAY(nvp);
	int i;

	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE:
		for (i = 0; i < nelem; i++)
			if (nvs_embedded(nvs, nvlp[i]) != 0)
				return (EFAULT);
		break;

	case NVS_OP_DECODE: {
		size_t len = nelem * sizeof (uint64_t);
		nvlist_t *embedded = (nvlist_t *)((uintptr_t)nvlp + len);

		bzero(nvlp, len);	/* don't trust packed data */
		for (i = 0; i < nelem; i++) {
			if (nvs_embedded(nvs, embedded) != 0) {
				nvpair_free(nvp);
				return (EFAULT);
			}

			nvlp[i] = embedded++;
		}
		break;
	}
	case NVS_OP_GETSIZE: {
		uint64_t nvsize = 0;

		for (i = 0; i < nelem; i++) {
			size_t nvp_sz = 0;

			if (nvs_operation(nvs, nvlp[i], &nvp_sz) != 0)
				return (EINVAL);

			if ((nvsize += nvp_sz) > INT32_MAX)
				return (EINVAL);
		}

		*size = nvsize;
		break;
	}
	default:
		return (EINVAL);
	}

	return (0);
}

static int nvs_native(nvstream_t *, nvlist_t *, char *, size_t *);
static int nvs_xdr(nvstream_t *, nvlist_t *, char *, size_t *);

/*
 * Common routine for nvlist operations:
 * encode, decode, getsize (encoded size).
 */
static int
nvlist_common(nvlist_t *nvl, char *buf, size_t *buflen, int encoding,
    int nvs_op)
{
	int err = 0;
	nvstream_t nvs;
	int nvl_endian;
#ifdef	_LITTLE_ENDIAN
	int host_endian = 1;
#else
	int host_endian = 0;
#endif	/* _LITTLE_ENDIAN */
	nvs_header_t *nvh = (void *)buf;

	if (buflen == NULL || nvl == NULL ||
	    (nvs.nvs_priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)
		return (EINVAL);

	nvs.nvs_op = nvs_op;
	nvs.nvs_recursion = 0;

	/*
	 * For NVS_OP_ENCODE and NVS_OP_DECODE make sure an nvlist and
	 * a buffer is allocated.  The first 4 bytes in the buffer are
	 * used for encoding method and host endian.
	 */
	switch (nvs_op) {
	case NVS_OP_ENCODE:
		if (buf == NULL || *buflen < sizeof (nvs_header_t))
			return (EINVAL);

		nvh->nvh_encoding = encoding;
		nvh->nvh_endian = nvl_endian = host_endian;
		nvh->nvh_reserved1 = 0;
		nvh->nvh_reserved2 = 0;
		break;

	case NVS_OP_DECODE:
		if (buf == NULL || *buflen < sizeof (nvs_header_t))
			return (EINVAL);

		/* get method of encoding from first byte */
		encoding = nvh->nvh_encoding;
		nvl_endian = nvh->nvh_endian;
		break;

	case NVS_OP_GETSIZE:
		nvl_endian = host_endian;

		/*
		 * add the size for encoding
		 */
		*buflen = sizeof (nvs_header_t);
		break;

	default:
		return (ENOTSUP);
	}

	/*
	 * Create an nvstream with proper encoding method
	 */
	switch (encoding) {
	case NV_ENCODE_NATIVE:
		/*
		 * check endianness, in case we are unpacking
		 * from a file
		 */
		if (nvl_endian != host_endian)
			return (ENOTSUP);
		err = nvs_native(&nvs, nvl, buf, buflen);
		break;
	case NV_ENCODE_XDR:
		err = nvs_xdr(&nvs, nvl, buf, buflen);
		break;
	default:
		err = ENOTSUP;
		break;
	}

	return (err);
}

int
nvlist_size(nvlist_t *nvl, size_t *size, int encoding)
{
	return (nvlist_common(nvl, NULL, size, encoding, NVS_OP_GETSIZE));
}

/*
 * Pack nvlist into contiguous memory
 */
int
nvlist_pack(nvlist_t *nvl, char **bufp, size_t *buflen, int encoding,
    int kmflag)
{
	return (nvlist_xpack(nvl, bufp, buflen, encoding,
	    nvlist_nv_alloc(kmflag)));
}

int
nvlist_xpack(nvlist_t *nvl, char **bufp, size_t *buflen, int encoding,
    nv_alloc_t *nva)
{
	nvpriv_t nvpriv;
	size_t alloc_size;
	char *buf;
	int err;

	if (nva == NULL || nvl == NULL || bufp == NULL || buflen == NULL)
		return (EINVAL);

	if (*bufp != NULL)
		return (nvlist_common(nvl, *bufp, buflen, encoding,
		    NVS_OP_ENCODE));

	/*
	 * Here is a difficult situation:
	 * 1. The nvlist has fixed allocator properties.
	 *    All other nvlist routines (like nvlist_add_*, ...) use
	 *    these properties.
	 * 2. When using nvlist_pack() the user can specify his own
	 *    allocator properties (e.g. by using KM_NOSLEEP).
	 *
	 * We use the user specified properties (2). A clearer solution
	 * will be to remove the kmflag from nvlist_pack(), but we will
	 * not change the interface.
	 */
	nv_priv_init(&nvpriv, nva, 0);

	if ((err = nvlist_size(nvl, &alloc_size, encoding)))
		return (err);

	if ((buf = nv_mem_zalloc(&nvpriv, alloc_size)) == NULL)
		return (ENOMEM);

	if ((err = nvlist_common(nvl, buf, &alloc_size, encoding,
	    NVS_OP_ENCODE)) != 0) {
		nv_mem_free(&nvpriv, buf, alloc_size);
	} else {
		*buflen = alloc_size;
		*bufp = buf;
	}

	return (err);
}

/*
 * Unpack buf into an nvlist_t
 */
int
nvlist_unpack(char *buf, size_t buflen, nvlist_t **nvlp, int kmflag)
{
	return (nvlist_xunpack(buf, buflen, nvlp, nvlist_nv_alloc(kmflag)));
}

int
nvlist_xunpack(char *buf, size_t buflen, nvlist_t **nvlp, nv_alloc_t *nva)
{
	nvlist_t *nvl;
	int err;

	if (nvlp == NULL)
		return (EINVAL);

	if ((err = nvlist_xalloc(&nvl, 0, nva)) != 0)
		return (err);

	if ((err = nvlist_common(nvl, buf, &buflen, 0, NVS_OP_DECODE)) != 0)
		nvlist_free(nvl);
	else
		*nvlp = nvl;

	return (err);
}

/*
 * Native encoding functions
 */
typedef struct {
	/*
	 * This structure is used when decoding a packed nvpair in
	 * the native format.  n_base points to a buffer containing the
	 * packed nvpair.  n_end is a pointer to the end of the buffer.
	 * (n_end actually points to the first byte past the end of the
	 * buffer.)  n_curr is a pointer that lies between n_base and n_end.
	 * It points to the current data that we are decoding.
	 * The amount of data left in the buffer is equal to n_end - n_curr.
	 * n_flag is used to recognize a packed embedded list.
	 */
	caddr_t n_base;
	caddr_t n_end;
	caddr_t n_curr;
	uint_t  n_flag;
} nvs_native_t;

static int
nvs_native_create(nvstream_t *nvs, nvs_native_t *native, char *buf,
    size_t buflen)
{
	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE:
	case NVS_OP_DECODE:
		nvs->nvs_private = native;
		native->n_curr = native->n_base = buf;
		native->n_end = buf + buflen;
		native->n_flag = 0;
		return (0);

	case NVS_OP_GETSIZE:
		nvs->nvs_private = native;
		native->n_curr = native->n_base = native->n_end = NULL;
		native->n_flag = 0;
		return (0);
	default:
		return (EINVAL);
	}
}

/*ARGSUSED*/
static void
nvs_native_destroy(nvstream_t *nvs)
{
}

static int
native_cp(nvstream_t *nvs, void *buf, size_t size)
{
	nvs_native_t *native = (nvs_native_t *)nvs->nvs_private;

	if (native->n_curr + size > native->n_end)
		return (EFAULT);

	/*
	 * The bcopy() below eliminates alignment requirement
	 * on the buffer (stream) and is preferred over direct access.
	 */
	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE:
		bcopy(buf, native->n_curr, size);
		break;
	case NVS_OP_DECODE:
		bcopy(native->n_curr, buf, size);
		break;
	default:
		return (EINVAL);
	}

	native->n_curr += size;
	return (0);
}

/*
 * operate on nvlist_t header
 */
static int
nvs_native_nvlist(nvstream_t *nvs, nvlist_t *nvl, size_t *size)
{
	nvs_native_t *native = nvs->nvs_private;

	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE:
	case NVS_OP_DECODE:
		if (native->n_flag)
			return (0);	/* packed embedded list */

		native->n_flag = 1;

		/* copy version and nvflag of the nvlist_t */
		if (native_cp(nvs, &nvl->nvl_version, sizeof (int32_t)) != 0 ||
		    native_cp(nvs, &nvl->nvl_nvflag, sizeof (int32_t)) != 0)
			return (EFAULT);

		return (0);

	case NVS_OP_GETSIZE:
		/*
		 * if calculate for packed embedded list
		 * 	4 for end of the embedded list
		 * else
		 * 	2 * sizeof (int32_t) for nvl_version and nvl_nvflag
		 * 	and 4 for end of the entire list
		 */
		if (native->n_flag) {
			*size += 4;
		} else {
			native->n_flag = 1;
			*size += 2 * sizeof (int32_t) + 4;
		}

		return (0);

	default:
		return (EINVAL);
	}
}

static int
nvs_native_nvl_fini(nvstream_t *nvs)
{
	if (nvs->nvs_op == NVS_OP_ENCODE) {
		nvs_native_t *native = (nvs_native_t *)nvs->nvs_private;
		/*
		 * Add 4 zero bytes at end of nvlist. They are used
		 * for end detection by the decode routine.
		 */
		if (native->n_curr + sizeof (int) > native->n_end)
			return (EFAULT);

		bzero(native->n_curr, sizeof (int));
		native->n_curr += sizeof (int);
	}

	return (0);
}

static int
nvpair_native_embedded(nvstream_t *nvs, nvpair_t *nvp)
{
	if (nvs->nvs_op == NVS_OP_ENCODE) {
		nvs_native_t *native = (nvs_native_t *)nvs->nvs_private;
		nvlist_t *packed = (void *)
		    (native->n_curr - nvp->nvp_size + NVP_VALOFF(nvp));
		/*
		 * Null out the pointer that is meaningless in the packed
		 * structure. The address may not be aligned, so we have
		 * to use bzero.
		 */
		bzero((char *)packed + offsetof(nvlist_t, nvl_priv),
		    sizeof (uint64_t));
	}

	return (nvs_embedded(nvs, EMBEDDED_NVL(nvp)));
}

static int
nvpair_native_embedded_array(nvstream_t *nvs, nvpair_t *nvp)
{
	if (nvs->nvs_op == NVS_OP_ENCODE) {
		nvs_native_t *native = (nvs_native_t *)nvs->nvs_private;
		char *value = native->n_curr - nvp->nvp_size + NVP_VALOFF(nvp);
		size_t len = NVP_NELEM(nvp) * sizeof (uint64_t);
		nvlist_t *packed = (nvlist_t *)((uintptr_t)value + len);
		int i;
		/*
		 * Null out pointers that are meaningless in the packed
		 * structure. The addresses may not be aligned, so we have
		 * to use bzero.
		 */
		bzero(value, len);

		for (i = 0; i < NVP_NELEM(nvp); i++, packed++)
			/*
			 * Null out the pointer that is meaningless in the
			 * packed structure. The address may not be aligned,
			 * so we have to use bzero.
			 */
			bzero((char *)packed + offsetof(nvlist_t, nvl_priv),
			    sizeof (uint64_t));
	}

	return (nvs_embedded_nvl_array(nvs, nvp, NULL));
}

static void
nvpair_native_string_array(nvstream_t *nvs, nvpair_t *nvp)
{
	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE: {
		nvs_native_t *native = (nvs_native_t *)nvs->nvs_private;
		uint64_t *strp = (void *)
		    (native->n_curr - nvp->nvp_size + NVP_VALOFF(nvp));
		/*
		 * Null out pointers that are meaningless in the packed
		 * structure. The addresses may not be aligned, so we have
		 * to use bzero.
		 */
		bzero(strp, NVP_NELEM(nvp) * sizeof (uint64_t));
		break;
	}
	case NVS_OP_DECODE: {
		char **strp = (void *)NVP_VALUE(nvp);
		char *buf = ((char *)strp + NVP_NELEM(nvp) * sizeof (uint64_t));
		int i;

		for (i = 0; i < NVP_NELEM(nvp); i++) {
			strp[i] = buf;
			buf += strlen(buf) + 1;
		}
		break;
	}
	}
}

static int
nvs_native_nvp_op(nvstream_t *nvs, nvpair_t *nvp)
{
	data_type_t type;
	int value_sz;
	int ret = 0;

	/*
	 * We do the initial bcopy of the data before we look at
	 * the nvpair type, because when we're decoding, we won't
	 * have the correct values for the pair until we do the bcopy.
	 */
	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE:
	case NVS_OP_DECODE:
		if (native_cp(nvs, nvp, nvp->nvp_size) != 0)
			return (EFAULT);
		break;
	default:
		return (EINVAL);
	}

	/* verify nvp_name_sz, check the name string length */
	if (i_validate_nvpair_name(nvp) != 0)
		return (EFAULT);

	type = NVP_TYPE(nvp);

	/*
	 * Verify type and nelem and get the value size.
	 * In case of data types DATA_TYPE_STRING and DATA_TYPE_STRING_ARRAY
	 * is the size of the string(s) excluded.
	 */
	if ((value_sz = i_get_value_size(type, NULL, NVP_NELEM(nvp))) < 0)
		return (EFAULT);

	if (NVP_SIZE_CALC(nvp->nvp_name_sz, value_sz) > nvp->nvp_size)
		return (EFAULT);

	switch (type) {
	case DATA_TYPE_NVLIST:
		ret = nvpair_native_embedded(nvs, nvp);
		break;
	case DATA_TYPE_NVLIST_ARRAY:
		ret = nvpair_native_embedded_array(nvs, nvp);
		break;
	case DATA_TYPE_STRING_ARRAY:
		nvpair_native_string_array(nvs, nvp);
		break;
	default:
		break;
	}

	return (ret);
}

static int
nvs_native_nvp_size(nvstream_t *nvs, nvpair_t *nvp, size_t *size)
{
	uint64_t nvp_sz = nvp->nvp_size;

	switch (NVP_TYPE(nvp)) {
	case DATA_TYPE_NVLIST: {
		size_t nvsize = 0;

		if (nvs_operation(nvs, EMBEDDED_NVL(nvp), &nvsize) != 0)
			return (EINVAL);

		nvp_sz += nvsize;
		break;
	}
	case DATA_TYPE_NVLIST_ARRAY: {
		size_t nvsize;

		if (nvs_embedded_nvl_array(nvs, nvp, &nvsize) != 0)
			return (EINVAL);

		nvp_sz += nvsize;
		break;
	}
	default:
		break;
	}

	if (nvp_sz > INT32_MAX)
		return (EINVAL);

	*size = nvp_sz;

	return (0);
}

static int
nvs_native_nvpair(nvstream_t *nvs, nvpair_t *nvp, size_t *size)
{
	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE:
		return (nvs_native_nvp_op(nvs, nvp));

	case NVS_OP_DECODE: {
		nvs_native_t *native = (nvs_native_t *)nvs->nvs_private;
		int32_t decode_len;

		/* try to read the size value from the stream */
		if (native->n_curr + sizeof (int32_t) > native->n_end)
			return (EFAULT);
		bcopy(native->n_curr, &decode_len, sizeof (int32_t));

		/* sanity check the size value */
		if (decode_len < 0 ||
		    decode_len > native->n_end - native->n_curr)
			return (EFAULT);

		*size = decode_len;

		/*
		 * If at the end of the stream then move the cursor
		 * forward, otherwise nvpair_native_op() will read
		 * the entire nvpair at the same cursor position.
		 */
		if (*size == 0)
			native->n_curr += sizeof (int32_t);
		break;
	}

	default:
		return (EINVAL);
	}

	return (0);
}

static const nvs_ops_t nvs_native_ops = {
	nvs_native_nvlist,
	nvs_native_nvpair,
	nvs_native_nvp_op,
	nvs_native_nvp_size,
	nvs_native_nvl_fini
};

static int
nvs_native(nvstream_t *nvs, nvlist_t *nvl, char *buf, size_t *buflen)
{
	nvs_native_t native;
	int err;

	nvs->nvs_ops = &nvs_native_ops;

	if ((err = nvs_native_create(nvs, &native, buf + sizeof (nvs_header_t),
	    *buflen - sizeof (nvs_header_t))) != 0)
		return (err);

	err = nvs_operation(nvs, nvl, buflen);

	nvs_native_destroy(nvs);

	return (err);
}

/*
 * XDR encoding functions
 *
 * An xdr packed nvlist is encoded as:
 *
 *  - encoding methode and host endian (4 bytes)
 *  - nvl_version (4 bytes)
 *  - nvl_nvflag (4 bytes)
 *
 *  - encoded nvpairs, the format of one xdr encoded nvpair is:
 *	- encoded size of the nvpair (4 bytes)
 *	- decoded size of the nvpair (4 bytes)
 *	- name string, (4 + sizeof(NV_ALIGN4(string))
 *	  a string is coded as size (4 bytes) and data
 *	- data type (4 bytes)
 *	- number of elements in the nvpair (4 bytes)
 *	- data
 *
 *  - 2 zero's for end of the entire list (8 bytes)
 */
static int
nvs_xdr_create(nvstream_t *nvs, XDR *xdr, char *buf, size_t buflen)
{
	/* xdr data must be 4 byte aligned */
	if ((ulong_t)buf % 4 != 0)
		return (EFAULT);

	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE:
		xdrmem_create(xdr, buf, (uint_t)buflen, XDR_ENCODE);
		nvs->nvs_private = xdr;
		return (0);
	case NVS_OP_DECODE:
		xdrmem_create(xdr, buf, (uint_t)buflen, XDR_DECODE);
		nvs->nvs_private = xdr;
		return (0);
	case NVS_OP_GETSIZE:
		nvs->nvs_private = NULL;
		return (0);
	default:
		return (EINVAL);
	}
}

static void
nvs_xdr_destroy(nvstream_t *nvs)
{
	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE:
	case NVS_OP_DECODE:
		xdr_destroy((XDR *)nvs->nvs_private);
		break;
	default:
		break;
	}
}

static int
nvs_xdr_nvlist(nvstream_t *nvs, nvlist_t *nvl, size_t *size)
{
	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE:
	case NVS_OP_DECODE: {
		XDR 	*xdr = nvs->nvs_private;

		if (!xdr_int(xdr, &nvl->nvl_version) ||
		    !xdr_u_int(xdr, &nvl->nvl_nvflag))
			return (EFAULT);
		break;
	}
	case NVS_OP_GETSIZE: {
		/*
		 * 2 * 4 for nvl_version + nvl_nvflag
		 * and 8 for end of the entire list
		 */
		*size += 2 * 4 + 8;
		break;
	}
	default:
		return (EINVAL);
	}
	return (0);
}

static int
nvs_xdr_nvl_fini(nvstream_t *nvs)
{
	if (nvs->nvs_op == NVS_OP_ENCODE) {
		XDR *xdr = nvs->nvs_private;
		int zero = 0;

		if (!xdr_int(xdr, &zero) || !xdr_int(xdr, &zero))
			return (EFAULT);
	}

	return (0);
}

/*
 * The format of xdr encoded nvpair is:
 * encode_size, decode_size, name string, data type, nelem, data
 */
static int
nvs_xdr_nvp_op(nvstream_t *nvs, nvpair_t *nvp)
{
	data_type_t type;
	char	*buf;
	char	*buf_end = (char *)nvp + nvp->nvp_size;
	int	value_sz;
	uint_t	nelem, buflen;
	bool_t	ret = FALSE;
	XDR	*xdr = nvs->nvs_private;

	ASSERT(xdr != NULL && nvp != NULL);

	/* name string */
	if ((buf = NVP_NAME(nvp)) >= buf_end)
		return (EFAULT);
	buflen = buf_end - buf;

	if (!xdr_string(xdr, &buf, buflen - 1))
		return (EFAULT);
	nvp->nvp_name_sz = strlen(buf) + 1;

	/* type and nelem */
	if (!xdr_int(xdr, (int *)&nvp->nvp_type) ||
	    !xdr_int(xdr, &nvp->nvp_value_elem))
		return (EFAULT);

	type = NVP_TYPE(nvp);
	nelem = nvp->nvp_value_elem;

	/*
	 * Verify type and nelem and get the value size.
	 * In case of data types DATA_TYPE_STRING and DATA_TYPE_STRING_ARRAY
	 * is the size of the string(s) excluded.
	 */
	if ((value_sz = i_get_value_size(type, NULL, nelem)) < 0)
		return (EFAULT);

	/* if there is no data to extract then return */
	if (nelem == 0)
		return (0);

	/* value */
	if ((buf = NVP_VALUE(nvp)) >= buf_end)
		return (EFAULT);
	buflen = buf_end - buf;

	if (buflen < value_sz)
		return (EFAULT);

	switch (type) {
	case DATA_TYPE_NVLIST:
		if (nvs_embedded(nvs, (void *)buf) == 0)
			return (0);
		break;

	case DATA_TYPE_NVLIST_ARRAY:
		if (nvs_embedded_nvl_array(nvs, nvp, NULL) == 0)
			return (0);
		break;

	case DATA_TYPE_BOOLEAN:
		ret = TRUE;
		break;

	case DATA_TYPE_BYTE:
	case DATA_TYPE_INT8:
	case DATA_TYPE_UINT8:
		ret = xdr_char(xdr, buf);
		break;

	case DATA_TYPE_INT16:
		ret = xdr_short(xdr, (void *)buf);
		break;

	case DATA_TYPE_UINT16:
		ret = xdr_u_short(xdr, (void *)buf);
		break;

	case DATA_TYPE_BOOLEAN_VALUE:
	case DATA_TYPE_INT32:
		ret = xdr_int(xdr, (void *)buf);
		break;

	case DATA_TYPE_UINT32:
		ret = xdr_u_int(xdr, (void *)buf);
		break;

	case DATA_TYPE_INT64:
		ret = xdr_longlong_t(xdr, (void *)buf);
		break;

	case DATA_TYPE_UINT64:
		ret = xdr_u_longlong_t(xdr, (void *)buf);
		break;

	case DATA_TYPE_HRTIME:
		/*
		 * NOTE: must expose the definition of hrtime_t here
		 */
		ret = xdr_longlong_t(xdr, (void *)buf);
		break;
#if !defined(_KERNEL)
	case DATA_TYPE_DOUBLE:
		ret = xdr_double(xdr, (void *)buf);
		break;
#endif
	case DATA_TYPE_STRING:
		ret = xdr_string(xdr, &buf, buflen - 1);
		break;

	case DATA_TYPE_BYTE_ARRAY:
		ret = xdr_opaque(xdr, buf, nelem);
		break;

	case DATA_TYPE_INT8_ARRAY:
	case DATA_TYPE_UINT8_ARRAY:
		ret = xdr_array(xdr, &buf, &nelem, buflen, sizeof (int8_t),
		    (xdrproc_t)xdr_char);
		break;

	case DATA_TYPE_INT16_ARRAY:
		ret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (int16_t),
		    sizeof (int16_t), (xdrproc_t)xdr_short);
		break;

	case DATA_TYPE_UINT16_ARRAY:
		ret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (uint16_t),
		    sizeof (uint16_t), (xdrproc_t)xdr_u_short);
		break;

	case DATA_TYPE_BOOLEAN_ARRAY:
	case DATA_TYPE_INT32_ARRAY:
		ret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (int32_t),
		    sizeof (int32_t), (xdrproc_t)xdr_int);
		break;

	case DATA_TYPE_UINT32_ARRAY:
		ret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (uint32_t),
		    sizeof (uint32_t), (xdrproc_t)xdr_u_int);
		break;

	case DATA_TYPE_INT64_ARRAY:
		ret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (int64_t),
		    sizeof (int64_t), (xdrproc_t)xdr_longlong_t);
		break;

	case DATA_TYPE_UINT64_ARRAY:
		ret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (uint64_t),
		    sizeof (uint64_t), (xdrproc_t)xdr_u_longlong_t);
		break;

	case DATA_TYPE_STRING_ARRAY: {
		size_t len = nelem * sizeof (uint64_t);
		char **strp = (void *)buf;
		int i;

		if (nvs->nvs_op == NVS_OP_DECODE)
			bzero(buf, len);	/* don't trust packed data */

		for (i = 0; i < nelem; i++) {
			if (buflen <= len)
				return (EFAULT);

			buf += len;
			buflen -= len;

			if (xdr_string(xdr, &buf, buflen - 1) != TRUE)
				return (EFAULT);

			if (nvs->nvs_op == NVS_OP_DECODE)
				strp[i] = buf;
			len = strlen(buf) + 1;
		}
		ret = TRUE;
		break;
	}
	default:
		break;
	}

	return (ret == TRUE ? 0 : EFAULT);
}

static int
nvs_xdr_nvp_size(nvstream_t *nvs, nvpair_t *nvp, size_t *size)
{
	data_type_t type = NVP_TYPE(nvp);
	/*
	 * encode_size + decode_size + name string size + data type + nelem
	 * where name string size = 4 + NV_ALIGN4(strlen(NVP_NAME(nvp)))
	 */
	uint64_t nvp_sz = 4 + 4 + 4 + NV_ALIGN4(strlen(NVP_NAME(nvp))) + 4 + 4;

	switch (type) {
	case DATA_TYPE_BOOLEAN:
		break;

	case DATA_TYPE_BOOLEAN_VALUE:
	case DATA_TYPE_BYTE:
	case DATA_TYPE_INT8:
	case DATA_TYPE_UINT8:
	case DATA_TYPE_INT16:
	case DATA_TYPE_UINT16:
	case DATA_TYPE_INT32:
	case DATA_TYPE_UINT32:
		nvp_sz += 4;	/* 4 is the minimum xdr unit */
		break;

	case DATA_TYPE_INT64:
	case DATA_TYPE_UINT64:
	case DATA_TYPE_HRTIME:
#if !defined(_KERNEL)
	case DATA_TYPE_DOUBLE:
#endif
		nvp_sz += 8;
		break;

	case DATA_TYPE_STRING:
		nvp_sz += 4 + NV_ALIGN4(strlen((char *)NVP_VALUE(nvp)));
		break;

	case DATA_TYPE_BYTE_ARRAY:
		nvp_sz += NV_ALIGN4(NVP_NELEM(nvp));
		break;

	case DATA_TYPE_BOOLEAN_ARRAY:
	case DATA_TYPE_INT8_ARRAY:
	case DATA_TYPE_UINT8_ARRAY:
	case DATA_TYPE_INT16_ARRAY:
	case DATA_TYPE_UINT16_ARRAY:
	case DATA_TYPE_INT32_ARRAY:
	case DATA_TYPE_UINT32_ARRAY:
		nvp_sz += 4 + 4 * (uint64_t)NVP_NELEM(nvp);
		break;

	case DATA_TYPE_INT64_ARRAY:
	case DATA_TYPE_UINT64_ARRAY:
		nvp_sz += 4 + 8 * (uint64_t)NVP_NELEM(nvp);
		break;

	case DATA_TYPE_STRING_ARRAY: {
		int i;
		char **strs = (void *)NVP_VALUE(nvp);

		for (i = 0; i < NVP_NELEM(nvp); i++)
			nvp_sz += 4 + NV_ALIGN4(strlen(strs[i]));

		break;
	}

	case DATA_TYPE_NVLIST:
	case DATA_TYPE_NVLIST_ARRAY: {
		size_t nvsize = 0;
		int old_nvs_op = nvs->nvs_op;
		int err;

		nvs->nvs_op = NVS_OP_GETSIZE;
		if (type == DATA_TYPE_NVLIST)
			err = nvs_operation(nvs, EMBEDDED_NVL(nvp), &nvsize);
		else
			err = nvs_embedded_nvl_array(nvs, nvp, &nvsize);
		nvs->nvs_op = old_nvs_op;

		if (err != 0)
			return (EINVAL);

		nvp_sz += nvsize;
		break;
	}

	default:
		return (EINVAL);
	}

	if (nvp_sz > INT32_MAX)
		return (EINVAL);

	*size = nvp_sz;

	return (0);
}


/*
 * The NVS_XDR_MAX_LEN macro takes a packed xdr buffer of size x and estimates
 * the largest nvpair that could be encoded in the buffer.
 *
 * See comments above nvpair_xdr_op() for the format of xdr encoding.
 * The size of a xdr packed nvpair without any data is 5 words.
 *
 * Using the size of the data directly as an estimate would be ok
 * in all cases except one.  If the data type is of DATA_TYPE_STRING_ARRAY
 * then the actual nvpair has space for an array of pointers to index
 * the strings.  These pointers are not encoded into the packed xdr buffer.
 *
 * If the data is of type DATA_TYPE_STRING_ARRAY and all the strings are
 * of length 0, then each string is endcoded in xdr format as a single word.
 * Therefore when expanded to an nvpair there will be 2.25 word used for
 * each string.  (a int64_t allocated for pointer usage, and a single char
 * for the null termination.)
 *
 * This is the calculation performed by the NVS_XDR_MAX_LEN macro.
 */
#define	NVS_XDR_HDR_LEN		((size_t)(5 * 4))
#define	NVS_XDR_DATA_LEN(y)	(((size_t)(y) <= NVS_XDR_HDR_LEN) ? \
					0 : ((size_t)(y) - NVS_XDR_HDR_LEN))
#define	NVS_XDR_MAX_LEN(x)	(NVP_SIZE_CALC(1, 0) + \
					(NVS_XDR_DATA_LEN(x) * 2) + \
					NV_ALIGN4((NVS_XDR_DATA_LEN(x) / 4)))

static int
nvs_xdr_nvpair(nvstream_t *nvs, nvpair_t *nvp, size_t *size)
{
	XDR 	*xdr = nvs->nvs_private;
	int32_t	encode_len, decode_len;

	switch (nvs->nvs_op) {
	case NVS_OP_ENCODE: {
		size_t nvsize;

		if (nvs_xdr_nvp_size(nvs, nvp, &nvsize) != 0)
			return (EFAULT);

		decode_len = nvp->nvp_size;
		encode_len = nvsize;
		if (!xdr_int(xdr, &encode_len) || !xdr_int(xdr, &decode_len))
			return (EFAULT);

		return (nvs_xdr_nvp_op(nvs, nvp));
	}
	case NVS_OP_DECODE: {
		struct xdr_bytesrec bytesrec;

		/* get the encode and decode size */
		if (!xdr_int(xdr, &encode_len) || !xdr_int(xdr, &decode_len))
			return (EFAULT);
		*size = decode_len;

		/* are we at the end of the stream? */
		if (*size == 0)
			return (0);

		/* sanity check the size parameter */
		if (!xdr_control(xdr, XDR_GET_BYTES_AVAIL, &bytesrec))
			return (EFAULT);

		if (*size > NVS_XDR_MAX_LEN(bytesrec.xc_num_avail))
			return (EFAULT);
		break;
	}

	default:
		return (EINVAL);
	}
	return (0);
}

static const struct nvs_ops nvs_xdr_ops = {
	nvs_xdr_nvlist,
	nvs_xdr_nvpair,
	nvs_xdr_nvp_op,
	nvs_xdr_nvp_size,
	nvs_xdr_nvl_fini
};

static int
nvs_xdr(nvstream_t *nvs, nvlist_t *nvl, char *buf, size_t *buflen)
{
	XDR xdr;
	int err;

	nvs->nvs_ops = &nvs_xdr_ops;

	if ((err = nvs_xdr_create(nvs, &xdr, buf + sizeof (nvs_header_t),
	    *buflen - sizeof (nvs_header_t))) != 0)
		return (err);

	err = nvs_operation(nvs, nvl, buflen);

	nvs_xdr_destroy(nvs);

	return (err);
}

#if defined(_KERNEL) && defined(HAVE_SPL)
static int __init
nvpair_init(void)
{
	return (0);
}

static void __exit
nvpair_fini(void)
{
}

module_init(nvpair_init);
module_exit(nvpair_fini);

MODULE_DESCRIPTION("Generic name/value pair implementation");
MODULE_AUTHOR(ZFS_META_AUTHOR);
MODULE_LICENSE(ZFS_META_LICENSE);
MODULE_VERSION(ZFS_META_VERSION "-" ZFS_META_RELEASE);

EXPORT_SYMBOL(nv_alloc_init);
EXPORT_SYMBOL(nv_alloc_reset);
EXPORT_SYMBOL(nv_alloc_fini);

/* list management */
EXPORT_SYMBOL(nvlist_alloc);
EXPORT_SYMBOL(nvlist_free);
EXPORT_SYMBOL(nvlist_size);
EXPORT_SYMBOL(nvlist_pack);
EXPORT_SYMBOL(nvlist_unpack);
EXPORT_SYMBOL(nvlist_dup);
EXPORT_SYMBOL(nvlist_merge);

EXPORT_SYMBOL(nvlist_xalloc);
EXPORT_SYMBOL(nvlist_xpack);
EXPORT_SYMBOL(nvlist_xunpack);
EXPORT_SYMBOL(nvlist_xdup);
EXPORT_SYMBOL(nvlist_lookup_nv_alloc);

EXPORT_SYMBOL(nvlist_add_nvpair);
EXPORT_SYMBOL(nvlist_add_boolean);
EXPORT_SYMBOL(nvlist_add_boolean_value);
EXPORT_SYMBOL(nvlist_add_byte);
EXPORT_SYMBOL(nvlist_add_int8);
EXPORT_SYMBOL(nvlist_add_uint8);
EXPORT_SYMBOL(nvlist_add_int16);
EXPORT_SYMBOL(nvlist_add_uint16);
EXPORT_SYMBOL(nvlist_add_int32);
EXPORT_SYMBOL(nvlist_add_uint32);
EXPORT_SYMBOL(nvlist_add_int64);
EXPORT_SYMBOL(nvlist_add_uint64);
EXPORT_SYMBOL(nvlist_add_string);
EXPORT_SYMBOL(nvlist_add_nvlist);
EXPORT_SYMBOL(nvlist_add_boolean_array);
EXPORT_SYMBOL(nvlist_add_byte_array);
EXPORT_SYMBOL(nvlist_add_int8_array);
EXPORT_SYMBOL(nvlist_add_uint8_array);
EXPORT_SYMBOL(nvlist_add_int16_array);
EXPORT_SYMBOL(nvlist_add_uint16_array);
EXPORT_SYMBOL(nvlist_add_int32_array);
EXPORT_SYMBOL(nvlist_add_uint32_array);
EXPORT_SYMBOL(nvlist_add_int64_array);
EXPORT_SYMBOL(nvlist_add_uint64_array);
EXPORT_SYMBOL(nvlist_add_string_array);
EXPORT_SYMBOL(nvlist_add_nvlist_array);
EXPORT_SYMBOL(nvlist_next_nvpair);
EXPORT_SYMBOL(nvlist_prev_nvpair);
EXPORT_SYMBOL(nvlist_empty);
EXPORT_SYMBOL(nvlist_add_hrtime);

EXPORT_SYMBOL(nvlist_remove);
EXPORT_SYMBOL(nvlist_remove_nvpair);
EXPORT_SYMBOL(nvlist_remove_all);

EXPORT_SYMBOL(nvlist_lookup_boolean);
EXPORT_SYMBOL(nvlist_lookup_boolean_value);
EXPORT_SYMBOL(nvlist_lookup_byte);
EXPORT_SYMBOL(nvlist_lookup_int8);
EXPORT_SYMBOL(nvlist_lookup_uint8);
EXPORT_SYMBOL(nvlist_lookup_int16);
EXPORT_SYMBOL(nvlist_lookup_uint16);
EXPORT_SYMBOL(nvlist_lookup_int32);
EXPORT_SYMBOL(nvlist_lookup_uint32);
EXPORT_SYMBOL(nvlist_lookup_int64);
EXPORT_SYMBOL(nvlist_lookup_uint64);
EXPORT_SYMBOL(nvlist_lookup_string);
EXPORT_SYMBOL(nvlist_lookup_nvlist);
EXPORT_SYMBOL(nvlist_lookup_boolean_array);
EXPORT_SYMBOL(nvlist_lookup_byte_array);
EXPORT_SYMBOL(nvlist_lookup_int8_array);
EXPORT_SYMBOL(nvlist_lookup_uint8_array);
EXPORT_SYMBOL(nvlist_lookup_int16_array);
EXPORT_SYMBOL(nvlist_lookup_uint16_array);
EXPORT_SYMBOL(nvlist_lookup_int32_array);
EXPORT_SYMBOL(nvlist_lookup_uint32_array);
EXPORT_SYMBOL(nvlist_lookup_int64_array);
EXPORT_SYMBOL(nvlist_lookup_uint64_array);
EXPORT_SYMBOL(nvlist_lookup_string_array);
EXPORT_SYMBOL(nvlist_lookup_nvlist_array);
EXPORT_SYMBOL(nvlist_lookup_hrtime);
EXPORT_SYMBOL(nvlist_lookup_pairs);

EXPORT_SYMBOL(nvlist_lookup_nvpair);
EXPORT_SYMBOL(nvlist_exists);

/* processing nvpair */
EXPORT_SYMBOL(nvpair_name);
EXPORT_SYMBOL(nvpair_type);
EXPORT_SYMBOL(nvpair_value_boolean_value);
EXPORT_SYMBOL(nvpair_value_byte);
EXPORT_SYMBOL(nvpair_value_int8);
EXPORT_SYMBOL(nvpair_value_uint8);
EXPORT_SYMBOL(nvpair_value_int16);
EXPORT_SYMBOL(nvpair_value_uint16);
EXPORT_SYMBOL(nvpair_value_int32);
EXPORT_SYMBOL(nvpair_value_uint32);
EXPORT_SYMBOL(nvpair_value_int64);
EXPORT_SYMBOL(nvpair_value_uint64);
EXPORT_SYMBOL(nvpair_value_string);
EXPORT_SYMBOL(nvpair_value_nvlist);
EXPORT_SYMBOL(nvpair_value_boolean_array);
EXPORT_SYMBOL(nvpair_value_byte_array);
EXPORT_SYMBOL(nvpair_value_int8_array);
EXPORT_SYMBOL(nvpair_value_uint8_array);
EXPORT_SYMBOL(nvpair_value_int16_array);
EXPORT_SYMBOL(nvpair_value_uint16_array);
EXPORT_SYMBOL(nvpair_value_int32_array);
EXPORT_SYMBOL(nvpair_value_uint32_array);
EXPORT_SYMBOL(nvpair_value_int64_array);
EXPORT_SYMBOL(nvpair_value_uint64_array);
EXPORT_SYMBOL(nvpair_value_string_array);
EXPORT_SYMBOL(nvpair_value_nvlist_array);
EXPORT_SYMBOL(nvpair_value_hrtime);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                               usr/src/zfs-0.6.5.9/module/nvpair/nvpair_alloc_fixed.c                                              0100644 0000000 0000000 00000006307 13045370707 021056  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */



#include <sys/stropts.h>
#include <sys/isa_defs.h>
#include <sys/nvpair.h>
#include <sys/sysmacros.h>
#if defined(_KERNEL) && !defined(_BOOT)
#include <sys/varargs.h>
#else
#include <stdarg.h>
#include <strings.h>
#endif

/*
 * This allocator is very simple.
 *  - it uses a pre-allocated buffer for memory allocations.
 *  - it does _not_ free memory in the pre-allocated buffer.
 *
 * The reason for the selected implemention is simplicity.
 * This allocator is designed for the usage in interrupt context when
 * the caller may not wait for free memory.
 */

/* pre-allocated buffer for memory allocations */
typedef struct nvbuf {
	uintptr_t	nvb_buf;	/* address of pre-allocated buffer */
	uintptr_t 	nvb_lim;	/* limit address in the buffer */
	uintptr_t	nvb_cur;	/* current address in the buffer */
} nvbuf_t;

/*
 * Initialize the pre-allocated buffer allocator. The caller needs to supply
 *
 *   buf	address of pre-allocated buffer
 *   bufsz	size of pre-allocated buffer
 *
 * nv_fixed_init() calculates the remaining members of nvbuf_t.
 */
static int
nv_fixed_init(nv_alloc_t *nva, va_list valist)
{
	uintptr_t base = va_arg(valist, uintptr_t);
	uintptr_t lim = base + va_arg(valist, size_t);
	nvbuf_t *nvb = (nvbuf_t *)P2ROUNDUP(base, sizeof (uintptr_t));

	if (base == 0 || (uintptr_t)&nvb[1] > lim)
		return (EINVAL);

	nvb->nvb_buf = (uintptr_t)&nvb[0];
	nvb->nvb_cur = (uintptr_t)&nvb[1];
	nvb->nvb_lim = lim;
	nva->nva_arg = nvb;

	return (0);
}

static void *
nv_fixed_alloc(nv_alloc_t *nva, size_t size)
{
	nvbuf_t *nvb = nva->nva_arg;
	uintptr_t new = nvb->nvb_cur;

	if (size == 0 || new + size > nvb->nvb_lim)
		return (NULL);

	nvb->nvb_cur = P2ROUNDUP(new + size, sizeof (uintptr_t));

	return ((void *)new);
}

/*ARGSUSED*/
static void
nv_fixed_free(nv_alloc_t *nva, void *buf, size_t size)
{
	/* don't free memory in the pre-allocated buffer */
}

static void
nv_fixed_reset(nv_alloc_t *nva)
{
	nvbuf_t *nvb = nva->nva_arg;

	nvb->nvb_cur = (uintptr_t)&nvb[1];
}

const nv_alloc_ops_t nv_fixed_ops_def = {
	nv_fixed_init,	/* nv_ao_init() */
	NULL,		/* nv_ao_fini() */
	nv_fixed_alloc,	/* nv_ao_alloc() */
	nv_fixed_free,	/* nv_ao_free() */
	nv_fixed_reset	/* nv_ao_reset() */
};

const nv_alloc_ops_t *nv_fixed_ops = &nv_fixed_ops_def;

#if defined(_KERNEL) && defined(HAVE_SPL)
EXPORT_SYMBOL(nv_fixed_ops);
#endif
                                                                                                                                                                                                                                                                                                                         usr/src/zfs-0.6.5.9/module/nvpair/nvpair_alloc_spl.c                                                0100644 0000000 0000000 00000004602 13045370707 020551  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at * usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#include <sys/nvpair.h>
#include <sys/kmem.h>
#include <sys/vmem.h>

static void *
nv_alloc_sleep_spl(nv_alloc_t *nva, size_t size)
{
	return (vmem_alloc(size, KM_SLEEP));
}

static void *
nv_alloc_pushpage_spl(nv_alloc_t *nva, size_t size)
{
	return (vmem_alloc(size, KM_PUSHPAGE));
}

static void *
nv_alloc_nosleep_spl(nv_alloc_t *nva, size_t size)
{
	return (kmem_alloc(size, KM_NOSLEEP));
}

static void
nv_free_spl(nv_alloc_t *nva, void *buf, size_t size)
{
	kmem_free(buf, size);
}

const nv_alloc_ops_t spl_sleep_ops_def = {
	NULL,			/* nv_ao_init() */
	NULL,			/* nv_ao_fini() */
	nv_alloc_sleep_spl,	/* nv_ao_alloc() */
	nv_free_spl,		/* nv_ao_free() */
	NULL			/* nv_ao_reset() */
};

const nv_alloc_ops_t spl_pushpage_ops_def = {
	NULL,			/* nv_ao_init() */
	NULL,			/* nv_ao_fini() */
	nv_alloc_pushpage_spl,	/* nv_ao_alloc() */
	nv_free_spl,		/* nv_ao_free() */
	NULL			/* nv_ao_reset() */
};

const nv_alloc_ops_t spl_nosleep_ops_def = {
	NULL,			/* nv_ao_init() */
	NULL,			/* nv_ao_fini() */
	nv_alloc_nosleep_spl,	/* nv_ao_alloc() */
	nv_free_spl,		/* nv_ao_free() */
	NULL			/* nv_ao_reset() */
};

nv_alloc_t nv_alloc_sleep_def = {
	&spl_sleep_ops_def,
	NULL
};

nv_alloc_t nv_alloc_pushpage_def = {
	&spl_pushpage_ops_def,
	NULL
};

nv_alloc_t nv_alloc_nosleep_def = {
	&spl_nosleep_ops_def,
	NULL
};

nv_alloc_t *nv_alloc_sleep = &nv_alloc_sleep_def;
nv_alloc_t *nv_alloc_pushpage = &nv_alloc_pushpage_def;
nv_alloc_t *nv_alloc_nosleep = &nv_alloc_nosleep_def;
                                                                                                                              usr/src/zfs-0.6.5.9/module/unicode/                                                                 0040755 0000000 0000000 00000000000 13077704276 015215  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/src/zfs-0.6.5.9/module/unicode/Makefile.in                                                      0100644 0000000 0000000 00000000342 13045171016 017237  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        src = @abs_top_srcdir@/module/unicode
obj = @abs_builddir@

MODULE := zunicode

EXTRA_CFLAGS = $(ZFS_MODULE_CFLAGS) @KERNELCPPFLAGS@

obj-$(CONFIG_ZFS) := $(MODULE).o

$(MODULE)-objs += u8_textprep.o
$(MODULE)-objs += uconv.o
                                                                                                                                                                                                                                                                                              usr/src/zfs-0.6.5.9/module/unicode/u8_textprep.c                                                    0100644 0000000 0000000 00000156177 13045370707 017657  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */




/*
 * UTF-8 text preparation functions (PSARC/2007/149, PSARC/2007/458).
 *
 * Man pages: u8_textprep_open(9F), u8_textprep_buf(9F), u8_textprep_close(9F),
 * u8_textprep_str(9F), u8_strcmp(9F), and u8_validate(9F). See also
 * the section 3C man pages.
 * Interface stability: Committed.
 */

#include <sys/types.h>
#ifdef	_KERNEL
#include <sys/param.h>
#include <sys/sysmacros.h>
#include <sys/systm.h>
#include <sys/debug.h>
#include <sys/kmem.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
#else
#include <sys/u8_textprep.h>
#include <strings.h>
#endif	/* _KERNEL */
#include <sys/byteorder.h>
#include <sys/errno.h>
#include <sys/u8_textprep_data.h>


/* The maximum possible number of bytes in a UTF-8 character. */
#define	U8_MB_CUR_MAX			(4)

/*
 * The maximum number of bytes needed for a UTF-8 character to cover
 * U+0000 - U+FFFF, i.e., the coding space of now deprecated UCS-2.
 */
#define	U8_MAX_BYTES_UCS2		(3)

/* The maximum possible number of bytes in a Stream-Safe Text. */
#define	U8_STREAM_SAFE_TEXT_MAX		(128)

/*
 * The maximum number of characters in a combining/conjoining sequence and
 * the actual upperbound limit of a combining/conjoining sequence.
 */
#define	U8_MAX_CHARS_A_SEQ		(32)
#define	U8_UPPER_LIMIT_IN_A_SEQ		(31)

/* The combining class value for Starter. */
#define	U8_COMBINING_CLASS_STARTER	(0)

/*
 * Some Hangul related macros at below.
 *
 * The first and the last of Hangul syllables, Hangul Jamo Leading consonants,
 * Vowels, and optional Trailing consonants in Unicode scalar values.
 *
 * Please be noted that the U8_HANGUL_JAMO_T_FIRST is 0x11A7 at below not
 * the actual U+11A8. This is due to that the trailing consonant is optional
 * and thus we are doing a pre-calculation of subtracting one.
 *
 * Each of 19 modern leading consonants has total 588 possible syllables since
 * Hangul has 21 modern vowels and 27 modern trailing consonants plus 1 for
 * no trailing consonant case, i.e., 21 x 28 = 588.
 *
 * We also have bunch of Hangul related macros at below. Please bear in mind
 * that the U8_HANGUL_JAMO_1ST_BYTE can be used to check whether it is
 * a Hangul Jamo or not but the value does not guarantee that it is a Hangul
 * Jamo; it just guarantee that it will be most likely.
 */
#define	U8_HANGUL_SYL_FIRST		(0xAC00U)
#define	U8_HANGUL_SYL_LAST		(0xD7A3U)

#define	U8_HANGUL_JAMO_L_FIRST		(0x1100U)
#define	U8_HANGUL_JAMO_L_LAST		(0x1112U)
#define	U8_HANGUL_JAMO_V_FIRST		(0x1161U)
#define	U8_HANGUL_JAMO_V_LAST		(0x1175U)
#define	U8_HANGUL_JAMO_T_FIRST		(0x11A7U)
#define	U8_HANGUL_JAMO_T_LAST		(0x11C2U)

#define	U8_HANGUL_V_COUNT		(21)
#define	U8_HANGUL_VT_COUNT		(588)
#define	U8_HANGUL_T_COUNT		(28)

#define	U8_HANGUL_JAMO_1ST_BYTE		(0xE1U)

#define	U8_SAVE_HANGUL_AS_UTF8(s, i, j, k, b) \
	(s)[(i)] = (uchar_t)(0xE0U | ((uint32_t)(b) & 0xF000U) >> 12); \
	(s)[(j)] = (uchar_t)(0x80U | ((uint32_t)(b) & 0x0FC0U) >> 6); \
	(s)[(k)] = (uchar_t)(0x80U | ((uint32_t)(b) & 0x003FU));

#define	U8_HANGUL_JAMO_L(u) \
	((u) >= U8_HANGUL_JAMO_L_FIRST && (u) <= U8_HANGUL_JAMO_L_LAST)

#define	U8_HANGUL_JAMO_V(u) \
	((u) >= U8_HANGUL_JAMO_V_FIRST && (u) <= U8_HANGUL_JAMO_V_LAST)

#define	U8_HANGUL_JAMO_T(u) \
	((u) > U8_HANGUL_JAMO_T_FIRST && (u) <= U8_HANGUL_JAMO_T_LAST)

#define	U8_HANGUL_JAMO(u) \
	((u) >= U8_HANGUL_JAMO_L_FIRST && (u) <= U8_HANGUL_JAMO_T_LAST)

#define	U8_HANGUL_SYLLABLE(u) \
	((u) >= U8_HANGUL_SYL_FIRST && (u) <= U8_HANGUL_SYL_LAST)

#define	U8_HANGUL_COMPOSABLE_L_V(s, u) \
	((s) == U8_STATE_HANGUL_L && U8_HANGUL_JAMO_V((u)))

#define	U8_HANGUL_COMPOSABLE_LV_T(s, u) \
	((s) == U8_STATE_HANGUL_LV && U8_HANGUL_JAMO_T((u)))

/* The types of decomposition mappings. */
#define	U8_DECOMP_BOTH			(0xF5U)
#define	U8_DECOMP_CANONICAL		(0xF6U)

/* The indicator for 16-bit table. */
#define	U8_16BIT_TABLE_INDICATOR	(0x8000U)

/* The following are some convenience macros. */
#define	U8_PUT_3BYTES_INTO_UTF32(u, b1, b2, b3)  \
	(u) = ((((uint32_t)(b1) & 0x0F) << 12) | \
		(((uint32_t)(b2) & 0x3F) << 6)  | \
		((uint32_t)(b3) & 0x3F));

#define	U8_SIMPLE_SWAP(a, b, t) \
	(t) = (a); \
	(a) = (b); \
	(b) = (t);

#define	U8_ASCII_TOUPPER(c) \
	(((c) >= 'a' && (c) <= 'z') ? (c) - 'a' + 'A' : (c))

#define	U8_ASCII_TOLOWER(c) \
	(((c) >= 'A' && (c) <= 'Z') ? (c) - 'A' + 'a' : (c))

#define	U8_ISASCII(c)			(((uchar_t)(c)) < 0x80U)
/*
 * The following macro assumes that the two characters that are to be
 * swapped are adjacent to each other and 'a' comes before 'b'.
 *
 * If the assumptions are not met, then, the macro will fail.
 */
#define	U8_SWAP_COMB_MARKS(a, b) \
	for (k = 0; k < disp[(a)]; k++) \
		u8t[k] = u8s[start[(a)] + k]; \
	for (k = 0; k < disp[(b)]; k++) \
		u8s[start[(a)] + k] = u8s[start[(b)] + k]; \
	start[(b)] = start[(a)] + disp[(b)]; \
	for (k = 0; k < disp[(a)]; k++) \
		u8s[start[(b)] + k] = u8t[k]; \
	U8_SIMPLE_SWAP(comb_class[(a)], comb_class[(b)], tc); \
	U8_SIMPLE_SWAP(disp[(a)], disp[(b)], tc);

/* The possible states during normalization. */
typedef enum {
	U8_STATE_START = 0,
	U8_STATE_HANGUL_L = 1,
	U8_STATE_HANGUL_LV = 2,
	U8_STATE_HANGUL_LVT = 3,
	U8_STATE_HANGUL_V = 4,
	U8_STATE_HANGUL_T = 5,
	U8_STATE_COMBINING_MARK = 6
} u8_normalization_states_t;

/*
 * The three vectors at below are used to check bytes of a given UTF-8
 * character are valid and not containing any malformed byte values.
 *
 * We used to have a quite relaxed UTF-8 binary representation but then there
 * was some security related issues and so the Unicode Consortium defined
 * and announced the UTF-8 Corrigendum at Unicode 3.1 and then refined it
 * one more time at the Unicode 3.2. The following three tables are based on
 * that.
 */

#define	U8_ILLEGAL_NEXT_BYTE_COMMON(c)	((c) < 0x80 || (c) > 0xBF)

#define	I_				U8_ILLEGAL_CHAR
#define	O_				U8_OUT_OF_RANGE_CHAR

const int8_t u8_number_of_bytes[0x100] = {
	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

/*	80  81  82  83  84  85  86  87  88  89  8A  8B  8C  8D  8E  8F  */
	I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_,

/*  	90  91  92  93  94  95  96  97  98  99  9A  9B  9C  9D  9E  9F  */
	I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_,

/*  	A0  A1  A2  A3  A4  A5  A6  A7  A8  A9  AA  AB  AC  AD  AE  AF  */
	I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_,

/*	B0  B1  B2  B3  B4  B5  B6  B7  B8  B9  BA  BB  BC  BD  BE  BF  */
	I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_,

/*	C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF  */
	I_, I_, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,

/*	D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF  */
	2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,

/*	E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF  */
	3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,

/*	F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF  */
	4,  4,  4,  4,  4,  O_, O_, O_, O_, O_, O_, O_, O_, O_, O_, O_,
};

#undef	I_
#undef	O_

const uint8_t u8_valid_min_2nd_byte[0x100] = {
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
/*	C0    C1    C2    C3    C4    C5    C6    C7    */
	0,    0,    0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
/*	C8    C9    CA    CB    CC    CD    CE    CF    */
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
/*	D0    D1    D2    D3    D4    D5    D6    D7    */
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
/*	D8    D9    DA    DB    DC    DD    DE    DF    */
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
/*	E0    E1    E2    E3    E4    E5    E6    E7    */
	0xa0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
/*	E8    E9    EA    EB    EC    ED    EE    EF    */
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
/*	F0    F1    F2    F3    F4    F5    F6    F7    */
	0x90, 0x80, 0x80, 0x80, 0x80, 0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
};

const uint8_t u8_valid_max_2nd_byte[0x100] = {
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
/*	C0    C1    C2    C3    C4    C5    C6    C7    */
	0,    0,    0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
/*	C8    C9    CA    CB    CC    CD    CE    CF    */
	0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
/*	D0    D1    D2    D3    D4    D5    D6    D7    */
	0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
/*	D8    D9    DA    DB    DC    DD    DE    DF    */
	0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
/*	E0    E1    E2    E3    E4    E5    E6    E7    */
	0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
/*	E8    E9    EA    EB    EC    ED    EE    EF    */
	0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0x9f, 0xbf, 0xbf,
/*	F0    F1    F2    F3    F4    F5    F6    F7    */
	0xbf, 0xbf, 0xbf, 0xbf, 0x8f, 0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
};


/*
 * The u8_validate() validates on the given UTF-8 character string and
 * calculate the byte length. It is quite similar to mblen(3C) except that
 * this will validate against the list of characters if required and
 * specific to UTF-8 and Unicode.
 */
int
u8_validate(char *u8str, size_t n, char **list, int flag, int *errnum)
{
	uchar_t *ib;
	uchar_t *ibtail;
	uchar_t **p;
	uchar_t *s1;
	uchar_t *s2;
	uchar_t f;
	int sz;
	size_t i;
	int ret_val;
	boolean_t second;
	boolean_t no_need_to_validate_entire;
	boolean_t check_additional;
	boolean_t validate_ucs2_range_only;

	if (! u8str)
		return (0);

	ib = (uchar_t *)u8str;
	ibtail = ib + n;

	ret_val = 0;

	no_need_to_validate_entire = ! (flag & U8_VALIDATE_ENTIRE);
	check_additional = flag & U8_VALIDATE_CHECK_ADDITIONAL;
	validate_ucs2_range_only = flag & U8_VALIDATE_UCS2_RANGE;

	while (ib < ibtail) {
		/*
		 * The first byte of a UTF-8 character tells how many
		 * bytes will follow for the character. If the first byte
		 * is an illegal byte value or out of range value, we just
		 * return -1 with an appropriate error number.
		 */
		sz = u8_number_of_bytes[*ib];
		if (sz == U8_ILLEGAL_CHAR) {
			*errnum = EILSEQ;
			return (-1);
		}

		if (sz == U8_OUT_OF_RANGE_CHAR ||
		    (validate_ucs2_range_only && sz > U8_MAX_BYTES_UCS2)) {
			*errnum = ERANGE;
			return (-1);
		}

		/*
		 * If we don't have enough bytes to check on, that's also
		 * an error. As you can see, we give illegal byte sequence
		 * checking higher priority then EINVAL cases.
		 */
		if ((ibtail - ib) < sz) {
			*errnum = EINVAL;
			return (-1);
		}

		if (sz == 1) {
			ib++;
			ret_val++;
		} else {
			/*
			 * Check on the multi-byte UTF-8 character. For more
			 * details on this, see comment added for the used
			 * data structures at the beginning of the file.
			 */
			f = *ib++;
			ret_val++;
			second = B_TRUE;
			for (i = 1; i < sz; i++) {
				if (second) {
					if (*ib < u8_valid_min_2nd_byte[f] ||
					    *ib > u8_valid_max_2nd_byte[f]) {
						*errnum = EILSEQ;
						return (-1);
					}
					second = B_FALSE;
				} else if (U8_ILLEGAL_NEXT_BYTE_COMMON(*ib)) {
					*errnum = EILSEQ;
					return (-1);
				}
				ib++;
				ret_val++;
			}
		}

		if (check_additional) {
			for (p = (uchar_t **)list, i = 0; p[i]; i++) {
				s1 = ib - sz;
				s2 = p[i];
				while (s1 < ib) {
					if (*s1 != *s2 || *s2 == '\0')
						break;
					s1++;
					s2++;
				}

				if (s1 >= ib && *s2 == '\0') {
					*errnum = EBADF;
					return (-1);
				}
			}
		}

		if (no_need_to_validate_entire)
			break;
	}

	return (ret_val);
}

/*
 * The do_case_conv() looks at the mapping tables and returns found
 * bytes if any. If not found, the input bytes are returned. The function
 * always terminate the return bytes with a null character assuming that
 * there are plenty of room to do so.
 *
 * The case conversions are simple case conversions mapping a character to
 * another character as specified in the Unicode data. The byte size of
 * the mapped character could be different from that of the input character.
 *
 * The return value is the byte length of the returned character excluding
 * the terminating null byte.
 */
static size_t
do_case_conv(int uv, uchar_t *u8s, uchar_t *s, int sz, boolean_t is_it_toupper)
{
	size_t i;
	uint16_t b1 = 0;
	uint16_t b2 = 0;
	uint16_t b3 = 0;
	uint16_t b3_tbl;
	uint16_t b3_base;
	uint16_t b4 = 0;
	size_t start_id;
	size_t end_id;

	/*
	 * At this point, the only possible values for sz are 2, 3, and 4.
	 * The u8s should point to a vector that is well beyond the size of
	 * 5 bytes.
	 */
	if (sz == 2) {
		b3 = u8s[0] = s[0];
		b4 = u8s[1] = s[1];
	} else if (sz == 3) {
		b2 = u8s[0] = s[0];
		b3 = u8s[1] = s[1];
		b4 = u8s[2] = s[2];
	} else if (sz == 4) {
		b1 = u8s[0] = s[0];
		b2 = u8s[1] = s[1];
		b3 = u8s[2] = s[2];
		b4 = u8s[3] = s[3];
	} else {
		/* This is not possible but just in case as a fallback. */
		if (is_it_toupper)
			*u8s = U8_ASCII_TOUPPER(*s);
		else
			*u8s = U8_ASCII_TOLOWER(*s);
		u8s[1] = '\0';

		return (1);
	}
	u8s[sz] = '\0';

	/*
	 * Let's find out if we have a corresponding character.
	 */
	b1 = u8_common_b1_tbl[uv][b1];
	if (b1 == U8_TBL_ELEMENT_NOT_DEF)
		return ((size_t)sz);

	b2 = u8_case_common_b2_tbl[uv][b1][b2];
	if (b2 == U8_TBL_ELEMENT_NOT_DEF)
		return ((size_t)sz);

	if (is_it_toupper) {
		b3_tbl = u8_toupper_b3_tbl[uv][b2][b3].tbl_id;
		if (b3_tbl == U8_TBL_ELEMENT_NOT_DEF)
			return ((size_t)sz);

		start_id = u8_toupper_b4_tbl[uv][b3_tbl][b4];
		end_id = u8_toupper_b4_tbl[uv][b3_tbl][b4 + 1];

		/* Either there is no match or an error at the table. */
		if (start_id >= end_id || (end_id - start_id) > U8_MB_CUR_MAX)
			return ((size_t)sz);

		b3_base = u8_toupper_b3_tbl[uv][b2][b3].base;

		for (i = 0; start_id < end_id; start_id++)
			u8s[i++] = u8_toupper_final_tbl[uv][b3_base + start_id];
	} else {
		b3_tbl = u8_tolower_b3_tbl[uv][b2][b3].tbl_id;
		if (b3_tbl == U8_TBL_ELEMENT_NOT_DEF)
			return ((size_t)sz);

		start_id = u8_tolower_b4_tbl[uv][b3_tbl][b4];
		end_id = u8_tolower_b4_tbl[uv][b3_tbl][b4 + 1];

		if (start_id >= end_id || (end_id - start_id) > U8_MB_CUR_MAX)
			return ((size_t)sz);

		b3_base = u8_tolower_b3_tbl[uv][b2][b3].base;

		for (i = 0; start_id < end_id; start_id++)
			u8s[i++] = u8_tolower_final_tbl[uv][b3_base + start_id];
	}

	/*
	 * If i is still zero, that means there is no corresponding character.
	 */
	if (i == 0)
		return ((size_t)sz);

	u8s[i] = '\0';

	return (i);
}

/*
 * The do_case_compare() function compares the two input strings, s1 and s2,
 * one character at a time doing case conversions if applicable and return
 * the comparison result as like strcmp().
 *
 * Since, in empirical sense, most of text data are 7-bit ASCII characters,
 * we treat the 7-bit ASCII characters as a special case trying to yield
 * faster processing time.
 */
static int
do_case_compare(size_t uv, uchar_t *s1, uchar_t *s2, size_t n1,
	size_t n2, boolean_t is_it_toupper, int *errnum)
{
	int f;
	int sz1;
	int sz2;
	size_t j;
	size_t i1;
	size_t i2;
	uchar_t u8s1[U8_MB_CUR_MAX + 1];
	uchar_t u8s2[U8_MB_CUR_MAX + 1];

	i1 = i2 = 0;
	while (i1 < n1 && i2 < n2) {
		/*
		 * Find out what would be the byte length for this UTF-8
		 * character at string s1 and also find out if this is
		 * an illegal start byte or not and if so, issue a proper
		 * error number and yet treat this byte as a character.
		 */
		sz1 = u8_number_of_bytes[*s1];
		if (sz1 < 0) {
			*errnum = EILSEQ;
			sz1 = 1;
		}

		/*
		 * For 7-bit ASCII characters mainly, we do a quick case
		 * conversion right at here.
		 *
		 * If we don't have enough bytes for this character, issue
		 * an EINVAL error and use what are available.
		 *
		 * If we have enough bytes, find out if there is
		 * a corresponding uppercase character and if so, copy over
		 * the bytes for a comparison later. If there is no
		 * corresponding uppercase character, then, use what we have
		 * for the comparison.
		 */
		if (sz1 == 1) {
			if (is_it_toupper)
				u8s1[0] = U8_ASCII_TOUPPER(*s1);
			else
				u8s1[0] = U8_ASCII_TOLOWER(*s1);
			s1++;
			u8s1[1] = '\0';
		} else if ((i1 + sz1) > n1) {
			*errnum = EINVAL;
			for (j = 0; (i1 + j) < n1; )
				u8s1[j++] = *s1++;
			u8s1[j] = '\0';
		} else {
			(void) do_case_conv(uv, u8s1, s1, sz1, is_it_toupper);
			s1 += sz1;
		}

		/* Do the same for the string s2. */
		sz2 = u8_number_of_bytes[*s2];
		if (sz2 < 0) {
			*errnum = EILSEQ;
			sz2 = 1;
		}

		if (sz2 == 1) {
			if (is_it_toupper)
				u8s2[0] = U8_ASCII_TOUPPER(*s2);
			else
				u8s2[0] = U8_ASCII_TOLOWER(*s2);
			s2++;
			u8s2[1] = '\0';
		} else if ((i2 + sz2) > n2) {
			*errnum = EINVAL;
			for (j = 0; (i2 + j) < n2; )
				u8s2[j++] = *s2++;
			u8s2[j] = '\0';
		} else {
			(void) do_case_conv(uv, u8s2, s2, sz2, is_it_toupper);
			s2 += sz2;
		}

		/* Now compare the two characters. */
		if (sz1 == 1 && sz2 == 1) {
			if (*u8s1 > *u8s2)
				return (1);
			if (*u8s1 < *u8s2)
				return (-1);
		} else {
			f = strcmp((const char *)u8s1, (const char *)u8s2);
			if (f != 0)
				return (f);
		}

		/*
		 * They were the same. Let's move on to the next
		 * characters then.
		 */
		i1 += sz1;
		i2 += sz2;
	}

	/*
	 * We compared until the end of either or both strings.
	 *
	 * If we reached to or went over the ends for the both, that means
	 * they are the same.
	 *
	 * If we reached only one of the two ends, that means the other string
	 * has something which then the fact can be used to determine
	 * the return value.
	 */
	if (i1 >= n1) {
		if (i2 >= n2)
			return (0);
		return (-1);
	}
	return (1);
}

/*
 * The combining_class() function checks on the given bytes and find out
 * the corresponding Unicode combining class value. The return value 0 means
 * it is a Starter. Any illegal UTF-8 character will also be treated as
 * a Starter.
 */
static uchar_t
combining_class(size_t uv, uchar_t *s, size_t sz)
{
	uint16_t b1 = 0;
	uint16_t b2 = 0;
	uint16_t b3 = 0;
	uint16_t b4 = 0;

	if (sz == 1 || sz > 4)
		return (0);

	if (sz == 2) {
		b3 = s[0];
		b4 = s[1];
	} else if (sz == 3) {
		b2 = s[0];
		b3 = s[1];
		b4 = s[2];
	} else if (sz == 4) {
		b1 = s[0];
		b2 = s[1];
		b3 = s[2];
		b4 = s[3];
	}

	b1 = u8_common_b1_tbl[uv][b1];
	if (b1 == U8_TBL_ELEMENT_NOT_DEF)
		return (0);

	b2 = u8_combining_class_b2_tbl[uv][b1][b2];
	if (b2 == U8_TBL_ELEMENT_NOT_DEF)
		return (0);

	b3 = u8_combining_class_b3_tbl[uv][b2][b3];
	if (b3 == U8_TBL_ELEMENT_NOT_DEF)
		return (0);

	return (u8_combining_class_b4_tbl[uv][b3][b4]);
}

/*
 * The do_decomp() function finds out a matching decomposition if any
 * and return. If there is no match, the input bytes are copied and returned.
 * The function also checks if there is a Hangul, decomposes it if necessary
 * and returns.
 *
 * To save time, a single byte 7-bit ASCII character should be handled by
 * the caller.
 *
 * The function returns the number of bytes returned sans always terminating
 * the null byte. It will also return a state that will tell if there was
 * a Hangul character decomposed which then will be used by the caller.
 */
static size_t
do_decomp(size_t uv, uchar_t *u8s, uchar_t *s, int sz,
	boolean_t canonical_decomposition, u8_normalization_states_t *state)
{
	uint16_t b1 = 0;
	uint16_t b2 = 0;
	uint16_t b3 = 0;
	uint16_t b3_tbl;
	uint16_t b3_base;
	uint16_t b4 = 0;
	size_t start_id;
	size_t end_id;
	size_t i;
	uint32_t u1;

	if (sz == 2) {
		b3 = u8s[0] = s[0];
		b4 = u8s[1] = s[1];
		u8s[2] = '\0';
	} else if (sz == 3) {
		/* Convert it to a Unicode scalar value. */
		U8_PUT_3BYTES_INTO_UTF32(u1, s[0], s[1], s[2]);

		/*
		 * If this is a Hangul syllable, we decompose it into
		 * a leading consonant, a vowel, and an optional trailing
		 * consonant and then return.
		 */
		if (U8_HANGUL_SYLLABLE(u1)) {
			u1 -= U8_HANGUL_SYL_FIRST;

			b1 = U8_HANGUL_JAMO_L_FIRST + u1 / U8_HANGUL_VT_COUNT;
			b2 = U8_HANGUL_JAMO_V_FIRST + (u1 % U8_HANGUL_VT_COUNT)
			    / U8_HANGUL_T_COUNT;
			b3 = u1 % U8_HANGUL_T_COUNT;

			U8_SAVE_HANGUL_AS_UTF8(u8s, 0, 1, 2, b1);
			U8_SAVE_HANGUL_AS_UTF8(u8s, 3, 4, 5, b2);
			if (b3) {
				b3 += U8_HANGUL_JAMO_T_FIRST;
				U8_SAVE_HANGUL_AS_UTF8(u8s, 6, 7, 8, b3);

				u8s[9] = '\0';
				*state = U8_STATE_HANGUL_LVT;
				return (9);
			}

			u8s[6] = '\0';
			*state = U8_STATE_HANGUL_LV;
			return (6);
		}

		b2 = u8s[0] = s[0];
		b3 = u8s[1] = s[1];
		b4 = u8s[2] = s[2];
		u8s[3] = '\0';

		/*
		 * If this is a Hangul Jamo, we know there is nothing
		 * further that we can decompose.
		 */
		if (U8_HANGUL_JAMO_L(u1)) {
			*state = U8_STATE_HANGUL_L;
			return (3);
		}

		if (U8_HANGUL_JAMO_V(u1)) {
			if (*state == U8_STATE_HANGUL_L)
				*state = U8_STATE_HANGUL_LV;
			else
				*state = U8_STATE_HANGUL_V;
			return (3);
		}

		if (U8_HANGUL_JAMO_T(u1)) {
			if (*state == U8_STATE_HANGUL_LV)
				*state = U8_STATE_HANGUL_LVT;
			else
				*state = U8_STATE_HANGUL_T;
			return (3);
		}
	} else if (sz == 4) {
		b1 = u8s[0] = s[0];
		b2 = u8s[1] = s[1];
		b3 = u8s[2] = s[2];
		b4 = u8s[3] = s[3];
		u8s[4] = '\0';
	} else {
		/*
		 * This is a fallback and should not happen if the function
		 * was called properly.
		 */
		u8s[0] = s[0];
		u8s[1] = '\0';
		*state = U8_STATE_START;
		return (1);
	}

	/*
	 * At this point, this rountine does not know what it would get.
	 * The caller should sort it out if the state isn't a Hangul one.
	 */
	*state = U8_STATE_START;

	/* Try to find matching decomposition mapping byte sequence. */
	b1 = u8_common_b1_tbl[uv][b1];
	if (b1 == U8_TBL_ELEMENT_NOT_DEF)
		return ((size_t)sz);

	b2 = u8_decomp_b2_tbl[uv][b1][b2];
	if (b2 == U8_TBL_ELEMENT_NOT_DEF)
		return ((size_t)sz);

	b3_tbl = u8_decomp_b3_tbl[uv][b2][b3].tbl_id;
	if (b3_tbl == U8_TBL_ELEMENT_NOT_DEF)
		return ((size_t)sz);

	/*
	 * If b3_tbl is bigger than or equal to U8_16BIT_TABLE_INDICATOR
	 * which is 0x8000, this means we couldn't fit the mappings into
	 * the cardinality of a unsigned byte.
	 */
	if (b3_tbl >= U8_16BIT_TABLE_INDICATOR) {
		b3_tbl -= U8_16BIT_TABLE_INDICATOR;
		start_id = u8_decomp_b4_16bit_tbl[uv][b3_tbl][b4];
		end_id = u8_decomp_b4_16bit_tbl[uv][b3_tbl][b4 + 1];
	} else {
		start_id = u8_decomp_b4_tbl[uv][b3_tbl][b4];
		end_id = u8_decomp_b4_tbl[uv][b3_tbl][b4 + 1];
	}

	/* This also means there wasn't any matching decomposition. */
	if (start_id >= end_id)
		return ((size_t)sz);

	/*
	 * The final table for decomposition mappings has three types of
	 * byte sequences depending on whether a mapping is for compatibility
	 * decomposition, canonical decomposition, or both like the following:
	 *
	 * (1) Compatibility decomposition mappings:
	 *
	 *	+---+---+-...-+---+
	 *	| B0| B1| ... | Bm|
	 *	+---+---+-...-+---+
	 *
	 *	The first byte, B0, is always less then 0xF5 (U8_DECOMP_BOTH).
	 *
	 * (2) Canonical decomposition mappings:
	 *
	 *	+---+---+---+-...-+---+
	 *	| T | b0| b1| ... | bn|
	 *	+---+---+---+-...-+---+
	 *
	 *	where the first byte, T, is 0xF6 (U8_DECOMP_CANONICAL).
	 *
	 * (3) Both mappings:
	 *
	 *	+---+---+---+---+-...-+---+---+---+-...-+---+
	 *	| T | D | b0| b1| ... | bn| B0| B1| ... | Bm|
	 *	+---+---+---+---+-...-+---+---+---+-...-+---+
	 *
	 *	where T is 0xF5 (U8_DECOMP_BOTH) and D is a displacement
	 *	byte, b0 to bn are canonical mapping bytes and B0 to Bm are
	 *	compatibility mapping bytes.
	 *
	 * Note that compatibility decomposition means doing recursive
	 * decompositions using both compatibility decomposition mappings and
	 * canonical decomposition mappings. On the other hand, canonical
	 * decomposition means doing recursive decompositions using only
	 * canonical decomposition mappings. Since the table we have has gone
	 * through the recursions already, we do not need to do so during
	 * runtime, i.e., the table has been completely flattened out
	 * already.
	 */

	b3_base = u8_decomp_b3_tbl[uv][b2][b3].base;

	/* Get the type, T, of the byte sequence. */
	b1 = u8_decomp_final_tbl[uv][b3_base + start_id];

	/*
	 * If necessary, adjust start_id, end_id, or both. Note that if
	 * this is compatibility decomposition mapping, there is no
	 * adjustment.
	 */
	if (canonical_decomposition) {
		/* Is the mapping only for compatibility decomposition? */
		if (b1 < U8_DECOMP_BOTH)
			return ((size_t)sz);

		start_id++;

		if (b1 == U8_DECOMP_BOTH) {
			end_id = start_id +
			    u8_decomp_final_tbl[uv][b3_base + start_id];
			start_id++;
		}
	} else {
		/*
		 * Unless this is a compatibility decomposition mapping,
		 * we adjust the start_id.
		 */
		if (b1 == U8_DECOMP_BOTH) {
			start_id++;
			start_id += u8_decomp_final_tbl[uv][b3_base + start_id];
		} else if (b1 == U8_DECOMP_CANONICAL) {
			start_id++;
		}
	}

	for (i = 0; start_id < end_id; start_id++)
		u8s[i++] = u8_decomp_final_tbl[uv][b3_base + start_id];
	u8s[i] = '\0';

	return (i);
}

/*
 * The find_composition_start() function uses the character bytes given and
 * find out the matching composition mappings if any and return the address
 * to the composition mappings as explained in the do_composition().
 */
static uchar_t *
find_composition_start(size_t uv, uchar_t *s, size_t sz)
{
	uint16_t b1 = 0;
	uint16_t b2 = 0;
	uint16_t b3 = 0;
	uint16_t b3_tbl;
	uint16_t b3_base;
	uint16_t b4 = 0;
	size_t start_id;
	size_t end_id;

	if (sz == 1) {
		b4 = s[0];
	} else if (sz == 2) {
		b3 = s[0];
		b4 = s[1];
	} else if (sz == 3) {
		b2 = s[0];
		b3 = s[1];
		b4 = s[2];
	} else if (sz == 4) {
		b1 = s[0];
		b2 = s[1];
		b3 = s[2];
		b4 = s[3];
	} else {
		/*
		 * This is a fallback and should not happen if the function
		 * was called properly.
		 */
		return (NULL);
	}

	b1 = u8_composition_b1_tbl[uv][b1];
	if (b1 == U8_TBL_ELEMENT_NOT_DEF)
		return (NULL);

	b2 = u8_composition_b2_tbl[uv][b1][b2];
	if (b2 == U8_TBL_ELEMENT_NOT_DEF)
		return (NULL);

	b3_tbl = u8_composition_b3_tbl[uv][b2][b3].tbl_id;
	if (b3_tbl == U8_TBL_ELEMENT_NOT_DEF)
		return (NULL);

	if (b3_tbl >= U8_16BIT_TABLE_INDICATOR) {
		b3_tbl -= U8_16BIT_TABLE_INDICATOR;
		start_id = u8_composition_b4_16bit_tbl[uv][b3_tbl][b4];
		end_id = u8_composition_b4_16bit_tbl[uv][b3_tbl][b4 + 1];
	} else {
		start_id = u8_composition_b4_tbl[uv][b3_tbl][b4];
		end_id = u8_composition_b4_tbl[uv][b3_tbl][b4 + 1];
	}

	if (start_id >= end_id)
		return (NULL);

	b3_base = u8_composition_b3_tbl[uv][b2][b3].base;

	return ((uchar_t *)&(u8_composition_final_tbl[uv][b3_base + start_id]));
}

/*
 * The blocked() function checks on the combining class values of previous
 * characters in this sequence and return whether it is blocked or not.
 */
static boolean_t
blocked(uchar_t *comb_class, size_t last)
{
	uchar_t my_comb_class;
	size_t i;

	my_comb_class = comb_class[last];
	for (i = 1; i < last; i++)
		if (comb_class[i] >= my_comb_class ||
		    comb_class[i] == U8_COMBINING_CLASS_STARTER)
			return (B_TRUE);

	return (B_FALSE);
}

/*
 * The do_composition() reads the character string pointed by 's' and
 * do necessary canonical composition and then copy over the result back to
 * the 's'.
 *
 * The input argument 's' cannot contain more than 32 characters.
 */
static size_t
do_composition(size_t uv, uchar_t *s, uchar_t *comb_class, uchar_t *start,
	uchar_t *disp, size_t last, uchar_t **os, uchar_t *oslast)
{
	uchar_t t[U8_STREAM_SAFE_TEXT_MAX + 1];
	uchar_t tc[U8_MB_CUR_MAX];
	uint8_t saved_marks[U8_MAX_CHARS_A_SEQ];
	size_t saved_marks_count;
	uchar_t *p;
	uchar_t *saved_p;
	uchar_t *q;
	size_t i;
	size_t saved_i;
	size_t j;
	size_t k;
	size_t l;
	size_t C;
	size_t saved_l;
	size_t size;
	uint32_t u1;
	uint32_t u2;
	boolean_t match_not_found = B_TRUE;

	/*
	 * This should never happen unless the callers are doing some strange
	 * and unexpected things.
	 *
	 * The "last" is the index pointing to the last character not last + 1.
	 */
	if (last >= U8_MAX_CHARS_A_SEQ)
		last = U8_UPPER_LIMIT_IN_A_SEQ;

	for (i = l = 0; i <= last; i++) {
		/*
		 * The last or any non-Starters at the beginning, we don't
		 * have any chance to do composition and so we just copy them
		 * to the temporary buffer.
		 */
		if (i >= last || comb_class[i] != U8_COMBINING_CLASS_STARTER) {
SAVE_THE_CHAR:
			p = s + start[i];
			size = disp[i];
			for (k = 0; k < size; k++)
				t[l++] = *p++;
			continue;
		}

		/*
		 * If this could be a start of Hangul Jamos, then, we try to
		 * conjoin them.
		 */
		if (s[start[i]] == U8_HANGUL_JAMO_1ST_BYTE) {
			U8_PUT_3BYTES_INTO_UTF32(u1, s[start[i]],
			    s[start[i] + 1], s[start[i] + 2]);
			U8_PUT_3BYTES_INTO_UTF32(u2, s[start[i] + 3],
			    s[start[i] + 4], s[start[i] + 5]);

			if (U8_HANGUL_JAMO_L(u1) && U8_HANGUL_JAMO_V(u2)) {
				u1 -= U8_HANGUL_JAMO_L_FIRST;
				u2 -= U8_HANGUL_JAMO_V_FIRST;
				u1 = U8_HANGUL_SYL_FIRST +
				    (u1 * U8_HANGUL_V_COUNT + u2) *
				    U8_HANGUL_T_COUNT;

				i += 2;
				if (i <= last) {
					U8_PUT_3BYTES_INTO_UTF32(u2,
					    s[start[i]], s[start[i] + 1],
					    s[start[i] + 2]);

					if (U8_HANGUL_JAMO_T(u2)) {
						u1 += u2 -
						    U8_HANGUL_JAMO_T_FIRST;
						i++;
					}
				}

				U8_SAVE_HANGUL_AS_UTF8(t + l, 0, 1, 2, u1);
				i--;
				l += 3;
				continue;
			}
		}

		/*
		 * Let's then find out if this Starter has composition
		 * mapping.
		 */
		p = find_composition_start(uv, s + start[i], disp[i]);
		if (p == NULL)
			goto SAVE_THE_CHAR;

		/*
		 * We have a Starter with composition mapping and the next
		 * character is a non-Starter. Let's try to find out if
		 * we can do composition.
		 */

		saved_p = p;
		saved_i = i;
		saved_l = l;
		saved_marks_count = 0;

TRY_THE_NEXT_MARK:
		q = s + start[++i];
		size = disp[i];

		/*
		 * The next for() loop compares the non-Starter pointed by
		 * 'q' with the possible (joinable) characters pointed by 'p'.
		 *
		 * The composition final table entry pointed by the 'p'
		 * looks like the following:
		 *
		 * +---+---+---+-...-+---+---+---+---+-...-+---+---+
		 * | C | b0| b2| ... | bn| F | B0| B1| ... | Bm| F |
		 * +---+---+---+-...-+---+---+---+---+-...-+---+---+
		 *
		 * where C is the count byte indicating the number of
		 * mapping pairs where each pair would be look like
		 * (b0-bn F, B0-Bm F). The b0-bn are the bytes of the second
		 * character of a canonical decomposition and the B0-Bm are
		 * the bytes of a matching composite character. The F is
		 * a filler byte after each character as the separator.
		 */

		match_not_found = B_TRUE;

		for (C = *p++; C > 0; C--) {
			for (k = 0; k < size; p++, k++)
				if (*p != q[k])
					break;

			/* Have we found it? */
			if (k >= size && *p == U8_TBL_ELEMENT_FILLER) {
				match_not_found = B_FALSE;

				l = saved_l;

				while (*++p != U8_TBL_ELEMENT_FILLER)
					t[l++] = *p;

				break;
			}

			/* We didn't find; skip to the next pair. */
			if (*p != U8_TBL_ELEMENT_FILLER)
				while (*++p != U8_TBL_ELEMENT_FILLER)
					;
			while (*++p != U8_TBL_ELEMENT_FILLER)
				;
			p++;
		}

		/*
		 * If there was no match, we will need to save the combining
		 * mark for later appending. After that, if the next one
		 * is a non-Starter and not blocked, then, we try once
		 * again to do composition with the next non-Starter.
		 *
		 * If there was no match and this was a Starter, then,
		 * this is a new start.
		 *
		 * If there was a match and a composition done and we have
		 * more to check on, then, we retrieve a new composition final
		 * table entry for the composite and then try to do the
		 * composition again.
		 */

		if (match_not_found) {
			if (comb_class[i] == U8_COMBINING_CLASS_STARTER) {
				i--;
				goto SAVE_THE_CHAR;
			}

			saved_marks[saved_marks_count++] = i;
		}

		if (saved_l == l) {
			while (i < last) {
				if (blocked(comb_class, i + 1))
					saved_marks[saved_marks_count++] = ++i;
				else
					break;
			}
			if (i < last) {
				p = saved_p;
				goto TRY_THE_NEXT_MARK;
			}
		} else if (i < last) {
			p = find_composition_start(uv, t + saved_l,
			    l - saved_l);
			if (p != NULL) {
				saved_p = p;
				goto TRY_THE_NEXT_MARK;
			}
		}

		/*
		 * There is no more composition possible.
		 *
		 * If there was no composition what so ever then we copy
		 * over the original Starter and then append any non-Starters
		 * remaining at the target string sequentially after that.
		 */

		if (saved_l == l) {
			p = s + start[saved_i];
			size = disp[saved_i];
			for (j = 0; j < size; j++)
				t[l++] = *p++;
		}

		for (k = 0; k < saved_marks_count; k++) {
			p = s + start[saved_marks[k]];
			size = disp[saved_marks[k]];
			for (j = 0; j < size; j++)
				t[l++] = *p++;
		}
	}

	/*
	 * If the last character is a Starter and if we have a character
	 * (possibly another Starter) that can be turned into a composite,
	 * we do so and we do so until there is no more of composition
	 * possible.
	 */
	if (comb_class[last] == U8_COMBINING_CLASS_STARTER) {
		p = *os;
		saved_l = l - disp[last];

		while (p < oslast) {
			size = u8_number_of_bytes[*p];
			if (size <= 1 || (p + size) > oslast)
				break;

			saved_p = p;

			for (i = 0; i < size; i++)
				tc[i] = *p++;

			q = find_composition_start(uv, t + saved_l,
			    l - saved_l);
			if (q == NULL) {
				p = saved_p;
				break;
			}

			match_not_found = B_TRUE;

			for (C = *q++; C > 0; C--) {
				for (k = 0; k < size; q++, k++)
					if (*q != tc[k])
						break;

				if (k >= size && *q == U8_TBL_ELEMENT_FILLER) {
					match_not_found = B_FALSE;

					l = saved_l;

					while (*++q != U8_TBL_ELEMENT_FILLER) {
						/*
						 * This is practically
						 * impossible but we don't
						 * want to take any chances.
						 */
						if (l >=
						    U8_STREAM_SAFE_TEXT_MAX) {
							p = saved_p;
							goto SAFE_RETURN;
						}
						t[l++] = *q;
					}

					break;
				}

				if (*q != U8_TBL_ELEMENT_FILLER)
					while (*++q != U8_TBL_ELEMENT_FILLER)
						;
				while (*++q != U8_TBL_ELEMENT_FILLER)
					;
				q++;
			}

			if (match_not_found) {
				p = saved_p;
				break;
			}
		}
SAFE_RETURN:
		*os = p;
	}

	/*
	 * Now we copy over the temporary string to the target string.
	 * Since composition always reduces the number of characters or
	 * the number of characters stay, we don't need to worry about
	 * the buffer overflow here.
	 */
	for (i = 0; i < l; i++)
		s[i] = t[i];
	s[l] = '\0';

	return (l);
}

/*
 * The collect_a_seq() function checks on the given string s, collect
 * a sequence of characters at u8s, and return the sequence. While it collects
 * a sequence, it also applies case conversion, canonical or compatibility
 * decomposition, canonical decomposition, or some or all of them and
 * in that order.
 *
 * The collected sequence cannot be bigger than 32 characters since if
 * it is having more than 31 characters, the sequence will be terminated
 * with a U+034F COMBINING GRAPHEME JOINER (CGJ) character and turned into
 * a Stream-Safe Text. The collected sequence is always terminated with
 * a null byte and the return value is the byte length of the sequence
 * including 0. The return value does not include the terminating
 * null byte.
 */
static size_t
collect_a_seq(size_t uv, uchar_t *u8s, uchar_t **source, uchar_t *slast,
	boolean_t is_it_toupper,
	boolean_t is_it_tolower,
	boolean_t canonical_decomposition,
	boolean_t compatibility_decomposition,
	boolean_t canonical_composition,
	int *errnum, u8_normalization_states_t *state)
{
	uchar_t *s;
	int sz;
	int saved_sz;
	size_t i;
	size_t j;
	size_t k;
	size_t l;
	uchar_t comb_class[U8_MAX_CHARS_A_SEQ];
	uchar_t disp[U8_MAX_CHARS_A_SEQ];
	uchar_t start[U8_MAX_CHARS_A_SEQ];
	uchar_t u8t[U8_MB_CUR_MAX];
	uchar_t uts[U8_STREAM_SAFE_TEXT_MAX + 1];
	uchar_t tc;
	size_t last;
	size_t saved_last;
	uint32_t u1;

	/*
	 * Save the source string pointer which we will return a changed
	 * pointer if we do processing.
	 */
	s = *source;

	/*
	 * The following is a fallback for just in case callers are not
	 * checking the string boundaries before the calling.
	 */
	if (s >= slast) {
		u8s[0] = '\0';

		return (0);
	}

	/*
	 * As the first thing, let's collect a character and do case
	 * conversion if necessary.
	 */

	sz = u8_number_of_bytes[*s];

	if (sz < 0) {
		*errnum = EILSEQ;

		u8s[0] = *s++;
		u8s[1] = '\0';

		*source = s;

		return (1);
	}

	if (sz == 1) {
		if (is_it_toupper)
			u8s[0] = U8_ASCII_TOUPPER(*s);
		else if (is_it_tolower)
			u8s[0] = U8_ASCII_TOLOWER(*s);
		else
			u8s[0] = *s;
		s++;
		u8s[1] = '\0';
	} else if ((s + sz) > slast) {
		*errnum = EINVAL;

		for (i = 0; s < slast; )
			u8s[i++] = *s++;
		u8s[i] = '\0';

		*source = s;

		return (i);
	} else {
		if (is_it_toupper || is_it_tolower) {
			i = do_case_conv(uv, u8s, s, sz, is_it_toupper);
			s += sz;
			sz = i;
		} else {
			for (i = 0; i < sz; )
				u8s[i++] = *s++;
			u8s[i] = '\0';
		}
	}

	/*
	 * And then canonical/compatibility decomposition followed by
	 * an optional canonical composition. Please be noted that
	 * canonical composition is done only when a decomposition is
	 * done.
	 */
	if (canonical_decomposition || compatibility_decomposition) {
		if (sz == 1) {
			*state = U8_STATE_START;

			saved_sz = 1;

			comb_class[0] = 0;
			start[0] = 0;
			disp[0] = 1;

			last = 1;
		} else {
			saved_sz = do_decomp(uv, u8s, u8s, sz,
			    canonical_decomposition, state);

			last = 0;

			for (i = 0; i < saved_sz; ) {
				sz = u8_number_of_bytes[u8s[i]];

				comb_class[last] = combining_class(uv,
				    u8s + i, sz);
				start[last] = i;
				disp[last] = sz;

				last++;
				i += sz;
			}

			/*
			 * Decomposition yields various Hangul related
			 * states but not on combining marks. We need to
			 * find out at here by checking on the last
			 * character.
			 */
			if (*state == U8_STATE_START) {
				if (comb_class[last - 1])
					*state = U8_STATE_COMBINING_MARK;
			}
		}

		saved_last = last;

		while (s < slast) {
			sz = u8_number_of_bytes[*s];

			/*
			 * If this is an illegal character, an incomplete
			 * character, or an 7-bit ASCII Starter character,
			 * then we have collected a sequence; break and let
			 * the next call deal with the two cases.
			 *
			 * Note that this is okay only if you are using this
			 * function with a fixed length string, not on
			 * a buffer with multiple calls of one chunk at a time.
			 */
			if (sz <= 1) {
				break;
			} else if ((s + sz) > slast) {
				break;
			} else {
				/*
				 * If the previous character was a Hangul Jamo
				 * and this character is a Hangul Jamo that
				 * can be conjoined, we collect the Jamo.
				 */
				if (*s == U8_HANGUL_JAMO_1ST_BYTE) {
					U8_PUT_3BYTES_INTO_UTF32(u1,
					    *s, *(s + 1), *(s + 2));

					if (U8_HANGUL_COMPOSABLE_L_V(*state,
					    u1)) {
						i = 0;
						*state = U8_STATE_HANGUL_LV;
						goto COLLECT_A_HANGUL;
					}

					if (U8_HANGUL_COMPOSABLE_LV_T(*state,
					    u1)) {
						i = 0;
						*state = U8_STATE_HANGUL_LVT;
						goto COLLECT_A_HANGUL;
					}
				}

				/*
				 * Regardless of whatever it was, if this is
				 * a Starter, we don't collect the character
				 * since that's a new start and we will deal
				 * with it at the next time.
				 */
				i = combining_class(uv, s, sz);
				if (i == U8_COMBINING_CLASS_STARTER)
					break;

				/*
				 * We know the current character is a combining
				 * mark. If the previous character wasn't
				 * a Starter (not Hangul) or a combining mark,
				 * then, we don't collect this combining mark.
				 */
				if (*state != U8_STATE_START &&
				    *state != U8_STATE_COMBINING_MARK)
					break;

				*state = U8_STATE_COMBINING_MARK;
COLLECT_A_HANGUL:
				/*
				 * If we collected a Starter and combining
				 * marks up to 30, i.e., total 31 characters,
				 * then, we terminate this degenerately long
				 * combining sequence with a U+034F COMBINING
				 * GRAPHEME JOINER (CGJ) which is 0xCD 0x8F in
				 * UTF-8 and turn this into a Stream-Safe
				 * Text. This will be extremely rare but
				 * possible.
				 *
				 * The following will also guarantee that
				 * we are not writing more than 32 characters
				 * plus a NULL at u8s[].
				 */
				if (last >= U8_UPPER_LIMIT_IN_A_SEQ) {
TURN_STREAM_SAFE:
					*state = U8_STATE_START;
					comb_class[last] = 0;
					start[last] = saved_sz;
					disp[last] = 2;
					last++;

					u8s[saved_sz++] = 0xCD;
					u8s[saved_sz++] = 0x8F;

					break;
				}

				/*
				 * Some combining marks also do decompose into
				 * another combining mark or marks.
				 */
				if (*state == U8_STATE_COMBINING_MARK) {
					k = last;
					l = sz;
					i = do_decomp(uv, uts, s, sz,
					    canonical_decomposition, state);
					for (j = 0; j < i; ) {
						sz = u8_number_of_bytes[uts[j]];

						comb_class[last] =
						    combining_class(uv,
						    uts + j, sz);
						start[last] = saved_sz + j;
						disp[last] = sz;

						last++;
						if (last >=
						    U8_UPPER_LIMIT_IN_A_SEQ) {
							last = k;
							goto TURN_STREAM_SAFE;
						}
						j += sz;
					}

					*state = U8_STATE_COMBINING_MARK;
					sz = i;
					s += l;

					for (i = 0; i < sz; i++)
						u8s[saved_sz++] = uts[i];
				} else {
					comb_class[last] = i;
					start[last] = saved_sz;
					disp[last] = sz;
					last++;

					for (i = 0; i < sz; i++)
						u8s[saved_sz++] = *s++;
				}

				/*
				 * If this is U+0345 COMBINING GREEK
				 * YPOGEGRAMMENI (0xCD 0x85 in UTF-8), a.k.a.,
				 * iota subscript, and need to be converted to
				 * uppercase letter, convert it to U+0399 GREEK
				 * CAPITAL LETTER IOTA (0xCE 0x99 in UTF-8),
				 * i.e., convert to capital adscript form as
				 * specified in the Unicode standard.
				 *
				 * This is the only special case of (ambiguous)
				 * case conversion at combining marks and
				 * probably the standard will never have
				 * anything similar like this in future.
				 */
				if (is_it_toupper && sz >= 2 &&
				    u8s[saved_sz - 2] == 0xCD &&
				    u8s[saved_sz - 1] == 0x85) {
					u8s[saved_sz - 2] = 0xCE;
					u8s[saved_sz - 1] = 0x99;
				}
			}
		}

		/*
		 * Let's try to ensure a canonical ordering for the collected
		 * combining marks. We do this only if we have collected
		 * at least one more non-Starter. (The decomposition mapping
		 * data tables have fully (and recursively) expanded and
		 * canonically ordered decompositions.)
		 *
		 * The U8_SWAP_COMB_MARKS() convenience macro has some
		 * assumptions and we are meeting the assumptions.
		 */
		last--;
		if (last >= saved_last) {
			for (i = 0; i < last; i++)
				for (j = last; j > i; j--)
					if (comb_class[j] &&
					    comb_class[j - 1] > comb_class[j]) {
						U8_SWAP_COMB_MARKS(j - 1, j);
					}
		}

		*source = s;

		if (! canonical_composition) {
			u8s[saved_sz] = '\0';
			return (saved_sz);
		}

		/*
		 * Now do the canonical composition. Note that we do this
		 * only after a canonical or compatibility decomposition to
		 * finish up NFC or NFKC.
		 */
		sz = do_composition(uv, u8s, comb_class, start, disp, last,
		    &s, slast);
	}

	*source = s;

	return ((size_t)sz);
}

/*
 * The do_norm_compare() function does string comparion based on Unicode
 * simple case mappings and Unicode Normalization definitions.
 *
 * It does so by collecting a sequence of character at a time and comparing
 * the collected sequences from the strings.
 *
 * The meanings on the return values are the same as the usual strcmp().
 */
static int
do_norm_compare(size_t uv, uchar_t *s1, uchar_t *s2, size_t n1, size_t n2,
	int flag, int *errnum)
{
	int result;
	size_t sz1;
	size_t sz2;
	uchar_t u8s1[U8_STREAM_SAFE_TEXT_MAX + 1];
	uchar_t u8s2[U8_STREAM_SAFE_TEXT_MAX + 1];
	uchar_t *s1last;
	uchar_t *s2last;
	boolean_t is_it_toupper;
	boolean_t is_it_tolower;
	boolean_t canonical_decomposition;
	boolean_t compatibility_decomposition;
	boolean_t canonical_composition;
	u8_normalization_states_t state;

	s1last = s1 + n1;
	s2last = s2 + n2;

	is_it_toupper = flag & U8_TEXTPREP_TOUPPER;
	is_it_tolower = flag & U8_TEXTPREP_TOLOWER;
	canonical_decomposition = flag & U8_CANON_DECOMP;
	compatibility_decomposition = flag & U8_COMPAT_DECOMP;
	canonical_composition = flag & U8_CANON_COMP;

	while (s1 < s1last && s2 < s2last) {
		/*
		 * If the current character is a 7-bit ASCII and the last
		 * character, or, if the current character and the next
		 * character are both some 7-bit ASCII characters then
		 * we treat the current character as a sequence.
		 *
		 * In any other cases, we need to call collect_a_seq().
		 */

		if (U8_ISASCII(*s1) && ((s1 + 1) >= s1last ||
		    ((s1 + 1) < s1last && U8_ISASCII(*(s1 + 1))))) {
			if (is_it_toupper)
				u8s1[0] = U8_ASCII_TOUPPER(*s1);
			else if (is_it_tolower)
				u8s1[0] = U8_ASCII_TOLOWER(*s1);
			else
				u8s1[0] = *s1;
			u8s1[1] = '\0';
			sz1 = 1;
			s1++;
		} else {
			state = U8_STATE_START;
			sz1 = collect_a_seq(uv, u8s1, &s1, s1last,
			    is_it_toupper, is_it_tolower,
			    canonical_decomposition,
			    compatibility_decomposition,
			    canonical_composition, errnum, &state);
		}

		if (U8_ISASCII(*s2) && ((s2 + 1) >= s2last ||
		    ((s2 + 1) < s2last && U8_ISASCII(*(s2 + 1))))) {
			if (is_it_toupper)
				u8s2[0] = U8_ASCII_TOUPPER(*s2);
			else if (is_it_tolower)
				u8s2[0] = U8_ASCII_TOLOWER(*s2);
			else
				u8s2[0] = *s2;
			u8s2[1] = '\0';
			sz2 = 1;
			s2++;
		} else {
			state = U8_STATE_START;
			sz2 = collect_a_seq(uv, u8s2, &s2, s2last,
			    is_it_toupper, is_it_tolower,
			    canonical_decomposition,
			    compatibility_decomposition,
			    canonical_composition, errnum, &state);
		}

		/*
		 * Now compare the two characters. If they are the same,
		 * we move on to the next character sequences.
		 */
		if (sz1 == 1 && sz2 == 1) {
			if (*u8s1 > *u8s2)
				return (1);
			if (*u8s1 < *u8s2)
				return (-1);
		} else {
			result = strcmp((const char *)u8s1, (const char *)u8s2);
			if (result != 0)
				return (result);
		}
	}

	/*
	 * We compared until the end of either or both strings.
	 *
	 * If we reached to or went over the ends for the both, that means
	 * they are the same.
	 *
	 * If we reached only one end, that means the other string has
	 * something which then can be used to determine the return value.
	 */
	if (s1 >= s1last) {
		if (s2 >= s2last)
			return (0);
		return (-1);
	}
	return (1);
}

/*
 * The u8_strcmp() function compares two UTF-8 strings quite similar to
 * the strcmp(). For the comparison, however, Unicode Normalization specific
 * equivalency and Unicode simple case conversion mappings based equivalency
 * can be requested and checked against.
 */
int
u8_strcmp(const char *s1, const char *s2, size_t n, int flag, size_t uv,
		int *errnum)
{
	int f;
	size_t n1;
	size_t n2;

	*errnum = 0;

	/*
	 * Check on the requested Unicode version, case conversion, and
	 * normalization flag values.
	 */

	if (uv > U8_UNICODE_LATEST) {
		*errnum = ERANGE;
		uv = U8_UNICODE_LATEST;
	}

	if (flag == 0) {
		flag = U8_STRCMP_CS;
	} else {
		f = flag & (U8_STRCMP_CS | U8_STRCMP_CI_UPPER |
		    U8_STRCMP_CI_LOWER);
		if (f == 0) {
			flag |= U8_STRCMP_CS;
		} else if (f != U8_STRCMP_CS && f != U8_STRCMP_CI_UPPER &&
		    f != U8_STRCMP_CI_LOWER) {
			*errnum = EBADF;
			flag = U8_STRCMP_CS;
		}

		f = flag & (U8_CANON_DECOMP | U8_COMPAT_DECOMP | U8_CANON_COMP);
		if (f && f != U8_STRCMP_NFD && f != U8_STRCMP_NFC &&
		    f != U8_STRCMP_NFKD && f != U8_STRCMP_NFKC) {
			*errnum = EBADF;
			flag = U8_STRCMP_CS;
		}
	}

	if (flag == U8_STRCMP_CS) {
		return (n == 0 ? strcmp(s1, s2) : strncmp(s1, s2, n));
	}

	n1 = strlen(s1);
	n2 = strlen(s2);
	if (n != 0) {
		if (n < n1)
			n1 = n;
		if (n < n2)
			n2 = n;
	}

	/*
	 * Simple case conversion can be done much faster and so we do
	 * them separately here.
	 */
	if (flag == U8_STRCMP_CI_UPPER) {
		return (do_case_compare(uv, (uchar_t *)s1, (uchar_t *)s2,
		    n1, n2, B_TRUE, errnum));
	} else if (flag == U8_STRCMP_CI_LOWER) {
		return (do_case_compare(uv, (uchar_t *)s1, (uchar_t *)s2,
		    n1, n2, B_FALSE, errnum));
	}

	return (do_norm_compare(uv, (uchar_t *)s1, (uchar_t *)s2, n1, n2,
	    flag, errnum));
}

size_t
u8_textprep_str(char *inarray, size_t *inlen, char *outarray, size_t *outlen,
	int flag, size_t unicode_version, int *errnum)
{
	int f;
	int sz;
	uchar_t *ib;
	uchar_t *ibtail;
	uchar_t *ob;
	uchar_t *obtail;
	boolean_t do_not_ignore_null;
	boolean_t do_not_ignore_invalid;
	boolean_t is_it_toupper;
	boolean_t is_it_tolower;
	boolean_t canonical_decomposition;
	boolean_t compatibility_decomposition;
	boolean_t canonical_composition;
	size_t ret_val;
	size_t i;
	size_t j;
	uchar_t u8s[U8_STREAM_SAFE_TEXT_MAX + 1];
	u8_normalization_states_t state;

	if (unicode_version > U8_UNICODE_LATEST) {
		*errnum = ERANGE;
		return ((size_t)-1);
	}

	f = flag & (U8_TEXTPREP_TOUPPER | U8_TEXTPREP_TOLOWER);
	if (f == (U8_TEXTPREP_TOUPPER | U8_TEXTPREP_TOLOWER)) {
		*errnum = EBADF;
		return ((size_t)-1);
	}

	f = flag & (U8_CANON_DECOMP | U8_COMPAT_DECOMP | U8_CANON_COMP);
	if (f && f != U8_TEXTPREP_NFD && f != U8_TEXTPREP_NFC &&
	    f != U8_TEXTPREP_NFKD && f != U8_TEXTPREP_NFKC) {
		*errnum = EBADF;
		return ((size_t)-1);
	}

	if (inarray == NULL || *inlen == 0)
		return (0);

	if (outarray == NULL) {
		*errnum = E2BIG;
		return ((size_t)-1);
	}

	ib = (uchar_t *)inarray;
	ob = (uchar_t *)outarray;
	ibtail = ib + *inlen;
	obtail = ob + *outlen;

	do_not_ignore_null = !(flag & U8_TEXTPREP_IGNORE_NULL);
	do_not_ignore_invalid = !(flag & U8_TEXTPREP_IGNORE_INVALID);
	is_it_toupper = flag & U8_TEXTPREP_TOUPPER;
	is_it_tolower = flag & U8_TEXTPREP_TOLOWER;

	ret_val = 0;

	/*
	 * If we don't have a normalization flag set, we do the simple case
	 * conversion based text preparation separately below. Text
	 * preparation involving Normalization will be done in the false task
	 * block, again, separately since it will take much more time and
	 * resource than doing simple case conversions.
	 */
	if (f == 0) {
		while (ib < ibtail) {
			if (*ib == '\0' && do_not_ignore_null)
				break;

			sz = u8_number_of_bytes[*ib];

			if (sz < 0) {
				if (do_not_ignore_invalid) {
					*errnum = EILSEQ;
					ret_val = (size_t)-1;
					break;
				}

				sz = 1;
				ret_val++;
			}

			if (sz == 1) {
				if (ob >= obtail) {
					*errnum = E2BIG;
					ret_val = (size_t)-1;
					break;
				}

				if (is_it_toupper)
					*ob = U8_ASCII_TOUPPER(*ib);
				else if (is_it_tolower)
					*ob = U8_ASCII_TOLOWER(*ib);
				else
					*ob = *ib;
				ib++;
				ob++;
			} else if ((ib + sz) > ibtail) {
				if (do_not_ignore_invalid) {
					*errnum = EINVAL;
					ret_val = (size_t)-1;
					break;
				}

				if ((obtail - ob) < (ibtail - ib)) {
					*errnum = E2BIG;
					ret_val = (size_t)-1;
					break;
				}

				/*
				 * We treat the remaining incomplete character
				 * bytes as a character.
				 */
				ret_val++;

				while (ib < ibtail)
					*ob++ = *ib++;
			} else {
				if (is_it_toupper || is_it_tolower) {
					i = do_case_conv(unicode_version, u8s,
					    ib, sz, is_it_toupper);

					if ((obtail - ob) < i) {
						*errnum = E2BIG;
						ret_val = (size_t)-1;
						break;
					}

					ib += sz;

					for (sz = 0; sz < i; sz++)
						*ob++ = u8s[sz];
				} else {
					if ((obtail - ob) < sz) {
						*errnum = E2BIG;
						ret_val = (size_t)-1;
						break;
					}

					for (i = 0; i < sz; i++)
						*ob++ = *ib++;
				}
			}
		}
	} else {
		canonical_decomposition = flag & U8_CANON_DECOMP;
		compatibility_decomposition = flag & U8_COMPAT_DECOMP;
		canonical_composition = flag & U8_CANON_COMP;

		while (ib < ibtail) {
			if (*ib == '\0' && do_not_ignore_null)
				break;

			/*
			 * If the current character is a 7-bit ASCII
			 * character and it is the last character, or,
			 * if the current character is a 7-bit ASCII
			 * character and the next character is also a 7-bit
			 * ASCII character, then, we copy over this
			 * character without going through collect_a_seq().
			 *
			 * In any other cases, we need to look further with
			 * the collect_a_seq() function.
			 */
			if (U8_ISASCII(*ib) && ((ib + 1) >= ibtail ||
			    ((ib + 1) < ibtail && U8_ISASCII(*(ib + 1))))) {
				if (ob >= obtail) {
					*errnum = E2BIG;
					ret_val = (size_t)-1;
					break;
				}

				if (is_it_toupper)
					*ob = U8_ASCII_TOUPPER(*ib);
				else if (is_it_tolower)
					*ob = U8_ASCII_TOLOWER(*ib);
				else
					*ob = *ib;
				ib++;
				ob++;
			} else {
				*errnum = 0;
				state = U8_STATE_START;

				j = collect_a_seq(unicode_version, u8s,
				    &ib, ibtail,
				    is_it_toupper,
				    is_it_tolower,
				    canonical_decomposition,
				    compatibility_decomposition,
				    canonical_composition,
				    errnum, &state);

				if (*errnum && do_not_ignore_invalid) {
					ret_val = (size_t)-1;
					break;
				}

				if ((obtail - ob) < j) {
					*errnum = E2BIG;
					ret_val = (size_t)-1;
					break;
				}

				for (i = 0; i < j; i++)
					*ob++ = u8s[i];
			}
		}
	}

	*inlen = ibtail - ib;
	*outlen = obtail - ob;

	return (ret_val);
}

#if defined(_KERNEL) && defined(HAVE_SPL)
static int __init
unicode_init(void) {
	return (0);
}

static void __exit
unicode_fini(void)
{
}

module_init(unicode_init);
module_exit(unicode_fini);

MODULE_DESCRIPTION("Unicode implementation");
MODULE_AUTHOR(ZFS_META_AUTHOR);
MODULE_LICENSE(ZFS_META_LICENSE);
MODULE_VERSION(ZFS_META_VERSION "-" ZFS_META_RELEASE);

EXPORT_SYMBOL(u8_validate);
EXPORT_SYMBOL(u8_strcmp);
EXPORT_SYMBOL(u8_textprep_str);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                 usr/src/zfs-0.6.5.9/module/unicode/uconv.c                                                          0100644 0000000 0000000 00000056105 13045370707 016510  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */



/*
 * Unicode encoding conversion functions among UTF-8, UTF-16, and UTF-32.
 * (PSARC/2005/446, PSARC/2007/038, PSARC/2007/517)
 * Man pages: uconv_u16tou32(9F), uconv_u16tou8(9F), uconv_u32tou16(9F),
 * uconv_u32tou8(9F), uconv_u8tou16(9F), and uconv_u8tou32(9F). See also
 * the section 3C man pages.
 * Interface stability: Committed
 */

#include <sys/types.h>
#ifdef	_KERNEL
#include <sys/param.h>
#include <sys/sysmacros.h>
#include <sys/systm.h>
#include <sys/debug.h>
#include <sys/kmem.h>
#include <sys/sunddi.h>
#else
#include <sys/u8_textprep.h>
#endif	/* _KERNEL */
#include <sys/byteorder.h>
#include <sys/errno.h>


/*
 * The max and min values of high and low surrogate pairs of UTF-16,
 * UTF-16 bit shift value, bit mask, and starting value outside of BMP.
 */
#define	UCONV_U16_HI_MIN	(0xd800U)
#define	UCONV_U16_HI_MAX	(0xdbffU)
#define	UCONV_U16_LO_MIN	(0xdc00U)
#define	UCONV_U16_LO_MAX	(0xdfffU)
#define	UCONV_U16_BIT_SHIFT	(0x0400U)
#define	UCONV_U16_BIT_MASK	(0x0fffffU)
#define	UCONV_U16_START		(0x010000U)

/* The maximum value of Unicode coding space and ASCII coding space. */
#define	UCONV_UNICODE_MAX	(0x10ffffU)
#define	UCONV_ASCII_MAX		(0x7fU)

/* The mask values for input and output endians. */
#define	UCONV_IN_ENDIAN_MASKS	(UCONV_IN_BIG_ENDIAN | UCONV_IN_LITTLE_ENDIAN)
#define	UCONV_OUT_ENDIAN_MASKS	(UCONV_OUT_BIG_ENDIAN | UCONV_OUT_LITTLE_ENDIAN)

/* Native and reversed endian macros. */
#ifdef	_BIG_ENDIAN
#define	UCONV_IN_NAT_ENDIAN	UCONV_IN_BIG_ENDIAN
#define	UCONV_IN_REV_ENDIAN	UCONV_IN_LITTLE_ENDIAN
#define	UCONV_OUT_NAT_ENDIAN	UCONV_OUT_BIG_ENDIAN
#define	UCONV_OUT_REV_ENDIAN	UCONV_OUT_LITTLE_ENDIAN
#else
#define	UCONV_IN_NAT_ENDIAN	UCONV_IN_LITTLE_ENDIAN
#define	UCONV_IN_REV_ENDIAN	UCONV_IN_BIG_ENDIAN
#define	UCONV_OUT_NAT_ENDIAN	UCONV_OUT_LITTLE_ENDIAN
#define	UCONV_OUT_REV_ENDIAN	UCONV_OUT_BIG_ENDIAN
#endif	/* _BIG_ENDIAN */

/* The Byte Order Mark (BOM) character in normal and reversed byte orderings. */
#define	UCONV_BOM_NORMAL	(0xfeffU)
#define	UCONV_BOM_SWAPPED	(0xfffeU)
#define	UCONV_BOM_SWAPPED_32	(0xfffe0000U)

/* UTF-32 boundaries based on UTF-8 character byte lengths. */
#define	UCONV_U8_ONE_BYTE	(0x7fU)
#define	UCONV_U8_TWO_BYTES	(0x7ffU)
#define	UCONV_U8_THREE_BYTES	(0xffffU)
#define	UCONV_U8_FOUR_BYTES	(0x10ffffU)

/* The common minimum and maximum values at the UTF-8 character bytes. */
#define	UCONV_U8_BYTE_MIN	(0x80U)
#define	UCONV_U8_BYTE_MAX	(0xbfU)

/*
 * The following "6" and "0x3f" came from "10xx xxxx" bit representation of
 * UTF-8 character bytes.
 */
#define	UCONV_U8_BIT_SHIFT	6
#define	UCONV_U8_BIT_MASK	0x3f

/*
 * The following vector shows remaining bytes in a UTF-8 character.
 * Index will be the first byte of the character.
 */
static const uchar_t remaining_bytes_tbl[0x100] = {
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,

/*	C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF */
	0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

/*	D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF */
	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

/*	E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF */
	2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,

/*	F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF */
	3,  3,  3,  3,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
};

/*
 * The following is a vector of bit-masks to get used bits in
 * the first byte of a UTF-8 character.  Index is remaining bytes at above of
 * the character.
 */
#ifdef	_KERNEL
const uchar_t u8_masks_tbl[6] = { 0x00, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
#else
static const uchar_t u8_masks_tbl[6] = { 0x00, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
#endif	/* _KERNEL */

/*
 * The following two vectors are to provide valid minimum and
 * maximum values for the 2'nd byte of a multibyte UTF-8 character for
 * better illegal sequence checking. The index value must be the value of
 * the first byte of the UTF-8 character.
 */
static const uchar_t valid_min_2nd_byte[0x100] = {
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,

/*	C0    C1    C2    C3    C4    C5    C6    C7 */
	0,    0,    0x80, 0x80, 0x80, 0x80, 0x80, 0x80,

/*	C8    C9    CA    CB    CC    CD    CE    CF */
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,

/*	D0    D1    D2    D3    D4    D5    D6    D7 */
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,

/*	D8    D9    DA    DB    DC    DD    DE    DF */
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,

/*	E0    E1    E2    E3    E4    E5    E6    E7 */
	0xa0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,

/*	E8    E9    EA    EB    EC    ED    EE    EF */
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,

/*	F0    F1    F2    F3    F4    F5    F6    F7 */
	0x90, 0x80, 0x80, 0x80, 0x80, 0,    0,    0,

	0,    0,    0,    0,    0,    0,    0,    0
};

static const uchar_t valid_max_2nd_byte[0x100] = {
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,
	0,    0,    0,    0,    0,    0,    0,    0,

/*	C0    C1    C2    C3    C4    C5    C6    C7 */
	0,    0,    0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,

/*	C8    C9    CA    CB    CC    CD    CE    CF */
	0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,

/*	D0    D1    D2    D3    D4    D5    D6    D7 */
	0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,

/*	D8    D9    DA    DB    DC    DD    DE    DF */
	0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,

/*	E0    E1    E2    E3    E4    E5    E6    E7 */
	0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,

/*	E8    E9    EA    EB    EC    ED    EE    EF */
	0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0x9f, 0xbf, 0xbf,

/*	F0    F1    F2    F3    F4    F5    F6    F7 */
	0xbf, 0xbf, 0xbf, 0xbf, 0x8f, 0,    0,    0,

	0,    0,    0,    0,    0,    0,    0,    0
};


static int
check_endian(int flag, int *in, int *out)
{
	*in = flag & UCONV_IN_ENDIAN_MASKS;

	/* You cannot have both. */
	if (*in == UCONV_IN_ENDIAN_MASKS)
		return (EBADF);

	if (*in == 0)
		*in = UCONV_IN_NAT_ENDIAN;

	*out = flag & UCONV_OUT_ENDIAN_MASKS;

	/* You cannot have both. */
	if (*out == UCONV_OUT_ENDIAN_MASKS)
		return (EBADF);

	if (*out == 0)
		*out = UCONV_OUT_NAT_ENDIAN;

	return (0);
}

static boolean_t
check_bom16(const uint16_t *u16s, size_t u16l, int *in)
{
	if (u16l > 0) {
		if (*u16s == UCONV_BOM_NORMAL) {
			*in = UCONV_IN_NAT_ENDIAN;
			return (B_TRUE);
		}
		if (*u16s == UCONV_BOM_SWAPPED) {
			*in = UCONV_IN_REV_ENDIAN;
			return (B_TRUE);
		}
	}

	return (B_FALSE);
}

static boolean_t
check_bom32(const uint32_t *u32s, size_t u32l, int *in)
{
	if (u32l > 0) {
		if (*u32s == UCONV_BOM_NORMAL) {
			*in = UCONV_IN_NAT_ENDIAN;
			return (B_TRUE);
		}
		if (*u32s == UCONV_BOM_SWAPPED_32) {
			*in = UCONV_IN_REV_ENDIAN;
			return (B_TRUE);
		}
	}

	return (B_FALSE);
}

int
uconv_u16tou32(const uint16_t *u16s, size_t *utf16len,
    uint32_t *u32s, size_t *utf32len, int flag)
{
	int inendian;
	int outendian;
	size_t u16l;
	size_t u32l;
	uint32_t hi;
	uint32_t lo;
	boolean_t do_not_ignore_null;

	/*
	 * Do preliminary validity checks on parameters and collect info on
	 * endians.
	 */
	if (u16s == NULL || utf16len == NULL)
		return (EILSEQ);

	if (u32s == NULL || utf32len == NULL)
		return (E2BIG);

	if (check_endian(flag, &inendian, &outendian) != 0)
		return (EBADF);

	/*
	 * Initialize input and output parameter buffer indices and
	 * temporary variables.
	 */
	u16l = u32l = 0;
	hi = 0;
	do_not_ignore_null = ((flag & UCONV_IGNORE_NULL) == 0);

	/*
	 * Check on the BOM at the beginning of the input buffer if required
	 * and if there is indeed one, process it.
	 */
	if ((flag & UCONV_IN_ACCEPT_BOM) &&
	    check_bom16(u16s, *utf16len, &inendian))
		u16l++;

	/*
	 * Reset inendian and outendian so that after this point, those can be
	 * used as condition values.
	 */
	inendian &= UCONV_IN_NAT_ENDIAN;
	outendian &= UCONV_OUT_NAT_ENDIAN;

	/*
	 * If there is something in the input buffer and if necessary and
	 * requested, save the BOM at the output buffer.
	 */
	if (*utf16len > 0 && *utf32len > 0 && (flag & UCONV_OUT_EMIT_BOM))
		u32s[u32l++] = (outendian) ? UCONV_BOM_NORMAL :
		    UCONV_BOM_SWAPPED_32;

	/*
	 * Do conversion; if encounter a surrogate pair, assemble high and
	 * low pair values to form a UTF-32 character. If a half of a pair
	 * exists alone, then, either it is an illegal (EILSEQ) or
	 * invalid (EINVAL) value.
	 */
	for (; u16l < *utf16len; u16l++) {
		if (u16s[u16l] == 0 && do_not_ignore_null)
			break;

		lo = (uint32_t)((inendian) ? u16s[u16l] : BSWAP_16(u16s[u16l]));

		if (lo >= UCONV_U16_HI_MIN && lo <= UCONV_U16_HI_MAX) {
			if (hi)
				return (EILSEQ);
			hi = lo;
			continue;
		} else if (lo >= UCONV_U16_LO_MIN && lo <= UCONV_U16_LO_MAX) {
			if (! hi)
				return (EILSEQ);
			lo = (((hi - UCONV_U16_HI_MIN) * UCONV_U16_BIT_SHIFT +
			    lo - UCONV_U16_LO_MIN) & UCONV_U16_BIT_MASK)
			    + UCONV_U16_START;
			hi = 0;
		} else if (hi) {
			return (EILSEQ);
		}

		if (u32l >= *utf32len)
			return (E2BIG);

		u32s[u32l++] = (outendian) ? lo : BSWAP_32(lo);
	}

	/*
	 * If high half didn't see low half, then, it's most likely the input
	 * para