gs, version))
            if hits:
                result[po] = hits
        if name[0] == '/':
            hit = (name, None, (None, None, None))
            for po in self.searchFiles(name):
                result.setdefault(po, []).append(hit)
        return result

    def getRequires(self, name, flags=None, version=(None, None, None)):
        """return dict { packages -> list of matching requires }"""
        self._checkIndexes(failure='build')
        if version is None:
            version = (None, None, None)
        elif type(version) in (str, type(None), unicode):
            version = rpmUtils.miscutils.stringToVersion(version)
        result = { }
        for po in self.requires.get(name, []):
            hits = po.matchingPrcos('requires', (name, flags, version))
            if hits:
                result[po] = hits
        return result

    def searchPrco(self, name, prcotype):
        self._checkIndexes(failure='build')
        prcodict = getattr(self, prcotype)
        (n,f,(e,v,r)) = misc.string_to_prco_tuple(name)
        
        basic_results = []
        results = []
        if n in prcodict:
            basic_results.extend(prcodict[n])

        for po in basic_results:
            if po.checkPrco(prcotype, (n, f, (e,v,r))):
                results.append(po)

        if prcotype != "provides":
            return results
            
        if not misc.re_filename(n):
            return results

        results.extend(self.searchFiles(n))
        return misc.unique(results)

            
    def searchRequires(self, name):
        """return list of package requiring the item requested"""

        return self.searchPrco(name, 'requires')

    def searchProvides(self, name):
        """return list of package providing the item requested"""
        
        return self.searchPrco(name, 'provides')

    def searchConflicts(self, name):
        """return list of package conflicting with item requested"""
        
        return self.searchPrco(name, 'conflicts')
        
    def searchObsoletes(self, name):
        """return list of package obsoleting the item requested"""

        return self.searchPrco(name, 'obsoletes')
        
    def returnObsoletes(self, newest=False):
        """returns a dict of obsoletes dict[obsoleting pkgtuple] = [list of obs]"""
        obs = {}
        for po in self.returnPackages():
            if len(po.obsoletes) == 0:
                continue
            obs.setdefault(po.pkgtup, []).extend(po.obsoletes)

        if not newest:
            return obs

        # FIXME - this is slooooooooooooooooooooooooooooooow
        # get the dict back
        newest_tups = set((pkg.pkgtup for pkg in self.returnNewestByName()))

        # go through each of the keys of the obs dict and see if it is in the
        # sack of newest pkgs - if it is not - remove the entry
        togo = []
        for obstup in obs:
            if obstup not in newest_tups:
                togo.append(obstup)
        for obstup in togo:
            del obs[obstup]
            
        return obs
        
    def have_fastReturnFileEntries(self):
        """ Is calling pkg.returnFileEntries(primary_only=True) faster than
            using searchFiles(). """
        return True

    def searchFiles(self, name):
        """ Return list of packages by filename. """
        self._checkIndexes(failure='build')
        if name in self.filenames:
            return self.filenames[name]
        else:
            return []

    def _addToDictAsList(self, dict, key, data):
        if key not in dict:
            dict[key] = []
        #if data not in dict[key]: - if I enable this the whole world grinds to a halt
        # need a faster way of looking for the object in any particular list
        dict[key].append(data)

    def _delFromListOfDict(self, dict, key, data):
        if key not in dict:
            return
        try:
            dict[key].remove(data)
        except ValueError:
            pass
            
        if len(dict[key]) == 0: # if it's an empty list of the dict, then kill it
            del dict[key]
            
            
    def addPackage(self, obj):
        """add a pkgobject to the packageSack"""

        repoid = obj.repoid
        (name, arch, epoch, ver, rel) = obj.pkgtup
        
        if not self.compatarchs or arch in self.compatarchs:
            self._addToDictAsList(self.pkgsByRepo, repoid, obj)
        if self.indexesBuilt:
            self._addPackageToIndex(obj)

    def buildIndexes(self):
        """builds the useful indexes for searching/querying the packageSack
           This should be called after all the necessary packages have been 
           added/deleted"""

        self.clearIndexes()
        
        for repoid in self.pkgsByRepo:
            for obj in self.pkgsByRepo[repoid]:
                self._addPackageToIndex(obj)
        self.indexesBuilt = 1


    def clearIndexes(self):
        # blank out the indexes
        self.obsoletes = {}
        self.requires = {}
        self.provides = {}
        self.conflicts = {}
        self.filenames = {}
        self.nevra = {}
        self.pkgsByID = {}

        self.indexesBuilt = 0
        
    def _addPackageToIndex(self, obj):
        # store the things provided just on name, not the whole require+version
        # this lets us reduce the set of pkgs to search when we're trying to depSolve
        for (n, fl, (e,v,r)) in obj.returnPrco('obsoletes'):
            self._addToDictAsList(self.obsoletes, n, obj)
        for (n, fl, (e,v,r)) in obj.returnPrco('requires'):
            self._addToDictAsList(self.requires, n, obj)
        for (n, fl, (e,v,r)) in obj.returnPrco('provides'):
            self._addToDictAsList(self.provides, n, obj)
        for (n, fl, (e,v,r)) in obj.returnPrco('conflicts'):
            self._addToDictAsList(self.conflicts, n, obj)
        for ftype in obj.returnFileTypes():
            for file in obj.returnFileEntries(ftype):
                self._addToDictAsList(self.filenames, file, obj)
        self._addToDictAsList(self.pkgsByID, obj.id, obj)
        (name, arch, epoch, ver, rel) = obj.pkgtup
        self._addToDictAsList(self.nevra, (name, epoch, ver, rel, arch), obj)
        self._addToDictAsList(self.nevra, (name, None, None, None, None), obj)

    def _delPackageFromIndex(self, obj):
        for (n, fl, (e,v,r)) in obj.returnPrco('obsoletes'):
            self._delFromListOfDict(self.obsoletes, n, obj)
        for (n, fl, (e,v,r)) in obj.returnPrco('requires'):
            self._delFromListOfDict(self.requires, n, obj)
        for (n, fl, (e,v,r)) in obj.returnPrco('provides'):
            self._delFromListOfDict(self.provides, n, obj)
        for (n, fl, (e,v,r)) in obj.returnPrco('conflicts'):
            self._delFromListOfDict(self.conflicts, n, obj)
        for ftype in obj.returnFileTypes():
            for file in obj.returnFileEntries(ftype):
                self._delFromListOfDict(self.filenames, file, obj)
        self._delFromListOfDict(self.pkgsByID, obj.id, obj)
        (name, arch, epoch, ver, rel) = obj.pkgtup
        self._delFromListOfDict(self.nevra, (name, epoch, ver, rel, arch), obj)
        self._delFromListOfDict(self.nevra, (name, None, None, None, None), obj)
        
    def delPackage(self, obj):
        """delete a pkgobject"""
        self._delFromListOfDict(self.pkgsByRepo, obj.repoid, obj)
        if self.indexesBuilt: 
            self._delPackageFromIndex(obj)
        
    def returnPackages(self, repoid=None, patterns=None, ignore_case=False):
        """return list of all packages, takes optional repoid"""
        returnList = []
        if repoid is None:
            for repo in self.pkgsByRepo:
                returnList.extend(self.pkgsByRepo[repo])
        else:
            try:
                returnList = self.pkgsByRepo[repoid]
            except KeyError:
                # nothing to return
                pass
        
        if patterns:
            returnList = parsePackages(returnList, patterns, not ignore_case,
                                       unique='repo-pkgkey')
            returnList = returnList[0] + returnList[1]
        return returnList

    def returnNewestByNameArch(self, naTup=None,
                               patterns=None, ignore_case=False):
        """return list of newest packages based on name, arch matching
           this means(in name.arch form): foo.i386 and foo.noarch are not 
           compared to each other for highest version only foo.i386 and 
           foo.i386 will be compared
           Note that given: foo-1.i386; foo-2.i386 and foo-3.x86_64
           The last _two_ pkgs will be returned, not just one of them. """

        highdict = {}
        # If naTup is set, only iterate through packages that match that
        # name
        if (naTup):
            self._checkIndexes(failure='build')
            where = self.nevra.get((naTup[0],None,None,None,None))
            if (not where):
                raise PackageSackError, 'No Package Matching %s.%s' % naTup
        else:
            where = self.returnPackages(patterns=patterns,
                                        ignore_case=ignore_case)

        for pkg in where:
            if (pkg.name, pkg.arch) not in highdict:
                highdict[(pkg.name, pkg.arch)] = pkg
            else:
                pkg2 = highdict[(pkg.name, pkg.arch)]
                if pkg.verGT(pkg2):
                    highdict[(pkg.name, pkg.arch)] = pkg
        
        if naTup:
            if naTup in highdict:
                return [highdict[naTup]]
            else:
                raise PackageSackError, 'No Package Matching %s.%s' % naTup
        
        return highdict.values()
        
    def returnNewestByName(self, name=None, patterns=None, ignore_case=False):
        """return list of newest packages based on name matching
           this means(in name.arch form): foo.i386 and foo.noarch will
           be compared to each other for highest version."""

        highdict = {}
        if patterns is None and name is not None:
            pkgs = self.searchNevra(name=name)
        else:
            pkgs = self.returnPackages(patterns=patterns,
                                       ignore_case=ignore_case)

        for pkg in pkgs:
            if pkg.name not in highdict:
                highdict[pkg.name] = [pkg]
            else:
                pkg2 = highdict[pkg.name][0]
                if pkg.verGT(pkg2):
                    highdict[pkg.name] = [pkg]
                if pkg.verEQ(pkg2):
                    highdict[pkg.name].append(pkg)
                
        if name:
            if name in highdict:
                return highdict[name]
            else:
                raise PackageSackError, 'No Package Matching  %s' % name
        
        #this is a list of lists - break it back out into a single list
        returnlist = []
        for polst in highdict.values():
            for po in polst:
                returnlist.append(po)

        return returnlist
           
    def simplePkgList(self, patterns=None, ignore_case=False):
        """returns a list of pkg tuples (n, a, e, v, r) optionally from a single repoid"""
        
        # Don't cache due to excludes
        return [pkg.pkgtup for pkg in self.returnPackages(patterns=patterns,
                                                          ignore_case=False)]
                       
    def printPackages(self):
        for pkg in self.returnPackages():
            print pkg

    def excludeArchs(self, archlist):
        """exclude incompatible arches. archlist is a list of compatible arches"""
        
        for pkg in self.returnPackages():
            if pkg.arch not in archlist:
                self.delPackage(pkg)

    def searchPackages(self, fields, criteria_re, callback):
        matches = {}

        for po in self.returnPackages():
            tmpvalues = []
            for field in fields:
                value = getattr(po, field)
                if value and criteria_re.search(value):
                    tmpvalues.append(value)
            if len(tmpvalues) > 0:
                if callback:
                    callback(po, tmpvalues)
                matches[po] = tmpvalues
 
        return matches

def packagesNewestByName(pkgs):
    """ Does the same as PackageSack.returnNewestByName().
        Note that given: foo-1.i386; foo-2.i386 and foo-3.x86_64"""
    newest = {}
    for pkg in pkgs:
        key = pkg.name

        # Can't use pkg.__cmp__ because it takes .arch into account
        cval = 1
        if key in newest:
            cval = pkg.verCMP(newest[key][0])
        if cval > 0:
            newest[key] = [pkg]
        elif cval == 0:
            newest[key].append(pkg)
    ret = []
    for vals in newest.itervalues():
        ret.extend(vals)
    return ret
def packagesNewestByNameArch(pkgs):
    """ Does the same as PackageSack.returnNewestByNameArch()
        The last _two_ pkgs will be returned, not just one of them."""
    newest = {}
    for pkg in pkgs:
        key = (pkg.name, pkg.arch)
        if key in newest and pkg.verLE(newest[key]):
            continue
        newest[key] = pkg
    return newest.values()

class ListPackageSack(PackageSack):
    """Derived class from PackageSack to build new Sack from list of
       pkgObjects - like one returned from self.returnNewestByNameArch()
       or self.returnNewestByName()"""
       
    def __init__(self, Objlist=None):
        PackageSack.__init__(self)
        if Objlist is not None:
            self.addList(Objlist)
    
    def addList(self, ObjList):
        for pkgobj in ObjList:
            self.addPackage(pkgobj)
    
                                                                                                         usr/lib/python2.7/dist-packages/yum/packageSack.pyc                                                 0100644 0000000 0000000 00000123734 13077704344 020662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   sÛ   d  Z  d d l m Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l	 Z
 d d l	 m Z d f  d Ñ  É  YZ d e f d	 Ñ  É  YZ d
 e f d Ñ  É  YZ d e f d Ñ  É  YZ d Ñ  Z d Ñ  Z d e f d Ñ  É  YZ d S(   s;   
Classes for manipulating and querying groups of packages.
iˇˇˇˇ(   t   PackageSackErrorN(   t   parsePackages(   t
   compareEVRt   PackageSackVersionc           B   s5   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s"   d |  _  t j d g É |  _ d  S(   Ni    t   sha1(   t   _numt   misct	   Checksumst   _chksum(   t   self(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   __init__   s    	c         C   s   d |  j  |  j j É  f S(   Ns   %u:%s(   R   R   t	   hexdigest(   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   __str__#   s    c         C   sÄ   | d  k r t St | É t d É t d É f k rD t |  É | k S|  j | j k rZ t S|  j j É  | j j É  k r| t St S(   Nt    u    (   t   Nonet   Falset   typet   strR   R   t   digestt   True(   R	   t   other(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   __eq__&   s     $  c         C   s   |  | k S(   N(    (   R	   R   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   __ne__-   s    c         C   s`   |  j  d 7_  |  j j t | É É | d  k	 r\ |  j j | d É |  j j | d É n  d  S(   Ni   i    (   R   R   t   updateR   R   (   R	   t   pkgt   csum(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR   0   s
    (   t   __name__t
   __module__R
   R   R   R   R   (    (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR      s
   				t   PackageSackBasec           B   s≤  e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d% d% d% d% d% d Ñ Z g  e d	 Ñ Z d
 Ñ  Z d Ñ  Z d% d% d% d% d% d% d Ñ Z d% d& d Ñ Z d% d' d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d% d% e d Ñ Z d Ñ  Z e i  d Ñ Z d% d% e d Ñ Z  d% d% e d Ñ Z! d% e d Ñ Z" d Ñ  Z# d  Ñ  Z$ d! Ñ  Z% d" Ñ  Z& d# Ñ  Z' d% d$ Ñ Z( RS((   s8   Base class that provides the interface for PackageSacks.c         C   s   i  |  _  d  S(   N(   t   added(   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR
   :   s    c         C   s   t  |  j É  É S(   N(   t   lent   returnPackages(   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   __len__=   s    c         C   s3   |  j  É  } t | d É r% | j É  St | É Sd  S(   Nt   __iter__(   R   t   hasattrR!   t   iter(   R	   t   ret(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR!   @   s    
c         C   s£   | d  k r d St |  j É } t | j É } t | É t | É k rZ t | É t | É SxB t t | É t | É É D]% \ } } t | | É } | rv | Sqv Wd S(   Ni   i    (   R   t   listR   R   t   zipt   sortedt   cmp(   R	   R   t   s_repost   o_repost   s_repot   o_repoR$   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   __cmp__G   s    (c         C   s   t  É  Ç d  S(   N(   t   NotImplementedError(   R	   t   compatArchs(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   setCompatArchsU   s    c         C   s   t  É  Ç d  S(   N(   R.   (   R	   t   repot   mdtypet   callbackt	   cacheOnly(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   populateX   s    c         C   s#   t  j d t d d É|  j | É S(   s5   return a list of package objects by (n,a,e,v,r) tuples;   packagesByTuple() will go away in a future version of Yum.
t
   stackleveli   (   t   warningst   warnt   DeprecationWarningt   searchPkgTuple(   R	   t   pkgtup(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   packagesByTuple[   s    	c         C   s   t  É  Ç d S(   s6   return list of pkgobjects matching the nevra requestedN(   R.   (   R	   t   namet   epocht   vert   relt   arch(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   searchNevrac   s    c         C   s   t  É  Ç d  S(   N(   R.   (   R	   t   namest   return_pkgtups(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   searchNamesg   s    c         C   s7   |  j  d | j d | j d | j d | j d | j É S(   sr   return list of package objects matching the name, epoch, ver, rel,
           arch of the package object passed inR=   R>   R?   R@   RA   (   RB   R=   R>   R?   R@   RA   (   R	   t   po(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   searchPOj   s    $c         C   s=   | \ } } } } } |  j  d | d | d | d | d | É S(   s7   return list of pkgobject matching the (n,a,e,v,r) tupleR=   RA   R>   R?   R@   (   RB   (   R	   R;   t   nt   at   et   vt   r(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR:   q   s    c         C   sd   | r6 | j  } | j } | j } | j } | j } n  t |  j d | d | d | d | d | É É S(   sp   return if there are any packages in the sack that match the given NAEVR 
           or the NAEVR of the given poR=   RA   R>   R?   R@   (   R=   RA   R>   t   versiont   releaset   boolRB   (   R	   R=   RA   R>   R?   R@   RF   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   containsv   s    				c         C   s   t  É  Ç d S(   s5   return dict { packages -> list of matching provides }N(   R.   (   R	   R=   t   flagsRM   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   getProvidesÅ   s    c         C   s   t  É  Ç d S(   s5   return dict { packages -> list of matching requires }N(   R.   (   R	   R=   RQ   RM   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   getRequiresÖ   s    c         C   s   t  É  Ç d S(   s<   return list of package requiring the name (any evr and flag)N(   R.   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   searchRequiresâ   s    c         C   s   t  É  Ç d S(   s<   return list of package providing the name (any evr and flag)N(   R.   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   searchProvidesç   s    c         C   s   t  É  Ç d S(   sC   return list of package conflicting with the name (any evr and flag)N(   R.   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   searchConflictsë   s    c         C   s   t  É  Ç d S(   s=   return list of package obsoleting the name (any evr and flag)N(   R.   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   searchObsoletesï   s    c         C   s   t  É  Ç d S(   sE   returns a dict of obsoletes dict[obsoleting pkgtuple] = [list of obs]N(   R.   (   R	   t   newest(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   returnObsoletesô   s    c         C   s   t  É  Ç d S(   sb    Is calling pkg.returnFileEntries(primary_only=True) faster than
            using searchFiles(). N(   R.   (   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   have_fastReturnFileEntriesù   s    c         C   s   t  É  Ç d S(   s#   return list of packages by filenameN(   R.   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   searchFiles¢   s    c         C   s   t  É  Ç d S(   s"   add a pkgobject to the packageSackN(   R.   (   R	   t   obj(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt
   addPackage¶   s    c         C   s   t  É  Ç d S(   s•   builds the useful indexes for searching/querying the packageSack
           This should be called after all the necessary packages have been
           added/deletedN(   R.   (   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   buildIndexes™   s    c         C   s   t  É  Ç d S(   s   delete a pkgobjectN(   R.   (   R	   R\   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt
   delPackage∞   s    c         C   s   t  É  Ç d S(   s   return list of all packagesN(   R.   (   R	   t   repoidt   patternst   ignore_case(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR   ¥   s    c         G   s   t  É  Ç d S(   s‚   Add an "excluder" for all packages in the repo/sack. Can basically
            do anything based on nevra, changes lots of exclude decisions from
            "preload package; test; delPackage" into "load excluder".
            Excluderid is used so the caller doesn't have to track
            "have I loaded the excluder for this repo.", it's probably only
            useful when repoid is None ... if it turns out utterly worthless
            then it's still not a huge wart. N(   R.   (   R	   R`   t
   excluderidt   excludert   args(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   addPackageExcluder∏   s    c         C   sV  d Ñ  } t  É  } i  } i  } i  } xt |  j É  É D]˚ } | j É  }	 | j | |	 É x^ | D]V }
 | j | |
 k r` |
 | k rü t  É  | |
 <i  | |
 <n  | |
 j | |	 É q` q` W| r∆ q7 n  | j j j } | | | j	 | | |	 É xA | D]9 }
 | j | |
 k rı | | |
 | j	 | | |	 É qı qı Wq7 W| rL| | | | g S| | g S(   s5    Return a simple version for all available packages. c         S   so   |  j  | i  É } | j  d  t É  É } | j | | É | d  k	 rk | j  | t É  É } | j | | É n  d  S(   N(   t
   setdefaultR   R   R   (   t   areposR`   t   revR   R   t   arevst   rpsv(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   _up_revsƒ   s    (
   R   R'   R   t   returnIdSumR   R=   R1   t   repoXMLt   revisionR`   (   R	   t	   main_onlyt   groupsRl   t   mainRh   t	   main_grpst   arepos_grpsR   R   t   groupRi   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   simpleVersion¬   s0    		(c         C   s   t  É  Ç d S(   s~  return list of newest packages based on name, arch matching
           this means(in name.arch form): foo.i386 and foo.noarch are not
           compared to each other for highest version only foo.i386 and
           foo.i386 will be compared
           Note that given: foo-1.i386; foo-2.i386 and foo-3.x86_64
           The last _two_ pkgs will be returned, not just one of them. N(   R.   (   R	   t   naTupRa   Rb   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   returnNewestByNameArchË   s    c         C   s   t  É  Ç d S(   s∂   return list of newest packages based on name matching
           this means(in name.arch form): foo.i386 and foo.noarch will
           be compared to each other for highest version.N(   R.   (   R	   R=   Ra   Rb   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   returnNewestByNameÚ   s    c         C   s   t  É  Ç d S(   s,   returns a list of pkg tuples (n, a, e, v, r)N(   R.   (   R	   Ra   Rb   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   simplePkgList¯   s    c         C   s   t  É  Ç d  S(   N(   R.   (   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   printPackages¸   s    c         C   s   t  É  Ç d S(   sD   exclude incompatible arches. archlist is a list of compatible archesN(   R.   (   R	   t   archlist(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   excludeArchsˇ   s    c         C   s   t  É  Ç d  S(   N(   R.   (   R	   t   fieldst   criteria_reR3   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   searchPackages  s    c         C   s   t  É  Ç d  S(   N(   R.   (   R	   t   argt
   query_type(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt	   searchAll  s    c         C   s  g  } g  } t  | É } i  } xL | D]D } t j | É r_ t j | É } t j | É | | <q% | | | <q% W|  j d | É } x]g  | D] }	 |	 j ^ qâ D]?}
 |
 \ } } } } } t  | d | | f d | | | | f d | | f d | | | f d | | | | | f d | | | | | f f É } x© | j	 É  D]õ \ } } | | k rç| | k r◊| j
 |  j |
 É d É | j | É q◊q<xG | D]? } | j | É rî| j
 |  j |
 É d É | j | É qîqîWq<Wqú Wt j | É t j | É t | É f S(	   s{  take a list strings and match the packages in the sack against it
           this will match against:
           name
           name.arch
           name-ver-rel.arch
           name-ver
           name-ver-rel
           epoch:name-ver-rel.arch
           name-epoch:ver-rel.arch
           
           return [exact matches], [glob matches], [unmatch search terms]
           Ra   s   %s.%ss   %s-%s-%s.%ss   %s-%ss   %s-%s-%ss   %s:%s-%s-%s.%ss   %s-%s:%s-%s.%si    (   t   setR   t   re_globt   fnmatcht	   translatet   ret   compileR   R;   t   itemst   appendR:   t   discardt   matcht   uniqueR%   (   R	   t   pkgspecst   matchedt
   exactmatcht	   unmatchedt   specst   pt   restringt   pkgsR   R;   RH   RI   RJ   RK   RL   RC   t   termt   query(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   matchPackageNames	  s<    #c   	      C   sA  d Ñ  } i  } g  } xâ |  j  d | É D]u } | j s= q( n  x] | j D]R } | | k ri t É  | | <n  t | | É d k rÖ qG n  | | j | j É qG Wq( Wxô |  j  d | É D]Ö } d } xZ | | É D]L } | | k rÕ t | | É d k s| j | | k r| d 7} PqqÕ qÕ W| d k r¥ | j | É q¥ q¥ W| S(   sj   returns a list of package objects that are not required by
           any other package in this repositoryc         s   sh   x |  j  D] } | Vq
 Wx |  j D] } | Vq# Wx |  j D] } | Vq< Wx |  j D] } | VqU Wd S(   s&    Return all the provides, via. yield. N(   t   provides_namest   filelistt   dirlistt	   ghostlist(   RF   t   prov(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   _return_all_providesB  s    			R`   i   i    (   R   t   requires_namesRÑ   R   t   addR=   Rã   (	   R	   R`   Rü   t   reqt   orphansRF   RL   t   preqRî   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   returnLeafNodes>  s,    		)
N(   NNN(   NNN()   R   R   t   __doc__R
   R    R!   R-   R0   R5   R<   R   RB   R   RE   RG   R:   RP   RR   RS   RT   RU   RV   RW   RY   RZ   R[   R]   R^   R_   R   Rf   Rv   Rx   Ry   Rz   R{   R}   RÄ   RÉ   Rô   R•   (    (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR   8   sL   																			
&						5t   MetaSackc           B   ss  e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d! d! d! d! d! d Ñ Z g  e d	 Ñ Z d! d" d
 Ñ Z d! d# d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d! d! e d Ñ Z d Ñ  Z d! d! e d Ñ Z d! d! e d Ñ Z d! e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d  Ñ  Z$ RS($   sq   Represents the aggregate of multiple package sacks, such that they can
       all be treated as one unified sack.c         C   s#   t  j |  É i  |  _ d  |  _ d  S(   N(   R   R
   t   sacksR   t   compatarchs(   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR
   r  s    	c         C   s:   d } x- t  |  j j É  É D] } | t | É 7} q W| S(   Ni    (   R'   R®   t   valuesR   (   R	   R$   t   sack(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR    w  s    c         C   s:   x3 |  j  j É  D]" } t | d É r | j É  q q Wd  S(   Nt   dropCachedData(   R®   R™   R"   R¨   (   R	   R´   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR¨   }  s    c         C   s!   | |  j  | <| j |  j É d S(   s1   Adds a repository's packageSack to this MetaSack.N(   R®   R0   R©   (   R	   R`   R´   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   addSackÇ  s    c         C   s$   |  j  | j j | | | | É d  S(   N(   R®   t   idR5   (   R	   R1   R2   R3   R4   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR5   â  s    c         C   s+   x$ |  j  j É  D] } | j | É q Wd  S(   N(   R®   R™   R0   (   R	   R/   R´   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR0   å  s    c         C   s&   t  j d t d d É|  j d | É S(   s5   return a list of package objects by (n,a,e,v,r) tuples;   packagesByTuple() will go away in a future version of Yum.
R6   i   R<   (   R7   R8   R9   t   _computeAggregateListResult(   R	   R;   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR<   ê  s    	c         C   s   |  j  d | | | | | É S(   s6   return list of pkgobjects matching the nevra requestedRB   (   RØ   (   R	   R=   R>   R?   R@   RA   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRB   ñ  s    c         C   s   |  j  d | | É S(   NRE   (   RØ   (   R	   RC   RD   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRE   ö  s    c         C   s   |  j  d | | | É S(   s5   return dict { packages -> list of matching provides }RR   (   t   _computeAggregateDictResult(   R	   R=   RQ   RM   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRR   ù  s    c         C   s   |  j  d | | | É S(   s5   return dict { packages -> list of matching requires }RS   (   R∞   (   R	   R=   RQ   RM   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRS   °  s    c         C   s   |  j  d | É S(   s<   return list of package requiring the name (any evr and flag)RT   (   RØ   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRT   •  s    c         C   s   |  j  d | É S(   s<   return list of package providing the name (any evr and flag)RU   (   RØ   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRU   ©  s    c         C   s   |  j  d | É S(   sC   return list of package conflicting with the name (any evr and flag)RV   (   RØ   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRV   ≠  s    c         C   s   |  j  d | É S(   s=   return list of package obsoleting the name (any evr and flag)RW   (   RØ   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRW   ±  s    c            sÁ   | s |  j  d É S|  j  d É } t d Ñ  | DÉ É } i  } d } d	 } d Ñ  â  á  f d Ü  } x~ t |  j | d t Éd à  ÉD][ } | d }	 | |	 k r∂ | |
 | É r∂ qÑ n  |	 } | }
 | | k rÑ | | | | <qÑ qÑ W| S(
   sE   returns a dict of obsoletes dict[obsoleting pkgtuple] = [list of obs]RY   c         s   s   |  ] } | d  Vq d S(   i    N(    (   t   .0t   obstup(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pys	   <genexpr>º  s    R   c         S   sY   t  |  d | d É } | r! | St |  d |  d |  d f | d | d | d f É S(   s4    Compare two pkgtup's (ignore arch): n, a, e, v, r. i    i   i   i   (   R(   R   (   t   xt   yR$   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   _pkgtup_nevr_cmp√  s     c            s   à  |  | É d k S(   Ni    (    (   R≥   R¥   (   Rµ   (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   _pkgtup_nevr_eq…  s    RD   R(   i    N(   R∞   RÑ   R   R'   RE   R   (   R	   RX   t   obsdictRC   t   nobsdictt	   last_namet   last_pkgR∂   R;   R=   t   last_pkgtup(    (   Rµ   s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRY   µ  s&    	
c         C   s   |  j  d | É S(   s#   return list of packages by filenameR[   (   RØ   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR[   ÷  s    c         C   s   d S(   sa   Add a pkgobject to the packageSack.  This is a meaningless operation
           for the MetaSack.N(    (   R	   R\   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR]   ⁄  s    c         C   s(   x! |  j  j É  D] } | j É  q Wd S(   s•   builds the useful indexes for searching/querying the packageSack
           This should be called after all the necessary packages have been
           added/deletedN(   R®   R™   R^   (   R	   R´   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR^   ﬂ  s    c         C   s   | j  j j | É d S(   s2   Delete a pkgobject if it exists in every sub-sack.N(   R1   R´   R_   (   R	   R\   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR_   Ê  s    c         C   s9   | s |  j  d d | | É S|  j | j d | d | É S(   s»   Returns a list of packages. Note that the packages are
           always filtered to those matching the patterns/case. An optional
           repoid allows you to easily get data for a specific repo. R   Ra   Rb   N(   RØ   R   R®   R   (   R	   R`   Ra   Rb   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR   Î  s
    	c         G   sB   | s% |  j  } | d d | | | å S|  j | j d | | | å S(   s‚   Add an "excluder" for all packages in the repo/sack. Can basically
            do anything based on nevra, changes lots of exclude decisions from
            "preload package; test; delPackage" into "load excluder".
            Excluderid is used so the caller doesn't have to track
            "have I loaded the excluder for this repo.", it's probably only
            useful when repoid is None ... if it turns out utterly worthless
            then it's still not a huge wart. Rf   N(   RØ   R   R®   Rf   (   R	   R`   Rc   Rd   Re   t   calr(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRf   ı  s
    	c         C   sf   |  j  } | d | | | É } t | É } | rb | s= | rb d j | pL g  É } t d | Ç n  | S(   s  return list of newest packages based on name, arch matching
           this means(in name.arch form): foo.i386 and foo.noarch are not
           compared to each other for highest version only foo.i386 and
           foo.i386 will be compared.
           Note that given: foo-1.i386; foo-2.i386 and foo-3.x86_64
           The last _two_ pkgs will be returned, not just one of them. Rx   s   , s   No Package Matching %s(   RØ   t   packagesNewestByNameArcht   joinR    (   R	   Rw   Ra   Rb   Rº   Rñ   t   ui_pats(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRx     s    	c         C   so   |  j  d | | | É } t | É } | rk | s7 | rk | rF | } n d j | pU g  É } t d | Ç n  | S(   s∂   return list of newest packages based on name matching
           this means(in name.arch form): foo.i386 and foo.noarch will
           be compared to each other for highest version.Ry   s   , s   No Package Matching %s(   RØ   t   packagesNewestByNameRæ   R    (   R	   R=   Ra   Rb   Rñ   Rø   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRy     s    	c         C   s   |  j  d | | É S(   s,   returns a list of pkg tuples (n, a, e, v, r)Rz   (   RØ   (   R	   Ra   Rb   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRz   "  s    	c         C   s(   x! |  j  j É  D] } | j É  q Wd  S(   N(   R®   R™   R{   (   R	   R´   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR{   '  s    c         C   s+   x$ |  j  j É  D] } | j | É q Wd S(   sD   exclude incompatible arches. archlist is a list of compatible archesN(   R®   R™   R}   (   R	   R|   R´   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR}   +  s    c         C   s   |  j  d | | | É S(   NRÄ   (   R∞   (   R	   R~   R   R3   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRÄ   0  s    c         C   s   |  j  d | | É S(   NRÉ   (   RØ   (   R	   RÅ   RÇ   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRÉ   3  s    c   	      C   s  g  } g  } d  } x∫ |  j j É  D]© } t | d É r" g  g  g  } } } y | j | É \ } } } Wn t k
 r} q" n X| j | É | j | É | d  k r≥ t | É } qÀ | j t | É É } q" q" Wt	 j
 | É } t	 j
 | É } | d  k rg  } n t | É } | | | f S(   NRô   (   R   R®   R™   R"   Rô   R    t   extendRÑ   t   intersectionR   Ré   R%   (	   R	   Rè   Rê   Rë   Rí   R´   RJ   t   mt   u(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRô   6  s*    	c         G   sã   g  } x~ t  |  j j É  É D]g } t | | É r t | | É } y t | | É } Wn t k
 ri q n X| rÉ | j | É qÉ q q W| S(   N(   R'   R®   R™   R"   t   getattrt   applyR    R¡   (   R	   t
   methodNameRe   t   resultR´   t   methodt
   sackResult(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRØ   Q  s    c         G   sã   i  } x~ t  |  j j É  É D]g } t | | É r t | | É } y t | | É } Wn t k
 ri q n X| rÉ | j | É qÉ q q W| S(   N(   R'   R®   R™   R"   R≈   R∆   R    R   (   R	   R«   Re   R»   R´   R…   R    (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR∞   `  s    N(   NNN(   NNN(%   R   R   R¶   R
   R    R¨   R≠   R5   R0   R<   R   RB   R   RE   RR   RS   RT   RU   RV   RW   RY   R[   R]   R^   R_   R   Rf   Rx   Ry   Rz   R{   R}   RÄ   RÉ   Rô   RØ   R∞   (    (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRß   n  sD   											!				
							t   PackageSackc           B   sv  e  Z d  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d" d" d" d" d" d Ñ Z	 g  e
 d Ñ Z d" d# d	 Ñ Z d" d$ d
 Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e
 d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d" d" e
 d Ñ Z d" d" e
 d Ñ Z d" d" e
 d Ñ Z  d" e
 d Ñ Z! d Ñ  Z" d  Ñ  Z# d! Ñ  Z$ RS(%   s*   represents sets (sacks) of Package Objectsc         C   s^   i  |  _  i  |  _ i  |  _ i  |  _ i  |  _ i  |  _ i  |  _ i  |  _ d  |  _	 d |  _
 d  S(   Ni    (   t   nevrat	   obsoletest   requirest   providest	   conflictst	   filenamest
   pkgsByRepot   pkgsByIDR   R©   t   indexesBuilt(   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR
   r  s    									c         C   s5   d } x( |  j  D] } | t |  j  | É 7} q W| S(   Ni    (   R“   R   (   R	   R$   R1   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR    Ç  s    t   errorc         C   sA   |  j  s= | d k r! t d Ç q= | d k r= |  j É  q= n  d S(   sè   check to see if the indexes are built, if not do what failure demands
           either error out or build the indexes, default is to error outR’   s$   Indexes not yet built, cannot searcht   buildN(   R‘   R    R^   (   R	   t   failure(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   _checkIndexesâ  s
    	c         C   s   |  j  É  d S(   s*    Do nothing, mainly for the testing code. N(   t   clearIndexes(   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR¨   ì  s    c         C   s   | |  _  d  S(   N(   R©   (   R	   R©   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR0   ó  s    c   
      C   s?  |  j  d d É | | | | | f |  j k rH |  j | | | | | f S| d k	 r{ |  j j | d d d d f g  É } n- g  } x$ |  j j É  D] } | j | É që Wg  } xä | D]Ç }	 | r– | |	 j k sµ | rÂ | |	 j k sµ | r˙ | |	 j	 k sµ | r| |	 j
 k sµ | r*| |	 j k r*qµ n  | j |	 É qµ W| S(   s6   return list of pkgobjects matching the nevra requestedR◊   R÷   N(   Rÿ   RÃ   R   t   getR“   t
   itervaluesR¡   R=   R>   R?   R@   RA   Rã   (
   R	   R=   R>   R?   R@   RA   Rñ   t
   pkgsbyRepoR»   RF   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRB   ö  s$    'c         C   sû   |  j  d d É g  } t É  } xX | D]P } | | k r> q& n  | j | É | j |  j j | d d d d f g  É É q& W| rö g  | D] } | j ^ qá S| S(   s6   return list of pkgobjects matching the names requestedR◊   R÷   N(   Rÿ   RÑ   R°   R¡   RÃ   R⁄   R   R;   (   R	   RC   RD   R»   t   doneR=   R   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRE   ±  s    	/c         C   s  |  j  d d É | d k r% d } n6 t | É t t d É t f k r[ t j j | É } n  i  } xK |  j j	 | g  É D]4 } | j
 d | | | f É } | rw | | | <qw qw W| d d k r| d d f } x3 |  j | É D] } | j | g  É j | É qﬁ Wn  | S(	   s5   return dict { packages -> list of matching provides }R◊   R÷   Rœ   i    t   /N(   NNN(   NNN(   Rÿ   R   R   R   t   unicodet   rpmUtilst	   miscutilst   stringToVersionRœ   R⁄   t   matchingPrcosR[   Rg   Rã   (   R	   R=   RQ   RM   R»   RF   t   hitst   hit(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRR   ø  s    	! c         C   s≥   |  j  d d É | d k r% d } n6 t | É t t d É t f k r[ t j j | É } n  i  } xK |  j j	 | g  É D]4 } | j
 d | | | f É } | rw | | | <qw qw W| S(   s5   return dict { packages -> list of matching requires }R◊   R÷   RŒ   N(   NNN(   Rÿ   R   R   R   Rﬂ   R‡   R·   R‚   RŒ   R⁄   R„   (   R	   R=   RQ   RM   R»   RF   R‰   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRS   —  s    	!c         C   s˜   |  j  d d É t |  | É } t j | É \ } } \ } } } g  }	 g  }
 | | k rl |	 j | | É n  xB |	 D]: } | j | | | | | | f f É rs |
 j | É qs qs W| d k r¡ |
 St j | É s‘ |
 S|
 j |  j | É É t j	 |
 É S(   NR◊   R÷   Rœ   (
   Rÿ   R≈   R   t   string_to_prco_tupleR¡   t	   checkPrcoRã   t   re_filenameR[   Ré   (   R	   R=   t   prcotypet   prcodictRH   t   fRJ   RK   RL   t   basic_resultst   resultsRF   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt
   searchPrcoﬂ  s     !$c         C   s   |  j  | d É S(   s3   return list of package requiring the item requestedRŒ   (   RÓ   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRT   ˜  s    c         C   s   |  j  | d É S(   s3   return list of package providing the item requestedRœ   (   RÓ   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRU   ¸  s    c         C   s   |  j  | d É S(   s6   return list of package conflicting with item requestedR–   (   RÓ   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRV     s    c         C   s   |  j  | d É S(   s4   return list of package obsoleting the item requestedRÕ   (   RÓ   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRW     s    c         C   sÃ   i  } xN |  j  É  D]@ } t | j É d k r4 q n  | j | j g  É j | j É q W| sa | St d Ñ  |  j É  DÉ É } g  } x* | D]" } | | k rä | j | É qä qä Wx | D] } | | =q∑ W| S(   sE   returns a dict of obsoletes dict[obsoleting pkgtuple] = [list of obs]i    c         s   s   |  ] } | j  Vq d  S(   N(   R;   (   R±   R   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pys	   <genexpr>  s    (	   R   R   RÕ   Rg   R;   R¡   RÑ   Ry   Rã   (   R	   RX   t   obsRF   t   newest_tupst   togoR≤   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRY     s    #c         C   s   t  S(   sb    Is calling pkg.returnFileEntries(primary_only=True) faster than
            using searchFiles(). (   R   (   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRZ   %  s    c         C   s2   |  j  d d É | |  j k r* |  j | Sg  Sd S(   s&    Return list of packages by filename. R◊   R÷   N(   Rÿ   R—   (   R	   R=   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR[   *  s    c         C   s.   | | k r g  | | <n  | | j  | É d  S(   N(   Rã   (   R	   t   dictt   keyt   data(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   _addToDictAsList2  s    c         C   s]   | | k r d  Sy | | j  | É Wn t k
 r8 n Xt | | É d k rY | | =n  d  S(   Ni    (   t   removet
   ValueErrorR   (   R	   RÚ   RÛ   RÙ   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   _delFromListOfDict9  s    c         C   sp   | j  } | j \ } } } } } |  j s: | |  j k rS |  j |  j | | É n  |  j rl |  j | É n  d S(   s"   add a pkgobject to the packageSackN(   R`   R;   R©   Rı   R“   R‘   t   _addPackageToIndex(   R	   R\   R`   R=   RA   R>   R?   R@   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR]   E  s    		c         C   sP   |  j  É  x6 |  j D]+ } x" |  j | D] } |  j | É q( Wq Wd |  _ d S(   s¶   builds the useful indexes for searching/querying the packageSack
           This should be called after all the necessary packages have been 
           added/deletedi   N(   RŸ   R“   R˘   R‘   (   R	   R`   R\   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR^   P  s
    
c         C   sL   i  |  _  i  |  _ i  |  _ i  |  _ i  |  _ i  |  _ i  |  _ d |  _ d  S(   Ni    (   RÕ   RŒ   Rœ   R–   R—   RÃ   R”   R‘   (   R	   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRŸ   ]  s    							c         C   sŒ  x? | j  d É D]. \ } } \ } } } |  j |  j | | É q Wx? | j  d É D]. \ } } \ } } } |  j |  j | | É qR Wx? | j  d É D]. \ } } \ } } } |  j |  j | | É qî Wx? | j  d É D]. \ } } \ } } } |  j |  j | | É q÷ WxD | j É  D]6 } x- | j | É D] } |  j |  j | | É q+WqW|  j |  j	 | j
 | É | j \ }	 }
 } } } |  j |  j |	 | | | |
 f | É |  j |  j |	 d  d  d  d  f | É d  S(   NRÕ   RŒ   Rœ   R–   (   t
   returnPrcoRı   RÕ   RŒ   Rœ   R–   t   returnFileTypest   returnFileEntriesR—   R”   RÆ   R;   RÃ   R   (   R	   R\   RH   t   flRJ   RK   RL   t   ftypet   fileR=   RA   R>   R?   R@   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR˘   i  s    ((((%c         C   sŒ  x? | j  d É D]. \ } } \ } } } |  j |  j | | É q Wx? | j  d É D]. \ } } \ } } } |  j |  j | | É qR Wx? | j  d É D]. \ } } \ } } } |  j |  j | | É qî Wx? | j  d É D]. \ } } \ } } } |  j |  j | | É q÷ WxD | j É  D]6 } x- | j | É D] } |  j |  j | | É q+WqW|  j |  j	 | j
 | É | j \ }	 }
 } } } |  j |  j |	 | | | |
 f | É |  j |  j |	 d  d  d  d  f | É d  S(   NRÕ   RŒ   Rœ   R–   (   R˙   R¯   RÕ   RŒ   Rœ   R–   R˚   R¸   R—   R”   RÆ   R;   RÃ   R   (   R	   R\   RH   R˝   RJ   RK   RL   R˛   Rˇ   R=   RA   R>   R?   R@   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   _delPackageFromIndex|  s    ((((%c         C   s6   |  j  |  j | j | É |  j r2 |  j | É n  d S(   s   delete a pkgobjectN(   R¯   R“   R`   R‘   R   (   R	   R\   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR_   ç  s    	c         C   sö   g  } | d k r= xM |  j D] } | j |  j | É q Wn% y |  j | } Wn t k
 ra n X| rñ t | | | d d É} | d | d } n  | S(   s2   return list of all packages, takes optional repoidRé   s   repo-pkgkeyi    i   N(   R   R“   R¡   t   KeyErrorR   (   R	   R`   Ra   Rb   t
   returnListR1   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR   ì  s    	c         C   s)  i  } | rZ |  j  d d É |  j j | d d d d d f É } | sr t d | Ç qr n |  j d | d | É } x} | D]u } | j | j f | k r∞ | | | j | j f <qy | | j | j f } | j | É ry | | | j | j f <qy qy W| r| | k r| | g St d | Ç n  | j	 É  S(   sÄ  return list of newest packages based on name, arch matching
           this means(in name.arch form): foo.i386 and foo.noarch are not 
           compared to each other for highest version only foo.i386 and 
           foo.i386 will be compared
           Note that given: foo-1.i386; foo-2.i386 and foo-3.x86_64
           The last _two_ pkgs will be returned, not just one of them. R◊   R÷   i    s   No Package Matching %s.%sRa   Rb   N(
   Rÿ   RÃ   R⁄   R   R    R   R=   RA   t   verGTR™   (   R	   Rw   Ra   Rb   t   highdictt   whereR   t   pkg2(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRx   ¶  s&    	%	c         C   s@  i  } | d k r3 | d k	 r3 |  j d | É } n |  j d | d | É } xâ | D]Å } | j | k rz | g | | j <qR | | j d } | j | É r≠ | g | | j <n  | j | É rR | | j j | É qR qR W| r| | k rÒ | | St d | Ç n  g  } x2 | j É  D]$ }	 x |	 D] }
 | j |
 É q!WqW| S(   s∂   return list of newest packages based on name matching
           this means(in name.arch form): foo.i386 and foo.noarch will
           be compared to each other for highest version.R=   Ra   Rb   i    s   No Package Matching  %sN(	   R   RB   R   R=   R  t   verEQRã   R    R™   (   R	   R=   Ra   Rb   R  Rñ   R   R  t
   returnlistt   polstRF   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRy   À  s,    	c         C   s,   g  |  j  d | d t É D] } | j ^ q S(   sL   returns a list of pkg tuples (n, a, e, v, r) optionally from a single repoidRa   Rb   (   R   R   R;   (   R	   Ra   Rb   R   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRz   Ô  s    c         C   s    x |  j  É  D] } | GHq Wd  S(   N(   R   (   R	   R   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR{   ˆ  s    c         C   s:   x3 |  j  É  D]% } | j | k r |  j | É q q Wd S(   sD   exclude incompatible arches. archlist is a list of compatible archesN(   R   RA   R_   (   R	   R|   R   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR}   ˙  s    c   	      C   s°   i  } xî |  j  É  D]Ü } g  } xB | D]: } t | | É } | r& | j | É r& | j | É q& q& Wt | É d k r | rå | | | É n  | | | <q q W| S(   Ni    (   R   R≈   t   searchRã   R   (	   R	   R~   R   R3   t   matchesRF   t	   tmpvaluest   fieldt   value(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRÄ     s    N(   NNN(   NNN(%   R   R   R¶   R
   R    Rÿ   R¨   R0   R   RB   R   RE   RR   RS   RÓ   RT   RU   RV   RW   RY   RZ   R[   Rı   R¯   R]   R^   RŸ   R˘   R   R_   R   Rx   Ry   Rz   R{   R}   RÄ   (    (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRÀ   p  sD   		
																	$$		c         C   s∂   i  } x |  D]w } | j  } d } | | k rH | j | | d É } n  | d k rd | g | | <q | d k r | | j | É q q Wg  } x! | j É  D] } | j | É qõ W| S(   st    Does the same as PackageSack.returnNewestByName().
        Note that given: foo-1.i386; foo-2.i386 and foo-3.x86_64i   i    (   R=   t   verCMPRã   R€   R¡   (   Rñ   RX   R   RÛ   t   cvalR$   t   vals(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR¿     s    	c         C   sb   i  } xO |  D]G } | j  | j f } | | k rJ | j | | É rJ q n  | | | <q W| j É  S(   sz    Does the same as PackageSack.returnNewestByNameArch()
        The last _two_ pkgs will be returned, not just one of them.(   R=   RA   t   verLER™   (   Rñ   RX   R   RÛ   (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyRΩ   $  s    t   ListPackageSackc           B   s#   e  Z d  Z d d Ñ Z d Ñ  Z RS(   s™   Derived class from PackageSack to build new Sack from list of
       pkgObjects - like one returned from self.returnNewestByNameArch()
       or self.returnNewestByName()c         C   s-   t  j |  É | d  k	 r) |  j | É n  d  S(   N(   RÀ   R
   R   t   addList(   R	   t   Objlist(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR
   4  s    c         C   s"   x | D] } |  j  | É q Wd  S(   N(   R]   (   R	   t   ObjListt   pkgobj(    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR  9  s    N(   R   R   R¶   R   R
   R  (    (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyR  /  s   (   R¶   t   ErrorsR    R7   Rà   RÜ   R   t   packagesR   t   rpmUtils.miscutilsR‡   R   R   t   objectR   Rß   RÀ   R¿   RΩ   R  (    (    (    s3   /usr/lib/python2.7/dist-packages/yum/packageSack.pyt   <module>   s$   ˇ 7ˇ ˇ ¢		                                    usr/lib/python2.7/dist-packages/yum/packages.py                                                     0100644 0000000 0000000 00000242275 12451005146 020067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2004 Duke University 
# Written by Seth Vidal <skvidal at phy.duke.edu>

"""
Classes and functions dealing with rpm package representations.
"""

import rpm
import os
import os.path
import misc
import i18n
import re
import fnmatch
import stat
import warnings
from subprocess import Popen, PIPE
from rpmUtils import RpmUtilsError
import rpmUtils.miscutils
from rpmUtils.miscutils import flagToString, stringToVersion, compareVerOnly
import Errors
import errno
import struct
from constants import *
from operator import itemgetter

import urlparse

try:
    urlparse.uses_fragment.append("media")
except AttributeError, err:
    print err

from urlgrabber.grabber import URLGrabber, URLGrabError

try:
    import xattr
    if not hasattr(xattr, 'get'):
        xattr = None # This is a "newer" API.
except ImportError:
    xattr = None

# For verify
import pwd
import grp

def comparePoEVR(po1, po2):
    """
    Compare two Package or PackageEVR objects.
    """
    (e1, v1, r1) = (po1.epoch, po1.version, po1.release)
    (e2, v2, r2) = (po2.epoch, po2.version, po2.release)
    return rpmUtils.miscutils.compareEVR((e1, v1, r1), (e2, v2, r2))
def comparePoEVREQ(po1, po2):
    """
    Compare two Package or PackageEVR objects for equality.
    """
    (e1, v1, r1) = (po1.epoch, po1.version, po1.release)
    (e2, v2, r2) = (po2.epoch, po2.version, po2.release)
    if r1 != r2: return False
    if v1 != v2: return False
    if e1 != e2: return False
    return True

def buildPkgRefDict(pkgs, casematch=True):
    """take a list of pkg objects and return a dict the contains all the possible
       naming conventions for them eg: for (name,i386,0,1,1)
       dict[name] = (name, i386, 0, 1, 1)
       dict[name.i386] = (name, i386, 0, 1, 1)
       dict[name-1-1.i386] = (name, i386, 0, 1, 1)       
       dict[name-1] = (name, i386, 0, 1, 1)       
       dict[name-1-1] = (name, i386, 0, 1, 1)
       dict[0:name-1-1.i386] = (name, i386, 0, 1, 1)
       dict[name-0:1-1.i386] = (name, i386, 0, 1, 1)
       """
    pkgdict = {}
    for pkg in pkgs:
        (n, a, e, v, r) = pkg.pkgtup
        if not casematch:
            n = n.lower()
            a = a.lower()
            e = e.lower()
            v = v.lower()
            r = r.lower()
        name = n
        nameArch = '%s.%s' % (n, a)
        nameVerRelArch = '%s-%s-%s.%s' % (n, v, r, a)
        nameVer = '%s-%s' % (n, v)
        nameVerRel = '%s-%s-%s' % (n, v, r)
        envra = '%s:%s-%s-%s.%s' % (e, n, v, r, a)
        nevra = '%s-%s:%s-%s.%s' % (n, e, v, r, a)
        for item in [name, nameArch, nameVerRelArch, nameVer, nameVerRel, envra, nevra]:
            if item not in pkgdict:
                pkgdict[item] = []
            pkgdict[item].append(pkg)
            
    return pkgdict
       
def parsePackages(pkgs, usercommands, casematch=0,
                  unique='repo-epoch-name-version-release-arch'):
    """matches up the user request versus a pkg list:
       for installs/updates available pkgs should be the 'others list' 
       for removes it should be the installed list of pkgs
       takes an optional casematch option to determine if case should be matched
       exactly. Defaults to not matching."""

    pkgdict = buildPkgRefDict(pkgs, bool(casematch))
    exactmatch = []
    matched = []
    unmatched = []
    for command in usercommands:
        if not casematch:
            command = command.lower()
        if command in pkgdict:
            exactmatch.extend(pkgdict[command])
            del pkgdict[command]
        else:
            # anything we couldn't find a match for
            # could mean it's not there, could mean it's a wildcard
            if misc.re_glob(command):
                trylist = pkgdict.keys()
                # command and pkgdict are already lowered if not casematch
                # so case sensitive is always fine
                restring = fnmatch.translate(command)
                regex = re.compile(restring)
                foundit = 0
                for item in trylist:
                    if regex.match(item):
                        matched.extend(pkgdict[item])
                        del pkgdict[item]
                        foundit = 1
 
                if not foundit:    
                    unmatched.append(command)
                    
            else:
                unmatched.append(command)

    unmatched = misc.unique(unmatched)
    if unique == 'repo-epoch-name-version-release-arch': # pkg.__hash__
        matched    = misc.unique(matched)
        exactmatch = misc.unique(exactmatch)
    elif unique == 'repo-pkgkey': # So we get all pkg entries from a repo
        def pkgunique(pkgs):
            u = {}
            for pkg in pkgs:
                mark = "%s%s" % (pkg.repo.id, pkg.pkgKey)
                u[mark] = pkg
            return u.values()
        matched    = pkgunique(matched)
        exactmatch = pkgunique(exactmatch)
    else:
        raise ValueError, "Bad value for unique: %s" % unique
    return exactmatch, matched, unmatched

class FakeSack:
    """ Fake PackageSack to use with FakeRepository"""
    def __init__(self):
        pass # This is fake, so do nothing
    
    def have_fastReturnFileEntries(self):
        """ Is calling pkg.returnFileEntries(primary_only=True) faster than
            using searchFiles(). """
        return True

    def delPackage(self, obj):
        """delete a pkgobject, do nothing, but make localpackages work with --skip-broken"""
        pass # This is fake, so do nothing
            
class FakeRepository:
    """Fake repository class for use in rpmsack package objects"""

    def _set_cleanup_repoid(self, repoid):
        """ Set the repoid, but because it can be random ... clean it up. """

        #  We don't want repoids to contain random bytes that can be
        # in the FS directories. It's also nice if they aren't "huge". So
        # just chop to the rpm name.
        pathbased = False
        if '/' in repoid:
            repoid = os.path.basename(repoid)
            pathbased = True

        if repoid.endswith(".rpm"):
            repoid = repoid[:-4]
            pathbased = True

        bytes = [] # Just in case someone uses mv to be evil:
        if pathbased:
            bytes.append('/')

        for byte in repoid:
            if ord(byte) >= 128:
                byte = '?'
            bytes.append(byte)
        self.id = "".join(bytes)

    def __init__(self, repoid):
        self._set_cleanup_repoid(repoid)
        self.name = self.id
        self.sack = FakeSack()

    def __cmp__(self, other):
        if self.id > other.id:
            return 1
        elif self.id < other.id:
            return -1
        else:
            return 0
        
    def __hash__(self):
        return hash(self.id)

    def __str__(self):
        return self.id


#  Goal for the below is to have a packageobject that can be used by generic
# functions independent of the type of package - ie: installed or available
#  Note that this is also used to history etc. ... so it's more a nevra+checksum
# holder than a base for things which are actual packages.
class PackageObject(object):
    """Base Package Object - sets up the default storage dicts and the
       most common returns"""
       
    def __init__(self):
        self.name = None
        self.version = None
        self.release = None
        self.epoch = None
        self.arch = None
        # self.pkgtup = (self.name, self.arch, self.epoch, self.version, self.release)
        self._checksums = [] # (type, checksum, id(0,1)
        
    def _ui_envra(self):
        if self.epoch == '0':
            out = '%s-%s-%s.%s' % (self.name, 
                                   self.version,
                                   self.release, 
                                   self.arch)
        else:
            out = '%s:%s-%s-%s.%s' % (self.epoch,
                                      self.name,  
                                      self.version, 
                                      self.release, 
                                      self.arch)
        return out
    ui_envra = property(fget=lambda self: self._ui_envra())

    def _ui_nevra(self):
        if self.epoch == '0':
            out = '%s-%s-%s.%s' % (self.name,
                                   self.version,
                                   self.release,
                                   self.arch)
        else:
            out = '%s-%s:%s-%s.%s' % (self.name,
                                      self.epoch,
                                      self.version,
                                      self.release,
                                      self.arch)
        return out
    ui_nevra = property(fget=lambda self: self._ui_nevra())

    def __str__(self):
        return self.ui_envra

    def printVer(self):
        """returns a printable version string - including epoch, if it's set"""
        if self.epoch != '0':
            ver = '%s:%s-%s' % (self.epoch, self.version, self.release)
        else:
            ver = '%s-%s' % (self.version, self.release)

        return ver

    def verCMP(self, other):
        """ Compare package to another one, only rpm-version ordering. """
        if not other:
            return 1
        ret = cmp(self.name, other.name)
        if ret == 0:
            ret = comparePoEVR(self, other)
        return ret

    def __cmp__(self, other):
        """ Compare packages, this is just for UI/consistency. """
        ret = self.verCMP(other)
        if ret == 0:
            ret = cmp(self.arch, other.arch)
        if ret == 0 and hasattr(self, 'repoid') and hasattr(other, 'repoid'):
            ret = cmp(self.repoid, other.repoid)
            # We want 'installed' to appear over 'abcd' and 'xyz', so boost that
            if ret and self.repoid == 'installed':
                return 1
            if ret and other.repoid == 'installed':
                return -1
        return ret
    def __eq__(self, other):
        """ Compare packages for yes/no equality, includes everything in the
            UI package comparison. """
        if not other:
            return False
        if self.pkgtup != other.pkgtup:
            return False
        if hasattr(self, 'repoid') and hasattr(other, 'repoid'):
            if self.repoid != other.repoid:
                return False
        return True
    def __ne__(self, other):
        if not (self == other):
            return True
        return False

    def __getitem__(self, key):
        return getattr(self, key)

    def verEQ(self, other):
        """ Compare package to another one, only rpm-version equality. """
        if not other:
            return None
        ret = cmp(self.name, other.name)
        if ret != 0:
            return False
        return comparePoEVREQ(self, other)
    def verNE(self, other):
        """ Compare package to another one, only rpm-version inequality. """
        if not other:
            return None
        return not self.verEQ(other)
    def verLT(self, other):
        """ Uses verCMP, tests if the other _rpm-version_ is <  ours. """
        return self.verCMP(other) <  0
    def verLE(self, other):
        """ Uses verCMP, tests if the other _rpm-version_ is <= ours. """
        return self.verCMP(other) <= 0
    def verGT(self, other):
        """ Uses verCMP, tests if the other _rpm-version_ is >  ours. """
        return self.verCMP(other) >  0
    def verGE(self, other):
        """ Uses verCMP, tests if the other _rpm-version_ is >= ours. """
        return self.verCMP(other) >= 0

    def __repr__(self):
        return "<%s : %s (%s)>" % (self.__class__.__name__, str(self),hex(id(self))) 

    def returnSimple(self, varname):
        warnings.warn("returnSimple() will go away in a future version of Yum.\n",
                      Errors.YumFutureDeprecationWarning, stacklevel=2)
        return getattr(self, varname)

    def returnChecksums(self):
        return self._checksums

    checksums = property(fget=lambda self: self.returnChecksums())
    
    def returnIdSum(self):
        for (csumtype, csum, csumid) in self.checksums:
            if csumid:
                return (csumtype, csum)


_not_found_repo = FakeRepository('-')
_not_found_repo.cost = 0
class YumNotFoundPackage(PackageObject):

    def __init__(self, pkgtup):
        self.name    = pkgtup[0]
        self.arch    = pkgtup[1]
        self.epoch   = pkgtup[2]
        self.version = pkgtup[3]
        self.release = pkgtup[4]
        self.pkgtup  = pkgtup

        self.size = 0
        self._checksums = [] # (type, checksum, id(0,1)

        self.repo = _not_found_repo
        self.repoid = _not_found_repo.id

    # Fakeout output.py that it's a real pkg. ...
    def _ui_from_repo(self):
        """ This just returns '-' """
        return self.repoid
    ui_from_repo = property(fget=lambda self: self._ui_from_repo())

    def verifyLocalPkg(self):
        """check the package checksum vs the localPkg
           return True if pkg is good, False if not"""
        return False

#  This is the virtual base class of actual packages, it basically requires a
# repo. even though it doesn't set one up in it's __init__. It also doesn't have
# PackageObject methods ... so is basically unusable on it's own
# see: YumAvailablePackage.
class RpmBase(object):
    """return functions and storage for rpm-specific data"""

    def __init__(self):
        self.prco = {}
        self.prco['obsoletes'] = [] # (name, flag, (e,v,r))
        self.prco['conflicts'] = [] # (name, flag, (e,v,r))
        self.prco['requires'] = [] # (name, flag, (e,v,r))
        self.prco['provides'] = [] # (name, flag, (e,v,r))
        self.files = {}
        self.files['file'] = []
        self.files['dir'] = []
        self.files['ghost'] = []
        self._changelog = [] # (ctime, cname, ctext)
        self.licenses = []
        self._hash = None

    # FIXME: This is identical to PackageObject.__eq__ and __ne__, should be
    #        remove (is .repoid fine here? ... we need it, maybe .repo.id).
    def __eq__(self, other):
        if not other: # check if other not is a package object. 
            return False
        if self.pkgtup != other.pkgtup:
            return False
        if self.repoid != other.repoid:
            return False
        return True
    def __ne__(self, other):
        if not (self == other):
            return True
        return False

    def returnEVR(self):
        return PackageEVR(self.epoch, self.version, self.release)
    
    def __hash__(self):
        if self._hash is None:
            mystr = '%s - %s:%s-%s-%s.%s' % (self.repo.id, self.epoch, self.name,
                                         self.version, self.release, self.arch)
            self._hash = hash(mystr)
        return self._hash
        
    def returnPrco(self, prcotype, printable=False):
        """return list of provides, requires, conflicts or obsoletes"""
        
        prcos = self.prco.get(prcotype, [])

        if printable:
            results = []
            for prco in prcos:
                if not prco[0]: # empty or none or whatever, doesn't matter
                    continue
                results.append(misc.prco_tuple_to_string(prco))
            return results

        return prcos

    def checkPrco(self, prcotype, prcotuple):
        """returns 1 or 0 if the pkg contains the requested tuple/tuple range"""
        # get rid of simple cases - nothing
        if prcotype not in self.prco:
            return 0

        # First try and exact match, then search
        # Make it faster, if it's "big".
        if len(self.prco[prcotype]) <= 8:
            if prcotuple in self.prco[prcotype]:
                return 1
        else:
            if not hasattr(self, '_prco_lookup'):
                self._prco_lookup = {'obsoletes' : None, 'conflicts' : None,
                                     'requires'  : None, 'provides'  : None}

            if self._prco_lookup[prcotype] is None:
                self._prco_lookup[prcotype] = set(self.prco[prcotype])

            if prcotuple in self._prco_lookup[prcotype]:
                return 1

        if True: # Keep indentation for patch smallness...
            # make us look it up and compare
            (reqn, reqf, (reqe, reqv ,reqr)) = prcotuple
            if reqf is not None:
                return self.inPrcoRange(prcotype, prcotuple)
            else:
                for (n, f, (e, v, r)) in self.returnPrco(prcotype):
                    if i18n.str_eq(reqn, n):
                        return 1

        return 0

    def inPrcoRange(self, prcotype, reqtuple):
        """returns true if the package has a the prco that satisfies 
           the reqtuple range, assume false.
           Takes: prcotype, requested prco tuple"""
        return bool(self.matchingPrcos(prcotype, reqtuple))

    def matchingPrcos(self, prcotype, reqtuple):
        (reqn, reqf, (reqe, reqv, reqr)) = reqtuple
        # find the named entry in pkgobj, do the comparsion
        result = []
        for (n, f, (e, v, r)) in self.returnPrco(prcotype):
            if not i18n.str_eq(reqn, n):
                continue

            if f == '=':
                f = 'EQ'
            if f != 'EQ' and prcotype == 'provides':
                # isn't this odd, it's not 'EQ' and it is a provides
                # - it really should be EQ
                # use the pkgobj's evr for the comparison
                if e is None:
                    e = self.epoch
                if v is None:
                    v = self.ver
                if r is None:
                    r = self.rel
                #(e, v, r) = (self.epoch, self.ver, self.rel)

            matched = rpmUtils.miscutils.rangeCompare(
                reqtuple, (n, f, (e, v, r)))
            if matched:
                result.append((n, f, (e, v, r)))

        return result

    def provides_for(self, reqtuple):
        """check to see if the package object provides for the requirement
           passed, including searching filelists if the requirement is a file
           dep"""
        
        if self.checkPrco('provides', reqtuple):
            return True
        
        if reqtuple[0].startswith('/'):
            if misc.re_primary_filename(reqtuple[0]):
                pri_only = True
            else:
                pri_only = False

            for ftype in ('file', 'dir', 'ghost'):
                if reqtuple[0] in self.returnFileEntries(ftype, pri_only):
                    return True
        
        return False
        
    def returnChangelog(self):
        """return changelog entries"""
        return self._changelog
        
    def returnFileEntries(self, ftype='file', primary_only=False):
        """return list of files based on type, you can pass primary_only=True
           to limit to those files in the primary repodata"""
        if self.files:
            if ftype in self.files:
                if primary_only:
                    if ftype == 'dir':
                        match = misc.re_primary_dirname
                    else:
                        match = misc.re_primary_filename
                    return [fn for fn in self.files[ftype] if match(fn)]
                return self.files[ftype]
        return []
            
    def returnFileTypes(self, primary_only=False):
        """return list of types of files in the package, you can pass
           primary_only=True to limit to those files in the primary repodata"""
        if primary_only:
            ret = [] # We only return the types for the primary files.
            for ftype in self.files.keys():
                if ftype == 'dir':
                    match = misc.re_primary_dirname
                else:
                    match = misc.re_primary_filename
                #  As soon as we find a primary file of this type, we can
                # return it.
                for fn in self.files[ftype]:
                    if match(fn):
                        break
                else:
                    continue
                ret.append(ftype)
            return ret

        return self.files.keys()

    def returnPrcoNames(self, prcotype):
        if not hasattr(self, '_cache_prco_names_' + prcotype):
            data = [n for (n, f, v) in self.returnPrco(prcotype)]
            setattr(self, '_cache_prco_names_' + prcotype, data)
        return getattr(self, '_cache_prco_names_' + prcotype)

    def getProvidesNames(self):
        warnings.warn('getProvidesNames() will go away in a future version of Yum.\n',
                      Errors.YumDeprecationWarning, stacklevel=2)
        return self.provides_names

    def simpleFiles(self, ftype='files'):
        warnings.warn('simpleFiles() will go away in a future version of Yum.'
                      'Use returnFileEntries(primary_only=True)\n',
                      Errors.YumDeprecationWarning, stacklevel=2)
        if self.files and ftype in self.files:
            return self.files[ftype]
        return []
    
    filelist = property(fget=lambda self: self.returnFileEntries(ftype='file'))
    dirlist = property(fget=lambda self: self.returnFileEntries(ftype='dir'))
    ghostlist = property(fget=lambda self: self.returnFileEntries(ftype='ghost'))
    requires = property(fget=lambda self: self.returnPrco('requires'))
    provides = property(fget=lambda self: self.returnPrco('provides'))
    obsoletes = property(fget=lambda self: self.returnPrco('obsoletes'))
    conflicts = property(fget=lambda self: self.returnPrco('conflicts'))
    provides_names = property(fget=lambda self: self.returnPrcoNames('provides'))
    requires_names = property(fget=lambda self: self.returnPrcoNames('requires'))
    conflicts_names = property(fget=lambda self: self.returnPrcoNames('conflicts'))
    obsoletes_names = property(fget=lambda self: self.returnPrcoNames('obsoletes'))
    provides_print = property(fget=lambda self: self.returnPrco('provides', True))
    requires_print = property(fget=lambda self: self.returnPrco('requires', True))
    conflicts_print = property(fget=lambda self: self.returnPrco('conflicts', True))
    obsoletes_print = property(fget=lambda self: self.returnPrco('obsoletes', True))
    changelog = property(fget=lambda self: self.returnChangelog())
    EVR = property(fget=lambda self: self.returnEVR())
    
    def _getBaseName(self):
        """ Return the "base name" of the package, atm. we can only look at
            the sourcerpm. """
        if hasattr(self, '_base_package_name_ret'):
            return self._base_package_name_ret

        if hasattr(self, 'sourcerpm') and self.sourcerpm:
            (n, v, r, e, a) = rpmUtils.miscutils.splitFilename(self.sourcerpm)
            if n != self.name:
                self._base_package_name_ret = n
                return n

        # If there is no sourcerpm, or sourcerpm == us, use .name
        self._base_package_name_ret = self.name
        return self._base_package_name_ret

    base_package_name = property(fget=lambda self: self._getBaseName())

    def have_fastReturnFileEntries(self):
        """ Is calling pkg.returnFileEntries(primary_only=True) faster than
            using searchFiles(). """
        return self.repo.sack.have_fastReturnFileEntries()

    def obsoletedBy(self, obsoleters, limit=0):
        """ Returns list of obsoleters that obsolete this package. Note that we
            don't do obsoleting loops. If limit is != 0, then we stop after
            finding that many. """
        provtup = (self.name, 'EQ', (self.epoch, self.version, self.release))
        ret = []
        for obspo in obsoleters:
            if obspo.inPrcoRange('obsoletes', provtup):
                ret.append(obspo)
                if limit and len(ret) > limit:
                    break
        return ret



# This is kind of deprecated
class PackageEVR:

    """
    A comparable epoch, version, and release representation. Note that you
    almost certainly want to use pkg.verEQ() or pkg.verGT() etc. instead.
    """
    
    def __init__(self,e,v,r):
        self.epoch = e
        self.ver = v
        self.version = v
        self.rel = r
        self.release = r
        
    def compare(self,other):
        return rpmUtils.miscutils.compareEVR((self.epoch, self.ver, self.rel), (other.epoch, other.ver, other.rel))
    
    def __lt__(self, other):
        if self.compare(other) < 0:
            return True
        return False

        
    def __gt__(self, other):
        if self.compare(other) > 0:
            return True
        return False

    def __le__(self, other):
        if self.compare(other) <= 0:
            return True
        return False

    def __ge__(self, other):
        if self.compare(other) >= 0:
            return True
        return False

    def __eq__(self, other):
        return comparePoEVREQ(self, other)

    def __ne__(self, other):
        if not (self == other):
            return True
        return False
    

#  This is the real base class of actual packages, it has a repo. and is
# usable on it's own, in theory (but in practise see sqlitesack).
class YumAvailablePackage(PackageObject, RpmBase):
    """derived class for the  packageobject and RpmBase packageobject yum
       uses this for dealing with packages in a repository"""

    def __init__(self, repo, pkgdict = None):
        PackageObject.__init__(self)
        RpmBase.__init__(self)
        
        self.repoid = repo.id
        self.repo = repo
        self.state = None
        self._loadedfiles = False
        self._verify_local_pkg_cache = None

        if pkgdict != None:
            self.importFromDict(pkgdict)
            self.ver = self.version
            self.rel = self.release
        self.pkgtup = (self.name, self.arch, self.epoch, self.version, self.release)

    def _ui_from_repo(self):
        """ This reports the repo the package is from, we integrate YUMDB info.
            for RPM packages so a package from "fedora" that is installed has a
            ui_from_repo of "@fedora". Note that, esp. with the --releasever
            option, "fedora" or "rawhide" isn't authoritive.
            So we also check against the current releasever and if it is
            different we also print the YUMDB releasever. This means that
            installing from F12 fedora, while running F12, would report as
            "@fedora/13". """
        if self.repoid == 'installed' and 'from_repo' in self.yumdb_info:
            end = ''
            if (self.rpmdb.releasever is not None and
                'releasever' in self.yumdb_info and
                self.yumdb_info.releasever != self.rpmdb.releasever):
                end = '/' + self.yumdb_info.releasever
            return '@' + self.yumdb_info.from_repo + end
        return self.repoid
    ui_from_repo = property(fget=lambda self: self._ui_from_repo())

    def exclude(self):
        """remove self from package sack"""
        self.repo.sack.delPackage(self)
        
    def printVer(self):
        """returns a printable version string - including epoch, if it's set"""
        if self.epoch != '0':
            ver = '%s:%s-%s' % (self.epoch, self.version, self.release)
        else:
            ver = '%s-%s' % (self.version, self.release)
        
        return ver
    
    def compactPrint(self):
        ver = self.printVer()
        return "%s.%s %s" % (self.name, self.arch, ver)

    def _size(self):
        return self.packagesize
    
    def _remote_path(self):
        return self.relativepath

    def _remote_url(self):
        """returns a URL that can be used for downloading the package.
        Note that if you're going to download the package in your tool,
        you should use self.repo.getPackage."""
        base = self.basepath
        if base:
            # urljoin sucks in the reverse way that os.path.join sucks :)
            if base[-1] != '/':
                base = base + '/'
            return urlparse.urljoin(base, self.remote_path)
        return urlparse.urljoin(self.repo.urls[0], self.remote_path)

    size = property(fget=lambda self: self._size())
    remote_path = property(_remote_path)
    remote_url = property(_remote_url)

    def _committer(self):
        "Returns the name of the last person to do a commit to the changelog."

        if hasattr(self, '_committer_ret'):
            return self._committer_ret

        def _nf2ascii(x):
            """ does .encode("ascii", "replace") but it never fails. """
            ret = []
            for val in x:
                if ord(val) >= 128:
                    val = '?'
                ret.append(val)
            return "".join(ret)

        if not len(self.changelog): # Empty changelog is _possible_ I guess
            self._committer_ret = self.packager
            return self._committer_ret
        val = self.changelog[0][1]
        # Chagnelog data is in multiple locale's, so we convert to ascii
        # ignoring "bad" chars.
        val = _nf2ascii(val)
        # Hacky way to get rid of version numbers...
        ix = val.find('> ')
        if ix != -1:
            val = val[0:ix+1]
        self._committer_ret = val
        return self._committer_ret

    committer  = property(_committer)
    
    def _committime(self):
        "Returns the time of the last commit to the changelog."

        if hasattr(self, '_committime_ret'):
            return self._committime_ret

        if not len(self.changelog): # Empty changelog is _possible_ I guess
            self._committime_ret = self.buildtime
            return self._committime_ret
        
        self._committime_ret = self.changelog[0][0]
        return self._committime_ret

    committime = property(_committime)
    
    # FIXME test this to see if it causes hell elsewhere
    def _checksum(self):
        "Returns the 'default' checksum"
        return self.checksums[0][1]
    checksum = property(_checksum)

    def getDiscNum(self):
        if self.basepath is None:
            return None
        (scheme, netloc, path, query, fragid) = urlparse.urlsplit(self.basepath)
        if scheme == "media":
            if len(fragid) == 0:
                return 0
            return int(fragid)
        return None
    
    def returnHeaderFromPackage(self):
        rpmfile = self.localPkg()
        ts = rpmUtils.transaction.initReadOnlyTransaction()
        try:
            hdr = rpmUtils.miscutils.hdrFromPackage(ts, rpmfile)
        except rpmUtils.RpmUtilsError:
            raise Errors.RepoError, 'Package Header %s: RPM Cannot open' % self
        return hdr
        
    def returnLocalHeader(self):
        """returns an rpm header object from the package object's local
           header cache"""
        
        if os.path.exists(self.localHdr()):
            try: 
                hlist = rpm.readHeaderListFromFile(self.localHdr())
                hdr = hlist[0]
            except (rpm.error, IndexError):
                raise Errors.RepoError, 'Package Header %s: Cannot open' % self
        else:
            raise Errors.RepoError, 'Package Header %s: Not Available' % self

        return hdr

       
    def localPkg(self):
        """return path to local package (whether it is present there, or not)"""
        if not hasattr(self, 'localpath'):
            rpmfn = os.path.basename(self.remote_path)
            self.localpath = self.repo.pkgdir + '/' + rpmfn
        return self.localpath

    def localHdr(self):
        """return path to local cached Header file downloaded from package 
           byte ranges"""
           
        if not hasattr(self, 'hdrpath'):
            pkgname = os.path.basename(self.remote_path)
            hdrname = pkgname[:-4] + '.hdr'
            self.hdrpath = self.repo.hdrdir + '/' + hdrname

        return self.hdrpath
    
    def verifyLocalPkg(self):
        """check the package checksum vs the localPkg
           return True if pkg is good, False if not"""

        #  This is called a few times now, so we want some way to not have to
        # read+checksum "large" datasets multiple times per. transaction.
        try:
            nst = os.stat(self.localPkg())
        except OSError, e:
            return False
        if (hasattr(self, '_verify_local_pkg_cache') and
            self._verify_local_pkg_cache):
            ost = self._verify_local_pkg_cache
            if (ost.st_ino   == nst.st_ino   and
                ost.st_dev   == nst.st_dev   and
                ost.st_mtime == nst.st_mtime and
                ost.st_size  == nst.st_size):
                return True

        (csum_type, csum) = self.returnIdSum()
        
        try:
            filesum = misc.checksum(csum_type, self.localPkg(),
                                    datasize=self.packagesize)
        except Errors.MiscError:
            return False
        
        if filesum != csum:
            return False
        
        self._verify_local_pkg_cache = nst

        return True

    # See: http://www.freedesktop.org/wiki/CommonExtendedAttributes
    def _localXattrUrl(self):
        """ Get the user.xdg.origin.url value from the local pkg. ... if it's
            present. We cache this so we can access it after the file has been
            deleted (keepcache=False). """

        if xattr is None:
            return None

        if hasattr(self, '__cached_localXattrUrl'):
            return getattr(self, '__cached_localXattrUrl')

        if not self.verifyLocalPkg():
            return None

        try:
            ret = xattr.get(self.localPkg(), 'user.xdg.origin.url')
        except: # Documented to be "EnvironmentError", but make sure
            return None

        setattr(self, '__cached_localXattrUrl', ret)
        return ret

    xattr_origin_url = property(lambda x: x._localXattrUrl())

    def prcoPrintable(self, prcoTuple):
        """convert the prco tuples into a nicer human string"""
        warnings.warn('prcoPrintable() will go away in a future version of Yum.\n',
                      Errors.YumDeprecationWarning, stacklevel=2)
        return misc.prco_tuple_to_string(prcoTuple)

    def requiresList(self):
        """return a list of requires in normal rpm format"""
        return self.requires_print

    def returnChecksums(self):
        return [(self.checksum_type, self.pkgId, 1)]
        
    def importFromDict(self, pkgdict):
        """handles an mdCache package dictionary item to populate out 
           the package information"""
        
        # translates from the pkgdict, populating out the information for the
        # packageObject
        
        if hasattr(pkgdict, 'nevra'):
            (n, e, v, r, a) = pkgdict.nevra
            self.name = n
            self.epoch = e
            self.version = v
            self.arch = a
            self.release = r
        
        if hasattr(pkgdict, 'time'):
            self.buildtime = pkgdict.time['build']
            self.filetime = pkgdict.time['file']
        
        if hasattr(pkgdict, 'size'):
            self.packagesize = pkgdict.size['package']
            self.archivesize = pkgdict.size['archive']
            self.installedsize = pkgdict.size['installed']
        
        if hasattr(pkgdict, 'location'):
            url = pkgdict.location.get('base')
            if url == '':
                url = None

            self.basepath = url
            self.relativepath = pkgdict.location['href']

        if hasattr(pkgdict, 'hdrange'):
            self.hdrstart = pkgdict.hdrange['start']
            self.hdrend = pkgdict.hdrange['end']
        
        if hasattr(pkgdict, 'info'):
            for item in ['summary', 'description', 'packager', 'group',
                         'buildhost', 'sourcerpm', 'url', 'vendor']:
                setattr(self, item, pkgdict.info[item])
            self.summary = self.summary.replace('\n', '')
            
            self.licenses.append(pkgdict.info['license'])
        
        if hasattr(pkgdict, 'files'):
            for fn in pkgdict.files:
                ftype = pkgdict.files[fn]
                if ftype not in self.files:
                    self.files[ftype] = []
                self.files[ftype].append(fn)
        
        if hasattr(pkgdict, 'prco'):
            for rtype in pkgdict.prco:
                for rdict in pkgdict.prco[rtype]:
                    name = rdict['name']
                    f = rdict.get('flags')
                    e = rdict.get('epoch')
                    v = rdict.get('ver')
                    r = rdict.get('rel')
                    self.prco[rtype].append((name, f, (e,v,r)))

        if hasattr(pkgdict, 'changelog'):
            for cdict in pkgdict.changelog:
                date = cdict.get('date')
                text = cdict.get('value')
                author = cdict.get('author')
                self._changelog.append((date, author, text))
        
        if hasattr(pkgdict, 'checksum'):
            ctype = pkgdict.checksum['type']
            csum = pkgdict.checksum['value']
            csumid = pkgdict.checksum['pkgid']
            if csumid is None or csumid.upper() == 'NO':
                csumid = 0
            elif csumid.upper() == 'YES':
                csumid = 1
            else:
                csumid = 0
            self._checksums.append((ctype, csum, csumid))

# from here down this is for dumping a package object back out to metadata
    
    
    def _return_remote_location(self):
        # break self.remote_url up into smaller pieces
        base = os.path.dirname(self.remote_url)
        href = os.path.basename(self.remote_url)
        msg = """<location xml:base="%s" href="%s"/>\n""" % (
                  misc.to_xml(base,attrib=True), misc.to_xml(href, attrib=True))
        return msg
        
    def _dump_base_items(self):
        
        packager = url = ''
        if self.packager:
            packager = misc.to_unicode(misc.to_xml(self.packager))
        
        if self.url:
            url = misc.to_unicode(misc.to_xml(self.url))
        (csum_type, csum, csumid) = self.checksums[0]
        msg = """
  <name>%s</name>
  <arch>%s</arch>
  <version epoch="%s" ver="%s" rel="%s"/>
  <checksum type="%s" pkgid="YES">%s</checksum>
  <summary>%s</summary>
  <description>%s</description>
  <packager>%s</packager>
  <url>%s</url>
  <time file="%s" build="%s"/>
  <size package="%s" installed="%s" archive="%s"/>\n""" % (self.name, 
         self.arch, self.epoch, self.ver, self.rel, csum_type, csum, 
         misc.to_unicode(misc.to_xml(self.summary)), 
         misc.to_unicode(misc.to_xml(self.description)), 
         packager, url, self.filetime, 
         self.buildtime, self.packagesize, self.size, self.archivesize)
        
        msg += self._return_remote_location()
        return msg

    def _dump_format_items(self):
        msg = "  <format>\n"
        if self.license:
            msg += """    <rpm:license>%s</rpm:license>\n""" % misc.to_xml(self.license)
        else:
            msg += """    <rpm:license/>\n"""
            
        if self.vendor:
            msg += """    <rpm:vendor>%s</rpm:vendor>\n""" % misc.to_xml(self.vendor)
        else:
            msg += """    <rpm:vendor/>\n"""
            
        if self.group:
            msg += """    <rpm:group>%s</rpm:group>\n""" % misc.to_xml(self.group)
        else:
            msg += """    <rpm:group/>\n"""
            
        if self.buildhost:
            msg += """    <rpm:buildhost>%s</rpm:buildhost>\n""" % misc.to_xml(self.buildhost)
        else:
            msg += """    <rpm:buildhost/>\n"""
            
        if self.sourcerpm:
            msg += """    <rpm:sourcerpm>%s</rpm:sourcerpm>\n""" % misc.to_xml(self.sourcerpm)
        else: # b/c yum 2.4.3 and OLD y-m-p willgfreak out if it is not there.
            msg += """    <rpm:sourcerpm/>\n"""
        
        msg +="""    <rpm:header-range start="%s" end="%s"/>""" % (self.hdrstart,
                                                               self.hdrend)
        msg += self._dump_pco('provides')
        msg += self._dump_requires()
        msg += self._dump_pco('conflicts')         
        msg += self._dump_pco('obsoletes')         
        msg += self._dump_files(True)
        if msg[-1] != '\n':
            msg += """\n"""
        msg += """  </format>"""
        
        return msg

    def _dump_pco(self, pcotype):
           
        msg = ""
        mylist = getattr(self, pcotype)
        if mylist: msg = "\n    <rpm:%s>\n" % pcotype
        for (name, flags, (e,v,r)) in mylist:
            pcostring = '''      <rpm:entry name="%s"''' % misc.to_xml(name, attrib=True)
            if flags:
                pcostring += ''' flags="%s"''' % misc.to_xml(flags, attrib=True)
                if e:
                    pcostring += ''' epoch="%s"''' % misc.to_xml(e, attrib=True)
                if v:
                    pcostring += ''' ver="%s"''' % misc.to_xml(v, attrib=True)
                if r:
                    pcostring += ''' rel="%s"''' % misc.to_xml(r, attrib=True)
                    
            pcostring += "/>\n"
            msg += pcostring
            
        if mylist: msg += "    </rpm:%s>" % pcotype
        return msg
    
    def _dump_files(self, primary=False):
        msg ="\n"
        if not primary:
            files = self.returnFileEntries('file')
            dirs = self.returnFileEntries('dir')
            ghosts = self.returnFileEntries('ghost')
        else:
            files = self.returnFileEntries('file', primary_only=True)
            dirs = self.returnFileEntries('dir', primary_only=True)
            ghosts = self.returnFileEntries('ghost', primary_only=True)
                
        for fn in files:
            msg += """    <file>%s</file>\n""" % misc.to_xml(fn)
        for fn in dirs:
            msg += """    <file type="dir">%s</file>\n""" % misc.to_xml(fn)
        for fn in ghosts:
            msg += """    <file type="ghost">%s</file>\n""" % misc.to_xml(fn)
        
        return msg


    def _requires_with_pre(self):
        raise NotImplementedError()
                    
    def _dump_requires(self):
        """returns deps in XML format"""
        mylist = self._requires_with_pre()

        msg = ""

        if mylist: msg = "\n    <rpm:requires>\n"
        if hasattr(self, '_collapse_libc_requires') and self._collapse_libc_requires:
            libc_requires = filter(lambda x: x[0].startswith('libc.so.6'), mylist)
            if libc_requires:
                rest = sorted(libc_requires, cmp=compareVerOnly, key=itemgetter(0))
                best = rest.pop()
                if len(rest) > 0 and best[0].startswith('libc.so.6()'): # rpmvercmp will sort this one as 'highest' so we need to remove it from the list
                    best = rest.pop()
                newlist = []
                for i in mylist:
                    if i[0].startswith('libc.so.6') and i != best:
                        continue
                    newlist.append(i)
                mylist = newlist
        
        for (name, flags, (e,v,r),pre) in mylist:
            if name.startswith('rpmlib('):
                continue
            # this drops out requires that the pkg provides for itself.
            if name in self.provides_names or \
                    (name.startswith('/') and \
                         (name in self.filelist or name in self.dirlist or
                          name in self.ghostlist)):
                if not flags:
                    continue
                else:
                    if self.checkPrco('provides', (name, flags, (e,v,r))):
                        continue
            prcostring = '''      <rpm:entry name="%s"''' % misc.to_xml(name, attrib=True)
            if flags:
                prcostring += ''' flags="%s"''' % misc.to_xml(flags, attrib=True)
                if e:
                    prcostring += ''' epoch="%s"''' % misc.to_xml(e, attrib=True)
                if v:
                    prcostring += ''' ver="%s"''' % misc.to_xml(v, attrib=True)
                if r:
                    prcostring += ''' rel="%s"''' % misc.to_xml(r, attrib=True)
            if pre:
                prcostring += ''' pre="%s"''' % pre
                    
            prcostring += "/>\n"
            msg += prcostring
            
        if mylist: msg += "    </rpm:requires>"
        return msg

    def _dump_changelog(self, clog_limit):
        if not self.changelog:
            return ""
        msg = "\n"
        # We need to output them "backwards", so the oldest is first
        if not clog_limit:
            clogs = self.changelog
        else:
            clogs = self.changelog[:clog_limit]
        last_ts = 0
        hack_ts = 0
        for (ts, author, content) in reversed(clogs):
            if ts != last_ts:
                hack_ts = 0
            else:
                hack_ts += 1
            last_ts = ts
            ts += hack_ts
            msg += """<changelog author="%s" date="%s">%s</changelog>\n""" % (
                        misc.to_xml(author, attrib=True), misc.to_xml(str(ts)), 
                        misc.to_xml(content))
        return msg

    def xml_dump_primary_metadata(self):
        msg = """\n<package type="rpm">"""
        msg += misc.to_unicode(self._dump_base_items())
        msg += misc.to_unicode(self._dump_format_items())
        msg += """\n</package>"""
        return misc.to_utf8(msg)

    def xml_dump_filelists_metadata(self):
        msg = """\n<package pkgid="%s" name="%s" arch="%s">
    <version epoch="%s" ver="%s" rel="%s"/>\n""" % (self.checksum, self.name, 
                                     self.arch, self.epoch, self.ver, self.rel)
        msg += misc.to_unicode(self._dump_files())
        msg += "</package>\n"
        return misc.to_utf8(msg)

    def xml_dump_other_metadata(self, clog_limit=0):
        msg = """\n<package pkgid="%s" name="%s" arch="%s">
    <version epoch="%s" ver="%s" rel="%s"/>\n""" % (self.checksum, self.name, 
                                     self.arch, self.epoch, self.ver, self.rel)
        msg += "%s\n</package>\n" % misc.to_unicode(self._dump_changelog(clog_limit))
        return misc.to_utf8(msg)



#  This is a tweak on YumAvailablePackage() and is a base class for packages
# which are actual rpms.
class YumHeaderPackage(YumAvailablePackage):
    """Package object built from an rpm header"""
    def __init__(self, repo, hdr):
        """hand in an rpm header, we'll assume it's installed and query from there"""
       
        YumAvailablePackage.__init__(self, repo)

        self.hdr = hdr
        self.name = misc.share_data(self.hdr['name'])
        this_a = self.hdr['arch']
        if not this_a: # this should only happen on gpgkeys and other "odd" pkgs
            this_a = 'noarch'
        self.arch = misc.share_data(this_a)
        self.epoch = misc.share_data(self.doepoch())
        self.version = misc.share_data(self.hdr['version'])
        self.release = misc.share_data(self.hdr['release'])
        self.ver = self.version
        self.rel = self.release
        self.pkgtup = (self.name, self.arch, self.epoch, self.version, self.release)
        self._loaded_summary = None
        self._loaded_description = None
        self.pkgid = self.hdr[rpm.RPMTAG_SHA1HEADER]
        if not self.pkgid:
            self.pkgid = "%s.%s" %(self.hdr['name'], self.hdr['buildtime'])
        self.packagesize = self.hdr['size']
        self.__mode_cache = {}
        self.__prcoPopulated = False

    def _loadSummary(self):
        # Summaries "can be" empty, which rpm return [], see BZ 473239, *sigh*
        if self._loaded_summary is None:
            summary = self._get_hdr()['summary'] or ''
            summary = misc.share_data(summary.replace('\n', ''))
            self._loaded_summary = summary
        return self._loaded_summary
    summary = property(lambda x: x._loadSummary())

    def _loadDescription(self):
        if self._loaded_description is None:
            description = self._get_hdr()['description'] or ''
            description = misc.share_data(description)
            self._loaded_description = description
        return self._loaded_description
    description = property(lambda x: x._loadDescription())

    def __str__(self):
        if self.epoch == '0':
            val = '%s-%s-%s.%s' % (self.name, self.version, self.release,
                                        self.arch)
        else:
            val = '%s:%s-%s-%s.%s' % (self.epoch,self.name, self.version,
                                           self.release, self.arch)
        return val

    def returnPrco(self, prcotype, printable=False):
        if not self.__prcoPopulated:
            self._populatePrco()
            self.__prcoPopulated = True
        return YumAvailablePackage.returnPrco(self, prcotype, printable)

    def _get_hdr(self):
        return self.hdr

    def _populatePrco(self):
        "Populate the package object with the needed PRCO interface."

        tag2prco = { "OBSOLETE": misc.share_data("obsoletes"),
                     "CONFLICT": misc.share_data("conflicts"),
                     "REQUIRE":  misc.share_data("requires"),
                     "PROVIDE":  misc.share_data("provides") }
        hdr = self._get_hdr()
        for tag in tag2prco:
            name = hdr[getattr(rpm, 'RPMTAG_%sNAME' % tag)]
            name = map(misc.share_data, name)
            if not name: # empty or none or whatever, doesn't matter
                continue

            lst = hdr[getattr(rpm, 'RPMTAG_%sFLAGS' % tag)]
            flag = map(rpmUtils.miscutils.flagToString, lst)
            flag = map(misc.share_data, flag)

            lst = hdr[getattr(rpm, 'RPMTAG_%sVERSION' % tag)]
            vers = map(rpmUtils.miscutils.stringToVersion, lst)
            vers = map(lambda x: (misc.share_data(x[0]), misc.share_data(x[1]),
                                  misc.share_data(x[2])), vers)

            prcotype = tag2prco[tag]
            self.prco[prcotype] = map(misc.share_data, zip(name,flag,vers))
    
    def tagByName(self, tag):
        warnings.warn("tagByName() will go away in a furture version of Yum.\n",
                      Errors.YumFutureDeprecationWarning, stacklevel=2)
        try:
            return getattr(self, tag)
        except AttributeError:
            raise Errors.MiscError, "Unknown header tag %s" % tag

    def __getattr__(self, thing):
        #FIXME - if an error - return AttributeError, not KeyError 
        # ONLY FIX THIS AFTER THE API BREAK
        if thing.startswith('__') and thing.endswith('__'):
            # If these existed, then we wouldn't get here ...
            # So these are missing.
            raise AttributeError, "%s has no attribute %s" % (self, thing)
        try:
            return self.hdr[thing]
        except KeyError:
            #  Note above, API break to fix this ... this at least is a nicer
            # msg. so we know what we accessed that is bad.
            raise KeyError, "%s has no attribute %s" % (self, thing)
        except ValueError:
            #  Note above, API break to fix this ... this at least is a nicer
            # msg. so we know what we accessed that is bad.
            raise ValueError, "%s has no attribute %s" % (self, thing)

    def doepoch(self):
        tmpepoch = self.hdr['epoch']
        if tmpepoch is None:
            epoch = '0'
        else:
            epoch = str(tmpepoch)
        
        return epoch

    def returnLocalHeader(self):
        return self.hdr
    

    def _loadFiles(self):
        files = self.hdr['filenames']
        fileflags = self.hdr['fileflags']
        filemodes = self.hdr['filemodes']
        filetuple = zip(files, filemodes, fileflags)
        if not self._loadedfiles:
            for (fn, mode, flag) in filetuple:
                #garbage checks
                if mode is None or mode == '':
                    if 'file' not in self.files:
                        self.files['file'] = []
                    self.files['file'].append(fn)
                    continue
                if mode not in self.__mode_cache:
                    self.__mode_cache[mode] = stat.S_ISDIR(mode)
          
                fkey = 'file'
                if self.__mode_cache[mode]:
                    fkey = 'dir'
                elif flag is not None and (flag & 64):
                    fkey = 'ghost'
                self.files.setdefault(fkey, []).append(fn)

            self._loadedfiles = True
            
    def returnFileEntries(self, ftype='file', primary_only=False):
        """return list of files based on type"""
        self._loadFiles()
        return YumAvailablePackage.returnFileEntries(self,ftype,primary_only)
    
    def returnChangelog(self):
        # note - if we think it is worth keeping changelogs in memory
        # then create a _loadChangelog() method to put them into the 
        # self._changelog attr
        if len(self.hdr['changelogname']) > 0:
            return zip(misc.to_unicode(self.hdr['changelogtime'], errors='replace'),
                       misc.to_unicode(self.hdr['changelogname'], errors='replace'),
                       misc.to_unicode(self.hdr['changelogtext'], errors='replace'))
        return []

    def returnChecksums(self):
        raise NotImplementedError()

    def _size(self):
        return self.hdr['size']

    def _is_pre_req(self, flag):
        """check the flags for a requirement, return 1 or 0 whether or not requires
           is a pre-requires or a not"""
        # FIXME this should probably be put in rpmUtils.miscutils since 
        # - that's what it is
        if flag is not None:
            # Note: RPMSENSE_PREREQ == 0 since rpm-4.4'ish
            if flag & (rpm.RPMSENSE_PREREQ |
                       rpm.RPMSENSE_SCRIPT_PRE |
                       rpm.RPMSENSE_SCRIPT_POST):
                return 1
        return 0

    def _requires_with_pre(self):
        """returns requires with pre-require bit"""
        name = self.hdr[rpm.RPMTAG_REQUIRENAME]
        lst = self.hdr[rpm.RPMTAG_REQUIREFLAGS]
        flag = map(flagToString, lst)
        pre = map(self._is_pre_req, lst)
        lst = self.hdr[rpm.RPMTAG_REQUIREVERSION]
        vers = map(stringToVersion, lst)
        if name is not None:
            lst = zip(name, flag, vers, pre)
        mylist = misc.unique(lst)
        return mylist

class _CountedReadFile:
    """ Has just a read() method, and keeps a count so we can find out how much
        has been read. Implemented so we can get the real size of the file from
        prelink. """
    
    def __init__(self, fp):
        self.fp = fp
        self.read_size = 0

    def read(self, size):
        ret = self.fp.read(size)
        self.read_size += len(ret)
        return ret

class _PkgVerifyProb:
    """ Holder for each "problem" we find with a pkg.verify(). """
    
    def __init__(self, type, msg, ftypes, fake=False):
        self.type           = type
        self.message        = msg
        self.database_value = None
        self.disk_value     = None
        self.file_types     = ftypes
        self.fake           = fake

    def __cmp__(self, other):
        if other is None:
            return 1
        type2sort = {'type' :  1, 'symlink' : 2, 'checksum' : 3, 'size'    :  4,
                     'user' :  4, 'group'   : 5, 'mode' : 6, 'genchecksum' :  7,
                     'mtime' : 8, 'missing' : 9, 'permissions-missing'     : 10,
                     'state' : 11, 'missingok' : 12, 'ghost' : 13}
        ret = cmp(type2sort[self.type], type2sort[other.type])
        if not ret:
            for attr in ['disk_value', 'database_value', 'file_types']:
                x = getattr(self,  attr)
                y = getattr(other, attr)
                if x is None:
                    assert y is None
                    continue
                ret = cmp(x, y)
                if ret:
                    break
        return ret

# From: lib/rpmvf.h ... not in rpm *sigh*
_RPMVERIFY_DIGEST   = (1 << 0)
_RPMVERIFY_FILESIZE = (1 << 1)
_RPMVERIFY_LINKTO   = (1 << 2)
_RPMVERIFY_USER     = (1 << 3)
_RPMVERIFY_GROUP    = (1 << 4)
_RPMVERIFY_MTIME    = (1 << 5)
_RPMVERIFY_MODE     = (1 << 6)
_RPMVERIFY_RDEV     = (1 << 7)
_RPMVERIFY_CAPS     = (1 << 8)
_RPMVERIFY_CONTEXTS = (1 << 15)

class YUMVerifyPackageFile(object):
    def __init__(self, filename):
        self.filename = filename

        self.readlink = None
        self.mtime    = None
        self.dev      = None
        self.user     = None
        self.group    = None
        self.mode     = None
        self.digest   = None
        self.size     = None

        self.verify_ftype  = False

        self.rpmfile_type  = set()
        self.rpmfile_state = None

    def _setVerifiedAttr(self, attr, val, vattr=None):
        if vattr is None:
            vattr = "verify_" + attr
        attr = "_" + attr
        setattr(self, attr, val)
        setattr(self, vattr, val is not None)

    readlink = property(fget=lambda x: x._readlink,
                        fdel=lambda x: setattr(x, 'readlink', None),
                        fset=lambda x,y: x._setVerifiedAttr("readlink", y))
    mtime    = property(fget=lambda x: x._mtime,
                        fdel=lambda x: setattr(x, 'mtime', None),
                        fset=lambda x,y: x._setVerifiedAttr("mtime", y))
    dev      = property(fget=lambda x: x._dev,
                        fdel=lambda x: setattr(x, 'dev', None),
                        fset=lambda x,y: x._setVerifiedAttr("dev", y))
    user     = property(fget=lambda x: x._user,
                        fdel=lambda x: setattr(x, 'user', None),
                        fset=lambda x,y: x._setVerifiedAttr("user", y))
    group    = property(fget=lambda x: x._group,
                        fdel=lambda x: setattr(x, 'group', None),
                        fset=lambda x,y: x._setVerifiedAttr("group", y))
    # Mode is special, because it's shared with ftype.
    digest   = property(fget=lambda x: x._digest,
                        fdel=lambda x: setattr(x, 'digest', None),
                        fset=lambda x,y: x._setVerifiedAttr("digest", y))
    size     = property(fget=lambda x: x._size,
                        fdel=lambda x: setattr(x, 'size', None),
                        fset=lambda x,y: x._setVerifiedAttr("size", y))

    def _setVerifiedMode(self, attr, val):
        self.verify_mode  = val is not None
        self.verify_ftype = val is not None
        attr = "_" + attr
        setattr(self, attr, val)

    mode = property(fget=lambda x: x._mode,
                    fdel=lambda x: setattr(x, 'mode', None),
                    fset=lambda x,y: x._setVerifiedMode("mode", y))

    @staticmethod
    def _ftype(mode):
        """ Given a "mode" return the name of the type of file. """
        if stat.S_ISREG(mode):  return "file"
        if stat.S_ISDIR(mode):  return "directory"
        if stat.S_ISLNK(mode):  return "symlink"
        if stat.S_ISFIFO(mode): return "fifo"
        if stat.S_ISCHR(mode):  return "character device"
        if stat.S_ISBLK(mode):  return "block device"
        return "<unknown>"

    ftype = property(fget=lambda x: x._ftype(x.mode))


class _RPMVerifyPackageFile(YUMVerifyPackageFile):
    def __init__(self, fi, filetuple, csum_type, override_vflags=False):
        YUMVerifyPackageFile.__init__(self, filetuple[0])

        flags          = filetuple[4]
        if override_vflags:
            vflags = -1
        else:
            vflags = filetuple[9]

        if vflags & _RPMVERIFY_FILESIZE:
            self.size      = filetuple[1]

        if vflags & _RPMVERIFY_RDEV|_RPMVERIFY_MODE:
            mode           = filetuple[2]
            if mode < 0:
                # Stupid rpm, should be unsigned value but is signed ...
                # so we "fix" it via. this hack
                mode = (mode & 0xFFFF)

            self.mode = mode
            if not (vflags & _RPMVERIFY_MODE):
                self.verify_mode  = False
            if not (vflags & _RPMVERIFY_RDEV):
                self.verify_ftype = False

        if vflags & _RPMVERIFY_MTIME:
            self.mtime     = filetuple[3]
        if vflags & _RPMVERIFY_RDEV:
            self.dev       = filetuple[5]

        self.rpmfile_types = rpmfile_types = set()
        if flags & rpm.RPMFILE_CONFIG:
            rpmfile_types.add('configuration')
        if flags & rpm.RPMFILE_DOC:
            rpmfile_types.add('documentation')
        if flags & rpm.RPMFILE_GHOST:
            rpmfile_types.add('ghost')
        if flags & rpm.RPMFILE_LICENSE:
            rpmfile_types.add('license')
        if flags & rpm.RPMFILE_PUBKEY:
            rpmfile_types.add('public key')
        if flags & rpm.RPMFILE_README:
            rpmfile_types.add('README')
        if flags & rpm.RPMFILE_MISSINGOK:
            rpmfile_types.add('missing ok')

        # 6 == inode
        # 7 == link
        state = filetuple[8]
        statemap = {rpm.RPMFILE_STATE_NORMAL : 'normal',
                    rpm.RPMFILE_STATE_REPLACED : 'replaced',
                    rpm.RPMFILE_STATE_NOTINSTALLED : 'not installed',
                    rpm.RPMFILE_STATE_WRONGCOLOR : 'wrong color',
                    rpm.RPMFILE_STATE_NETSHARED : 'netshared'}

        if state in statemap:
            self.rpmfile_state = statemap[state]
        else:
            self.rpmfile_state = "<unknown>"

        if vflags & _RPMVERIFY_USER:
            self.user      = filetuple[10]
        if vflags & _RPMVERIFY_GROUP:
            self.group     = filetuple[11]
        if vflags & _RPMVERIFY_DIGEST:
            self.digest    = (csum_type, filetuple[12])

        if self.ftype == 'symlink' and vflags & _RPMVERIFY_LINKTO:
            self.readlink = fi.FLink() # fi.foo is magic, don't think about it
        elif vflags & _RPMVERIFY_LINKTO:
            self.readlink = ''


class YUMVerifyPackage:
    """ A holder for YUMVerifyPackageFile objects. """
    def __init__(self, po):
        self.po = po
        self._files = {}

    def __contains__(self, fname):
        """ Note that this checks if a filename is part of the package, and
            not a full YUMVerifyPackageFile(). """
        return fname in self._files

    def __iter__(self):
        for fn in self._files:
            yield self._files[fn]

    def add(self, vpf):
        self._files[vpf.filename] = vpf

    def remove(self, vpf):
        del self._files[vpf.filename]

    def discard(self, vpf):
        if vpf.filename not in self:
            return
        self.remove(vpf)

    def clear(self):
        self._files = {}


class _RPMVerifyPackage(YUMVerifyPackage):
    def __init__(self, po, fi, def_csum_type, patterns, all):
        YUMVerifyPackage.__init__(self, po)

        self._presetup = (fi, def_csum_type, patterns, all)
    def _setup(self):
        if not hasattr(self, '_presetup'):
            return

        (fi, def_csum_type, patterns, all) = self._presetup
        del self._presetup

        for ft in fi:
            fn = ft[0]
            if patterns:
                matched = False
                for p in patterns:
                    if fnmatch.fnmatch(fn, p):
                        matched = True
                        break
                if not matched: 
                    continue

            self.add(_RPMVerifyPackageFile(fi, ft, def_csum_type, all))

    def __contains__(self, *args, **kwargs):
        self._setup()
        return YUMVerifyPackage.__contains__(self, *args, **kwargs)
    def __iter__(self, *args, **kwargs):
        self._setup()
        return YUMVerifyPackage.__iter__(self, *args, **kwargs)
    def add(self, *args, **kwargs):
        self._setup()
        return YUMVerifyPackage.add(self, *args, **kwargs)
    def remove(self, *args, **kwargs):
        self._setup()
        return YUMVerifyPackage.remove(self, *args, **kwargs)
    # discard uses contains...
    def clear(self, *args, **kwargs):
        if hasattr(self, '_presetup'):
            del self._presetup
        return YUMVerifyPackage.clear(self, *args, **kwargs)


_installed_repo = FakeRepository('installed')
_installed_repo.cost = 0
# This is a tweak on YumHeaderPackage() for installed rpm packages.
class YumInstalledPackage(YumHeaderPackage):
    """super class for dealing with packages in the rpmdb"""
    def __init__(self, hdr, yumdb=None):
        YumHeaderPackage.__init__(self, _installed_repo, hdr)
        if yumdb:
            self.yumdb_info = yumdb.get_package(self)

    def verify(self, patterns=[], deps=False, script=False,
               fake_problems=True, all=False, fast=False, callback=None):
        """verify that the installed files match the packaged checksum
           optionally verify they match only if they are in the 'pattern' list
           returns a tuple """
        fi = self.hdr.fiFromHeader()
        results = {} # fn = problem_obj?

        # Use prelink_undo_cmd macro?
        prelink_cmd = "/usr/sbin/prelink"
        have_prelink = os.path.exists(prelink_cmd)

        # determine what checksum algo to use:
        csum_type = 'md5' # default for legacy
        if hasattr(rpm, 'RPMTAG_FILEDIGESTALGO'):
            csum_num = self.hdr[rpm.RPMTAG_FILEDIGESTALGO]
            if csum_num:
                if csum_num in RPM_CHECKSUM_TYPES:
                    csum_type = RPM_CHECKSUM_TYPES[csum_num]
                # maybe an else with an error code here? or even a verify issue?

        pfs = _RPMVerifyPackage(self, fi, csum_type, patterns, all)

        if callback is not None:
            pfs = callback(pfs)

        for pf in pfs:
            fn = pf.filename
            ftypes = list(pf.rpmfile_types)
            if pf.rpmfile_state != "normal":
                ftypes.append("state=" + pf.rpmfile_state)
                if fake_problems:
                    results[fn] = [_PkgVerifyProb('state',
                                                  'state is not normal',
                                                  ftypes, fake=True)]
                continue

            if 'missing ok' in pf.rpmfile_types and fake_problems:
                results[fn] = [_PkgVerifyProb('missingok', 'missing but ok',
                                              ftypes, fake=True)]
            if 'missing ok' in pf.rpmfile_types and not all:
                continue # rpm just skips missing ok, so we do too

            if 'ghost' in pf.rpmfile_types and fake_problems:
                results[fn] = [_PkgVerifyProb('ghost', 'ghost file', ftypes,
                                              fake=True)]
            if 'ghost' in pf.rpmfile_types and not all:
                continue

            # do check of file status on system
            problems = []
            if os.path.lexists(pf.filename):
                # stat
                my_st = os.lstat(pf.filename)
                my_st_size = my_st.st_size
                try:
                    my_user  = pwd.getpwuid(my_st[stat.ST_UID])[0]
                except KeyError, e:
                    my_user = 'uid %s not found' % my_st[stat.ST_UID]
                try:
                    my_group = grp.getgrgid(my_st[stat.ST_GID])[0]
                except KeyError, e:
                    my_group = 'gid %s not found' % my_st[stat.ST_GID]

                my_ftype = YUMVerifyPackageFile._ftype(my_st.st_mode)

                verify_dev = False
                if (pf.verify_dev and (pf.ftype.endswith("device") or
                                       my_ftype.endswith("device"))):
                    verify_dev = True
                if verify_dev:
                    if pf.ftype != my_ftype:
                        prob = _PkgVerifyProb('type','file type does not match',
                                              ftypes)
                        prob.database_value = pf.ftype
                        prob.disk_value = my_ftype
                        problems.append(prob)
                    elif (pf.dev & 0xFFFF) != (my_st.st_dev & 0xFFFF):
                        prob =_PkgVerifyProb('type','dev does not match',ftypes)
                        prob.database_value = hex(pf.dev & 0xffff)
                        prob.disk_value = hex(my_st.st_dev & 0xffff)
                        problems.append(prob)

                if pf.verify_readlink:
                    my_fnl = ''
                    if my_ftype == "symlink":
                        my_fnl = os.readlink(pf.filename)
                    if my_fnl != pf.readlink:
                        prob = _PkgVerifyProb('symlink',
                                              'symlink does not match', ftypes)
                        prob.database_value = pf.readlink
                        prob.disk_value     = my_fnl
                        problems.append(prob)

                check_content = True
                if 'ghost' in ftypes:
                    check_content = False
                if my_ftype == "symlink" and pf.ftype == "file":
                    # Don't let things hide behind symlinks
                    my_st_size = os.stat(pf.filename).st_size
                elif my_ftype != "file":
                    check_content = False
                check_perms = True
                if my_ftype == "symlink":
                    #  No, rpm doesn't check user/group on the dst. of the
                    # symlink ... so we don't.
                    check_perms = False

                if (check_content and pf.verify_mtime and
                    int(my_st.st_mtime) != int(pf.mtime)):
                    prob = _PkgVerifyProb('mtime', 'mtime does not match',
                                          ftypes)
                    prob.database_value = pf.mtime
                    prob.disk_value     = int(my_st.st_mtime)
                    problems.append(prob)

                if check_perms and pf.verify_user and my_user != pf.user:
                    prob = _PkgVerifyProb('user', 'user does not match', ftypes)
                    prob.database_value = pf.user
                    prob.disk_value = my_user
                    problems.append(prob)
                if check_perms and pf.verify_group and my_group != pf.group:
                    prob = _PkgVerifyProb('group', 'group does not match',
                                          ftypes)
                    prob.database_value = pf.group
                    prob.disk_value     = my_group
                    problems.append(prob)

                my_mode = my_st.st_mode
                if 'ghost' in ftypes: #  This is what rpm does, although it
                    my_mode &= 0777   # doesn't usually get here.
                if check_perms and pf.verify_mode and my_mode != pf.mode:
                    prob = _PkgVerifyProb('mode', 'mode does not match', ftypes)
                    prob.database_value = pf.mode
                    prob.disk_value     = my_st.st_mode
                    problems.append(prob)

                verify_digest = pf.verify_digest
                if fast and not problems and (my_st_size == pf.size):
                    verify_digest = False
                if not pf.digest:
                    verify_digest = False

                # Note that because we might get the _size_ from prelink,
                # we need to do the checksum, even if we just throw it away,
                # just so we get the size correct.
                if (check_content and
                    (verify_digest or (pf.verify_size and have_prelink and 
                                       my_st_size != pf.size))):
                    if pf.digest:
                        digest_type = pf.digest[0]
                        csum = pf.digest[0] + ':' + pf.digest[1]
                    else:
                        digest_type = csum_type
                        csum = ''
                    try:
                        my_csum = misc.checksum(digest_type, pf.filename)
                        my_csum = digest_type + ':' + my_csum
                    except Errors.MiscError:
                        # Don't have permission?
                        my_csum = None

                    if pf.verify_digest and my_csum is None:
                        prob = _PkgVerifyProb('genchecksum',
                                              'checksum not available', ftypes)
                        prob.database_value = csum
                        prob.disk_value     = None
                        problems.append(prob)
                        
                    if my_csum != csum and have_prelink:
                        #  This is how rpm -V works, try and if that fails try
                        # again with prelink.
                        p = Popen([prelink_cmd, "-y", pf.filename], 
                            bufsize=-1, stdin=PIPE,
                            stdout=PIPE, stderr=PIPE, close_fds=True)
                        (ig, fp, er) = (p.stdin, p.stdout, p.stderr)
                        # er.read(1024 * 1024) # Try and get most of the stderr
                        fp = _CountedReadFile(fp)
                        tcsum = misc.checksum(digest_type, fp)
                        if fp.read_size: # If prelink worked
                            my_csum = tcsum
                            my_csum = digest_type + ':' + my_csum
                            my_st_size = fp.read_size

                    if pf.verify_digest and my_csum != csum:
                        prob = _PkgVerifyProb('checksum',
                                              'checksum does not match', ftypes)
                        prob.database_value = csum
                        prob.disk_value     = my_csum
                        problems.append(prob)

                # Size might be got from prelink ... *sigh*.
                if check_content and pf.verify_size and my_st_size != pf.size:
                    prob = _PkgVerifyProb('size', 'size does not match', ftypes)
                    prob.database_value = pf.size
                    prob.disk_value     = my_st_size
                    problems.append(prob)

            else:
                try:
                    os.stat(pf.filename)
                    perms_ok = True # Shouldn't happen
                except OSError, e:
                    perms_ok = True
                    if e.errno == errno.EACCES:
                        perms_ok = False

                if perms_ok:
                    prob = _PkgVerifyProb('missing', 'file is missing', ftypes)
                else:
                    prob = _PkgVerifyProb('permissions-missing',
                                          'file is missing (Permission denied)',
                                          ftypes)
                problems.append(prob)

            if problems:
                results[pf.filename] = problems
                
        return results
        
                             
# This is a tweak on YumHeaderPackage() for rpm packages which are on disk.
class YumLocalPackage(YumHeaderPackage):
    """Class to handle an arbitrary package from a file path
       this inherits most things from YumInstalledPackage because
       installed packages and an arbitrary package on disk act very
       much alike. init takes a ts instance and a filename/path 
       to the package."""

    def __init__(self, ts=None, filename=None):
        if ts is None:
            #  This shouldn't be used "normally" within yum, but is very useful
            # for small scripts and debugging/etc.
            ts = rpmUtils.transaction.initReadOnlyTransaction()

        if filename is None:
            raise Errors.MiscError, \
                 'No Filename specified for YumLocalPackage instance creation'
                 
        self.pkgtype = 'local'
        self.localpath = filename
        self._checksum = None

        
        try:
            hdr = rpmUtils.miscutils.hdrFromPackage(ts, self.localpath)
        except RpmUtilsError, e:
            raise Errors.MiscError, \
                'Could not open local rpm file: %s: %s' % (self.localpath, e)
        
        fakerepo = FakeRepository(filename)
        fakerepo.cost = 0
        YumHeaderPackage.__init__(self, fakerepo, hdr)
        self.id = self.pkgid
        self._stat = os.stat(self.localpath)
        self.filetime = str(self._stat[-2])
        self.packagesize = str(self._stat[6])
        self.arch = self.isSrpm()
        self.pkgtup = (self.name, self.arch, self.epoch, self.ver, self.rel)
        self._hdrstart = None
        self._hdrend = None
        self.checksum_type = misc._default_checksums[0]

        # these can be set by callers that need these features (ex: createrepo)
        self._reldir = None 
        self._baseurl = "" 
        # self._packagenumber will be needed when we do sqlite creation here

        
    def isSrpm(self):
        if self.tagByName('sourcepackage') == 1 or not self.tagByName('sourcerpm'):
            return 'src'
        else:
            return self.tagByName('arch')
        
    def localPkg(self):
        return self.localpath
    
    def _do_checksum(self, checksum_type=None):
        if checksum_type is None:
            checksum_type = misc._default_checksums[0]
        if not self._checksum:
            self._checksum = misc.checksum(checksum_type, self.localpath)
            self._checksums = [(checksum_type, self._checksum, 1)]

        return self._checksum    

    checksum = property(fget=lambda self: self._do_checksum())   

    def returnChecksums(self):
        self._do_checksum()
        return self._checksums

    def verifyLocalPkg(self):
        """ don't bother "checking" the package matches itself. """
        return True

    def _get_header_byte_range(self):
        """takes an rpm file or fileobject and returns byteranges for location of the header"""
        if self._hdrstart and self._hdrend:
            return (self._hdrstart, self._hdrend)
      
           
        fo = open(self.localpath, 'r')
        #read in past lead and first 8 bytes of sig header
        fo.seek(104)
        # 104 bytes in
        binindex = fo.read(4)
        # 108 bytes in
        (sigindex, ) = struct.unpack('>I', binindex)
        bindata = fo.read(4)
        # 112 bytes in
        (sigdata, ) = struct.unpack('>I', bindata)
        # each index is 4 32bit segments - so each is 16 bytes
        sigindexsize = sigindex * 16
        sigsize = sigdata + sigindexsize
        # we have to round off to the next 8 byte boundary
        disttoboundary = (sigsize % 8)
        if disttoboundary != 0:
            disttoboundary = 8 - disttoboundary
        # 112 bytes - 96 == lead, 8 = magic and reserved, 8 == sig header data
        hdrstart = 112 + sigsize  + disttoboundary
        
        fo.seek(hdrstart) # go to the start of the header
        fo.seek(8,1) # read past the magic number and reserved bytes

        binindex = fo.read(4) 
        (hdrindex, ) = struct.unpack('>I', binindex)
        bindata = fo.read(4)
        (hdrdata, ) = struct.unpack('>I', bindata)
        
        # each index is 4 32bit segments - so each is 16 bytes
        hdrindexsize = hdrindex * 16 
        # add 16 to the hdrsize to account for the 16 bytes of misc data b/t the
        # end of the sig and the header.
        hdrsize = hdrdata + hdrindexsize + 16
        
        # header end is hdrstart + hdrsize 
        hdrend = hdrstart + hdrsize 
        fo.close()
        self._hdrstart = hdrstart
        self._hdrend = hdrend
       
        return (hdrstart, hdrend)
        
    hdrend = property(fget=lambda self: self._get_header_byte_range()[1])
    hdrstart = property(fget=lambda self: self._get_header_byte_range()[0])

    def _return_remote_location(self):

        # if we start seeing fullpaths in the location tag - this is the culprit
        if self._reldir and self.localpath.startswith(self._reldir):
            relpath = self.localpath.replace(self._reldir, '')
            if relpath[0] == '/': relpath = relpath[1:]
        else:
            relpath = self.localpath

        if self._baseurl:
            msg = """<location xml:base="%s" href="%s"/>\n""" % (
                                     misc.to_xml(self._baseurl, attrib=True),
                                     misc.to_xml(relpath, attrib=True))
        else:
            msg = """<location href="%s"/>\n""" % misc.to_xml(relpath, attrib=True)

        return msg


#  This is a tweak on YumLocalPackage() to download rpm packages to disk, and
# then use them directly.
class YumUrlPackage(YumLocalPackage):
    """Class to handle an arbitrary package from a URL
       this inherits most things from YumLocalPackage, but will download a
       remote package to make it local.
       init takes a YumBase, a ts instance and a url to the package."""

    def __init__(self, yb=None, ts=None, url=None, ua=None):
        if url.lower().startswith("file:"):
            result = url[len("file:"):]
        elif not misc.re_remote_url(url):
            result = url
        else:
            cb = None
            pd = {}
            for repo in yb.repos.listEnabled():
                cb = repo.callback # Hacky, but these are "always" the same
                if (repo.proxy == yb.conf.proxy and
                    repo.proxy_username == yb.conf.proxy_username and
                    repo.proxy_password == yb.conf.proxy_password):
                    # Even more hacky...
                    pd = repo.proxy_dict
                    break
            fname = os.path.basename(url)
            local = misc.getCacheDir()
            if local is None: # bugger...
                local = "%s/../" % repo.cachedir
            local = "%s/%s" % (local, fname)
            try:
                ug = URLGrabber(bandwidth = yb.conf.bandwidth,
                                retry = yb.conf.retries,
                                throttle = yb.conf.throttle,
                                progress_obj = cb,
                                proxies=pd)
                if ua is not None:
                    ug.opts.user_agent = ua
                result = ug.urlgrab(url, local, text=fname)
            except URLGrabError, e:
                raise Errors.MiscError("Cannot download %s: %s" % (url, e))
        YumLocalPackage.__init__(self, ts, result)
                                                                                                                                                                                                                                                                                                                                   usr/lib/python2.7/dist-packages/yum/packages.pyc                                                    0100644 0000000 0000000 00000234145 13077704344 020242  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   s–  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 m Z m Z d d l m Z d d l Z d d l m Z m Z m Z d d l Z d d l Z d d l Z d d l Td d l m Z d d l Z y e j j d É Wn e k
 r8Z e GHn Xd d	 l m Z m  Z  y) d d l! Z! e" e! d
 É rwe# Z! n  Wn e$ k
 rëe# Z! n Xd d l% Z% d d l& Z& d Ñ  Z' d Ñ  Z( e) d Ñ Z* d d d Ñ Z+ d f  d Ñ  É  YZ, d f  d Ñ  É  YZ- d e. f d Ñ  É  YZ/ e- d É Z0 d e0 _1 d e/ f d Ñ  É  YZ2 d e. f d Ñ  É  YZ3 d f  d Ñ  É  YZ4 d e/ e3 f d Ñ  É  YZ5 d  e5 f d! Ñ  É  YZ6 d" f  d# Ñ  É  YZ7 d$ f  d% Ñ  É  YZ8 d& d >Z9 d& d& >Z: d& d' >Z; d& d( >Z< d& d) >Z= d& d* >Z> d& d+ >Z? d& d, >Z@ d& d- >ZA d& d. >ZB d/ e. f d0 Ñ  É  YZC d1 eC f d2 Ñ  É  YZD d3 f  d4 Ñ  É  YZE d5 eE f d6 Ñ  É  YZF e- d7 É ZG d eG _1 d8 e6 f d9 Ñ  É  YZH d: e6 f d; Ñ  É  YZI d< eI f d= Ñ  É  YZJ d S(>   sA   
Classes and functions dealing with rpm package representations.
iˇˇˇˇN(   t   Popent   PIPE(   t   RpmUtilsError(   t   flagToStringt   stringToVersiont   compareVerOnly(   t   *(   t
   itemgettert   media(   t
   URLGrabbert   URLGrabErrort   getc         C   s_   |  j  |  j |  j } } } | j  | j | j } } } t j j | | | f | | | f É S(   s4   
    Compare two Package or PackageEVR objects.
    (   t   epocht   versiont   releaset   rpmUtilst	   miscutilst
   compareEVR(   t   po1t   po2t   e1t   v1t   r1t   e2t   v2t   r2(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   comparePoEVR=   s    c         C   sn   |  j  |  j |  j } } } | j  | j | j } } } | | k rJ t S| | k rZ t S| | k rj t St S(   sA   
    Compare two Package or PackageEVR objects for equality.
    (   R   R   R   t   Falset   True(   R   R   R   R   R   R   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   comparePoEVREQD   s       c         C   sI  i  } x<|  D]4} | j  \ } } } } } | sp | j É  } | j É  } | j É  } | j É  } | j É  } n  | }	 d | | f }
 d | | | | f } d | | f } d | | | f } d | | | | | f } d | | | | | f } xM |	 |
 | | | | | g D]0 } | | k r,g  | | <n  | | j | É qWq W| S(   sÌ  take a list of pkg objects and return a dict the contains all the possible
       naming conventions for them eg: for (name,i386,0,1,1)
       dict[name] = (name, i386, 0, 1, 1)
       dict[name.i386] = (name, i386, 0, 1, 1)
       dict[name-1-1.i386] = (name, i386, 0, 1, 1)       
       dict[name-1] = (name, i386, 0, 1, 1)       
       dict[name-1-1] = (name, i386, 0, 1, 1)
       dict[0:name-1-1.i386] = (name, i386, 0, 1, 1)
       dict[name-0:1-1.i386] = (name, i386, 0, 1, 1)
       s   %s.%ss   %s-%s-%s.%ss   %s-%ss   %s-%s-%ss   %s:%s-%s-%s.%ss   %s-%s:%s-%s.%s(   t   pkgtupt   lowert   append(   t   pkgst	   casematcht   pkgdictt   pkgt   nt   at   et   vt   rt   namet   nameArcht   nameVerRelArcht   nameVert
   nameVerRelt   envrat   nevrat   item(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   buildPkgRefDictO   s*    "i    s$   repo-epoch-name-version-release-archc         C   s†  t  |  t | É É } g  } g  } g  } x | D]Ë } | sI | j É  } n  | | k rp | j | | É | | =q. t j | É r	| j É  }	 t j | É }
 t	 j
 |
 É } d } x> |	 D]6 } | j | É r∂ | j | | É | | =d } q∂ q∂ W| s| j | É qq. | j | É q. Wt j | É } | d k rVt j | É } t j | É } n= | d k rÜd Ñ  } | | É } | | É } n t d | Ç | | | f S(   s,  matches up the user request versus a pkg list:
       for installs/updates available pkgs should be the 'others list' 
       for removes it should be the installed list of pkgs
       takes an optional casematch option to determine if case should be matched
       exactly. Defaults to not matching.i    i   s$   repo-epoch-name-version-release-archs   repo-pkgkeyc         S   sD   i  } x1 |  D]) } d | j  j | j f } | | | <q W| j É  S(   Ns   %s%s(   t   repot   idt   pkgKeyt   values(   R!   t   uR$   t   mark(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt	   pkguniqueû   s
    s   Bad value for unique: %s(   R2   t   boolR   t   extendt   misct   re_globt   keyst   fnmatcht	   translatet   ret   compilet   matchR    t   uniquet
   ValueError(   R!   t   usercommandsR"   RD   R#   t
   exactmatcht   matchedt	   unmatchedt   commandt   trylistt   restringt   regext   founditR1   R9   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   parsePackagesq   sB    
	t   FakeSackc           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s,    Fake PackageSack to use with FakeRepositoryc         C   s   d  S(   N(    (   t   self(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __init__¨   s    c         C   s   t  S(   sb    Is calling pkg.returnFileEntries(primary_only=True) faster than
            using searchFiles(). (   R   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   have_fastReturnFileEntriesØ   s    c         C   s   d S(   sN   delete a pkgobject, do nothing, but make localpackages work with --skip-brokenN(    (   RQ   t   obj(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt
   delPackage¥   s    (   t   __name__t
   __module__t   __doc__RR   RS   RU   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRP   ™   s   		t   FakeRepositoryc           B   s;   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s8   Fake repository class for use in rpmsack package objectsc         C   s∫   t  } d | k r- t j j | É } t } n  | j d É rO | d  } t } n  g  } | rk | j d É n  x6 | D]. } t | É d k rì d } n  | j | É qr Wd j | É |  _	 d S(   s?    Set the repoid, but because it can be random ... clean it up. t   /s   .rpmi¸ˇˇˇiÄ   t   ?t    N(
   R   t   ost   patht   basenameR   t   endswithR    t   ordt   joinR4   (   RQ   t   repoidt	   pathbasedt   bytest   byte(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _set_cleanup_repoidª   s    	
		c         C   s)   |  j  | É |  j |  _ t É  |  _ d  S(   N(   Rg   R4   R*   RP   t   sack(   RQ   Rc   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   ‘   s    c         C   s4   |  j  | j  k r d S|  j  | j  k  r, d Sd Sd  S(   Ni   iˇˇˇˇi    (   R4   (   RQ   t   other(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __cmp__Ÿ   s
    c         C   s   t  |  j É S(   N(   t   hashR4   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __hash__·   s    c         C   s   |  j  S(   N(   R4   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __str__‰   s    (   RV   RW   RX   Rg   RR   Rj   Rl   Rm   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRY   ∏   s   				t   PackageObjectc           B   s¯   e  Z d  Z d Ñ  Z d Ñ  Z e d d Ñ  É Z d Ñ  Z e d d Ñ  É Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d d Ñ  É Z d Ñ  Z RS(   sZ   Base Package Object - sets up the default storage dicts and the
       most common returnsc         C   s:   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ g  |  _ d  S(   N(   t   NoneR*   R   R   R   t   archt
   _checksums(   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR      s    					c         C   s`   |  j  d k r4 d |  j |  j |  j |  j f } n( d |  j  |  j |  j |  j |  j f } | S(   Nt   0s   %s-%s-%s.%ss   %s:%s-%s-%s.%s(   R   R*   R   R   Rp   (   RQ   t   out(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt	   _ui_envra˘   s    		t   fgetc         C   s
   |  j  É  S(   N(   Rt   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   <lambda>  s    c         C   s`   |  j  d k r4 d |  j |  j |  j |  j f } n( d |  j |  j  |  j |  j |  j f } | S(   NRr   s   %s-%s-%s.%ss   %s-%s:%s-%s.%s(   R   R*   R   R   Rp   (   RQ   Rs   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt	   _ui_nevra  s    		c         C   s
   |  j  É  S(   N(   Rw   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv     s    c         C   s   |  j  S(   N(   t   ui_envra(   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRm     s    c         C   sH   |  j  d k r. d |  j  |  j |  j f } n d |  j |  j f } | S(   sA   returns a printable version string - including epoch, if it's setRr   s   %s:%s-%ss   %s-%s(   R   R   R   (   RQ   t   ver(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   printVer  s    c         C   sA   | s
 d St  |  j | j É } | d k r= t |  | É } n  | S(   s<    Compare package to another one, only rpm-version ordering. i   i    (   t   cmpR*   R   (   RQ   Ri   t   ret(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   verCMP#  s    c         C   s´   |  j  | É } | d k r3 t |  j | j É } n  | d k rß t |  d É rß t | d É rß t |  j | j É } | rã |  j d k rã d S| rß | j d k rß d Sn  | S(   s4    Compare packages, this is just for UI/consistency. i    Rc   t	   installedi   iˇˇˇˇ(   R}   R{   Rp   t   hasattrRc   (   RQ   Ri   R|   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRj   ,  s    *c         C   s[   | s
 t  S|  j | j k r  t  St |  d É rW t | d É rW |  j | j k rW t  Sn  t S(   se    Compare packages for yes/no equality, includes everything in the
            UI package comparison. Rc   (   R   R   R   Rc   R   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __eq__9  s    c         C   s   |  | k s t  St S(   N(   R   R   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __ne__D  s    c         C   s   t  |  | É S(   N(   t   getattr(   RQ   t   key(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __getitem__I  s    c         C   s<   | s
 d St |  j | j É } | d k r/ t St |  | É S(   s<    Compare package to another one, only rpm-version equality. i    N(   Ro   R{   R*   R   R   (   RQ   Ri   R|   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   verEQL  s    c         C   s   | s
 d S|  j | É S(   s>    Compare package to another one, only rpm-version inequality. N(   Ro   RÖ   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   verNET  s    c         C   s   |  j  | É d k  S(   s;    Uses verCMP, tests if the other _rpm-version_ is <  ours. i    (   R}   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   verLTY  s    c         C   s   |  j  | É d k S(   s;    Uses verCMP, tests if the other _rpm-version_ is <= ours. i    (   R}   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   verLE\  s    c         C   s   |  j  | É d k S(   s;    Uses verCMP, tests if the other _rpm-version_ is >  ours. i    (   R}   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   verGT_  s    c         C   s   |  j  | É d k S(   s;    Uses verCMP, tests if the other _rpm-version_ is >= ours. i    (   R}   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   verGEb  s    c         C   s)   d |  j  j t |  É t t |  É É f S(   Ns   <%s : %s (%s)>(   t	   __class__RV   t   strt   hexR4   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __repr__f  s    c         C   s&   t  j d t j d d Ét |  | É S(   Ns8   returnSimple() will go away in a future version of Yum.
t
   stackleveli   (   t   warningst   warnt   Errorst   YumFutureDeprecationWarningRÇ   (   RQ   t   varname(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   returnSimplei  s    	c         C   s   |  j  S(   N(   Rq   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   returnChecksumsn  s    c         C   s
   |  j  É  S(   N(   Rñ   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   q  s    c         C   s1   x* |  j  D] \ } } } | r
 | | f Sq
 Wd  S(   N(   t	   checksums(   RQ   t   csumtypet   csumt   csumid(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   returnIdSums  s    (   RV   RW   RX   RR   Rt   t   propertyRx   Rw   t   ui_nevraRm   Rz   R}   Rj   RÄ   RÅ   RÑ   RÖ   RÜ   Rá   Rà   Râ   Rä   Ré   Rï   Rñ   Ró   Rõ   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRn   Ï   s0   																						t   -t   YumNotFoundPackagec           B   s5   e  Z d  Ñ  Z d Ñ  Z e d d Ñ  É Z d Ñ  Z RS(   c         C   su   | d |  _  | d |  _ | d |  _ | d |  _ | d |  _ | |  _ d |  _ g  |  _ t |  _	 t j
 |  _ d  S(   Ni    i   i   i   i   (   R*   Rp   R   R   R   R   t   sizeRq   t   _not_found_repoR3   R4   Rc   (   RQ   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   }  s    				c         C   s   |  j  S(   s    This just returns '-' (   Rc   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _ui_from_repoå  s    Ru   c         C   s
   |  j  É  S(   N(   R¢   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   è  s    c         C   s   t  S(   s^   check the package checksum vs the localPkg
           return True if pkg is good, False if not(   R   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   verifyLocalPkgë  s    (   RV   RW   RR   R¢   Rú   t   ui_from_repoR£   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRü   {  s   		t   RpmBasec           B   s  e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d e d Ñ Z e d Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z e d d Ñ  É Z e d d Ñ  É Z e d d Ñ  É Z e d d Ñ  É Z e d d Ñ  É Z e d d Ñ  É Z e d d Ñ  É Z e d d Ñ  É Z e d d Ñ  É Z e d d Ñ  É Z e d d Ñ  É Z e d d Ñ  É Z  e d d  Ñ  É Z! e d d! Ñ  É Z" e d d" Ñ  É Z# e d d# Ñ  É Z$ e d d$ Ñ  É Z% d% Ñ  Z& e d d& Ñ  É Z' d' Ñ  Z( d( d) Ñ Z) RS(*   s2   return functions and storage for rpm-specific datac         C   så   i  |  _  g  |  j  d <g  |  j  d <g  |  j  d <g  |  j  d <i  |  _ g  |  j d <g  |  j d <g  |  j d <g  |  _ g  |  _ d  |  _ d  S(   Nt	   obsoletest	   conflictst   requirest   providest   filet   dirt   ghost(   t   prcot   filest
   _changelogt   licensesRo   t   _hash(   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   ù  s    				c         C   s:   | s
 t  S|  j | j k r  t  S|  j | j k r6 t  St S(   N(   R   R   Rc   R   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRÄ   ≠  s    c         C   s   |  | k s t  St S(   N(   R   R   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRÅ   µ  s    c         C   s   t  |  j |  j |  j É S(   N(   t
   PackageEVRR   R   R   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt	   returnEVR∫  s    c         C   sY   |  j  d  k rR d |  j j |  j |  j |  j |  j |  j f } t	 | É |  _  n  |  j  S(   Ns   %s - %s:%s-%s-%s.%s(
   R±   Ro   R3   R4   R   R*   R   R   Rp   Rk   (   RQ   t   mystr(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRl   Ω  s
    c         C   s`   |  j  j | g  É } | r\ g  } x4 | D], } | d s> q( n  | j t j | É É q( W| S| S(   s9   return list of provides, requires, conflicts or obsoletesi    (   R≠   R   R    R<   t   prco_tuple_to_string(   RQ   t   prcotypet	   printablet   prcost   resultsR≠   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt
   returnPrcoƒ  s    
c         C   sG  | |  j  k r d St |  j  | É d k rF | |  j  | k rƒ d Sn~ t |  d É s} i d	 d 6d	 d 6d	 d 6d	 d 6|  _ n  |  j | d	 k r≠ t |  j  | É |  j | <n  | |  j | k rƒ d St rC| \ } } \ } } } | d	 k	 r˛ |  j | | É SxB |  j | É D]. \ } }	 \ }
 } } t	 j
 | | É rd SqWn  d S(
   sB   returns 1 or 0 if the pkg contains the requested tuple/tuple rangei    i   i   t   _prco_lookupR¶   Rß   R®   R©   N(   R≠   t   lenR   Ro   Rª   t   setR   t   inPrcoRangeR∫   t   i18nt   str_eq(   RQ   R∂   t	   prcotuplet   reqnt   reqft   reqet   reqvt   reqrR%   t   fR'   R(   R)   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt	   checkPrco”  s(    (c         C   s   t  |  j | | É É S(   sò   returns true if the package has a the prco that satisfies 
           the reqtuple range, assume false.
           Takes: prcotype, requested prco tuple(   R:   t   matchingPrcos(   RQ   R∂   t   reqtuple(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRæ   ı  s    c         C   s-  | \ } } \ } } } g  } x|  j  | É D]˜ \ }	 }
 \ } } } t j | |	 É s^ q. n  |
 d k rs d }
 n  |
 d k r÷ | d k r÷ | d  k r£ |  j } n  | d  k rª |  j } n  | d  k r÷ |  j } q÷ n  t j j	 | |	 |
 | | | f f É } | r. | j
 |	 |
 | | | f f É q. q. W| S(   Nt   =t   EQR©   (   R∫   Rø   R¿   Ro   R   Ry   t   relR   R   t   rangeCompareR    (   RQ   R∂   R    R¬   R√   Rƒ   R≈   R∆   t   resultR%   R«   R'   R(   R)   RH   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR…   ˚  s&    (		&c         C   sÉ   |  j  d | É r t S| d j d É r t j | d É rE t } n t } x1 d D]& } | d |  j | | É k rR t SqR Wn  t S(   sú   check to see if the package object provides for the requirement
           passed, including searching filelists if the requirement is a file
           depR©   i    RZ   R™   R´   R¨   (   s   files   dirs   ghost(   R»   R   t
   startswithR<   t   re_primary_filenameR   t   returnFileEntries(   RQ   R    t   pri_onlyt   ftype(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   provides_for  s    	c         C   s   |  j  S(   s   return changelog entries(   RØ   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   returnChangelog,  s    R™   c         C   s{   |  j  rw | |  j  k rw | ri | d k r6 t j } n	 t j } g  |  j  | D] } | | É rM | ^ qM S|  j  | Sn  g  S(   s}   return list of files based on type, you can pass primary_only=True
           to limit to those files in the primary repodataR´   (   RÆ   R<   t   re_primary_dirnameR—   (   RQ   R‘   t   primary_onlyRC   t   fn(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR“   0  s    		*c         C   sê   | rÉ g  } xp |  j  j É  D]_ } | d k r: t j } n	 t j } x( |  j  | D] } | | É rQ PqQ qQ Wq | j | É q W| S|  j  j É  S(   sá   return list of types of files in the package, you can pass
           primary_only=True to limit to those files in the primary repodataR´   (   RÆ   R>   R<   R◊   R—   R    (   RQ   Rÿ   R|   R‘   RC   RŸ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   returnFileTypes>  s    	c         C   sf   t  |  d | É sU g  |  j | É D] \ } } } | ^ q# } t |  d | | É n  t |  d | É S(   Nt   _cache_prco_names_(   R   R∫   t   setattrRÇ   (   RQ   R∂   R%   R«   R(   t   data(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   returnPrcoNamesT  s    +c         C   s    t  j d t j d d É|  j S(   Ns<   getProvidesNames() will go away in a future version of Yum.
Rè   i   (   Rê   Rë   Rí   t   YumDeprecationWarningt   provides_names(   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   getProvidesNamesZ  s    	RÆ   c         C   s@   t  j d t j d d É|  j r< | |  j k r< |  j | Sg  S(   Ns_   simpleFiles() will go away in a future version of Yum.Use returnFileEntries(primary_only=True)
Rè   i   (   Rê   Rë   Rí   Rﬂ   RÆ   (   RQ   R‘   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   simpleFiles_  s
    	Ru   c         C   s   |  j  d d É S(   NR‘   R™   (   R“   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   g  s    c         C   s   |  j  d d É S(   NR‘   R´   (   R“   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   h  s    c         C   s   |  j  d d É S(   NR‘   R¨   (   R“   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   i  s    c         C   s   |  j  d É S(   NR®   (   R∫   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   j  s    c         C   s   |  j  d É S(   NR©   (   R∫   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   k  s    c         C   s   |  j  d É S(   NR¶   (   R∫   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   l  s    c         C   s   |  j  d É S(   NRß   (   R∫   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   m  s    c         C   s   |  j  d É S(   NR©   (   Rﬁ   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   n  s    c         C   s   |  j  d É S(   NR®   (   Rﬁ   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   o  s    c         C   s   |  j  d É S(   NRß   (   Rﬁ   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   p  s    c         C   s   |  j  d É S(   NR¶   (   Rﬁ   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   q  s    c         C   s   |  j  d t É S(   NR©   (   R∫   R   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   r  s    c         C   s   |  j  d t É S(   NR®   (   R∫   R   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   s  s    c         C   s   |  j  d t É S(   NRß   (   R∫   R   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   t  s    c         C   s   |  j  d t É S(   NR¶   (   R∫   R   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   u  s    c         C   s
   |  j  É  S(   N(   R÷   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   v  s    c         C   s
   |  j  É  S(   N(   R≥   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   w  s    c         C   sÑ   t  |  d É r |  j St  |  d É rq |  j rq t j j |  j É \ } } } } } | |  j k rq | |  _ | Sn  |  j |  _ |  j S(   s\    Return the "base name" of the package, atm. we can only look at
            the sourcerpm. t   _base_package_name_rett	   sourcerpm(   R   R„   R‰   R   R   t   splitFilenameR*   (   RQ   R%   R(   R)   R'   R&   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _getBaseNamey  s    $	c         C   s
   |  j  É  S(   N(   RÊ   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   â  s    c         C   s   |  j  j j É  S(   sb    Is calling pkg.returnFileEntries(primary_only=True) faster than
            using searchFiles(). (   R3   Rh   RS   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRS   ã  s    i    c         C   s}   |  j  d |  j |  j |  j f f } g  } xL | D]D } | j d | É r1 | j | É | ru t | É | k ru Pqu q1 q1 W| S(   s∞    Returns list of obsoleters that obsolete this package. Note that we
            don't do obsoleting loops. If limit is != 0, then we stop after
            finding that many. RÃ   R¶   (   R*   R   R   R   Ræ   R    Rº   (   RQ   t
   obsoleterst   limitt   provtupR|   t   obspo(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   obsoletedByê  s    $(*   RV   RW   RX   RR   RÄ   RÅ   R≥   Rl   R   R∫   R»   Ræ   R…   R’   R÷   R“   R⁄   Rﬁ   R·   R‚   Rú   t   filelistt   dirlistt	   ghostlistR®   R©   R¶   Rß   R‡   t   requires_namest   conflicts_namest   obsoletes_namest   provides_printt   requires_printt   conflicts_printt   obsoletes_printt	   changelogt   EVRRÊ   t   base_package_nameRS   RÎ   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR•   ö  sL   						"								R≤   c           B   sV   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(	   sö   
    A comparable epoch, version, and release representation. Note that you
    almost certainly want to use pkg.verEQ() or pkg.verGT() etc. instead.
    c         C   s1   | |  _  | |  _ | |  _ | |  _ | |  _ d  S(   N(   R   Ry   R   RÕ   R   (   RQ   R'   R(   R)   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   ß  s
    				c         C   s7   t  j j |  j |  j |  j f | j | j | j f É S(   N(   R   R   R   R   Ry   RÕ   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   compareÆ  s    c         C   s   |  j  | É d k  r t St S(   Ni    (   R˘   R   R   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __lt__±  s    c         C   s   |  j  | É d k r t St S(   Ni    (   R˘   R   R   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __gt__∑  s    c         C   s   |  j  | É d k r t St S(   Ni    (   R˘   R   R   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __le__º  s    c         C   s   |  j  | É d k r t St S(   Ni    (   R˘   R   R   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __ge__¡  s    c         C   s   t  |  | É S(   N(   R   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRÄ   ∆  s    c         C   s   |  | k s t  St S(   N(   R   R   (   RQ   Ri   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRÅ   …  s    (   RV   RW   RX   RR   R˘   R˙   R˚   R¸   R˝   RÄ   RÅ   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR≤   †  s   							t   YumAvailablePackagec           B   sØ  e  Z d  Z d' d Ñ Z d Ñ  Z e d d Ñ  É Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z e d d Ñ  É Z e e É Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ  É Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& e' d Ñ Z( d  Ñ  Z) d! Ñ  Z* d" Ñ  Z+ d# Ñ  Z, d$ Ñ  Z- d% d& Ñ Z. RS((   s}   derived class for the  packageobject and RpmBase packageobject yum
       uses this for dealing with packages in a repositoryc         C   s©   t  j |  É t j |  É | j |  _ | |  _ d  |  _ t |  _	 d  |  _
 | d  k r~ |  j | É |  j |  _ |  j |  _ n  |  j |  j |  j |  j |  j f |  _ d  S(   N(   Rn   RR   R•   R4   Rc   R3   Ro   t   stateR   t   _loadedfilest   _verify_local_pkg_cachet   importFromDictR   Ry   R   RÕ   R*   Rp   R   R   (   RQ   R3   R#   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   ’  s    				c         C   sâ   |  j  d k rÇ d |  j k rÇ d } |  j j d k	 rp d |  j k rp |  j j |  j j k rp d |  j j } n  d |  j j | S|  j  S(   s   This reports the repo the package is from, we integrate YUMDB info.
            for RPM packages so a package from "fedora" that is installed has a
            ui_from_repo of "@fedora". Note that, esp. with the --releasever
            option, "fedora" or "rawhide" isn't authoritive.
            So we also check against the current releasever and if it is
            different we also print the YUMDB releasever. This means that
            installing from F12 fedora, while running F12, would report as
            "@fedora/13". R~   t	   from_repoR\   t
   releaseverRZ   t   @N(   Rc   t
   yumdb_infot   rpmdbR  Ro   R  (   RQ   t   end(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR¢   Â  s    	Ru   c         C   s
   |  j  É  S(   N(   R¢   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   ˆ  s    c         C   s   |  j  j j |  É d S(   s   remove self from package sackN(   R3   Rh   RU   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   exclude¯  s    c         C   sH   |  j  d k r. d |  j  |  j |  j f } n d |  j |  j f } | S(   sA   returns a printable version string - including epoch, if it's setRr   s   %s:%s-%ss   %s-%s(   R   R   R   (   RQ   Ry   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRz   ¸  s    c         C   s#   |  j  É  } d |  j |  j | f S(   Ns   %s.%s %s(   Rz   R*   Rp   (   RQ   Ry   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   compactPrint  s    c         C   s   |  j  S(   N(   t   packagesize(   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _size	  s    c         C   s   |  j  S(   N(   t   relativepath(   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _remote_path  s    c         C   s\   |  j  } | r? | d d k r, | d } n  t j | |  j É St j |  j j d |  j É S(   s∞   returns a URL that can be used for downloading the package.
        Note that if you're going to download the package in your tool,
        you should use self.repo.getPackage.iˇˇˇˇRZ   i    (   t   basepatht   urlparset   urljoint   remote_pathR3   t   urls(   RQ   t   base(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _remote_url  s    	c         C   s
   |  j  É  S(   N(   R  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv     s    c         C   sù   t  |  d É r |  j Sd Ñ  } t |  j É sA |  j |  _ |  j S|  j d d } | | É } | j d É } | d k rç | d | d !} n  | |  _ |  j S(   sD   Returns the name of the last person to do a commit to the changelog.t   _committer_retc         S   sL   g  } x6 |  D]. } t  | É d k r. d } n  | j | É q Wd j | É S(   s6    does .encode("ascii", "replace") but it never fails. iÄ   R[   R\   (   Ra   R    Rb   (   t   xR|   t   val(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt	   _nf2ascii%  s    	i    i   s   > iˇˇˇˇ(   R   R  Rº   Rˆ   t   packagert   find(   RQ   R  R  t   ix(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt
   _committer  s    			c         C   sS   t  |  d É r |  j St |  j É s8 |  j |  _ |  j S|  j d d |  _ |  j S(   s5   Returns the time of the last commit to the changelog.t   _committime_reti    (   R   R  Rº   Rˆ   t	   buildtime(   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _committime>  s    c         C   s   |  j  d d S(   s   Returns the 'default' checksumi    i   (   Ró   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt	   _checksumN  s    c         C   sd   |  j  d  k r d  St j |  j  É \ } } } } } | d k r` t | É d k rV d St | É Sd  S(   NR   i    (   R  Ro   R  t   urlsplitRº   t   int(   RQ   t   schemet   netlocR^   t   queryt   fragid(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt
   getDiscNumS  s    !
c         C   s_   |  j  É  } t j j É  } y t j j | | É } Wn$ t j k
 rZ t j d |  Ç n X| S(   Ns"   Package Header %s: RPM Cannot open(	   t   localPkgR   t   transactiont   initReadOnlyTransactionR   t   hdrFromPackageR   Rí   t	   RepoError(   RQ   t   rpmfilet   tst   hdr(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   returnHeaderFromPackage]  s    c         C   s   t  j j |  j É  É rk y# t j |  j É  É } | d } Wq{ t j t f k
 rg t j	 d |  Ç q{ Xn t j	 d |  Ç | S(   sT   returns an rpm header object from the package object's local
           header cachei    s   Package Header %s: Cannot opens    Package Header %s: Not Available(
   R]   R^   t   existst   localHdrt   rpmt   readHeaderListFromFilet   errort
   IndexErrorRí   R-  (   RQ   t   hlistR0  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   returnLocalHeaderf  s    c         C   sE   t  |  d É s> t j j |  j É } |  j j d | |  _ n  |  j S(   sB   return path to local package (whether it is present there, or not)t	   localpathRZ   (   R   R]   R^   R_   R  R3   t   pkgdirR:  (   RQ   t   rpmfn(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR)  v  s    c         C   sS   t  |  d É sL t j j |  j É } | d  d } |  j j d | |  _ n  |  j S(   sW   return path to local cached Header file downloaded from package 
           byte rangest   hdrpathi¸ˇˇˇs   .hdrRZ   (   R   R]   R^   R_   R  R3   t   hdrdirR=  (   RQ   t   pkgnamet   hdrname(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR3  }  s
    c         C   s  y t  j |  j É  É } Wn t k
 r/ } t SXt |  d É r† |  j r† |  j } | j | j k r† | j | j k r† | j	 | j	 k r† | j
 | j
 k r† t Sn  |  j É  \ } } y% t j | |  j É  d |  j É} Wn t j k
 rÓ t SX| | k rˇ t S| |  _ t S(   s^   check the package checksum vs the localPkg
           return True if pkg is good, False if notR  t   datasize(   R]   t   statR)  t   OSErrorR   R   R  t   st_inot   st_devt   st_mtimet   st_sizeR   Rõ   R<   t   checksumR  Rí   t	   MiscError(   RQ   t   nstR'   t   ostt	   csum_typeRô   t   filesum(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR£   à  s,    			c         C   sw   t  d k r d St |  d É r, t |  d É S|  j É  s< d Sy t  j |  j É  d É } Wn d SXt |  d | É | S(   sπ    Get the user.xdg.origin.url value from the local pkg. ... if it's
            present. We cache this so we can access it after the file has been
            deleted (keepcache=False). t   __cached_localXattrUrls   user.xdg.origin.urlN(   t   xattrRo   R   RÇ   R£   R   R)  R‹   (   RQ   R|   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _localXattrUrl´  s    c         C   s
   |  j  É  S(   N(   RP  (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   ¡  s    c         C   s&   t  j d t j d d Ét j | É S(   s1   convert the prco tuples into a nicer human strings9   prcoPrintable() will go away in a future version of Yum.
Rè   i   (   Rê   Rë   Rí   Rﬂ   R<   Rµ   (   RQ   t	   prcoTuple(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   prcoPrintable√  s    	c         C   s   |  j  S(   s.   return a list of requires in normal rpm format(   RÛ   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   requiresList…  s    c         C   s   |  j  |  j d f g S(   Ni   (   t   checksum_typet   pkgId(   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRñ   Õ  s    c         C   sÍ  t  | d É rW | j \ } } } } } | |  _ | |  _ | |  _ | |  _ | |  _ n  t  | d É râ | j d |  _ | j d |  _	 n  t  | d É rÀ | j
 d |  _ | j
 d |  _ | j
 d |  _ n  t  | d	 É r| j j d
 É } | d k rd- } n  | |  _ | j d |  _ n  t  | d É rO| j d |  _ | j d |  _ n  t  | d É r–x= d d d d d d d d g D] } t |  | | j | É q}W|  j j d d É |  _ |  j j | j d É n  t  | d É r6xT | j D]F }	 | j |	 }
 |
 |  j k rg  |  j |
 <n  |  j |
 j |	 É qÈWn  t  | d É r‡xò | j D]ä } xÅ | j | D]r } | d } | j d É } | j d É } | j d  É } | j d! É } |  j | j | | | | | f f É qcWqOWn  t  | d" É rLxZ | j D]L } | j d# É } | j d$ É } | j d% É } |  j j | | | f É q˘Wn  t  | d& É rÊ| j  d' } | j  d$ } | j  d( } | d- k s†| j! É  d) k r©d* } n! | j! É  d+ k rƒd, } n d* } |  j" j | | | f É n  d- S(.   s^   handles an mdCache package dictionary item to populate out 
           the package informationR0   t   timet   buildR™   R†   t   packaget   archiveR~   t   locationR  R\   t   hreft   hdranget   startR  t   infot   summaryt   descriptionR  t   groupt	   buildhostR‰   t   urlt   vendors   
t   licenseRÆ   R≠   R*   t   flagsR   Ry   RÕ   Rˆ   t   datet   valuet   authorRH  t   typet   pkgidt   NOi    t   YESi   N(#   R   R0   R*   R   R   Rp   R   RV  R  t   filetimeR†   R  t   archivesizet   installedsizeRZ  R   Ro   R  R  R\  t   hdrstartt   hdrendR‹   R^  R_  t   replaceR∞   R    RÆ   R≠   Rˆ   RØ   RH  t   upperRq   (   RQ   R#   R%   R'   R(   R)   R&   Rc  R1   RŸ   R‘   t   rtypet   rdictR*   R«   t   cdictRg  t   textRi  t   ctypeRô   Rö   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR  –  sx    						
1 		c         C   s\   t  j j |  j É } t  j j |  j É } d t j | d t Ét j | d t Éf } | S(   Ns$   <location xml:base="%s" href="%s"/>
t   attrib(   R]   R^   t   dirnamet
   remote_urlR_   R<   t   to_xmlR   (   RQ   R  R[  t   msg(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _return_remote_location#  s
    +c         C   s  d } } |  j  r1 t j t j |  j  É É } n  |  j rX t j t j |  j É É } n  |  j d \ } } } d |  j |  j |  j |  j	 |  j
 | | t j t j |  j É É t j t j |  j É É | | |  j |  j |  j |  j |  j f } | |  j É  7} | S(   NR\   i    s3  
  <name>%s</name>
  <arch>%s</arch>
  <version epoch="%s" ver="%s" rel="%s"/>
  <checksum type="%s" pkgid="YES">%s</checksum>
  <summary>%s</summary>
  <description>%s</description>
  <packager>%s</packager>
  <url>%s</url>
  <time file="%s" build="%s"/>
  <size package="%s" installed="%s" archive="%s"/>
(   R  R<   t
   to_unicodeR}  Rc  Ró   R*   Rp   R   Ry   RÕ   R_  R`  Rn  R  R  R†   Ro  R  (   RQ   R  Rc  RL  Rô   Rö   R~  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _dump_base_items+  s    
			c         C   só  d } |  j  r, | d t j |  j  É 7} n
 | d 7} |  j r\ | d t j |  j É 7} n
 | d 7} |  j rå | d t j |  j É 7} n
 | d 7} |  j rº | d t j |  j É 7} n
 | d	 7} |  j rÏ | d
 t j |  j É 7} n
 | d 7} | d |  j |  j f 7} | |  j	 d É 7} | |  j
 É  7} | |  j	 d É 7} | |  j	 d É 7} | |  j t É 7} | d d k râ| d 7} n  | d 7} | S(   Ns     <format>
s"       <rpm:license>%s</rpm:license>
s       <rpm:license/>
s        <rpm:vendor>%s</rpm:vendor>
s       <rpm:vendor/>
s       <rpm:group>%s</rpm:group>
s       <rpm:group/>
s&       <rpm:buildhost>%s</rpm:buildhost>
s       <rpm:buildhost/>
s&       <rpm:sourcerpm>%s</rpm:sourcerpm>
s       <rpm:sourcerpm/>
s+       <rpm:header-range start="%s" end="%s"/>R©   Rß   R¶   iˇˇˇˇs   
s     </format>(   Re  R<   R}  Rd  Ra  Rb  R‰   Rq  Rr  t	   _dump_pcot   _dump_requirest   _dump_filesR   (   RQ   R~  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _dump_format_itemsH  s6    	
	
	
	
	

c   
      C   s+  d } t  |  | É } | r( d | } n  xÂ | D]› \ } } \ } } } d t j | d t É}	 | r¯ |	 d t j | d t É7}	 | r© |	 d t j | d t É7}	 n  | rœ |	 d t j | d t É7}	 n  | r¯ |	 d t j | d t É7}	 q¯ n  |	 d	 7}	 | |	 7} q/ W| r'| d
 | 7} n  | S(   NR\   s   
    <rpm:%s>
s         <rpm:entry name="%s"Rz  s    flags="%s"s    epoch="%s"s	    ver="%s"s	    rel="%s"s   />
s       </rpm:%s>(   RÇ   R<   R}  R   (
   RQ   t   pcotypeR~  t   mylistR*   Rf  R'   R(   R)   t	   pcostring(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRÇ  p  s&       #
 c         C   s˜   d } | s< |  j  d É } |  j  d É } |  j  d É } n? |  j  d d t É} |  j  d d t É} |  j  d d t É} x% | D] } | d t j | É 7} qÇ Wx% | D] } | d t j | É 7} q™ Wx% | D] } | d t j | É 7} q“ W| S(	   Ns   
R™   R´   R¨   Rÿ   s       <file>%s</file>
s       <file type="dir">%s</file>
s!       <file type="ghost">%s</file>
(   R“   R   R<   R}  (   RQ   t   primaryR~  RÆ   t   dirst   ghostsRŸ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRÑ  Ü  s    c         C   s   t  É  Ç d  S(   N(   t   NotImplementedError(   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _requires_with_preõ  s    c         C   s∂  |  j  É  } d } | r! d } n  t |  d É r|  j rt d Ñ  | É } | rt | d t d t d É É} | j É  } t | É d k rØ | d j	 d É rØ | j É  } n  g  } x@ | D]8 } | d j	 d	 É rÁ | | k rÁ qº n  | j
 | É qº W| } qn  xò| D]ê\ } }	 \ }
 } } } | j	 d
 É r;qn  | |  j k sÜ| j	 d É rø| |  j k sÜ| |  j k sÜ| |  j k rø|	 síqqø|  j d | |	 |
 | | f f É røqqøn  d t j | d t É} |	 rp| d t j |	 d t É7} |
 r!| d t j |
 d t É7} n  | rG| d t j | d t É7} n  | rp| d t j | d t É7} qpn  | rá| d | 7} n  | d 7} | | 7} qW| r≤| d 7} n  | S(   s   returns deps in XML formatR\   s   
    <rpm:requires>
t   _collapse_libc_requiresc         S   s   |  d j  d É S(   Ni    s	   libc.so.6(   R–   (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   ¶  s    R{   RÉ   i    s   libc.so.6()s	   libc.so.6s   rpmlib(RZ   R©   s         <rpm:entry name="%s"Rz  s    flags="%s"s    epoch="%s"s	    ver="%s"s	    rel="%s"s	    pre="%s"s   />
s       </rpm:requires>(   Rç  R   Ré  t   filtert   sortedR   R   t   popRº   R–   R    R‡   RÏ   RÌ   RÓ   R»   R<   R}  R   (   RQ   Rá  R~  t   libc_requirest   restt   bestt   newlistt   iR*   Rf  R'   R(   R)   t   pret
   prcostring(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRÉ  û  sX     	%"$	  #
 c   	      C   sœ   |  j  s d Sd } | s% |  j  } n |  j  |  } d } d } xä t | É D]| \ } } } | | k ro d } n
 | d 7} | } | | 7} | d t j | d t Ét j t | É É t j | É f 7} qK W| S(   NR\   s   
i    i   s0   <changelog author="%s" date="%s">%s</changelog>
Rz  (   Rˆ   t   reversedR<   R}  R   Rå   (	   RQ   t
   clog_limitR~  t   clogst   last_tst   hack_tsR/  Ri  t   content(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _dump_changelog“  s$    		

$c         C   sO   d } | t  j |  j É  É 7} | t  j |  j É  É 7} | d 7} t  j | É S(   Ns   
<package type="rpm">s   
</package>(   R<   RÄ  RÅ  RÖ  t   to_utf8(   RQ   R~  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   xml_dump_primary_metadataÈ  s
    
c         C   s^   d |  j  |  j |  j |  j |  j |  j f } | t j |  j É  É 7} | d 7} t j	 | É S(   NsV   
<package pkgid="%s" name="%s" arch="%s">
    <version epoch="%s" ver="%s" rel="%s"/>
s   </package>
(
   RH  R*   Rp   R   Ry   RÕ   R<   RÄ  RÑ  R†  (   RQ   R~  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   xml_dump_filelists_metadata  s
    
i    c         C   s[   d |  j  |  j |  j |  j |  j |  j f } | d t j |  j | É É 7} t j	 | É S(   NsV   
<package pkgid="%s" name="%s" arch="%s">
    <version epoch="%s" ver="%s" rel="%s"/>
s   %s
</package>
(
   RH  R*   Rp   R   Ry   RÕ   R<   RÄ  Rü  R†  (   RQ   Rö  R~  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   xml_dump_other_metadata¯  s     N(/   RV   RW   RX   Ro   RR   R¢   Rú   R§   R	  Rz   R
  R  R  R  R†   R  R|  R  t	   committerR   t
   committimeR!  RH  R(  R1  R9  R)  R3  R£   RP  t   xattr_origin_urlRR  RS  Rñ   R  R  RÅ  RÖ  RÇ  R   RÑ  Rç  RÉ  Rü  R°  R¢  R£  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR˛   —  sT   												
						#					S			(			4			t   YumHeaderPackagec           B   s◊   e  Z d  Z d Ñ  Z d Ñ  Z e d Ñ  É Z d Ñ  Z e d Ñ  É Z d Ñ  Z	 e
 d Ñ Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d e
 d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s'   Package object built from an rpm headerc         C   sa  t  j |  | É | |  _ t j |  j d É |  _ |  j d } | sN d } n  t j | É |  _ t j |  j É  É |  _ t j |  j d É |  _	 t j |  j d É |  _
 |  j	 |  _ |  j
 |  _ |  j |  j |  j |  j	 |  j
 f |  _ d	 |  _ d	 |  _ |  j t j |  _ |  j s;d |  j d |  j d f |  _ n  |  j d |  _ i  |  _ t |  _ d	 S(
   sG   hand in an rpm header, we'll assume it's installed and query from thereR*   Rp   t   noarchR   R   s   %s.%sR  R†   N(   R˛   RR   R0  R<   t
   share_dataR*   Rp   t   doepochR   R   R   Ry   RÕ   R   Ro   t   _loaded_summaryt   _loaded_descriptionR4  t   RPMTAG_SHA1HEADERRk  R  t   _YumHeaderPackage__mode_cacheR   t    _YumHeaderPackage__prcoPopulated(   RQ   R3   R0  t   this_a(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR     s*    		'			$	c         C   sS   |  j  d  k rL |  j É  d p" d } t j | j d d É É } | |  _  n  |  j  S(   NR_  R\   s   
(   R´  Ro   t   _get_hdrR<   R©  Rs  (   RQ   R_  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _loadSummary  s
    c         C   s
   |  j  É  S(   N(   R≤  (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   &  s    c         C   sG   |  j  d  k r@ |  j É  d p" d } t j | É } | |  _  n  |  j  S(   NR`  R\   (   R¨  Ro   R±  R<   R©  (   RQ   R`  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _loadDescription(  s
    c         C   s
   |  j  É  S(   N(   R≥  (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   .  s    c         C   s`   |  j  d k r4 d |  j |  j |  j |  j f } n( d |  j  |  j |  j |  j |  j f } | S(   NRr   s   %s-%s-%s.%ss   %s:%s-%s-%s.%s(   R   R*   R   R   Rp   (   RQ   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRm   0  s    c         C   s2   |  j  s |  j É  t |  _  n  t j |  | | É S(   N(   RØ  t   _populatePrcoR   R˛   R∫   (   RQ   R∂   R∑   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR∫   9  s    	
c         C   s   |  j  S(   N(   R0  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR±  ?  s    c   	      C   sG  i t  j d É d 6t  j d É d 6t  j d É d 6t  j d É d 6} |  j É  } xÓ | D]Ê } | t t d	 | É } t t  j | É } | sî qY n  | t t d
 | É } t t j j | É } t t  j | É } | t t d | É } t t j j	 | É } t d Ñ  | É } | | } t t  j t
 | | | É É |  j | <qY Wd S(   s;   Populate the package object with the needed PRCO interface.R¶   t   OBSOLETERß   t   CONFLICTR®   t   REQUIRER©   t   PROVIDEs   RPMTAG_%sNAMEs   RPMTAG_%sFLAGSs   RPMTAG_%sVERSIONc         S   s4   t  j |  d É t  j |  d É t  j |  d É f S(   Ni    i   i   (   R<   R©  (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   V  s    N(   R<   R©  R±  RÇ   R4  t   mapR   R   R   R   t   zipR≠   (	   RQ   t   tag2prcoR0  t   tagR*   t   lstt   flagt   versR∂   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR¥  B  s&    		
c         C   sR   t  j d t j d d Éy t |  | É SWn! t k
 rM t j d | Ç n Xd  S(   Ns6   tagByName() will go away in a furture version of Yum.
Rè   i   s   Unknown header tag %s(   Rê   Rë   Rí   Rì   RÇ   t   AttributeErrorRI  (   RQ   Rº  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt	   tagByName\  s    	c         C   së   | j  d É r4 | j d É r4 t d |  | f Ç n  y |  j | SWnG t k
 ri t d |  | f Ç n$ t k
 rå t d |  | f Ç n Xd  S(   Nt   __s   %s has no attribute %s(   R–   R`   R¿  R0  t   KeyErrorRE   (   RQ   t   thing(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __getattr__d  s    c         C   s2   |  j  d } | d  k r" d } n t | É } | S(   NR   Rr   (   R0  Ro   Rå   (   RQ   t   tmpepochR   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR™  v  s
    	c         C   s   |  j  S(   N(   R0  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR9    s    c   	      C   s<  |  j  d } |  j  d } |  j  d } t | | | É } |  j s8xÁ | D]ﬂ \ } } } | d  k sp | d k r© d |  j k rè g  |  j d <n  |  j d j | É qI n  | |  j k r— t j | É |  j | <n  d } |  j | rÌ d } n | d  k	 r| d @rd } n  |  j j	 | g  É j | É qI Wt
 |  _ n  d  S(	   Nt	   filenamest	   fileflagst	   filemodesR\   R™   R´   i@   R¨   (   R0  R∫  R   Ro   RÆ   R    RÆ  RB  t   S_ISDIRt
   setdefaultR   (	   RQ   RÆ   R»  R…  t	   filetupleRŸ   t   modeRæ  t   fkey(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt
   _loadFilesÉ  s(    			 R™   c         C   s   |  j  É  t j |  | | É S(   s"   return list of files based on type(   Rœ  R˛   R“   (   RQ   R‘   Rÿ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR“   ú  s    
c         C   so   t  |  j d É d k rk t t j |  j d d d Ét j |  j d d d Ét j |  j d d d ÉÉ Sg  S(   Nt   changelognamei    t   changelogtimet   errorsRs  t   changelogtext(   Rº   R0  R∫  R<   RÄ  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR÷   °  s
    c         C   s   t  É  Ç d  S(   N(   Rå  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRñ   ´  s    c         C   s   |  j  d S(   NR†   (   R0  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR  Æ  s    c         C   s2   | d k	 r. | t j t j Bt j B@r. d Sn  d S(   sn   check the flags for a requirement, return 1 or 0 whether or not requires
           is a pre-requires or a noti   i    N(   Ro   R4  t   RPMSENSE_PREREQt   RPMSENSE_SCRIPT_PREt   RPMSENSE_SCRIPT_POST(   RQ   Ræ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _is_pre_req±  s    c         C   só   |  j  t j } |  j  t j } t t | É } t |  j | É } |  j  t j } t t | É } | d k	 rÑ t
 | | | | É } n  t j | É } | S(   s%   returns requires with pre-require bitN(   R0  R4  t   RPMTAG_REQUIRENAMEt   RPMTAG_REQUIREFLAGSRπ  R   R◊  t   RPMTAG_REQUIREVERSIONR   Ro   R∫  R<   RD   (   RQ   R*   RΩ  Ræ  Ró  Rø  Rá  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRç  æ  s    (   RV   RW   RX   RR   R≤  Rú   R_  R≥  R`  Rm   R   R∫   R±  R¥  R¡  R≈  R™  R9  Rœ  R“   R÷   Rñ   R  R◊  Rç  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRß    s*   														
			t   _CountedReadFilec           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s™    Has just a read() method, and keeps a count so we can find out how much
        has been read. Implemented so we can get the real size of the file from
        prelink. c         C   s   | |  _  d |  _ d  S(   Ni    (   t   fpt	   read_size(   RQ   R‹  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   –  s    	c         C   s+   |  j  j | É } |  j t | É 7_ | S(   N(   R‹  t   readR›  Rº   (   RQ   R†   R|   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRﬁ  ‘  s    (   RV   RW   RX   RR   Rﬁ  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR€  À  s   	t   _PkgVerifyProbc           B   s#   e  Z d  Z e d Ñ Z d Ñ  Z RS(   s8    Holder for each "problem" we find with a pkg.verify(). c         C   s:   | |  _  | |  _ d  |  _ d  |  _ | |  _ | |  _ d  S(   N(   Rj  t   messageRo   t   database_valuet
   disk_valuet
   file_typest   fake(   RQ   Rj  R~  t   ftypesR‰  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   ‹  s    					c         C   s  | d  k r d Si d d 6d d 6d d 6d d 6d d	 6d
 d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6} t | |  j | | j É } | sxu d d d g D]a } t |  | É } t | | É } | d  k rÛ | d  k s´ t Ç q´ n  t | | É } | r´ Pq´ q´ Wn  | S(   Ni   Rj  i   t   symlinki   RH  i   R†   t   useri   Ra  i   RÕ  i   t   genchecksumi   t   mtimei	   t   missingi
   s   permissions-missingi   Rˇ   i   t	   missingoki   R¨   R‚  R·  R„  (   Ro   R{   Rj  RÇ   t   AssertionError(   RQ   Ri   t	   type2sortR|   t   attrR  t   y(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRj   ‰  s$    (   RV   RW   RX   R   RR   Rj   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRﬂ  Ÿ  s   i   i   i   i   i   i   i   i   i   t   YUMVerifyPackageFilec           B   sg  e  Z d  Ñ  Z d  d Ñ Z e d d Ñ  d d Ñ  d d Ñ  É Z e d d Ñ  d d	 Ñ  d d
 Ñ  É Z e d d Ñ  d d Ñ  d d Ñ  É Z e d d Ñ  d d Ñ  d d Ñ  É Z	 e d d Ñ  d d Ñ  d d Ñ  É Z
 e d d Ñ  d d Ñ  d d Ñ  É Z e d d Ñ  d d Ñ  d d Ñ  É Z d Ñ  Z e d d Ñ  d d Ñ  d d Ñ  É Z e d Ñ  É Z e d d Ñ  É Z RS(!   c         C   ss   | |  _  d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 t
 |  _ t É  |  _ d  |  _ d  S(   N(   t   filenameRo   t   readlinkRÈ  t   devRÁ  Ra  RÕ  t   digestR†   R   t   verify_ftypeRΩ   t   rpmfile_typet   rpmfile_state(   RQ   RÒ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR     s    										c         C   sM   | d  k r d | } n  d | } t |  | | É t |  | | d  k	 É d  S(   Nt   verify_t   _(   Ro   R‹   (   RQ   RÓ  R  t   vattr(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _setVerifiedAttr  s
    
Ru   c         C   s   |  j  S(   N(   t	   _readlink(   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv     s    t   fdelc         C   s   t  |  d d  É S(   NRÚ  (   R‹   Ro   (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv     s    t   fsetc         C   s   |  j  d | É S(   NRÚ  (   R˚  (   R  RÔ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv     s    c         C   s   |  j  S(   N(   t   _mtime(   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv      s    c         C   s   t  |  d d  É S(   NRÈ  (   R‹   Ro   (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   !  s    c         C   s   |  j  d | É S(   NRÈ  (   R˚  (   R  RÔ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   "  s    c         C   s   |  j  S(   N(   t   _dev(   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   #  s    c         C   s   t  |  d d  É S(   NRÛ  (   R‹   Ro   (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   $  s    c         C   s   |  j  d | É S(   NRÛ  (   R˚  (   R  RÔ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   %  s    c         C   s   |  j  S(   N(   t   _user(   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   &  s    c         C   s   t  |  d d  É S(   NRÁ  (   R‹   Ro   (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   '  s    c         C   s   |  j  d | É S(   NRÁ  (   R˚  (   R  RÔ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   (  s    c         C   s   |  j  S(   N(   t   _group(   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   )  s    c         C   s   t  |  d d  É S(   NRa  (   R‹   Ro   (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   *  s    c         C   s   |  j  d | É S(   NRa  (   R˚  (   R  RÔ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   +  s    c         C   s   |  j  S(   N(   t   _digest(   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   -  s    c         C   s   t  |  d d  É S(   NRÙ  (   R‹   Ro   (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   .  s    c         C   s   |  j  d | É S(   NRÙ  (   R˚  (   R  RÔ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   /  s    c         C   s   |  j  S(   N(   R  (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   0  s    c         C   s   t  |  d d  É S(   NR†   (   R‹   Ro   (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   1  s    c         C   s   |  j  d | É S(   NR†   (   R˚  (   R  RÔ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   2  s    c         C   s<   | d  k	 |  _ | d  k	 |  _ d | } t |  | | É d  S(   NR˘  (   Ro   t   verify_modeRı  R‹   (   RQ   RÓ  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _setVerifiedMode4  s    
c         C   s   |  j  S(   N(   t   _mode(   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   :  s    c         C   s   t  |  d d  É S(   NRÕ  (   R‹   Ro   (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   ;  s    c         C   s   |  j  d | É S(   NRÕ  (   R  (   R  RÔ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   <  s    c         C   sv   t  j |  É r d St  j |  É r& d St  j |  É r9 d St  j |  É rL d St  j |  É r_ d St  j |  É rr d Sd S(   s5    Given a "mode" return the name of the type of file. R™   t	   directoryRÊ  t   fifos   character devices   block devices	   <unknown>(   RB  t   S_ISREGR   t   S_ISLNKt   S_ISFIFOt   S_ISCHRt   S_ISBLK(   RÕ  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _ftype>  s          c         C   s   |  j  |  j É S(   N(   R  RÕ  (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   I  s    N(   RV   RW   RR   Ro   R˚  Rú   RÚ  RÈ  RÛ  RÁ  Ra  RÙ  R†   R  RÕ  t   staticmethodR  R‘   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR    s:   										t   _RPMVerifyPackageFilec           B   s   e  Z e d  Ñ Z RS(   c         C   s…  t  j |  | d É | d } | r- d } n
 | d } | t @rQ | d |  _ n  | t @t Br∫ | d } | d k  rÇ | d @} n  | |  _ | t @s° t |  _ n  | t @s∫ t |  _	 q∫ n  | t
 @r‘ | d |  _ n  | t @rÓ | d	 |  _ n  t É  |  _ } | t j @r| j d
 É n  | t j @r8| j d É n  | t j @rU| j d É n  | t j @rr| j d É n  | t j @rè| j d É n  | t j @r¨| j d É n  | t j @r…| j d É n  | d }	 i d t j 6d t j 6d t j 6d t j 6d t j 6}
 |	 |
 k r'|
 |	 |  _ n	 d |  _ | t @rJ| d |  _ n  | t  @rd| d |  _! n  | t" @rÑ| | d f |  _# n  |  j$ d k rØ| t% @rØ| j& É  |  _' n | t% @r≈d |  _' n  d  S(   Ni    i   iˇˇˇˇi	   i   i   iˇˇ  i   i   t   configurationt   documentationR¨   Re  s
   public keyt   READMEs
   missing oki   t   normalt   replaceds   not installeds   wrong colort	   netshareds	   <unknown>i
   i   i   RÊ  R\   ((   R  RR   t   _RPMVERIFY_FILESIZER†   t   _RPMVERIFY_RDEVt   _RPMVERIFY_MODERÕ  R   R  Rı  t   _RPMVERIFY_MTIMERÈ  RÛ  RΩ   t   rpmfile_typesR4  t   RPMFILE_CONFIGt   addt   RPMFILE_DOCt   RPMFILE_GHOSTt   RPMFILE_LICENSEt   RPMFILE_PUBKEYt   RPMFILE_READMEt   RPMFILE_MISSINGOKt   RPMFILE_STATE_NORMALt   RPMFILE_STATE_REPLACEDt   RPMFILE_STATE_NOTINSTALLEDt   RPMFILE_STATE_WRONGCOLORt   RPMFILE_STATE_NETSHAREDR˜  t   _RPMVERIFY_USERRÁ  t   _RPMVERIFY_GROUPRa  t   _RPMVERIFY_DIGESTRÙ  R‘   t   _RPMVERIFY_LINKTOt   FLinkRÚ  (   RQ   t   fiRÃ  RL  t   override_vflagsRf  t   vflagsRÕ  R  Rˇ   t   statemap(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   M  sl    
	


	







	



(   RV   RW   R   RR   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR  L  s   t   YUMVerifyPackagec           B   sM   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   s,    A holder for YUMVerifyPackageFile objects. c         C   s   | |  _  i  |  _ d  S(   N(   t   pot   _files(   RQ   R3  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   ò  s    	c         C   s   | |  j  k S(   sp    Note that this checks if a filename is part of the package, and
            not a full YUMVerifyPackageFile(). (   R4  (   RQ   t   fname(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __contains__ú  s    c         c   s$   x |  j  D] } |  j  | Vq
 Wd  S(   N(   R4  (   RQ   RŸ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   __iter__°  s    c         C   s   | |  j  | j <d  S(   N(   R4  RÒ  (   RQ   t   vpf(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR  •  s    c         C   s   |  j  | j =d  S(   N(   R4  RÒ  (   RQ   R8  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   remove®  s    c         C   s$   | j  |  k r d  S|  j | É d  S(   N(   RÒ  R9  (   RQ   R8  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   discard´  s    c         C   s   i  |  _  d  S(   N(   R4  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   clear∞  s    (
   RV   RW   RX   RR   R6  R7  R  R9  R:  R;  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR2  ñ  s   						t   _RPMVerifyPackagec           B   sG   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s)   t  j |  | É | | | | f |  _ d  S(   N(   R2  RR   t	   _presetup(   RQ   R3  R.  t   def_csum_typet   patternst   all(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   µ  s    c   	      C   s±   t  |  d É s d  S|  j \ } } } } |  ` x| | D]t } | d } | rç t } x* | D]" } t j | | É rX t } PqX qX W| sç q5 qç n  |  j t | | | | É É q5 Wd  S(   NR=  i    (   R   R=  R   R?   R   R  R  (	   RQ   R.  R>  R?  R@  t   ftRŸ   RH   t   p(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _setupπ  s    
	c         O   s   |  j  É  t j |  | | é S(   N(   RC  R2  R6  (   RQ   t   argst   kwargs(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR6  Õ  s    
c         O   s   |  j  É  t j |  | | é S(   N(   RC  R2  R7  (   RQ   RD  RE  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR7  –  s    
c         O   s   |  j  É  t j |  | | é S(   N(   RC  R2  R  (   RQ   RD  RE  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR  ”  s    
c         O   s   |  j  É  t j |  | | é S(   N(   RC  R2  R9  (   RQ   RD  RE  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR9  ÷  s    
c         O   s+   t  |  d É r |  ` n  t j |  | | é S(   NR=  (   R   R=  R2  R;  (   RQ   RD  RE  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR;  ⁄  s    	(	   RV   RW   RR   RC  R6  R7  R  R9  R;  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR<  ¥  s   						R~   t   YumInstalledPackagec           B   s8   e  Z d  Z d d Ñ Z g  e e e e e d d Ñ Z RS(   s2   super class for dealing with packages in the rpmdbc         C   s2   t  j |  t | É | r. | j |  É |  _ n  d  S(   N(   Rß  RR   t   _installed_repot   get_packageR  (   RQ   R0  t   yumdb(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   Â  s    c   )      C   sD	  |  j  j É  } i  }	 d }
 t j j |
 É } d } t t d É rw |  j  t j } | rw | t k rt t | } qt qw n  t	 |  | | | | É } | d6 k	 r™ | | É } n  xì| D]ã} | j } t | j É } | j d k r | j d | j É | r± t d d | d t Ég |	 | <q± q± n  d	 | j k rW| rWt d
 d | d t Ég |	 | <n  d	 | j k rs| rsq± n  d | j k r™| r™t d d | d t Ég |	 | <n  d | j k r∆| r∆q± n  g  } t j j | j É rõt j | j É } | j } y t j | t j É d } Wn$ t k
 r@} d | t j } n Xy t j | t j É d } Wn$ t k
 rÖ} d | t j } n Xt j | j É } t  } | j! r—| j" j# d É s»| j# d É r—t } n  | rà| j" | k rt d d | É } | j" | _$ | | _% | j | É qà| j& d @| j' d @k ràt d d | É } t( | j& d @É | _$ t( | j' d @É | _% | j | É qàn  | j) rd } | d k r∏t j* | j É } n  | | j* k rt d d | É } | j* | _$ | | _% | j | É qn  t } d | k rt  } n  | d k rO| j" d k rOt j | j É j } n | d k rdt  } n  t } | d k rt  } n  | rÏ| j+ rÏt, | j- É t, | j. É k rÏt d d | É } | j. | _$ t, | j- É | _% | j | É n  | rA| j/ rA| | j0 k rAt d d | É } | j0 | _$ | | _% | j | É n  | rñ| j1 rñ| | j2 k rñt d d | É } | j2 | _$ | | _% | j | É n  | j } d | k r∏| d  M} n  | r| j3 r| | j4 k rt d! d" | É } | j4 | _$ | j | _% | j | É n  | j5 } | r>| r>| | j6 k r>t  } n  | j7 sPt  } n  | rC| sz| j8 rC| rC| | j6 k rC| j7 rØ| j7 d }  | j7 d d# | j7 d$ }! n | }  d }! y' t9 j: |  | j É }" |  d# |" }" Wn t; j< k
 r˛d6 }" n X| j5 rH|" d6 k rHt d% d& | É } |! | _$ d6 | _% | j | É n  |" |! k r˜| r˜t= |
 d' | j g d( d) d* t> d+ t> d, t> d- t É}# |# j? |# j@ |# jA }$ }% }& tB |% É }% t9 j: |  |% É }' |% jC r˜|' }" |  d# |" }" |% jC } q˜n  | j5 rC|" |! k rCt d. d/ | É } |! | _$ |" | _% | j | É qCn  | r&	| j8 r&	| | j6 k r&	t d0 d1 | É } | j6 | _$ | | _% | j | É q&	nã y t j | j É t }( Wn4 tD k
 rÎ} t }( | jE tE jF k rÏt  }( qÏn X|( r	t d2 d3 | É } n t d4 d5 | É } | j | É | r± | |	 | j <q± q± W|	 S(7   s¶   verify that the installed files match the packaged checksum
           optionally verify they match only if they are in the 'pattern' list
           returns a tuple s   /usr/sbin/prelinkt   md5t   RPMTAG_FILEDIGESTALGOR  s   state=Rˇ   s   state is not normalR‰  s
   missing okRÎ  s   missing but okR¨   s
   ghost filei    s   uid %s not founds   gid %s not foundt   deviceRj  s   file type does not matchiˇˇ  s   dev does not matchR\   RÊ  s   symlink does not matchR™   RÈ  s   mtime does not matchRÁ  s   user does not matchRa  s   group does not matchiˇ  RÕ  s   mode does not matcht   :i   RË  s   checksum not availables   -yt   bufsizeiˇˇˇˇt   stdint   stdoutt   stderrt	   close_fdsRH  s   checksum does not matchR†   s   size does not matchRÍ  s   file is missings   permissions-missings#   file is missing (Permission denied)N(G   R0  t   fiFromHeaderR]   R^   R2  R   R4  RK  t   RPM_CHECKSUM_TYPESR<  Ro   RÒ  t   listR  R˜  R    Rﬂ  R   t   lexistst   lstatRG  t   pwdt   getpwuidRB  t   ST_UIDR√  t   grpt   getgrgidt   ST_GIDR  R  t   st_modeR   t
   verify_devR‘   R`   R·  R‚  RÛ  RE  Rç   t   verify_readlinkRÚ  t   verify_mtimeR#  RF  RÈ  t   verify_userRÁ  t   verify_groupRa  R  RÕ  t   verify_digestR†   RÙ  t   verify_sizeR<   RH  Rí   RI  R    R   RO  RP  RQ  R€  R›  RC  t   errnot   EACCES()   RQ   R?  t   depst   scriptt   fake_problemsR@  t   fastt   callbackR.  Rπ   t   prelink_cmdt   have_prelinkRL  t   csum_numt   pfst   pfRŸ   RÂ  t   problemst   my_stt
   my_st_sizet   my_userR'   t   my_groupt   my_ftypeR_  t   probt   my_fnlt   check_contentt   check_permst   my_modeRd  t   digest_typeRô   t   my_csumRB  t   igR‹  t   ert   tcsumt   perms_ok(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   verifyÍ  sT   																								
						
	N(   RV   RW   RX   Ro   RR   R   R   RÉ  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRF  „  s   	t   YumLocalPackagec           B   sï   e  Z d  Z d d d Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z e d d Ñ  É Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z e d d
 Ñ  É Z e d d Ñ  É Z d Ñ  Z RS(   s  Class to handle an arbitrary package from a file path
       this inherits most things from YumInstalledPackage because
       installed packages and an arbitrary package on disk act very
       much alike. init takes a ts instance and a filename/path 
       to the package.c         C   sÇ  | d  k r t j j É  } n  | d  k r9 t j d Ç n  d |  _ | |  _ d  |  _ y t j	 j
 | |  j É } Wn, t k
 rû } t j d |  j | f Ç n Xt | É } d | _ t j |  | | É |  j |  _ t j |  j É |  _ t |  j d É |  _ t |  j d É |  _ |  j É  |  _ |  j |  j |  j |  j |  j f |  _ d  |  _ d  |  _  t! j" d |  _# d  |  _$ d |  _% d  S(   Ns;   No Filename specified for YumLocalPackage instance creationt   locals%   Could not open local rpm file: %s: %si    i˛ˇˇˇi   R\   (&   Ro   R   R*  R+  Rí   RI  t   pkgtypeR:  R!  R   R,  R   RY   t   costRß  RR   Rk  R4   R]   RB  t   _statRå   Rn  R  t   isSrpmRp   R*   R   Ry   RÕ   R   t	   _hdrstartt   _hdrendR<   t   _default_checksumsRT  t   _reldirt   _baseurl(   RQ   R/  RÒ  R0  R'   t   fakerepo(    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   œ  s6    					'			c         C   s:   |  j  d É d k s% |  j  d É r) d S|  j  d É Sd  S(   Nt   sourcepackagei   R‰   t   srcRp   (   R¡  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRâ  ˜  s    %c         C   s   |  j  S(   N(   R:  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR)  ˝  s    c         C   s_   | d  k r t j d } n  |  j sX t j | |  j É |  _ | |  j d f g |  _ n  |  j S(   Ni    i   (   Ro   R<   Rå  R!  RH  R:  Rq   (   RQ   RT  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _do_checksum   s    	Ru   c         C   s
   |  j  É  S(   N(   Rí  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   	  s    c         C   s   |  j  É  |  j S(   N(   Rí  Rq   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRñ     s    
c         C   s   t  S(   s5    don't bother "checking" the package matches itself. (   R   (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR£     s    c         C   s{  |  j  r" |  j r" |  j  |  j f St |  j d É } | j d É | j d É } t j d | É \ } | j d É } t j d | É \ } | d } | | } | d } | d k r¿ d | } n  d | | }	 | j |	 É | j d d	 É | j d É } t j d | É \ }
 | j d É } t j d | É \ } |
 d } | | d } |	 | } | j É  |	 |  _  | |  _ |	 | f S(
   sQ   takes an rpm file or fileobject and returns byteranges for location of the headerR)   ih   i   s   >Ii   i   i    ip   i   (	   Rä  Rã  t   openR:  t   seekRﬁ  t   structt   unpackt   close(   RQ   t   fot   binindext   sigindext   bindatat   sigdatat   sigindexsizet   sigsizet   disttoboundaryRq  t   hdrindext   hdrdatat   hdrindexsizet   hdrsizeRr  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   _get_header_byte_range  s6    





		c         C   s   |  j  É  d S(   Ni   (   R§  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   C  s    c         C   s   |  j  É  d S(   Ni    (   R§  (   RQ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRv   D  s    c         C   sπ   |  j  rV |  j j |  j  É rV |  j j |  j  d É } | d d k r_ | d } q_ n	 |  j } |  j rú d t j |  j d t Ét j | d t Éf } n d t j | d t É} | S(   NR\   i    RZ   i   s$   <location xml:base="%s" href="%s"/>
Rz  s   <location href="%s"/>
(   Rç  R:  R–   Rs  Ré  R<   R}  R   (   RQ   t   relpathR~  (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR  F  s     		N(   RV   RW   RX   Ro   RR   Râ  R)  Rí  Rú   RH  Rñ   R£   R§  Rr  Rq  R  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRÑ  »  s   (						0t   YumUrlPackagec           B   s#   e  Z d  Z d d d d d Ñ Z RS(   sÁ   Class to handle an arbitrary package from a URL
       this inherits most things from YumLocalPackage, but will download a
       remote package to make it local.
       init takes a YumBase, a ts instance and a url to the package.c         C   sª  | j  É  j d É r( | t d É } n|t j | É s@ | } ndd  } i  } xl | j j É  D][ } | j } | j	 | j
 j	 k r\ | j | j
 j k r\ | j | j
 j k r\ | j } Pq\ q\ Wt j j | É }	 t j É  }
 |
 d  k rı d | j }
 n  d |
 |	 f }
 yp t d | j
 j d | j
 j d | j
 j d | d | É } | d  k	 r\| | j _ n  | j | |
 d	 |	 É} Wn, t k
 r£} t j d
 | | f É Ç n Xt j |  | | É d  S(   Ns   file:s   %s/../s   %s/%st	   bandwidtht   retryt   throttlet   progress_objt   proxiesRx  s   Cannot download %s: %s(   R   R–   Rº   R<   t   re_remote_urlRo   t   repost   listEnabledRl  t   proxyt   conft   proxy_usernamet   proxy_passwordt
   proxy_dictR]   R^   R_   t   getCacheDirt   cachedirR	   Rß  t   retriesR©  t   optst
   user_agentt   urlgrabR
   Rí   RI  RÑ  RR   (   RQ   t   ybR/  Rc  t   uaRœ   t   cbt   pdR3   R5  RÖ  t   ugR'   (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyRR   a  s<    				N(   RV   RW   RX   Ro   RR   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyR¶  [  s   (K   RX   R4  R]   t   os.pathR<   Rø   RA   R?   RB  Rê   t
   subprocessR    R   R   R   t   rpmUtils.miscutilsR   R   R   Rí   Rf  Rï  t	   constantst   operatorR   R  t   uses_fragmentR    R¿  t   errt   urlgrabber.grabberR	   R
   RO  R   Ro   t   ImportErrorRX  R[  R   R   R   R2   RO   RP   RY   t   objectRn   R°   Rá  Rü   R•   R≤   R˛   Rß  R€  Rﬂ  R+  R  R,  R)  R*  R  R  R  t   _RPMVERIFY_CAPSt   _RPMVERIFY_CONTEXTSR  R  R2  R<  RG  RF  RÑ  R¶  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/packages.pyt   <module>   sé   
	
		"84ç	ˇ 1ˇ ˇ 4» 









HJ,	Âì                                                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python2.7/dist-packages/yum/parser.py                                                       0100644 0000000 0000000 00000017500 12451005146 017574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python -tt
import re
import urlparse
import urlgrabber
import os.path

import Errors


_KEYCRE = re.compile(r"\$(\w+)")

def varReplace(raw, vars):
    '''Perform variable replacement

    @param raw: String to perform substitution on.  
    @param vars: Dictionary of variables to replace. Key is variable name
        (without $ prefix). Value is replacement string.
    @return: Input raw string with substituted values.
    '''

    done = []                      # Completed chunks to return

    while raw:
        m = _KEYCRE.search(raw)
        if not m:
            done.append(raw)
            break

        # Determine replacement value (if unknown variable then preserve
        # original)
        varname = m.group(1).lower()
        replacement = vars.get(varname, m.group())

        start, end = m.span()
        done.append(raw[:start])    # Keep stuff leading up to token
        done.append(replacement)    # Append replacement value
        raw = raw[end:]             # Continue with remainder of string

    return ''.join(done)

class ConfigPreProcessor:
    """
    ConfigParser Include Pre-Processor

    File-like Object capable of pre-processing include= lines for
    a ConfigParser. 

    The readline function expands lines matching include=(url)
    into lines from the url specified. Includes may occur in
    included files as well. 

    Suggested Usage::
        cfg = ConfigParser.ConfigParser()
        fileobj = confpp( fileorurl )
        cfg.readfp(fileobj)
    """
    
    
    def __init__(self, configfile, vars=None):
        # put the vars away in a helpful place
        self._vars = vars

        # used to track the current ini-section
        self._section = None
        
        # set some file-like object attributes for ConfigParser
        # these just make confpp look more like a real file object.
        self.mode = 'r' 
        
        # first make configfile a url even if it points to 
        # a local file
        scheme = urlparse.urlparse(configfile)[0]
        if scheme == '':
            # check it to make sure it's not a relative file url
            if configfile[0] != '/':
                configfile = os.getcwd() + '/' + configfile
            url = 'file://' + configfile
        else:
            url = configfile
        
        # these are used to maintain the include stack and check
        # for recursive/duplicate includes
        self._incstack = []
        self._alreadyincluded = []
        
        # _pushfile will return None if he couldn't open the file
        fo = self._pushfile( url )
        if fo is None: 
            raise Errors.ConfigError, 'Error accessing file: %s' % url
        
    def readline( self, size=0 ):
        """
        Implementation of File-Like Object readline function. This should be
        the only function called by ConfigParser according to the python docs.
        We maintain a stack of real FLOs and delegate readline calls to the 
        FLO on top of the stack. When EOF occurs on the topmost FLO, it is 
        popped off the stack and the next FLO takes over. include= lines 
        found anywhere cause a new FLO to be opened and pushed onto the top 
        of the stack. Finally, we return EOF when the bottom-most (configfile
        arg to __init__) FLO returns EOF.
        
        Very Technical Pseudo Code::
        
            def confpp.readline() [this is called by ConfigParser]
                open configfile, push on stack
                while stack has some stuff on it
                    line = readline from file on top of stack
                    pop and continue if line is EOF
                    if line starts with 'include=' then
                        error if file is recursive or duplicate
                        otherwise open file, push on stack
                        continue
                    else
                        return line
                
                return EOF
        """
        
        # set line to EOF initially. 
        line=''
        while len(self._incstack) > 0:
            # peek at the file like object on top of the stack
            fo = self._incstack[-1]
            line = fo.readline()
            if len(line) > 0:
                m = re.match( r'\s*include\s*=\s*(?P<url>.*)', line )
                if m:
                    url = m.group('url')
                    if len(url) == 0:
                        raise Errors.ConfigError, \
                             'Error parsing config %s: include must specify file to include.' % (self.name)
                    else:
                        # whooohoo a valid include line.. push it on the stack
                        fo = self._pushfile( url )
                else:
                    # check if the current line starts a new section
                    secmatch = re.match( r'\s*\[(?P<section>.*)\]', line )
                    if secmatch:
                        self._section = secmatch.group('section')
                    # line didn't match include=, just return it as is
                    # for the ConfigParser
                    break
            else:
                # the current file returned EOF, pop it off the stack.
                self._popfile()
        
        # if the section is prefixed by a space then it is breaks iniparser/configparser
        # so fix it
        broken_sec_match = re.match(r'\s+\[(?P<section>.*)\]', line)
        if broken_sec_match:
            line = line.lstrip()
        # at this point we have a line from the topmost file on the stack
        # or EOF if the stack is empty
        if self._vars:
            return varReplace(line, self._vars)
        return line
    
    
    def _absurl( self, url ):
        """
        Returns an absolute url for the (possibly) relative
        url specified. The base url used to resolve the
        missing bits of url is the url of the file currently
        being included (i.e. the top of the stack).
        """
        
        if len(self._incstack) == 0:
            # it's the initial config file. No base url to resolve against.
            return url
        else:
            return urlparse.urljoin( self.geturl(), url )

    def _pushfile( self, url ):
        """
        Opens the url specified, pushes it on the stack, and 
        returns a file like object. Returns None if the url 
        has previously been included.
        If the file can not be opened this function exits.
        """
        
        # absolutize this url using the including files url
        # as a base url.
        absurl = self._absurl(url)

        # get the current section to add it to the included
        # url's name.
        includetuple = (absurl, self._section)
        # check if this has previously been included.
        if self._isalreadyincluded(includetuple):
            return None
        try:
            fo = urlgrabber.grabber.urlopen(absurl)
        except urlgrabber.grabber.URLGrabError, e:
            fo = None
        if fo is not None:
            self.name = absurl
            self._incstack.append( fo )
            self._alreadyincluded.append(includetuple)
        else:
            raise Errors.ConfigError, \
                  'Error accessing file for config %s' % (absurl)

        return fo
    
    
    def _popfile( self ):
        """
        Pop a file off the stack signaling completion of including that file.
        """
        fo = self._incstack.pop()
        fo.close()
        if len(self._incstack) > 0:
            self.name = self._incstack[-1].geturl()
        else:
            self.name = None
    
    
    def _isalreadyincluded( self, tuple ):
        """
        Checks if the tuple describes an include that was already done.
        This does not necessarily have to be recursive
        """
        for etuple in self._alreadyincluded:
            if etuple == tuple: return 1
        return 0
    
    
    def geturl(self): return self.name
                                                                                                                                                                                                usr/lib/python2.7/dist-packages/yum/parser.pyc                                                      0100644 0000000 0000000 00000014700 13077704344 017751  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   sk   d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z e  j d É Z d Ñ  Z d d d Ñ  É  YZ	 d S(   iˇˇˇˇNs   \$(\w+)c         C   s≠   g  } xó |  rü t  j |  É } | s5 | j |  É Pn  | j d É j É  } | j | | j É  É } | j É  \ } } | j |  |  É | j | É |  | }  q	 Wd j | É S(   s  Perform variable replacement

    @param raw: String to perform substitution on.  
    @param vars: Dictionary of variables to replace. Key is variable name
        (without $ prefix). Value is replacement string.
    @return: Input raw string with substituted values.
    i   t    (   t   _KEYCREt   searcht   appendt   groupt   lowert   gett   spant   join(   t   rawt   varst   donet   mt   varnamet   replacementt   startt   end(    (    s.   /usr/lib/python2.7/dist-packages/yum/parser.pyt
   varReplace   s    		t   ConfigPreProcessorc           B   sS   e  Z d  Z d	 d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(
   s°  
    ConfigParser Include Pre-Processor

    File-like Object capable of pre-processing include= lines for
    a ConfigParser. 

    The readline function expands lines matching include=(url)
    into lines from the url specified. Includes may occur in
    included files as well. 

    Suggested Usage::
        cfg = ConfigParser.ConfigParser()
        fileobj = confpp( fileorurl )
        cfg.readfp(fileobj)
    c         C   s∏   | |  _  d  |  _ d |  _ t j | É d } | d k rn | d d k ra t j É  d | } n  d | } n | } g  |  _ g  |  _ |  j	 | É } | d  k r¥ t
 j d | Ç n  d  S(   Nt   ri    R    t   /s   file://s   Error accessing file: %s(   t   _varst   Nonet   _sectiont   modet   urlparset   ost   getcwdt	   _incstackt   _alreadyincludedt	   _pushfilet   Errorst   ConfigError(   t   selft
   configfileR
   t   schemet   urlt   fo(    (    s.   /usr/lib/python2.7/dist-packages/yum/parser.pyt   __init__;   s    					i    c         C   s-  d } x‡ t  |  j É d k rË |  j d } | j É  } t  | É d k r€ t j d | É } | r™ | j d É } t  | É d k rò t j d |  j Ç qÿ |  j	 | É } qÂ t j d | É } | r◊ | j d É |  _
 n  Pq	 |  j É  q	 Wt j d	 | É } | r| j É  } n  |  j r)t | |  j É S| S(
   s÷  
        Implementation of File-Like Object readline function. This should be
        the only function called by ConfigParser according to the python docs.
        We maintain a stack of real FLOs and delegate readline calls to the 
        FLO on top of the stack. When EOF occurs on the topmost FLO, it is 
        popped off the stack and the next FLO takes over. include= lines 
        found anywhere cause a new FLO to be opened and pushed onto the top 
        of the stack. Finally, we return EOF when the bottom-most (configfile
        arg to __init__) FLO returns EOF.
        
        Very Technical Pseudo Code::
        
            def confpp.readline() [this is called by ConfigParser]
                open configfile, push on stack
                while stack has some stuff on it
                    line = readline from file on top of stack
                    pop and continue if line is EOF
                    if line starts with 'include=' then
                        error if file is recursive or duplicate
                        otherwise open file, push on stack
                        continue
                    else
                        return line
                
                return EOF
        R    i    iˇˇˇˇs   \s*include\s*=\s*(?P<url>.*)R$   s>   Error parsing config %s: include must specify file to include.s   \s*\[(?P<section>.*)\]t   sections   \s+\[(?P<section>.*)\](   t   lenR   t   readlinet   ret   matchR   R   R    t   nameR   R   t   _popfilet   lstripR   R   (   R!   t   sizet   lineR%   R   R$   t   secmatcht   broken_sec_match(    (    s.   /usr/lib/python2.7/dist-packages/yum/parser.pyR)   [   s.    	c         C   s3   t  |  j É d k r | St j |  j É  | É Sd S(   sÓ   
        Returns an absolute url for the (possibly) relative
        url specified. The base url used to resolve the
        missing bits of url is the url of the file currently
        being included (i.e. the top of the stack).
        i    N(   R(   R   R   t   urljoint   geturl(   R!   R$   (    (    s.   /usr/lib/python2.7/dist-packages/yum/parser.pyt   _absurlü   s    c         C   sµ   |  j  | É } | |  j f } |  j | É r1 d Sy t j j | É } Wn t j j k
 rh } d } n X| d k	 r° | |  _ |  j	 j
 | É |  j j
 | É n t j d | Ç | S(   sÂ   
        Opens the url specified, pushes it on the stack, and 
        returns a file like object. Returns None if the url 
        has previously been included.
        If the file can not be opened this function exits.
        s"   Error accessing file for config %sN(   R5   R   t   _isalreadyincludedR   t
   urlgrabbert   grabbert   urlopent   URLGrabErrorR,   R   R   R   R   R    (   R!   R$   t   absurlt   includetupleR%   t   e(    (    s.   /usr/lib/python2.7/dist-packages/yum/parser.pyR   ≠   s    

	
c         C   sT   |  j  j É  } | j É  t |  j  É d k rG |  j  d j É  |  _ n	 d |  _ d S(   sW   
        Pop a file off the stack signaling completion of including that file.
        i    iˇˇˇˇN(   R   t   popt   closeR(   R4   R,   R   (   R!   R%   (    (    s.   /usr/lib/python2.7/dist-packages/yum/parser.pyR-   Œ   s
    
c         C   s(   x! |  j  D] } | | k r
 d Sq
 Wd S(   sà   
        Checks if the tuple describes an include that was already done.
        This does not necessarily have to be recursive
        i   i    (   R   (   R!   t   tuplet   etuple(    (    s.   /usr/lib/python2.7/dist-packages/yum/parser.pyR6   ⁄   s     c         C   s   |  j  S(   N(   R,   (   R!   (    (    s.   /usr/lib/python2.7/dist-packages/yum/parser.pyR4   ‰   s    N(   t   __name__t
   __module__t   __doc__R   R&   R)   R5   R   R-   R6   R4   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/parser.pyR   )   s    D		!		
(    (
   R*   R   R7   t   os.pathR   R   t   compileR   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/parser.pyt   <module>   s   	                                                                usr/lib/python2.7/dist-packages/yum/pgpmsg.py                                                       0100644 0000000 0000000 00000152224 12451005146 017600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python -tt
##Copyright (C) 2003,2005,2009  Jens B. Jorgensen <jbj1@ultraemail.net>
##
##This program is free software; you can redistribute it and/or
##modify it under the terms of the GNU General Public License
##as published by the Free Software Foundation; either version 2
##of the License, or (at your option) any later version.
##
##This program is distributed in the hope that it will be useful,
##but WITHOUT ANY WARRANTY; without even the implied warranty of
##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##GNU General Public License for more details.
##
##You should have received a copy of the GNU General Public License
##along with this program; if not, write to the Free Software
##Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
import struct, time, cStringIO, base64, types

#  We use this so that we can work on python-2.4 and python-2.6, and thus.
# use import md5/import sha on the older one and import hashlib on the newer.
#  Stupid deprecation warnings.

# pylint: disable-msg=W0108 
# Ignore :W0108: *Lambda may not be necessary*


try:
    import hashlib
except ImportError:
    # Python-2.4.z ... gah!
    import sha
    import md5
    class hashlib:

        @staticmethod
        def new(algo):
            if algo == 'md5':
                return md5.new()
            if algo == 'sha1':
                return sha.new()
            raise ValueError, "Bad checksum type"

debug = None

# Cypher Type Byte
# bits 7,6 of the CTB say what kind it is
# we only have reserved defined
CTB_76_NORMAL = 0x80
CTB_76_NEW = 0xc0
CTB_76_MASK = 0xc0

# CTB packet type, bits 5,4,3,2
CTB_PKTV2_MASK = 0x3c    # 1111 - mask for this field
CTB_PKT_MASK = 0x3f      # 111111 - all the lower bits

CTB_PKT_PK_ENC = 1       # 0001 - public-key encrypted session packet
CTB_PKT_SIG = 2          # 0010 - signature packet
CTB_PKT_SK_ENC = 3       # 0011 - symmetric-key encrypted session packet
CTB_PKT_OP_SIG = 4       # 0100 - one-pass signature packet
CTB_PKT_SK_CERT = 5      # 0101 - secret-key certificate packet
CTB_PKT_PK_CERT = 6      # 0110 - public-key certificate packet
CTB_PKT_SK_SUB = 7       # 0111 - secret-key subkey packet
CTB_PKT_COMPRESSED = 8   # 1000 - compressed data packet
CTB_PKT_ENC = 9          # 1001 - symmetric-key encrypted data packet
CTB_PKT_MARKER = 10      # 1010 - marker packet
CTB_PKT_LIT = 11         # 1011 - literal data packet
CTB_PKT_TRUST = 12       # 1100 - trust packet
CTB_PKT_USER_ID = 13     # 1101 - user id packet
CTB_PKT_PK_SUB = 14      # 1110 - public subkey packet
CTB_PKT_USER_ATTR = 17   # 10001 - user attribute packet
CTB_PKT_SYM_ENC_INT = 18 # 10010 - symmetric encrypted integrity packet
CTB_PKT_MOD_DETECT = 19  # 10011 - modification detection code packet

ctb_pkt_to_str = {
    CTB_PKT_PK_ENC : 'public-key encrypted session packet',
    CTB_PKT_SIG : 'signature packet',
    CTB_PKT_SK_ENC : 'symmetric-key encrypted session packet',
    CTB_PKT_OP_SIG : 'one-pass signature packet',
    CTB_PKT_SK_CERT : 'secret-key certificate packet',
    CTB_PKT_PK_CERT : 'public-key certificate packet',
    CTB_PKT_SK_SUB : 'secret-key subkey packet',
    CTB_PKT_COMPRESSED : 'compressed data packet',
    CTB_PKT_ENC : 'symmetric-key encrypted data packet',
    CTB_PKT_MARKER : 'marker packet',
    CTB_PKT_LIT : 'literal data packet',
    CTB_PKT_TRUST : 'trust packet',
    CTB_PKT_USER_ID : 'user id packet',
    CTB_PKT_PK_SUB : 'public subkey packet',
    CTB_PKT_USER_ATTR : 'user attribute packet',
    CTB_PKT_SYM_ENC_INT : 'symmetric encrypted integrity packet',
    CTB_PKT_MOD_DETECT : 'modification detection code packet'
}


# CTB packet-length
CTB_PKT_LEN_MASK = 0x3   # 11 - mask

CTB_PKT_LEN_1 = 0        # 00 - 1 byte
CTB_PKT_LEN_2 = 1        # 01 - 2 bytes
CTB_PKT_LEN_4 = 2        # 10 - 4 bytes
CTB_PKT_LEN_UNDEF = 3    # 11 - no packet length supplied

# Algorithms

# Public Key Algorithms
ALGO_PK_RSA_ENC_OR_SIGN = 1        # RSA (Encrypt or Sign)
ALGO_PK_RSA_ENC_ONLY = 2           # RSA Encrypt-Only
ALGO_PK_RSA_SIGN_ONLY = 3          # RSA Sign-Only
ALGO_PK_ELGAMAL_ENC_ONLY = 16      # Elgamal (Encrypt-Only)
ALGO_PK_DSA = 17                   # DSA (Digital Signature Standard)
ALGO_PK_ELLIPTIC_CURVE = 18        # Elliptic Curve
ALGO_PK_ECDSA = 19                 # ECDSA
ALGO_PK_ELGAMAL_ENC_OR_SIGN = 20   # Elgamal (Encrypt or Sign)
ALGO_PK_DH = 21                    # Diffie-Hellman

algo_pk_to_str = {
    ALGO_PK_RSA_ENC_OR_SIGN : 'RSA (Encrypt or Sign)',
    ALGO_PK_RSA_ENC_ONLY : 'RSA Encrypt-Only',
    ALGO_PK_RSA_SIGN_ONLY : 'RSA Sign-Only',
    ALGO_PK_ELGAMAL_ENC_ONLY : 'Elgamal Encrypt-Only',
    ALGO_PK_DSA : 'DSA (Digital Signature Standard)',
    ALGO_PK_ELLIPTIC_CURVE : 'Elliptic Curve',
    ALGO_PK_ECDSA : 'ECDSA',
    ALGO_PK_ELGAMAL_ENC_OR_SIGN : 'Elgamal (Encrypt or Sign)',
    ALGO_PK_DH : 'Diffie-Hellman'
}    

# Symmetric Key Algorithms
ALGO_SK_PLAIN = 0 # Plaintext or unencrypted data
ALGO_SK_IDEA = 1 # IDEA
ALGO_SK_3DES = 2 # Triple-DES
ALGO_SK_CAST5 = 3 # CAST5
ALGO_SK_BLOWFISH = 4 # Blowfish
ALGO_SK_SAFER_SK128 = 5 # SAFER-SK128
ALGO_SK_DES_SK = 6 # DES/SK
ALGO_SK_AES_128 = 7 # AES 128-bit
ALGO_SK_AES_192 = 8 # AES 192-bit
ALGO_SK_AES_256 = 9 # AES 256-bit
ALGO_SK_TWOFISH_256 = 10 # Twofish 256

algo_sk_to_str = {
    ALGO_SK_PLAIN : 'Plaintext or unencrypted data',
    ALGO_SK_IDEA : 'IDEA',
    ALGO_SK_3DES : 'Triple-DES',
    ALGO_SK_CAST5 : 'CAST5',
    ALGO_SK_BLOWFISH : 'Blowfish',
    ALGO_SK_SAFER_SK128 : 'SAFER-SK128',
    ALGO_SK_DES_SK : 'DES/SK',
    ALGO_SK_AES_128 : 'AES 128-bit',
    ALGO_SK_AES_192 : 'AES 192-bit',
    ALGO_SK_AES_256 : 'AES 256-bit',
    ALGO_SK_TWOFISH_256 : 'Twofish 256-bit'
}

# Compression Algorithms
ALGO_COMP_UNCOMP = 0 # Uncompressed
ALGO_COMP_ZIP = 1    # ZIP
ALGO_COMP_ZLIB = 2   # ZLIB
ALGO_COMP_BZIP2 = 3  # BZip2

algo_comp_to_str = {
    ALGO_COMP_UNCOMP : 'Uncompressed',
    ALGO_COMP_ZIP : 'ZIP',
    ALGO_COMP_ZLIB : 'ZLIB',
    ALGO_COMP_BZIP2 : 'BZip2'
}

# Hash Algorithms
ALGO_HASH_MD5 = 1                  # MD5
ALGO_HASH_SHA1 = 2                 # SHA1
ALGO_HASH_RIPEMD160 = 3            # RIPEMD160
ALGO_HASH_SHA_DBL = 4              # double-width SHA
ALGO_HASH_MD2 = 5                  # MD2
ALGO_HASH_TIGER192 = 6             # TIGER192
ALGO_HASH_HAVAL_5_160 = 7          # HAVAL-5-160
ALGO_HASH_SHA256 = 8               # SHA256
ALGO_HASH_SHA384 = 9               # SHA384
ALGO_HASH_SHA512 = 10              # SHA512
ALGO_HASH_SHA224 = 11              # SHA224

algo_hash_to_str = {
    ALGO_HASH_MD5 : 'MD5',
    ALGO_HASH_SHA1 : 'SHA1',
    ALGO_HASH_RIPEMD160 : 'RIPEMD160',
    ALGO_HASH_SHA_DBL : 'double-width SHA',
    ALGO_HASH_MD2 : 'MD2',
    ALGO_HASH_TIGER192 : 'TIGER192',
    ALGO_HASH_HAVAL_5_160 : 'HAVAL-5-160',
    ALGO_HASH_SHA256 : 'SHA256',
    ALGO_HASH_SHA384 : 'SHA384',
    ALGO_HASH_SHA512 : 'SHA512',
    ALGO_HASH_SHA224 : 'SHA224'
}

# Signature types
SIG_TYPE_DOCUMENT = 0x00           # document signature, binary image
SIG_TYPE_DOCUMENT_CANON = 0x01     # document signature, canonical text
SIG_TYPE_STANDALONE = 0x02         # signature over just subpackets
SIG_TYPE_PK_USER_GEN = 0x10        # public key packet and user ID packet, generic certification
SIG_TYPE_PK_USER_PER = 0x11        # public key packet and user ID packet, persona
SIG_TYPE_PK_USER_CAS = 0x12        # public key packet and user ID packet, casual certification
SIG_TYPE_PK_USER_POS = 0x13        # public key packet and user ID packet, positive certification
SIG_TYPE_SUBKEY_BIND = 0x18        # subkey binding
SIG_TYPE_KEY = 0x1F                # key signature
SIG_TYPE_KEY_REVOKE = 0x20      # key revocation
SIG_TYPE_SUBKEY_REVOKE = 0x28   # subkey revocation
SIG_TYPE_CERT_REVOKE = 0x30     # certificate revocation
SIG_TYPE_TIMESTAMP = 0x40       # timestamp

sig_type_to_str = {
    SIG_TYPE_DOCUMENT : 'document signature, binary image',
    SIG_TYPE_DOCUMENT_CANON : 'document signature, canonical text',
    SIG_TYPE_STANDALONE : 'signature over just subpackets',
    SIG_TYPE_PK_USER_GEN : 'public key packet and user ID packet, generic certification',
    SIG_TYPE_PK_USER_PER : 'public key packet and user ID packet, persona',
    SIG_TYPE_PK_USER_CAS : 'public key packet and user ID packet, casual certification',
    SIG_TYPE_PK_USER_POS : 'public key packet and user ID packet, positive certification',
    SIG_TYPE_SUBKEY_BIND : 'subkey binding',
    SIG_TYPE_KEY : 'key signature',
    SIG_TYPE_KEY_REVOKE : 'key revocation',
    SIG_TYPE_SUBKEY_REVOKE : 'subkey revocation',
    SIG_TYPE_CERT_REVOKE : 'certificate revocation',
    SIG_TYPE_TIMESTAMP : 'timestamp'
}

# Signature sub-packet types
SIG_SUB_TYPE_CREATE_TIME = 2        # signature creation time
SIG_SUB_TYPE_EXPIRE_TIME = 3        # signature expiration time
SIG_SUB_TYPE_EXPORT_CERT = 4        # exportable certification
SIG_SUB_TYPE_TRUST_SIG = 5          # trust signature
SIG_SUB_TYPE_REGEXP = 6             # regular expression
SIG_SUB_TYPE_REVOCABLE = 7          # revocable
SIG_SUB_TYPE_KEY_EXPIRE = 9         # key expiration time
SIG_SUB_TYPE_PLACEHOLDER = 10       # placeholder for backward compatibility
SIG_SUB_TYPE_PREF_SYMM_ALGO = 11    # preferred symmetric algorithms
SIG_SUB_TYPE_REVOKE_KEY = 12        # revocation key
SIG_SUB_TYPE_ISSUER_KEY_ID = 16     # issuer key ID
SIG_SUB_TYPE_NOTATION = 20          # notation data
SIG_SUB_TYPE_PREF_HASH_ALGO = 21    # preferred hash algorithms
SIG_SUB_TYPE_PREF_COMP_ALGO = 22    # preferred compression algorithms
SIG_SUB_TYPE_KEY_SRV_PREF = 23      # key server preferences
SIG_SUB_TYPE_PREF_KEY_SRVR = 24     # preferred key server
SIG_SUB_TYPE_PRIM_USER_ID = 25      # primary user id
SIG_SUB_TYPE_POLICY_URI = 26        # policy URI
SIG_SUB_TYPE_KEY_FLAGS = 27         # key flags
SIG_SUB_TYPE_SGNR_USER_ID = 28      # signer's user id
SIG_SUB_TYPE_REVOKE_REASON = 29     # reason for revocation
SIG_SUB_TYPE_FEATURES = 30          # features
SIG_SUB_TYPE_SIG_TARGET = 31        # signature target
SIG_SUB_TYPE_EMBEDDED_SIG = 32      # embedded signature

sig_sub_type_to_str = {
    SIG_SUB_TYPE_CREATE_TIME : 'signature creation time',
    SIG_SUB_TYPE_EXPIRE_TIME : 'signature expiration time',
    SIG_SUB_TYPE_EXPORT_CERT : 'exportable certification',
    SIG_SUB_TYPE_TRUST_SIG : 'trust signature',
    SIG_SUB_TYPE_REGEXP : 'regular expression',
    SIG_SUB_TYPE_REVOCABLE : 'revocable',
    SIG_SUB_TYPE_KEY_EXPIRE : 'key expiration time',
    SIG_SUB_TYPE_PLACEHOLDER : 'placeholder for backward compatibility',
    SIG_SUB_TYPE_PREF_SYMM_ALGO : 'preferred symmetric algorithms',
    SIG_SUB_TYPE_REVOKE_KEY : 'revocation key',
    SIG_SUB_TYPE_ISSUER_KEY_ID : 'issuer key ID',
    SIG_SUB_TYPE_NOTATION : 'notation data',
    SIG_SUB_TYPE_PREF_HASH_ALGO : 'preferred hash algorithms',
    SIG_SUB_TYPE_PREF_COMP_ALGO : 'preferred compression algorithms',
    SIG_SUB_TYPE_KEY_SRV_PREF : 'key server preferences',
    SIG_SUB_TYPE_PREF_KEY_SRVR : 'preferred key server',
    SIG_SUB_TYPE_PRIM_USER_ID : 'primary user id',
    SIG_SUB_TYPE_POLICY_URI : 'policy URI',
    SIG_SUB_TYPE_KEY_FLAGS : 'key flags',
    SIG_SUB_TYPE_SGNR_USER_ID : "signer's user id",
    SIG_SUB_TYPE_REVOKE_REASON : 'reason for revocation',
    SIG_SUB_TYPE_FEATURES : 'features',
    SIG_SUB_TYPE_SIG_TARGET : 'signature target',
    SIG_SUB_TYPE_EMBEDDED_SIG : 'embedded signature'
}

# in a signature subpacket there may be a revocation reason, these codes indicate
# the reason
REVOKE_REASON_NONE = 0              # No reason specified
REVOKE_REASON_SUPER = 0x01          # Key is superceded
REVOKE_REASON_COMPR = 0x02          # Key has been compromised
REVOKE_REASON_NOT_USED = 0x03       # Key is no longer used
REVOKE_REASON_ID_INVALID = 0x20     # user id information is no longer valid

revoke_reason_to_str = {
    REVOKE_REASON_NONE : 'No reason specified',
    REVOKE_REASON_SUPER : 'Key is superceded',
    REVOKE_REASON_COMPR : 'Key has been compromised',
    REVOKE_REASON_NOT_USED : 'Key is no longer used',
    REVOKE_REASON_ID_INVALID : 'user id information is no longer valid'
}

# These flags are used in a 'key flags' signature subpacket
KEY_FLAGS1_MAY_CERTIFY = 0x01 # This key may be used to certify other keys
KEY_FLAGS1_MAY_SIGN = 0x02 # This key may be used to sign data
KEY_FLAGS1_MAY_ENC_COMM = 0x04 # This key may be used to encrypt communications
KEY_FLAGS1_MAY_ENC_STRG = 0x08 # This key may be used to encrypt storage
KEY_FLAGS1_PRIV_MAYBE_SPLIT = 0x10 # Private component have be split through secret-sharing mech.
KEY_FLAGS1_GROUP = 0x80 # Private component may be among group

# A revocation key subpacket has these class values
REVOKE_KEY_CLASS_MAND = 0x80 # this bit must always be set
REVOKE_KEY_CLASS_SENS = 0x40 # sensitive

# Features may be indicated in a signature hashed subpacket
PGP_FEATURE_1_MOD_DETECT = 0x01 # Modification detection

pgp_feature_to_str = {
    PGP_FEATURE_1_MOD_DETECT : 'Modification Detection'
}

def get_whole_number(msg, idx, numlen) :
    """get_whole_number(msg, idx, numlen)
extracts a "whole number" field of length numlen from msg at index idx
returns (<whole number>, new_idx) where the whole number is a long integer
and new_idx is the index of the next element in the message"""
    n = 0L 
    while numlen > 0 :
        b = (struct.unpack("B", msg[idx:idx+1]))[0]
        n = n * 256L + long(b)
        idx = idx + 1
        numlen = numlen - 1
    return (n, idx)

def get_whole_int(msg, idx, numlen) :
    """get_whole_int(msg, idx, numlen)
same as get_whole_number but returns the number as an int for convenience"""
    n, idx = get_whole_number(msg, idx, numlen)
    return int(n), idx

def pack_long(l) :
    """pack_long(l)
    returns big-endian representation of unsigned long integer"""
    arr = []
    while l > 0 :
        arr.insert(0, struct.pack("B", l & 0xff))
        l >>= 8
    return ''.join(arr)
    
def pack_mpi(l) :
    """pack_mpi(l)
    returns the PGP Multi-Precision Integer representation of unsigned long integer"""
    s = pack_long(l)
    # the len is the number of bits, counting only from the MSB,
    # so we need to account for that
    bits = (len(s) - 1) * 8
    if len(s) > 0 :
        n = ord(s[0])
        while n != 0 :
            bits += 1
            n >>= 1
    else :
        bits = 0 # otherwise bits == -8
    return struct.pack(">H", bits) + s

def get_sig_subpak_len(msg, idx) :
    """get_sig_subpak_len(msg, idx)
extracts a signature subpacket length field
returns (subpak_len, new_idx)"""
    plen, idx = get_whole_int(msg, idx, 1)
    if plen < 192 :
        return plen, idx
    if plen < 255 :
        plen2, idx = get_whole_int(msg, idx, 1)
        return ((plen - 192) << 8) + plen2 + 192, idx
    return get_whole_int(msg, idx, 4)

def get_n_mpi(msg, idx) :
    """get_mpi(msg, idx)
    extracts a multi-precision integer field from the message msg at index idx
    returns (n, <mpi>, new_idx) where the mpi is a long integer and new_idx is
    the index of the next element in the message and n is the number of bits of
    precision in <mpi>"""
    ln, idx = get_whole_int(msg, idx, 2)
    return (ln,) + get_whole_number(msg, idx, (ln+7)/8)

def get_mpi(msg, idx) :
    """get_mpi(msg, idx)
extracts a multi-precision integer field from the message msg at index idx
returns (<mpi>, new_idx) where the mpi is a long integer and new_idx is
the index of the next element in the message"""
    l = get_n_mpi(msg, idx)
    return (l[1], l[2])

def str_to_hex(s) :
    return ''.join(map(lambda x : hex(ord(x))[2:].zfill(2), list(s)))

def duration_to_str(s) :
    if s == 0 :
        return 'never'
    secs = s % 60
    s = s / 60
    mins = s % 60
    s = s / 60
    hrs = s % 60
    s = s / 24
    days = s
    return '%d days %02d:%02d:%02d' % (days, hrs, mins, secs)

def map_to_str(m, vals) :
    slist = []
    # change to a list if it's a single value
    if type(vals) != types.ListType and type(vals) != types.TupleType :
        vals = list((vals,))
    for i in vals :
        if i in m :
            slist.append(m[i])
        else :
            slist.append('unknown(' + str(i) + ')')
    return ', '.join(slist)

class pgp_packet(object) :
    def __init__(self) :
        self.pkt_typ = None

    def __str__(self) :
        return map_to_str(ctb_pkt_to_str, self.pkt_typ)

class public_key(pgp_packet) :
    def __init__(self) :
        pgp_packet.__init__(self)
        self.version = None
        self.pk_algo = None
        self.key_size = 0
        self.fingerprint_ = None # we cache this upon calculation

    def fingerprint(self) :
        # return cached value if we have it
        if self.fingerprint_ :
            return self.fingerprint_
        
        # otherwise calculate it now and cache it
        # v3 and v4 are calculated differently
        if self.version == 3 :
            h = hashlib.new('md5')
            h.update(pack_long(self.pk_rsa_mod))
            h.update(pack_long(self.pk_rsa_exp))
            self.fingerprint_ = h.digest()
        elif self.version == 4 :
            # we hash what would be the whole PGP message containing
            # the pgp certificate
            h = hashlib.new('sha1')
            h.update('\x99')
            # we need to has the length of the packet as well
            buf = self.serialize()
            h.update(struct.pack(">H", len(buf)))
            h.update(buf)
            self.fingerprint_ = h.digest()
        else :
            raise RuntimeError("unknown public key version %d" % self.version)
        return self.fingerprint_

    def key_id(self) :
        if self.version == 3 :
            return pack_long(self.pk_rsa_mod & 0xffffffffffffffffL)
        elif self.version == 4 :
            return self.fingerprint()[-8:]

    def serialize(self) :
        chunks = []
        if self.version == 3 :
            chunks.append(struct.pack('>BIHB', self.version, int(self.timestamp), self.validity, self.pk_algo))
            chunks.append(pack_mpi(self.pk_rsa_mod))
            chunks.append(pack_mpi(self.pk_rsa_exp))
        elif self.version == 4 :
            chunks.append(struct.pack('>BIB', self.version, int(self.timestamp), self.pk_algo))
            if self.pk_algo == ALGO_PK_RSA_ENC_OR_SIGN or self.pk_algo == ALGO_PK_RSA_SIGN_ONLY :
                chunks.append(pack_mpi(self.pk_rsa_mod))
                chunks.append(pack_mpi(self.pk_rsa_exp))
            elif self.pk_algo == ALGO_PK_DSA :
                chunks.append(pack_mpi(self.pk_dsa_prime_p))
                chunks.append(pack_mpi(self.pk_dsa_grp_ord_q))
                chunks.append(pack_mpi(self.pk_dsa_grp_gen_g))
                chunks.append(pack_mpi(self.pk_dsa_pub_key))
            elif self.pk_algo == ALGO_PK_ELGAMAL_ENC_OR_SIGN or self.pk_algo == ALGO_PK_ELGAMAL_ENC_ONLY :
                chunks.append(pack_mpi(self.pk_elgamal_prime_p))
                chunks.append(pack_mpi(self.pk_elgamal_grp_gen_g))
                chunks.append(pack_mpi(self.pk_elgamal_pub_key))
            else :
                raise RuntimeError("unknown public key algorithm %d" % (self.pk_algo))
        return ''.join(chunks)
    
    def deserialize(self, msg, idx, pkt_len) :
        idx_save = idx
        self.version, idx = get_whole_int(msg, idx, 1)
        if self.version != 2 and self.version != 3 and self.version != 4 :
            raise RuntimeError('unknown public key packet version %d at %d' % (self.version, idx_save))
        if self.version == 2 : # map v2 into v3 for coding simplicity since they're structurally the same
            self.version = 3
        self.timestamp, idx = get_whole_number(msg, idx, 4)
        self.timestamp = float(self.timestamp)
        if self.version == 3 :
            self.validity, idx = get_whole_number(msg, idx, 2)
        self.pk_algo, idx = get_whole_int(msg, idx, 1)
        if self.pk_algo == ALGO_PK_RSA_ENC_OR_SIGN or self.pk_algo == ALGO_PK_RSA_SIGN_ONLY :
            self.key_size, self.pk_rsa_mod, idx = get_n_mpi(msg, idx)
            self.pk_rsa_exp, idx = get_mpi(msg, idx)
        elif self.pk_algo == ALGO_PK_DSA :
            l1, self.pk_dsa_prime_p, idx = get_n_mpi(msg, idx)
            self.pk_dsa_grp_ord_q, idx = get_mpi(msg, idx)
            self.pk_dsa_grp_gen_g, idx = get_mpi(msg, idx)
            l2, self.pk_dsa_pub_key, idx = get_n_mpi(msg, idx)
            self.key_size = l1 + l2
        elif self.pk_algo == ALGO_PK_ELGAMAL_ENC_OR_SIGN or self.pk_algo == ALGO_PK_ELGAMAL_ENC_ONLY :
            self.key_size, self.pk_elgamal_prime_p, idx = get_n_mpi(msg, idx)
            self.pk_elgamal_grp_gen_g, idx = get_mpi(msg, idx)
            self.pk_elgamal_pub_key, idx = get_mpi(msg, idx)
        else :
            raise RuntimeError("unknown public key algorithm %d at %d" % (self.pk_algo, idx_save))

    def __str__(self) :
        sio = cStringIO.StringIO()
        sio.write(pgp_packet.__str__(self) + "\n")
        sio.write("version: " + str(self.version) + "\n")
        sio.write("timestamp: " + time.ctime(self.timestamp) + "\n")
        if self.version == 3 :
            sio.write("validity: " + time.ctime(self.timestamp + self.validity * 24 * 60 * 60) + "\n")
        sio.write("pubkey algo: " + algo_pk_to_str[self.pk_algo] + "\n")
        if self.pk_algo == ALGO_PK_RSA_ENC_OR_SIGN or self.pk_algo == ALGO_PK_RSA_SIGN_ONLY :
            sio.write("pk_rsa_mod: " + hex(self.pk_rsa_mod) + "\n")
            sio.write("pk_rsa_exp: " + hex(self.pk_rsa_exp) + "\n")
        elif self.pk_algo == ALGO_PK_DSA :
            sio.write("pk_dsa_prime_p: " + hex(self.pk_dsa_prime_p) + "\n")
            sio.write("pk_dsa_grp_ord_q: " + hex(self.pk_dsa_grp_ord_q) + "\n")
            sio.write("pk_dsa_grp_gen_g: " + hex(self.pk_dsa_grp_gen_g) + "\n")
            sio.write("pk_dsa_pub_key: " + hex(self.pk_dsa_pub_key) + "\n")
        elif self.pk_algo == ALGO_PK_ELGAMAL_ENC_OR_SIGN or self.pk_algo == ALGO_PK_ELGAMAL_ENC_ONLY :
            sio.write("pk_elgamal_prime_p: " + hex(self.pk_elgamal_prime_p) + "\n")
            sio.write("pk_elgamal_grp_gen_g: " + hex(self.pk_elgamal_grp_gen_g) + "\n")
            sio.write("pk_elgamal_pub_key: " + hex(self.pk_elgamal_pub_key) + "\n")
        return sio.getvalue()

class user_id(pgp_packet) :
    def __init__(self) :
        pgp_packet.__init__(self)
        self.id = None

    def deserialize(self, msg, idx, pkt_len) :
        self.id = msg[idx:idx + pkt_len]

    def __str__(self) :
        return pgp_packet.__str__(self) + "\n" + "id: " + self.id + "\n"

class user_attribute(pgp_packet) :
    def __init__(self) :
        pgp_packet.__init__(self)
        self.sub_type = None
        self.data = None

    def deserialize(self, msg, idx, pkt_len) :
        self.sub_type, idx = get_whole_int(msg, idx, 1)
        pkt_len = pkt_len - 1
        self.data = msg[idx:idx + pkt_len]

    def __str__(self) :
        return pgp_packet.__str__(self) + "\n" + "sub_type: " + str(self.sub_type) + "\ndata: " + str_to_hex(self.data)

class signature(pgp_packet) :
    def __init__(self) :
        pgp_packet.__init__(self)
        self.version = None
        self.sig_type = None
        self.pk_algo = None
        self.hash_algo = None
        self.hash_frag = None

    def key_id(self) :
        if self.version == 3 :
            return self.key_id_
        else :
            i = self.get_hashed_subpak(SIG_SUB_TYPE_ISSUER_KEY_ID)
            if i :
                return i[1]
            i = self.get_unhashed_subpak(SIG_SUB_TYPE_ISSUER_KEY_ID)
            if i :
                return i[1]
            return None

    def creation_time(self) :
        if self.version == 3 :
            return self.timestamp
        else :
            i = self.get_hashed_subpak(SIG_SUB_TYPE_CREATE_TIME)
            return i[1]

    def expiration(self) :
        if self.version != 4 :
            raise ValueError('v3 signatures don\'t have expirations')
        i = self.get_hashed_subpak(SIG_SUB_TYPE_KEY_EXPIRE)
        if i :
            return i[1]
        return 0 # if not present then it never expires

    def get_hashed_subpak(self, typ) :
        for i in self.hashed_subpaks :
            if i[0] == typ :
                return i
        return None
    
    def get_unhashed_subpak(self, typ) :
        for i in self.unhashed_subpaks :
            if i[0] == typ :
                return i
        return None
    
    def deserialize_subpacket(self, msg, idx) :
        sublen, idx = get_sig_subpak_len(msg, idx)
        subtype, idx = get_whole_int(msg, idx, 1)
        if subtype == SIG_SUB_TYPE_CREATE_TIME : # key creation time
            tm, idx = get_whole_number(msg, idx, 4)
            return (subtype, float(tm)), idx
        if subtype == SIG_SUB_TYPE_EXPIRE_TIME or subtype == SIG_SUB_TYPE_KEY_EXPIRE :
            s, idx = get_whole_int(msg, idx, 4)
            return (subtype, s), idx
        if subtype == SIG_SUB_TYPE_EXPORT_CERT or subtype == SIG_SUB_TYPE_REVOCABLE :
            bool, idx = get_whole_int(msg, idx, 1)
            return (subtype, bool), idx
        if subtype == SIG_SUB_TYPE_TRUST_SIG : # trust signature
            trust_lvl, idx = get_whole_int(msg, idx, 1)
            trust_amt, idx = get_whole_int(msg, idx, 1)
            return (subtype, trust_lvl, trust_amt), idx
        if subtype == SIG_SUB_TYPE_REGEXP : # regular expression
            expr = msg[idx:idx+sublen-1]
            idx = idx + sublen - 1
            return (subtype, expr), idx
        if subtype == SIG_SUB_TYPE_PREF_SYMM_ALGO or subtype == SIG_SUB_TYPE_PREF_HASH_ALGO or subtype == SIG_SUB_TYPE_PREF_COMP_ALGO or subtype == SIG_SUB_TYPE_KEY_FLAGS :
            algo_list = map(lambda x : ord(x), list(msg[idx:idx+sublen-1]))
            idx = idx + sublen - 1
            return (subtype, algo_list), idx
        if subtype == SIG_SUB_TYPE_REVOKE_KEY : # revocation key
            cls, idx = get_whole_int(msg, idx, 1)
            algo, idx = get_whole_int(msg, idx, 1)
            fprint = msg[idx:idx+20]
            idx = idx + 20
            return (subtype, cls, algo, fprint), idx
        if subtype == SIG_SUB_TYPE_ISSUER_KEY_ID : # issuer key ID
            k_id = msg[idx:idx+8]
            idx = idx + 8
            return (subtype, k_id), idx
        if subtype == SIG_SUB_TYPE_NOTATION : # notation data
            flg1, idx = get_whole_int(msg, idx, 1)
            flg2, idx = get_whole_int(msg, idx, 1)
            flg3, idx = get_whole_int(msg, idx, 1)
            flg4, idx = get_whole_int(msg, idx, 1)
            name_len, idx = get_whole_int(msg, idx, 2)
            val_len, idx = get_whole_int(msg, idx, 2)
            nam = msg[idx:idx+name_len]
            idx = idx + name_len
            val = msg[idx:idx+val_len]
            idx = idx + val_len
            return (subtype, flg1, flg2, flg3, flg4, nam, val), idx
        if subtype == SIG_SUB_TYPE_KEY_SRV_PREF : # key server preferences
            prefs = [ ord(x) for x in msg[idx:idx+sublen-1] ]
            idx = idx + sublen - 1
            return (subtype, prefs), idx
        if subtype == SIG_SUB_TYPE_PREF_KEY_SRVR : # preferred key server
            url = msg[idx:idx+sublen-1]
            idx = idx + sublen - 1
            return (subtype, url), idx
        if subtype == SIG_SUB_TYPE_PRIM_USER_ID : # primary user id
            bool, idx = get_whole_int(msg, idx, 1)
            return (subtype, bool), idx
        if subtype == SIG_SUB_TYPE_POLICY_URI : # policy URI
            uri = msg[idx:idx+sublen-1]
            idx = idx + sublen - 1
            return (subtype, uri), idx
        if subtype == SIG_SUB_TYPE_SGNR_USER_ID : # signer's user id
            signer_id = msg[idx:idx+sublen-1]
            idx = idx + sublen - 1
            return (subtype, signer_id), idx
        if subtype == SIG_SUB_TYPE_REVOKE_REASON : # reason for revocation
            rev_code, idx = get_whole_int(msg, idx, 1)
            reas_len = sublen - 2
            reas = msg[idx:idx+reas_len]
            idx = idx + reas_len
            return (subtype, rev_code, reas), idx
        if subtype == SIG_SUB_TYPE_FEATURES : # features
            sublen = sublen - 1
            l = [subtype]
            while sublen > 0 :
                oct, idx = get_whole_int(msg, idx, 1)
                l.append(oct)
                sublen = sublen - 1
            return tuple(l), idx
        if subtype == SIG_SUB_TYPE_SIG_TARGET : # signature target
            public_key_algo, idx = get_whole_int(msg, idx, 1)
            hash_algo, idx = get_whole_int(msg, idx, 1)
            hash = msg[idx:idx+sublen-3]
            idx = idx + sublen - 3
            return (subtype, public_key_algo, hash_algo, hash), idx
        if subtype == SIG_SUB_TYPE_EMBEDDED_SIG : # embedded signature
            # don't do anything fancy, just the raw bits
            dat = msg[idx:idx+sublen-1]
            idx = idx + sublen - 1
            return (subtype, dat), idx

        # otherwise the subpacket is an unknown type, so we just pack the data in it
        dat = msg[idx:idx+sublen-1]
        idx = idx + sublen - 1
        return (subtype, dat), idx

    def is_primary_user_id(self) :
        """is_primary_user_id()
        returns true if this signature contains a primary user id subpacket with value true"""
        for i in self.hashed_subpaks :
            if i[0] == SIG_SUB_TYPE_PRIM_USER_ID :
                return i[1]
        return 0
    
    def subpacket_to_str(self, sp) :
        if sp[0] == SIG_SUB_TYPE_CREATE_TIME : # signature creation time
            return 'creation time: ' + time.ctime(sp[1])
        if sp[0] == SIG_SUB_TYPE_EXPIRE_TIME : # signature expiration time
            return 'signature expires: ' + duration_to_str(sp[1])
        if sp[0] == SIG_SUB_TYPE_EXPORT_CERT : # exportable certification
            if sp[1] :
                return 'signature exportable: TRUE'
            else :
                return 'signature exportable: FALSE'
        if sp[0] == SIG_SUB_TYPE_TRUST_SIG : # trust signature
            if sp[1] == 0 :
                return 'trust: ordinary'
            if sp[1] == 1 :
                return 'trust: introducer (%d)' % sp[2]
            if sp[1] == 2 :
                return 'trust: meta-introducer (%d)' % sp[2]
            return 'trust: %d %d' % (sp[1], sp[2])
        if sp[0] == SIG_SUB_TYPE_REGEXP : # regular expression
            return 'regexp: ' + sp[1]
        if sp[0] == SIG_SUB_TYPE_REVOCABLE : # revocable
            if sp[1] :
                return 'signature revocable: TRUE'
            else :
                return 'signature revocable: FALSE'
        if sp[0] == SIG_SUB_TYPE_KEY_EXPIRE : # key expiration time
            return 'key expires: ' + duration_to_str(sp[1])
        if sp[0] == SIG_SUB_TYPE_PREF_SYMM_ALGO : # preferred symmetric algorithms
            return 'preferred symmetric algorithms: ' + map_to_str(algo_sk_to_str, sp[1])
        if sp[0] == SIG_SUB_TYPE_REVOKE_KEY : # revocation key
            s = 'revocation key: '
            if sp[1] & REVOKE_KEY_CLASS_SENS :
                s = s + '(sensitive) '
            return s + map_to_str(algo_pk_to_str, sp[2]) + ' ' + str_to_hex(sp[3])
        if sp[0] == SIG_SUB_TYPE_ISSUER_KEY_ID : # issuer key ID
            return 'issuer key id: ' + str_to_hex(sp[1])
        if sp[0] == SIG_SUB_TYPE_NOTATION : # notation data
            return 'notation: flags(%d, %d, %d, %d) name(%s) value(%s)' % sp[1:]
        if sp[0] == SIG_SUB_TYPE_PREF_HASH_ALGO : # preferred hash algorithms
            return 'preferred hash algorithms: ' + map_to_str(algo_hash_to_str, sp[1])
        if sp[0] == SIG_SUB_TYPE_PREF_COMP_ALGO : # preferred compression algorithms
            return 'preferred compression algorithms: ' + map_to_str(algo_comp_to_str, sp[1])
        if sp[0] == SIG_SUB_TYPE_KEY_SRV_PREF : # key server preferences
            s = 'key server preferences: '
            prefs = []
            if sp[1][0] & 0x80 :
                prefs.append('No-modify')
            return s + ', '.join(prefs)
        if sp[0] == SIG_SUB_TYPE_PREF_KEY_SRVR : # preferred key server
            return 'preferred key server: %s' % sp[1]
        if sp[0] == SIG_SUB_TYPE_PRIM_USER_ID : # primary user id
            if sp[1] :
                return 'is primary user id'
            else :
                return 'is not primary user id'
        if sp[0] == SIG_SUB_TYPE_POLICY_URI : # policy URL
            return 'policy url: %s' % sp[1]
        if sp[0] == SIG_SUB_TYPE_KEY_FLAGS : # key flags
            flags = []
            flgs1 = 0
            if len(sp[1]) >= 1 :
                flgs1 = sp[1][0]
            if flgs1 & KEY_FLAGS1_MAY_CERTIFY :
                flags.append('may certify other keys')
            if flgs1 & KEY_FLAGS1_MAY_SIGN :
                flags.append('may sign data')
            if flgs1 & KEY_FLAGS1_MAY_ENC_COMM :
                flags.append('may encrypt communications')
            if flgs1 & KEY_FLAGS1_MAY_ENC_STRG :
                flags.append('may encrypt storage')
            if flgs1 & KEY_FLAGS1_PRIV_MAYBE_SPLIT :
                flags.append('private component may have been secret-sharing split')
            if flgs1 & KEY_FLAGS1_GROUP :
                flags.append('group key')
            return 'key flags: ' + ', '.join(flags)
        if sp[0] == SIG_SUB_TYPE_SGNR_USER_ID : # signer's user id
            return 'signer id: ' + sp[1]
        if sp[0] == SIG_SUB_TYPE_REVOKE_REASON : # reason for revocation
            reas = revoke_reason_to_str.get(sp[1], '')
            return 'reason for revocation: %s, %s' % (reas, sp[2])
        if sp[0] == SIG_SUB_TYPE_FEATURES : # features
            features = []
            if len(sp) > 1 :
                val = sp[1]
                if val & PGP_FEATURE_1_MOD_DETECT :
                    features.append('Modification Detection')
                val = val & ~PGP_FEATURE_1_MOD_DETECT
                if val != 0 :
                    features.append('[0]=0x%x' % val)
            for i in range(2, len(sp)) :
                features.append('[%d]=0x%x' % (i-1,sp[i]))
            return 'features: ' + ', '.join(features)
        # this means we don't know what the thing is so we just have raw data
        return 'unknown(%d): %s' % (sp[0], str_to_hex(sp[1]))

    def deserialize(self, msg, idx, pkt_len) :
        self.version, idx = get_whole_int(msg, idx, 1)
        if self.version == 2 :
            self.version = 3
        if self.version == 3 :
            hash_len, idx = get_whole_number(msg, idx, 1)
            self.sig_type, idx = get_whole_int(msg, idx, 1)
            self.timestamp, idx = get_whole_number(msg, idx, 4)
            self.timestamp = float(self.timestamp)
            self.key_id_ = msg[idx:idx+8]
            idx = idx + 8
            self.pk_algo, idx = get_whole_int(msg, idx, 1)
            self.hash_algo, idx = get_whole_int(msg, idx, 1)
        elif self.version == 4:
            self.sig_type, idx = get_whole_int(msg, idx, 1)
            self.pk_algo, idx = get_whole_int(msg, idx, 1)
            self.hash_algo, idx = get_whole_int(msg, idx, 1)
            sub_paks_len, idx = get_whole_int(msg, idx, 2)
            sub_paks_end = idx + sub_paks_len
            self.hashed_subpaks = []
            while idx < sub_paks_end :
                sp, idx = self.deserialize_subpacket(msg, idx)
                self.hashed_subpaks.append(sp)
            sub_paks_len, idx = get_whole_int(msg, idx, 2)
            sub_paks_end = idx + sub_paks_len
            self.unhashed_subpaks = []
            while idx < sub_paks_end :
                sp, idx = self.deserialize_subpacket(msg, idx)
                self.unhashed_subpaks.append(sp)
        else :
            raise RuntimeError('unknown signature packet version %d at %d' % (self.version, idx))
        self.hash_frag, idx = get_whole_number(msg, idx, 2)
        if self.pk_algo == ALGO_PK_RSA_ENC_OR_SIGN or self.pk_algo == ALGO_PK_RSA_SIGN_ONLY :
            self.rsa_sig, idx = get_mpi(msg, idx)
        elif self.pk_algo == ALGO_PK_DSA :
            self.dsa_sig_r, idx = get_mpi(msg, idx)
            self.dsa_sig_s, idx = get_mpi(msg, idx)
        else :
            raise RuntimeError('unknown public-key algorithm (%d) in signature at %d' % (self.pk_algo, idx))
        return idx

    def __str__(self) :
        sio = cStringIO.StringIO()
        sio.write(pgp_packet.__str__(self) + "\n")
        sio.write("version: " + str(self.version) + "\n")
        sio.write("type: " + sig_type_to_str[self.sig_type] + "\n")
        if self.version == 3 :
            sio.write("timestamp: " + time.ctime(self.timestamp) + "\n")
            sio.write("key_id: " + str_to_hex(self.key_id_) + "\n")
        elif self.version == 4 :
            sio.write("hashed subpackets:\n")
            for i in self.hashed_subpaks :
                sio.write("    " + self.subpacket_to_str(i) + "\n")
            sio.write("unhashed subpackets:\n")
            for i in self.unhashed_subpaks :
                sio.write("    " + self.subpacket_to_str(i) + "\n")
        sio.write("hash_algo: " + algo_hash_to_str[self.hash_algo] + "\n")
        sio.write("hash_frag: " + hex(self.hash_frag) + "\n")
        if self.pk_algo == ALGO_PK_RSA_ENC_OR_SIGN or self.pk_algo == ALGO_PK_RSA_SIGN_ONLY :
            sio.write("pk_algo: RSA\n")
            sio.write("rsa_sig: " + hex(self.rsa_sig) + "\n")
        elif self.pk_algo == ALGO_PK_DSA :
            sio.write("pk_algo: DSA\n")
            sio.write("dsa_sig_r: " + hex(self.dsa_sig_r) + "\n")
            sio.write("dsa_sig_s: " + hex(self.dsa_sig_s) + "\n")
        return sio.getvalue()

#
# This class encapsulates an openpgp public "certificate", which is formed in a message as
# a series of PGP packets of certain types in certain orders
#

class pgp_certificate(object):
    def __init__(self) :
        self.version = None
        self.public_key = None
        self.revocations = []
        self.user_ids = []
        self.primary_user_id = -1 # index of the primary user id

    def __str__(self) :
        sio = cStringIO.StringIO()
        sio.write("PGP Public Key Certificate v%d\n" % self.version)
        sio.write("Cert ID: %s\n" % str_to_hex(self.public_key.key_id()))
        sio.write("Primary ID: %s\n" % self.user_id)
        sio.write(str(self.public_key))
        for uid in self.user_ids :
            sio.write(str(uid[0]))
            for sig in uid[1:] :
                sio.write("   " + str(sig))
        if hasattr(self, 'user_attrs') :
            for uattr in self.user_attrs :
                sio.write(' ')
                sio.write(str(uattr[0]))
                for sig in uattr[1:] :
                    sio.write("   " + str(sig))
        return sio.getvalue()
    
    def get_user_id(self):
        # take the LAST one in the list, not first
        # they appear to be ordered FIFO from the key and that means if you
        # added a key later then it won't show the one you expect
        return self.user_ids[self.primary_user_id][0].id
        
    user_id = property(get_user_id)
    
    def expiration(self) :
        if self.version == 3 :
            if self.public_key.validity == 0 :
                return 0
            return self.public_key.timestamp + self.public_key.validity * 24 * 60 * 60
        else : # self.version == 4
            # this is a bit more complex, we need to find the signature on the
            # key and get its expiration
            u_id = self.user_ids[0]
            for i in u_id[1:] :
                if i.sig_type == SIG_TYPE_PK_USER_GEN :
                    exp = i.expiration()
                    if exp == 0 :
                        return 0
                    return self.public_key.timestamp + exp
            return 0

    def key_size(self) :
        return 0
    
    def load(self, pkts) :
        """load(pkts)
Initialize the pgp_certificate with a list of OpenPGP packets. The list of packets will
be scanned to make sure they are valid for a pgp certificate."""
        
        # each certificate should begin with a public key packet
        if pkts[0].pkt_typ != CTB_PKT_PK_CERT :
            raise ValueError('first PGP packet should be a public-key packet, not %s' % map_to_str(ctb_pkt_to_str, pkts[0].pkt_typ))

        # all versions have a public key although in a v4 cert the main key is only
        # used for signing, never encryption
        self.public_key = pkts[0]

        # ok, then what's the version
        self.version = self.public_key.version

        # now the behavior splits a little depending on the version
        if self.version == 3 :
            pkt_idx = 1

            # zero or more revocations
            while pkts[pkt_idx].pkt_typ == CTB_PKT_SIG :
                if pkts[pkt_idx].version != 3 :
                    raise ValueError('version 3 cert has version %d signature' % pkts[pkt_idx].version)
                if pkts[pkt_idx].sig_type != SIG_TYPE_KEY_REVOKE :
                    raise ValueError('v3 cert revocation sig has type %s' % map_to_str(sig_type_to_str, pkts[pkt_idx].sig_type))

                # ok, well at least the type is good, we'll assume the cert is
                # revoked
                self.revocations.append(pkts[pkt_idx])

                # increment the pkt_idx to go to the next one
                pkt_idx = pkt_idx + 1

            # the following packets are User ID, Signature pairs
            while pkt_idx < len(pkts) :
                # this packet is supposed to be a user id
                if pkts[pkt_idx].pkt_typ != CTB_PKT_USER_ID :
                    if len(self.user_ids) == 0 :
                        raise ValueError('pgp packet %d is not user id, is %s' % (pkt_idx, map_to_str(ctb_pkt_to_str, pkts[pkt_idx].pkt_typ)))
                    else :
                        break

                user_id = [pkts[pkt_idx]]
                pkt_idx = pkt_idx + 1
                is_revoked = 0
                is_primary_user_id = 0

                # there may be a sequence of signatures following the user id which
                # bind it to the key
                while pkt_idx < len(pkts) and pkts[pkt_idx].pkt_typ == CTB_PKT_SIG :
                    if pkts[pkt_idx].sig_type not in (SIG_TYPE_PK_USER_GEN, SIG_TYPE_PK_USER_PER, SIG_TYPE_PK_USER_CAS, SIG_TYPE_PK_USER_POS, SIG_TYPE_CERT_REVOKE) :
                        raise ValueError('signature %d doesn\'t bind user_id to key, is %s' % (pkt_idx, map_to_str(sig_type_to_str, pkts[pkt_idx].sig_typ)))

                    user_id.append(pkts[pkt_idx])

                    pkt_idx = pkt_idx + 1

                # append the user ID and signature(s) onto a list
                self.user_ids.append(user_id)

        else : # self.version == 4
            pkt_idx = 1
            self.direct_key_sigs = []
            self.subkeys = []
            self.rvkd_subkeys = []
            self.user_attrs = []

            cert_id = self.public_key.key_id()

            # second packet could be a revocation (or a direct key self signature)
            while pkt_idx < len(pkts) and pkts[pkt_idx].pkt_typ == CTB_PKT_SIG :
                if pkts[pkt_idx].version != 4 :
                    raise ValueError('version 4 cert has version %d signature' % pkts[pkt_idx].version)
                if pkts[pkt_idx].sig_type == SIG_TYPE_KEY_REVOKE :
                    self.revocations.append(pkts[pkt_idx])
                elif pkts[pkt_idx].sig_type == SIG_TYPE_KEY :
                    self.direct_key_sigs.append(pkts[pkt_idx])
                else :
                    raise ValueError('v4 cert signature has type %s, supposed to be revocation signature or direct key signature' % map_to_str(sig_type_to_str, pkts[pkt_idx].sig_type))

                # increment the pkt_idx to go to the next one
                pkt_idx = pkt_idx + 1
                
            # the following packets are:
            # User ID, signature... sets or
            # subkey, signature... sets or
            # user attribute, signature... sets
            prim_user_id_sig_time = 0

            while pkt_idx < len(pkts) :
                # this packet is supposed to be a user id
                if pkts[pkt_idx].pkt_typ == CTB_PKT_USER_ID :
                    user_id = [pkts[pkt_idx]]
                    is_revoked = 0
                    is_primary_user_id = 0

                    pkt_idx = pkt_idx + 1

                    # there may be a sequence of signatures following the user id which
                    # bind it to the key
                    while pkt_idx < len(pkts) and pkts[pkt_idx].pkt_typ == CTB_PKT_SIG :
                        if pkts[pkt_idx].sig_type not in (SIG_TYPE_PK_USER_GEN, SIG_TYPE_PK_USER_PER, SIG_TYPE_PK_USER_CAS, SIG_TYPE_PK_USER_POS, SIG_TYPE_CERT_REVOKE) :
                            raise ValueError('signature %d doesn\'t bind user_id to key, is %s' % (pkt_idx, map_to_str(sig_type_to_str, pkts[pkt_idx].sig_type)))
                        user_id.append(pkts[pkt_idx])

                        # is this the primary user id?
                        if pkts[pkt_idx].key_id() == cert_id :
                            if pkts[pkt_idx].is_primary_user_id() :
                                ct = pkts[pkt_idx].creation_time()
                                if ct > prim_user_id_sig_time :
                                    self.primary_user_id = len(self.user_ids)
                                    prim_user_id_sig_time = ct

                        pkt_idx = pkt_idx + 1

                    # append the user ID and signature(s) onto the list
                    self.user_ids.append(user_id)

                # this packet is supposed to be a user id
                elif pkts[pkt_idx].pkt_typ == CTB_PKT_USER_ATTR :
                    user_attr = [pkts[pkt_idx]]
                    is_revoked = 0

                    pkt_idx = pkt_idx + 1

                    # there may be a sequence of signatures following the user id which
                    # bind it to the key
                    while pkt_idx < len(pkts) and pkts[pkt_idx].pkt_typ == CTB_PKT_SIG :
                        if pkts[pkt_idx].sig_type not in (SIG_TYPE_PK_USER_GEN, SIG_TYPE_PK_USER_PER, SIG_TYPE_PK_USER_CAS, SIG_TYPE_PK_USER_POS, SIG_TYPE_CERT_REVOKE) :
                            raise ValueError('signature %d doesn\'t bind user_attr to key, is %s' % (pkt_idx, map_to_str(sig_type_to_str, pkts[pkt_idx].sig_type)))
                        user_attr.append(pkts[pkt_idx])
                        pkt_idx = pkt_idx + 1

                    # append the user ID and signature(s) onto the list
                    self.user_attrs.append(user_attr)

                elif pkts[pkt_idx].pkt_typ == CTB_PKT_PK_SUB :
                    # collect this list of subkey + signature [ + revocation ]
                    subkey = [pkts[pkt_idx]]
                    pkt_idx = pkt_idx + 1
                    is_revoked = 0

                    # there must be one signature following the subkey that binds it to the main key
                    if pkt_idx >= len(pkts) :
                        raise ValueError('subkey at index %d was not followed by a signature' % (pkt_idx-1))
                    if pkts[pkt_idx].pkt_typ != CTB_PKT_SIG or pkts[pkt_idx].sig_type != SIG_TYPE_SUBKEY_BIND :
                        raise ValueError('signature %d doesn\'t bind subkey to key, type is %s' % (pkt_idx, map_to_str(sig_type_to_str, pkts[pkt_idx].sig_typ)))
                    subkey.append(pkts[pkt_idx])

                    pkt_idx = pkt_idx + 1

                    # there may optionally be a revocation
                    if pkt_idx < len(pkts) and pkts[pkt_idx].pkt_typ == CTB_PKT_SIG and pkts[pkt_idx].sig_type == SIG_TYPE_SUBKEY_REVOKE :
                        is_revoked = 1
                        subkey.append(pkts[pkt_idx])
                        pkt_idx = pkt_idx + 1

                    # append the user ID and signature(s) onto the list
                    if is_revoked :
                        self.rvkd_subkeys.append(subkey)
                    else :
                        self.subkeys.append(subkey)
                else :
                    break

        # did we get all the things we needed?
        #if not self.user_id :
        # just take the first valid user id we encountered then
        if len(self.user_ids) == 0 :
            raise ValueError('no user id packet was present in the cert %s' % str_to_hex(self.public_key.key_id()))
        return pkt_idx


def get_ctb(msg, idx) :
    """get_ctb(msg, idx)
extracts a the "cypher type bit" information from message msg at index idx
returns (type, len, new_idx) where type is the enumerated type of the packet,
len is the length of the packet, and new_idx is the index of the next element
in the message"""
    b, idx = get_whole_int(msg, idx, 1)
    if (b & CTB_76_MASK) == CTB_76_NORMAL :
        n_len = 0 # undefined length
        if (b & CTB_PKT_LEN_MASK) == CTB_PKT_LEN_1 :
            n_len = 1
        if (b & CTB_PKT_LEN_MASK) == CTB_PKT_LEN_2 :
            n_len = 2
        if (b & CTB_PKT_LEN_MASK) == CTB_PKT_LEN_4 :
            n_len = 4
        if (b & CTB_PKT_LEN_MASK) == CTB_PKT_LEN_UNDEF :
            n_len = 0
        pkt_len = 0
        if n_len > 0 :
            pkt_len, idx = get_whole_int(msg, idx, n_len)
        return (b & CTB_PKTV2_MASK) >> 2, pkt_len, idx
    elif (b & CTB_76_MASK) == CTB_76_NEW :
        plen, idx = get_whole_int(msg, idx, 1)
        if plen < 192 :
            return b & CTB_PKT_MASK, plen, idx
        if plen < 224 :
            plen2, idx = get_whole_int(msg, idx, 1)
            return b & CTB_PKT_MASK, ((plen - 192) << 8) + plen2 + 192, idx
        if plen == 255 :
            plen, idx = get_whole_int(msg, idx, 4)
            return b & CTB_PKT_MASK, plen, idx
        else :
            raise Exception, 'partial message bodies are not supported by this version (%d)', b
    else :
        raise Exception, "unknown (not \"normal\") cypher type bit %d at byte %d" % (b, idx)

def crc24(msg) :
    crc24_init = 0xb704ce
    crc24_poly = 0x1864cfb

    crc = crc24_init
    for i in list(msg) :
        crc = crc ^ (ord(i) << 16)
        for j in range(0, 8) :
            crc = crc << 1
            if crc & 0x1000000 :
                crc = crc ^ crc24_poly
    return crc & 0xffffff

def decode(msg) :
    # each message is a sequence of packets so we go through the message
    # and generate a list of packets and return that
    pkt_list = []
    idx = 0
    msg_len = len(msg)
    while idx < msg_len :
        pkt_typ, pkt_len, idx = get_ctb(msg, idx)
        pkt = None
        if pkt_typ == CTB_PKT_PK_CERT or pkt_typ == CTB_PKT_PK_SUB :
            pkt = public_key()

        elif pkt_typ == CTB_PKT_USER_ID :
            pkt = user_id()

        elif pkt_typ == CTB_PKT_SIG :
            pkt = signature()

        elif pkt_typ == CTB_PKT_USER_ATTR :
            pkt = user_attribute()

        if pkt :
            pkt.pkt_typ = pkt_typ
            pkt.deserialize(msg, idx, pkt_len)
            if debug :
                debug.write(pkt.__str__() + "\n")
        else :
            raise ValueError('unexpected pgp packet type %s at %d' % (map_to_str(ctb_pkt_to_str, pkt_typ), idx))

        pkt_list.append(pkt)

        idx = idx + pkt_len
    return pkt_list

def decode_msg(msg, multi=False) :
    """decode_msg(msg) ==> list of OpenPGP "packet" objects
Takes an ascii-armored PGP block and returns a list of objects each of which
corresponds to a PGP "packets".

A PGP message is a series of packets. You need to understand how packets are
to be combined together in order to know what to do with them. For example
a PGP "certificate" includes a public key, user id(s), and signature. 
"""
    # first we'll break the block up into lines and trim each line of any 
    # carriage return chars
    pgpkey_lines = map(lambda x : x.rstrip(), msg.split('\n'))

    # check out block
    in_block = 0
    in_data = 0
    
    block_buf = cStringIO.StringIO()
    for l in pgpkey_lines :
        if not in_block :
            if l == '-----BEGIN PGP PUBLIC KEY BLOCK-----' :
                in_block = 1
            continue

        # are we at the actual data yet?
        if not in_data :
            if len(l) == 0 :
                in_data = 1
            continue
        
        # are we at the checksum line?
        if l and l[0] == '=' :
            # get the checksum number
            csum = base64.decodestring(l[1:5])
            i = 0
            csum, i = get_whole_number(csum, i, 3)

            # convert the base64 cert data to binary data
            cert_msg = base64.decodestring(block_buf.getvalue())
            block_buf.close()

            # check the checksum
            if csum != crc24(cert_msg) :
                raise Exception, 'bad checksum on pgp message'

            # ok, the sum looks ok so we'll actually decode the thing
            pkt_list = decode(cert_msg)

            # turn it into a real cert
            cert_list = []
            while len(pkt_list) > 0 :
                cert = pgp_certificate()
                cert.raw_key = msg
                pkt_idx = cert.load(pkt_list)
                cert_list.append(cert)
                pkt_list[0:pkt_idx] = []
            if not multi:
                if not cert_list:
                    return None
                return cert_list[0]
            return cert_list
        
        # add the data to our buffer then
        block_buf.write(l)

    if not multi:
        return None
    return []

def decode_multiple_keys(msg):
    #ditto of above - but handling multiple certs/keys per file
    certs = []

    pgpkey_lines = map(lambda x : x.rstrip(), msg.split('\n'))
    in_block = 0
    block = ''
    for l in pgpkey_lines :
        if not in_block :
            if l == '-----BEGIN PGP PUBLIC KEY BLOCK-----' :
                in_block = 1        
                block += '%s\n' % l
                continue

        block += '%s\n' % l
        if l == '-----END PGP PUBLIC KEY BLOCK-----':
            in_block = 0
            thesecerts = decode_msg(block, multi=True)
            if thesecerts:
                certs.extend(thesecerts)
            block = ''
            continue
    return certs


if __name__ == '__main__' :
    import sys
    for pgp_cert in decode_msg(open(sys.argv[1]).read()) :
        print pgp_cert
                                                                                                                                                                                                                                                                                                                                                                            usr/lib/python2.7/dist-packages/yum/pgpmsg.pyc                                                      0100644 0000000 0000000 00000114344 13077704344 017757  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   sb  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z y d  d l Z Wn< e k
 rä d  d l Z d  d l Z d f  d Ñ  É  YZ n Xe	 Z
 d Z d Z d Z d Z d Z d Z d	 Z d
 Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z  i d e 6d e 6d e 6d e 6d e 6d e 6d e 6d  e 6d! e 6d" e 6d# e 6d$ e 6d% e 6d& e 6d' e 6d( e 6d) e  6Z! d
 Z" d* Z# d Z$ d	 Z% d
 Z& d Z' d	 Z( d
 Z) d+ Z* d Z+ d Z, d Z- d, Z. d- Z/ i	 d. e' 6d/ e( 6d0 e) 6d1 e* 6d2 e+ 6d3 e, 6d4 e- 6d5 e. 6d6 e/ 6Z0 d* Z1 d Z2 d	 Z3 d
 Z4 d Z5 d Z6 d Z7 d Z8 d Z9 d Z: d Z; i d7 e1 6d8 e2 6d9 e3 6d: e4 6d; e5 6d< e6 6d= e7 6d> e8 6d? e9 6d@ e: 6dA e; 6Z< d* Z= d Z> d	 Z? d
 Z@ i dB e= 6dC e> 6dD e? 6dE e@ 6ZA d ZB d	 ZC d
 ZD d ZE d ZF d ZG d ZH d ZI d ZJ d ZK d ZL i dF eB 6dG eC 6dH eD 6dI eE 6dJ eF 6dK eG 6dL eH 6dM eI 6dN eJ 6dO eK 6dP eL 6ZM d* ZN d ZO d	 ZP d+ ZQ d ZR d ZS d ZT dQ ZU dR ZV dS ZW dT ZX dU ZY dV ZZ i dW eN 6dX eO 6dY eP 6dZ eQ 6d[ eR 6d\ eS 6d] eT 6d^ eU 6d_ eV 6d` eW 6da eX 6db eY 6dc eZ 6Z[ d	 Z\ d
 Z] d Z^ d Z_ d Z` d Za d Zb d Zc d Zd d Ze d+ Zf d, Zg d- Zh dd Zi de Zj dQ Zk df Zl dg Zm dh Zn di Zo dj Zp dk Zq dR Zr dS Zs i dl e\ 6dm e] 6dn e^ 6do e_ 6dp e` 6dq ea 6dr eb 6ds ec 6dt ed 6du ee 6dv ef 6dw eg 6dx eh 6dy ei 6dz ej 6d{ ek 6d| el 6d} em 6d~ en 6d eo 6dÄ ep 6dÅ eq 6dÇ er 6dÉ es 6Zt d* Zu d Zv d	 Zw d
 Zx dS Zy i dÑ eu 6dÖ ev 6dÜ ew 6dá ex 6dà ey 6Zz d Z{ d	 Z| d Z} d Z~ d+ Z d ZÄ d ZÅ dV ZÇ d ZÉ i dâ eÉ 6ZÑ dä Ñ  ZÖ dã Ñ  ZÜ då Ñ  Zá dç Ñ  Zà dé Ñ  Zâ dè Ñ  Zä dê Ñ  Zã dë Ñ  Zå dí Ñ  Zç dì Ñ  Zé dî eè f dï Ñ  É  YZê dñ eê f dó Ñ  É  YZë dò eê f dô Ñ  É  YZí dö eê f dõ Ñ  É  YZì dú eê f dù Ñ  É  YZî dû eè f dü Ñ  É  YZï d† Ñ  Zñ d° Ñ  Zó d¢ Ñ  Zò eô d£ Ñ Zö d§ Ñ  Zõ eú d• k r^d  d lù Zù x, eö eû eù jü d É j† É  É D] Z° e° GHqLWn  d S(¶   iˇˇˇˇNt   hashlibc           B   s   e  Z e d  Ñ  É Z RS(   c         C   s9   |  d k r t  j É  S|  d k r, t j É  St d Ç d  S(   Nt   md5t   sha1s   Bad checksum type(   R   t   newt   shat
   ValueError(   t   algo(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR   #   s
    

(   t   __name__t
   __module__t   staticmethodR   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR    !   s   iÄ   i¿   i<   i?   i   i   i   i   i   i   i   i   i	   i
   i   i   i   i   i   i   i   s#   public-key encrypted session packets   signature packets&   symmetric-key encrypted session packets   one-pass signature packets   secret-key certificate packets   public-key certificate packets   secret-key subkey packets   compressed data packets#   symmetric-key encrypted data packets   marker packets   literal data packets   trust packets   user id packets   public subkey packets   user attribute packets$   symmetric encrypted integrity packets"   modification detection code packeti    i   i   i   s   RSA (Encrypt or Sign)s   RSA Encrypt-Onlys   RSA Sign-Onlys   Elgamal Encrypt-Onlys    DSA (Digital Signature Standard)s   Elliptic Curvet   ECDSAs   Elgamal (Encrypt or Sign)s   Diffie-Hellmans   Plaintext or unencrypted datat   IDEAs
   Triple-DESt   CAST5t   Blowfishs   SAFER-SK128s   DES/SKs   AES 128-bits   AES 192-bits   AES 256-bits   Twofish 256-bitt   Uncompressedt   ZIPt   ZLIBt   BZip2t   MD5t   SHA1t	   RIPEMD160s   double-width SHAt   MD2t   TIGER192s   HAVAL-5-160t   SHA256t   SHA384t   SHA512t   SHA224i   i   i    i(   i0   i@   s    document signature, binary images"   document signature, canonical texts   signature over just subpacketss;   public key packet and user ID packet, generic certifications-   public key packet and user ID packet, personas:   public key packet and user ID packet, casual certifications<   public key packet and user ID packet, positive certifications   subkey bindings   key signatures   key revocations   subkey revocations   certificate revocationt	   timestampi   i   i   i   i   i   i   i   s   signature creation times   signature expiration times   exportable certifications   trust signatures   regular expressiont	   revocables   key expiration times&   placeholder for backward compatibilitys   preferred symmetric algorithmss   revocation keys   issuer key IDs   notation datas   preferred hash algorithmss    preferred compression algorithmss   key server preferencess   preferred key servers   primary user ids
   policy URIs	   key flagss   signer's user ids   reason for revocationt   featuress   signature targets   embedded signatures   No reason specifieds   Key is supercededs   Key has been compromiseds   Key is no longer useds&   user id information is no longer valids   Modification Detectionc         C   sl   d } xY | d k ra t  j d |  | | d !É d } | d t | É } | d } | d } q	 W| | f S(   s   get_whole_number(msg, idx, numlen)
extracts a "whole number" field of length numlen from msg at index idx
returns (<whole number>, new_idx) where the whole number is a long integer
and new_idx is the index of the next element in the messagel    i    t   Bi   l    (   t   structt   unpackt   long(   t   msgt   idxt   numlent   nt   b(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   get_whole_number:  s    !
c         C   s(   t  |  | | É \ } } t | É | f S(   si   get_whole_int(msg, idx, numlen)
same as get_whole_number but returns the number as an int for convenience(   R'   t   int(   R"   R#   R$   R%   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   get_whole_intG  s    c         C   sP   g  } x: |  d k rB | j  d t j d |  d @É É |  d L}  q	 Wd j | É S(   sK   pack_long(l)
    returns big-endian representation of unsigned long integeri    R   iˇ   i   t    (   t   insertR   t   packt   join(   t   lt   arr(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt	   pack_longM  s
     c         C   sÜ   t  |  É } t | É d d } t | É d k rl t | d É } x- | d k rh | d 7} | d L} qE Wn d } t j d | É | S(   s_   pack_mpi(l)
    returns the PGP Multi-Precision Integer representation of unsigned long integeri   i   i    s   >H(   R0   t   lent   ordR   R,   (   R.   t   st   bitsR%   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   pack_mpiV  s    
c         C   s|   t  |  | d É \ } } | d k  r. | | f S| d k  rl t  |  | d É \ } } | d d >| d | f St  |  | d É S(   sf   get_sig_subpak_len(msg, idx)
extracts a signature subpacket length field
returns (subpak_len, new_idx)i   i¿   iˇ   i   i   (   R)   (   R"   R#   t   plent   plen2(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   get_sig_subpak_lenf  s    
c         C   s7   t  |  | d É \ } } | f t |  | | d d É S(   s  get_mpi(msg, idx)
    extracts a multi-precision integer field from the message msg at index idx
    returns (n, <mpi>, new_idx) where the mpi is a long integer and new_idx is
    the index of the next element in the message and n is the number of bits of
    precision in <mpi>i   i   i   (   R)   R'   (   R"   R#   t   ln(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt	   get_n_mpir  s    c         C   s!   t  |  | É } | d | d f S(   s—   get_mpi(msg, idx)
extracts a multi-precision integer field from the message msg at index idx
returns (<mpi>, new_idx) where the mpi is a long integer and new_idx is
the index of the next element in the messagei   i   (   R:   (   R"   R#   R.   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   get_mpi{  s    c         C   s   d j  t d Ñ  t |  É É É S(   NR*   c         S   s   t  t |  É É d j d É S(   Ni   (   t   hexR2   t   zfill(   t   x(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   <lambda>Ñ  s    (   R-   t   mapt   list(   R3   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt
   str_to_hexÉ  s    c         C   sf   |  d k r d S|  d } |  d }  |  d } |  d }  |  d } |  d }  |  } d | | | | f S(   Ni    t   neveri<   i   s   %d days %02d:%02d:%02d(    (   R3   t   secst   minst   hrst   days(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   duration_to_strÜ  s    





c         C   sõ   g  } t  | É t j k rB t  | É t j k rB t | f É } n  xI | D]A } | |  k ro | j |  | É qI | j d t | É d É qI Wd j | É S(   Ns   unknown(t   )s   , (   t   typet   typest   ListTypet	   TupleTypeRA   t   appendt   strR-   (   t   mt   valst   slistt   i(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt
   map_to_strí  s    *t
   pgp_packetc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s   d  |  _ d  S(   N(   t   Nonet   pkt_typ(   t   self(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   __init__ü  s    c         C   s   t  t |  j É S(   N(   RT   t   ctb_pkt_to_strRW   (   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   __str__¢  s    (   R   R   RY   R[   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRU   û  s   	t
   public_keyc           B   s>   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s5   t  j |  É d  |  _ d  |  _ d |  _ d  |  _ d  S(   Ni    (   RU   RY   RV   t   versiont   pk_algot   key_sizet   fingerprint_(   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRY   ¶  s
    			c         C   s˚   |  j  r |  j  S|  j d k rl t j d É } | j t |  j É É | j t |  j É É | j É  |  _  nà |  j d k r· t j d É } | j d É |  j	 É  } | j t
 j d t | É É É | j | É | j É  |  _  n t d |  j É Ç |  j  S(   Ni   R   i   R   s   ôs   >Hs   unknown public key version %d(   R`   R]   R    R   t   updateR0   t
   pk_rsa_modt
   pk_rsa_expt   digestt	   serializeR   R,   R1   t   RuntimeError(   RX   t   ht   buf(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   fingerprint≠  s     	c         C   sA   |  j  d k r  t |  j d @É S|  j  d k r= |  j É  d Sd  S(   Ni   l   ˇˇˇˇ i   i¯ˇˇˇ(   R]   R0   Rb   Ri   (   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   key_id«  s    c         C   sÚ  g  } |  j  d k rx | j t j d |  j  t |  j É |  j |  j É É | j t |  j	 É É | j t |  j
 É É nm|  j  d k rÂ| j t j d |  j  t |  j É |  j É É |  j t k s” |  j t k r| j t |  j	 É É | j t |  j
 É É qÂ|  j t k rl| j t |  j É É | j t |  j É É | j t |  j É É | j t |  j É É qÂ|  j t k sä|  j t k rœ| j t |  j É É | j t |  j É É | j t |  j É É qÂt d |  j É Ç n  d j | É S(   Ni   s   >BIHBi   s   >BIBs   unknown public key algorithm %dR*   (   R]   RN   R   R,   R(   R   t   validityR^   R5   Rb   Rc   t   ALGO_PK_RSA_ENC_OR_SIGNt   ALGO_PK_RSA_SIGN_ONLYt   ALGO_PK_DSAt   pk_dsa_prime_pt   pk_dsa_grp_ord_qt   pk_dsa_grp_gen_gt   pk_dsa_pub_keyt   ALGO_PK_ELGAMAL_ENC_OR_SIGNt   ALGO_PK_ELGAMAL_ENC_ONLYt   pk_elgamal_prime_pt   pk_elgamal_grp_gen_gt   pk_elgamal_pub_keyRf   R-   (   RX   t   chunks(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRe   Õ  s*    4.c         C   sb  | } t  | | d É \ |  _ } |  j d k rj |  j d k rj |  j d k rj t d |  j | f É Ç n  |  j d k rÖ d |  _ n  t | | d É \ |  _ } t |  j É |  _ |  j d k rﬂ t | | d É \ |  _ } n  t  | | d É \ |  _ } |  j t k s|  j t	 k rQt
 | | É \ |  _ |  _ } t | | É \ |  _ } n|  j t k r÷t
 | | É \ } |  _ } t | | É \ |  _ } t | | É \ |  _ } t
 | | É \ } |  _ } | | |  _ nà |  j t k sÙ|  j t k rEt
 | | É \ |  _ |  _ } t | | É \ |  _ } t | | É \ |  _ } n t d |  j | f É Ç d  S(   Ni   i   i   i   s*   unknown public key packet version %d at %ds%   unknown public key algorithm %d at %d(   R)   R]   Rf   R'   R   t   floatRk   R^   Rl   Rm   R:   R_   Rb   R;   Rc   Rn   Ro   Rp   Rq   Rr   Rs   Rt   Ru   Rv   Rw   (   RX   R"   R#   t   pkt_lent   idx_savet   l1t   l2(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   deserializeÂ  s2    -c         C   s3  t  j É  } | j t j |  É d É | j d t |  j É d É | j d t j |  j	 É d É |  j d k r´ | j d t j |  j	 |  j
 d d d É d É n  | j d t |  j d É |  j t k sÂ |  j t k r$| j d	 t |  j É d É | j d
 t |  j É d É n|  j t k rÆ| j d t |  j É d É | j d t |  j É d É | j d t |  j É d É | j d t |  j É d É n{ |  j t k sÃ|  j t k r)| j d t |  j É d É | j d t |  j É d É | j d t |  j É d É n  | j É  S(   Ns   
s	   version: s   timestamp: i   s
   validity: i   i<   s   pubkey algo: s   pk_rsa_mod: s   pk_rsa_exp: s   pk_dsa_prime_p: s   pk_dsa_grp_ord_q: s   pk_dsa_grp_gen_g: s   pk_dsa_pub_key: s   pk_elgamal_prime_p: s   pk_elgamal_grp_gen_g: s   pk_elgamal_pub_key: (   t	   cStringIOt   StringIOt   writeRU   R[   RO   R]   t   timet   ctimeR   Rk   t   algo_pk_to_strR^   Rl   Rm   R<   Rb   Rc   Rn   Ro   Rp   Rq   Rr   Rs   Rt   Ru   Rv   Rw   t   getvalue(   RX   t   sio(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR[     s(    !7!!!(   R   R   RY   Ri   Rj   Re   R~   R[   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR\   •  s   					t   user_idc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   t  j |  É d  |  _ d  S(   N(   RU   RY   RV   t   id(   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRY     s    c         C   s   | | | | !|  _  d  S(   N(   Rà   (   RX   R"   R#   Rz   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR~     s    c         C   s    t  j |  É d d |  j d S(   Ns   
s   id: (   RU   R[   Rà   (   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR[     s    (   R   R   RY   R~   R[   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRá     s   		t   user_attributec           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s#   t  j |  É d  |  _ d  |  _ d  S(   N(   RU   RY   RV   t   sub_typet   data(   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRY   #  s    	c         C   s=   t  | | d É \ |  _ } | d } | | | | !|  _ d  S(   Ni   (   R)   Rä   Rã   (   RX   R"   R#   Rz   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR~   (  s    
c         C   s3   t  j |  É d d t |  j É d t |  j É S(   Ns   
s
   sub_type: s   
data: (   RU   R[   RO   Rä   RB   Rã   (   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR[   -  s    (   R   R   RY   R~   R[   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRâ   "  s   		t	   signaturec           B   sk   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z RS(   c         C   s>   t  j |  É d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   N(   RU   RY   RV   R]   t   sig_typeR^   t	   hash_algot	   hash_frag(   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRY   1  s    				c         C   sX   |  j  d k r |  j S|  j t É } | r3 | d S|  j t É } | rP | d Sd  Sd  S(   Ni   i   (   R]   t   key_id_t   get_hashed_subpakt   SIG_SUB_TYPE_ISSUER_KEY_IDt   get_unhashed_subpakRV   (   RX   RS   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRj   9  s    c         C   s1   |  j  d k r |  j S|  j t É } | d Sd  S(   Ni   i   (   R]   R   Rë   t   SIG_SUB_TYPE_CREATE_TIME(   RX   RS   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   creation_timeE  s    c         C   s?   |  j  d k r t d É Ç n  |  j t É } | r; | d Sd S(   Ni   s$   v3 signatures don't have expirationsi   i    (   R]   R   Rë   t   SIG_SUB_TYPE_KEY_EXPIRE(   RX   RS   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt
   expirationL  s    c         C   s,   x% |  j  D] } | d | k r
 | Sq
 Wd  S(   Ni    (   t   hashed_subpaksRV   (   RX   t   typRS   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRë   T  s    c         C   s,   x% |  j  D] } | d | k r
 | Sq
 Wd  S(   Ni    (   t   unhashed_subpaksRV   (   RX   Rô   RS   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRì   Z  s    c   &      C   s|  t  | | É \ } } t | | d É \ } } | t k rg t | | d É \ } } | t | É f | f S| t k s | t k rß t | | d É \ } } | | f | f S| t k sø | t k rÁ t | | d É \ } } | | f | f S| t	 k r6t | | d É \ } } t | | d É \ }	 } | | |	 f | f S| t
 k ru| | | | d !}
 | | d } | |
 f | f S| t k s•| t k s•| t k s•| t k rÍt d Ñ  t | | | | d !É É } | | d } | | f | f S| t k rWt | | d É \ } } t | | d É \ } } | | | d !} | d } | | | | f | f S| t k ré| | | d !} | d } | | f | f S| t k rt | | d É \ } } t | | d É \ } } t | | d É \ } } t | | d É \ } } t | | d É \ } } t | | d É \ } } | | | | !} | | } | | | | !} | | } | | | | | | | f | f S| t k r◊g  | | | | d !D] } t | É ^ q°} | | d } | | f | f S| t k r| | | | d !} | | d } | | f | f S| t k rJt | | d É \ } } | | f | f S| t k râ| | | | d !} | | d } | | f | f S| t k r»| | | | d !} | | d } | | f | f S| t k r$t | | d É \ } } | d } | | | | !} | | } | | | f | f S| t k rï| d } | g }  x? | d k rÑt | | d É \ }! } |  j |! É | d } qFWt |  É | f S| t k r
t | | d É \ }" } t | | d É \ }# } | | | | d !}$ | | d } | |" |# |$ f | f S| t k rI| | | | d !}% | | d } | |% f | f S| | | | d !}% | | d } | |% f | f S(	   Ni   i   c         S   s
   t  |  É S(   N(   R2   (   R>   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR?   u  s    i   i   i   i    i   (    R8   R)   Rî   R'   Ry   t   SIG_SUB_TYPE_EXPIRE_TIMERñ   t   SIG_SUB_TYPE_EXPORT_CERTt   SIG_SUB_TYPE_REVOCABLEt   SIG_SUB_TYPE_TRUST_SIGt   SIG_SUB_TYPE_REGEXPt   SIG_SUB_TYPE_PREF_SYMM_ALGOt   SIG_SUB_TYPE_PREF_HASH_ALGOt   SIG_SUB_TYPE_PREF_COMP_ALGOt   SIG_SUB_TYPE_KEY_FLAGSR@   RA   t   SIG_SUB_TYPE_REVOKE_KEYRí   t   SIG_SUB_TYPE_NOTATIONt   SIG_SUB_TYPE_KEY_SRV_PREFR2   t   SIG_SUB_TYPE_PREF_KEY_SRVRt   SIG_SUB_TYPE_PRIM_USER_IDt   SIG_SUB_TYPE_POLICY_URIt   SIG_SUB_TYPE_SGNR_USER_IDt   SIG_SUB_TYPE_REVOKE_REASONt   SIG_SUB_TYPE_FEATURESRN   t   tuplet   SIG_SUB_TYPE_SIG_TARGETt   SIG_SUB_TYPE_EMBEDDED_SIG(&   RX   R"   R#   t   sublent   subtypet   tmR3   t   boolt	   trust_lvlt	   trust_amtt   exprt	   algo_listt   clsR   t   fprintt   k_idt   flg1t   flg2t   flg3t   flg4t   name_lent   val_lent   namt   valR>   t   prefst   urlt   urit	   signer_idt   rev_codet   reas_lent   reasR.   t   octt   public_key_algoRé   t   hasht   dat(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   deserialize_subpacket`  s∂    0'



.


	c         C   s0   x) |  j  D] } | d t k r
 | d Sq
 Wd S(   sp   is_primary_user_id()
        returns true if this signature contains a primary user id subpacket with value truei    i   (   Rò   R®   (   RX   RS   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   is_primary_user_id¿  s    c   
      C   s  | d t  k r% d t j | d É S| d t k rG d t | d É S| d t k rl | d re d Sd Sn  | d t k rﬁ | d d k rê d S| d d k r¨ d | d	 S| d d	 k r» d
 | d	 Sd | d | d	 f S| d t k r˙ d | d S| d t k r| d rd Sd Sn  | d t	 k rAd t | d É S| d t
 k rfd t t | d É S| d t k ræd } | d t @ró| d } n  | t t | d	 É d t | d É S| d t k r‡d t | d É S| d t k r¸d | d S| d t k r!d t t | d É S| d t k rFd t t | d É S| d t k rïd } g  } | d d d @rÑ| j d É n  | d j | É S| d t k r±d | d S| d t k r÷| d rœd Sd Sn  | d t k rÚd  | d S| d t k r‚g  } d } t | d É d k r5| d d } n  | t @rO| j d! É n  | t  @ri| j d" É n  | t! @rÉ| j d# É n  | t" @rù| j d$ É n  | t# @r∑| j d% É n  | t$ @r—| j d& É n  d' d j | É S| d t% k r˛d( | d S| d t& k r6t' j( | d d) É } d* | | d	 f S| d t) k r g  } t | É d k r∞| d } | t* @rÇ| j d+ É n  | t* @} | d k r∞| j d, | É q∞n  x< t+ d	 t | É É D]% }	 | j d- |	 d | |	 f É q∆Wd. d j | É Sd/ | d t | d É f S(0   Ni    s   creation time: i   s   signature expires: s   signature exportable: TRUEs   signature exportable: FALSEs   trust: ordinarys   trust: introducer (%d)i   s   trust: meta-introducer (%d)s   trust: %d %ds   regexp: s   signature revocable: TRUEs   signature revocable: FALSEs   key expires: s    preferred symmetric algorithms: s   revocation key: s   (sensitive) t    i   s   issuer key id: s2   notation: flags(%d, %d, %d, %d) name(%s) value(%s)s   preferred hash algorithms: s"   preferred compression algorithms: s   key server preferences: iÄ   s	   No-modifys   , s   preferred key server: %ss   is primary user ids   is not primary user ids   policy url: %ss   may certify other keyss   may sign datas   may encrypt communicationss   may encrypt storages4   private component may have been secret-sharing splits	   group keys   key flags: s   signer id: R*   s   reason for revocation: %s, %ss   Modification Detections   [0]=0x%xs	   [%d]=0x%xs
   features: s   unknown(%d): %s(,   Rî   RÇ   RÉ   Rõ   RH   Rú   Rû   Rü   Rù   Rñ   R†   RT   t   algo_sk_to_strR§   t   REVOKE_KEY_CLASS_SENSRÑ   RB   Rí   R•   R°   t   algo_hash_to_strR¢   t   algo_comp_to_strR¶   RN   R-   Rß   R®   R©   R£   R1   t   KEY_FLAGS1_MAY_CERTIFYt   KEY_FLAGS1_MAY_SIGNt   KEY_FLAGS1_MAY_ENC_COMMt   KEY_FLAGS1_MAY_ENC_STRGt   KEY_FLAGS1_PRIV_MAYBE_SPLITt   KEY_FLAGS1_GROUPR™   R´   t   revoke_reason_to_strt   getR¨   t   PGP_FEATURE_1_MOD_DETECTt   range(
   RX   t   spR3   R√   t   flagst   flgs1R…   R   R¬   RS   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   subpacket_to_str»  s≤    

'








#c         C   s˜  t  | | d É \ |  _ } |  j d k r6 d |  _ n  |  j d k r¸ t | | d É \ } } t  | | d É \ |  _ } t | | d É \ |  _ } t |  j É |  _ | | | d !|  _ | d } t  | | d É \ |  _ } t  | | d É \ |  _ } nH|  j d k r+t  | | d É \ |  _ } t  | | d É \ |  _ } t  | | d É \ |  _ } t  | | d É \ } } | | } g  |  _	 x8 | | k  r¡|  j
 | | É \ } } |  j	 j | É qäWt  | | d É \ } } | | } g  |  _ xT | | k  r'|  j
 | | É \ } } |  j j | É qWn t d |  j | f É Ç t | | d É \ |  _ } |  j t k s}|  j t k ròt | | É \ |  _ } n[ |  j t k r⁄t | | É \ |  _ } t | | É \ |  _ } n t d |  j | f É Ç | S(   Ni   i   i   i   i   s)   unknown signature packet version %d at %ds4   unknown public-key algorithm (%d) in signature at %d(   R)   R]   R'   Rç   R   Ry   Rê   R^   Ré   Rò   RŒ   RN   Rö   Rf   Rè   Rl   Rm   R;   t   rsa_sigRn   t	   dsa_sig_rt	   dsa_sig_s(   RX   R"   R#   Rz   t   hash_lent   sub_paks_lent   sub_paks_endRﬂ   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR~   '  sJ    

	
	c         C   s,  t  j É  } | j t j |  É d É | j d t |  j É d É | j d t |  j d É |  j d k r± | j d t	 j
 |  j É d É | j d t |  j É d É nê |  j d k rA| j d É x/ |  j D]$ } | j d	 |  j | É d É q◊ W| j d
 É x2 |  j D]$ } | j d	 |  j | É d É qWn  | j d t |  j d É | j d t |  j É d É |  j t k sô|  j t k r«| j d É | j d t |  j É d É n[ |  j t k r"| j d É | j d t |  j É d É | j d t |  j É d É n  | j É  S(   Ns   
s	   version: s   type: i   s   timestamp: s   key_id: i   s   hashed subpackets:
s       s   unhashed subpackets:
s   hash_algo: s   hash_frag: s   pk_algo: RSA
s	   rsa_sig: s   pk_algo: DSA
s   dsa_sig_r: s   dsa_sig_s: (   R   RÄ   RÅ   RU   R[   RO   R]   t   sig_type_to_strRç   RÇ   RÉ   R   RB   Rê   Rò   R‚   Rö   R”   Ré   R<   Rè   R^   Rl   Rm   R„   Rn   R‰   RÂ   RÖ   (   RX   RÜ   RS   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR[   P  s0    !!"%!!(   R   R   RY   Rj   Rï   Ró   Rë   Rì   RŒ   Rœ   R‚   R~   R[   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRå   0  s   							`		_	)t   pgp_certificatec           B   sJ   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z e e É Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   c         C   s1   d  |  _ d  |  _ g  |  _ g  |  _ d |  _ d  S(   Niˇˇˇˇ(   RV   R]   R\   t   revocationst   user_idst   primary_user_id(   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRY   p  s
    				c         C   sA  t  j É  } | j d |  j É | j d t |  j j É  É É | j d |  j É | j t |  j É É xT |  j	 D]I } | j t | d É É x) | d D] } | j d t | É É qú Wqt Wt
 |  d É r7xd |  j D]V } | j d É | j t | d É É x) | d D] } | j d t | É É qWq⁄ Wn  | j É  S(	   Ns   PGP Public Key Certificate v%d
s   Cert ID: %s
s   Primary ID: %s
i    i   s      t
   user_attrsR–   (   R   RÄ   RÅ   R]   RB   R\   Rj   Rá   RO   RÏ   t   hasattrRÓ   RÖ   (   RX   RÜ   t   uidt   sigt   uattr(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR[   w  s      "c         C   s   |  j  |  j d j S(   Ni    (   RÏ   RÌ   Rà   (   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   get_user_idâ  s    c         C   s®   |  j  d k rE |  j j d k r% d S|  j j |  j j d d d S|  j d } xK | d D]? } | j t k r] | j É  } | d k ré d S|  j j | Sq] Wd Sd  S(   Ni   i    i   i<   i   (   R]   R\   Rk   R   RÏ   Rç   t   SIG_TYPE_PK_USER_GENRó   (   RX   t   u_idRS   t   exp(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRó   ë  s     c         C   s   d S(   Ni    (    (   RX   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR_   ¢  s    c         C   s  | d j  t k r6 t d t t | d j  É É Ç n  | d |  _ |  j j |  _ |  j d k r8d } xò | | j  t k r| | j d k r™ t d | | j É Ç n  | | j t	 k r‡ t d t t
 | | j É É Ç n  |  j j | | É | d } qj Wx¡| t | É k  r4| | j  t k rlt |  j É d k rht d | t t | | j  É f É Ç qlPn  | | g } | d } d } d } xè | t | É k  r | | j  t k r | | j t t t t t f k rt d | t t
 | | j É f É Ç n  | j | | É | d } qíW|  j j | É qWnéd } g  |  _ g  |  _ g  |  _ g  |  _ |  j j É  } x‘ | t | É k  rG| | j  t k rG| | j d	 k r∆t d
 | | j É Ç n  | | j t	 k r|  j j | | É nJ | | j t k r|  j j | | É n  t d t t
 | | j É É Ç | d } qtWd } xu| t | É k  r≈| | j  t k r°| | g } d } d } | d } xÚ | t | É k  rç| | j  t k rç| | j t t t t t f k rt d | t t
 | | j É f É Ç n  | j | | É | | j É  | k rÄ| | j É  rÄ| | j É  } | | k r}t |  j É |  _ | } q}qÄn  | d } qúW|  j j | É qQ| | j  t k rv| | g }	 d } | d } xè | t | É k  rb| | j  t k rb| | j t t t t t f k rDt d | t t
 | | j É f É Ç n  |	 j | | É | d } q‘W|  j j |	 É qQ| | j  t  k r¡| | g }
 | d } d } | t | É k rœt d | d É Ç n  | | j  t k sı| | j t! k rt d | t t
 | | j É f É Ç n  |
 j | | É | d } | t | É k  rï| | j  t k rï| | j t" k rïd } |
 j | | É | d } n  | rÆ|  j j |
 É q¬|  j j |
 É qQPqQWt |  j É d k r˝t d t# |  j j É  É É Ç n  | S(   s†   load(pkts)
Initialize the pgp_certificate with a list of OpenPGP packets. The list of packets will
be scanned to make sure they are valid for a pgp certificate.i    s6   first PGP packet should be a public-key packet, not %si   i   s'   version 3 cert has version %d signatures"   v3 cert revocation sig has type %ss#   pgp packet %d is not user id, is %ss/   signature %d doesn't bind user_id to key, is %si   s'   version 4 cert has version %d signaturesZ   v4 cert signature has type %s, supposed to be revocation signature or direct key signatures1   signature %d doesn't bind user_attr to key, is %ss2   subkey at index %d was not followed by a signatures3   signature %d doesn't bind subkey to key, type is %ss,   no user id packet was present in the cert %s($   RW   t   CTB_PKT_PK_CERTR   RT   RZ   R\   R]   t   CTB_PKT_SIGRç   t   SIG_TYPE_KEY_REVOKERÈ   RÎ   RN   R1   t   CTB_PKT_USER_IDRÏ   RÙ   t   SIG_TYPE_PK_USER_PERt   SIG_TYPE_PK_USER_CASt   SIG_TYPE_PK_USER_POSt   SIG_TYPE_CERT_REVOKEt   sig_typt   direct_key_sigst   subkeyst   rvkd_subkeysRÓ   Rj   t   SIG_TYPE_KEYRœ   Rï   RÌ   t   CTB_PKT_USER_ATTRt   CTB_PKT_PK_SUBt   SIG_TYPE_SUBKEY_BINDt   SIG_TYPE_SUBKEY_REVOKERB   (   RX   t   pktst   pkt_idxRá   t
   is_revokedRœ   t   cert_idt   prim_user_id_sig_timet   ctt	   user_attrt   subkey(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   load•  s∫    ##)
(")				( 
(")
(")
&)
8"(
   R   R   RY   R[   RÛ   t   propertyRá   Ró   R_   R  (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyRÍ   o  s   					c         C   sπ  t  |  | d É \ } } | t @t k r‘ d } | t @t k rG d } n  | t @t k r` d } n  | t @t k ry d } n  | t @t k rí d } n  d } | d k rø t  |  | | É \ } } n  | t @d ?| | f S| t @t	 k r¢t  |  | d É \ } } | d k  r| t
 @| | f S| d k  r^t  |  | d É \ } } | t
 @| d d >| d | f S| d k rìt  |  | d É \ } } | t
 @| | f St d	 | Ç n t d
 | | f Ç d S(   s  get_ctb(msg, idx)
extracts a the "cypher type bit" information from message msg at index idx
returns (type, len, new_idx) where type is the enumerated type of the packet,
len is the length of the packet, and new_idx is the index of the next element
in the messagei   i    i   i   i¿   i‡   i   iˇ   s=   partial message bodies are not supported by this version (%d)s4   unknown (not "normal") cypher type bit %d at byte %dN(   R)   t   CTB_76_MASKt   CTB_76_NORMALt   CTB_PKT_LEN_MASKt   CTB_PKT_LEN_1t   CTB_PKT_LEN_2t   CTB_PKT_LEN_4t   CTB_PKT_LEN_UNDEFt   CTB_PKTV2_MASKt
   CTB_76_NEWt   CTB_PKT_MASKt	   Exception(   R"   R#   R&   t   n_lenRz   R6   R7   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   get_ctbS  s6    				!c         C   sÄ   d } d } | } xc t  |  É D]U } | t | É d >A} x8 t d d É D]' } | d >} | d @rI | | A} qI qI Wq W| d @S(	   NiŒ∑ i˚LÜi   i    i   i   i   iˇˇˇ (   RA   R2   Rﬁ   (   R"   t
   crc24_initt
   crc24_polyt   crcRS   t   j(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   crc24w  s    

c         C   s4  g  } d } t  |  É } x| | k  r/t |  | É \ } } } d  } | t k s] | t k ri t É  } nH | t k rÅ t É  } n0 | t k rô t	 É  } n | t
 k r± t É  } n  | rˆ | | _ | j |  | | É t rt j | j É  d É qn t d t t | É | f É Ç | j | É | | } q W| S(   Ni    s   
s#   unexpected pgp packet type %s at %d(   R1   R  RV   R˜   R  R\   R˙   Rá   R¯   Rå   R  Râ   RW   R~   t   debugRÅ   R[   R   RT   RZ   RN   (   R"   t   pkt_listR#   t   msg_lenRW   Rz   t   pkt(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   decodeÑ  s.    	c         C   s∞  t  d Ñ  |  j d É É } d } d } t j É  } xl| D]d} | sa | d k r: d } q: q: n  | sà t | É d k r: d } q: q: n  | rë| d d k rët j | d d !É } d } t | | d É \ } } t j | j É  É }	 | j	 É  | t
 |	 É k rt d	 Ç n  t |	 É }
 g  } xQ t |
 É d k rtt É  } |  | _ | j |
 É } | j | É g  |
 d | +q$W| sç| sÖd
 S| d S| S| j | É q: W| s¨d
 Sg  S(   sÇ  decode_msg(msg) ==> list of OpenPGP "packet" objects
Takes an ascii-armored PGP block and returns a list of objects each of which
corresponds to a PGP "packets".

A PGP message is a series of packets. You need to understand how packets are
to be combined together in order to know what to do with them. For example
a PGP "certificate" includes a public key, user id(s), and signature. 
c         S   s
   |  j  É  S(   N(   t   rstrip(   R>   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR?   ±  s    s   
i    s$   -----BEGIN PGP PUBLIC KEY BLOCK-----i   t   =i   i   s   bad checksum on pgp messageN(   R@   t   splitR   RÄ   R1   t   base64t   decodestringR'   RÖ   t   closeR#  R  R(  RÍ   t   raw_keyR  RN   RV   RÅ   (   R"   t   multit   pgpkey_linest   in_blockt   in_datat	   block_bufR.   t   csumRS   t   cert_msgR%  t	   cert_listt   certR	  (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt
   decode_msg¶  sL    		
		c         C   s≈   g  } t  d Ñ  |  j d É É } d } d } xë | D]â } | si | d k ri d } | d | 7} q4 qi n  | d | 7} | d k r4 d } t | d	 t É} | r± | j | É n  d } q4 q4 q4 W| S(
   Nc         S   s
   |  j  É  S(   N(   R)  (   R>   (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyR?   Ô  s    s   
i    R*   s$   -----BEGIN PGP PUBLIC KEY BLOCK-----i   s   %s
s"   -----END PGP PUBLIC KEY BLOCK-----R0  (   R@   R+  R9  t   Truet   extend(   R"   t   certsR1  R2  t   blockR.   t
   thesecerts(    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   decode_multiple_keysÎ  s&    	
t   __main__(¢   R   RÇ   R   R,  RK   R    t   ImportErrorR   R   RV   R$  R  R  R  R  R  t   CTB_PKT_PK_ENCR¯   t   CTB_PKT_SK_ENCt   CTB_PKT_OP_SIGt   CTB_PKT_SK_CERTR˜   t   CTB_PKT_SK_SUBt   CTB_PKT_COMPRESSEDt   CTB_PKT_ENCt   CTB_PKT_MARKERt   CTB_PKT_LITt   CTB_PKT_TRUSTR˙   R  R  t   CTB_PKT_SYM_ENC_INTt   CTB_PKT_MOD_DETECTRZ   R  R  R  R  R  Rl   t   ALGO_PK_RSA_ENC_ONLYRm   Rt   Rn   t   ALGO_PK_ELLIPTIC_CURVEt   ALGO_PK_ECDSARs   t
   ALGO_PK_DHRÑ   t   ALGO_SK_PLAINt   ALGO_SK_IDEAt   ALGO_SK_3DESt   ALGO_SK_CAST5t   ALGO_SK_BLOWFISHt   ALGO_SK_SAFER_SK128t   ALGO_SK_DES_SKt   ALGO_SK_AES_128t   ALGO_SK_AES_192t   ALGO_SK_AES_256t   ALGO_SK_TWOFISH_256R—   t   ALGO_COMP_UNCOMPt   ALGO_COMP_ZIPt   ALGO_COMP_ZLIBt   ALGO_COMP_BZIP2R‘   t   ALGO_HASH_MD5t   ALGO_HASH_SHA1t   ALGO_HASH_RIPEMD160t   ALGO_HASH_SHA_DBLt   ALGO_HASH_MD2t   ALGO_HASH_TIGER192t   ALGO_HASH_HAVAL_5_160t   ALGO_HASH_SHA256t   ALGO_HASH_SHA384t   ALGO_HASH_SHA512t   ALGO_HASH_SHA224R”   t   SIG_TYPE_DOCUMENTt   SIG_TYPE_DOCUMENT_CANONt   SIG_TYPE_STANDALONERÙ   R˚   R¸   R˝   R  R  R˘   R  R˛   t   SIG_TYPE_TIMESTAMPRÈ   Rî   Rõ   Rú   Rû   Rü   Rù   Rñ   t   SIG_SUB_TYPE_PLACEHOLDERR†   R§   Rí   R•   R°   R¢   R¶   Rß   R®   R©   R£   R™   R´   R¨   RÆ   RØ   t   sig_sub_type_to_strt   REVOKE_REASON_NONEt   REVOKE_REASON_SUPERt   REVOKE_REASON_COMPRt   REVOKE_REASON_NOT_USEDt   REVOKE_REASON_ID_INVALIDR€   R’   R÷   R◊   Rÿ   RŸ   R⁄   t   REVOKE_KEY_CLASS_MANDR“   R›   t   pgp_feature_to_strR'   R)   R0   R5   R8   R:   R;   RB   RH   RT   t   objectRU   R\   Rá   Râ   Rå   RÍ   R  R#  R(  t   FalseR9  R?  R   t   syst   opent   argvt   readt   pgp_cert(    (    (    s.   /usr/lib/python2.7/dist-packages/yum/pgpmsg.pyt   <module>   sÙ  <










												rˇ @‰	$		"E	&                                                                                                                                                                                                                                                                                            usr/lib/python2.7/dist-packages/yum/pkgtag_db.py                                                    0100644 0000000 0000000 00000011533 12451005146 020222  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2009 Red Hat, Inc
# written by seth vidal

# parse sqlite tag database
# return pkgnames and tag that was matched
from sqlutils import sqlite, executeSQL, sql_esc
from Errors import PkgTagsError
import sqlutils
import sys
import misc

def catchSqliteException(func):
    """This decorator converts sqlite exceptions into PkgTagsError"""
    def newFunc(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except sqlutils.sqlite.Error, e:
            # 2.4.x requires this, but 2.6.x complains about even hasattr()
            # of e.message ... *sigh*
            if sys.hexversion < 0x02050000:
                if hasattr(e,'message'):
                    raise PkgTagsError, str(e.message)
                else:
                    raise PkgTagsError, str(e)
            raise PkgTagsError, str(e)

    newFunc.__name__ = func.__name__
    newFunc.__doc__ = func.__doc__
    newFunc.__dict__.update(func.__dict__)
    return newFunc



class PackageTagDB(object):
    def __init__(self, repoid, sqlite_file):
        self.sqlite_file = sqlite_file
        self.repoid = repoid
        # take a path to the sqlite tag db
        # open it and leave a cursor in place for the db
        self._conn = sqlite.connect(sqlite_file)
        self.cur = self._conn.cursor()

    def _getTagsCount(self):
        ''' Unused, so no need to cache. '''
        for n in self._sql_exec("select count(*) from packagetags",):
            return n[0]

    count = property(fget=lambda self: self._getTagsCount(),
                     doc="Number of entries in the pkgtag DB")
        
    @catchSqliteException
    def _sql_exec(self, sql, *args):
        """ Exec SQL against an MD of the repo, return a cursor. """
        
        executeSQL(self.cur, sql, *args)
        return self.cur
    
    def search_tags(self, tag):
        """Search by tag name/glob
           Return dict of dict[packagename] = [stringmatched, stringmatched, ...]"""
        res = {}
        (tag, esc) = sql_esc(tag)
        query = "SELECT name, tag, score FROM packagetags where tag like ? %s" % esc
        tag = '%' + tag + '%' 
        rows = self._sql_exec(query, (tag,))
        for (name, tag, score) in rows:
            if name not in res:
                res[name] = []
            res[name].append(tag)
            
        return res
        
    def search_names(self, name):
        """Search by package name/glob.
           Return dict of dict[packagename] = [tag1, tag2, tag3, tag4, ...]"""
        res = {}
        (name, esc) = sql_esc(name)
        query = "SELECT name, tag, score FROM packagetags where name like ?%s " % esc
        name = '%' + name + '%' 
        rows = self._sql_exec(query, (name,))
        for (name, tag, score) in rows:
            if name not in res:
                res[name] = []
            res[name].append(tag)

        return res

class PackageTags(object):
    def __init__(self):
        self.db_objs = {}
        
    def add(self, repoid, sqlite_file):
        if repoid in self.db_objs:
            raise PkgTagsError, "Already added tags from %s" % repoid
            
        dbobj = PackageTagDB(repoid, sqlite_file)
        self.db_objs[repoid] = dbobj

    def remove(self, repoid):
        if repoid in self.db_objs:
            del self.db_objs[repoid]
        else:
            raise PkgTagsError, "No tag db for %s" % repoid
    
    def search_names(self, name):
        res = {}
        for ptd in self.db_objs.values():
            for (name, taglist) in ptd.search_names(name).items():
                if not name in res:
                    res[name] = []
                res[name].extend(taglist)
        
        out = {}
        for (name, taglist) in res.items():
            out[name] = misc.unique(taglist)
        return out

    def search_tags(self, tagname):
        res = {}
        for ptd in self.db_objs.values():
            for (name, taglist) in ptd.search_tags(tagname).items():
                if not name in res:
                    res[name] = []
                res[name].extend(taglist)
        out = {}
        for (name, taglist) in res.items():
            out[name] = misc.unique(taglist)
        return out
        
                                                                                                                                                                     usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyc                                                   0100644 0000000 0000000 00000012070 13077704344 020375  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   sâ   d  d l  m Z m Z m Z d  d l m Z d  d l  Z  d  d l Z d  d l Z d Ñ  Z d e	 f d Ñ  É  YZ
 d e	 f d Ñ  É  YZ d S(	   iˇˇˇˇ(   t   sqlitet
   executeSQLt   sql_esc(   t   PkgTagsErrorNc            s>   á  f d Ü  } à  j  | _  à  j | _ | j j à  j É | S(   s;   This decorator converts sqlite exceptions into PkgTagsErrorc             sÖ   y à  |  | é  SWnm t  j j k
 rÄ } t j d k  rn t | d É r\ t t | j É Ç qn t t | É Ç n  t t | É Ç n Xd  S(   Ni  t   message(	   t   sqlutilsR    t   Errort   syst
   hexversiont   hasattrR   t   strR   (   t   argst   kwargst   e(   t   func(    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyt   newFunc   s    (   t   __name__t   __doc__t   __dict__t   update(   R   R   (    (   R   s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyt   catchSqliteException   s
    t   PackageTagDBc           B   sS   e  Z d  Ñ  Z d Ñ  Z e d d Ñ  d d É Z e d Ñ  É Z d Ñ  Z d Ñ  Z	 RS(	   c         C   s:   | |  _  | |  _ t j | É |  _ |  j j É  |  _ d  S(   N(   t   sqlite_filet   repoidR    t   connectt   _connt   cursort   cur(   t   selfR   R   (    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyt   __init__1   s    		c         C   s#   x |  j  d É D] } | d SWd S(   s    Unused, so no need to cache. s    select count(*) from packagetagsi    N(   t	   _sql_exec(   R   t   n(    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyt   _getTagsCount9   s    t   fgetc         C   s
   |  j  É  S(   N(   R    (   R   (    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyt   <lambda>>   s    t   docs"   Number of entries in the pkgtag DBc         G   s   t  |  j | | å |  j S(   s6    Exec SQL against an MD of the repo, return a cursor. (   R   R   (   R   t   sqlR   (    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyR   A   s    c         C   sç   i  } t  | É \ } } d | } d | d } |  j | | f É } xA | D]9 \ } } } | | k rt g  | | <n  | | j | É qL W| S(   si   Search by tag name/glob
           Return dict of dict[packagename] = [stringmatched, stringmatched, ...]s<   SELECT name, tag, score FROM packagetags where tag like ? %st   %(   R   R   t   append(   R   t   tagt   rest   esct   queryt   rowst   namet   score(    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyt   search_tagsH   s    
c         C   sç   i  } t  | É \ } } d | } d | d } |  j | | f É } xA | D]9 \ } } } | | k rt g  | | <n  | | j | É qL W| S(   sh   Search by package name/glob.
           Return dict of dict[packagename] = [tag1, tag2, tag3, tag4, ...]s=   SELECT name, tag, score FROM packagetags where name like ?%s R%   (   R   R   R&   (   R   R,   R(   R)   R*   R+   R'   R-   (    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyt   search_namesW   s    
(
   R   t
   __module__R   R    t   propertyt   countR   R   R.   R/   (    (    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyR   0   s   				t   PackageTagsc           B   s5   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   i  |  _  d  S(   N(   t   db_objs(   R   (    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyR   g   s    c         C   s?   | |  j  k r t d | Ç n  t | | É } | |  j  | <d  S(   Ns   Already added tags from %s(   R4   R   R   (   R   R   R   t   dbobj(    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyt   addj   s    c         C   s-   | |  j  k r |  j  | =n t d | Ç d  S(   Ns   No tag db for %s(   R4   R   (   R   R   (    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyt   removeq   s    c         C   s™   i  } xg |  j  j É  D]V } xM | j | É j É  D]6 \ } } | | k rW g  | | <n  | | j | É q2 Wq Wi  } x- | j É  D] \ } } t j | É | | <qÉ W| S(   N(   R4   t   valuesR/   t   itemst   extendt   misct   unique(   R   R,   R(   t   ptdt   taglistt   out(    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyR/   w   s    "c         C   s™   i  } xg |  j  j É  D]V } xM | j | É j É  D]6 \ } } | | k rW g  | | <n  | | j | É q2 Wq Wi  } x- | j É  D] \ } } t j | É | | <qÉ W| S(   N(   R4   R8   R.   R9   R:   R;   R<   (   R   t   tagnameR(   R=   R,   R>   R?   (    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyR.   Ñ   s    "(   R   R0   R   R6   R7   R/   R.   (    (    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyR3   f   s
   				(   R   R    R   R   t   ErrorsR   R   R;   R   t   objectR   R3   (    (    (    s1   /usr/lib/python2.7/dist-packages/yum/pkgtag_db.pyt   <module>   s   	6                                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/dist-packages/yum/plugins.py                                                      0100644 0000000 0000000 00000056312 12451005146 017765  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University

import os
import glob
import imp
import warnings
import atexit
import gettext
import logging
import logginglevels
from constants import *
import config 
from config import ParsingError, ConfigParser
import Errors
from parser import ConfigPreProcessor

from textwrap import fill
import fnmatch

from weakref import proxy as weakref

from yum import _

from yum.i18n import utf8_width

# TODO: expose rpm package sack objects to plugins (once finished)
# TODO: allow plugins to use the existing config stuff to define options for
# their own configuration files (would replace confString() etc).
# TODO: expose progress bar interface
# TODO "log" slot? To allow plugins to do customised logging/history (say to a
# SQL db)
# TODO: consistent case of YumPlugins methods
# TODO: allow plugins to extend shell commands
# TODO: allow plugins to define new repository types
# TODO: More developer docs:  use epydoc as API begins to stablise


# The API_VERSION constant defines the current plugin API version. It is used
# to decided whether or not plugins can be loaded. It is compared against the
# 'requires_api_version' attribute of each plugin. The version number has the
# format: "major_version.minor_version".
# 
# For a plugin to be loaded the major version required by the plugin must match
# the major version in API_VERSION. Additionally, the minor version in
# API_VERSION must be greater than or equal the minor version required by the
# plugin.
# 
# If a change to yum is made that break backwards compatibility wrt the plugin
# API, the major version number must be incremented and the minor version number
# reset to 0. If a change is made that doesn't break backwards compatibility,
# then the minor number must be incremented.
API_VERSION = '2.6'

class DeprecatedInt(int):
    '''
    A simple int subclass that used to check when a deprecated constant is used.
    '''

# Plugin types
TYPE_CORE = 0
TYPE_INTERACTIVE = 1
TYPE_INTERFACE = DeprecatedInt(1)
ALL_TYPES = (TYPE_CORE, TYPE_INTERACTIVE)

# Mapping of slots to conduit classes
SLOT_TO_CONDUIT = {
    'config': 'ConfigPluginConduit',
    'postconfig': 'PostConfigPluginConduit',
    'init': 'InitPluginConduit',
    'args': 'ArgsPluginConduit',
    'predownload': 'DownloadPluginConduit',
    'postdownload': 'DownloadPluginConduit',
    'prereposetup': 'PreRepoSetupPluginConduit',
    'postreposetup': 'PostRepoSetupPluginConduit',
    'close': 'PluginConduit',
    'clean': 'PluginConduit',
    'pretrans': 'MainPluginConduit',
    'posttrans': 'MainPluginConduit',
    'preverifytrans': 'MainPluginConduit',
    'postverifytrans': 'MainPluginConduit',
    'exclude': 'MainPluginConduit',
    'preresolve': 'DepsolvePluginConduit',
    'postresolve': 'DepsolvePluginConduit',
    'historybegin': 'HistoryPluginConduit',
    'historyend': 'HistoryPluginConduit',
    'compare_providers': 'CompareProvidersPluginConduit',
    'verify_package': 'VerifyPluginConduit',
    }

# Enumerate all slot names
SLOTS = sorted(SLOT_TO_CONDUIT.keys())

class PluginYumExit(Exception):
    '''Used by plugins to signal that yum should stop
    '''
    def __init__(self, value="", translation_domain=""):
        self.value = value
        self.translation_domain = translation_domain
    def __str__(self):
        if self.translation_domain:
            return gettext.dgettext(self.translation_domain, self.value)
        else:
            return self.value
    
class YumPlugins:
    '''
    Manager class for Yum plugins.
    '''

    def __init__(self, base, searchpath, optparser=None, types=None, 
            pluginconfpath=None,disabled=None,enabled=None):
        '''Initialise the instance.

        @param base: The
        @param searchpath: A list of paths to look for plugin modules.
        @param optparser: The OptionParser instance for this run (optional).
            Use to allow plugins to extend command line options.
        @param types: A sequence specifying the types of plugins to load.
            This should be sequnce containing one or more of the TYPE_...
            constants. If None (the default), all plugins will be loaded.
        @param pluginconfpath: A list of paths to look for plugin configuration
            files. Defaults to "/etc/yum/pluginconf.d".
        '''
        if not pluginconfpath:
            pluginconfpath = ['/etc/yum/pluginconf.d']

        self.searchpath = searchpath
        self.pluginconfpath = pluginconfpath
        self.base = weakref(base)
        self.optparser = optparser
        self.cmdline = (None, None)
        self.verbose_logger = logging.getLogger("yum.verbose.YumPlugins")
        self.disabledPlugins = disabled
        self.enabledPlugins  = enabled
        if types is None:
            types = ALL_TYPES
        if not isinstance(types, (list, tuple)):
            types = (types,)

        if id(TYPE_INTERFACE) in [id(t) for t in types]:
            self.verbose_logger.log(logginglevels.INFO_2,
                    'Deprecated constant TYPE_INTERFACE during plugin '
                    'initialization.\nPlease use TYPE_INTERACTIVE instead.')

        self._importplugins(types)

        self.cmdlines = {}

        # Call close handlers when yum exit's
        atexit.register(self.run, 'close')

        # Let plugins register custom config file options
        self.run('config')

    def run(self, slotname, **kwargs):
        '''Run all plugin functions for the given slot.
        '''
        # Determine handler class to use
        conduitcls = SLOT_TO_CONDUIT.get(slotname, None)
        if conduitcls is None:
            raise ValueError('unknown slot name "%s"' % slotname)
        conduitcls = eval(conduitcls)       # Convert name to class object

        for modname, func in self._pluginfuncs[slotname]:
            self.verbose_logger.log(logginglevels.DEBUG_4,
                                    'Running "%s" handler for "%s" plugin',
                                    slotname, modname)
    
            _, conf = self._plugins[modname]
            func(conduitcls(self, self.base, conf, **kwargs))

    def _importplugins(self, types):
        '''Load plugins matching the given types.
        '''

        # Initialise plugin dict
        self._plugins = {}
        self._pluginfuncs = {}
        for slot in SLOTS:
            self._pluginfuncs[slot] = []

        # Import plugins 
        self._used_disable_plugin = set()
        self._used_enable_plugin  = set()
        for dir in self.searchpath:
            if not os.path.isdir(dir):
                continue
            for modulefile in sorted(glob.glob('%s/*.py' % dir)):
                self._loadplugin(modulefile, types)

        # If we are in verbose mode we get the full 'Loading "blah" plugin' lines
        if (self._plugins and
            not self.verbose_logger.isEnabledFor(logginglevels.DEBUG_3)):
            # Mostly copied from YumOutput._outKeyValFill()
            key = _("Loaded plugins: ")
            val = ", ".join(sorted(self._plugins))
            nxt = ' ' * (utf8_width(key) - 2) + ': '
            width = 80
            if hasattr(self.base, 'term'):
                width = self.base.term.columns
            self.verbose_logger.log(logginglevels.INFO_2,
                                    fill(val, width=width, initial_indent=key,
                                         subsequent_indent=nxt))

        if self.disabledPlugins:
            for wc in self.disabledPlugins:
                if wc not in self._used_disable_plugin:
                    self.verbose_logger.log(logginglevels.INFO_2,
                                            _("No plugin match for: %s") % wc)
        del self._used_disable_plugin
        if self.enabledPlugins:
            for wc in self.enabledPlugins:
                if wc not in self._used_enable_plugin:
                    self.verbose_logger.log(logginglevels.INFO_2,
                                            _("No plugin match for: %s") % wc)
        del self._used_enable_plugin

    @staticmethod
    def _plugin_cmdline_match(modname, plugins, used):
        """ Check if this plugin has been temporary enabled/disabled. """
        if plugins is None:
            return False

        for wc in plugins:
            if fnmatch.fnmatch(modname, wc):
                used.add(wc)
                return True

        return False


    def _loadplugin(self, modulefile, types):
        '''Attempt to import a plugin module and register the hook methods it
        uses.
        '''
        dir, modname = os.path.split(modulefile)
        modname = modname.split('.py')[0]

        conf = self._getpluginconf(modname)
        if (not conf or
            (not config.getOption(conf, 'main', 'enabled',
                                  config.BoolOption(False)) and
             not self._plugin_cmdline_match(modname, self.enabledPlugins,
                                            self._used_enable_plugin))):
            self.verbose_logger.debug(_('Not loading "%s" plugin, as it is disabled'), modname)
            return

        try:
            fp, pathname, description = imp.find_module(modname, [dir])
            try:
                module = imp.load_module(modname, fp, pathname, description)
            finally:
                fp.close()
        except:
            if self.verbose_logger.isEnabledFor(logginglevels.DEBUG_4):
                raise # Give full backtrace:
            self.verbose_logger.error(_('Plugin "%s" can\'t be imported') %
                                      modname)
            return

        # Check API version required by the plugin
        if not hasattr(module, 'requires_api_version'):
            self.verbose_logger.error(
                _('Plugin "%s" doesn\'t specify required API version') %
                modname)
            return
        if not apiverok(API_VERSION, module.requires_api_version):
            self.verbose_logger.error(
                _('Plugin "%s" requires API %s. Supported API is %s.') % (
                    modname,
                    module.requires_api_version,
                    API_VERSION,
                    ))
            return

        # Check plugin type against filter
        plugintypes = getattr(module, 'plugin_type', ALL_TYPES)
        if not isinstance(plugintypes, (list, tuple)):
            plugintypes = (plugintypes,)

        if len(plugintypes) < 1:
            return
        for plugintype in plugintypes:
            if id(plugintype) == id(TYPE_INTERFACE):
                self.verbose_logger.log(logginglevels.INFO_2,
                        'Plugin "%s" uses deprecated constant '
                        'TYPE_INTERFACE.\nPlease use TYPE_INTERACTIVE '
                        'instead.', modname)

            if plugintype not in types:
                return

        #  This should really work like enable/disable repo. and be based on the
        # cmd line order ... but the API doesn't really allow that easily.
        # FIXME: Fix for 4.*
        if (self._plugin_cmdline_match(modname, self.disabledPlugins,
                                       self._used_disable_plugin) and
            not self._plugin_cmdline_match(modname, self.enabledPlugins,
                                           self._used_enable_plugin)):
            return

        self.verbose_logger.log(logginglevels.DEBUG_3, _('Loading "%s" plugin'),
                                modname)

        # Store the plugin module and its configuration file
        if modname not in self._plugins:
            self._plugins[modname] = (module, conf)
        else:
            raise Errors.ConfigError(_('Two or more plugins with the name "%s" ' \
                    'exist in the plugin search path') % modname)
        
        for slot in SLOTS:
            funcname = slot+'_hook'
            if hasattr(module, funcname):
                self._pluginfuncs[slot].append(
                        (modname, getattr(module, funcname))
                        )

    def _getpluginconf(self, modname):
        '''Parse the plugin specific configuration file and return a
        IncludingConfigParser instance representing it. Returns None if there
        was an error reading or parsing the configuration file.
        '''
        for dir in self.pluginconfpath:
            conffilename = os.path.join(dir, modname + ".conf")
            if os.access(conffilename, os.R_OK):
                # Found configuration file
                break
            self.verbose_logger.log(logginglevels.INFO_2, _("Configuration file %s not found") % conffilename)
        else: # for
            # Configuration files for the plugin not found
            self.verbose_logger.log(logginglevels.INFO_2, _("Unable to find configuration file for plugin %s")
                % modname)
            return None
        parser = ConfigParser()
        confpp_obj = ConfigPreProcessor(conffilename)
        try:
            parser.readfp(confpp_obj)
        except ParsingError, e:
            raise Errors.ConfigError("Couldn't parse %s: %s" % (conffilename,
                str(e)))
        return parser

    def setCmdLine(self, opts, commands):
        '''Set the parsed command line options so that plugins can access them
        '''
        self.cmdline = (opts, commands)


class DummyYumPlugins:
    '''
    This class provides basic emulation of the YumPlugins class. It exists so
    that calls to plugins.run() don't fail if plugins aren't in use.
    '''
    def run(self, *args, **kwargs):
        pass

    def setCmdLine(self, *args, **kwargs):
        pass

class PluginConduit:
    def __init__(self, parent, base, conf):
        self._parent = parent
        self._base = base
        self._conf = conf

        self.logger = logging.getLogger("yum.plugin")
        self.verbose_logger = logging.getLogger("yum.verbose.plugin")

    def info(self, level, msg):
        converted_level = logginglevels.logLevelFromDebugLevel(level)
        self.verbose_logger.log(converted_level, msg)

    def error(self, level, msg):
        converted_level = logginglevels.logLevelFromErrorLevel(level)
        self.logger.log(converted_level, msg)

    def promptYN(self, msg):
        self.info(2, msg)
        if self._base.conf.assumeyes:
            return 1
        else:
            return self._base.userconfirm()

    def getYumVersion(self):
        import yum
        return yum.__version__

    def getOptParser(self):
        '''Return the optparse.OptionParser instance for this execution of Yum

        In the "config" and "init" slots a plugin may add extra options to this
        instance to extend the command line options that Yum exposes.

        In all other slots a plugin may only read the OptionParser instance.
        Any modification of the instance at this point will have no effect. 
        
        See the getCmdLine() method for details on how to retrieve the parsed
        values of command line options.

        @return: the global optparse.OptionParser instance used by Yum. May be
            None if an OptionParser isn't in use.
        '''
        # ' xemacs highlighting hack
        # This isn't API compatible :(
        # return self._parent.optparser.plugin_option_group
        return self._parent.optparser

    def confString(self, section, opt, default=None):
        '''Read a string value from the plugin's own configuration file

        @param section: Configuration file section to read.
        @param opt: Option name to read.
        @param default: Value to read if option is missing.
        @return: String option value read, or default if option was missing.
        '''
        # ' xemacs highlighting hack
        return config.getOption(self._conf, section, opt, config.Option(default))

    def confInt(self, section, opt, default=None):
        '''Read an integer value from the plugin's own configuration file

        @param section: Configuration file section to read.
        @param opt: Option name to read.
        @param default: Value to read if option is missing.
        @return: Integer option value read, or default if option was missing or
            could not be parsed.
        '''
        return config.getOption(self._conf, section, opt, config.IntOption(default))

    def confFloat(self, section, opt, default=None):
        '''Read a float value from the plugin's own configuration file

        @param section: Configuration file section to read.
        @param opt: Option name to read.
        @param default: Value to read if option is missing.
        @return: Float option value read, or default if option was missing or
            could not be parsed.
        '''
        return config.getOption(self._conf, section, opt, config.FloatOption(default))

    def confBool(self, section, opt, default=None):
        '''Read a boolean value from the plugin's own configuration file

        @param section: Configuration file section to read.
        @param opt: Option name to read.
        @param default: Value to read if option is missing.
        @return: Boolean option value read, or default if option was missing or
            could not be parsed.
        '''
        return config.getOption(self._conf, section, opt, config.BoolOption(default))

    def registerPackageName(self, name):
        self._base.run_with_package_names.add(name)


class ConfigPluginConduit(PluginConduit):

    def registerOpt(self, name, valuetype, where, default):
        '''Register a yum configuration file option.

        @param name: Name of the new option.
        @param valuetype: Option type (PLUG_OPT_BOOL, PLUG_OPT_STRING ...)
        @param where: Where the option should be available in the config file.
            (PLUG_OPT_WHERE_MAIN, PLUG_OPT_WHERE_REPO, ...)
        @param default: Default value for the option if not set by the user.
        '''
        warnings.warn('registerOpt() will go away in a future version of Yum.\n'
                'Please manipulate config.YumConf and config.RepoConf directly.',
                DeprecationWarning)

        type2opt =  {
            PLUG_OPT_STRING: config.Option,
            PLUG_OPT_INT: config.IntOption,
            PLUG_OPT_BOOL: config.BoolOption,
            PLUG_OPT_FLOAT: config.FloatOption,
            }

        if where == PLUG_OPT_WHERE_MAIN:
            setattr(config.YumConf, name, type2opt[valuetype](default))

        elif where == PLUG_OPT_WHERE_REPO:
            setattr(config.RepoConf, name, type2opt[valuetype](default))

        elif where == PLUG_OPT_WHERE_ALL:
            option = type2opt[valuetype](default)
            setattr(config.YumConf, name, option)
            setattr(config.RepoConf, name, config.Inherit(option))

    def registerCommand(self, command):
        if hasattr(self._base, 'registerCommand'):
            self._base.registerCommand(command)
        else:
            raise Errors.ConfigError(_('registration of commands not supported'))

class PostConfigPluginConduit(ConfigPluginConduit):

    def getConf(self):
        return self._base.conf

class InitPluginConduit(PluginConduit):

    def getConf(self):
        return self._base.conf

    def getRepos(self):
        '''Return Yum's container object for all configured repositories.

        @return: Yum's RepoStorage instance
        '''
        return self._base.repos

class ArgsPluginConduit(InitPluginConduit):

    def __init__(self, parent, base, conf, args):
        InitPluginConduit.__init__(self, parent, base, conf)
        self._args = args

    def getArgs(self):
        return self._args

class PreRepoSetupPluginConduit(InitPluginConduit):

    def getCmdLine(self):
        '''Return parsed command line options.

        @return: (options, commands) as returned by OptionParser.parse_args()
        '''
        return self._parent.cmdline

    def getRpmDB(self):
        '''Return a representation of local RPM database. This allows querying
        of installed packages.

        @return: rpmUtils.RpmDBHolder instance
        '''
        return self._base.rpmdb

class PostRepoSetupPluginConduit(PreRepoSetupPluginConduit):

    def getGroups(self):
        '''Return group information.

        @return: yum.comps.Comps instance
        '''
        return self._base.comps

class DownloadPluginConduit(PostRepoSetupPluginConduit):

    def __init__(self, parent, base, conf, pkglist, errors=None):
        PostRepoSetupPluginConduit.__init__(self, parent, base, conf)
        self._pkglist = pkglist
        self._errors = errors

    def getDownloadPackages(self):
        '''Return a list of package objects representing packages to be
        downloaded.
        '''
        return self._pkglist

    def getErrors(self):
        '''Return a dictionary of download errors. 
        
        The returned dictionary is indexed by package object. Each element is a
        list of strings describing the error.
        '''
        if not self._errors:
            return {}
        return self._errors

class MainPluginConduit(PostRepoSetupPluginConduit):

    def getPackages(self, repo=None):
        if repo:
            arg = repo.id
        else:
            arg = None
        return self._base.pkgSack.returnPackages(arg)

    def getPackageByNevra(self, nevra):
        '''Retrieve a package object from the packages loaded by Yum using
        nevra information 
        
        @param nevra: A tuple holding (name, epoch, version, release, arch)
            for a package
        @return: A PackageObject instance (or subclass)
        '''
        return self._base.getPackageObject(nevra)

    def delPackage(self, po):
        po.repo.sack.delPackage(po)

    def getTsInfo(self):
        return self._base.tsInfo

class DepsolvePluginConduit(MainPluginConduit):
    def __init__(self, parent, base, conf, rescode=None, restring=[]):
        MainPluginConduit.__init__(self, parent, base, conf)
        self.resultcode = rescode
        self.resultstring = restring

class CompareProvidersPluginConduit(MainPluginConduit):
    def __init__(self, parent, base, conf, providers_dict={}, reqpo=None):
        MainPluginConduit.__init__(self, parent, base, conf)
        self.packages = providers_dict
        self.reqpo = reqpo

class HistoryPluginConduit(MainPluginConduit):
    def __init__(self, parent, base, conf, rescode=None, restring=[]):
        MainPluginConduit.__init__(self, parent, base, conf)
        self.history = self._base.history

class VerifyPluginConduit(MainPluginConduit):
    def __init__(self, parent, base, conf, verify_package):
        MainPluginConduit.__init__(self, parent, base, conf)
        self.verify_package = verify_package

def parsever(apiver):
    maj, min = apiver.split('.')
    return int(maj), int(min)

def apiverok(a, b):
    '''Return true if API version "a" supports API version "b"
    '''
    a = parsever(a)
    b = parsever(b)

    if a[0] != b[0]:
        return 0

    if a[1] >= b[1]:
        return 1

    return 0
                                                                                                                                                                                                                                                                                                                      usr/lib/python2.7/dist-packages/yum/plugins.pyc                                                     0100644 0000000 0000000 00000057742 13077704344 020153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   sL  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Td  d l	 Z	 d  d l	 m
 Z
 m Z d  d l Z d  d l m Z d  d l m Z d  d l Z d  d l m Z d  d l m Z d  d l m Z d	 Z d
 e f d Ñ  É  YZ d Z d Z e d É Z e e f Z i d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d  d! 6d  d" 6d  d# 6d  d$ 6d  d% 6d& d' 6d& d( 6d) d* 6d) d+ 6d, d- 6d. d/ 6Z e  e j! É  É Z" d0 e# f d1 Ñ  É  YZ$ d2 dE d3 Ñ  É  YZ% d4 dF d5 Ñ  É  YZ& d dG d6 Ñ  É  YZ' d e' f d7 Ñ  É  YZ( d e( f d8 Ñ  É  YZ) d e' f d9 Ñ  É  YZ* d e* f d: Ñ  É  YZ+ d e* f d; Ñ  É  YZ, d e, f d< Ñ  É  YZ- d e- f d= Ñ  É  YZ. d  e- f d> Ñ  É  YZ/ d& e/ f d? Ñ  É  YZ0 d, e/ f d@ Ñ  É  YZ1 d) e/ f dA Ñ  É  YZ2 d. e/ f dB Ñ  É  YZ3 dC Ñ  Z4 dD Ñ  Z5 d S(H   iˇˇˇˇN(   t   *(   t   ParsingErrort   ConfigParser(   t   ConfigPreProcessor(   t   fill(   t   proxy(   t   _(   t
   utf8_widths   2.6t   DeprecatedIntc           B   s   e  Z d  Z RS(   sV   
    A simple int subclass that used to check when a deprecated constant is used.
    (   t   __name__t
   __module__t   __doc__(    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR   D   s   i    i   t   ConfigPluginConduitt   configt   PostConfigPluginConduitt
   postconfigt   InitPluginConduitt   initt   ArgsPluginConduitt   argst   DownloadPluginConduitt   predownloadt   postdownloadt   PreRepoSetupPluginConduitt   prereposetupt   PostRepoSetupPluginConduitt   postreposetupt   PluginConduitt   closet   cleant   MainPluginConduitt   pretranst	   posttranst   preverifytranst   postverifytranst   excludet   DepsolvePluginConduitt
   preresolvet   postresolvet   HistoryPluginConduitt   historybegint
   historyendt   CompareProvidersPluginConduitt   compare_providerst   VerifyPluginConduitt   verify_packaget   PluginYumExitc           B   s&   e  Z d  Z d d d Ñ Z d Ñ  Z RS(   s3   Used by plugins to signal that yum should stop
    t    c         C   s   | |  _  | |  _ d  S(   N(   t   valuet   translation_domain(   t   selfR0   R1   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   __init__n   s    	c         C   s*   |  j  r t j |  j  |  j É S|  j Sd  S(   N(   R1   t   gettextt   dgettextR0   (   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   __str__q   s    	(   R	   R
   R   R3   R6   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR.   k   s   t
   YumPluginsc           B   sb   e  Z d  Z d d d d d d Ñ Z d Ñ  Z d Ñ  Z e d Ñ  É Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z RS(	   s(   
    Manager class for Yum plugins.
    c   	      C   s  | s d g } n  | |  _  | |  _ t | É |  _ | |  _ d |  _ t j d É |  _	 | |  _
 | |  _ | d k r~ t } n  t | t t f É sü | f } n  t t É g  | D] } t | É ^ qØ k r„ |  j	 j t j d É n  |  j | É i  |  _ t j |  j d É |  j d É d S(   sv  Initialise the instance.

        @param base: The
        @param searchpath: A list of paths to look for plugin modules.
        @param optparser: The OptionParser instance for this run (optional).
            Use to allow plugins to extend command line options.
        @param types: A sequence specifying the types of plugins to load.
            This should be sequnce containing one or more of the TYPE_...
            constants. If None (the default), all plugins will be loaded.
        @param pluginconfpath: A list of paths to look for plugin configuration
            files. Defaults to "/etc/yum/pluginconf.d".
        s   /etc/yum/pluginconf.ds   yum.verbose.YumPluginsse   Deprecated constant TYPE_INTERFACE during plugin initialization.
Please use TYPE_INTERACTIVE instead.R   R   N(   NN(   t
   searchpatht   pluginconfpatht   weakreft   baset	   optparsert   Nonet   cmdlinet   loggingt	   getLoggert   verbose_loggert   disabledPluginst   enabledPluginst	   ALL_TYPESt
   isinstancet   listt   tuplet   idt   TYPE_INTERFACEt   logt   logginglevelst   INFO_2t   _importpluginst   cmdlinest   atexitt   registert   run(	   R2   R;   R8   R<   t   typesR9   t   disabledt   enabledt   t(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR3   |   s*    							+
	c         K   s™   t  j | d É } | d k r1 t d | É Ç n  t | É } xf |  j | D]W \ } } |  j j t j	 d | | É |  j
 | \ } } | | |  |  j | | ç É qK Wd S(   s5   Run all plugin functions for the given slot.
        s   unknown slot name "%s"s$   Running "%s" handler for "%s" pluginN(   t   SLOT_TO_CONDUITt   getR=   t
   ValueErrort   evalt   _pluginfuncsRA   RJ   RK   t   DEBUG_4t   _pluginsR;   (   R2   t   slotnamet   kwargst
   conduitclst   modnamet   funcR   t   conf(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyRQ   ©   s    
c   
   
   C   s  i  |  _  i  |  _ x t D] } g  |  j | <q Wt É  |  _ t É  |  _ x] |  j D]R } t j j	 | É sp qR n  x1 t
 t j d | É É D] } |  j | | É qä WqR W|  j  r^|  j j t j É r^t d É } d j t
 |  j  É É } d t | É d d } d } t |  j d É r-|  j j j } n  |  j j t j t | d	 | d
 | d | ÉÉ n  |  j r∞xF |  j D]8 }	 |	 |  j k rq|  j j t j t d É |	 É qqqqWn  |  ` |  j rxF |  j D]8 }	 |	 |  j k r…|  j j t j t d É |	 É q…q…Wn  |  ` d S(   s/   Load plugins matching the given types.
        s   %s/*.pys   Loaded plugins: s   , t    i   s   : iP   t   termt   widtht   initial_indentt   subsequent_indents   No plugin match for: %sN(   R\   RZ   t   SLOTSt   sett   _used_disable_plugint   _used_enable_pluginR8   t   ost   patht   isdirt   sortedt   globt   _loadpluginRA   t   isEnabledForRK   t   DEBUG_3R   t   joinR   t   hasattrR;   Rd   t   columnsRJ   RL   R   RB   RC   (
   R2   RR   t   slott   dirt
   modulefilet   keyt   valt   nxtRe   t   wc(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyRM   ∫   sD    		 			c         C   sH   | d k r t Sx1 | D]) } t j |  | É r | j | É t Sq Wt S(   s;    Check if this plugin has been temporary enabled/disabled. N(   R=   t   Falset   fnmatcht   addt   True(   R`   t   pluginst   usedR}   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   _plugin_cmdline_matchË   s    c         C   s  t  j j | É \ } } | j d É d } |  j | É } | s t j | d d t j t É É rú |  j | |  j	 |  j
 É rú |  j j t d É | É d SyL t j | | g É \ } } } z t j | | | | É }	 Wd | j É  XWn= |  j j t j É r	Ç  n  |  j j t d É | É d SXt |	 d É sU|  j j t d	 É | É d St t |	 j É së|  j j t d
 É | |	 j t f É d St |	 d t É }
 t |
 t t f É sƒ|
 f }
 n  t |
 É d k  r⁄d SxR |
 D]J } t  | É t  t! É k r|  j j" t j# d | É n  | | k r·d Sq·W|  j | |  j$ |  j% É rj|  j | |  j	 |  j
 É rjd S|  j j" t j& t d É | É | |  j' k rÆ|	 | f |  j' | <n t( j) t d É | É Ç xM t* D]E } | d } t |	 | É rŒ|  j+ | j, | t |	 | É f É qŒqŒWd S(   sY   Attempt to import a plugin module and register the hook methods it
        uses.
        s   .pyi    t   mainRT   s*   Not loading "%s" plugin, as it is disabledNs   Plugin "%s" can't be importedt   requires_api_versions0   Plugin "%s" doesn't specify required API versions1   Plugin "%s" requires API %s. Supported API is %s.t   plugin_typei   sY   Plugin "%s" uses deprecated constant TYPE_INTERFACE.
Please use TYPE_INTERACTIVE instead.s   Loading "%s" pluginsF   Two or more plugins with the name "%s" exist in the plugin search patht   _hook(-   Rl   Rm   t   splitt   _getpluginconfR   t	   getOptiont
   BoolOptionR~   RÑ   RC   Rk   RA   t   debugR   t   impt   find_modulet   load_moduleR   Rr   RK   R[   t   errorRu   t   apiverokt   API_VERSIONRÜ   t   getattrRD   RE   RF   RG   t   lenRH   RI   RJ   RL   RB   Rj   Rs   R\   t   Errorst   ConfigErrorRh   RZ   t   append(   R2   Ry   RR   Rx   R`   Rb   t   fpt   pathnamet   descriptiont   modulet   plugintypest
   plugintypeRw   t   funcname(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyRq   ˆ   sz    				


c         C   sÈ   xá |  j  D]X } t j j | | d É } t j | t j É rB Pn  |  j j t j	 t
 d É | É q
 W|  j j t j	 t
 d É | É d St É  } t | É } y | j | É Wn2 t k
 r‰ } t j d | t | É f É Ç n X| S(   s–   Parse the plugin specific configuration file and return a
        IncludingConfigParser instance representing it. Returns None if there
        was an error reading or parsing the configuration file.
        s   .confs   Configuration file %s not founds/   Unable to find configuration file for plugin %ss   Couldn't parse %s: %sN(   R9   Rl   Rm   Rt   t   accesst   R_OKRA   RJ   RK   RL   R   R=   R   R   t   readfpR   Rñ   Ró   t   str(   R2   R`   Rx   t   conffilenamet   parsert
   confpp_objt   e(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyRä   M  s     $	c         C   s   | | f |  _  d S(   sL   Set the parsed command line options so that plugins can access them
        N(   R>   (   R2   t   optst   commands(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt
   setCmdLinef  s    N(   R	   R
   R   R=   R3   RQ   RM   t   staticmethodRÑ   Rq   Rä   R™   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR7   w   s   ,		.	W	t   DummyYumPluginsc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sò   
    This class provides basic emulation of the YumPlugins class. It exists so
    that calls to plugins.run() don't fail if plugins aren't in use.
    c         O   s   d  S(   N(    (   R2   R   R^   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyRQ   q  s    c         O   s   d  S(   N(    (   R2   R   R^   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR™   t  s    (   R	   R
   R   RQ   R™   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR¨   l  s   	c           B   sw   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z	 d d Ñ Z
 d d Ñ Z d d	 Ñ Z d
 Ñ  Z RS(   c         C   sC   | |  _  | |  _ | |  _ t j d É |  _ t j d É |  _ d  S(   Ns
   yum.plugins   yum.verbose.plugin(   t   _parentt   _baset   _confR?   R@   t   loggerRA   (   R2   t   parentR;   Rb   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR3   x  s
    			c         C   s&   t  j | É } |  j j | | É d  S(   N(   RK   t   logLevelFromDebugLevelRA   RJ   (   R2   t   levelt   msgt   converted_level(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   infoÄ  s    c         C   s&   t  j | É } |  j j | | É d  S(   N(   RK   t   logLevelFromErrorLevelR∞   RJ   (   R2   R≥   R¥   Rµ   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyRë   Ñ  s    c         C   s4   |  j  d | É |  j j j r# d S|  j j É  Sd  S(   Ni   i   (   R∂   RÆ   Rb   t	   assumeyest   userconfirm(   R2   R¥   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   promptYNà  s    c         C   s   d d  l  } | j S(   Niˇˇˇˇ(   t   yumt   __version__(   R2   Rª   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   getYumVersionè  s    c         C   s
   |  j  j S(   s  Return the optparse.OptionParser instance for this execution of Yum

        In the "config" and "init" slots a plugin may add extra options to this
        instance to extend the command line options that Yum exposes.

        In all other slots a plugin may only read the OptionParser instance.
        Any modification of the instance at this point will have no effect. 
        
        See the getCmdLine() method for details on how to retrieve the parsed
        values of command line options.

        @return: the global optparse.OptionParser instance used by Yum. May be
            None if an OptionParser isn't in use.
        (   R≠   R<   (   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   getOptParserì  s    c         C   s"   t  j |  j | | t  j | É É S(   s4  Read a string value from the plugin's own configuration file

        @param section: Configuration file section to read.
        @param opt: Option name to read.
        @param default: Value to read if option is missing.
        @return: String option value read, or default if option was missing.
        (   R   Rã   RØ   t   Option(   R2   t   sectiont   optt   default(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt
   confStringß  s    	c         C   s"   t  j |  j | | t  j | É É S(   sZ  Read an integer value from the plugin's own configuration file

        @param section: Configuration file section to read.
        @param opt: Option name to read.
        @param default: Value to read if option is missing.
        @return: Integer option value read, or default if option was missing or
            could not be parsed.
        (   R   Rã   RØ   t	   IntOption(   R2   R¿   R¡   R¬   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   confInt≤  s    	c         C   s"   t  j |  j | | t  j | É É S(   sU  Read a float value from the plugin's own configuration file

        @param section: Configuration file section to read.
        @param opt: Option name to read.
        @param default: Value to read if option is missing.
        @return: Float option value read, or default if option was missing or
            could not be parsed.
        (   R   Rã   RØ   t   FloatOption(   R2   R¿   R¡   R¬   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt	   confFloatΩ  s    	c         C   s"   t  j |  j | | t  j | É É S(   sY  Read a boolean value from the plugin's own configuration file

        @param section: Configuration file section to read.
        @param opt: Option name to read.
        @param default: Value to read if option is missing.
        @return: Boolean option value read, or default if option was missing or
            could not be parsed.
        (   R   Rã   RØ   Rå   (   R2   R¿   R¡   R¬   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   confBool»  s    	c         C   s   |  j  j j | É d  S(   N(   RÆ   t   run_with_package_namesRÄ   (   R2   t   name(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   registerPackageName”  s    N(   R	   R
   R3   R∂   Rë   R∫   RΩ   Ræ   R=   R√   R≈   R«   R»   RÀ   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR   w  s   						c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   sË   t  j d t É i t j t 6t j t 6t j t	 6t j
 t 6} | t k rj t t j | | | | É É nz | t k rñ t t j | | | | É É nN | t k r‰ | | | É } t t j | | É t t j | t j | É É n  d S(   sÉ  Register a yum configuration file option.

        @param name: Name of the new option.
        @param valuetype: Option type (PLUG_OPT_BOOL, PLUG_OPT_STRING ...)
        @param where: Where the option should be available in the config file.
            (PLUG_OPT_WHERE_MAIN, PLUG_OPT_WHERE_REPO, ...)
        @param default: Default value for the option if not set by the user.
        su   registerOpt() will go away in a future version of Yum.
Please manipulate config.YumConf and config.RepoConf directly.N(   t   warningst   warnt   DeprecationWarningR   Rø   t   PLUG_OPT_STRINGRƒ   t   PLUG_OPT_INTRå   t   PLUG_OPT_BOOLR∆   t   PLUG_OPT_FLOATt   PLUG_OPT_WHERE_MAINt   setattrt   YumConft   PLUG_OPT_WHERE_REPOt   RepoConft   PLUG_OPT_WHERE_ALLt   Inherit(   R2   R    t	   valuetypet   whereR¬   t   type2optt   option(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   registerOptŸ  s    		


  c         C   s>   t  |  j d É r% |  j j | É n t j t d É É Ç d  S(   Nt   registerCommands&   registration of commands not supported(   Ru   RÆ   Rﬂ   Rñ   Ró   R   (   R2   t   command(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyRﬂ   ¯  s    (   R	   R
   Rﬁ   Rﬂ   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR   ◊  s   	c           B   s   e  Z d  Ñ  Z RS(   c         C   s
   |  j  j S(   N(   RÆ   Rb   (   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   getConf   s    (   R	   R
   R·   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR   ˛  s   c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s
   |  j  j S(   N(   RÆ   Rb   (   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR·     s    c         C   s
   |  j  j S(   st   Return Yum's container object for all configured repositories.

        @return: Yum's RepoStorage instance
        (   RÆ   t   repos(   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   getRepos  s    (   R	   R
   R·   R„   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR     s   	c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s#   t  j |  | | | É | |  _ d  S(   N(   R   R3   t   _args(   R2   R±   R;   Rb   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR3     s    c         C   s   |  j  S(   N(   R‰   (   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   getArgs  s    (   R	   R
   R3   RÂ   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR     s   	c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s
   |  j  j S(   s{   Return parsed command line options.

        @return: (options, commands) as returned by OptionParser.parse_args()
        (   R≠   R>   (   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt
   getCmdLine  s    c         C   s
   |  j  j S(   sõ   Return a representation of local RPM database. This allows querying
        of installed packages.

        @return: rpmUtils.RpmDBHolder instance
        (   RÆ   t   rpmdb(   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   getRpmDB!  s    (   R	   R
   RÊ   RË   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR     s   	c           B   s   e  Z d  Ñ  Z RS(   c         C   s
   |  j  j S(   sM   Return group information.

        @return: yum.comps.Comps instance
        (   RÆ   t   comps(   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt	   getGroups+  s    (   R	   R
   RÍ   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR   )  s   c           B   s&   e  Z d d  Ñ Z d Ñ  Z d Ñ  Z RS(   c         C   s,   t  j |  | | | É | |  _ | |  _ d  S(   N(   R   R3   t   _pkglistt   _errors(   R2   R±   R;   Rb   t   pkglistt   errors(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR3   4  s    	c         C   s   |  j  S(   sY   Return a list of package objects representing packages to be
        downloaded.
        (   RÎ   (   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   getDownloadPackages9  s    c         C   s   |  j  s i  S|  j  S(   s∏   Return a dictionary of download errors. 
        
        The returned dictionary is indexed by package object. Each element is a
        list of strings describing the error.
        (   RÏ   (   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt	   getErrors?  s    	N(   R	   R
   R=   R3   RÔ   R   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR   2  s   	c           B   s/   e  Z d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s+   | r | j  } n d  } |  j j j | É S(   N(   RH   R=   RÆ   t   pkgSackt   returnPackages(   R2   t   repot   arg(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   getPackagesK  s    c         C   s   |  j  j | É S(   s
  Retrieve a package object from the packages loaded by Yum using
        nevra information 
        
        @param nevra: A tuple holding (name, epoch, version, release, arch)
            for a package
        @return: A PackageObject instance (or subclass)
        (   RÆ   t   getPackageObject(   R2   t   nevra(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   getPackageByNevraR  s    c         C   s   | j  j j | É d  S(   N(   RÛ   t   sackt
   delPackage(   R2   t   po(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR˙   \  s    c         C   s
   |  j  j S(   N(   RÆ   t   tsInfo(   R2   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt	   getTsInfo_  s    N(   R	   R
   R=   Rı   R¯   R˙   R˝   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR   I  s   	
	c           B   s   e  Z d g  d  Ñ Z RS(   c         C   s,   t  j |  | | | É | |  _ | |  _ d  S(   N(   R   R3   t
   resultcodet   resultstring(   R2   R±   R;   Rb   t   rescodet   restring(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR3   c  s    	N(   R	   R
   R=   R3   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR$   b  s   c           B   s   e  Z i  d d  Ñ Z RS(   c         C   s,   t  j |  | | | É | |  _ | |  _ d  S(   N(   R   R3   t   packagest   reqpo(   R2   R±   R;   Rb   t   providers_dictR  (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR3   i  s    	N(   R	   R
   R=   R3   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR*   h  s   c           B   s   e  Z d g  d  Ñ Z RS(   c         C   s)   t  j |  | | | É |  j j |  _ d  S(   N(   R   R3   RÆ   t   history(   R2   R±   R;   Rb   R   R  (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR3   o  s    N(   R	   R
   R=   R3   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR'   n  s   c           B   s   e  Z d  Ñ  Z RS(   c         C   s#   t  j |  | | | É | |  _ d  S(   N(   R   R3   R-   (   R2   R±   R;   Rb   R-   (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR3   t  s    (   R	   R
   R3   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyR,   s  s   c         C   s+   |  j  d É \ } } t | É t | É f S(   Nt   .(   Râ   t   int(   t   apivert   majt   min(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   parseverx  s    c         C   sL   t  |  É }  t  | É } |  d | d k r0 d S|  d | d k rH d Sd S(   s<   Return true if API version "a" supports API version "b"
    i    i   (   R  (   t   at   b(    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyRí   |  s    (    (    (    (6   Rl   Rp   Ré   RÃ   RO   R4   R?   RK   t	   constantsR   R   R   Rñ   R•   R   t   textwrapR   R   R:   R   Rª   R   t   yum.i18nR   Rì   R  R   t	   TYPE_COREt   TYPE_INTERACTIVERI   RD   RV   Ro   t   keysRh   t	   ExceptionR.   R7   R¨   R   R   R   R   R   R   R   R   R   R$   R*   R'   R,   R  Rí   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/plugins.pyt   <module>   sÄ   

ı`'			                              usr/lib/python2.7/dist-packages/yum/repoMDObject.py                                                 0100644 0000000 0000000 00000023227 12451005146 020620  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2006 Duke University

from yum.misc import cElementTree_iterparse as iterparse 
from Errors import RepoMDError

import sys
import types
from misc import AutoFileChecksums, to_xml

def ns_cleanup(qn):
    if qn.find('}') == -1: return qn 
    return qn.split('}')[1]

class RepoData:
    """represents anything beneath a <data> tag"""
    def __init__(self, elem=None):
        self.type = None
        if elem:
            self.type = elem.attrib.get('type')
        self.location = (None, None)
        self.checksum = (None,None) # type,value
        self.openchecksum = (None,None) # type,value
        self.timestamp = None
        self.dbversion = None
        self.size      = None
        self.opensize  = None

        if elem:
            self.parse(elem)

    def parse(self, elem):
        
        for child in elem:
            child_name = ns_cleanup(child.tag)
            if child_name == 'location':
                relative = child.attrib.get('href')
                base = child.attrib.get('base')
                self.location = (base, relative)
            
            elif child_name == 'checksum':
                csum_value = child.text
                csum_type = child.attrib.get('type')
                self.checksum = (csum_type,csum_value)

            elif child_name == 'open-checksum':
                csum_value = child.text
                csum_type = child.attrib.get('type')
                self.openchecksum = (csum_type, csum_value)
            
            elif child_name == 'timestamp':
                self.timestamp = child.text
            elif child_name == 'database_version':
                self.dbversion = child.text
            elif child_name == 'size':
                self.size = child.text
            elif child_name == 'open-size':
                self.opensize = child.text

    def dump_xml(self):
        msg = ""
        top = """<data type="%s">\n""" % to_xml(self.type, attrib=True)
        msg += top
        
        for (data, xmlname) in [('checksum', 'checksum'),('openchecksum', 'open-checksum')]:
            if hasattr(self, data):
                val = getattr(self, data)
                if val[0]:
                    d_xml = """  <%s type="%s">%s</%s>\n""" % (xmlname,
                                       to_xml(val[0], attrib=True), 
                                       to_xml(val[1]), xmlname)
                    msg += d_xml

        if hasattr(self, 'location'):
            val = getattr(self, 'location')
            if val[1]:
                loc = """  <location href="%s"/>\n""" % to_xml(val[1], attrib=True)
                if val[0]:
                    loc = """  <location xml:base="%s" href="%s"/>\n""" % (
                       to_xml(val[0], attrib=True), to_xml(val[1], attrib=True))
                msg += loc
            
        for (data,xmlname) in [('timestamp', 'timestamp'),
                               ('dbversion', 'database_version'),
                               ('size','size'), ('opensize', 'open-size')]:
            val = getattr(self, data)
            if val:
                d_xml = """  <%s>%s</%s>\n""" % (xmlname, to_xml(val), 
                                                 xmlname)
                msg += d_xml

        bottom = """</data>\n"""
        msg += bottom
        return msg
        
class RepoMD:
    """represents the repomd xml file"""
    
    def __init__(self, repoid, srcfile=None):
        """takes a repoid and a filename for the repomd.xml"""
        
        self.timestamp = 0
        self.repoid    = repoid
        self.repoData  = {}
        self.checksums = {}
        self.length    = 0
        self.revision  = None
        self.tags      = {'content' : set(), 'distro' : {}, 'repo': set()}
    
        if srcfile:
            self.parse(srcfile)
    
    def parse(self, srcfile):
        if type(srcfile) in types.StringTypes:
            # srcfile is a filename string
            try:
                infile = open(srcfile, 'rt')
            except IOError:
                raise RepoMDError, "Unable to open %s" %(srcfile,)
        else:
            # srcfile is a file object
            infile = srcfile

        # We trust any of these to mean the repomd.xml is valid.
        infile = AutoFileChecksums(infile, ['sha256', 'sha512'],
                                   ignore_missing=True, ignore_none=True)
        parser = iterparse(infile)
        
        try:
            for event, elem in parser:
                elem_name = ns_cleanup(elem.tag)
                
                if elem_name == "data":
                    thisdata = RepoData(elem=elem)
                    self.repoData[thisdata.type] = thisdata
                    try:
                        nts = int(thisdata.timestamp)
                        if nts > self.timestamp: # max() not in old python
                            self.timestamp = nts
                    except:
                        pass
                elif elem_name == "revision":
                    self.revision = elem.text
                elif elem_name == "tags":
                    for child in elem:
                        child_name = ns_cleanup(child.tag)
                        if child_name == 'content':
                            self.tags['content'].add(child.text)
                        if child_name == 'distro':
                            cpeid = child.attrib.get('cpeid', '')
                            distro = self.tags['distro'].setdefault(cpeid,set())
                            distro.add(child.text)

            self.checksums = infile.checksums.hexdigests()
            self.length    = len(infile.checksums)
        except SyntaxError, e:
            raise RepoMDError, "Damaged repomd.xml file"
            
    def fileTypes(self):
        """return list of metadata file types available"""
        return self.repoData.keys()
    
    def getData(self, type):
        if type in self.repoData:
            return self.repoData[type]
        else:
            raise RepoMDError, "requested datatype %s not available" % type
            
    def dump(self):
        """dump fun output"""

        print "file timestamp: %s" % self.timestamp
        print "file length   : %s" % self.length
        for csum in sorted(self.checksums):
            print "file checksum : %s/%s" % (csum, self.checksums[csum])
        if self.revision is not None:
            print 'revision: %s' % self.revision
        if self.tags['content']:
            print 'tags content: %s' % ", ".join(sorted(self.tags['content']))
        if self.tags['distro']:
            for distro in sorted(self.tags['distro']):
                print 'tags distro: %s' % distro
                tags = self.tags['distro'][distro]
                print '  tags: %s' % ", ".join(sorted(tags))
        print '\n---- Data ----'
        for ft in sorted(self.fileTypes()):
            thisdata = self.repoData[ft]
            print '  datatype: %s' % thisdata.type
            print '    location     : %s %s' % thisdata.location
            print '    timestamp    : %s' % thisdata.timestamp
            print '    size         : %s' % thisdata.size
            print '    open size    : %s' % thisdata.opensize
            print '    checksum     : %s - %s' % thisdata.checksum
            print '    open checksum: %s - %s' %  thisdata.openchecksum
            print '    dbversion    : %s' % thisdata.dbversion
            print ''
    def dump_xml(self):
        msg = ""
        
        top = """<?xml version="1.0" encoding="UTF-8"?>
<repomd xmlns="http://linux.duke.edu/metadata/repo" xmlns:rpm="http://linux.duke.edu/metadata/rpm">\n"""
        msg += top
        if self.revision:
            rev = """ <revision>%s</revision>\n""" % to_xml(self.revision)
            msg += rev
        
        if self.tags['content'] or self.tags['distro'] or self.tags['repo']:
            tags = """ <tags>\n"""
            for item in self.tags['content']:
                tag = """   <content>%s</content>\n""" % (to_xml(item))
                tags += tag
            for item in self.tags['repo']:
                tag = """   <repo>%s</repo>\n""" % (to_xml(item))
                tags += tag
            for (cpeid, item) in self.tags['distro']:
                itemlist = list(item) # frellingsets.
                if cpeid:
                    tag = """   <distro cpeid="%s">%s</distro>\n""" % (
                                to_xml(cpeid, attrib=True), to_xml(itemlist[0]))
                else:
                    tag = """   <distro>%s</distro>\n""" % (to_xml(itemlist[0]))
                tags += tag
            tags += """ </tags>\n"""
            msg += tags
        
        for md in self.repoData.values():
            msg += md.dump_xml()
        
        msg += """</repomd>\n"""

        return msg

def main():

    try:
        print "file          : %s" % sys.argv[1]
        p = RepoMD('repoid', sys.argv[1])
        p.dump()
        
    except IOError:
        print >> sys.stderr, "newcomps.py: No such file:\'%s\'" % sys.argv[1]
        sys.exit(1)
        
if __name__ == '__main__':
    main()

                                                                                                                                                                                                                                                                                                                                                                         usr/lib/python2.7/dist-packages/yum/repoMDObject.pyc                                                0100644 0000000 0000000 00000020310 13077704344 020764  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   s†   d  d l  m Z d  d l m Z d  d l Z d  d l Z d  d l m Z m	 Z	 d Ñ  Z
 d d d Ñ  É  YZ d d d	 Ñ  É  YZ d
 Ñ  Z e d k rú e É  n  d S(   iˇˇˇˇ(   t   cElementTree_iterparse(   t   RepoMDErrorN(   t   AutoFileChecksumst   to_xmlc         C   s*   |  j  d É d k r |  S|  j d É d S(   Nt   }iˇˇˇˇi   (   t   findt   split(   t   qn(    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyt
   ns_cleanup   s     t   RepoDatac           B   s,   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z RS(   s(   represents anything beneath a <data> tagc         C   sÄ   d  |  _ | r' | j j d É |  _ n  d |  _ d |  _ d |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 | r| |  j | É n  d  S(   Nt   type(   NN(   NN(   NN(   t   NoneR
   t   attribt   gett   locationt   checksumt   openchecksumt	   timestampt	   dbversiont   sizet   opensizet   parse(   t   selft   elem(    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyt   __init__   s    								c         C   sD  x=| D]5} t  | j É } | d k r^ | j j d É } | j j d É } | | f |  _ q | d k ró | j } | j j d É } | | f |  _ q | d k r– | j } | j j d É } | | f |  _ q | d k rÎ | j |  _ q | d k r| j |  _	 q | d	 k r!| j |  _
 q | d
 k r | j |  _ q q Wd  S(   NR   t   hreft   baseR   R
   s   open-checksumR   t   database_versionR   s	   open-size(   R   t   tagR   R   R   t   textR   R   R   R   R   R   (   R   R   t   childt
   child_namet   relativeR   t
   csum_valuet	   csum_type(    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyR   -   s,    		c   	      C   sØ  d } d t  |  j d t É} | | 7} xÇ d d g D]t \ } } t |  | É r6 t |  | É } | d r™ d | t  | d d t Ét  | d	 É | f } | | 7} q™ q6 q6 Wt |  d
 É r=t |  d
 É } | d	 r=d t  | d	 d t É} | d r-d t  | d d t Ét  | d	 d t Éf } n  | | 7} q=n  x[ d d d d g D]G \ } } t |  | É } | rPd | t  | É | f } | | 7} qPqPWd } | | 7} | S(   Nt    s   <data type="%s">
R   R   R   s   open-checksumi    s     <%s type="%s">%s</%s>
i   R   s     <location href="%s"/>
s&     <location xml:base="%s" href="%s"/>
R   R   R   R   R   s	   open-sizes     <%s>%s</%s>
s   </data>
(   s   checksums   checksum(   s   openchecksums   open-checksum(   s	   timestamps	   timestamp(   s	   dbversions   database_version(   s   sizes   size(   s   opensizes	   open-size(   R   R
   t   Truet   hasattrt   getattr(	   R   t   msgt   topt   datat   xmlnamet   valt   d_xmlt   loct   bottom(    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyt   dump_xmlI   s<    



0

N(   t   __name__t
   __module__t   __doc__R   R   R   R/   (    (    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyR	      s   	t   RepoMDc           B   sG   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   s   represents the repomd xml filec         C   st   d |  _  | |  _ i  |  _ i  |  _ d |  _ d |  _ i t É  d 6i  d 6t É  d 6|  _ | rp |  j	 | É n  d S(   s0   takes a repoid and a filename for the repomd.xmli    t   contentt   distrot   repoN(
   R   t   repoidt   repoDatat	   checksumst   lengthR   t   revisiont   sett   tagsR   (   R   R7   t   srcfile(    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyR   p   s    						$c         C   s  t  | É t j k rO y t | d É } WqU t k
 rK t d | f Ç qU Xn | } t | d d g d t d t É} t | É } ytxI| D]A\ } } t	 | j
 É } | d k rt d | É } | |  j | j  <y. t | j É } | |  j k rˇ | |  _ n  WqÕqÕXqå | d	 k r(| j |  _ qå | d
 k rå xñ | D]ã }	 t	 |	 j
 É }
 |
 d k rv|  j d j |	 j É n  |
 d k r;|	 j j d d É } |  j d j | t É  É } | j |	 j É q;q;Wqå qå W| j j É  |  _ t | j É |  _ Wn t k
 r} t d Ç n Xd  S(   Nt   rts   Unable to open %st   sha256t   sha512t   ignore_missingt   ignore_noneR)   R   R;   R=   R4   R5   t   cpeidR#   s   Damaged repomd.xml file(   R
   t   typest   StringTypest   opent   IOErrorR   R   R$   t	   iterparseR   R   R	   R8   t   intR   R   R;   R=   t   addR   R   t
   setdefaultR<   R9   t
   hexdigestst   lenR:   t   SyntaxError(   R   R>   t   infilet   parsert   eventR   t	   elem_namet   thisdatat   ntsR   R   RD   R5   t   e(    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyR   ~   sH    c         C   s   |  j  j É  S(   s,   return list of metadata file types available(   R8   t   keys(   R   (    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyt	   fileTypes¨   s    c         C   s+   | |  j  k r |  j  | St d | Ç d  S(   Ns#   requested datatype %s not available(   R8   R   (   R   R
   (    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyt   getData∞   s    c         C   sç  d |  j  GHd |  j GHx- t |  j É D] } d | |  j | f GHq( W|  j d k	 rf d |  j GHn  |  j d rï d d j t |  j d É É GHn  |  j d rı xP t |  j d É D]8 } d	 | GH|  j d | } d
 d j t | É É GHq∂ Wn  d GHxå t |  j É  É D]x } |  j	 | } d | j
 GHd | j GHd | j  GHd | j GHd | j GHd | j GHd | j GHd | j GHd GHqWd S(   s   dump fun outputs   file timestamp: %ss   file length   : %ss   file checksum : %s/%ss   revision: %sR4   s   tags content: %ss   , R5   s   tags distro: %ss
     tags: %ss   
---- Data ----s     datatype: %ss       location     : %s %ss       timestamp    : %ss       size         : %ss       open size    : %ss       checksum     : %s - %ss       open checksum: %s - %ss       dbversion    : %sR#   N(   R   R:   t   sortedR9   R;   R   R=   t   joinRX   R8   R
   R   R   R   R   R   R   (   R   t   csumR5   R=   t   ftRT   (    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyt   dump∂   s2    "	c   
      C   sñ  d } d } | | 7} |  j  r? d t |  j  É } | | 7} n  |  j d sf |  j d sf |  j d r^d } x/ |  j d D]  } d t | É } | | 7} qz Wx/ |  j d D]  } d	 t | É } | | 7} q¨ Wxt |  j d D]e \ } } t | É } | r%d
 t | d t Ét | d É f } n d t | d É } | | 7} qﬁ W| d 7} | | 7} n  x' |  j j É  D] }	 | |	 j É  7} qnW| d 7} | S(   NR#   sã   <?xml version="1.0" encoding="UTF-8"?>
<repomd xmlns="http://linux.duke.edu/metadata/repo" xmlns:rpm="http://linux.duke.edu/metadata/rpm">
s    <revision>%s</revision>
R4   R5   R6   s    <tags>
s      <content>%s</content>
s      <repo>%s</repo>
s"      <distro cpeid="%s">%s</distro>
R   i    s      <distro>%s</distro>
s	    </tags>
s
   </repomd>
(   R;   R   R=   t   listR$   R8   t   valuesR/   (
   R   R'   R(   t   revR=   t   itemR   RD   t   itemlistt   md(    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyR/   “   s6    
	'&

N(
   R0   R1   R2   R   R   R   RX   RY   R^   R/   (    (    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyR3   m   s   	.			c          C   sq   y4 d t  j d GHt d t  j d É }  |  j É  Wn6 t k
 rl t  j d t  j d IJt  j d É n Xd  S(   Ns   file          : %si   R7   s   newcomps.py: No such file:'%s'(   t   syst   argvR3   R^   RH   t   stderrt   exit(   t   p(    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyt   mainˆ   s    t   __main__(    (    (   t   yum.miscR    RI   t   ErrorsR   Re   RE   t   miscR   R   R   R	   R3   Rj   R0   (    (    (    s4   /usr/lib/python2.7/dist-packages/yum/repoMDObject.pyt   <module>   s   	Qâ	                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/dist-packages/yum/repos.py                                                        0100644 0000000 0000000 00000030535 12451005146 017433  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2004 Duke University 

import re
import fnmatch
import types
import logging
import misc

import Errors
from packageSack import MetaSack

from weakref import proxy as weakref

class _wrap_ayum_getKeyForRepo:
    """ This is a wrapper for calling YumBase.getKeyForRepo() because
        otherwise we take a real reference through the bound method and
        that is d00m (this applies to YumBase and RepoStorage, hence why
        we have a seperate class).
        A "better" fix might be to explicitly pass the YumBase instance to
        the callback ... API change! """
    def __init__(self, ayum, ca=False):
        self.ayum = weakref(ayum)
        self.ca = ca
    def __call__(self, repo, callback=None):
        if self.ca:
            return self.ayum.getCAKeyForRepo(repo, callback)
        return self.ayum.getKeyForRepo(repo, callback)

class RepoStorage:
    """This class contains multiple repositories and core configuration data
       about them."""
       
    def __init__(self, ayum):
        self.repos = {} # list of repos by repoid pointing a repo object 
                        # of repo options/misc data
        self.callback = None # progress callback used for populateSack() for importing the xml files
        self.cache = 0
        self.pkgSack = MetaSack()
        self.logger = logging.getLogger("yum.RepoStorage")

        self._setup = False

        self.ayum = weakref(ayum)
        # callbacks for handling gpg key imports for repomd.xml sig checks
        # need to be set from outside of the repos object to do anything
        # even quasi-useful
        # defaults to what is probably sane-ish
        self.gpg_import_func = _wrap_ayum_getKeyForRepo(ayum)
        self.gpgca_import_func = _wrap_ayum_getKeyForRepo(ayum, ca=True)
        self.confirm_func = None

        # This allow listEnabled() to be O(1) most of the time.
        self._cache_enabled_repos = []
        self.quick_enable_disable = {}

    def doSetup(self, thisrepo = None):
        
        self.ayum.plugins.run('prereposetup')
        
        if thisrepo is None:
            repos = self.listEnabled()
        else:
            repos = self.findRepos(thisrepo)

        if len(repos) < 1:
            self.logger.debug('No Repositories Available to Set Up')

        for repo in repos:
            repo.setup(self.ayum.conf.cache, self.ayum.mediagrabber,
                   gpg_import_func = self.gpg_import_func, confirm_func=self.confirm_func,
                   gpgca_import_func = self.gpgca_import_func)
            # if we come back from setup NOT enabled then mark as disabled
            # so nothing else touches us
            if not repo.enabled:
                self.disableRepo(repo.id)
                
        self._setup = True
        self.ayum.plugins.run('postreposetup')
        
    def __str__(self):
        return str(self.repos.keys())

    def __del__(self):
        self.close()

    def close(self):
        for repo in self.repos.values():
            repo.close()

    def add(self, repoobj):
        if repoobj.id in self.repos:
            raise Errors.DuplicateRepoError, 'Repository %s is listed more than once in the configuration' % (repoobj.id)
        self.repos[repoobj.id] = repoobj
        if hasattr(repoobj, 'quick_enable_disable'):
            self.quick_enable_disable.update(repoobj.quick_enable_disable)
            repoobj.quick_enable_disable = self.quick_enable_disable
        else:
            self._cache_enabled_repos = None
        #  At least pulp reuses RepoStorage but doesn't have a "real" YumBase()
        # so we can't guarantee new YumBase() attrs. exist.
        if not hasattr(self.ayum, '_override_sigchecks'):
            repoobj._override_sigchecks = False
        else:
            repoobj._override_sigchecks = self.ayum._override_sigchecks

    def delete(self, repoid):
        if repoid in self.repos:
            thisrepo = self.repos[repoid]
            thisrepo.close()
            del self.repos[repoid]
            
    def sort(self):
        repolist = self.repos.values()
        repolist.sort()
        return repolist
        
    def getRepo(self, repoid):
        try:
            return self.repos[repoid]
        except KeyError, e:
            raise Errors.RepoError, \
                'Error getting repository data for %s, repository not found' % (repoid)

    def findRepos(self,pattern):
        """find all repositories matching fnmatch `pattern`"""

        result = []
        
        for item in pattern.split(','):
            item = item.strip()
            match = re.compile(fnmatch.translate(item)).match
            for name,repo in self.repos.items():
                if match(name):
                    result.append(repo)
        return result
        
    def disableRepo(self, repoid):
        """disable a repository from use
        
        fnmatch wildcards may be used to disable a group of repositories.
        returns repoid of disabled repos as list
        """
        repos = []
        if misc.re_glob(repoid) or repoid.find(',') != -1:
            for repo in self.findRepos(repoid):
                repos.append(repo.id)
                repo.disable()
        else:
            thisrepo = self.getRepo(repoid)
            repos.append(thisrepo.id)
            thisrepo.disable()
        
        return repos
        
    def enableRepo(self, repoid):
        """enable a repository for use
        
        fnmatch wildcards may be used to enable a group of repositories.
        returns repoid of enables repos as list
        """
        repos = []
        if misc.re_glob(repoid) or repoid.find(',') != -1:
            for repo in self.findRepos(repoid):
                repos.append(repo.id)
                repo.enable()
        else:
            thisrepo = self.getRepo(repoid)
            repos.append(thisrepo.id)
            thisrepo.enable()
        
        return repos
        
    def listEnabled(self):
        """return list of enabled repo objects"""

        if (self._cache_enabled_repos is not None and
            not self.quick_enable_disable):
            return self._cache_enabled_repos

        returnlist = []
        for repo in self.repos.values():
            if repo.isEnabled():
                returnlist.append(repo)

        returnlist.sort()

        if self._cache_enabled_repos is not None:
            self._cache_enabled_repos = returnlist
            self.quick_enable_disable.clear()
        return returnlist

    def listGroupsEnabled(self):
        """return a list of repo objects that have groups enabled"""
        returnlist = []
        for repo in self.listEnabled():
            if repo.enablegroups:
                returnlist.append(repo)

        return returnlist

    def setCache(self, cacheval):
        """sets cache value in all repos"""
        self.cache = cacheval
        for repo in self.repos.values():
            repo.cache = cacheval

    def setCacheDir(self, cachedir):
        """sets the cachedir value in all repos"""
        
        self._cachedir = cachedir
        for repo in self.repos.values():
            repo.old_base_cache_dir = repo.basecachedir
            repo.basecachedir = cachedir


    def setProgressBar(self, obj):
        """sets the progress bar for downloading files from repos"""
        
        for repo in self.repos.values():
            repo.setCallback(obj)

    def setFailureCallback(self, obj):
        """sets the failure callback for all repos"""
        
        for repo in self.repos.values():
            repo.setFailureObj(obj)

    def setMirrorFailureCallback(self, obj):
        """sets the failure callback for all mirrors"""
        
        for repo in self.repos.values():
            repo.setMirrorFailureObj(obj)

    def setInterruptCallback(self, callback):
        for repo in self.repos.values():
            repo.setInterruptCallback(callback)

    def getPackageSack(self):
        return self.pkgSack


    def populateSack(self, which='enabled', mdtype='metadata', callback=None, cacheonly=0):
        """
        This populates the package sack from the repositories, two optional 
        arguments:
            - which='repoid, enabled, all'
            - mdtype='metadata, filelists, otherdata, all'
        """

        if not self._setup:
            self.doSetup()

        if not callback:
            callback = self.callback
        myrepos = []
        if which == 'enabled':
            myrepos = self.listEnabled()
        elif which == 'all':
            myrepos = self.repos.values()
        else:
            if type(which) == types.ListType:
                for repo in which:
                    if isinstance(repo, Repository):
                        myrepos.append(repo)
                    else:
                        repobj = self.getRepo(repo)
                        myrepos.append(repobj)
            elif type(which) == types.StringType:
                repobj = self.getRepo(which)
                myrepos.append(repobj)

        if mdtype == 'all':
            data = ['metadata', 'filelists', 'otherdata']
        else:
            data = [ mdtype ]
         
        for repo in myrepos:
            sack = repo.getPackageSack()
            try:
                sack.populate(repo, mdtype, callback, cacheonly)
            except Errors.RepoError, e:
                if mdtype in ['all', 'metadata'] and repo.skip_if_unavailable:
                    self.disableRepo(repo.id)
                else:
                    raise
            else:
                self.pkgSack.addSack(repo.id, sack)


class Repository:
    """this is an actual repository object"""       

    def __init__(self, repoid):
        self.id = repoid
        self.quick_enable_disable = {}
        self.disable()
        self._xml2sqlite_local = False

    def __cmp__(self, other):
        """ Sort base class repos. by alphanumeric on their id, also
            see __cmp__ in YumRepository(). """
        if self.id > other.id:
            return 1
        elif self.id < other.id:
            return -1
        else:
            return 0

    def __str__(self):
        return self.id

    def __hash__(self):
        return hash(self.id)
        
    def __del__(self):
        self.close()

    def close(self):
        pass

    def setAttribute(self, key, value):
        """sets a generic attribute of this repository"""
        setattr(self, key, value)

    def getAttribute(self, key):
        return getattr(self, key, None)

    def isEnabled(self):
        enabled = self.getAttribute('enabled')
        return enabled is not None and enabled

    def enable(self):
        self.setAttribute('enabled', 1)
        self.quick_enable_disable[self.id] = True
                    
    def disable(self):
        self.setAttribute('enabled', 0)
        self.quick_enable_disable[self.id] = False

    def getExcludePkgList(self):
        excludeList = self.getAttribute('exclude')
        return excludeList or []

    def getIncludePkgList(self):
        includeList = self.getAttribute('includepkgs')
        return includeList or []

    # Abstract interface
    def ready(self):
        raise NotImplementedError()

    def getGroupLocation(self):
        raise NotImplementedError()
 
    def getPackageSack(self):
        raise NotImplementedError()

    def setup(self, cache):
        raise NotImplementedError()
                    
    def setCallback(self, callback):
        raise NotImplementedError()

    def setFailureObj(self, obj):
        raise NotImplementedError()

    def setMirrorFailureObj(self, obj):
        raise NotImplementedError()

    def getPackage(self, package, checkfunc = None, text = None, cache = True):
        raise NotImplementedError()

    def getHeader(self, package, checkfunc = None, reget = 'simple', cache = True):
        raise NotImplementedError()

                                                                                                                                                                   usr/lib/python2.7/dist-packages/yum/repos.pyc                                                       0100644 0000000 0000000 00000034477 13077704344 017622  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   s•   d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l m Z d  d l m	 Z d f  d Ñ  É  YZ
 d f  d Ñ  É  YZ d f  d	 Ñ  É  YZ d S(
   iˇˇˇˇN(   t   MetaSack(   t   proxyt   _wrap_ayum_getKeyForRepoc           B   s&   e  Z d  Z e d Ñ Z d d Ñ Z RS(   sc   This is a wrapper for calling YumBase.getKeyForRepo() because
        otherwise we take a real reference through the bound method and
        that is d00m (this applies to YumBase and RepoStorage, hence why
        we have a seperate class).
        A "better" fix might be to explicitly pass the YumBase instance to
        the callback ... API change! c         C   s   t  | É |  _ | |  _ d  S(   N(   t   weakreft   ayumt   ca(   t   selfR   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   __init__#   s    c         C   s/   |  j  r |  j j | | É S|  j j | | É S(   N(   R   R   t   getCAKeyForRepot   getKeyForRepo(   R   t   repot   callback(    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   __call__&   s    	N(   t   __name__t
   __module__t   __doc__t   FalseR   t   NoneR   (    (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR      s   t   RepoStoragec           B   s„   e  Z d  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d d d d Ñ Z RS(   sX   This class contains multiple repositories and core configuration data
       about them.c         C   sî   i  |  _  d  |  _ d |  _ t É  |  _ t j d É |  _ t	 |  _
 t | É |  _ t | É |  _ t | d t É|  _ d  |  _ g  |  _ i  |  _ d  S(   Ni    s   yum.RepoStorageR   (   t   reposR   R   t   cacheR    t   pkgSackt   loggingt	   getLoggert   loggerR   t   _setupR   R   R   t   gpg_import_funct   Truet   gpgca_import_funct   confirm_funct   _cache_enabled_repost   quick_enable_disable(   R   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR   /   s    						c      
   C   sÈ   |  j  j j d É | d  k r. |  j É  } n |  j | É } t | É d k  rb |  j j d É n  xd | D]\ } | j	 |  j  j
 j |  j  j d |  j d |  j d |  j É| j si |  j | j É qi qi Wt |  _ |  j  j j d É d  S(   Nt   prereposetupi   s#   No Repositories Available to Set UpR   R   R   t   postreposetup(   R   t   pluginst   runR   t   listEnabledt	   findRepost   lenR   t   debugt   setupt   confR   t   mediagrabberR   R   R   t   enabledt   disableRepot   idR   R   (   R   t   thisrepoR   R
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   doSetupF   s    
		c         C   s   t  |  j j É  É S(   N(   t   strR   t   keys(   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   __str__^   s    c         C   s   |  j  É  d  S(   N(   t   close(   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   __del__a   s    c         C   s(   x! |  j  j É  D] } | j É  q Wd  S(   N(   R   t   valuesR3   (   R   R
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR3   d   s    c         C   s£   | j  |  j k r( t j d | j  Ç n  | |  j | j  <t | d É ri |  j j | j É |  j | _ n	 d  |  _ t |  j	 d É sê t
 | _ n |  j	 j | _ d  S(   Ns;   Repository %s is listed more than once in the configurationR   t   _override_sigchecks(   R-   R   t   Errorst   DuplicateRepoErrort   hasattrR   t   updateR   R   R   R   R6   (   R   t   repoobj(    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   addh   s    	c         C   s7   | |  j  k r3 |  j  | } | j É  |  j  | =n  d  S(   N(   R   R3   (   R   t   repoidR.   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   deletex   s    
c         C   s   |  j  j É  } | j É  | S(   N(   R   R5   t   sort(   R   t   repolist(    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR?   ~   s    
c         C   s9   y |  j  | SWn# t k
 r4 } t j d | Ç n Xd  S(   Ns:   Error getting repository data for %s, repository not found(   R   t   KeyErrorR7   t	   RepoError(   R   R=   t   e(    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   getRepoÉ   s
    c         C   sá   g  } xz | j  d É D]i } | j É  } t j t j | É É j } x9 |  j j É  D]( \ } } | | É rS | j	 | É qS qS Wq W| S(   s0   find all repositories matching fnmatch `pattern`t   ,(
   t   splitt   stript   ret   compilet   fnmatcht	   translatet   matchR   t   itemst   append(   R   t   patternt   resultt   itemRL   t   nameR
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR%   ä   s    c         C   sé   g  } t  j | É s* | j d É d k ra x] |  j | É D]  } | j | j É | j É  q: Wn) |  j | É } | j | j É | j É  | S(   s™   disable a repository from use
        
        fnmatch wildcards may be used to disable a group of repositories.
        returns repoid of disabled repos as list
        RE   iˇˇˇˇ(   t   misct   re_globt   findR%   RN   R-   t   disableRD   (   R   R=   R   R
   R.   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR,   ó   s    $
c         C   sé   g  } t  j | É s* | j d É d k ra x] |  j | É D]  } | j | j É | j É  q: Wn) |  j | É } | j | j É | j É  | S(   s¶   enable a repository for use
        
        fnmatch wildcards may be used to enable a group of repositories.
        returns repoid of enables repos as list
        RE   iˇˇˇˇ(   RS   RT   RU   R%   RN   R-   t   enableRD   (   R   R=   R   R
   R.   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt
   enableRepo©   s    $
c         C   sí   |  j  d k	 r  |  j r  |  j  Sg  } x3 |  j j É  D]" } | j É  r6 | j | É q6 q6 W| j É  |  j  d k	 ré | |  _  |  j j É  n  | S(   s#   return list of enabled repo objectsN(	   R   R   R   R   R5   t	   isEnabledRN   R?   t   clear(   R   t
   returnlistR
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR$   ª   s    

	c         C   s:   g  } x- |  j  É  D] } | j r | j | É q q W| S(   s6   return a list of repo objects that have groups enabled(   R$   t   enablegroupsRN   (   R   R[   R
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   listGroupsEnabledŒ   s
    	c         C   s0   | |  _  x  |  j j É  D] } | | _  q Wd S(   s   sets cache value in all reposN(   R   R   R5   (   R   t   cachevalR
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   setCache◊   s    	c         C   s<   | |  _  x, |  j j É  D] } | j | _ | | _ q Wd S(   s$   sets the cachedir value in all reposN(   t	   _cachedirR   R5   t   basecachedirt   old_base_cache_dir(   R   t   cachedirR
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   setCacheDir›   s    	c         C   s+   x$ |  j  j É  D] } | j | É q Wd S(   s6   sets the progress bar for downloading files from reposN(   R   R5   t   setCallback(   R   t   objR
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   setProgressBarÊ   s    c         C   s+   x$ |  j  j É  D] } | j | É q Wd S(   s'   sets the failure callback for all reposN(   R   R5   t   setFailureObj(   R   Rf   R
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   setFailureCallbackÏ   s    c         C   s+   x$ |  j  j É  D] } | j | É q Wd S(   s)   sets the failure callback for all mirrorsN(   R   R5   t   setMirrorFailureObj(   R   Rf   R
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   setMirrorFailureCallbackÚ   s    c         C   s+   x$ |  j  j É  D] } | j | É q Wd  S(   N(   R   R5   t   setInterruptCallback(   R   R   R
   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyRl   ¯   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   getPackageSack¸   s    R+   t   metadatai    c         C   sª  |  j  s |  j É  n  | s( |  j } n  g  } | d k rI |  j É  } n∂ | d k rg |  j j É  } nò t | É t j k rÀ xÄ | D]A } t	 | t
 É r® | j | É qÉ |  j | É } | j | É qÉ Wn4 t | É t j k rˇ |  j | É } | j | É n  | d k rd d d g } n	 | g } xé | D]Ü } | j É  }	 y |	 j | | | | É WnA t j k
 rú}
 | d k rñ| j rñ|  j | j É q≥Ç  q-X|  j j | j |	 É q-Wd S(   sœ   
        This populates the package sack from the repositories, two optional 
        arguments:
            - which='repoid, enabled, all'
            - mdtype='metadata, filelists, otherdata, all'
        R+   t   allRn   t	   filelistst	   otherdataN(   s   allRn   (   R   R/   R   R$   R   R5   t   typet   typest   ListTypet
   isinstancet
   RepositoryRN   RD   t
   StringTypeRm   t   populateR7   RB   t   skip_if_unavailableR,   R-   R   t   addSack(   R   t   whicht   mdtypeR   t	   cacheonlyt   myreposR
   t   repobjt   datat   sackRC   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   populateSack   s<    		N(   R   R   R   R   R   R/   R2   R4   R3   R<   R>   R?   RD   R%   R,   RX   R$   R]   R_   Rd   Rg   Ri   Rk   Rl   Rm   RÇ   (    (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR   +   s.   																						Rv   c           B   sÊ   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d e d Ñ Z d d e d Ñ Z RS(   s#   this is an actual repository objectc         C   s)   | |  _  i  |  _ |  j É  t |  _ d  S(   N(   R-   R   RV   R   t   _xml2sqlite_local(   R   R=   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR   3  s    		
c         C   s4   |  j  | j  k r d S|  j  | j  k  r, d Sd Sd S(   sf    Sort base class repos. by alphanumeric on their id, also
            see __cmp__ in YumRepository(). i   iˇˇˇˇi    N(   R-   (   R   t   other(    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   __cmp__9  s
    c         C   s   |  j  S(   N(   R-   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR2   C  s    c         C   s   t  |  j É S(   N(   t   hashR-   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   __hash__F  s    c         C   s   |  j  É  d  S(   N(   R3   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR4   I  s    c         C   s   d  S(   N(    (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR3   L  s    c         C   s   t  |  | | É d S(   s+   sets a generic attribute of this repositoryN(   t   setattr(   R   t   keyt   value(    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   setAttributeO  s    c         C   s   t  |  | d  É S(   N(   t   getattrR   (   R   Râ   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   getAttributeS  s    c         C   s   |  j  d É } | d  k	 o | S(   NR+   (   Rç   R   (   R   R+   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyRY   V  s    c         C   s$   |  j  d d É t |  j |  j <d  S(   NR+   i   (   Rã   R   R   R-   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyRW   Z  s    c         C   s$   |  j  d d É t |  j |  j <d  S(   NR+   i    (   Rã   R   R   R-   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyRV   ^  s    c         C   s   |  j  d É } | p g  S(   Nt   exclude(   Rç   (   R   t   excludeList(    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   getExcludePkgListb  s    c         C   s   |  j  d É } | p g  S(   Nt   includepkgs(   Rç   (   R   t   includeList(    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   getIncludePkgListf  s    c         C   s   t  É  Ç d  S(   N(   t   NotImplementedError(   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   readyk  s    c         C   s   t  É  Ç d  S(   N(   Rî   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   getGroupLocationn  s    c         C   s   t  É  Ç d  S(   N(   Rî   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyRm   q  s    c         C   s   t  É  Ç d  S(   N(   Rî   (   R   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyR(   t  s    c         C   s   t  É  Ç d  S(   N(   Rî   (   R   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyRe   w  s    c         C   s   t  É  Ç d  S(   N(   Rî   (   R   Rf   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyRh   z  s    c         C   s   t  É  Ç d  S(   N(   Rî   (   R   Rf   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyRj   }  s    c         C   s   t  É  Ç d  S(   N(   Rî   (   R   t   packaget	   checkfunct   textR   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt
   getPackageÄ  s    t   simplec         C   s   t  É  Ç d  S(   N(   Rî   (   R   Ró   Rò   t   regetR   (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt	   getHeaderÉ  s    N(   R   R   R   R   RÖ   R2   Rá   R4   R3   Rã   Rç   RY   RW   RV   Rê   Rì   Rï   Rñ   Rm   R(   Re   Rh   Rj   R   R   Rö   Rù   (    (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyRv   0  s.   		
																		(   RH   RJ   Rs   R   RS   R7   t   packageSackR    R   R   R   R   Rv   (    (    (    s-   /usr/lib/python2.7/dist-packages/yum/repos.pyt   <module>   s   ˇ                                                                                                                                                                                                  usr/lib/python2.7/dist-packages/yum/rpmsack.py                                                      0100644 0000000 0000000 00000202615 12451005146 017743  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import rpm
import types
import warnings
import glob
import os
import os.path

from rpmUtils import miscutils
from rpmUtils import arch
from rpmUtils.transaction import initReadOnlyTransaction
import misc
import Errors
from packages import YumInstalledPackage, parsePackages
from packageSack import PackageSackBase, PackageSackVersion

# For returnPackages(patterns=)
import fnmatch
import re

from yum.i18n import to_unicode, _
import constants

import yum.depsolve

def _open_no_umask(*args):
    """ Annoying people like to set umask's for root, which screws everything
        up for user readable stuff. """
    oumask = os.umask(022)
    try:
        ret = open(*args)
    finally:
        os.umask(oumask)

    return ret

def _iopen(*args):
    """ IOError wrapper BS for open, stupid exceptions. """
    try:
        ret = open(*args)
    except IOError, e:
        return None, e
    return ret, None


class RPMInstalledPackage(YumInstalledPackage):

    def __init__(self, rpmhdr, index, rpmdb):
        self._has_hdr = True
        YumInstalledPackage.__init__(self, rpmhdr, yumdb=rpmdb.yumdb)

        self.idx   = index
        self.rpmdb = rpmdb

        self._has_hdr = False
        del self.hdr

    def _get_hdr(self):
        # Note that we can't use hasattr(self, 'hdr') or we'll recurse
        if self._has_hdr:
            return self.hdr

        ts = self.rpmdb.readOnlyTS()
        mi = ts.dbMatch(0, self.idx)
        try:
            return mi.next()
        except StopIteration:
            raise Errors.PackageSackError, 'Rpmdb changed underneath us'

    def __getattr__(self, varname):
        # If these existed, then we wouldn't get here...
        # Prevent access of __foo__, _cached_foo etc from loading the header 
        if varname.startswith('_'):
            raise AttributeError, "%s has no attribute %s" % (self, varname)

        if varname != 'hdr': # Don't cache the hdr, unless explicitly requested
            #  Note that we don't even cache the .blah value, but looking up the
            # header is _really_ fast so it's not obvious any of it is worth it.
            # This is different to prco etc. data, which is loaded separately.
            val = self._get_hdr()
        else:
            self.hdr = val = self._get_hdr()
            self._has_hdr = True
        if varname != 'hdr':   #  This is unusual, for anything that happens
            val = val[varname] # a lot we should preload at __init__.
                               # Also note that pkg.no_value raises KeyError.

        return val
    
    def requiring_packages(self):
        """return list of installed pkgs requiring this package"""
        pkgset = set()
        for (reqn, reqf, reqevr) in self.provides:
            for pkg in self.rpmdb.getRequires(reqn,reqf,reqevr):
                if pkg != self:
                    pkgset.add(pkg)
                
        for fn in self.filelist + self.dirlist:
            for pkg in self.rpmdb.getRequires(fn, None, (None, None, None)):
                if pkg != self:
                    pkgset.add(pkg)
                
        return list(pkgset)
        

    def required_packages(self):
        pkgset = set()
        for (reqn, reqf, reqevr) in self.requires:
            for pkg in self.rpmdb.getProvides(reqn, reqf, reqevr):
                if pkg != self:
                    pkgset.add(pkg)
        
        return list(pkgset)
        
class RPMDBProblem:
    '''
    Represents a problem in the rpmdb, from the check_*() functions.
    '''
    def __init__(self, pkg, problem, **kwargs):
        self.pkg = pkg
        self.problem = problem
        for kwarg in kwargs:
            setattr(self, kwarg, kwargs[kwarg])

    def __cmp__(self, other):
        if other is None:
            return 1
        return cmp(self.pkg, other.pkg) or cmp(self.problem, other.problem)


class RPMDBProblemDependency(RPMDBProblem):
    def __str__(self):
        if self.problem == 'requires':
            return "%s %s %s" % (self.pkg, _('has missing requires of'),
                                 self.missing)

        return "%s %s %s: %s" % (self.pkg, _('has installed conflicts'),
                                 self.found,', '.join(map(str, self.conflicts)))


class RPMDBProblemDuplicate(RPMDBProblem):
    def __init__(self, pkg, **kwargs):
        RPMDBProblem.__init__(self, pkg, "duplicate", **kwargs)

    def __str__(self):
        return _("%s is a duplicate with %s") % (self.pkg, self.duplicate)


class RPMDBProblemObsoleted(RPMDBProblem):
    def __init__(self, pkg, **kwargs):
        RPMDBProblem.__init__(self, pkg, "obsoleted", **kwargs)

    def __str__(self):
        return _("%s is obsoleted by %s") % (self.pkg, self.obsoleter)


class RPMDBProblemProvides(RPMDBProblem):
    def __init__(self, pkg, **kwargs):
        RPMDBProblem.__init__(self, pkg, "provides", **kwargs)

    def __str__(self):
        return _("%s provides %s but it cannot be found") % (self.pkg,
                                                             self.provide)


class RPMDBPackageSack(PackageSackBase):
    '''
    Represent rpmdb as a packagesack
    '''

    DEP_TABLE = { 
            'requires'  : (rpm.RPMTAG_REQUIRENAME,
                           rpm.RPMTAG_REQUIREVERSION,
                           rpm.RPMTAG_REQUIREFLAGS),
            'provides'  : (rpm.RPMTAG_PROVIDENAME,
                           rpm.RPMTAG_PROVIDEVERSION,
                           rpm.RPMTAG_PROVIDEFLAGS),
            'conflicts' : (rpm.RPMTAG_CONFLICTNAME,
                           rpm.RPMTAG_CONFLICTVERSION,
                           rpm.RPMTAG_CONFLICTFLAGS),
            'obsoletes' : (rpm.RPMTAG_OBSOLETENAME,
                           rpm.RPMTAG_OBSOLETEVERSION,
                           rpm.RPMTAG_OBSOLETEFLAGS)
            }

    # Do we want to cache rpmdb data in a file, for later use?
    __cache_rpmdb__ = True

    def __init__(self, root='/', releasever=None, cachedir=None,
                 persistdir='/var/lib/yum'):
        self.root = root
        self._idx2pkg = {}
        self._name2pkg = {}
        self._pkgnames_loaded = set()
        self._tup2pkg = {}
        self._completely_loaded = False
        self._pkgname_fails = set()
        self._pkgmatch_fails = set()
        self._provmatch_fails = set()
        self._simple_pkgtup_list = []
        self._get_pro_cache = {}
        self._get_req_cache  = {}
        self._loaded_gpg_keys = False
        if cachedir is None:
            cachedir = persistdir + "/rpmdb-indexes"
        self.setCacheDir(cachedir)
        if not os.path.normpath(persistdir).startswith(self.root):
            self._persistdir = root +  '/' + persistdir
        else:
            self._persistdir = persistdir
        if hasattr(rpm, 'expandMacro'):
            dbpath = rpm.expandMacro('%_dbpath')
        else:
            dbpath = '/var/lib/rpm'
        self._rpmdbpath = os.path.normpath(root + '/' + dbpath)
        self._have_cached_rpmdbv_data = None
        self._cached_conflicts_data = None
        # Store the result of what happens, if a transaction completes.
        self._trans_cache_store = {}
        self.ts = None
        self.releasever = releasever
        self.auto_close = False # this forces a self.ts.close() after
                                     # most operations so it doesn't leave
                                     # any lingering locks.
        self._cached_rpmdb_mtime = None

        self._cache = {
            'provides' : { },
            'requires' : { },
            'conflicts' : { },
            'obsoletes' : { },
            }
        
        addldb_path = os.path.normpath(self._persistdir + '/yumdb')
        version_path = os.path.normpath(cachedir + '/version')
        self.yumdb = RPMDBAdditionalData(db_path=addldb_path,
                                         version_path=version_path)

    def _get_pkglist(self):
        '''Getter for the pkglist property. 
        Returns a list of package tuples.
        '''
        if not self._simple_pkgtup_list:
            csumpkgtups = self.preloadPackageChecksums(load_packages=False)
            if csumpkgtups is not None:
                self._simple_pkgtup_list = csumpkgtups.keys()

        if not self._simple_pkgtup_list:
            for (hdr, mi) in self._get_packages():
                self._simple_pkgtup_list.append(self._hdr2pkgTuple(hdr))
            
        return self._simple_pkgtup_list

    pkglist = property(_get_pkglist, None)

    def dropCachedData(self):
        """ Drop all cached data, this is a big perf. hit if we need to load
            the data back in again. Also note that if we ever call this while
            a transaction is ongoing we'll have multiple copies of packages
            which is _bad_. """
        self._idx2pkg = {}
        self._name2pkg = {}
        self._pkgnames_loaded = set()
        self._tup2pkg = {}
        self._completely_loaded = False
        self._pkgmatch_fails = set()
        self._pkgname_fails = set()
        self._provmatch_fails = set()
        self._simple_pkgtup_list = []
        self._get_pro_cache = {}
        self._get_req_cache = {}
        #  We can be called on python shutdown (due to yb.__del__), at which
        # point other modules might not be available.
        if misc is not None:
            misc.unshare_data()
        self._cache = {
            'provides' : { },
            'requires' : { },
            'conflicts' : { },
            'obsoletes' : { },
            }
        self._have_cached_rpmdbv_data = None
        self._cached_conflicts_data = None
        self.transactionReset() # Should do nothing, but meh...
        self._cached_rpmdb_mtime = None

    def dropCachedDataPostTransaction(self, txmbrs):
        """ Drop cached data that is assocciated with the given transaction,
            this tries to keep as much data as possible and even does a
            "preload" on the checksums. This should be called once, when a
            transaction is complete. """
        # -- Below -- self._idx2pkg = {}
        # -- Below -- self._name2pkg = {}
        # -- Below -- self._pkgnames_loaded = set()
        # -- Below -- self._tup2pkg = {}
        self._completely_loaded = False
        self._pkgmatch_fails = set()
        # -- Below -- self._pkgname_fails = set()
        self._provmatch_fails = set()
        self._simple_pkgtup_list = []
        self._get_pro_cache = {}
        self._get_req_cache = {}
        #  We can be called on python shutdown (due to yb.__del__), at which
        # point other modules might not be available.
        if misc is not None:
            misc.unshare_data()
        self._cache = {
            'provides' : { },
            'requires' : { },
            'conflicts' : { },
            'obsoletes' : { },
            }
        self._have_cached_rpmdbv_data = None
        self._cached_conflicts_data = None
        self.transactionReset() # Should do nothing, but meh...

        #  We are keeping some data from before, and sometimes (Eg. remove only)
        # we never open the rpmdb again ... so get the mtime now.
        rpmdbfname  = self._rpmdbpath + "/Packages"
        self._cached_rpmdb_mtime = os.path.getmtime(rpmdbfname)

        def _safe_del(x, y):
            """ Make sure we never traceback here, because it screws our yumdb
                if we do. """
            # Maybe use x.pop(y, None) ?
            if y in x:
                del x[y]

        precache = []
        for txmbr in txmbrs:
            self._pkgnames_loaded.discard(txmbr.name)
            _safe_del(self._name2pkg, txmbr.name)

            if txmbr.output_state in constants.TS_INSTALL_STATES:
                self._pkgname_fails.discard(txmbr.name)
                precache.append(txmbr)
                if txmbr.reinstall:
                    #  For reinstall packages we have:
                    #
                    # 1. one txmbr: the new install.
                    # 2. two rpmdb entries: the new; the old;
                    #
                    # ...so we need to remove the old one, given only the new
                    # one.
                    ipo = self._tup2pkg[txmbr.pkgtup]
                    _safe_del(self._idx2pkg, ipo.idx)
                    _safe_del(self._tup2pkg, txmbr.pkgtup)

            if txmbr.output_state in constants.TS_REMOVE_STATES:
                _safe_del(self._idx2pkg, txmbr.po.idx)
                _safe_del(self._tup2pkg, txmbr.pkgtup)

        for txmbr in precache:
            (n, a, e, v, r) = txmbr.pkgtup
            pkg = self.searchNevra(n, e, v, r, a)
            if not pkg:
                # Wibble?
                self._deal_with_bad_rpmdbcache("dCDPT(pkg checksums)")
                continue

            pkg = pkg[0]
            csum = txmbr.po.returnIdSum()
            if csum is None:
                continue

            (T, D) = (str(csum[0]), str(csum[1]))
            if ('checksum_type' in pkg.yumdb_info._read_cached_data or
                'checksum_data' in pkg.yumdb_info._read_cached_data):
                continue
            pkg.yumdb_info._read_cached_data['checksum_type'] = T
            pkg.yumdb_info._read_cached_data['checksum_data'] = D

    def setCacheDir(self, cachedir):
        """ Sets the internal cachedir value for the rpmdb, to be the
            "rpmdb-indexes" directory in the persisent yum storage. """
        if not os.path.normpath(cachedir).startswith(self.root):
            self._cachedir = self.root + '/' + cachedir
        else:
            self._cachedir = '/' + cachedir

        if hasattr(self, 'yumdb'): # Need to keep this upto date, after init.
            version_path = os.path.normpath(self._cachedir + '/version')
            self.yumdb.conf.version_path = version_path

    def readOnlyTS(self):
        if not self.ts:
            self.ts =  initReadOnlyTransaction(root=self.root)
        if not self.ts.open:
            self.ts = initReadOnlyTransaction(root=self.root)
        return self.ts

    def buildIndexes(self):
        # Not used here
        return

    def _checkIndexes(self, failure='error'):
        # Not used here
        return

    def delPackage(self, obj):
        # Not supported with this sack type
        pass

    def searchAll(self, name, query_type='like'):
        result = {}

        # check provides
        tag = self.DEP_TABLE['provides'][0]
        mi = self._get_packages(patterns=[(tag, rpm.RPMMIRE_GLOB, name)])
        for hdr, idx in mi:
            pkg = self._makePackageObject(hdr, idx)
            result.setdefault(pkg.pkgid, pkg)

        fileresults = self.searchFiles(name)
        for pkg in fileresults:
            result.setdefault(pkg.pkgid, pkg)
        
        return result.values()

    def searchFiles(self, name):
        """search the filelists in the rpms for anything matching name"""

        result = {}
        
        name = os.path.normpath(name)
        # Note that globs can't be done. As of 4.8.1:
        #   mi.pattern('basenames', rpm.RPMMIRE_GLOB, name)
        # ...produces no results.

        for hdr, idx in self._get_packages('basenames', name):
            pkg = self._makePackageObject(hdr, idx)
            result.setdefault(pkg.pkgid, pkg)

        return result.values()
        
    def searchPrco(self, name, prcotype):

        result = self._cache[prcotype].get(name)
        if result is not None:
            return result
        (n,f,(e,v,r)) = misc.string_to_prco_tuple(name)
        glob = False
        
        if misc.re_glob(n):
            glob = True
            
        result = {}
        tag = self.DEP_TABLE[prcotype][0]
        for hdr, idx in self._get_packages(tag, misc.to_utf8(n)):
            po = self._makePackageObject(hdr, idx)
            if not glob:
                if po.checkPrco(prcotype, (n, f, (e,v,r))):
                    result[po.pkgid] = po
            else:
                result[po.pkgid] = po

        # If it's not a provides or filename, we are done
        if prcotype == 'provides' and name[0] == '/':
            fileresults = self.searchFiles(name)
            for pkg in fileresults:
                result[pkg.pkgid] = pkg
        
        result = result.values()
        self._cache[prcotype][name] = result

        return result

    def searchProvides(self, name):
        if name in self._provmatch_fails:
            return []
        ret = self.searchPrco(name, 'provides')
        if not ret:
            self._provmatch_fails.add(name)
        return ret

    def searchRequires(self, name):
        return self.searchPrco(name, 'requires')

    def searchObsoletes(self, name):
        return self.searchPrco(name, 'obsoletes')

    def searchConflicts(self, name):
        return self.searchPrco(name, 'conflicts')

    def simplePkgList(self):
        return self.pkglist

    installed = PackageSackBase.contains

    def returnNewestByNameArch(self, naTup=None, patterns=None):

        #FIXME - should this (or any packagesack) be returning tuples?
        if not naTup:
            return
        
        (name, arch) = naTup

        allpkg = self._search(name=name, arch=arch)

        if not allpkg:
            raise Errors.PackageSackError, 'No Package Matching %s' % name

        return [ po.pkgtup for po in misc.newestInList(allpkg) ]

    def returnNewestByName(self, name=None):
        if not name:
            return

        allpkgs = self._search(name=name)

        if not allpkgs:
            raise Errors.PackageSackError, 'No Package Matching %s' % name

        return misc.newestInList(allpkgs)

    @staticmethod
    def _compile_patterns(patterns, ignore_case=False):
        if not patterns or len(patterns) > constants.PATTERNS_MAX:
            return None
        ret = []
        for pat in patterns:
            if not pat:
                continue

            qpat = pat[0]
            if qpat in ('?', '*', '['):
                qpat = None
            if ignore_case:
                if qpat is not None:
                    qpat = qpat.lower()
                ret.append((qpat, re.compile(fnmatch.translate(pat), re.I)))
            else:
                ret.append((qpat, re.compile(fnmatch.translate(pat))))
        return ret
    @staticmethod
    def _match_repattern(repatterns, hdr, ignore_case):
        """ This is basically parsePackages() but for rpm hdr objects. """
        if repatterns is None:
            return True

        for qpat, repat in repatterns:
            epoch = hdr['epoch']
            if epoch is None:
                epoch = '0'
            else:
                epoch = str(epoch)
            qname = hdr['name'][0]
            if ignore_case:
                qname = qname.lower()
            if qpat is not None and qpat != qname and qpat != epoch[0]:
                continue
            if repat.match(hdr['name']):
                return True
            if repat.match("%(name)s-%(version)s-%(release)s.%(arch)s" % hdr):
                return True
            if repat.match("%(name)s.%(arch)s" % hdr):
                return True
            if repat.match("%(name)s-%(version)s" % hdr):
                return True
            if repat.match("%(name)s-%(version)s-%(release)s" % hdr):
                return True
            if repat.match(epoch + ":%(name)s-%(version)s-%(release)s.%(arch)s"
                           % hdr):
                return True
            if repat.match("%(name)s-%(epoch)s:%(version)s-%(release)s.%(arch)s"
                           % hdr):
                return True
        return False

    def returnPackages(self, repoid=None, patterns=None, ignore_case=False):
        """Returns a list of packages. Note that the packages are
           always filtered to those matching the patterns/case. repoid is
           ignored, and is just here for compatibility with non-rpmdb sacks. """

        #  See if we can load the "patterns" via. dbMatch('name', ...) because
        # that's basically instant and walking the entire rpmdb isn't.
        #  We assume that if we get "Yum" and _something_ matches, that we have
        # _all_ the matches. IOW there can be either Yum or yum, but not BOTH.
        if not self._completely_loaded and patterns:
            ret = []
            for pat in patterns:
                #  We aren't wasting anything here, because the next bit
                # will pick up any loads :)
                pkgs = self.searchNames([pat])
                if not pkgs:
                    break
                ret.extend(pkgs)
            else:
                return ret

        ret = []
        if patterns and not ignore_case:
            tpats = []
            for pat in patterns:
                if pat in self._pkgmatch_fails:
                    continue
                if pat in self._pkgnames_loaded:
                    ret.extend(self._name2pkg[pat])
                    continue
                tpats.append(pat)
            patterns = tpats
            if not patterns:
                return ret

        if not self._completely_loaded:
            rpats = self._compile_patterns(patterns, ignore_case)
            for hdr, idx in self._get_packages():
                if self._match_repattern(rpats, hdr, ignore_case):
                    self._makePackageObject(hdr, idx)
            self._completely_loaded = patterns is None

        pkgobjlist = self._idx2pkg.values()
        # Remove gpg-pubkeys, as no sane callers expects/likes them...
        if self._loaded_gpg_keys:
            pkgobjlist = [pkg for pkg in pkgobjlist if pkg.name != 'gpg-pubkey']
        if patterns:
            pkgobjlist = parsePackages(pkgobjlist, patterns, not ignore_case)
            self._pkgmatch_fails.update(pkgobjlist[2])
            if ret:
                pkgobjlist = pkgobjlist[0] + pkgobjlist[1] + ret
            else:
                pkgobjlist = pkgobjlist[0] + pkgobjlist[1]
            for pkg in pkgobjlist:
                for pat in patterns:
                    if pkg.name == pat:
                        self._pkgnames_loaded.add(pkg.name)
        return pkgobjlist

    def _uncached_returnConflictPackages(self):
        """ Load the packages which have conflicts from the rpmdb, newer
            versions of rpm have an index here so this is as fast as
            cached (we test rpm version at cache write time). """

        if self._cached_conflicts_data is None:
            result = {}

            for hdr, idx in self._get_packages('conflictname'):
                if not hdr[rpm.RPMTAG_CONFLICTNAME]:
                    # Pre. rpm-4.9.x the above dbMatch() does nothing.
                    continue

                po = self._makePackageObject(hdr, idx)
                result[po.pkgid] = po
                if po._has_hdr:
                    continue # Unlikely, but, meh...

                po.hdr = hdr
                po._has_hdr = True
                po.conflicts
                po._has_hdr = False
                del po.hdr
            self._cached_conflicts_data = result.values()

        return self._cached_conflicts_data

    def _write_conflicts_new(self, pkgs, rpmdbv):
        if not os.access(self._cachedir, os.W_OK):
            return

        conflicts_fname = self._cachedir + '/conflicts'
        fo = _open_no_umask(conflicts_fname + '.tmp', 'w')
        fo.write("%s\n" % rpmdbv)
        fo.write("%u\n" % len(pkgs))
        for pkg in sorted(pkgs):
            for var in pkg.pkgtup:
                fo.write("%s\n" % var)
        fo.close()
        os.rename(conflicts_fname + '.tmp', conflicts_fname)

    def _write_conflicts(self, pkgs):
        rpmdbv = self.simpleVersion(main_only=True)[0]
        self._write_conflicts_new(pkgs, rpmdbv)

    def _deal_with_bad_rpmdbcache(self, caller):
        """ This shouldn't be called, but people are hitting weird stuff so
            we want to deal with it so it doesn't stay broken "forever". """
        misc.unlink_f(self._cachedir + "/version")
        misc.unlink_f(self._cachedir + '/conflicts')
        misc.unlink_f(self._cachedir + '/file-requires')
        misc.unlink_f(self._cachedir + '/pkgtups-checksums')
        #  We have a couple of options here, we can:
        #
        # . Ignore it and continue - least invasive, least likely to get any
        #   bugs fixed.
        #
        # . Ignore it and continue, when not in debug mode - Helps users doing
        #   weird things (and we won't know), but normal bugs will be seen by
        #   anyone not running directly from a package.
        #
        # . Always throw - but at least it shouldn't happen again.
        #
        if __debug__:
            raise Errors.PackageSackError, 'Rpmdb checksum is invalid: %s' % caller

    def _read_conflicts(self):
        if not self.__cache_rpmdb__:
            return None

        def _read_str(fo):
            return fo.readline()[:-1]

        conflict_fname = self._cachedir + '/conflicts'
        fo, e = _iopen(conflict_fname)
        if fo is None:
            return None
        frpmdbv = fo.readline()
        rpmdbv = self.simpleVersion(main_only=True)[0]
        if not frpmdbv or rpmdbv != frpmdbv[:-1]:
            return None

        ret = []
        try:
            # Read the conflicts...
            pkgtups_num = int(_read_str(fo))
            while pkgtups_num > 0:
                pkgtups_num -= 1

                # n, a, e, v, r
                pkgtup = (_read_str(fo), _read_str(fo),
                          _read_str(fo), _read_str(fo), _read_str(fo))
                int(pkgtup[2]) # Check epoch is valid
                ret.extend(self.searchPkgTuple(pkgtup))
            if fo.readline() != '': # Should be EOF
                return None
        except ValueError:
            self._deal_with_bad_rpmdbcache("conflicts")
            return None

        self._cached_conflicts_data = ret
        return self._cached_conflicts_data

    def transactionCacheConflictPackages(self, pkgs):
        if self.__cache_rpmdb__:
            self._trans_cache_store['conflicts'] = pkgs

    def returnConflictPackages(self):
        """ Return a list of packages that have conflicts. """
        pkgs = self._read_conflicts()
        if pkgs is None:
            pkgs = self._uncached_returnConflictPackages()
            if self.__cache_rpmdb__:
                self._write_conflicts(pkgs)

        return pkgs

    def transactionResultVersion(self, rpmdbv):
        """ We are going to do a transaction, and the parameter will be the
            rpmdb version when we finish. The idea being we can update all
            our rpmdb caches for that rpmdb version. """

        if not self.__cache_rpmdb__:
            self._trans_cache_store = {}
            return

        if 'conflicts' in self._trans_cache_store:
            pkgs = self._trans_cache_store['conflicts']
            self._write_conflicts_new(pkgs, rpmdbv)

        if 'file-requires' in self._trans_cache_store:
            data = self._trans_cache_store['file-requires']
            self._write_file_requires(rpmdbv, data)

        if 'pkgtups-checksums' in self._trans_cache_store:
            data = self._trans_cache_store['pkgtups-checksums']
            self._write_package_checksums(rpmdbv, data)

        self._trans_cache_store = {}

    def transactionReset(self):
        """ We are going to reset the transaction, because the data we've added
            already might now be invalid (Eg. skip-broken, or splitting a
            transaction). """

        self._trans_cache_store = {}

    def returnGPGPubkeyPackages(self):
        """ Return packages of the gpg-pubkeys ... hacky. """
        ts = self.readOnlyTS()
        mi = ts.dbMatch('name', 'gpg-pubkey')
        ret = []
        for hdr in mi:
            self._loaded_gpg_keys = True
            ret.append(self._makePackageObject(hdr, mi.instance()))
        return ret

    def _read_file_requires(self):
        def _read_str(fo):
            return fo.readline()[:-1]

        assert self.__cache_rpmdb__

        fo, e = _iopen(self._cachedir + '/file-requires')
        if fo is None:
            return None, None

        rpmdbv = self.simpleVersion(main_only=True)[0]
        frpmdbv = fo.readline()
        if not frpmdbv or rpmdbv != frpmdbv[:-1]:
            return None, None

        iFR = {}
        iFP = {}
        try:
            # Read the requires...
            pkgtups_num = int(_read_str(fo))
            while pkgtups_num > 0:
                pkgtups_num -= 1

                # n, a, e, v, r
                pkgtup = (_read_str(fo), _read_str(fo),
                          _read_str(fo), _read_str(fo), _read_str(fo))
                int(pkgtup[2]) # Check epoch is valid

                files_num = int(_read_str(fo))
                while files_num > 0:
                    files_num -= 1

                    fname = _read_str(fo)

                    iFR.setdefault(pkgtup, []).append(fname)

            # Read the provides...
            files_num = int(_read_str(fo))
            while files_num > 0:
                files_num -= 1
                fname = _read_str(fo)
                pkgtups_num = int(_read_str(fo))
                while pkgtups_num > 0:
                    pkgtups_num -= 1

                    # n, a, e, v, r
                    pkgtup = (_read_str(fo), _read_str(fo),
                              _read_str(fo), _read_str(fo), _read_str(fo))
                    int(pkgtup[2]) # Check epoch is valid

                    iFP.setdefault(fname, []).append(pkgtup)

            if fo.readline() != '': # Should be EOF
                return None, None
        except ValueError:
            self._deal_with_bad_rpmdbcache("file requires")
            return None, None

        return iFR, iFP

    def fileRequiresData(self):
        """ Get a cached copy of the fileRequiresData for
            depsolving/checkFileRequires, note the giant comment in that
            function about how we don't keep this perfect for the providers of
            the requires. """
        if self.__cache_rpmdb__:
            iFR, iFP = self._read_file_requires()
            if iFR is not None:
                return iFR, set(), iFP

        installedFileRequires = {}
        installedUnresolvedFileRequires = set()
        resolved = set()
        for pkg in self.returnPackages():
            for name, flag, evr in pkg.requires:
                if not name.startswith('/'):
                    continue
                installedFileRequires.setdefault(pkg.pkgtup, []).append(name)
                if name not in resolved:
                    dep = self.getProvides(name, flag, evr)
                    resolved.add(name)
                    if not dep:
                        installedUnresolvedFileRequires.add(name)

        fileRequires = set()
        for fnames in installedFileRequires.itervalues():
            fileRequires.update(fnames)
        installedFileProviders = {}
        for fname in fileRequires:
            pkgtups = [pkg.pkgtup for pkg in self.getProvides(fname)]
            installedFileProviders[fname] = pkgtups

        ret =  (installedFileRequires, installedUnresolvedFileRequires,
                installedFileProviders)
        if self.__cache_rpmdb__:
            rpmdbv = self.simpleVersion(main_only=True)[0]
            self._write_file_requires(rpmdbv, ret)

        return ret

    def transactionCacheFileRequires(self, installedFileRequires,
                                     installedUnresolvedFileRequires,
                                     installedFileProvides,
                                     problems):
        if not self.__cache_rpmdb__:
            return

        if installedUnresolvedFileRequires or problems:
            return

        data = (installedFileRequires,
                installedUnresolvedFileRequires,
                installedFileProvides)

        self._trans_cache_store['file-requires'] = data

    def _write_file_requires(self, rpmdbversion, data):
        if not os.access(self._cachedir, os.W_OK):
            return

        (installedFileRequires,
         installedUnresolvedFileRequires,
         installedFileProvides) = data

        #  Have to do this here, as well as in transactionCacheFileRequires,
        # because fileRequiresData() calls us directly.
        if installedUnresolvedFileRequires:
            return

        fo = _open_no_umask(self._cachedir + '/file-requires.tmp', 'w')
        fo.write("%s\n" % rpmdbversion)

        fo.write("%u\n" % len(installedFileRequires))
        for pkgtup in sorted(installedFileRequires):
            for var in pkgtup:
                fo.write("%s\n" % var)
            filenames = set(installedFileRequires[pkgtup])
            fo.write("%u\n" % len(filenames))
            for fname in sorted(filenames):
                fo.write("%s\n" % fname)

        fo.write("%u\n" % len(installedFileProvides))
        for fname in sorted(installedFileProvides):
            fo.write("%s\n" % fname)

            pkgtups = set(installedFileProvides[fname])
            fo.write("%u\n" % len(pkgtups))
            for pkgtup in sorted(pkgtups):
                for var in pkgtup:
                    fo.write("%s\n" % var)
        fo.close()
        os.rename(self._cachedir + '/file-requires.tmp',
                  self._cachedir + '/file-requires')

    def preloadPackageChecksums(self, load_packages=True):
        """ As simpleVersion() et. al. requires it, we "cache" this yumdb data
            as part of our rpmdb cache. We cache it with rpmdb data, even
            though someone _could_ use yumdb to alter it without changing the
            rpmdb ... don't do that.
            NOTE: This is also used as a cache of pkgtups in the rpmdb. """
        if not self.__cache_rpmdb__:
            return

        def _read_str(fo):
            return fo.readline()[:-1]

        fo, e = _iopen(self._cachedir + '/pkgtups-checksums')
        if fo is None:
            return

        rpmdbv = self.simpleVersion(main_only=True)[0]
        frpmdbv = fo.readline()
        if not frpmdbv or rpmdbv != frpmdbv[:-1]:
            return

        checksum_data = {}
        try:
            # Read the checksums...
            pkgtups_num = int(_read_str(fo))
            while pkgtups_num > 0:
                pkgtups_num -= 1

                # n, a, e, v, r
                pkgtup = (_read_str(fo), _read_str(fo),
                          _read_str(fo), _read_str(fo), _read_str(fo))
                int(pkgtup[2]) # Check epoch is valid

                T = _read_str(fo)
                D = _read_str(fo)
                if T == '-':
                    checksum_data[pkgtup] = None
                else:
                    checksum_data[pkgtup] = (T, D)

            if fo.readline() != '': # Should be EOF
                return
        except ValueError:
            self._deal_with_bad_rpmdbcache("pkg checksums")
            return

        if not load_packages:
             return checksum_data

        for pkgtup in checksum_data:
            if checksum_data[pkgtup] is None:
                continue

            (n, a, e, v, r) = pkgtup
            pkg = self.searchNevra(n, e, v, r, a)
            if not pkg:
                self._deal_with_bad_rpmdbcache("pkg checksums")
                continue
            pkg = pkg[0]
            (T, D) = checksum_data[pkgtup]
            if ('checksum_type' in pkg.yumdb_info._read_cached_data or
                'checksum_data' in pkg.yumdb_info._read_cached_data):
                continue
            pkg.yumdb_info._read_cached_data['checksum_type'] = T
            pkg.yumdb_info._read_cached_data['checksum_data'] = D

    def transactionCachePackageChecksums(self, pkg_checksum_tups):
        if not self.__cache_rpmdb__:
            return

        self._trans_cache_store['pkgtups-checksums'] = pkg_checksum_tups

    def _write_package_checksums(self, rpmdbversion, data):
        if not os.access(self._cachedir, os.W_OK):
            return

        pkg_checksum_tups = data
        fo = _open_no_umask(self._cachedir + '/pkgtups-checksums.tmp', 'w')
        fo.write("%s\n" % rpmdbversion)
        fo.write("%u\n" % len(pkg_checksum_tups))
        for pkgtup, TD in sorted(pkg_checksum_tups):
            for var in pkgtup:
                fo.write("%s\n" % var)
            if TD is None:
                TD = ('-', '-')
            for var in TD:
                fo.write("%s\n" % var)
        fo.close()
        os.rename(self._cachedir + '/pkgtups-checksums.tmp',
                  self._cachedir + '/pkgtups-checksums')

    def _get_cached_simpleVersion_main(self):
        """ Return the cached string of the main rpmdbv. """
        if self._have_cached_rpmdbv_data is not None:
            return self._have_cached_rpmdbv_data

        if not self.__cache_rpmdb__:
            return None

        #  This test is "obvious" and the only thing to come out of:
        # http://lists.rpm.org/pipermail/rpm-maint/2007-November/001719.html
        # ...if anything gets implemented, we should change.
        rpmdbvfname = self._cachedir + "/version"
        rpmdbfname  = self._rpmdbpath + "/Packages"

        if os.path.exists(rpmdbvfname) and os.path.exists(rpmdbfname):
            # See if rpmdb has "changed" ...
            nmtime = os.path.getmtime(rpmdbvfname)
            omtime = os.path.getmtime(rpmdbfname)
            if omtime <= nmtime:
                fo, e = _iopen(rpmdbvfname)
                if fo is None:
                    return None
                rpmdbv = fo.readline()[:-1]
                self._have_cached_rpmdbv_data  = rpmdbv
        return self._have_cached_rpmdbv_data

    def _put_cached_simpleVersion_main(self, rpmdbv):
        self._have_cached_rpmdbv_data  = str(rpmdbv)

        if not self.__cache_rpmdb__:
            return

        if self._cached_rpmdb_mtime is None:
            return # We haven't loaded any packages!!!

        rpmdbfname  = self._rpmdbpath + "/Packages"
        if not os.path.exists(rpmdbfname):
            return # haha

        _cached_rpmdb_mtime = os.path.getmtime(rpmdbfname)
        if self._cached_rpmdb_mtime != _cached_rpmdb_mtime:
            #  Something altered the rpmdb since we loaded our first package,
            # so don't save the rpmdb version as who knows what happened.
            return

        rpmdbvfname = self._cachedir + "/version"
        if not os.access(self._cachedir, os.W_OK):
            if os.path.exists(self._cachedir):
                return

            try:
                os.makedirs(self._cachedir)
            except (IOError, OSError), e:
                return

        fo = _open_no_umask(rpmdbvfname + ".tmp", "w")
        fo.write(self._have_cached_rpmdbv_data)
        fo.write('\n')
        fo.close()
        os.rename(rpmdbvfname + ".tmp", rpmdbvfname)

    def simpleVersion(self, main_only=False, groups={}):
        """ Return a simple version for all installed packages. """
        def _up_revs(irepos, repoid, rev, pkg, csum):
            irevs = irepos.setdefault(repoid, {})
            rpsv = irevs.setdefault(None, PackageSackVersion())
            rpsv.update(pkg, csum)
            if rev is not None:
                rpsv = irevs.setdefault(rev, PackageSackVersion())
                rpsv.update(pkg, csum)

        if main_only and not groups:
            rpmdbv = self._get_cached_simpleVersion_main()
            if rpmdbv is not None:
                return [rpmdbv, {}]

        main = PackageSackVersion()
        irepos = {}
        main_grps = {}
        irepos_grps = {}
        for pkg in sorted(self.returnPackages()):
            ydbi = pkg.yumdb_info
            csum = None
            if 'checksum_type' in ydbi and 'checksum_data' in ydbi:
                csum = (ydbi.checksum_type, ydbi.checksum_data)
            main.update(pkg, csum)

            for group in groups:
                if pkg.name in groups[group]:
                    if group not in main_grps:
                        main_grps[group] = PackageSackVersion()
                        irepos_grps[group] = {}
                    main_grps[group].update(pkg, csum)

            if main_only:
                continue

            repoid = 'installed'
            rev = None
            if 'from_repo' in pkg.yumdb_info:
                repoid = '@' + pkg.yumdb_info.from_repo
                if 'from_repo_revision' in pkg.yumdb_info:
                    rev = pkg.yumdb_info.from_repo_revision

            _up_revs(irepos, repoid, rev, pkg, csum)
            for group in groups:
                if pkg.name in groups[group]:
                    _up_revs(irepos_grps[group], repoid, rev, pkg, csum)

        if self._have_cached_rpmdbv_data is None:
            self._put_cached_simpleVersion_main(main)

        if groups:
            return [main, irepos, main_grps, irepos_grps]
        return [main, irepos]

    @staticmethod
    def _find_search_fields(fields, searchstrings, hdr):
        count = 0
        for s in searchstrings:
            for field in fields:
                value = to_unicode(hdr[field])
                if value and value.lower().find(s) != -1:
                    count += 1
                    break
        return count

    def searchPrimaryFieldsMultipleStrings(self, fields, searchstrings,
                                           lowered=False):
        if not lowered:
            searchstrings = map(lambda x: x.lower(), searchstrings)
        ret = []
        for hdr, idx in self._get_packages():
            n = self._find_search_fields(fields, searchstrings, hdr)
            if n > 0:
                ret.append((self._makePackageObject(hdr, idx), n))
        return ret
    def searchNames(self, names=[]):
        returnList = []
        for name in names:
            returnList.extend(self._search(name=name))
        return returnList

    def searchNevra(self, name=None, epoch=None, ver=None, rel=None, arch=None):
        return self._search(name, epoch, ver, rel, arch)

    def excludeArchs(self, archlist):
        pass
    
    def returnLeafNodes(self, repoid=None):
        ts = self.readOnlyTS()
        return [ self._makePackageObject(h, mi) for (h, mi) in ts.returnLeafNodes(headers=True) ]
        
    # Helper functions
    def _get_packages(self, *args, **kwds):
        '''dbMatch() wrapper generator that yields (header, index) for matches
        '''
        ts = self.readOnlyTS()

        mi = ts.dbMatch(*args, **kwds)
        for h in mi:
            if h['name'] != 'gpg-pubkey':
                yield (h, mi.instance())
        del mi

        if self.auto_close:
            self.ts.close()

    def _search(self, name=None, epoch=None, ver=None, rel=None, arch=None):
        '''List of matching packages, to zero or more of NEVRA.'''
        if name is not None and name in self._pkgname_fails:
            return []

        pkgtup = (name, arch, epoch, ver, rel)
        if pkgtup in self._tup2pkg:
            return [self._tup2pkg[pkgtup]]

        loc = locals()
        ret = []

        if self._completely_loaded or name in self._pkgnames_loaded:
            if name is not None:
                pkgs = self._name2pkg.get(name, [])
                if not pkgs:
                    self._pkgname_fails.add(name)
            else:
                pkgs = self.returnPkgs()
            for po in pkgs:
                for tag in ('arch', 'rel', 'ver', 'epoch'):
                    if loc[tag] is not None and loc[tag] != getattr(po, tag):
                        break
                else:
                    ret.append(po)
            return ret

        ts = self.readOnlyTS()
        if name is not None:
            mi = self._get_packages('name', name)
        elif arch is not None:
            mi = self._get_packages('arch', arch)
        else:
            mi = self._get_packages()
            self._completely_loaded = True

        done = False
        for hdr, idx in mi:
            po = self._makePackageObject(hdr, idx)
            #  We create POs out of all matching names, even if we don't return
            # them.
            self._pkgnames_loaded.add(po.name)
            done = True

            for tag in ('arch', 'rel', 'ver', 'epoch'):
                if loc[tag] is not None and loc[tag] != getattr(po, tag):
                    break
            else:
                ret.append(po)

        if not done and name is not None:
            self._pkgname_fails.add(name)

        return ret

    def _makePackageObject(self, hdr, index):
        if index in self._idx2pkg:
            return self._idx2pkg[index]
        po = RPMInstalledPackage(hdr, index, self)
        self._idx2pkg[index] = po
        self._name2pkg.setdefault(po.name, []).append(po)
        self._tup2pkg[po.pkgtup] = po
        if self.__cache_rpmdb__ and self._cached_rpmdb_mtime is None:
            rpmdbfname  = self._rpmdbpath + "/Packages"
            self._cached_rpmdb_mtime = os.path.getmtime(rpmdbfname)

        return po
        
    def _hdr2pkgTuple(self, hdr):
        name = misc.share_data(hdr['name'])
        arch = misc.share_data(hdr['arch'])
         # convert these to strings to be sure
        ver = misc.share_data(str(hdr['version']))
        rel = misc.share_data(str(hdr['release']))
        epoch = hdr['epoch']
        if epoch is None:
            epoch = '0'
        else:
            epoch = str(epoch)
        epoch = misc.share_data(epoch)
        return misc.share_data((name, arch, epoch, ver, rel))

    # deprecated options for compat only - remove once rpmdb is converted:
    def getPkgList(self):
        warnings.warn('getPkgList() will go away in a future version of Yum.\n'
                'Please access this via the pkglist attribute.',
                DeprecationWarning, stacklevel=2)
    
        return self.pkglist

    def getHdrList(self):
        warnings.warn('getHdrList() will go away in a future version of Yum.\n',
                DeprecationWarning, stacklevel=2)
        return [ hdr for hdr, idx in self._get_packages() ]

    def getNameArchPkgList(self):
        warnings.warn('getNameArchPkgList() will go away in a future version of Yum.\n',
                DeprecationWarning, stacklevel=2)
        
        lst = []
        for (name, arch, epoch, ver, rel) in self.pkglist:
            lst.append((name, arch))
        
        return miscutils.unique(lst)
        
    def getNamePkgList(self):
        warnings.warn('getNamePkgList() will go away in a future version of Yum.\n',
                DeprecationWarning, stacklevel=2)
    
        lst = []
        for (name, arch, epoch, ver, rel) in self.pkglist:
            lst.append(name)

        return miscutils.unique(lst)
    
    def returnTupleByKeyword(self, name=None, arch=None, epoch=None, ver=None, rel=None):
        warnings.warn('returnTuplebyKeyword() will go away in a future version of Yum.\n',
                DeprecationWarning, stacklevel=2)
        return [po.pkgtup for po in self._search(name=name, arch=arch, epoch=epoch, ver=ver, rel=rel)]

    def returnHeaderByTuple(self, pkgtuple):
        warnings.warn('returnHeaderByTuple() will go away in a future version of Yum.\n',
                DeprecationWarning, stacklevel=2)
        """returns a list of header(s) based on the pkgtuple provided"""
        
        (n, a, e, v, r) = pkgtuple
        
        lst = self.searchNevra(name=n, arch=a, epoch=e, ver=v, rel=r)
        if len(lst) > 0:
            item = lst[0]
            return [item.hdr]
        else:
            return []

    def returnIndexByTuple(self, pkgtuple):
        """returns a list of header indexes based on the pkgtuple provided"""

        warnings.warn('returnIndexbyTuple() will go away in a future version of Yum.\n',
                DeprecationWarning, stacklevel=2)

        name, arch, epoch, version, release = pkgtuple

        # Normalise epoch
        if epoch in (None, 0, '(none)', ''):
            epoch = '0'

        return [po.idx for po in self._search(name, epoch, version, release, arch)]
        
    def addDB(self, ts):
        # Can't support this now
        raise NotImplementedError

    @staticmethod
    def _genDeptup(name, flags, version):
        """ Given random stuff, generate a usable dep tuple. """

        if flags == 0:
            flags = None

        if type(version) is types.StringType:
            (r_e, r_v, r_r) = miscutils.stringToVersion(version)
        # would this ever be a ListType?
        elif type(version) in (types.TupleType, types.ListType):
            (r_e, r_v, r_r) = version
        else:
            # FIXME: This isn't always  type(version) is types.NoneType:
            # ...not sure what it is though, come back to this
            r_e = r_v = r_r = None

        deptup = (name, misc.share_data(flags),
                  (misc.share_data(r_e), misc.share_data(r_v),
                   misc.share_data(r_r)))
        return misc.share_data(deptup)

    def getProvides(self, name, flags=None, version=(None, None, None)):
        """searches the rpmdb for what provides the arguments
           returns a list of pkg objects of providing packages, possibly empty"""

        name = misc.share_data(name)
        deptup = self._genDeptup(name, flags, version)
        if deptup in self._get_pro_cache:
            return self._get_pro_cache[deptup]
        r_v = deptup[2][1]
        
        pkgs = self.searchProvides(name)
        
        result = { }
        
        for po in pkgs:
            if name[0] == '/' and r_v is None:
                result[po] = [(name, None, (None, None, None))]
                continue
            hits = po.matchingPrcos('provides', deptup)
            if hits:
                result[po] = hits
        self._get_pro_cache[deptup] = result
        return result

    def whatProvides(self, name, flags, version):
        # XXX deprecate?
        return [po.pkgtup for po in self.getProvides(name, flags, version)]

    def getRequires(self, name, flags=None, version=(None, None, None)):
        """searches the rpmdb for what provides the arguments
           returns a list of pkgtuples of providing packages, possibly empty"""

        name = misc.share_data(name)
        deptup = self._genDeptup(name, flags, version)
        if deptup in self._get_req_cache:
            return self._get_req_cache[deptup]
        r_v = deptup[2][1]

        pkgs = self.searchRequires(name)

        result = { }

        for po in pkgs:
            if name[0] == '/' and r_v is None:
                # file dep add all matches to the defSack
                result[po] = [(name, None, (None, None, None))]
                continue
            hits = po.matchingPrcos('requires', deptup)
            if hits:
                result[po] = hits
        self._get_req_cache[deptup] = result
        return result

    def whatRequires(self, name, flags, version):
        # XXX deprecate?
        return [po.pkgtup for po in self.getRequires(name, flags, version)]

    def return_running_packages(self):
        """returns a list of yum installed package objects which own a file
           that are currently running or in use."""
        pkgs = {}
        for pid in misc.return_running_pids():
            for fn in misc.get_open_files(pid):
                for pkg in self.searchFiles(fn):
                    pkgs[pkg] = 1

        return sorted(pkgs.keys())

    def check_dependencies(self, pkgs=None):
        """ Checks for any missing dependencies. """

        if pkgs is None:
            pkgs = self.returnPackages()

        providers = set() # Speedup, as usual :)
        problems = []
        for pkg in sorted(pkgs): # The sort here is mainly for "UI"
            for rreq in pkg.requires:
                if rreq[0].startswith('rpmlib'): continue
                if rreq in providers:            continue

                (req, flags, ver) = rreq
                if self.getProvides(req, flags, ver):
                    providers.add(rreq)
                    continue
                flags = yum.depsolve.flags.get(flags, flags)
                missing = miscutils.formatRequire(req, ver, flags)
                prob = RPMDBProblemDependency(pkg, "requires", missing=missing)
                problems.append(prob)

            for creq in pkg.conflicts:
                if creq[0].startswith('rpmlib'): continue

                (req, flags, ver) = creq
                res = self.getProvides(req, flags, ver)
                if not res:
                    continue
                flags = yum.depsolve.flags.get(flags, flags)
                found = miscutils.formatRequire(req, ver, flags)
                prob = RPMDBProblemDependency(pkg, "conflicts", found=found,
                                              conflicts=res)
                problems.append(prob)
        return problems

    def _iter_two_pkgs(self, ignore_provides):
        last = None
        for pkg in sorted(self.returnPackages()):
            if pkg.name in ignore_provides:
                continue
            if ignore_provides.intersection(set(pkg.provides_names)):
                continue

            if last is None:
                last = pkg
                continue
            yield last, pkg
            last = pkg

    def check_duplicates(self, ignore_provides=[]):
        """ Checks for any "duplicate packages" (those with multiple versions
            installed), we ignore any packages with a provide in the passed
            provide list (this is how installonlyworks, so we do the same). """
        ignore_provides = set(ignore_provides)
        problems = []
        for last, pkg in self._iter_two_pkgs(ignore_provides):
            if pkg.name != last.name:
                continue
            if pkg.verEQ(last) and pkg != last:
                if arch.isMultiLibArch(pkg.arch) and last.arch != 'noarch':
                    continue
                if arch.isMultiLibArch(last.arch) and pkg.arch != 'noarch':
                    continue

            # More than one pkg, they aren't version equal, or aren't multiarch
            problems.append(RPMDBProblemDuplicate(pkg, duplicate=last))
        return problems

    def check_obsoleted(self):
        """ Checks for any packages which are obsoleted by other packages. """
        obsoleters = []
        problems = []
        for pkg in sorted(self.returnPackages()):
            if not pkg.obsoletes:
                continue
            obsoleters.append(pkg)
        for pkg in sorted(self.returnPackages()):
            for obspo in pkg.obsoletedBy(obsoleters):
                problems.append(RPMDBProblemObsoleted(pkg, obsoleter=obspo))
        return problems

    def check_provides(self):
        """ For each package, check that a provides search for it's name (and
            everything it provides) finds it. """
        problems = []
        for pkg in sorted(self.returnPackages()):
            for provtup in pkg.provides:
                name, flags, version = provtup
                if pkg not in self.getProvides(name, flags, version):
                    problems.append(RPMDBProblemProvides(pkg, provide=provtup))
                    break
        return problems

def _sanitize(path):
    return path.replace('/', '').replace('~', '')


class RPMDBAdditionalData(object):
    """class for access to the additional data not able to be stored in the
       rpmdb"""
    # dir: /var/lib/yum/yumdb/
    # pkgs stored in name[0]/name[1]/pkgid-name-ver-rel-arch dirs
    # dirs have files per piece of info we're keeping
    #    repoid, install reason, status, blah, (group installed for?), notes?
    
    def __init__(self, db_path='/var/lib/yum/yumdb', version_path=None):
        self.conf = misc.GenericHolder()
        self.conf.db_path = db_path
        self.conf.version_path = version_path
        self.conf.writable = False
        
        self._packages = {} # pkgid = dir
        if not os.path.exists(self.conf.db_path):
            try:
                os.makedirs(self.conf.db_path)
            except (IOError, OSError), e:
                # some sort of useful thing here? A warning?
                return
            self.conf.writable = True
        else:
            if os.access(self.conf.db_path, os.W_OK):
                self.conf.writable = True
        #  Don't call _load_all_package_paths to preload, as it's expensive
        # if the dirs. aren't in cache.
        self.yumdb_cache = {'attr' : {}}

    def _load_all_package_paths(self):
        # glob the path and get a dict of pkgs to their subdir
        glb = '%s/*/*/' % self.conf.db_path
        pkgdirs = glob.glob(glb)
        for d in pkgdirs:
            pkgid = os.path.basename(d).split('-')[0]
            self._packages[pkgid] = d

    def _get_dir_name(self, pkgtup, pkgid):
        if pkgid in self._packages:
            return self._packages[pkgid]
        (n, a, e, v,r) = pkgtup
        n = _sanitize(n) # Please die in a fire rpmbuild
        thisdir = '%s/%s/%s-%s-%s-%s-%s' % (self.conf.db_path,
                                            n[0], pkgid, n, v, r, a)
        self._packages[pkgid] = thisdir
        return thisdir

    def get_package(self, po=None, pkgtup=None, pkgid=None):
        """Return an RPMDBAdditionalDataPackage Object for this package"""
        if po:
            thisdir = self._get_dir_name(po.pkgtup, po.pkgid)
        elif pkgtup and pkgid:
            thisdir = self._get_dir_name(pkgtup, pkgid)
        else:
            raise ValueError,"Pass something to RPMDBAdditionalData.get_package"
        
        return RPMDBAdditionalDataPackage(self.conf, thisdir,
                                          yumdb_cache=self.yumdb_cache)

    def sync_with_rpmdb(self, rpmdbobj):
        """populate out the dirs and remove all the items no longer in the rpmd
           and/or populate various bits to the currently installed version"""
        # TODO:
        # get list of all items in the yumdb
        # remove any no longer in the rpmdb/andor migrate them up to the currently
        # installed version
        # add entries for items in the rpmdb if they don't exist in the yumdb

        pass

class RPMDBAdditionalDataPackage(object):

    # We do auto hardlink on these attributes
    _auto_hardlink_attrs = set(['checksum_type', 'reason',
                                'installed_by', 'changed_by',
                                'from_repo', 'from_repo_revision',
                                'from_repo_timestamp', 'releasever',
                                'command_line'])

    def __init__(self, conf, pkgdir, yumdb_cache=None):
        self._conf = conf
        self._mydir = pkgdir

        self._read_cached_data = {}

        #  'from_repo' is the most often requested piece of data, and is often
        # the same for a huge number of packages. So we use hardlinks to share
        # data, and try to optimize for that.
        #  It's useful for other keys too (installed_by/changed_by/reason/etc.)
        # so we make it generic.
        self._yumdb_cache = yumdb_cache

    def _auto_cache(self, attr, value, fn, info=None):
        """ Create caches for the attr. We have a per. object read cache so at
            worst we only have to read a single attr once. Then we expand that
            with (dev, ino) cache, so hardlink data can be read once for
            multiple packages. """
        self._read_cached_data[attr] = value
        if self._yumdb_cache is None:
            return

        nlinks = 1
        if info is not None:
            nlinks = info.st_nlink
        if nlinks <= 1 and attr not in self._auto_hardlink_attrs:
            return

        if value in self._yumdb_cache['attr']:
            sinfo = self._yumdb_cache['attr'][value][1]
            if info is not None and sinfo is not None:
                if (info.st_dev, info.st_ino) == (sinfo.st_dev, sinfo.st_ino):
                    self._yumdb_cache['attr'][value][2].add(fn)
                    self._yumdb_cache[fn] = value
                    return
            if self._yumdb_cache['attr'][value][0] >= nlinks:
                # We already have a better cache file.
                return

        self._yumdb_cache['attr'][value] = (nlinks, info, set([fn]))
        self._yumdb_cache[fn]            = value

    def _unlink_yumdb_cache(self, fn):
        """ Remove old values from the link cache. """
        if fn in self._yumdb_cache:
            ovalue = self._yumdb_cache[fn]
            if ovalue in self._yumdb_cache['attr']:
                self._yumdb_cache['attr'][ovalue][2].discard(fn)
                if not self._yumdb_cache['attr'][ovalue][2]:
                    del self._yumdb_cache['attr'][ovalue]
            del self._yumdb_cache[fn]

    def _link_yumdb_cache(self, fn, value):
        """ If we have a matching yumdb cache, link() to it instead of having
            to open()+write(). """
        if self._yumdb_cache is None:
            return False

        self._unlink_yumdb_cache(fn)

        if value not in self._yumdb_cache['attr']:
            return False

        assert self._yumdb_cache['attr'][value][2]
        try:
            lfn = iter(self._yumdb_cache['attr'][value][2]).next()
            misc.unlink_f(fn + '.tmp')
            os.link(lfn, fn + '.tmp')
            os.rename(fn + '.tmp', fn)
        except:
            return False

        self._yumdb_cache['attr'][value][2].add(fn)
        self._yumdb_cache[fn] = value

        return True

    def _attr2fn(self, attr):
        """ Given an attribute, return the filename. """
        return os.path.normpath(self._mydir + '/' + attr)

    def _write(self, attr, value):
        # check for self._conf.writable before going on?
        if not os.path.exists(self._mydir):
            os.makedirs(self._mydir)

        attr = _sanitize(attr)
        if attr in self._read_cached_data:
            del self._read_cached_data[attr]
        fn = self._attr2fn(attr)

        if attr.endswith('.tmp'):
            raise AttributeError, "Cannot set attribute %s on %s" % (attr, self)

        #  These two are special, as they have an index and are used as our
        # cache-breaker.
        if attr in ('checksum_type', 'checksum_data'):
            misc.unlink_f(self._conf.version_path)

        # Auto hardlink some of the attrs...
        if self._link_yumdb_cache(fn, value):
            return

        # Default write()+rename()... hardlink -c can still help.
        misc.unlink_f(fn + '.tmp')

        fo = _open_no_umask(fn + '.tmp', 'w')
        try:
            fo.write(value)
        except (OSError, IOError), e:
            raise AttributeError, "Cannot set attribute %s on %s" % (attr, self)

        fo.flush()
        fo.close()
        del fo
        os.rename(fn +  '.tmp', fn) # even works on ext4 now!:o

        self._auto_cache(attr, value, fn)
    
    def _read(self, attr):
        attr = _sanitize(attr)

        if attr in self._read_cached_data:
            return self._read_cached_data[attr]
        fn = self._attr2fn(attr)

        if attr.endswith('.tmp'):
            raise AttributeError, "%s has no attribute %s" % (self, attr)

        info = misc.stat_f(fn)
        if info is None:
            raise AttributeError, "%s has no attribute %s" % (self, attr)

        if info.st_nlink > 1 and self._yumdb_cache is not None:
            key = (info.st_dev, info.st_ino)
            if key in self._yumdb_cache:
                self._auto_cache(attr, self._yumdb_cache[key], fn, info)
                return self._read_cached_data[attr]

        fo, e = _iopen(fn)
        if fo is None: # This really sucks, don't do that.
            return '<E:%d>' % e.errno
        value = fo.read()
        fo.close()
        del fo

        if info.st_nlink > 1 and self._yumdb_cache is not None:
            self._yumdb_cache[key] = value
        self._auto_cache(attr, value, fn, info)

        return value
    
    def _delete(self, attr):
        """remove the attribute file"""

        attr = _sanitize(attr)
        fn = self._attr2fn(attr)
        if attr in self._read_cached_data:
            del self._read_cached_data[attr]
        self._unlink_yumdb_cache(fn)
        if os.path.exists(fn):
            try:
                os.unlink(fn)
            except (IOError, OSError):
                raise AttributeError, "Cannot delete attribute %s on %s " % (attr, self)
    
    def __getattr__(self, attr):
        return self._read(attr)

    def __setattr__(self, attr, value):
        if not attr.startswith('_'):
            self._write(attr, value)
        else:
            object.__setattr__(self, attr, value)

    def __delattr__(self, attr):
        if not attr.startswith('_'):
            self._delete(attr)
        else:
            object.__delattr__(self, attr)

    def __contains__(self, attr):
        #  This is faster than __iter__ and it makes things fail in a much more
        # obvious way in weird FS corruption cases like: BZ 593436
        x = self.get(attr)
        return x is not None

    def __iter__(self, show_hidden=False):
        for item in self._read_cached_data:
            yield item
        for item in glob.glob(self._mydir + '/*'):
            item = item[(len(self._mydir) + 1):]
            if item in self._read_cached_data:
                continue
            if not show_hidden and item.endswith('.tmp'):
                continue
            yield item

    def clean(self):
        # purge out everything
        for item in self.__iter__(show_hidden=True):
            self._delete(item)
        try:
            os.rmdir(self._mydir)
        except OSError:
            pass

#    def __dir__(self): # for 2.6 and beyond, apparently
#        return list(self.__iter__()) + self.__dict__.keys()

    def get(self, attr, default=None):
        """retrieve an add'l data obj"""

        try:
            res = self._read(attr)
        except AttributeError:
            return default
        return res
        
        
def main():
    sack = RPMDBPackageSack('/')
    for p in sack.simplePkgList():
        print p

if __name__ == '__main__':
    main()

                                                                                                                   usr/lib/python2.7/dist-packages/yum/rpmsack.pyc                                                     0100644 0000000 0000000 00000156015 13077704344 020123  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   s  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l m Z d  d l m Z d  d l	 m
 Z
 d  d l Z d  d l Z d  d l m Z m Z d  d l m Z m Z d  d l Z d  d l Z d  d l m Z m Z d  d l Z d  d l Z d Ñ  Z d	 Ñ  Z d
 e f d Ñ  É  YZ d f  d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ  d e f d Ñ  É  YZ! d e f d Ñ  É  YZ" d e f d Ñ  É  YZ# d Ñ  Z$ d e% f d Ñ  É  YZ& d e% f d Ñ  É  YZ' d Ñ  Z( e) d k rˇe( É  n  d S(   iˇˇˇˇN(   t	   miscutils(   t   arch(   t   initReadOnlyTransaction(   t   YumInstalledPackaget   parsePackages(   t   PackageSackBaset   PackageSackVersion(   t
   to_unicodet   _c          G   s4   t  j d É } z t |  å  } Wd t  j | É X| S(   sk    Annoying people like to set umask's for root, which screws everything
        up for user readable stuff. i   N(   t   ost   umaskt   open(   t   argst   oumaskt   ret(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _open_no_umask(   s
    c          G   s7   y t  |  å  } Wn t k
 r, } d | f SX| d f S(   s1    IOError wrapper BS for open, stupid exceptions. N(   R   t   IOErrort   None(   R   R   t   e(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _iopen3   s
    t   RPMInstalledPackagec           B   s5   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sG   t  |  _ t j |  | d | j É| |  _ | |  _ t |  _ |  ` d  S(   Nt   yumdb(	   t   Truet   _has_hdrR   t   __init__R   t   idxt   rpmdbt   Falset   hdr(   t   selft   rpmhdrt   indexR   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR   >   s    				c         C   sf   |  j  r |  j S|  j j É  } | j d |  j É } y | j É  SWn t k
 ra t j	 d Ç n Xd  S(   Ni    s   Rpmdb changed underneath us(
   R   R   R   t
   readOnlyTSt   dbMatchR   t   nextt   StopIterationt   Errorst   PackageSackError(   R   t   tst   mi(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _get_hdrH   s    	c         C   sy   | j  d É r% t d |  | f Ç n  | d k r@ |  j É  } n |  j É  |  _ } t |  _ | d k ru | | } n  | S(   NR   s   %s has no attribute %sR   (   t
   startswitht   AttributeErrorR(   R   R   R   (   R   t   varnamet   val(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   __getattr__T   s    	c         C   s…   t  É  } xY |  j D]N \ } } } x< |  j j | | | É D]" } | |  k r; | j | É q; q; Wq WxW |  j |  j D]E } x< |  j j | d d É D]" } | |  k rï | j | É qï qï Wqv Wt | É S(   s4   return list of installed pkgs requiring this packageN(   NNN(	   t   sett   providesR   t   getRequirest   addt   filelistt   dirlistR   t   list(   R   t   pkgsett   reqnt   reqft   reqevrt   pkgt   fn(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   requiring_packagesh   s    	c         C   so   t  É  } xY |  j D]N \ } } } x< |  j j | | | É D]" } | |  k r; | j | É q; q; Wq Wt | É S(   N(   R.   t   requiresR   t   getProvidesR1   R4   (   R   R5   R6   R7   R8   R9   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   required_packagesx   s    	(   t   __name__t
   __module__R   R(   R-   R;   R>   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR   <   s
   	
			t   RPMDBProblemc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sJ   
    Represents a problem in the rpmdb, from the check_*() functions.
    c         K   s;   | |  _  | |  _ x" | D] } t |  | | | É q Wd  S(   N(   R9   t   problemt   setattr(   R   R9   RB   t   kwargst   kwarg(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR   Ö   s    		c         C   s8   | d  k r d St |  j | j É p7 t |  j | j É S(   Ni   (   R   t   cmpR9   RB   (   R   t   other(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   __cmp__ã   s    (   R?   R@   t   __doc__R   RH   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRA   Å   s   	t   RPMDBProblemDependencyc           B   s   e  Z d  Ñ  Z RS(   c         C   sa   |  j  d k r, d |  j t d É |  j f Sd |  j t d É |  j d j t t |  j É É f S(   NR<   s   %s %s %ss   has missing requires ofs   %s %s %s: %ss   has installed conflictss   , (	   RB   R9   R   t   missingt   foundt   joint   mapt   strt	   conflicts(   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   __str__í   s
    (   R?   R@   RQ   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRJ   ë   s   t   RPMDBProblemDuplicatec           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         K   s   t  j |  | d | ç d  S(   Nt	   duplicate(   RA   R   (   R   R9   RD   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR   ú   s    c         C   s   t  d É |  j |  j f S(   Ns   %s is a duplicate with %s(   R   R9   RS   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRQ   ü   s    (   R?   R@   R   RQ   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRR   õ   s   	t   RPMDBProblemObsoletedc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         K   s   t  j |  | d | ç d  S(   Nt	   obsoleted(   RA   R   (   R   R9   RD   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR   §   s    c         C   s   t  d É |  j |  j f S(   Ns   %s is obsoleted by %s(   R   R9   t	   obsoleter(   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRQ   ß   s    (   R?   R@   R   RQ   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRT   £   s   	t   RPMDBProblemProvidesc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         K   s   t  j |  | d | ç d  S(   NR/   (   RA   R   (   R   R9   RD   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR   ¨   s    c         C   s   t  d É |  j |  j f S(   Ns%   %s provides %s but it cannot be found(   R   R9   t   provide(   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRQ   Ø   s    (   R?   R@   R   RQ   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRW   ´   s   	t   RPMDBPackageSackc           B   s•  e  Z d  Z i e j e j e j f d 6e j e j e j	 f d 6e j
 e j e j f d 6e j e j e j f d 6Z e Z d dP dP d d Ñ Z d Ñ  Z e e dP É Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d d Ñ Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& e' j( Z) dP dP d Ñ Z* dP d Ñ Z+ e, e- d Ñ É Z. e, d Ñ  É Z/ dP dP e- d Ñ Z0 d Ñ  Z1 d  Ñ  Z2 d! Ñ  Z3 d" Ñ  Z4 d# Ñ  Z5 d$ Ñ  Z6 d% Ñ  Z7 d& Ñ  Z8 d' Ñ  Z9 d( Ñ  Z: d) Ñ  Z; d* Ñ  Z< d+ Ñ  Z= d, Ñ  Z> e d- Ñ Z? d. Ñ  Z@ d/ Ñ  ZA d0 Ñ  ZB d1 Ñ  ZC e- i  d2 Ñ ZD e, d3 Ñ  É ZE e- d4 Ñ ZF g  d5 Ñ ZG dP dP dP dP dP d6 Ñ ZH d7 Ñ  ZI dP d8 Ñ ZJ d9 Ñ  ZK dP dP dP dP dP d: Ñ ZL d; Ñ  ZM d< Ñ  ZN d= Ñ  ZO d> Ñ  ZP d? Ñ  ZQ d@ Ñ  ZR dP dP dP dP dP dA Ñ ZS dB Ñ  ZT dC Ñ  ZU dD Ñ  ZV e, dE Ñ  É ZW dP dQ dF Ñ ZX dG Ñ  ZY dP dR dH Ñ ZZ dI Ñ  Z[ dJ Ñ  Z\ dP dK Ñ Z] dL Ñ  Z^ g  dM Ñ Z_ dN Ñ  Z` dO Ñ  Za RS(S   s*   
    Represent rpmdb as a packagesack
    R<   R/   RP   t	   obsoletest   /s   /var/lib/yumc         C   s’  | |  _  i  |  _ i  |  _ t É  |  _ i  |  _ t |  _ t É  |  _ t É  |  _	 t É  |  _
 g  |  _ i  |  _ i  |  _ t |  _ | d  k rö | d } n  |  j | É t j j | É j |  j  É sŸ | d | |  _ n	 | |  _ t t d É rt j d É } n d } t j j | d | É |  _ d  |  _ d  |  _ i  |  _ d  |  _ | |  _ t |  _ d  |  _  i i  d 6i  d 6i  d 6i  d	 6|  _! t j j |  j d
 É } t j j | d É } t" d | d | É |  _# d  S(   Ns   /rpmdb-indexesR[   t   expandMacros   %_dbpaths   /var/lib/rpmR/   R<   RP   RZ   s   /yumdbs   /versiont   db_patht   version_path($   t   roott   _idx2pkgt	   _name2pkgR.   t   _pkgnames_loadedt   _tup2pkgR   t   _completely_loadedt   _pkgname_failst   _pkgmatch_failst   _provmatch_failst   _simple_pkgtup_listt   _get_pro_cachet   _get_req_cachet   _loaded_gpg_keysR   t   setCacheDirR	   t   patht   normpathR)   t   _persistdirt   hasattrt   rpmR\   t
   _rpmdbpatht   _have_cached_rpmdbv_datat   _cached_conflicts_datat   _trans_cache_storeR&   t
   releasevert
   auto_closet   _cached_rpmdb_mtimet   _cachet   RPMDBAdditionalDataR   (   R   R_   Rv   t   cachedirt
   persistdirt   dbpatht   addldb_pathR^   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR   À   sN    																	c         C   sÖ   |  j  s< |  j d t É } | d k	 r< | j É  |  _  q< n  |  j  s~ x6 |  j É  D]% \ } } |  j  j |  j | É É qR Wn  |  j  S(   sT   Getter for the pkglist property. 
        Returns a list of package tuples.
        t   load_packagesN(   Rh   t   preloadPackageChecksumsR   R   t   keyst   _get_packagest   appendt   _hdr2pkgTuple(   R   t   csumpkgtupsR   R'   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _get_pkglist˝   s    		 c         C   s÷   i  |  _  i  |  _ t É  |  _ i  |  _ t |  _ t É  |  _ t É  |  _ t É  |  _	 g  |  _
 i  |  _ i  |  _ t d k	 rà t j É  n  i i  d 6i  d 6i  d 6i  d 6|  _ d |  _ d |  _ |  j É  d |  _ d S(   s¯    Drop all cached data, this is a big perf. hit if we need to load
            the data back in again. Also note that if we ever call this while
            a transaction is ongoing we'll have multiple copies of packages
            which is _bad_. R/   R<   RP   RZ   N(   R`   Ra   R.   Rb   Rc   R   Rd   Rf   Re   Rg   Rh   Ri   Rj   t   miscR   t   unshare_dataRy   Rs   Rt   t   transactionResetRx   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   dropCachedData  s,    									
c         C   s™  t  |  _ t É  |  _ t É  |  _ g  |  _ i  |  _ i  |  _ t d k	 rU t j
 É  n  i i  d 6i  d 6i  d 6i  d 6|  _ d |  _ d |  _ |  j É  |  j d } t j j | É |  _ d Ñ  } g  } xÈ | D]· } |  j j | j É | |  j | j É | j t j k rq|  j j | j É | j | É | j rq|  j | j } | |  j  | j! É | |  j | j É qqn  | j t j" k rŒ | |  j  | j# j! É | |  j | j É qŒ qŒ Wx | D]Ë } | j \ } } }	 }
 } |  j$ | |	 |
 | | É } | s|  j% d É q∫n  | d } | j# j& É  } | d k r7q∫n  t' | d É t' | d	 É } } d
 | j( j) k s∫d | j( j) k rÇq∫n  | | j( j) d
 <| | j( j) d <q∫Wd S(   s˙    Drop cached data that is assocciated with the given transaction,
            this tries to keep as much data as possible and even does a
            "preload" on the checksums. This should be called once, when a
            transaction is complete. R/   R<   RP   RZ   s	   /Packagesc         S   s   | |  k r |  | =n  d S(   sZ    Make sure we never traceback here, because it screws our yumdb
                if we do. N(    (   t   xt   y(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt	   _safe_delP  s    s   dCDPT(pkg checksums)i    i   t   checksum_typet   checksum_dataN(*   R   Rd   R.   Rf   Rg   Rh   Ri   Rj   Rá   R   Rà   Ry   Rs   Rt   Râ   Rr   R	   Rm   t   getmtimeRx   Rb   t   discardt   nameRa   t   output_statet	   constantst   TS_INSTALL_STATESRe   RÉ   t	   reinstallRc   t   pkgtupR`   R   t   TS_REMOVE_STATESt   pot   searchNevrat   _deal_with_bad_rpmdbcachet   returnIdSumRO   t
   yumdb_infot   _read_cached_data(   R   t   txmbrst
   rpmdbfnameRç   t   precachet   txmbrt   ipot   nt   aR   t   vt   rR9   t   csumt   Tt   D(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   dropCachedDataPostTransaction-  sb    							
		
!c         C   sÄ   t  j j | É j |  j É s5 |  j d | |  _ n d | |  _ t |  d É r| t  j j |  j d É } | |  j j _	 n  d S(   s    Sets the internal cachedir value for the rpmdb, to be the
            "rpmdb-indexes" directory in the persisent yum storage. R[   R   s   /versionN(
   R	   Rm   Rn   R)   R_   t	   _cachedirRp   R   t   confR^   (   R   R{   R^   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRl   É  s    c         C   sL   |  j  s! t d |  j É |  _  n  |  j  j sE t d |  j É |  _  n  |  j  S(   NR_   (   R&   R   R_   R   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR    è  s
    	c         C   s   d  S(   N(    (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   buildIndexesñ  s    t   errorc         C   s   d  S(   N(    (   R   t   failure(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _checkIndexesö  s    c         C   s   d  S(   N(    (   R   t   obj(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt
   delPackageû  s    t   likec   
      C   s±   i  } |  j  d d } |  j d | t j | f g É } x9 | D]1 \ } } |  j | | É } | j | j | É q? W|  j | É }	 x! |	 D] } | j | j | É qä W| j É  S(   NR/   i    t   patterns(	   t	   DEP_TABLERÇ   Rq   t   RPMMIRE_GLOBt   _makePackageObjectt
   setdefaultt   pkgidt   searchFilest   values(
   R   Rí   t
   query_typet   resultt   tagR'   R   R   R9   t   fileresults(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt	   searchAll¢  s    !c         C   sj   i  } t  j j | É } xE |  j d | É D]1 \ } } |  j | | É } | j | j | É q+ W| j É  S(   s;   search the filelists in the rpms for anything matching namet	   basenames(   R	   Rm   Rn   RÇ   R∏   Rπ   R∫   Rº   (   R   Rí   Ræ   R   R   R9   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRª   ≤  s    c         C   sq  |  j  | j | É } | d  k	 r& | St j | É \ } } \ } } } t }	 t j | É re t }	 n  i  } |  j | d }
 xÖ |  j	 |
 t j
 | É É D]h \ } } |  j | | É } |	 sÛ | j | | | | | | f f É r | | | j <q qò | | | j <qò W| d k rP| d d k rP|  j | É } x | D] } | | | j <q6Wn  | j É  } | |  j  | | <| S(   Ni    R/   R[   (   Ry   t   getR   Rá   t   string_to_prco_tupleR   t   re_globR   R∂   RÇ   t   to_utf8R∏   t	   checkPrcoR∫   Rª   Rº   (   R   Rí   t   prcotypeRæ   R§   t   fR   R¶   Rß   t   globRø   R   R   Rô   R¿   R9   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt
   searchPrco¬  s,    !	($c         C   sB   | |  j  k r g  S|  j | d É } | s> |  j  j | É n  | S(   NR/   (   Rg   RÀ   R1   (   R   Rí   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   searchProvides‚  s    c         C   s   |  j  | d É S(   NR<   (   RÀ   (   R   Rí   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   searchRequiresÍ  s    c         C   s   |  j  | d É S(   NRZ   (   RÀ   (   R   Rí   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   searchObsoletesÌ  s    c         C   s   |  j  | d É S(   NRP   (   RÀ   (   R   Rí   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   searchConflicts  s    c         C   s   |  j  S(   N(   t   pkglist(   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   simplePkgListÛ  s    c         C   sj   | s
 d  S| \ } } |  j  d | d | É } | sG t j d | Ç n  g  t j | É D] } | j ^ qW S(   NRí   R   s   No Package Matching %s(   t   _searchR$   R%   Rá   t   newestInListRó   (   R   t   naTupRµ   Rí   R   t   allpkgRô   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   returnNewestByNameArch¯  s    c         C   sB   | s
 d  S|  j  d | É } | s5 t j d | Ç n  t j | É S(   NRí   s   No Package Matching %s(   R“   R$   R%   Rá   R”   (   R   Rí   t   allpkgs(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   returnNewestByName  s    c         C   s⁄   |  s t  |  É t j k r  d  Sg  } x≠ |  D]• } | s? q- n  | d } | d k r^ d  } n  | r≠ | d  k	 r | j É  } n  | j | t j t j	 | É t j
 É f É q- | j | t j t j	 | É É f É q- W| S(   Ni    t   ?t   *t   [(   RŸ   R⁄   R€   (   t   lenRî   t   PATTERNS_MAXR   t   lowerRÉ   t   ret   compilet   fnmatcht	   translatet   I(   Rµ   t   ignore_caseR   t   patt   qpat(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _compile_patterns  s    
	.)c         C   sL  |  d k r t Sx5|  D]-\ } } | d } | d k rB d } n t | É } | d d } | rq | j É  } n  | d k	 rü | | k rü | | d k rü q n  | j | d É r∂ t S| j d | É rÕ t S| j d | É r‰ t S| j d | É r˚ t S| j d | É rt S| j | d	 | É r-t S| j d
 | É r t Sq Wt S(   s<    This is basically parsePackages() but for rpm hdr objects. t   epocht   0Rí   i    s)   %(name)s-%(version)s-%(release)s.%(arch)ss   %(name)s.%(arch)ss   %(name)s-%(version)ss    %(name)s-%(version)s-%(release)ss*   :%(name)s-%(version)s-%(release)s.%(arch)ss3   %(name)s-%(epoch)s:%(version)s-%(release)s.%(arch)sN(   R   R   RO   Rﬁ   t   matchR   (   t
   repatternsR   R‰   RÊ   t   repatRË   t   qname(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _match_repattern%  s:    
	(	
c         C   s@  |  j  rW | rW g  } x> | D]/ } |  j | g É } | s? Pn  | j | É q W| Sn  g  } | rﬂ | rﬂ g  } xY | D]Q } | |  j k rí qw n  | |  j k rª | j |  j | É qw n  | j | É qw W| } | sﬂ | Sn  |  j  sQ|  j | | É } xB |  j É  D]4 \ }	 }
 |  j	 | |	 | É r|  j
 |	 |
 É qqW| d k |  _  n  |  j j É  } |  j rîg  | D] } | j d k rp| ^ qp} n  | r<t | | | É } |  j j | d É | r‡| d | d | } n | d | d } xG | D]< } x3 | D]+ } | j | k r|  j j | j É qqWq˘Wn  | S(   sŒ   Returns a list of packages. Note that the packages are
           always filtered to those matching the patterns/case. repoid is
           ignored, and is just here for compatibility with non-rpmdb sacks. s
   gpg-pubkeyi   i    i   N(   Rd   t   searchNamest   extendRf   Rb   Ra   RÉ   RÁ   RÇ   RÓ   R∏   R   R`   Rº   Rk   Rí   R   t   updateR1   (   R   t   repoidRµ   R‰   R   RÂ   t   pkgst   tpatst   rpatsR   R   t
   pkgobjlistR9   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   returnPackagesH  sR    			+!c         C   s∑   |  j  d k r∞ i  } xÜ |  j d É D]u \ } } | t j sD q% n  |  j | | É } | | | j <| j rr q% n  | | _ t	 | _ | j
 t | _ | ` q% W| j É  |  _  n  |  j  S(   s¡    Load the packages which have conflicts from the rpmdb, newer
            versions of rpm have an index here so this is as fast as
            cached (we test rpm version at cache write time). t   conflictnameN(   Rt   R   RÇ   Rq   t   RPMTAG_CONFLICTNAMER∏   R∫   R   R   R   RP   R   Rº   (   R   Ræ   R   R   Rô   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt    _uncached_returnConflictPackagesÉ  s     				
c         C   s¬   t  j |  j t  j É s d  S|  j d } t | d d É } | j d | É | j d t | É É x9 t | É D]+ } x" | j D] } | j d | É qÅ Wqq W| j	 É  t  j
 | d | É d  S(   Ns
   /conflictss   .tmpt   ws   %s
s   %u
(   R	   t   accessR¨   t   W_OKR   t   writeR‹   t   sortedRó   t   closet   rename(   R   RÛ   t   rpmdbvt   conflicts_fnamet   foR9   t   var(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _write_conflicts_newû  s    
c         C   s*   |  j  d t É d } |  j | | É d  S(   Nt	   main_onlyi    (   t   simpleVersionR   R  (   R   RÛ   R  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _write_conflicts¨  s    c         C   sd   t  j |  j d É t  j |  j d É t  j |  j d É t  j |  j d É t j d | Ç d S(   sä    This shouldn't be called, but people are hitting weird stuff so
            we want to deal with it so it doesn't stay broken "forever". s   /versions
   /conflictss   /file-requiress   /pkgtups-checksumss   Rpmdb checksum is invalid: %sN(   Rá   t   unlink_fR¨   R$   R%   (   R   t   caller(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRõ   ∞  s
    c   
      C   sZ  |  j  s d  Sd Ñ  } |  j d } t | É \ } } | d  k rE d  S| j É  } |  j d t É d } | s~ | | d  k rÇ d  Sg  } y† t | | É É } xq | d k r| d 8} | | É | | É | | É | | É | | É f }	 t |	 d É | j |  j	 |	 É É q† W| j É  d k r'd  SWn t
 k
 rI|  j d	 É d  SX| |  _ |  j S(
   Nc         S   s   |  j  É  d  S(   Niˇˇˇˇ(   t   readline(   R  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt	   _read_str…  s    s
   /conflictsR  i    iˇˇˇˇi   i   t    RP   (   t   __cache_rpmdb__R   R¨   R   R  R  R   t   intR   t   searchPkgTuplet
   ValueErrorRõ   Rt   (
   R   R  t   conflict_fnameR  R   t   frpmdbvR  R   t   pkgtups_numRó   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _read_conflicts≈  s6    		
!	c         C   s   |  j  r | |  j d <n  d  S(   NRP   (   R  Ru   (   R   RÛ   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt    transactionCacheConflictPackagesÍ  s    	c         C   sD   |  j  É  } | d k r@ |  j É  } |  j r@ |  j | É q@ n  | S(   s0    Return a list of packages that have conflicts. N(   R  R   R˙   R  R	  (   R   RÛ   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   returnConflictPackagesÓ  s    	c         C   s∞   |  j  s i  |  _ d Sd |  j k rE |  j d } |  j | | É n  d |  j k rt |  j d } |  j | | É n  d |  j k r£ |  j d } |  j | | É n  i  |  _ d S(   s¡    We are going to do a transaction, and the parameter will be the
            rpmdb version when we finish. The idea being we can update all
            our rpmdb caches for that rpmdb version. NRP   s   file-requiress   pkgtups-checksums(   R  Ru   R  t   _write_file_requirest   _write_package_checksums(   R   R  RÛ   t   data(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   transactionResultVersion¯  s    		c         C   s   i  |  _  d S(   s©    We are going to reset the transaction, because the data we've added
            already might now be invalid (Eg. skip-broken, or splitting a
            transaction). N(   Ru   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRâ     s    c         C   sa   |  j  É  } | j d d É } g  } x6 | D]. } t |  _ | j |  j | | j É  É É q+ W| S(   s/    Return packages of the gpg-pubkeys ... hacky. Rí   s
   gpg-pubkey(   R    R!   R   Rk   RÉ   R∏   t   instance(   R   R&   R'   R   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   returnGPGPubkeyPackages  s    	#c         C   sX  d Ñ  } |  j  s t Ç t |  j d É \ } } | d  k rA d
 S|  j d t É d } | j É  } | sz | | d  k r~ d Si  } i  } y¢t | | É É } xØ | d k rP| d 8} | | É | | É | | É | | É | | É f }	 t |	 d É t | | É É }
 x? |
 d k rL|
 d 8}
 | | É } | j	 |	 g  É j
 | É qWq¢ Wt | | É É }
 xØ |
 d k r|
 d 8}
 | | É } t | | É É } xt | d k r| d 8} | | É | | É | | É | | É | | É f }	 t |	 d É | j	 | g  É j
 |	 É qùWqfW| j É  d k r+d SWn t k
 rM|  j d	 É d SX| | f S(   Nc         S   s   |  j  É  d  S(   Niˇˇˇˇ(   R  (   R  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR  !  s    s   /file-requiresR  i    iˇˇˇˇi   i   R  s   file requires(   NN(   NN(   NN(   NN(   R  t   AssertionErrorR   R¨   R   R  R   R  R  Rπ   RÉ   R  Rõ   (   R   R  R  R   R  R  t   iFRt   iFPR  Ró   t	   files_numt   fname(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _read_file_requires   sP    	
!
!

!!c         C   s∂  |  j  r: |  j É  \ } } | d k	 r: | t É  | f Sn  i  } t É  } t É  } x© |  j É  D]õ } xí | j D]á \ } } }	 | j d É sì qo n  | j | j g  É j	 | É | | k ro |  j
 | | |	 É }
 | j | É |
 sˆ | j | É qˆ qo qo Wq_ Wt É  } x! | j É  D] } | j | É qWi  } x= | D]5 } g  |  j
 | É D] } | j ^ qN} | | | <q8W| | | f } |  j  r≤|  j d t É d } |  j | | É n  | S(   s·    Get a cached copy of the fileRequiresData for
            depsolving/checkFileRequires, note the giant comment in that
            function about how we don't keep this perfect for the providers of
            the requires. R[   R  i    N(   R  R$  R   R.   R˜   R<   R)   Rπ   Ró   RÉ   R=   R1   t
   itervaluesRÒ   R  R   R  (   R   R   R!  t   installedFileRequirest   installedUnresolvedFileRequirest   resolvedR9   Rí   t   flagt   evrt   dept   fileRequirest   fnamest   installedFileProvidersR#  t   pkgtupsR   R  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   fileRequiresData\  s<    				%		c         C   s=   |  j  s d  S| s | r d  S| | | f } | |  j d <d  S(   Ns   file-requires(   R  Ru   (   R   R&  R'  t   installedFileProvidest   problemsR  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   transactionCacheFileRequiresÑ  s    		c         C   s∆  t  j |  j t  j É s d  S| \ } } } | r5 d  St |  j d d É } | j d | É | j d t | É É xÖ t | É D]w } x | D] } | j d | É qç Wt | | É }	 | j d t |	 É É x% t |	 É D] }
 | j d |
 É q‹ WqÄ W| j d t | É É xÖ t | É D]w }
 | j d |
 É t | |
 É } | j d t | É É x6 t | É D]( } x | D] } | j d | É qwWqjWqW| j	 É  t  j
 |  j d |  j d É d  S(   Ns   /file-requires.tmpR˚   s   %s
s   %u
s   /file-requires(   R	   R¸   R¨   R˝   R   R˛   R‹   Rˇ   R.   R   R  (   R   t   rpmdbversionR  R&  R'  R1  R  Ró   R  t	   filenamesR#  R/  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR  î  s4    
c         C   sQ  |  j  s d Sd Ñ  } t |  j d É \ } } | d k r? d S|  j d t É d } | j É  } | sx | | d  k r| d Si  } yÀ t | | É É } xú | d k r5| d 8} | | É | | É | | É | | É | | É f }	 t |	 d É | | É }
 | | É } |
 d	 k r"d | |	 <qö |
 | f | |	 <qö W| j É  d
 k rLd SWn t k
 rn|  j	 d É d SX| sy| Sx— | D]… }	 | |	 d k rúqÄn  |	 \ } } } } } |  j
 | | | | | É } | sÂ|  j	 d É qÄn  | d } | |	 \ }
 } d | j j k sÄd | j j k r)qÄn  |
 | j j d <| | j j d <qÄWd S(   sI   As simpleVersion() et. al. requires it, we "cache" this yumdb data
            as part of our rpmdb cache. We cache it with rpmdb data, even
            though someone _could_ use yumdb to alter it without changing the
            rpmdb ... don't do that.
            NOTE: This is also used as a cache of pkgtups in the rpmdb. Nc         S   s   |  j  É  d  S(   Niˇˇˇˇ(   R  (   R  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR  √  s    s   /pkgtups-checksumsR  i    iˇˇˇˇi   i   t   -R  s   pkg checksumsRé   Rè   (   R  R   R¨   R   R  R   R  R  R  Rõ   Rö   Rù   Rû   (   R   R   R  R  R   R  R  Rè   R  Ró   R©   R™   R§   R•   R¶   Rß   R9   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRÄ   ∫  sZ    		
!
c         C   s   |  j  s d  S| |  j d <d  S(   Ns   pkgtups-checksums(   R  Ru   (   R   t   pkg_checksum_tups(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt    transactionCachePackageChecksums¸  s    	c         C   s  t  j |  j t  j É s d  S| } t |  j d d É } | j d | É | j d t | É É xs t | É D]e \ } } x | D] } | j d | É qÄ W| d  k r∞ d } n  x | D] } | j d | É q∑ Wqm W| j	 É  t  j
 |  j d |  j d É d  S(   Ns   /pkgtups-checksums.tmpR˚   s   %s
s   %u
R6  s   /pkgtups-checksums(   R6  R6  (   R	   R¸   R¨   R˝   R   R˛   R‹   Rˇ   R   R   R  (   R   R4  R  R7  R  Ró   t   TDR  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR    s     	
c         C   sŸ   |  j  d k	 r |  j  S|  j s# d S|  j d } |  j d } t j j | É r“ t j j | É r“ t j j | É } t j j | É } | | k r“ t	 | É \ } } | d k r≥ d S| j
 É  d  } | |  _  q“ n  |  j  S(   s.    Return the cached string of the main rpmdbv. s   /versions	   /PackagesiˇˇˇˇN(   Rs   R   R  R¨   Rr   R	   Rm   t   existsRê   R   R  (   R   t   rpmdbvfnameR†   t   nmtimet   omtimeR  R   R  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _get_cached_simpleVersion_main  s     	$c         C   s;  t  | É |  _ |  j s d  S|  j d  k r/ d  S|  j d } t j j | É sR d  St j j	 | É } |  j | k rw d  S|  j
 d } t j |  j
 t j É sÈ t j j |  j
 É rµ d  Sy t j |  j
 É WqÈ t t f k
 rÂ } d  SXn  t | d d É } | j |  j É | j d É | j É  t j | d | É d  S(   Ns	   /Packagess   /versions   .tmpR˚   s   
(   RO   Rs   R  Rx   R   Rr   R	   Rm   R:  Rê   R¨   R¸   R˝   t   makedirsR   t   OSErrorR   R˛   R   R  (   R   R  R†   Rx   R;  R   R  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _put_cached_simpleVersion_main/  s0    	
c         C   s  d Ñ  } | r; | r; |  j  É  } | d k	 r; | i  g Sn  t É  } i  } i  } i  } xvt |  j É  É D]b}	 |	 j }
 d } d |
 k r´ d |
 k r´ |
 j |
 j f } n  | j |	 | É x^ | D]V } |	 j	 | | k r¬ | | k rt É  | | <i  | | <n  | | j |	 | É q¬ q¬ W| r(qi n  d } d } d |	 j k rtd |	 j j
 } d |	 j k rt|	 j j } qtn  | | | | |	 | É x> | D]6 } |	 j	 | | k rë| | | | | |	 | É qëqëWqi W|  j d k rÓ|  j | É n  | r| | | | g S| | g S(	   s5    Return a simple version for all installed packages. c         S   so   |  j  | i  É } | j  d  t É  É } | j | | É | d  k	 rk | j  | t É  É } | j | | É n  d  S(   N(   Rπ   R   R   RÒ   (   t   ireposRÚ   t   revR9   R®   t   irevst   rpsv(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _up_revsT  s    Ré   Rè   t	   installedt	   from_repot   @t   from_repo_revisionN(   R>  R   R   Rˇ   R˜   Rù   Ré   Rè   RÒ   Rí   RH  RJ  Rs   RA  (   R   R  t   groupsRF  R  t   mainRB  t	   main_grpst   irepos_grpsR9   t   ydbiR®   t   groupRÚ   RC  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR  R  sL    			%c         C   sk   d } x^ | D]V } xM |  D]E } t  | | É } | r | j É  j | É d k r | d 7} Pq q Wq W| S(   Ni    iˇˇˇˇi   (   R   Rﬁ   t   find(   t   fieldst   searchstringsR   t   countt   st   fieldt   value(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _find_search_fieldsâ  s    !
c         C   sÖ   | s t  d Ñ  | É } n  g  } x] |  j É  D]O \ } } |  j | | | É } | d k r. | j |  j | | É | f É q. q. W| S(   Nc         S   s
   |  j  É  S(   N(   Rﬁ   (   Rã   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   <lambda>ó  s    i    (   RN   RÇ   RX  RÉ   R∏   (   R   RR  RS  t   loweredR   R   R   R§   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt"   searchPrimaryFieldsMultipleStringsî  s    &c         C   s4   g  } x' | D] } | j  |  j d | É É q W| S(   NRí   (   R   R“   (   R   t   namest
   returnListRí   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRÔ   û  s    c         C   s   |  j  | | | | | É S(   N(   R“   (   R   Rí   RË   t   vert   relR   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRö   §  s    c         C   s   d  S(   N(    (   R   t   archlist(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   excludeArchsß  s    c         C   sA   |  j  É  } g  | j d t É D] \ } } |  j | | É ^ q S(   Nt   headers(   R    t   returnLeafNodesR   R∏   (   R   RÚ   R&   t   hR'   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRc  ™  s    c         o   ss   |  j  É  } | j | | é  } x2 | D]* } | d d k r% | | j É  f Vq% q% W~ |  j ro |  j j É  n  d S(   sL   dbMatch() wrapper generator that yields (header, index) for matches
        Rí   s
   gpg-pubkeyN(   R    R!   R  Rw   R&   R   (   R   R   t   kwdsR&   R'   Rd  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRÇ   Ø  s    	c         C   sA  | d k	 r | |  j k r g  S| | | | | f } | |  j k rQ |  j | g St É  } g  } |  j sx | |  j k r!| d k	 rµ |  j j | g  É }	 |	 s¡ |  j j | É q¡ n |  j	 É  }	 xY |	 D]Q }
 xH d D]3 } | | d k	 r’ | | t
 |
 | É k r’ Pq’ q’ W| j |
 É q» W| S|  j É  } | d k	 rN|  j d | É } n6 | d k	 ro|  j d | É } n |  j É  } t |  _ t } xä | D]Ç \ } } |  j | | É }
 |  j j |
 j É t } xH d D]3 } | | d k	 rœ| | t
 |
 | É k rœPqœqœW| j |
 É qëW| r=| d k	 r=|  j j | É n  | S(	   s4   List of matching packages, to zero or more of NEVRA.R   R_  R^  RË   Rí   N(   s   archs   rels   vers   epoch(   s   archs   rels   vers   epoch(   R   Re   Rc   t   localsRd   Rb   Ra   R√   R1   t
   returnPkgst   getattrRÉ   R    RÇ   R   R   R∏   Rí   (   R   Rí   RË   R^  R_  R   Ró   t   locR   RÛ   Rô   Rø   R&   R'   t   doneR   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR“   Ω  sL    	)	)c         C   s©   | |  j  k r |  j  | St | | |  É } | |  j  | <|  j j | j g  É j | É | |  j | j <|  j r• |  j	 d  k r• |  j d } t j j | É |  _	 n  | S(   Ns	   /Packages(   R`   R   Ra   Rπ   Rí   RÉ   Rc   Ró   R  Rx   R   Rr   R	   Rm   Rê   (   R   R   R   Rô   R†   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR∏   Ù  s    c         C   sÆ   t  j | d É } t  j | d É } t  j t | d É É } t  j t | d É É } | d } | d  k rw d } n t | É } t  j | É } t  j | | | | | f É S(   NRí   R   t   versiont   releaseRË   RÈ   (   Rá   t
   share_dataRO   R   (   R   R   Rí   R   R^  R_  RË   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRÑ     s    
	c         C   s   t  j d t d d É|  j S(   Nsc   getPkgList() will go away in a future version of Yum.
Please access this via the pkglist attribute.t
   stackleveli   (   t   warningst   warnt   DeprecationWarningR–   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt
   getPkgList  s    	c         C   s9   t  j d t d d Ég  |  j É  D] \ } } | ^ q# S(   Ns6   getHdrList() will go away in a future version of Yum.
Rn  i   (   Ro  Rp  Rq  RÇ   (   R   R   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt
   getHdrList  s    	c         C   s_   t  j d t d d Ég  } x3 |  j D]( \ } } } } } | j | | f É q& Wt j | É S(   Ns>   getNameArchPkgList() will go away in a future version of Yum.
Rn  i   (   Ro  Rp  Rq  R–   RÉ   R    t   unique(   R   t   lstRí   R   RË   R^  R_  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   getNameArchPkgList  s    	c         C   sY   t  j d t d d Ég  } x- |  j D]" \ } } } } } | j | É q& Wt j | É S(   Ns:   getNamePkgList() will go away in a future version of Yum.
Rn  i   (   Ro  Rp  Rq  R–   RÉ   R    Rt  (   R   Ru  Rí   R   RË   R^  R_  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   getNamePkgList&  s    	c         C   sT   t  j d t d d Ég  |  j d | d | d | d | d | É D] } | j ^ qA S(	   Ns@   returnTuplebyKeyword() will go away in a future version of Yum.
Rn  i   Rí   R   RË   R^  R_  (   Ro  Rp  Rq  R“   Ró   (   R   Rí   R   RË   R^  R_  Rô   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   returnTupleByKeyword0  s    	c   	      C   sÉ   t  j d t d d É| \ } } } } } |  j d | d | d | d | d | É } t | É d	 k r{ | d	 } | j g Sg  Sd  S(
   Ns?   returnHeaderByTuple() will go away in a future version of Yum.
Rn  i   Rí   R   RË   R^  R_  i    (   Ro  Rp  Rq  Rö   R‹   R   (	   R   t   pkgtupleR§   R•   R   R¶   Rß   Ru  t   item(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   returnHeaderByTuple5  s    	*

c         C   so   t  j d t d d É| \ } } } } } | d	 k r@ d } n  g  |  j | | | | | É D] } | j ^ q\ S(
   s?   returns a list of header indexes based on the pkgtuple provideds>   returnIndexbyTuple() will go away in a future version of Yum.
Rn  i   i    s   (none)R  RÈ   N(   Ni    s   (none)R  (   Ro  Rp  Rq  R   R“   R   (   R   Ry  Rí   R   RË   Rk  Rl  Rô   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   returnIndexByTupleC  s    		c         C   s
   t  Ç d  S(   N(   t   NotImplementedError(   R   R&   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   addDBQ  s    c         C   sÃ   | d k r d } n  t | É t j k rE t j | É \ } } } n> t | É t j t j f k ru | \ } } } n d } } } |  t j	 | É t j	 | É t j	 | É t j	 | É f f } t j	 | É S(   s2    Given random stuff, generate a usable dep tuple. i    N(
   R   t   typet   typest
   StringTypeR    t   stringToVersiont	   TupleTypet   ListTypeRá   Rm  (   Rí   t   flagsRk  t   r_et   r_vt   r_rt   deptup(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt
   _genDeptupU  s    	c   
      C   s‡   t  j | É } |  j | | | É } | |  j k r> |  j | S| d d } |  j | É } i  } xk | D]c } | d d k r¶ | d k r¶ | d d f g | | <qh n  | j d | É }	 |	 rh |	 | | <qh qh W| |  j | <| S(   sÅ   searches the rpmdb for what provides the arguments
           returns a list of pkg objects of providing packages, possibly emptyi   i   i    R[   R/   N(   NNN(   Rá   Rm  Rä  Ri   RÃ   R   t   matchingPrcos(
   R   Rí   RÖ  Rk  Râ  Rá  RÛ   Ræ   Rô   t   hits(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR=   k  s     c         C   s)   g  |  j  | | | É D] } | j ^ q S(   N(   R=   Ró   (   R   Rí   RÖ  Rk  Rô   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   whatProvidesÉ  s    c   
      C   s‡   t  j | É } |  j | | | É } | |  j k r> |  j | S| d d } |  j | É } i  } xk | D]c } | d d k r¶ | d k r¶ | d d f g | | <qh n  | j d | É }	 |	 rh |	 | | <qh qh W| |  j | <| S(   s   searches the rpmdb for what provides the arguments
           returns a list of pkgtuples of providing packages, possibly emptyi   i   i    R[   R<   N(   NNN(   Rá   Rm  Rä  Rj   RÕ   R   Rã  (
   R   Rí   RÖ  Rk  Râ  Rá  RÛ   Ræ   Rô   Rå  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR0   á  s     c         C   s)   g  |  j  | | | É D] } | j ^ q S(   N(   R0   Ró   (   R   Rí   RÖ  Rk  Rô   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   whatRequires†  s    c         C   sk   i  } xR t  j É  D]D } x; t  j | É D]* } x! |  j | É D] } d | | <q? Wq) Wq Wt | j É  É S(   sq   returns a list of yum installed package objects which own a file
           that are currently running or in use.i   (   Rá   t   return_running_pidst   get_open_filesRª   Rˇ   RÅ   (   R   RÛ   t   pidR:   R9   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   return_running_packages§  s    c      	   C   sº  | d k r |  j É  } n  t É  } g  } xãt | É D]}} x¬ | j D]∑ } | d j d É rf qG n  | | k rx qG n  | \ } } } |  j | | | É rØ | j | É qG n  t j	 j
 j | | É } t j | | | É }	 t | d d |	 É}
 | j |
 É qG WxØ | j D]§ } | d j d É r+qn  | \ } } } |  j | | | É } | s[qn  t j	 j
 j | | É } t j | | | É } t | d d | d | É}
 | j |
 É qWq7 W| S(   s&    Checks for any missing dependencies. i    t   rpmlibR<   RK   RP   RL   N(   R   R˜   R.   Rˇ   R<   R)   R=   R1   t   yumt   depsolveRÖ  R√   R    t   formatRequireRJ   RÉ   RP   (   R   RÛ   t	   providersR2  R9   t   rreqt   reqRÖ  R^  RK   t   probt   creqt   resRL   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   check_dependenciesØ  s>    	   	c         c   sÉ   d  } xv t |  j É  É D]b } | j | k r4 q n  | j t | j É É rR q n  | d  k rj | } q n  | | f V| } q Wd  S(   N(   R   Rˇ   R˜   Rí   t   intersectionR.   t   provides_names(   R   t   ignore_providest   lastR9   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _iter_two_pkgs”  s    c         C   s”   t  | É } g  } x∫ |  j | É D]© \ } } | j | j k rF q" n  | j | É r≤ | | k r≤ t j | j É rà | j d k rà q" n  t j | j É r≤ | j d k r≤ q" q≤ n  | j t | d | ÉÉ q" W| S(   s€    Checks for any "duplicate packages" (those with multiple versions
            installed), we ignore any packages with a provide in the passed
            provide list (this is how installonlyworks, so we do the same). t   noarchRS   (   R.   R¢  Rí   t   verEQR   t   isMultiLibArchRÉ   RR   (   R   R†  R2  R°  R9   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   check_duplicates·  s    !!	c         C   sô   g  } g  } x6 t  |  j É  É D]" } | j s4 q n  | j | É q WxM t  |  j É  É D]9 } x0 | j | É D] } | j t | d | ÉÉ qn WqX W| S(   s@    Checks for any packages which are obsoleted by other packages. RV   (   Rˇ   R˜   RZ   RÉ   t   obsoletedByRT   (   R   t
   obsoletersR2  R9   t   obspo(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   check_obsoletedÙ  s    	!c         C   sÇ   g  } xu t  |  j É  É D]a } xX | j D]M } | \ } } } | |  j | | | É k r) | j t | d | ÉÉ Pq) q) Wq W| S(   sq    For each package, check that a provides search for it's name (and
            everything it provides) finds it. RX   (   Rˇ   R˜   R/   R=   RÉ   RW   (   R   R2  R9   t   provtupRí   RÖ  Rk  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   check_provides  s    N(   NNN(   NNN(b   R?   R@   RI   Rq   t   RPMTAG_REQUIRENAMEt   RPMTAG_REQUIREVERSIONt   RPMTAG_REQUIREFLAGSt   RPMTAG_PROVIDENAMEt   RPMTAG_PROVIDEVERSIONt   RPMTAG_PROVIDEFLAGSR˘   t   RPMTAG_CONFLICTVERSIONt   RPMTAG_CONFLICTFLAGSt   RPMTAG_OBSOLETENAMEt   RPMTAG_OBSOLETEVERSIONt   RPMTAG_OBSOLETEFLAGSR∂   R   R  R   R   RÜ   t   propertyR–   Rä   R´   Rl   R    RÆ   R±   R≥   R¡   Rª   RÀ   RÃ   RÕ   RŒ   Rœ   R—   R   t   containsRG  R÷   Rÿ   t   staticmethodR   RÁ   RÓ   R˜   R˙   R  R	  Rõ   R  R  R  R  Râ   R  R$  R0  R3  R  RÄ   R8  R  R>  RA  R  RX  R[  RÔ   Rö   Ra  Rc  RÇ   R“   R∏   RÑ   Rr  Rs  Rv  Rw  Rx  R{  R|  R~  Rä  R=   Rç  R0   Ré  Rí  Rù  R¢  R¶  R™  R¨  (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRY   ¥   s¥   	1			V						 						#;					%		
			
	<	(		&B				#7			7					
	
						$		c         C   s   |  j  d d É j  d d É S(   NR[   R  t   ~(   t   replace(   Rm   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt	   _sanitize  s    Rz   c           B   sJ   e  Z d  Z d d d Ñ Z d Ñ  Z d Ñ  Z d d d d Ñ Z d Ñ  Z RS(   sQ   class for access to the additional data not able to be stored in the
       rpmdbs   /var/lib/yum/yumdbc         C   s’   t  j É  |  _ | |  j _ | |  j _ t |  j _ i  |  _ t j	 j
 |  j j É só y t j |  j j É Wn t t f k
 rá } d  SXt |  j _ n* t j |  j j t j É r¡ t |  j _ n  i i  d 6|  _ d  S(   Nt   attr(   Rá   t   GenericHolderR≠   R]   R^   R   t   writablet	   _packagesR	   Rm   R:  R?  R   R@  R   R¸   R˝   t   yumdb_cache(   R   R]   R^   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR     s    	c         C   s`   d |  j  j } t j | É } x: | D]2 } t j j | É j d É d } | |  j | <q& Wd  S(   Ns   %s/*/*/R6  i    (   R≠   R]   R    R	   Rm   t   basenamet   splitR¡  (   R   t   glbt   pkgdirst   dR∫   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _load_all_package_paths.  s
    c   	      C   su   | |  j  k r |  j  | S| \ } } } } } t | É } d |  j j | d | | | | | f } | |  j  | <| S(   Ns   %s/%s/%s-%s-%s-%s-%si    (   R¡  RΩ  R≠   R]   (	   R   Ró   R∫   R§   R•   R   R¶   Rß   t   thisdir(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _get_dir_name6  s    c         C   sd   | r! |  j  | j | j É } n* | rB | rB |  j  | | É } n	 t d Ç t |  j | d |  j ÉS(   s<   Return an RPMDBAdditionalDataPackage Object for this packages1   Pass something to RPMDBAdditionalData.get_packageR¬  (   R   Ró   R∫   R  t   RPMDBAdditionalDataPackageR≠   R¬  (   R   Rô   Ró   R∫   R…  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   get_package@  s    	c         C   s   d S(   sè   populate out the dirs and remove all the items no longer in the rpmd
           and/or populate various bits to the currently installed versionN(    (   R   t   rpmdbobj(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   sync_with_rpmdbL  s    	N(	   R?   R@   RI   R   R   R»  R   RÃ  RŒ  (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRz     s   		
RÀ  c        
   B   s¬   e  Z e d  d d d d d d d d g	 É Z d d	 Ñ Z d d
 Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z d Ñ  Z d d Ñ Z RS(   Ré   t   reasont   installed_byt
   changed_byRH  RJ  t   from_repo_timestampRv   t   command_linec         C   s(   | |  _  | |  _ i  |  _ | |  _ d  S(   N(   t   _conft   _mydirRû   t   _yumdb_cache(   R   R≠   t   pkgdirR¬  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR   `  s    			c         C   sG  | |  j  | <|  j d k r  d Sd } | d k	 r> | j } n  | d k r] | |  j k r] d S| |  j d k r|  j d | d } | d k	 rÒ | d k	 rÒ | j | j f | j | j f k rÒ |  j d | d j | É | |  j | <d Sn  |  j d | d | k rd Sn  | | t | g É f |  j d | <| |  j | <d S(   s˚    Create caches for the attr. We have a per. object read cache so at
            worst we only have to read a single attr once. Then we expand that
            with (dev, ino) cache, so hardlink data can be read once for
            multiple packages. Ni   Ræ  i   i    (	   Rû   R÷  R   t   st_nlinkt   _auto_hardlink_attrst   st_devt   st_inoR1   R.   (   R   Ræ  RW  R:   t   infot   nlinkst   sinfo(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _auto_cachem  s&    $#c         C   sÖ   | |  j  k rÅ |  j  | } | |  j  d k rt |  j  d | d j | É |  j  d | d st |  j  d | =qt n  |  j  | =n  d S(   s(    Remove old values from the link cache. Ræ  i   N(   R÷  Rë   (   R   R:   t   ovalue(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _unlink_yumdb_cacheä  s    c         C   sË   |  j  d k r t S|  j | É | |  j  d k r7 t S|  j  d | d sR t Ç y^ t |  j  d | d É j É  } t j | d É t	 j
 | | d É t	 j | d | É Wn t SX|  j  d | d j | É | |  j  | <t S(   sb    If we have a matching yumdb cache, link() to it instead of having
            to open()+write(). Ræ  i   s   .tmpN(   R÷  R   R   R·  R  t   iterR"   Rá   R
  R	   t   linkR  R1   R   (   R   R:   RW  t   lfn(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _link_yumdb_cacheî  s     !c         C   s   t  j j |  j d | É S(   s*    Given an attribute, return the filename. R[   (   R	   Rm   Rn   R’  (   R   Ræ  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _attr2fn≠  s    c         C   sb  t  j j |  j É s( t  j |  j É n  t | É } | |  j k rP |  j | =n  |  j | É } | j d É rÑ t	 d | |  f Ç n  | d k r¶ t
 j |  j j É n  |  j | | É rº d  St
 j | d É t | d d É } y | j | É Wn, t t f k
 r} t	 d | |  f Ç n X| j É  | j É  ~ t  j | d | É |  j | | | É d  S(   Ns   .tmps   Cannot set attribute %s on %sRé   Rè   R˚   (   s   checksum_types   checksum_data(   R	   Rm   R:  R’  R?  RΩ  Rû   RÊ  t   endswithR*   Rá   R
  R‘  R^   RÂ  R   R˛   R@  R   t   flushR   R  Rﬂ  (   R   Ræ  RW  R:   R  R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _write±  s.    

c         C   s  t  | É } | |  j k r& |  j | S|  j | É } | j d É rZ t d |  | f Ç n  t j | É } | d  k rã t d |  | f Ç n  | j d k rı |  j	 d  k	 rı | j
 | j f } | |  j	 k rı |  j | |  j	 | | | É |  j | Sn  t | É \ } } | d  k rd | j S| j É  } | j É  ~ | j d k re|  j	 d  k	 re| |  j	 | <n  |  j | | | | É | S(   Ns   .tmps   %s has no attribute %si   s   <E:%d>(   RΩ  Rû   RÊ  RÁ  R*   Rá   t   stat_fR   Rÿ  R÷  R⁄  R€  Rﬂ  R   t   errnot   readR   (   R   Ræ  R:   R‹  t   keyR  R   RW  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _read◊  s0    
c         C   sõ   t  | É } |  j | É } | |  j k r7 |  j | =n  |  j | É t j j | É ró y t j | É Wqó t t	 f k
 rì t
 d | |  f Ç qó Xn  d S(   s   remove the attribute files!   Cannot delete attribute %s on %s N(   RΩ  RÊ  Rû   R·  R	   Rm   R:  t   unlinkR   R@  R*   (   R   Ræ  R:   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   _delete¯  s    c         C   s   |  j  | É S(   N(   RÓ  (   R   Ræ  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR-     s    c         C   s9   | j  d É s" |  j | | É n t j |  | | É d  S(   NR   (   R)   RÈ  t   objectt   __setattr__(   R   Ræ  RW  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRÚ  	  s    c         C   s3   | j  d É s |  j | É n t j |  | É d  S(   NR   (   R)   R  RÒ  t   __delattr__(   R   Ræ  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRÛ    s    c         C   s   |  j  | É } | d  k	 S(   N(   R√   R   (   R   Ræ  Rã   (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   __contains__  s    c         c   sã   x |  j  D] } | Vq
 Wxk t j |  j d É D]S } | t |  j É d } | |  j  k rb q0 n  | r~ | j d É r~ q0 n  | Vq0 Wd  S(   Ns   /*i   s   .tmp(   Rû   R    R’  R‹   RÁ  (   R   t   show_hiddenRz  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   __iter__  s    	c         C   sV   x' |  j  d t É D] } |  j | É q Wy t j |  j É Wn t k
 rQ n Xd  S(   NRı  (   Rˆ  R   R  R	   t   rmdirR’  R@  (   R   Rz  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   clean&  s    c         C   s,   y |  j  | É } Wn t k
 r' | SX| S(   s   retrieve an add'l data obj(   RÓ  R*   (   R   Ræ  t   defaultRú  (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyR√   2  s
    N(   R?   R@   R.   RŸ  R   R   Rﬂ  R·  RÂ  RÊ  RÈ  RÓ  R  R-   RÚ  RÛ  RÙ  R   Rˆ  R¯  R√   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRÀ  W  s(   		
			&	!						c          C   s,   t  d É }  x |  j É  D] } | GHq Wd  S(   NR[   (   RY   R—   (   t   sackt   p(    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyRL  <  s    t   __main__(*   Rq   RÄ  Ro  R    R	   t   os.patht   rpmUtilsR    R   t   rpmUtils.transactionR   Rá   R$   t   packagesR   R   t   packageSackR   R   R·   Rﬂ   t   yum.i18nR   R   Rî   t   yum.depsolveRî  R   R   R   RA   RJ   RR   RT   RW   RY   RΩ  RÒ  Rz   RÀ  RL  R?   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/rpmsack.pyt   <module>   sJ   			E
	ˇ ˇ ˇ ˇ ˇ ^	FÂ	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python2.7/dist-packages/yum/rpmtrans.py                                                     0100644 0000000 0000000 00000057045 12451005146 020156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -t
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University
# Parts Copyright 2007 Red Hat, Inc


import rpm
import os
import fcntl
import time
import logging
import types
import sys
from yum.constants import *
from yum import _
from yum.transactioninfo import TransactionMember
import misc
import tempfile

class NoOutputCallBack:
    def __init__(self):
        pass
        
    def event(self, package, action, te_current, te_total, ts_current, ts_total):
        """
        @param package: A yum package object or simple string of a package name
        @param action: A yum.constant transaction set state or in the obscure 
                       rpm repackage case it could be the string 'repackaging'
        @param te_current: current number of bytes processed in the transaction
                           element being processed
        @param te_total: total number of bytes in the transaction element being
                         processed
        @param ts_current: number of processes completed in whole transaction
        @param ts_total: total number of processes in the transaction.
        """
        # this is where a progress bar would be called
        
        pass

    def scriptout(self, package, msgs):
        """package is the package.  msgs is the messages that were
        output (if any)."""
        pass

    def errorlog(self, msg):
        """takes a simple error msg string"""
        
        pass

    def filelog(self, package, action):
        # check package object type - if it is a string - just output it
        """package is the same as in event() - a package object or simple string
           action is also the same as in event()"""
        pass
        
class RPMBaseCallback:
    '''
    Base class for a RPMTransaction display callback class
    '''
    def __init__(self):
        self.action = { TS_UPDATE : _('Updating'), 
                        TS_ERASE: _('Erasing'),
                        TS_INSTALL: _('Installing'), 
                        TS_TRUEINSTALL : _('Installing'),
                        TS_OBSOLETED: _('Obsoleted'),
                        TS_OBSOLETING: _('Installing'),
                        TS_UPDATED: _('Cleanup'),
                        'repackaging': _('Repackaging')}
        # The fileaction are not translated, most sane IMHO / Tim
        self.fileaction = { TS_UPDATE: 'Updated', 
                            TS_ERASE: 'Erased',
                            TS_INSTALL: 'Installed', 
                            TS_TRUEINSTALL: 'Installed', 
                            TS_OBSOLETED: 'Obsoleted',
                            TS_OBSOLETING: 'Installed',
                            TS_UPDATED: 'Cleanup'}   
        self.logger = logging.getLogger('yum.filelogging.RPMInstallCallback')        
        
    def event(self, package, action, te_current, te_total, ts_current, ts_total):
        """
        @param package: A yum package object or simple string of a package name
        @param action: A yum.constant transaction set state or in the obscure 
                       rpm repackage case it could be the string 'repackaging'
        @param te_current: Current number of bytes processed in the transaction
                           element being processed
        @param te_total: Total number of bytes in the transaction element being
                         processed
        @param ts_current: number of processes completed in whole transaction
        @param ts_total: total number of processes in the transaction.
        """
        raise NotImplementedError()

    def scriptout(self, package, msgs):
        """package is the package.  msgs is the messages that were
        output (if any)."""
        pass

    def errorlog(self, msg):
        # FIXME this should probably dump to the filelog, too
        print >> sys.stderr, msg

    def filelog(self, package, action):
        # If the action is not in the fileaction list then dump it as a string
        # hurky but, sadly, not much else 
        if action in self.fileaction:
            msg = '%s: %s' % (self.fileaction[action], package)
        else:
            msg = '%s: %s' % (package, action)
        self.logger.info(msg)
            

class SimpleCliCallBack(RPMBaseCallback):
    def __init__(self):
        RPMBaseCallback.__init__(self)
        self.lastmsg = None
        self.lastpackage = None # name of last package we looked at
        
    def event(self, package, action, te_current, te_total, ts_current, ts_total):
        # this is where a progress bar would be called
        msg = '%s: %s %s/%s [%s/%s]' % (self.action[action], package, 
                                   te_current, te_total, ts_current, ts_total)
        if msg != self.lastmsg:
            print msg
        self.lastmsg = msg
        self.lastpackage = package

    def scriptout(self, package, msgs):
        if msgs:
            print msgs,

#  This is ugly, but atm. rpm can go insane and run the "cleanup" phase
# without the "install" phase if it gets an exception in it's callback. The
# following means that we don't really need to know/care about that in the
# display callback functions.
#  Note try/except's in RPMTransaction are for the same reason.
class _WrapNoExceptions:
    def __init__(self, parent):
        self.__parent = parent

    def __getattr__(self, name):
        """ Wraps all access to the parent functions. This is so it'll eat all
            exceptions because rpm doesn't like exceptions in the callback. """
        func = getattr(self.__parent, name)

        def newFunc(*args, **kwargs):
            try:
                func(*args, **kwargs)
            except:
                pass

        newFunc.__name__ = func.__name__
        newFunc.__doc__ = func.__doc__
        newFunc.__dict__.update(func.__dict__)
        return newFunc

class RPMTransaction:
    def __init__(self, base, test=False, display=NoOutputCallBack):
        if not callable(display):
            self.display = display
        else:
            self.display = display() # display callback
        self.display = _WrapNoExceptions(self.display)
        self.base = base # base yum object b/c we need so much
        self.test = test # are we a test?
        self.trans_running = False
        self.fd = None
        self.total_actions = 0
        self.total_installed = 0
        self.complete_actions = 0
        self.installed_pkg_names = set()
        self.total_removed = 0
        self.logger = logging.getLogger('yum.filelogging.RPMInstallCallback')
        self.filelog = False

        self._setupOutputLogging(base.conf.rpmverbosity)
        if not os.path.exists(self.base.conf.persistdir):
            os.makedirs(self.base.conf.persistdir) # make the dir, just in case

    # Error checking? -- these should probably be where else
    def _fdSetNonblock(self, fd):
        """ Set the Non-blocking flag for a filedescriptor. """
        flag = os.O_NONBLOCK
        current_flags = fcntl.fcntl(fd, fcntl.F_GETFL)
        if current_flags & flag:
            return
        fcntl.fcntl(fd, fcntl.F_SETFL, current_flags | flag)

    def _fdSetCloseOnExec(self, fd):
        """ Set the close on exec. flag for a filedescriptor. """
        flag = fcntl.FD_CLOEXEC
        current_flags = fcntl.fcntl(fd, fcntl.F_GETFD)
        if current_flags & flag:
            return
        fcntl.fcntl(fd, fcntl.F_SETFD, current_flags | flag)

    def _setupOutputLogging(self, rpmverbosity="info"):
        # UGLY... set up the transaction to record output from scriptlets
        io_r = tempfile.NamedTemporaryFile()
        self._readpipe = io_r
        self._writepipe = open(io_r.name, 'w+b')
        self.base.ts.setScriptFd(self._writepipe)
        rpmverbosity = {'critical' : 'crit',
                        'emergency' : 'emerg',
                        'error' : 'err',
                        'information' : 'info',
                        'warn' : 'warning'}.get(rpmverbosity, rpmverbosity)
        rpmverbosity = 'RPMLOG_' + rpmverbosity.upper()
        if not hasattr(rpm, rpmverbosity):
            rpmverbosity = 'RPMLOG_INFO'
        rpm.setVerbosity(getattr(rpm, rpmverbosity))
        rpm.setLogFile(self._writepipe)

    def _shutdownOutputLogging(self):
        # reset rpm bits from reording output
        rpm.setVerbosity(rpm.RPMLOG_NOTICE)
        rpm.setLogFile(sys.stderr)
        try:
            self._writepipe.close()
        except:
            pass

    def _scriptOutput(self):
        try:
            out = self._readpipe.read()
            if not out:
                return None
            return out
        except IOError:
            pass

    def _scriptout(self, data):
        msgs = self._scriptOutput()
        self.display.scriptout(data, msgs)
        self.base.history.log_scriptlet_output(data, msgs)

    def __del__(self):
        self._shutdownOutputLogging()
        
    def _dopkgtup(self, hdr):
        tmpepoch = hdr['epoch']
        if tmpepoch is None: epoch = '0'
        else: epoch = str(tmpepoch)

        return (hdr['name'], hdr['arch'], epoch, hdr['version'], hdr['release'])

    # Find out txmbr based on the callback key. On erasures we dont know
    # the exact txmbr but we always have a name, so return (name, txmbr)
    # tuples so callers have less twists to deal with.
    def _getTxmbr(self, cbkey, erase=False):
        if isinstance(cbkey, TransactionMember):
            return (cbkey.name, cbkey)
        elif isinstance(cbkey, tuple):
            pkgtup = self._dopkgtup(cbkey[0])
            txmbrs = self.base.tsInfo.getMembers(pkgtup=pkgtup)
            # if this is not one, somebody screwed up
            assert len(txmbrs) == 1
            return (txmbrs[0].name, txmbrs[0])
        elif isinstance(cbkey, basestring):
            ret = None
            #  If we don't have a tuple, it's because this is an erase txmbr and
            # rpm doesn't provide one in that case. So we can "cheat" and look
            # through all our txmbrs for the name we have, and if we find a
            # single match ... that must be it.
            if not erase:
                return (cbkey, None)
            for txmbr in self.base.tsInfo.matchNaevr(name=cbkey):
                if txmbr.output_state not in TS_REMOVE_STATES:
                    continue
                #  If we have more than one match, then we don't know which one
                # it is ... so just give up.
                if ret is not None:
                    return (cbkey, None)
                ret = txmbr

            return (cbkey, ret)
        else:
            return (None, None)

    def _fn_rm_installroot(self, filename):
        """ Remove the installroot from the filename. """
        # to handle us being inside a chroot at this point
        # we hand back the right path to those 'outside' of the chroot() calls
        # but we're using the right path inside.
        if self.base.conf.installroot == '/':
            return filename

        return filename.replace(os.path.normpath(self.base.conf.installroot),'')

    def ts_done_open(self):
        """ Open the transaction done file, must be started outside the
            chroot. """

        if self.test: return False

        if hasattr(self, '_ts_done'):
            return True

        self.ts_done_fn = '%s/transaction-done.%s' % (self.base.conf.persistdir,
                                                      self._ts_time)
        ts_done_fn = self._fn_rm_installroot(self.ts_done_fn)

        try:
            self._ts_done = open(ts_done_fn, 'w')
        except (IOError, OSError), e:
            self.display.errorlog('could not open ts_done file: %s' % e)
            self._ts_done = None
            return False
        self._fdSetCloseOnExec(self._ts_done.fileno())
        return True

    def ts_done_write(self, msg):
        """ Write some data to the transaction done file. """
        if self._ts_done is None:
            return

        try:
            self._ts_done.write(msg)
            self._ts_done.flush()
        except (IOError, OSError), e:
            #  Having incomplete transactions is probably worse than having
            # nothing.
            self.display.errorlog('could not write to ts_done file: %s' % e)
            self._ts_done = None
            misc.unlink_f(self.ts_done_fn)

    def ts_done(self, package, action):
        """writes out the portions of the transaction which have completed"""
        
        if not self.ts_done_open(): return
    
        # walk back through self._te_tuples
        # make sure the package and the action make some kind of sense
        # write it out and pop(0) from the list
        
        # make sure we have a list to work from
        if len(self._te_tuples) == 0:
            # if we don't then this is pretrans or postrans or a trigger
            # either way we have to respond correctly so just return and don't
            # emit anything
            return

        (t,e,n,v,r,a) = self._te_tuples[0] # what we should be on

        # make sure we're in the right action state
        msg = 'ts_done state is %s %s should be %s %s' % (package, action, t, n)
        if action in TS_REMOVE_STATES:
            if t != 'erase':
                self.display.filelog(package, msg)
        if action in TS_INSTALL_STATES:
            if t != 'install':
                self.display.filelog(package, msg)
                
        # check the pkg name out to make sure it matches
        if type(package) in types.StringTypes:
            name = package
        else:
            name = package.name
        
        if n != name:
            msg = 'ts_done name in te is %s should be %s' % (n, package)
            self.display.filelog(package, msg)

        # hope springs eternal that this isn't wrong
        msg = '%s %s:%s-%s-%s.%s\n' % (t,e,n,v,r,a)

        self.ts_done_write(msg)
        self._te_tuples.pop(0)
    
    def ts_all(self):
        """write out what our transaction will do"""
        
        # save the transaction elements into a list so we can run across them
        if not hasattr(self, '_te_tuples'):
            self._te_tuples = []

        for te in self.base.ts:
            n = te.N()
            a = te.A()
            v = te.V()
            r = te.R()
            e = te.E()
            if e is None:
                e = '0'
            if te.Type() == 1:
                t = 'install'
            elif te.Type() == 2:
                t = 'erase'
            else:
                t = te.Type()
            
            # save this in a list            
            self._te_tuples.append((t,e,n,v,r,a))

        # write to a file
        self._ts_time = time.strftime('%Y-%m-%d.%H:%M.%S')
        tsfn = '%s/transaction-all.%s' % (self.base.conf.persistdir, self._ts_time)
        self.ts_all_fn = tsfn
        tsfn = self._fn_rm_installroot(tsfn)

        try:
            if not os.path.exists(os.path.dirname(tsfn)):
                os.makedirs(os.path.dirname(tsfn)) # make the dir,
            fo = open(tsfn, 'w')
        except (IOError, OSError), e:
            self.display.errorlog('could not open ts_all file: %s' % e)
            self._ts_done = None
            return

        try:
            for (t,e,n,v,r,a) in self._te_tuples:
                msg = "%s %s:%s-%s-%s.%s\n" % (t,e,n,v,r,a)
                fo.write(msg)
            fo.flush()
            fo.close()
        except (IOError, OSError), e:
            #  Having incomplete transactions is probably worse than having
            # nothing.
            self.display.errorlog('could not write to ts_all file: %s' % e)
            misc.unlink_f(tsfn)
            self._ts_done = None

    def callback( self, what, bytes, total, h, user ):
        if what == rpm.RPMCALLBACK_TRANS_START:
            self._transStart( bytes, total, h )
        elif what == rpm.RPMCALLBACK_TRANS_PROGRESS:
            self._transProgress( bytes, total, h )
        elif what == rpm.RPMCALLBACK_TRANS_STOP:
            self._transStop( bytes, total, h )
        elif what == rpm.RPMCALLBACK_INST_OPEN_FILE:
            return self._instOpenFile( bytes, total, h )
        elif what == rpm.RPMCALLBACK_INST_CLOSE_FILE:
            self._instCloseFile(  bytes, total, h )
        elif what == rpm.RPMCALLBACK_INST_PROGRESS:
            self._instProgress( bytes, total, h )
        elif what == rpm.RPMCALLBACK_UNINST_START:
            self._unInstStart( bytes, total, h )
        elif what == rpm.RPMCALLBACK_UNINST_PROGRESS:
            self._unInstProgress( bytes, total, h )
        elif what == rpm.RPMCALLBACK_UNINST_STOP:
            self._unInstStop( bytes, total, h )
        elif what == rpm.RPMCALLBACK_REPACKAGE_START:
            self._rePackageStart( bytes, total, h )
        elif what == rpm.RPMCALLBACK_REPACKAGE_STOP:
            self._rePackageStop( bytes, total, h )
        elif what == rpm.RPMCALLBACK_REPACKAGE_PROGRESS:
            self._rePackageProgress( bytes, total, h )
        elif what == rpm.RPMCALLBACK_CPIO_ERROR:
            self._cpioError(bytes, total, h)
        elif what == rpm.RPMCALLBACK_UNPACK_ERROR:
            self._unpackError(bytes, total, h)
        # SCRIPT_ERROR is only in rpm >= 4.6.0
        elif hasattr(rpm, "RPMCALLBACK_SCRIPT_ERROR") and what == rpm.RPMCALLBACK_SCRIPT_ERROR:
            self._scriptError(bytes, total, h)
    
    
    def _transStart(self, bytes, total, h):
        self.total_actions = total
        if self.test: return
        self.trans_running = True
        self.ts_all() # write out what transaction will do
        self.ts_done_open()

    def _transProgress(self, bytes, total, h):
        pass
        
    def _transStop(self, bytes, total, h):
        pass

    def _instOpenFile(self, bytes, total, h):
        self.lastmsg = None
        name, txmbr = self._getTxmbr(h)
        if txmbr is not None:
            rpmloc = txmbr.po.localPkg()
            try:
                self.fd = file(rpmloc)
            except IOError, e:
                self.display.errorlog("Error: Cannot open file %s: %s" % (rpmloc, e))
            else:
                if self.trans_running:
                    self.total_installed += 1
                    self.complete_actions += 1
                    self.installed_pkg_names.add(name)
                return self.fd.fileno()
        else:
            self.display.errorlog("Error: No Header to INST_OPEN_FILE")
            
    def _instCloseFile(self, bytes, total, h):
        name, txmbr = self._getTxmbr(h)
        if txmbr is not None:
            self.fd.close()
            self.fd = None
            if self.test: return
            if self.trans_running:
                self.display.filelog(txmbr.po, txmbr.output_state)
                self._scriptout(txmbr.po)
                pid   = self.base.history.pkg2pid(txmbr.po)
                state = self.base.history.txmbr2state(txmbr)
                self.base.history.trans_data_pid_end(pid, state)
                self.ts_done(txmbr.po, txmbr.output_state)
    
    def _instProgress(self, bytes, total, h):
        name, txmbr = self._getTxmbr(h)
        if name is not None:
            # If we only have a name, we're repackaging.
            # Why the RPMCALLBACK_REPACKAGE_PROGRESS flag isn't set, I have no idea
            if txmbr is None:
                self.display.event(name, 'repackaging',  bytes, total,
                                self.complete_actions, self.total_actions)
            else:
                action = txmbr.output_state
                self.display.event(txmbr.po, action, bytes, total,
                            self.complete_actions, self.total_actions)

    def _unInstStart(self, bytes, total, h):
        pass
        
    def _unInstProgress(self, bytes, total, h):
        pass
    
    def _unInstStop(self, bytes, total, h):
        name, txmbr = self._getTxmbr(h, erase=True)
        self.total_removed += 1
        self.complete_actions += 1
        if name not in self.installed_pkg_names:
            if txmbr is not None:
                self.display.filelog(txmbr.po, TS_ERASE)
            else:
                self.display.filelog(name, TS_ERASE)
            action = TS_ERASE
        else:
            action = TS_UPDATED                    

        # FIXME: Do we want to pass txmbr.po here too?
        self.display.event(name, action, 100, 100, self.complete_actions,
                            self.total_actions)
        
        if self.test: return # and we're done

        if txmbr is not None:
            self._scriptout(txmbr.po)

            #  Note that we are currently inside the chroot, which makes
            # sqlite panic when it tries to open it's journal file.
            # So let's have some "fun" and workaround that:
            _do_chroot = False
            if _do_chroot and self.base.conf.installroot != '/':
                os.chroot(".")
            pid   = self.base.history.pkg2pid(txmbr.po)
            state = self.base.history.txmbr2state(txmbr)
            self.base.history.trans_data_pid_end(pid, state)
            if _do_chroot and self.base.conf.installroot != '/':
                os.chroot(self.base.conf.installroot)

            self.ts_done(txmbr.po, txmbr.output_state)
        else:
            self._scriptout(name)

            self.ts_done(name, action)
        
        
    def _rePackageStart(self, bytes, total, h):
        pass
        
    def _rePackageStop(self, bytes, total, h):
        pass
        
    def _rePackageProgress(self, bytes, total, h):
        pass
        
    def _cpioError(self, bytes, total, h):
        name, txmbr = self._getTxmbr(h)
        # In the case of a remove, we only have a name, not a txmbr
        if txmbr is not None:
            msg = "Error in cpio payload of rpm package %s" % txmbr.po
            txmbr.output_state = TS_FAILED
            self.display.errorlog(msg)
            # FIXME - what else should we do here? raise a failure and abort?
    
    def _unpackError(self, bytes, total, h):
        name, txmbr = self._getTxmbr(h)
        # In the case of a remove, we only have a name, not a txmbr
        if txmbr is not None:
            txmbr.output_state = TS_FAILED
            msg = "Error unpacking rpm package %s" % txmbr.po
            self.display.errorlog(msg)
            # FIXME - should we raise? I need a test case pkg to see what the
            # right behavior should be
                
    def _scriptError(self, bytes, total, h):
        # "bytes" carries the failed scriptlet tag,
        # "total" carries fatal/non-fatal status
        scriptlet_name = rpm.tagnames.get(bytes, "<unknown>")

        name, txmbr = self._getTxmbr(h, erase=True)
        if txmbr is None:
            package_name = name
        else:
            package_name = txmbr.po
            
        if total:
            msg = ("Error in %s scriptlet in rpm package %s" % 
                    (scriptlet_name, package_name))
            # In the case of a remove, we only have a name, not a txmbr
            if txmbr is not None:        
                txmbr.output_state = TS_FAILED
        else:
            msg = ("Non-fatal %s scriptlet failure in rpm package %s" % 
                   (scriptlet_name, package_name))
        self.display.errorlog(msg)
        # FIXME - what else should we do here? raise a failure and abort?
    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python2.7/dist-packages/yum/rpmtrans.pyc                                                    0100644 0000000 0000000 00000052030 13077704344 020321  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   s¸   d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Td  d l m	 Z	 d  d l
 m Z d  d l Z d  d l Z d d d Ñ  É  YZ d d d Ñ  É  YZ d	 e f d
 Ñ  É  YZ d d d Ñ  É  YZ d d d Ñ  É  YZ d S(   iˇˇˇˇN(   t   *(   t   _(   t   TransactionMembert   NoOutputCallBackc           B   s5   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   d  S(   N(    (   t   self(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   __init__!   s    c         C   s   d S(   sÇ  
        @param package: A yum package object or simple string of a package name
        @param action: A yum.constant transaction set state or in the obscure 
                       rpm repackage case it could be the string 'repackaging'
        @param te_current: current number of bytes processed in the transaction
                           element being processed
        @param te_total: total number of bytes in the transaction element being
                         processed
        @param ts_current: number of processes completed in whole transaction
        @param ts_total: total number of processes in the transaction.
        N(    (   R   t   packaget   actiont
   te_currentt   te_totalt
   ts_currentt   ts_total(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   event$   s    c         C   s   d S(   sP   package is the package.  msgs is the messages that were
        output (if any).N(    (   R   R   t   msgs(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt	   scriptout4   s    c         C   s   d S(   s   takes a simple error msg stringN(    (   R   t   msg(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   errorlog9   s    c         C   s   d S(   sv   package is the same as in event() - a package object or simple string
           action is also the same as in event()N(    (   R   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   filelog>   s    (   t   __name__t
   __module__R   R   R   R   R   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR       s
   				t   RPMBaseCallbackc           B   s;   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s@   
    Base class for a RPMTransaction display callback class
    c         C   s¡   i t  d É t 6t  d É t 6t  d É t 6t  d É t 6t  d É t 6t  d É t 6t  d É t 6t  d É d 6|  _ i d t 6d	 t 6d
 t 6d
 t 6d t 6d
 t 6d t 6|  _	 t
 j d É |  _ d  S(   Nt   Updatingt   Erasingt
   Installingt	   Obsoletedt   Cleanupt   Repackagingt   repackagingt   Updatedt   Erasedt	   Installeds"   yum.filelogging.RPMInstallCallback(   R   t	   TS_UPDATEt   TS_ERASEt
   TS_INSTALLt   TS_TRUEINSTALLt   TS_OBSOLETEDt   TS_OBSOLETINGt
   TS_UPDATEDR   t
   fileactiont   loggingt	   getLoggert   logger(   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   H   s     
c         C   s   t  É  Ç d S(   sÇ  
        @param package: A yum package object or simple string of a package name
        @param action: A yum.constant transaction set state or in the obscure 
                       rpm repackage case it could be the string 'repackaging'
        @param te_current: Current number of bytes processed in the transaction
                           element being processed
        @param te_total: Total number of bytes in the transaction element being
                         processed
        @param ts_current: number of processes completed in whole transaction
        @param ts_total: total number of processes in the transaction.
        N(   t   NotImplementedError(   R   R   R   R   R	   R
   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   [   s    c         C   s   d S(   sP   package is the package.  msgs is the messages that were
        output (if any).N(    (   R   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   i   s    c         C   s   t  j | IJd  S(   N(   t   syst   stderr(   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   n   s    c         C   sM   | |  j  k r) d |  j  | | f } n d | | f } |  j j | É d  S(   Ns   %s: %s(   R&   R)   t   info(   R   R   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   r   s    (   R   R   t   __doc__R   R   R   R   R   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   D   s   				t   SimpleCliCallBackc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s#   t  j |  É d  |  _ d  |  _ d  S(   N(   R   R   t   Nonet   lastmsgt   lastpackage(   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   }   s    	c         C   sP   d |  j  | | | | | | f } | |  j k r: | GHn  | |  _ | |  _ d  S(   Ns   %s: %s %s/%s [%s/%s](   R   R1   R2   (   R   R   R   R   R	   R
   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   Ç   s    	c         C   s   | r | Gn  d  S(   N(    (   R   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   ã   s    (   R   R   R   R   R   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR/   |   s   			t   _WrapNoExceptionsc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s   | |  _  d  S(   N(   t   _WrapNoExceptions__parent(   R   t   parent(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   ï   s    c            sP   t  |  j | É â  á  f d Ü  } à  j | _ à  j | _ | j j à  j É | S(   sê    Wraps all access to the parent functions. This is so it'll eat all
            exceptions because rpm doesn't like exceptions in the callback. c             s   y à  |  | é  Wn n Xd  S(   N(    (   t   argst   kwargs(   t   func(    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   newFuncù   s    (   t   getattrR4   R   R.   t   __dict__t   update(   R   t   nameR9   (    (   R8   s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   __getattr__ò   s    (   R   R   R   R>   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR3   î   s   	t   RPMTransactionc           B   s+  e  Z e e d  Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z e d
 Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" RS(    c         C   s   t  | É s | |  _ n | É  |  _ t |  j É |  _ | |  _ | |  _ t |  _ d  |  _ d |  _	 d |  _
 d |  _ t É  |  _ d |  _ t j d É |  _ t |  _ |  j | j j É t j j |  j j j É sÏ t j |  j j j É n  d  S(   Ni    s"   yum.filelogging.RPMInstallCallback(   t   callablet   displayR3   t   baset   testt   Falset   trans_runningR0   t   fdt   total_actionst   total_installedt   complete_actionst   sett   installed_pkg_namest   total_removedR'   R(   R)   R   t   _setupOutputLoggingt   conft   rpmverbosityt   ost   patht   existst
   persistdirt   makedirs(   R   RB   RC   RA   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR   ©   s$    									c         C   sJ   t  j } t j | t j É } | | @r, d St j | t j | | BÉ d S(   s1    Set the Non-blocking flag for a filedescriptor. N(   RP   t
   O_NONBLOCKt   fcntlt   F_GETFLt   F_SETFL(   R   RF   t   flagt   current_flags(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   _fdSetNonblock¿   s
    	
c         C   sJ   t  j } t  j  | t  j É } | | @r, d St  j  | t  j | | BÉ d S(   s3    Set the close on exec. flag for a filedescriptor. N(   RV   t
   FD_CLOEXECt   F_GETFDt   F_SETFD(   R   RF   RY   RZ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   _fdSetCloseOnExec»   s
    	
R-   c         C   s«   t  j É  } | |  _ t | j d É |  _ |  j j j |  j É i d d 6d d 6d d 6d d	 6d
 d 6j	 | | É } d | j
 É  } t t | É sù d } n  t j t t | É É t j |  j É d  S(   Ns   w+bt   critt   criticalt   emergt	   emergencyt   errt   errorR-   t   informationt   warningt   warnt   RPMLOG_t   RPMLOG_INFO(   t   tempfilet   NamedTemporaryFilet	   _readpipet   openR=   t
   _writepipeRB   t   tst   setScriptFdt   gett   uppert   hasattrt   rpmt   setVerbosityR:   t
   setLogFile(   R   RO   t   io_r(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyRM   –   s    	
	c         C   s?   t  j t  j É t  j t j É y |  j j É  Wn n Xd  S(   N(   Ru   Rv   t   RPMLOG_NOTICERw   R+   R,   Ro   t   close(   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   _shutdownOutputLogging·   s    c         C   s9   y! |  j  j É  } | s d  S| SWn t k
 r4 n Xd  S(   N(   Rm   t   readR0   t   IOError(   R   t   out(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   _scriptOutputÍ   s    c         C   s9   |  j  É  } |  j j | | É |  j j j | | É d  S(   N(   R   RA   R   RB   t   historyt   log_scriptlet_output(   R   t   dataR   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt
   _scriptoutÛ   s    c         C   s   |  j  É  d  S(   N(   R{   (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   __del__¯   s    c         C   sN   | d } | d  k r d } n t | É } | d | d | | d | d f S(   Nt   epocht   0R=   t   archt   versiont   release(   R0   t   str(   R   t   hdrt   tmpepochRÖ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt	   _dopkgtup˚   s
    
 	c         C   s  t  | t É r | j | f St  | t É rÉ |  j | d É } |  j j j d | É } t | É d k sn t	 Ç | d j | d f St  | t
 É rd  } | s® | d  f SxQ |  j j j d | É D]7 } | j t k r‹ q¡ n  | d  k	 rÚ | d  f S| } q¡ W| | f Sd Sd  S(   Ni    t   pkgtupi   R=   (   NN(   t
   isinstanceR   R=   t   tupleRç   RB   t   tsInfot
   getMemberst   lent   AssertionErrort
   basestringR0   t
   matchNaevrt   output_statet   TS_REMOVE_STATES(   R   t   cbkeyt   eraseRé   t   txmbrst   rett   txmbr(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt	   _getTxmbr  s&    



c         C   s>   |  j  j j d k r | S| j t j j |  j  j j É d É S(   s+    Remove the installroot from the filename. t   /t    (   RB   RN   t   installroott   replaceRP   RQ   t   normpath(   R   t   filename(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   _fn_rm_installroot#  s    c         C   sª   |  j  r t St |  d É r  t Sd |  j j j |  j f |  _ |  j	 |  j É } y t
 | d É |  _ Wn7 t t f k
 r† } |  j j d | É d |  _ t SX|  j |  j j É  É t S(   sQ    Open the transaction done file, must be started outside the
            chroot. t   _ts_dones   %s/transaction-done.%st   ws   could not open ts_done file: %sN(   RC   RD   Rt   t   TrueRB   RN   RS   t   _ts_timet
   ts_done_fnR•   Rn   R¶   R}   t   OSErrorRA   R   R0   R_   t   fileno(   R   R™   t   e(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   ts_done_open-  s    	 	c         C   sÅ   |  j  d k r d Sy! |  j  j | É |  j  j É  WnF t t f k
 r| } |  j j d | É d |  _  t j	 |  j
 É n Xd S(   s/    Write some data to the transaction done file. Ns#   could not write to ts_done file: %s(   R¶   R0   t   writet   flushR}   R´   RA   R   t   misct   unlink_fR™   (   R   R   R≠   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   ts_done_writeC  s    	c         C   sV  |  j  É  s d St |  j É d k r) d S|  j d \ } } } } } } d | | | | f }	 | t k rè | d k rè |  j j | |	 É qè n  | t k r¿ | d k r¿ |  j j | |	 É q¿ n  t | É t j	 k rﬁ | }
 n	 | j
 }
 | |
 k rd | | f }	 |  j j | |	 É n  d | | | | | | f }	 |  j |	 É |  j j d É d S(   s?   writes out the portions of the transaction which have completedNi    s&   ts_done state is %s %s should be %s %sRö   t   installs%   ts_done name in te is %s should be %ss   %s %s:%s-%s-%s.%s
(   RÆ   Rì   t
   _te_tuplesRò   RA   R   t   TS_INSTALL_STATESt   typet   typest   StringTypesR=   R≥   t   pop(   R   R   R   t   tR≠   t   nt   vt   rt   aR   R=   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   ts_doneR  s*     		c         C   se  t  |  d É s g  |  _ n  x… |  j j D]ª } | j É  } | j É  } | j É  } | j É  } | j É  } | d k r d } n  | j
 É  d k rö d } n' | j
 É  d k rµ d } n | j
 É  } |  j j | | | | | | f É q( Wt j d É |  _ d |  j j j |  j f } | |  _ |  j | É } yM t j j t j j | É É sjt j t j j | É É n  t | d	 É }	 Wn7 t t f k
 r≥} |  j j d
 | É d |  _ d SXyg xL |  j D]A \ } } } } } } d | | | | | | f }
 |	 j |
 É q¡W|	 j É  |	 j  É  WnC t t f k
 r`} |  j j d | É t! j" | É d |  _ n Xd S(   s&   write out what our transaction will doRµ   RÜ   i   R¥   i   Rö   s   %Y-%m-%d.%H:%M.%Ss   %s/transaction-all.%sRß   s   could not open ts_all file: %sNs   %s %s:%s-%s-%s.%s
s"   could not write to ts_all file: %s(#   Rt   Rµ   RB   Rp   t   Nt   At   Vt   Rt   ER0   t   Typet   appendt   timet   strftimeR©   RN   RS   t	   ts_all_fnR•   RP   RQ   RR   t   dirnameRT   Rn   R}   R´   RA   R   R¶   RØ   R∞   Rz   R±   R≤   (   R   t   teRº   Rø   RΩ   Ræ   R≠   Rª   t   tsfnt   foR   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   ts_all}  sL    			&		"
c         C   s;  | t  j k r% |  j | | | É n| t  j k rJ |  j | | | É nÌ| t  j k ro |  j | | | É n»| t  j k rë |  j | | | É S| t  j	 k r∂ |  j
 | | | É nÅ| t  j k r€ |  j | | | É n\| t  j k r |  j | | | É n7| t  j k r%|  j | | | É n| t  j k rJ|  j | | | É nÌ | t  j k ro|  j | | | É n» | t  j k rî|  j | | | É n£ | t  j k rπ|  j | | | É n~ | t  j k rﬁ|  j | | | É nY | t  j k r|  j | | | É n4 t t  d É r7| t  j k r7|  j | | | É n  d  S(   Nt   RPMCALLBACK_SCRIPT_ERROR(    Ru   t   RPMCALLBACK_TRANS_STARTt   _transStartt   RPMCALLBACK_TRANS_PROGRESSt   _transProgresst   RPMCALLBACK_TRANS_STOPt
   _transStopt   RPMCALLBACK_INST_OPEN_FILEt   _instOpenFilet   RPMCALLBACK_INST_CLOSE_FILEt   _instCloseFilet   RPMCALLBACK_INST_PROGRESSt   _instProgresst   RPMCALLBACK_UNINST_STARTt   _unInstStartt   RPMCALLBACK_UNINST_PROGRESSt   _unInstProgresst   RPMCALLBACK_UNINST_STOPt   _unInstStopt   RPMCALLBACK_REPACKAGE_STARTt   _rePackageStartt   RPMCALLBACK_REPACKAGE_STOPt   _rePackageStopt   RPMCALLBACK_REPACKAGE_PROGRESSt   _rePackageProgresst   RPMCALLBACK_CPIO_ERRORt
   _cpioErrort   RPMCALLBACK_UNPACK_ERRORt   _unpackErrorRt   R–   t   _scriptError(   R   t   whatt   bytest   totalt   ht   user(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   callback≤  s<    c         C   s7   | |  _  |  j r d  St |  _ |  j É  |  j É  d  S(   N(   RG   RC   R®   RE   Rœ   RÆ   (   R   RÔ   R   RÒ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR“   ‘  s    		 	
c         C   s   d  S(   N(    (   R   RÔ   R   RÒ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR‘   €  s    c         C   s   d  S(   N(    (   R   RÔ   R   RÒ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR÷   ﬁ  s    c         C   s⁄   d  |  _ |  j | É \ } } | d  k	 r∆ | j j É  } y t | É |  _ Wn- t k
 r{ } |  j j	 d | | f É q÷ X|  j
 r∂ |  j d 7_ |  j d 7_ |  j j | É n  |  j j É  Sn |  j j	 d É d  S(   Ns   Error: Cannot open file %s: %si   s"   Error: No Header to INST_OPEN_FILE(   R0   R1   Rû   t   pot   localPkgt   fileRF   R}   RA   R   RE   RH   RI   RK   t   addR¨   (   R   RÔ   R   RÒ   R=   Rù   t   rpmlocR≠   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyRÿ   ·  s    		c         C   sŸ   |  j  | É \ } } | d  k	 r’ |  j j É  d  |  _ |  j rD d  S|  j r’ |  j j | j | j	 É |  j
 | j É |  j j j | j É } |  j j j | É } |  j j j | | É |  j | j | j	 É q’ n  d  S(   N(   Rû   R0   RF   Rz   RC   RE   RA   R   RÙ   Ró   RÉ   RB   RÄ   t   pkg2pidt   txmbr2statet   trans_data_pid_endR¿   (   R   RÔ   R   RÒ   R=   Rù   t   pidt   state(    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR⁄   Û  s    		 	c         C   sç   |  j  | É \ } } | d  k	 râ | d  k rU |  j j | d | | |  j |  j É qâ | j } |  j j | j | | | |  j |  j É n  d  S(   NR   (   Rû   R0   RA   R   RI   RG   Ró   RÙ   (   R   RÔ   R   RÒ   R=   Rù   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR‹     s    	c         C   s   d  S(   N(    (   R   RÔ   R   RÒ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyRﬁ     s    c         C   s   d  S(   N(    (   R   RÔ   R   RÒ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR‡     s    c   
      C   sø  |  j  | d t É\ } } |  j d 7_ |  j d 7_ | |  j k râ | d  k	 rm |  j j | j t	 É n |  j j | t	 É t	 } n t
 } |  j j | | d d |  j |  j É |  j r¡ d  S| d  k	 rû|  j | j É t } | r|  j j j d k rt j d É n  |  j j j | j É } |  j j j | É }	 |  j j j | |	 É | rÖ|  j j j d k rÖt j |  j j j É n  |  j | j | j É n |  j | É |  j | | É d  S(   NRö   i   id   Rü   t   .(   Rû   R®   RL   RI   RK   R0   RA   R   RÙ   R    R%   R   RG   RC   RÉ   RD   RB   RN   R°   RP   t   chrootRÄ   R˘   R˙   R˚   R¿   Ró   (
   R   RÔ   R   RÒ   R=   Rù   R   t
   _do_chrootR¸   R˝   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR‚     s4    	
	 c         C   s   d  S(   N(    (   R   RÔ   R   RÒ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR‰   =  s    c         C   s   d  S(   N(    (   R   RÔ   R   RÒ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyRÊ   @  s    c         C   s   d  S(   N(    (   R   RÔ   R   RÒ   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyRË   C  s    c         C   sN   |  j  | É \ } } | d  k	 rJ d | j } t | _ |  j j | É n  d  S(   Ns'   Error in cpio payload of rpm package %s(   Rû   R0   RÙ   t	   TS_FAILEDRó   RA   R   (   R   RÔ   R   RÒ   R=   Rù   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyRÍ   F  s
    	c         C   sN   |  j  | É \ } } | d  k	 rJ t | _ d | j } |  j j | É n  d  S(   Ns   Error unpacking rpm package %s(   Rû   R0   R  Ró   RÙ   RA   R   (   R   RÔ   R   RÒ   R=   Rù   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyRÏ   O  s
    	c   	      C   s£   t  j j | d É } |  j | d t É\ } } | d  k rE | } n	 | j } | r d | | f } | d  k	 rè t | _ qè n d | | f } |  j	 j
 | É d  S(   Ns	   <unknown>Rö   s'   Error in %s scriptlet in rpm package %ss0   Non-fatal %s scriptlet failure in rpm package %s(   Ru   t   tagnamesRr   Rû   R®   R0   RÙ   R  Ró   RA   R   (	   R   RÔ   R   RÒ   t   scriptlet_nameR=   Rù   t   package_nameR   (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyRÌ   Y  s    		(#   R   R   RD   R   R   R[   R_   RM   R{   R   RÉ   RÑ   Rç   Rû   R•   RÆ   R≥   R¿   Rœ   RÛ   R“   R‘   R÷   Rÿ   R⁄   R‹   Rﬁ   R‡   R‚   R‰   RÊ   RË   RÍ   RÏ   RÌ   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyR?   ®   s>   									
	
			+	5	"									)						
(    (    (    (    (   Ru   RP   RV   R»   R'   R∏   R+   t   yum.constantst   yumR   t   yum.transactioninfoR   R±   Rk   R   R   R/   R3   R?   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/rpmtrans.pyt   <module>   s    
$8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/dist-packages/yum/sqlitesack.py                                                   0100644 0000000 0000000 00000211110 12451005146 020434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University 

#
# Implementation of the YumPackageSack class that uses an sqlite backend
#

import os
import os.path
import fnmatch

import yumRepo
from packages import PackageObject, RpmBase, YumAvailablePackage, parsePackages
import Errors
import misc

from sqlutils import executeSQL, sql_esc, sql_esc_glob
import rpmUtils.miscutils
import sqlutils
import constants
import operator
from yum.misc import seq_max_split
from yum.i18n import to_utf8, to_unicode
import sys
import re
import warnings

def catchSqliteException(func):
    """This decorator converts sqlite exceptions into RepoError"""
    def newFunc(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except sqlutils.sqlite.Error, e:
            # 2.4.x requires this, but 2.6.x complains about even hasattr()
            # of e.message ... *sigh*
            if sys.hexversion < 0x02050000:
                if hasattr(e,'message'):
                    raise Errors.RepoError, str(e.message)
                else:
                    raise Errors.RepoError, str(e)
            raise Errors.RepoError, str(e)

    newFunc.__name__ = func.__name__
    newFunc.__doc__ = func.__doc__
    newFunc.__dict__.update(func.__dict__)
    return newFunc

def _share_data(value):
    return misc.share_data(value)

# FIXME: parsePackages()
def _parse_pkg_n(match, regexp_match, n):
    if match == n:
        return True
    if not regexp_match:
        return False

    if (match and n and match[0] not in ('?', '*') and match[0] != n[0]):
        return False
    if regexp_match(n):
        return True
    return False

def _parse_pkg(match, regexp_match, data, e,v,r,a):

    n = data['n']
    assert e, 'Nothing in epoch'
    # Worthless speed hacks?
    if match == n:
        return True
    if (match and n and match[0] not in ('?', '*') and
        match[0] != n[0] and match[0] != e[0]):
        return False

    if 'nameArch' not in data:
        data['nameArch'] = '%s.%s' % (n, a)
        data['nameVerRelArch'] = '%s-%s-%s.%s' % (n, v, r, a)
        data['nameVer'] = '%s-%s' % (n, v)
        data['nameVerRel'] = '%s-%s-%s' % (n, v, r)
        data['envra'] = '%s:%s-%s-%s.%s' % (e, n, v, r, a)
        data['nevra'] = '%s-%s:%s-%s.%s' % (n, e, v, r, a)
    data = set([n, data['nameArch'], data['nameVerRelArch'], data['nameVer'],
                data['nameVerRel'], data['envra'], data['nevra']])

    if match in data:
        return True
    if not regexp_match:
        return False

    for item in data:
        if regexp_match(item):
            return True
    return False

def _excluder_match(excluder, match, regexp_match, data, e,v,r,a):
    if False: pass
    elif excluder in ('eq', 'match'):
        if _parse_pkg(match, regexp_match, data, e,v,r,a):
            return True

    elif excluder in ('name.eq', 'name.match'):
        if _parse_pkg_n(match, regexp_match, data['n']):
            return True

    elif excluder in ('arch.eq', 'arch.match'):
        if _parse_pkg_n(match, regexp_match, a):
            return True

    elif excluder == 'nevr.eq':
        if 'nevr' not in data:
            data['nevr'] = '%s-%s:%s-%s' % (data['n'], e, v, r)
        if match == data['nevr']:
            return True

    elif excluder in ('nevra.eq', 'nevra.match'):
        if 'nevra' not in data:
            data['nevra'] = '%s-%s:%s-%s.%s' % (data['n'], e, v, r, a)
        if _parse_pkg_n(match, regexp_match, data['nevra']):
            return True

    elif excluder == 'name.in':
        if data['n'] in match:
            return True

    elif excluder == 'nevr.in':
        if 'nevr' not in data:
            data['nevr'] = '%s-%s:%s-%s' % (data['n'], e, v, r)
        if data['nevr'] in match:
            return True

    elif excluder == 'nevra.in':
        if 'nevra' not in data:
            data['nevra'] = '%s-%s:%s-%s.%s' % (data['n'], e, v, r, a)
        if data['nevra'] in match:
            return True

    elif excluder == 'pkgtup.eq':
        if match == data['pkgtup']:
            return True

    elif excluder == 'pkgtup.in':
        if data['pkgtup'] in match:
            return True

    elif excluder == 'marked':
        if data['marked']:
            return True

    elif excluder == 'washed':
        if not data['marked']:
            return True

    elif excluder == '*':
        return True

    else:
        assert False, 'Bad excluder: ' + excluder
        return None

    return False


class YumAvailablePackageSqlite(YumAvailablePackage, PackageObject, RpmBase):
    def __init__(self, repo, db_obj):
        self.prco = { 'obsoletes': (),
                      'conflicts': (),
                      'requires': (),
                      'provides': () }
        self.sack = repo.sack
        self.repoid = repo.id
        self.repo = repo
        self.state = None
        self._loadedfiles = False
        self._files = None
        self._read_db_obj(db_obj)
        # for stupid metadata created without epochs listed in the version tag
        # die die
        if self.epoch is None:
            self.epoch = '0'
        self.id = self.pkgId
        self.ver = self.version 
        self.rel = self.release 
        self.pkgtup = (self.name, self.arch, self.epoch, self.version, self.release)

        self._changelog = None
        self._hash = None
        

    files = property(fget=lambda self: self._loadFiles())

    def _read_db_obj(self, db_obj, item=None):
        """read the db obj. If asked for a specific item, return it.
           otherwise populate out into the object what exists"""
        if item:
            try:
                return db_obj[item]
            except (IndexError, KeyError):
                return None

        for item in ['name', 'arch', 'epoch', 'version', 'release', 'pkgKey']:
            try:
                setattr(self, item, _share_data(db_obj[item]))
            except (IndexError, KeyError):
                pass

        try:
            self.pkgId = db_obj['pkgId']

            checksum_type = _share_data(db_obj['checksum_type'])
            check_sum = (checksum_type, db_obj['pkgId'], True)
            self._checksums = [ check_sum ]
        except (IndexError, KeyError):
            pass

    @catchSqliteException
    def _sql_MD(self, MD, sql, *args):
        """ Exec SQL against an MD of the repo, return a cursor. """

        cache = getattr(self.sack, MD + 'db')[self.repo]
        cur = cache.cursor()
        executeSQL(cur, sql, *args)
        return cur

    def __getattr__(self, varname):
        db2simplemap = { 'packagesize' : 'size_package',
                         'archivesize' : 'size_archive',
                         'installedsize' : 'size_installed',
                         'buildtime' : 'time_build',
                         'hdrstart' : 'rpm_header_start',
                         'hdrend' : 'rpm_header_end',
                         'basepath' : 'location_base',
                         'relativepath': 'location_href',
                         'filetime' : 'time_file',
                         'packager' : 'rpm_packager',
                         'group' : 'rpm_group',
                         'buildhost' : 'rpm_buildhost',
                         'sourcerpm' : 'rpm_sourcerpm',
                         'vendor' : 'rpm_vendor',
                         'license' : 'rpm_license',
                         'checksum_value' : 'pkgId',
                        }

        # If these existed, then we wouldn't get here ... and nothing in the DB
        # starts and ends with __'s. So these are missing.
        if varname.startswith('__') and varname.endswith('__'):
            raise AttributeError, varname
        
        dbname = db2simplemap.get(varname, varname)
        try:
            r = self._sql_MD('primary',
                         "SELECT %s FROM packages WHERE pkgId = ?" % dbname,
                         (self.pkgId,)).fetchone()
        except Errors.RepoError, e:
            if str(e).startswith('no such column'):
                #FIXME - after API break make this an AttributeError Raise
                raise KeyError, str(e)
            raise                         
        value = r[0]
        if varname == 'epoch' and value is None:
            value = '0'
        if varname in ('summary', 'description') and value is None:
            # Maybe others here? ... location_base is a bad NONO though.
            value = '' # Description for picasa, probably among others *sigh*
        if varname in {'vendor' : 1, 'packager' : 1, 'buildhost' : 1,
                       'license' : 1, 'group' : 1,
                       'summary' : 1, 'description' : 1, 'sourcerpm' : 1,
                       'url' : 1}:
            value  = _share_data(value)
        setattr(self, varname, value)
            
        return value
        
    def _loadFiles(self):
        if self._loadedfiles:
            return self._files

        result = {}
        
        #FIXME - this should be try, excepting
        self.sack.populate(self.repo, mdtype='filelists')
        cur = self._sql_MD('filelists',
                           "SELECT dirname, filetypes, filenames " \
                           "FROM   filelist JOIN packages USING(pkgKey) " \
                           "WHERE  packages.pkgId = ?", (self.pkgId,))
        for ob in cur:
            dirname = ob['dirname']
            filetypes = decodefiletypelist(ob['filetypes'])
            filenames = decodefilenamelist(ob['filenames'])
            while(filetypes):
                if dirname:
                    filename = dirname+'/'+filenames.pop()
                else:
                    filename = filenames.pop()
                filetype = _share_data(filetypes.pop())
                result.setdefault(filetype,[]).append(filename)
        self._loadedfiles = True
        self._files = result

        return self._files

    def _loadChangelog(self):
        result = []
        if not self._changelog:
            if self.repo not in self.sack.otherdb:
                try:
                    self.sack.populate(self.repo, mdtype='otherdata')
                except Errors.RepoError:
                    self._changelog = result
                    return
            cur = self._sql_MD('other',
                               "SELECT date, author, changelog " \
                               "FROM   changelog JOIN packages USING(pkgKey) " \
                               "WHERE  pkgId = ? ORDER BY date DESC",
                               (self.pkgId,))
            # Check count(pkgId) here, the same way we do in searchFiles()?
            # Failure mode is much less of a problem.
            for ob in cur:
                # Note: Atm. rpm only does days, where (60 * 60 * 24) == 86400
                #       and we have the hack in _dump_changelog() to keep the
                #       order the same, so this is a quick way to get rid of
                #       any extra "seconds".
                #       We still leak the seconds if there are 100 updates in
                #       a day ... but don't do that. It also breaks if rpm ever
                #       gets fixed (but that is unlikely).
                c_date = 100 * (ob['date'] / 100)
                c_author = to_utf8(ob['author'])
                c_log = to_utf8(ob['changelog'])
                result.append((c_date, _share_data(c_author), c_log))
            self._changelog = result
            return
        
    def returnIdSum(self):
        return (self.checksum_type, self.pkgId)
    
    def returnChangelog(self):
        self._loadChangelog()
        return self._changelog
    
    def returnFileEntries(self, ftype='file', primary_only=False):
        """return list of files based on type, you can pass primary_only=True
           to limit to those files in the primary repodata"""
        if primary_only and not self._loadedfiles:
            sql = "SELECT name as fname FROM files WHERE pkgKey = ? and type = ?"
            cur = self._sql_MD('primary', sql, (self.pkgKey, ftype))
            return map(lambda x: x['fname'], cur)

        self._loadFiles()
        return RpmBase.returnFileEntries(self,ftype,primary_only)
    
    def returnFileTypes(self, primary_only=False):
        """return list of types of files in the package, you can pass
           primary_only=True to limit to those files in the primary repodata"""
        if primary_only and not self._loadedfiles:
            sql = "SELECT DISTINCT type as ftype FROM files WHERE pkgKey = ?"
            cur = self._sql_MD('primary', sql, (self.pkgKey,))
            return map(lambda x: x['ftype'], cur)

        self._loadFiles()
        return RpmBase.returnFileTypes(self)

    def simpleFiles(self, ftype='file'):
        warnings.warn('simpleFiles() will go away in a future version of Yum.'
                      'Use returnFileEntries(primary_only=True)\n',
                      Errors.YumDeprecationWarning, stacklevel=2)
        sql = "SELECT name as fname FROM files WHERE pkgKey = ? and type = ?"
        cur = self._sql_MD('primary', sql, (self.pkgKey, ftype))
        return map(lambda x: x['fname'], cur)

    def returnPrco(self, prcotype, printable=False):
        prcotype = _share_data(prcotype)
        if isinstance(self.prco[prcotype], tuple):
            sql = "SELECT name, version, release, epoch, flags " \
                  "FROM %s WHERE pkgKey = ?" % prcotype
            cur = self._sql_MD('primary', sql, (self.pkgKey,))
            self.prco[prcotype] = [ ]
            for ob in cur:
                if not ob['name']:
                    continue
                prco_set = (_share_data(ob['name']), _share_data(ob['flags']),
                            (_share_data(ob['epoch']),
                             _share_data(ob['version']),
                             _share_data(ob['release'])))
                self.prco[prcotype].append(_share_data(prco_set))

        return RpmBase.returnPrco(self, prcotype, printable)
    
    def _requires_with_pre(self):
        """returns requires with pre-require bit"""
        sql = "SELECT name, version, release, epoch, flags,pre " \
              "FROM requires WHERE pkgKey = ?"
        cur = self._sql_MD('primary', sql, (self.pkgKey,))
        requires = []
        for ob in cur:
            pre = "0"
            if ob['pre'].lower() in ['TRUE', 1]:
                pre = "1"
            prco_set = (_share_data(ob['name']), _share_data(ob['flags']),
                        (_share_data(ob['epoch']),
                         _share_data(ob['version']),
                         _share_data(ob['release'])), pre)
            requires.append(prco_set)
        return requires

class YumSqlitePackageSack(yumRepo.YumPackageSack):
    """ Implementation of a PackageSack that uses sqlite cache instead of fully
    expanded metadata objects to provide information """

    def __init__(self, packageClass):
        # Just init as usual and create a dict to hold the databases
        yumRepo.YumPackageSack.__init__(self, packageClass)
        self.primarydb = {}
        self.filelistsdb = {}
        self.otherdb = {}
        self.excludes = {}     # of [repo] => {} of pkgId's => 1
        self._excludes = set() # of (repo, pkgKey)
        self._exclude_whitelist = set() # of (repo, pkgKey)
        self._all_excludes = {}
        self._search_cache = {
            'provides' : { },
            'requires' : { },
            }
        self._key2pkg = {}
        self._pkgname2pkgkeys = {}
        self._pkgtup2pkgs = {}
        self._pkgnames_loaded = set()
        self._pkgmatch_fails = set()
        self._provmatch_fails = set()
        self._arch_allowed = None
        self._pkgExcluder = []
        self._pkgExcludeIds = {}
        self._pkgobjlist_dirty = False

    @catchSqliteException
    def _sql_MD(self, MD, repo, sql, *args):
        """ Exec SQL against an MD of the repo, return a cursor. """

        cache = getattr(self, MD + 'db')[repo]
        cur = cache.cursor()
        executeSQL(cur, sql, *args)
        return cur

    def _sql_MD_pkg_num(self, MD, repo):
        """ Give a count of pkgIds in the given repo DB """
        sql = "SELECT count(pkgId) FROM packages"
        return self._sql_MD('primary', repo, sql).fetchone()[0]
        
    def _clean_pkgobjlist(self):
        """ If the pkgobjlist is dirty (possible pkgs on it which are excluded)
            then clean it, and return the clean list. """
        assert hasattr(self, 'pkgobjlist')

        if self._pkgobjlist_dirty:
            pol = filter(lambda x: not self._pkgExcluded(x), self.pkgobjlist)
            self.pkgobjlist = pol
            self._pkgobjlist_dirty = False

        return self.pkgobjlist

    def __len__(self):
        # First check if everything is excluded
        all_excluded = True
        for (repo, cache) in self.primarydb.items():
            if repo not in self._all_excludes:
                all_excluded = False
                break
        if all_excluded:
            return 0
            
        if hasattr(self, 'pkgobjlist'):
            return len(self._clean_pkgobjlist())

        exclude_num = 0
        for repo in self.excludes:
            exclude_num += len(self.excludes[repo])
        pkg_num = 0
        for repo in self.primarydb:
            pkg_num += self._sql_MD_pkg_num('primary', repo)
        return pkg_num - exclude_num

    def dropCachedData(self):
        if hasattr(self, '_memoize_requires'):
            del self._memoize_requires
        if hasattr(self, '_memoize_provides'):
            del self._memoize_provides
        if hasattr(self, 'pkgobjlist'):
            del self.pkgobjlist
        self._pkgobjlist_dirty = False
        self._key2pkg = {}
        self._pkgname2pkgkeys = {}
        self._pkgnames_loaded = set()
        self._pkgmatch_fails = set()
        self._provmatch_fails = set()
        self._pkgtup2pkgs = {}
        self._search_cache = {
            'provides' : { },
            'requires' : { },
            }
        misc.unshare_data()

    @catchSqliteException
    def close(self):
        self.dropCachedData()

        for dataobj in self.primarydb.values() + \
                       self.filelistsdb.values() + \
                       self.otherdb.values():
            dataobj.close()
        self.primarydb = {}
        self.filelistsdb = {}
        self.otherdb = {}
        self.excludes = {}
        self._excludes = set()
        self._exclude_whitelist = set()
        self._all_excludes = {}
        self._pkgExcluder = []
        self._pkgExcludeIds = {}
        self._pkgobjlist_dirty = False

        yumRepo.YumPackageSack.close(self)

    def buildIndexes(self):
        # We don't need to play with returnPackages() caching as it handles
        # additions to excludes after the cache is built.
        pass

    def _checkIndexes(self, failure='error'):
        return

    def _delPackageRK(self, repo, pkgKey):
        ''' Exclude a package so that _pkgExcluded*() knows it's gone.
            Note that this doesn't update self.exclude. '''
        self._excludes.add((repo, pkgKey))
        # Don't keep references around, just wastes memory.
        if repo in self._key2pkg:
            po = self._key2pkg[repo].pop(pkgKey, None)
            if po is not None: # Will also be in the pkgtup2pkgs cache...
                pos = self._pkgtup2pkgs[po.pkgtup]
                pos = filter(lambda x: id(x) == id(po), pos)
                self._pkgtup2pkgs[po.pkgtup] = pos

    # Remove a package
    # Because we don't want to remove a package from the database we just
    # add it to the exclude list
    def delPackage(self, obj):
        if obj.repo not in self.excludes:
            self.excludes[obj.repo] = {}
        self.excludes[obj.repo][obj.pkgId] = 1
        if (obj.repo, obj.pkgKey) in self._exclude_whitelist:
            self._exclude_whitelist.discard((obj.repo, obj.pkgKey))
        self._delPackageRK(obj.repo, obj.pkgKey)
        self._pkgobjlist_dirty = True

    def _delAllPackages(self, repo):
        """ Exclude all packages from the repo. """
        self._all_excludes[repo] = True
        if repo in self.excludes:
            del self.excludes[repo]
        if repo in self._key2pkg:
            del self._key2pkg[repo]
        if repo in self._pkgname2pkgkeys:
            del self._pkgname2pkgkeys[repo]

    def _excluded(self, repo, pkgId):
        if repo in self._all_excludes:
            return True
        
        if repo in self.excludes and pkgId in self.excludes[repo]:
            return True
                
        return False

    def _pkgKeyExcluded(self, repo, pkgKey):
        if self._all_excludes and repo in self._all_excludes:
            return True

        return self._excludes and (repo, pkgKey) in self._excludes

    def _pkgExcludedRKNEVRA(self, repo,pkgKey, n,e,v,r,a):
        ''' Main function to use for "can we use this package" question.
                . Tests repo against allowed repos.
                . Tests pkgKey against allowed packages.
                . Tests arch against allowed arches.
                . Tests addPackageExcluder() calls.
        '''

        if self._exclude_whitelist and (repo,pkgKey) in self._exclude_whitelist:
            return False

        if self._pkgKeyExcluded(repo, pkgKey):
            return True

        if self._arch_allowed is not None and a not in self._arch_allowed:
            self._delPackageRK(repo, pkgKey)
            return True

        if not self._pkgExcluder:
            return False

        data = {'n' : n.lower(), 'pkgtup' : (n, a, e, v, r), 'marked' : False}
        e = e.lower()
        v = v.lower()
        r = r.lower()
        a = a.lower()

        for repoid, excluder, match, regexp_match in self._pkgExcluder:
            if repoid is not None and repoid != repo.id:
                continue

            exSPLIT = excluder.split('.', 1)
            if len(exSPLIT) != 2:
                assert False, 'Bad excluder: ' + excluder
                continue

            exT, exM = exSPLIT
            if False: pass
            elif exT == 'exclude':
                if _excluder_match(exM, match, regexp_match, data, e,v,r,a):
                    self._delPackageRK(repo, pkgKey)
                    return True

            elif exT == 'include':
                if _excluder_match(exM, match, regexp_match, data, e,v,r,a):
                    break

            elif exT == 'mark':
                if data['marked']:
                    pass # Speed opt. don't do matches we don't need to do.
                elif _excluder_match(exM, match, regexp_match, data, e,v,r,a):
                    data['marked'] = True

            elif exT == 'wash':
                if not data['marked']:
                    pass # Speed opt. don't do matches we don't need to do.
                elif _excluder_match(exM, match, regexp_match, data, e,v,r,a):
                    data['marked'] = False

            else:
                assert False, 'Bad excluder: ' + excluder

        self._exclude_whitelist.add((repo, pkgKey))
        return False

    def _pkgExcludedRKT(self, repo,pkgKey, pkgtup):
        ''' Helper function to call _pkgExcludedRKNEVRA.
            Takes a repo, pkgKey and a package tuple'''
        (n,a,e,v,r) = pkgtup
        return self._pkgExcludedRKNEVRA(repo, pkgKey, n,e,v,r,a)

    def _pkgExcludedRKD(self, repo,pkgKey, data):
        ''' Helper function to call _pkgExcludedRKNEVRA.
            Takes a repo, pkgKey and a dict of package data'''
        (n,a,e,v,r) = (data['name'], data['arch'],
                       data['epoch'], data['version'], data['release'])
        return self._pkgExcludedRKNEVRA(repo, pkgKey, n,e,v,r,a)

    def _pkgExcluded(self, po):
        ''' Helper function to call _pkgExcludedRKNEVRA.
            Takes a package object. '''
        return self._pkgExcludedRKT(po.repo, po.pkgKey, po.pkgtup)

    def addPackageExcluder(self, repoid, excluderid, excluder, *args):
        """ Add an "excluder" for all packages in the repo/sack. Can basically
            do anything based on nevra, changes lots of exclude decisions from
            "preload package; test; delPackage" into "load excluder".
            Excluderid is used so the caller doesn't have to track
            "have I loaded the excluder for this repo.", it's probably only
            useful when repoid is None ... if it turns out utterly worthless
            then it's still not a huge wart. """
        if excluderid is not None and excluderid in self._pkgExcludeIds:
            return

        match        = None
        regexp_match = None
        if False: pass
        elif excluder.endswith('.eq'):
            assert len(args) == 1
            match = args[0].lower()
        elif excluder.endswith('.in'):
            assert len(args) == 1
            match = args[0]
        elif excluder.endswith('.match'):
            assert len(args) == 1
            match = args[0].lower()
            if misc.re_glob(match):
                regexp_match = re.compile(fnmatch.translate(match)).match
        elif excluder.endswith('.*'):
            assert len(args) == 0
        elif excluder.endswith('.marked'):
            assert len(args) == 0
        elif excluder.endswith('.washed'):
            assert len(args) == 0
        #  Really need to do this, need to cleanup pkgExcluder first though
        # or it does nothing.
        # self._pkgobjlist_dirty = True
        self._pkgExcluder.append((repoid, excluder, match, regexp_match))
        if excluderid is not None:
            self._pkgExcludeIds[excluderid] = len(self._pkgExcluder)

        self._exclude_whitelist = set()
        self._pkgobjlist_dirty  = True

    def _packageByKey(self, repo, pkgKey, exclude=True):
        """ Lookup a pkg by it's pkgKey, if we don't have it load it """
        # Speed hack, so we don't load the pkg. if the pkgKey is dead.
        assert exclude
        if exclude and self._pkgKeyExcluded(repo, pkgKey):
            return None

        if repo not in self._key2pkg:
            self._key2pkg[repo] = {}
            self._pkgname2pkgkeys[repo] = {}
        if pkgKey not in self._key2pkg[repo]:
            sql = "SELECT pkgKey, pkgId, name, epoch, version, release, arch " \
                  "FROM packages WHERE pkgKey = ?"
            data = self._sql_MD('primary', repo, sql, (pkgKey,)).fetchone()
            if data is None:
                msg = "pkgKey %s doesn't exist in repo %s" % (pkgKey, repo)
                raise Errors.RepoError, msg
            if exclude and self._pkgExcludedRKD(repo, pkgKey, data):
                return None
            po = self.pc(repo, data)
            self._key2pkg[repo][pkgKey] = po
            self._pkgtup2pkgs.setdefault(po.pkgtup, []).append(po)
            pkgkeys = self._pkgname2pkgkeys[repo].setdefault(data['name'], [])
            pkgkeys.append(pkgKey)
        elif exclude and self._pkgExcluded(self._key2pkg[repo][pkgKey]):
            self._delPackageRK(repo, pkgKey)
            return None
        return self._key2pkg[repo][pkgKey]
        
    def _packageByKeyData(self, repo, pkgKey, data, exclude=True):
        """ Like _packageByKey() but we already have the data for .pc() """
        assert exclude
        if exclude and self._pkgExcludedRKD(repo, pkgKey, data):
            return None
        if repo not in self._key2pkg:
            self._key2pkg[repo] = {}
            self._pkgname2pkgkeys[repo] = {}
        if data['pkgKey'] not in self._key2pkg.get(repo, {}):
            po = self.pc(repo, data)
            self._key2pkg[repo][pkgKey] = po
            self._pkgtup2pkgs.setdefault(po.pkgtup, []).append(po)
            pkgkeys = self._pkgname2pkgkeys[repo].setdefault(data['name'], [])
            pkgkeys.append(pkgKey)
        return self._key2pkg[repo][data['pkgKey']]

    def _pkgtupByKeyData(self, repo, pkgKey, data):
        """ Like _packageByKeyData() but we don't create the package, we just
            return the pkgtup. """
        if self._pkgExcludedRKD(repo, pkgKey, data):
            return None
        prepo = self._key2pkg.get(repo)
        if prepo is None:
            self._key2pkg[repo] = {}
            self._pkgname2pkgkeys[repo] = {}
        elif data['pkgKey'] in prepo:
            return prepo[data['pkgKey']].pkgtup
        return (data['name'], data['arch'],
                data['epoch'], data['version'], data['release'])

    def _packagesByName(self, pkgname):
        """ Load all pkgnames from cache, with a given name. """
        ret = []
        for repo in self.primarydb:
            pkgkeys = self._pkgname2pkgkeys.get(repo, {}).get(pkgname, [])
            if not pkgkeys:
                continue

            for pkgkey in pkgkeys:
                pkg = self._packageByKey(repo, pkgkey)
                if pkg is None:
                    continue
                ret.append(pkg)
        return ret

    def addDict(self, repo, datatype, dataobj, callback=None):
        if repo in self.added:
            if datatype in self.added[repo]:
                return
        else:
            self.added[repo] = []

        if repo not in self.excludes:
            self.excludes[repo] = {}

        if dataobj is None:
            raise Errors.RepoError, "Tried to add None %s to %s" % (datatype, repo)

        if datatype == 'metadata':
            self.primarydb[repo] = dataobj
        elif datatype == 'filelists':
            self.filelistsdb[repo] = dataobj
        elif datatype == 'otherdata':
            self.otherdb[repo] = dataobj
        else:
            # We can not handle this yet...
            raise Errors.RepoError, "Sorry sqlite does not support %s in %s" % (datatype, repo)
    
        self.added[repo].append(datatype)

        
    # Get all files for a certain pkgId from the filelists.xml metadata
    # Search packages that either provide something containing name
    # or provide a file containing name 
    def searchAll(self,name, query_type='like'):
        # this function is just silly and it reduces down to just this
        return self.searchPrco(name, 'provides')

    def _sql_pkgKey2po(self, repo, cur, pkgs=None, have_data=False):
        """ Takes a cursor and maps the pkgKey rows into a list of packages. """
        if pkgs is None: pkgs = []
        for ob in cur:
            if have_data:
                pkg = self._packageByKeyData(repo, ob['pkgKey'], ob)
            else:
                pkg = self._packageByKey(repo, ob['pkgKey'])
            if pkg is None:
                continue
            pkgs.append(pkg)
        return pkgs

    def _skip_all(self):
        """ Are we going to skip every package in all our repos? """
        skip_all = True
        for repo in self.added:
            if repo not in self._all_excludes:
                skip_all = False
                break
        return skip_all

    @catchSqliteException
    def _search_primary_files(self, name):
        querytype = 'glob'
        name = os.path.normpath(name)
        if not misc.re_glob(name):
            querytype = '='        
        results = []
        
        for (rep,cache) in self.primarydb.items():
            if rep in self._all_excludes:
                continue
            cur = cache.cursor()
            executeSQL(cur, "select DISTINCT pkgKey from files where name %s ?" % querytype, (name,))
            self._sql_pkgKey2po(rep, cur, results)

        return misc.unique(results)
        
    @catchSqliteException
    def _have_fastReturnFileEntries(self):
        """ Return true if pkg.returnFileEntries(primary_only=True) is fast.
            basically does "CREATE INDEX pkgfiles ON files (pkgKey);" exist. """

        for (rep,cache) in self.primarydb.items():
            if rep in self._all_excludes:
                continue
            cur = cache.cursor()
            executeSQL(cur, "PRAGMA index_info(pkgfiles)")
            #  If we get anything, we're fine. There might be a better way of
            # saying "anything" but this works.
            for ob in cur:
                break
            else:
                return False

        return True

    def have_fastReturnFileEntries(self):
        """ Is calling pkg.returnFileEntries(primary_only=True) faster than
            using searchFiles(). """
        if not hasattr(self, '_cached_fRFE'):
            self._cached_fRFE = self._have_fastReturnFileEntries()
        return self._cached_fRFE

    @catchSqliteException
    def searchFiles(self, name, strict=False):
        """search primary if file will be in there, if not, search filelists, use globs, if possible"""
        
        if self._skip_all():
            return []

        # optimizations:
        # if it is not  glob, then see if it is in the primary.xml filelists, 
        # if so, just use those for the lookup
        
        glob = True
        file_glob = True
        querytype = 'glob'
        name = os.path.normpath(name)
        dirname  = os.path.dirname(name)
        filename = os.path.basename(name)
        if strict or not misc.re_glob(name):
            glob = False
            file_glob = False
            querytype = '='
        elif not misc.re_glob(filename):
            file_glob = False

        # Take off the trailing slash to act like rpm
        if name[-1] == '/':
            name = name[:-1]
       
        pkgs = []

        # ultra simple optimization 
        if misc.re_primary_filename(name):
            if not misc.re_glob(dirname): # is the dirname a glob?
                return self._search_primary_files(name)
        
        if len(self.filelistsdb) == 0:
            # grab repo object from primarydb and force filelists population in this sack using repo
            # sack.populate(repo, mdtype, callback, cacheonly)
            for (repo,cache) in self.primarydb.items():
                if repo in self._all_excludes:
                    continue

                self.populate(repo, mdtype='filelists')

        # Check to make sure the DB data matches, this should always pass but
        # we've had weird errors. So check it for a bit.
        for repo in self.filelistsdb:
            # Only check each repo. once ... the libguestfs check :).
            if hasattr(repo, '_checked_filelists_pkgs'):
                continue
            pri_pkgs = self._sql_MD_pkg_num('primary',   repo)
            fil_pkgs = self._sql_MD_pkg_num('filelists', repo)
            if pri_pkgs != fil_pkgs:
                raise Errors.RepoError
            repo._checked_filelists_pkgs = True

        sql_params = []
        dirname_check = ""
        if not glob:
            (pattern, esc) = sql_esc(filename)
            dirname_check = "dirname = ? and filenames LIKE ? %s and " % esc
            sql_params.append(dirname)
            sql_params.append('%' + pattern + '%')
        elif not file_glob:
            (pattern, esc) = sql_esc(filename)
            dirname_check = "dirname GLOB ? and filenames LIKE ? %s and " % esc
            sql_params.append(dirname)
            sql_params.append('%' + pattern + '%')
        elif filename == '*':
            # We only care about matching on dirname...
            for (rep,cache) in self.filelistsdb.items():
                if rep in self._all_excludes:
                    continue

                cur = cache.cursor()
                sql_params.append(dirname)
                executeSQL(cur, """SELECT pkgKey FROM filelist
                                   WHERE dirname %s ?""" % (querytype,),
                           sql_params)
                self._sql_pkgKey2po(rep, cur, pkgs)

            return misc.unique(pkgs)

        for (rep,cache) in self.filelistsdb.items():
            if rep in self._all_excludes:
                continue

            cur = cache.cursor()

            # grab the entries that are a single file in the 
            # filenames section, use sqlites globbing if it is a glob
            executeSQL(cur, "select pkgKey from filelist where \
                    %s length(filetypes) = 1 and \
                    dirname || ? || filenames \
                    %s ?" % (dirname_check, querytype), sql_params + ['/',name])
            self._sql_pkgKey2po(rep, cur, pkgs)

            if file_glob:
                name_re = re.compile(fnmatch.translate(name))
            def filelist_globber(sql_dirname, sql_filenames):
                # Note: Can't return bool, because sqlite doesn't like it in
                #       weird ways. Test:
                #                         install '*bin/autoheader'
                #                         provides /lib/security/pam_loginuid.so
                files = sql_filenames.split('/')
                if not file_glob:
                    return int(filename in files)

                fns = map(lambda f: '%s/%s' % (sql_dirname, f), files)
                for match in fns:
                    if name_re.match(match):
                        return 1
                return 0

            cache.create_function("filelist_globber", 2, filelist_globber)
            # for all the ones where filenames is multiple files, 
            # make the files up whole and use python's globbing method
            executeSQL(cur, "select pkgKey from filelist where \
                             %s length(filetypes) > 1 \
                             and filelist_globber(dirname,filenames)" % dirname_check,
                       sql_params)

            self._sql_pkgKey2po(rep, cur, pkgs)

        pkgs = misc.unique(pkgs)
        return pkgs
        
    @catchSqliteException
    def searchPrimaryFields(self, fields, searchstring):
        """search arbitrary fields from the primarydb for a string"""
        if self._skip_all():
            return []

        result = []
        if len(fields) < 1:
            return result
        
        searchstring = searchstring.replace("'", "''")
        (searchstring, esc) = sql_esc(searchstring)
        sql = "select DISTINCT pkgKey from packages where %s like '%%%s%%'%s " % (fields[0], searchstring, esc)
        
        for f in fields[1:]:
            sql = "%s or %s like '%%%s%%'%s " % (sql, f, searchstring, esc)
        
        for (rep,cache) in self.primarydb.items():
            cur = cache.cursor()
            executeSQL(cur, sql)
            self._sql_pkgKey2po(rep, cur, result)
        return result    

    @catchSqliteException
    def searchPrimaryFieldsMultipleStrings(self, fields, searchstrings):
        """search arbitrary fields from the primarydb for a multiple strings
           return packages, number of items it matched as a list of tuples"""
           
        if self._skip_all():
            return []

        result = [] # (pkg, num matches)
        if not fields or not searchstrings:
            return result
        
        # NOTE: I can't see any reason not to use this all the time, speed
        # comparison shows them as basically equal.
        if len(searchstrings) > (constants.PATTERNS_MAX / len(fields)):
            tot = {}
            for searchstring in searchstrings:
                matches = self.searchPrimaryFields(fields, searchstring)
                for po in matches:
                    tot[po] = tot.get(po, 0) + 1
            for po in sorted(tot, key=operator.itemgetter, reverse=True):
                result.append((po, tot[po]))
            return result
       
        unionstring = "select pkgKey, SUM(cumul) AS total from ( "
        endunionstring = ")GROUP BY pkgKey ORDER BY total DESC"
                
        #SELECT pkgkey, SUM(cumul) AS total FROM (SELECT pkgkey, 1 
        #AS cumul FROM packages WHERE description LIKE '%foo%' UNION ... ) 
        #GROUP BY pkgkey ORDER BY total DESC;
        selects = []
        
        for s in searchstrings:         
            s = s.replace("'", "''")
            (s, esc) = sql_esc(s)
            sql="select pkgKey,1 AS cumul from packages where %s like '%%%s%%'%s " % (fields[0], s, esc)
            for f in fields[1:]:
                sql = "%s or %s like '%%%s%%'%s " % (sql, f, s, esc)
            selects.append(sql)
        
        totalstring = unionstring + " UNION ALL ".join(selects) + endunionstring

        for (rep,cache) in self.primarydb.items():
            cur = cache.cursor()
            executeSQL(cur, totalstring)
            for ob in cur:
                pkg = self._packageByKey(rep, ob['pkgKey'])
                if pkg is None:
                    continue
                result.append((pkg, ob['total']))
        return result
        
    @catchSqliteException
    def returnObsoletes(self, newest=False):
        if self._skip_all():
            return {}

        if newest:
            raise NotImplementedError()

        obsoletes = {}
        for (rep,cache) in self.primarydb.items():
            cur = cache.cursor()
            executeSQL(cur, "select packages.name as name,\
                packages.pkgKey as pkgKey,\
                packages.arch as arch, packages.epoch as epoch,\
                packages.release as release, packages.version as version,\
                obsoletes.name as oname, obsoletes.epoch as oepoch,\
                obsoletes.release as orelease, obsoletes.version as oversion,\
                obsoletes.flags as oflags\
                from obsoletes,packages where obsoletes.pkgKey = packages.pkgKey")
            for ob in cur:
                key = ( _share_data(ob['name']), _share_data(ob['arch']),
                        _share_data(ob['epoch']), _share_data(ob['version']),
                        _share_data(ob['release']))
                if self._pkgExcludedRKT(rep, ob['pkgKey'], key):
                    continue

                (n,f,e,v,r) = ( _share_data(ob['oname']),
                                _share_data(ob['oflags']),
                                _share_data(ob['oepoch']),
                                _share_data(ob['oversion']),
                                _share_data(ob['orelease']))

                key = _share_data(key)
                val = _share_data((n,f,(e,v,r)))
                obsoletes.setdefault(key,[]).append(val)

        return obsoletes

    @catchSqliteException
    def getPackageDetails(self,pkgId):
        for (rep,cache) in self.primarydb.items():
            cur = cache.cursor()
            executeSQL(cur, "select * from packages where pkgId = ?", (pkgId,))
            for ob in cur:
                return ob
    
    @catchSqliteException
    def _getListofPackageDetails(self, pkgId_list):
        pkgs = []
        if len(pkgId_list) == 0:
            return pkgs
        pkgid_query = str(tuple(pkgId_list))

        for (rep,cache) in self.primarydb.items():
            cur = cache.cursor()
            executeSQL(cur, "select * from packages where pkgId in %s" %(pkgid_query,))
            for ob in cur:
                pkgs.append(ob)
        
        return pkgs
        
    @catchSqliteException
    def _search_get_memoize(self, prcotype):
        if not hasattr(self, '_memoize_' + prcotype):
            memoize = {}

            for (rep,cache) in self.primarydb.items():
                if rep in self._all_excludes:
                    continue

                cur = cache.cursor()
                executeSQL(cur, "select * from %s" % prcotype)
                for x in cur:
                    val = (_share_data(x['name']), _share_data(x['flags']),
                           (_share_data(x['epoch']), _share_data(x['version']),
                            _share_data(x['release'])))
                    val = _share_data(val)
                    key = (rep, val[0])
                    pkgkey = _share_data(x['pkgKey'])
                    val = (pkgkey, val)
                    memoize.setdefault(key, []).append(val)
            setattr(self, '_memoize_' + prcotype, memoize)
        return getattr(self, '_memoize_' + prcotype)

    @catchSqliteException
    def _search(self, prcotype, name, flags, version):

        if self._skip_all():
            return {}
        
        name = to_unicode(name)
        if flags == 0:
            flags = None
        if type(version) in (str, type(None), unicode):
            req = (name, flags, rpmUtils.miscutils.stringToVersion(
                version))
        elif type(version) in (tuple, list): # would this ever be a list?
            req = (name, flags, version)

        prcotype = _share_data(prcotype)
        req      = _share_data(req)
        if req in self._search_cache[prcotype]:
            return self._search_cache[prcotype][req]

        result = { }

        #  Requires is the biggest hit, pre-loading provides actually hurts
        #  NOTE: Disabling atm. ... small install/updates get a significant hit.
        # And even large updates take a hit with the memoize path, maybe we
        # fixed something with later change? ... maybe I was on crack?
        #  Speed seems to depend on _search_cache.
        if True: # prcotype != 'requires':
            primarydb_items = self.primarydb.items()
            preload = False
        else:
            primarydb_items = []
            preload = True
            memoize = self._search_get_memoize(prcotype)
            for (rep,cache) in self.primarydb.items():
                if rep in self._all_excludes:
                    continue

                tmp = {}
                for x in memoize.get((rep, name), []):
                    pkgkey, val = x
                    if rpmUtils.miscutils.rangeCompare(req, val):
                        tmp.setdefault(pkgkey, []).append(val)
                for pkgKey, hits in tmp.iteritems():
                    pkg = self._packageByKey(rep, pkgKey)
                    if pkg is None:
                        continue
                    result[pkg] = hits

        for (rep,cache) in primarydb_items:
            if rep in self._all_excludes:
                continue

            cur = cache.cursor()
            executeSQL(cur, "select * from %s where name=?" % prcotype,
                       (name,))
            tmp = { }
            for x in cur:
                val = (_share_data(x['name']), _share_data(x['flags']),
                       (_share_data(x['epoch']), _share_data(x['version']),
                        _share_data(x['release'])))
                val = _share_data(val)
                if rpmUtils.miscutils.rangeCompare(req, val):
                    tmp.setdefault(x['pkgKey'], []).append(val)
            for pkgKey, hits in tmp.iteritems():
                pkg = self._packageByKey(rep, pkgKey)
                if pkg is None:
                    continue
                result[pkg] = hits

        if prcotype != 'provides' or name[0] != '/':
            if not preload:
                self._search_cache[prcotype][req] = result
            return result

        if not misc.re_primary_filename(name):
            # If it is not in the primary.xml files
            # search the files.xml file info
            for pkg in self.searchFiles(name, strict=True):
                result[pkg] = [(name, None, None)]
            if not preload:
                self._search_cache[prcotype][req] = result
            return result

        # If it is a filename, search the primary.xml file info
        
        for pkg in self._search_primary_files(name):
            result[pkg] = [(name, None, None)]
            self._search_cache[prcotype][req] = result
        return result

    def getProvides(self, name, flags=None, version=(None, None, None)):
        return self._search("provides", name, flags, version)

    def getRequires(self, name, flags=None, version=(None, None, None)):
        return self._search("requires", name, flags, version)

    @catchSqliteException
    def searchNames(self, names=[], return_pkgtups=False):
        """return a list of packages matching any of the given names. This is 
           only a match on package name, nothing else"""
        
        if self._skip_all():
            return []
        
        loaded_all_names = hasattr(self, 'pkgobjlist')
        returnList = []
        user_names = set(names)
        names = []
        for pkgname in user_names:
            if pkgname in self._pkgmatch_fails:
                continue

            if loaded_all_names or pkgname in self._pkgnames_loaded:
                returnList.extend(self._packagesByName(pkgname))
            else:
                names.append(pkgname)

        if return_pkgtups:
            returnList = [pkg.pkgtup for pkg in returnList]
        if not names:
            return returnList

        max_entries = constants.PATTERNS_INDEXED_MAX
        if len(names) > max_entries:
            # Unique is done at user_names time, above.
            for names in seq_max_split(names, max_entries):
                returnList.extend(self.searchNames(names, return_pkgtups))
            return returnList

        pat_sqls = []
        qsql = """select pkgId,pkgKey,name,epoch,version,release,arch
                      from packages where """
        for name in names:
            pat_sqls.append("name = ?")
        qsql = qsql + " OR ".join(pat_sqls)

        for (repo, cache) in self.primarydb.items():
            cur = cache.cursor()
            executeSQL(cur, qsql, names)

            if return_pkgtups:
                for ob in cur:
                    pkgtup = self._pkgtupByKeyData(repo, ob['pkgKey'], ob)
                    if pkgtup is None:
                        continue
                    returnList.append(pkgtup)
                continue

            self._sql_pkgKey2po(repo, cur, returnList, have_data=True)

        if not return_pkgtups:
            # Mark all the processed pkgnames as fully loaded
            self._pkgnames_loaded.update([name for name in names])

        return returnList
 
    @catchSqliteException
    def searchPrco(self, name, prcotype):
        """return list of packages matching name and prcotype """
        # we take name to be a string of some kind
        # we parse the string to see if it is a foo > 1.1 or if it is just 'foo'
        # or what - so we can answer correctly
        
        if self._skip_all():
            return []
        try:
            (n,f,(e,v,r)) = misc.string_to_prco_tuple(name)
        except Errors.MiscError, e:
            raise Errors.PackageSackError, to_unicode(e)

        # The _b means this is a byte string
        # The _u means this is a unicode string
        # A bare n is used when, it's unicode but hasn't been evaluated
        # whether that's actually the right thing to do
        n_b = n
        n_u = to_unicode(n)
        n = n_u

        glob = True
        querytype = 'glob'
        if not misc.re_glob(n):
            glob = False
            querytype = '='

        basic_results = []
        results = []
        for (rep,cache) in self.primarydb.items():
            cur = cache.cursor()
            executeSQL(cur, "select DISTINCT pkgKey from %s where name %s ?" % (prcotype,querytype), (n,))
            self._sql_pkgKey2po(rep, cur, basic_results)
        
        # now we have a list of items matching just the name - let's match them out
        for po in basic_results:
            if misc.re_filename(n) and v is None:
                # file dep add all matches to the results
                results.append(po)
                continue

            if not glob:
                if po.checkPrco(prcotype, (n_b, f, (e,v,r))):
                    results.append(po)
            else:
                # if it is a glob we can't really get any closer to checking it
                results.append(po)
        # If it's not a provides or a filename, we are done
        if prcotype != "provides":
            return results
        if not misc.re_filename(n):
            return results

        # If it is a filename, search the primary.xml file info
        results.extend(self._search_primary_files(n))

        # If it is in the primary.xml files then skip the other check
        if misc.re_primary_filename(n) and not glob:
            return misc.unique(results)

        # If it is a filename, search the files.xml file info
        results.extend(self.searchFiles(n))
        return misc.unique(results)

    def searchProvides(self, name):
        """return list of packages providing name (any evr and flag)"""
        if name in self._provmatch_fails:
            return []
        ret = self.searchPrco(name, "provides")
        if not ret:
            self._provmatch_fails.add(name)
        return ret
                
    def searchRequires(self, name):
        """return list of packages requiring name (any evr and flag)"""
        return self.searchPrco(name, "requires")

    def searchObsoletes(self, name):
        """return list of packages obsoleting name (any evr and flag)"""
        return self.searchPrco(name, "obsoletes")

    def searchConflicts(self, name):
        """return list of packages conflicting with name (any evr and flag)"""
        return self.searchPrco(name, "conflicts")


    def db2class(self, db, nevra_only=False):
        print 'die die die die die db2class'
        class tmpObject:
            pass
        y = tmpObject()
        
        y.nevra = (db['name'],db['epoch'],db['version'],db['release'],db['arch'])
        y.sack = self
        y.pkgId = db['pkgId']
        if nevra_only:
            return y
        
        y.hdrange = {'start': db['rpm_header_start'],'end': db['rpm_header_end']}
        y.location = {'href': db['location_href'],'value': '', 'base': db['location_base']}
        y.checksum = {'pkgid': 'YES','type': db['checksum_type'], 
                    'value': db['pkgId'] }
        y.time = {'build': db['time_build'], 'file': db['time_file'] }
        y.size = {'package': db['size_package'], 'archive': db['size_archive'], 'installed': db['size_installed'] }
        y.info = {'summary': db['summary'], 'description': db['description'],
                'packager': db['rpm_packager'], 'group': db['rpm_group'],
                'buildhost': db['rpm_buildhost'], 'sourcerpm': db['rpm_sourcerpm'],
                'url': db['url'], 'vendor': db['rpm_vendor'], 'license': db['rpm_license'] }
        return y

    @catchSqliteException
    def returnNewestByNameArch(self, naTup=None, patterns=None, ignore_case=False):

        # If naTup is set do it from the database otherwise use our parent's
        # returnNewestByNameArch
        if (not naTup):
            return yumRepo.YumPackageSack.returnNewestByNameArch(self, naTup,
                                                                 patterns,
                                                                 ignore_case)

        # First find all packages that fulfill naTup
        allpkg = []
        for (rep,cache) in self.primarydb.items():
            cur = cache.cursor()
            executeSQL(cur, "select pkgId,pkgKey,name,epoch,version,release,arch from packages where name=? and arch=?", naTup)
            self._sql_pkgKey2po(rep, cur, allpkg, have_data=True)
        
        # if we've got zilch then raise
        if not allpkg:
            raise Errors.PackageSackError, 'No Package Matching %s.%s' % naTup
        return misc.newestInList(allpkg)

    @catchSqliteException
    def returnNewestByName(self, name=None, patterns=None, ignore_case=False):
        """return list of newest packages based on name matching
           this means(in name.arch form): foo.i386 and foo.noarch will
           be compared to each other for highest version.
           Note that given: foo-1.i386; foo-2.i386 and foo-3.x86_64
           The last _two_ pkgs will be returned, not just one of them. """
        # If name is set do it from the database otherwise use our parent's
        # returnNewestByName
        if self._skip_all():
            return []

        if (not name):
            return yumRepo.YumPackageSack.returnNewestByName(self, name,
                                                             patterns,
                                                             ignore_case)

        # First find all packages that fulfill name
        allpkg = []
        for (rep,cache) in self.primarydb.items():
            cur = cache.cursor()
            executeSQL(cur, "select pkgId,pkgKey,name,epoch,version,release,arch from packages where name=?", (name,))
            self._sql_pkgKey2po(rep, cur, allpkg, have_data=True)
        
        # if we've got zilch then raise
        if not allpkg:
            raise Errors.PackageSackError, 'No Package Matching %s' % name
        return misc.newestInList(allpkg)

    # Do what packages.matchPackageNames does, but query the DB directly
    @catchSqliteException
    def matchPackageNames(self, pkgspecs):
        if self._skip_all():
            return [], [], []

        matched = []
        exactmatch = []
        unmatched = list(pkgspecs)

        for p in pkgspecs:
            if misc.re_glob(p):
                query = PARSE_QUERY % ({ "op": "glob", "q": p })
                matchres = matched
            else:
                query = PARSE_QUERY % ({ "op": "=", "q": p })
                matchres = exactmatch

            for (rep, db) in self.primarydb.items():
                cur = db.cursor()
                executeSQL(cur, query)
                pmatches = self._sql_pkgKey2po(rep, cur)
                if len(pmatches):
                    unmatched.remove(p)
                matchres.extend(pmatches)

        exactmatch = misc.unique(exactmatch)
        matched = misc.unique(matched)
        unmatched = misc.unique(unmatched)
        return exactmatch, matched, unmatched

    def _setupPkgObjList(self, repoid=None, patterns=None, ignore_case=False):
        """Setup need_full and patterns for _yieldSQLDataList, also see if
           we can get away with just using searchNames(). """

        if patterns is None:
            patterns = []

        fields = ['name', 'sql_nameArch', 'sql_nameVerRelArch',
                  'sql_nameVer', 'sql_nameVerRel',
                  'sql_envra', 'sql_nevra']
        need_full = False
        for pat in patterns:
            if (misc.re_full_search_needed(pat) and
                (ignore_case or pat not in self._pkgnames_loaded)):
                need_full = True
                break

        pat_max = constants.PATTERNS_MAX
        if not need_full:
            fields = ['name']
            pat_max = constants.PATTERNS_INDEXED_MAX
        if len(patterns) > pat_max:
            patterns = []
        if ignore_case:
            patterns = sql_esc_glob(patterns)
        else:
            tmp = []
            need_glob = False
            for pat in patterns:
                if misc.re_glob(pat):
                    tmp.append((pat, 'glob'))
                    need_glob = True
                else:
                    tmp.append((pat, '='))
            if not need_full and not need_glob and patterns:
                return (need_full, patterns, fields, True)
            patterns = tmp
        return (need_full, patterns, fields, False)

    @catchSqliteException
    def _yieldSQLDataList(self, repoid, patterns, fields, ignore_case):
        """Yields all the package data for the given params. Excludes are done
           at this stage. """

        pat_sqls = []
        pat_data = []
        for (pattern, rest) in patterns:
            if not ignore_case and pattern in self._pkgmatch_fails:
                continue

            for field in fields:
                if ignore_case:
                    pat_sqls.append("%s LIKE ?%s" % (field, rest))
                else:
                    pat_sqls.append("%s %s ?" % (field, rest))
                pat_data.append(pattern)
        if patterns and not pat_sqls:
            return

        if pat_sqls:
            qsql = _FULL_PARSE_QUERY_BEG + " OR ".join(pat_sqls)
        else:
            qsql = """select pkgId, pkgKey, name,epoch,version,release,arch
                      from packages"""

        for (repo,cache) in self.primarydb.items():
            if (repoid == None or repoid == repo.id):
                cur = cache.cursor()
                executeSQL(cur, qsql, pat_data)
                for x in cur:
                    yield (repo, x)

    def _buildPkgObjList(self, repoid=None, patterns=None, ignore_case=False):
        """Builds a list of packages, only containing nevra information.
           Excludes are done at this stage. """

        returnList = []

        data = self._setupPkgObjList(repoid, patterns, ignore_case)
        (need_full, patterns, fields, names) = data
        if names:
            return self.searchNames(patterns)

        for (repo, x) in self._yieldSQLDataList(repoid, patterns, fields,
                                                ignore_case):
            # Can't use: _sql_pkgKey2po because we change repos.
            po = self._packageByKeyData(repo, x['pkgKey'], x)
            if po is None:
                continue
            returnList.append(po)
        if not patterns and repoid is None:
            self.pkgobjlist = returnList
            self._pkgnames_loaded = set() # Save memory
        if not need_full and repoid is None:
            # Mark all the processed pkgnames as fully loaded
            self._pkgnames_loaded.update([po.name for po in returnList])
        if need_full:
            for (pat, rest) in patterns:
                if rest not in ('=', ''): # Wildcards: 'glob' or ' ESCAPE "!"'
                    continue
                for pkg in returnList:
                    if pkg.name == pat:
                        self._pkgnames_loaded.add(pkg.name)
                        break
        if not returnList:
            for (pat, rest) in patterns:
                self._pkgmatch_fails.add(pat)

        return returnList
                
    def returnPackages(self, repoid=None, patterns=None, ignore_case=False):
        """Returns a list of packages, only containing nevra information. The
           packages are processed for excludes. Note that the packages are
           always filtered to those matching the patterns/case. """

        if self._skip_all():
            return []

        internal_pkgoblist = hasattr(self, 'pkgobjlist')
        if internal_pkgoblist:
            pkgobjlist = self._clean_pkgobjlist()
        else:
            pkgobjlist = self._buildPkgObjList(repoid, patterns, ignore_case)
            internal_pkgoblist = hasattr(self, 'pkgobjlist')

        if internal_pkgoblist and patterns:
            internal_pkgoblist = False
            pkgobjlist = parsePackages(pkgobjlist, patterns, not ignore_case,
                                       unique='repo-pkgkey')
            pkgobjlist = pkgobjlist[0] + pkgobjlist[1]

        # Can't unexclude things, and new excludes are done above...
        if repoid is None:
            if internal_pkgoblist:
                pkgobjlist = pkgobjlist[:]
            return pkgobjlist

        returnList = []
        for po in pkgobjlist:
            if repoid != po.repoid:
                continue
            returnList.append(po)

        return returnList

    def simplePkgList(self, patterns=None, ignore_case=False):
        """Returns a list of pkg tuples (n, a, e, v, r), optionally from a
           single repoid. Note that the packages are always filtered to those
           matching the patterns/case. """

        if self._skip_all():
            return []

        internal_pkgoblist = hasattr(self, 'pkgobjlist')
        if internal_pkgoblist:
            return yumRepo.YumPackageSack.simplePkgList(self, patterns,
                                                        ignore_case)

        repoid = None
        returnList = []
        # Haven't loaded everything, so _just_ get the pkgtups...
        data = self._setupPkgObjList(repoid, patterns, ignore_case)
        (need_full, patterns, fields, names) = data
        if names:
            return [pkg.pkgtup for pkg in self.searchNames(patterns)]

        for (repo, x) in self._yieldSQLDataList(repoid, patterns, fields,
                                                ignore_case):
            # NOTE: Can't unexclude things...
            pkgtup = self._pkgtupByKeyData(repo, x['pkgKey'], x)
            if pkgtup is None:
                continue
            returnList.append(pkgtup)
        return returnList

    @catchSqliteException
    def searchNevra(self, name=None, epoch=None, ver=None, rel=None, arch=None):        
        """return list of pkgobjects matching the nevra requested"""
        if self._skip_all():
            return []

        returnList = []
        
        if name: # Almost always true...
            for pkg in self.searchNames(names=[name]):
                match = True
                for (col, var) in [('epoch', epoch), ('version', ver),
                                   ('arch', arch), ('release', rel)]:
                    if var and getattr(pkg, col) != var:
                        match = False
                        break
                if match:
                    returnList.append(pkg)
            return returnList

        # make sure some dumbass didn't pass us NOTHING to search on
        empty = True
        for arg in (name, epoch, ver, rel, arch):
            if arg:
                empty = False
        if empty:
            return returnList
        
        # make up our execute string
        q = "select pkgId,pkgKey,name,epoch,version,release,arch from packages WHERE"
        for (col, var) in [('name', name), ('epoch', epoch), ('version', ver),
                           ('arch', arch), ('release', rel)]:
            if var:
                if q[-5:] != 'WHERE':
                    q = q + ' AND %s = "%s"' % (col, var)
                else:
                    q = q + ' %s = "%s"' % (col, var)
            
        # Search all repositories            
        for (rep,cache) in self.primarydb.items():
            cur = cache.cursor()
            executeSQL(cur, q)
            self._sql_pkgKey2po(rep, cur, returnList, have_data=True)
        return returnList
    
    @catchSqliteException
    def excludeArchs(self, archlist):
        """excludes incompatible arches - archlist is a list of compat arches"""

        if self._arch_allowed is None:
            self._arch_allowed = set(archlist)
        else:
            self._arch_allowed = self._arch_allowed.intersection(archlist)
        sarchlist = map(lambda x: "'%s'" % x , archlist)
        arch_query = ",".join(sarchlist)

        for (rep, cache) in self.primarydb.items():
            cur = cache.cursor()

            #  This is a minor hack opt. for source repos. ... if they are
            # enabled normally, we don't want to exclude each package so we
            # check it and exclude the entire thing.
            if not rep.id.endswith("-source") or 'src' in self._arch_allowed:
                continue
            has_arch = False
            executeSQL(cur, "SELECT DISTINCT arch FROM packages")
            for row in cur:
                if row[0] in archlist:
                    has_arch = True
                    break
            if not has_arch:
                self._delAllPackages(rep)
                return

# Simple helper functions

# Return a string representing filenamelist (filenames can not contain /)
def encodefilenamelist(filenamelist):
    return '/'.join(filenamelist)

# Return a list representing filestring (filenames can not contain /)
def decodefilenamelist(filenamestring):
    filenamestring = filenamestring.replace('//', '/')
    return filenamestring.split('/')

# Return a string representing filetypeslist
# filetypes should be file, dir or ghost
def encodefiletypelist(filetypelist):
    result = ''
    ft2string = {'file': 'f','dir': 'd','ghost': 'g'}
    for x in filetypelist:
        result += ft2string[x]
    return result

# Return a list representing filetypestring
# filetypes should be file, dir or ghost
def decodefiletypelist(filetypestring):
    string2ft = {'f':'file','d': 'dir','g': 'ghost'}
    return [string2ft[x] for x in filetypestring]


# Query used by matchPackageNames
# op is either '=' or 'like', q is the search term
# Check against name, nameArch, nameVerRelArch, nameVer, nameVerRel,
# envra, nevra
PARSE_QUERY = """
select pkgKey from packages
where name %(op)s '%(q)s'
   or name || '.' || arch %(op)s '%(q)s'
   or name || '-' || version %(op)s '%(q)s'
   or name || '-' || version || '-' || release %(op)s '%(q)s'
   or name || '-' || version || '-' || release || '.' || arch %(op)s '%(q)s'
   or epoch || ':' || name || '-' || version || '-' || release || '.' || arch %(op)s '%(q)s'
   or name || '-' || epoch || ':' || version || '-' || release || '.' || arch %(op)s '%(q)s'
"""

# This is roughly the same as above, and used by _buildPkgObjList().
#  Use " to quote because we using ? ... and sqlutils.QmarkToPyformat gets
# confused.
_FULL_PARSE_QUERY_BEG = """
SELECT pkgId,pkgKey,name,epoch,version,release,arch,
  name || "." || arch AS sql_nameArch,
  name || "-" || version || "-" || release || "." || arch AS sql_nameVerRelArch,
  name || "-" || version AS sql_nameVer,
  name || "-" || version || "-" || release AS sql_nameVerRel,
  epoch || ":" || name || "-" || version || "-" || release || "." || arch AS sql_envra,
  name || "-" || epoch || ":" || version || "-" || release || "." || arch AS sql_nevra
  FROM packages
  WHERE
"""
                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/dist-packages/yum/sqlitesack.pyc                                                  0100644 0000000 0000000 00000152106 13077704344 020623  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   sñ  d  d l  Z  d  d l Z  d  d l Z d  d l Z d  d l m Z m Z m Z m Z d  d l	 Z	 d  d l
 Z
 d  d l m Z m Z m Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l m Z d  d l m Z m Z d  d l Z d  d l Z d  d l Z d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d e e e f d Ñ  É  YZ  d e j! f d Ñ  É  YZ" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& d Z' d Z( d S(   iˇˇˇˇN(   t   PackageObjectt   RpmBaset   YumAvailablePackaget   parsePackages(   t
   executeSQLt   sql_esct   sql_esc_glob(   t   seq_max_split(   t   to_utf8t
   to_unicodec            s>   á  f d Ü  } à  j  | _  à  j | _ | j j à  j É | S(   s8   This decorator converts sqlite exceptions into RepoErrorc             sé   y à  |  | é  SWnv t  j j k
 râ } t j d k  rt t | d É r_ t j t | j	 É Ç qt t j t | É Ç n  t j t | É Ç n Xd  S(   Ni  t   message(
   t   sqlutilst   sqlitet   Errort   syst
   hexversiont   hasattrt   Errorst	   RepoErrort   strR
   (   t   argst   kwargst   e(   t   func(    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   newFunc,   s    (   t   __name__t   __doc__t   __dict__t   update(   R   R   (    (   R   s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   catchSqliteException*   s
    c         C   s   t  j |  É S(   N(   t   misct
   share_data(   t   value(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _share_data>   s    c         C   sb   |  | k r t  S| s t S|  rN | rN |  d d k rN |  d | d k rN t S| | É r^ t  St S(   Ni    t   ?t   *(   R"   R#   (   t   Truet   False(   t   matcht   regexp_matcht   n(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _parse_pkg_nB   s    0c   	   	   C   sé  | d } | s t  d É Ç |  | k r, t S|  rt | rt |  d d k rt |  d | d k rt |  d | d k rt t Sd | k rd | | f | d <d | | | | f | d	 <d
 | | f | d <d | | | f | d <d | | | | | f | d <d | | | | | f | d <n  t | | d | d	 | d | d | d | d g É } |  | k r_t S| sit Sx | D] } | | É rpt SqpWt S(   NR(   s   Nothing in epochi    R"   R#   t   nameArchs   %s.%ss   %s-%s-%s.%st   nameVerRelArchs   %s-%st   nameVers   %s-%s-%st
   nameVerRels   %s:%s-%s-%s.%st   envras   %s-%s:%s-%s.%st   nevra(   R"   R#   (   t   AssertionErrorR$   R%   t   set(	   R&   R'   t   dataR   t   vt   rt   aR(   t   item(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt
   _parse_pkgN   s0    
( c         C   s•  t  r	 nò|  d k r: t | | | | | | | É r°t Sng|  d k rc t | | | d É r°t Sn>|  d k rà t | | | É r°t Sn|  d k rÿ d	 | k r¡ d
 | d | | | f | d	 <n  | | d	 k r°t Sn…|  d k r1d | k rd | d | | | | f | d <n  t | | | d É r°t Snp|  d k rT| d | k r°t SnM|  d k r§d	 | k rçd
 | d | | | f | d	 <n  | d	 | k r°t Sn˝ |  d k r˜d | k r‡d | d | | | | f | d <n  | d | k r°t Sn™ |  d k r| | d k r°t Sná |  d k r=| d | k r°t Snd |  d k rZ| d r°t SnG |  d k rw| d s°t Sn* |  d k rát St  sùt d |  É Ç d  St  S(   Nt   eqR&   s   name.eqs
   name.matchR(   s   arch.eqs
   arch.matchs   nevr.eqt   nevrs   %s-%s:%s-%ss   nevra.eqs   nevra.matchR/   s   %s-%s:%s-%s.%ss   name.ins   nevr.ins   nevra.ins	   pkgtup.eqt   pkgtups	   pkgtup.int   markedt   washedR#   s   Bad excluder: (   R8   s   match(   s   name.eqs
   name.match(   s   arch.eqs
   arch.match(   s   nevra.eqs   nevra.match(   R%   R7   R$   R)   R0   t   None(   t   excluderR&   R'   R2   R   R3   R4   R5   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _excluder_matchm   sf     !$!$

t   YumAvailablePackageSqlitec           B   sß   e  Z d  Ñ  Z e d d Ñ  É Z d d Ñ Z e d Ñ  É Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 e d Ñ Z e d Ñ Z d
 d Ñ Z e d Ñ Z d Ñ  Z RS(   c         C   sÍ   i d d 6d d 6d d 6d	 d 6|  _  | j |  _ | j |  _ | |  _ d  |  _ t |  _ d  |  _	 |  j
 | É |  j d  k râ d |  _ n  |  j |  _ |  j |  _ |  j |  _ |  j |  j |  j |  j |  j f |  _ d  |  _ d  |  _ d  S(
   Nt	   obsoletest	   conflictst   requirest   providest   0(    (    (    (    (   t   prcot   sackt   idt   repoidt   repoR=   t   stateR%   t   _loadedfilest   _filest   _read_db_objt   epocht   pkgIdt   versiont   vert   releaset   relt   namet   archR:   t
   _changelogt   _hash(   t   selfRJ   t   db_obj(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   __init__≤   s&    
				'	t   fgetc         C   s
   |  j  É  S(   N(   t
   _loadFiles(   RY   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   <lambda>À   s    c         C   sÈ   | r0 y | | SWq0 t  t f k
 r, d	 SXn  xX d d d d d d g D]> } y t |  | t | | É É WqI t  t f k
 rÜ qI XqI Wy@ | d |  _ t | d É } | | d t f } | g |  _ Wn t  t f k
 r‰ n Xd	 S(
   sw   read the db obj. If asked for a specific item, return it.
           otherwise populate out into the object what existsRU   RV   RO   RQ   RS   t   pkgKeyRP   t   checksum_typeN(   t
   IndexErrort   KeyErrorR=   t   setattrR!   RP   R$   t
   _checksums(   RY   RZ   R6   R`   t	   check_sum(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyRN   Õ   s"    c         G   s=   t  |  j | d É |  j } | j É  } t | | | å | S(   s6    Exec SQL against an MD of the repo, return a cursor. t   db(   t   getattrRG   RJ   t   cursorR   (   RY   t   MDt   sqlR   t   cachet   cur(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _sql_MDÂ   s    c         C   sÿ  i d d 6d d 6d d 6d d 6d	 d
 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d  6} | j  d! É r† | j d! É r† t | Ç n  | j | | É } y) |  j d" d# | |  j f É j É  } Wn@ t j k
 r} t	 | É j  d$ É rt
 t	 | É Ç n  Ç  n X| d% } | d& k rI| d  k rId' } n  | d- k rj| d  k rjd* } n  | i	 d+ d 6d+ d 6d+ d 6d+ d 6d+ d 6d+ d( 6d+ d) 6d+ d 6d+ d, 6k rƒt | É } n  t |  | | É | S(.   Nt   size_packaget   packagesizet   size_archivet   archivesizet   size_installedt   installedsizet
   time_buildt	   buildtimet   rpm_header_startt   hdrstartt   rpm_header_endt   hdrendt   location_baset   basepatht   location_hreft   relativepatht	   time_filet   filetimet   rpm_packagert   packagert	   rpm_groupt   groupt   rpm_buildhostt	   buildhostt   rpm_sourcerpmt	   sourcerpmt
   rpm_vendort   vendort   rpm_licenset   licenseRP   t   checksum_valuet   __t   primarys'   SELECT %s FROM packages WHERE pkgId = ?s   no such columni    RO   RE   t   summaryt   descriptiont    i   t   url(   Rè   Rê   (   t
   startswitht   endswitht   AttributeErrort   getRm   RP   t   fetchoneR   R   R   Rb   R=   R!   Rc   (   RY   t   varnamet   db2simplemapt   dbnameR4   R   R    (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   __getattr__Ó   sN    

	
		c   	      C   sˇ   |  j  r |  j Si  } |  j j |  j d d É|  j d d |  j f É } xô | D]ë } | d } t | d É } t | d É } x^ | r· | rß | d | j	 É  } n | j	 É  } t
 | j	 É  É } | j | g  É j | É qÑ WqQ Wt |  _  | |  _ |  j S(   Nt   mdtypet	   filelistssj   SELECT dirname, filetypes, filenames FROM   filelist JOIN packages USING(pkgKey) WHERE  packages.pkgId = ?t   dirnamet	   filetypest	   filenamest   /(   RL   RM   RG   t   populateRJ   Rm   RP   t   decodefiletypelistt   decodefilenamelistt   popR!   t
   setdefaultt   appendR$   (	   RY   t   resultRl   t   obRû   Rü   R†   t   filenamet   filetype(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR]     s(    		
	!		c         C   s   g  } |  j  sÏ |  j |  j j k re y |  j j |  j d d ÉWqe t j k
 ra | |  _  d  SXn  |  j d d |  j f É } x\ | D]T } d | d d } t	 | d É } t	 | d É } | j
 | t | É | f É qá W| |  _  d  Sd  S(	   NRú   t	   otherdatat   otherso   SELECT date, author, changelog FROM   changelog JOIN packages USING(pkgKey) WHERE  pkgId = ? ORDER BY date DESCid   t   datet   authort	   changelog(   RW   RJ   RG   t   otherdbR¢   R   R   Rm   RP   R   Rß   R!   (   RY   R®   Rl   R©   t   c_datet   c_authort   c_log(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _loadChangelog;  s$    			 	c         C   s   |  j  |  j f S(   N(   R`   RP   (   RY   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   returnIdSumZ  s    c         C   s   |  j  É  |  j S(   N(   Rµ   RW   (   RY   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   returnChangelog]  s    
t   filec         C   sa   | rD |  j  rD d } |  j d | |  j | f É } t d Ñ  | É S|  j É  t j |  | | É S(   s}   return list of files based on type, you can pass primary_only=True
           to limit to those files in the primary repodatas=   SELECT name as fname FROM files WHERE pkgKey = ? and type = ?Ré   c         S   s   |  d S(   Nt   fname(    (   t   x(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR^   g  s    (   RL   Rm   R_   t   mapR]   R   t   returnFileEntries(   RY   t   ftypet   primary_onlyRj   Rl   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyRº   a  s    
c         C   sX   | rA |  j  rA d } |  j d | |  j f É } t d Ñ  | É S|  j É  t j |  É S(   sá   return list of types of files in the package, you can pass
           primary_only=True to limit to those files in the primary repodatas9   SELECT DISTINCT type as ftype FROM files WHERE pkgKey = ?Ré   c         S   s   |  d S(   NRΩ   (    (   R∫   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR^   r  s    (   RL   Rm   R_   Rª   R]   R   t   returnFileTypes(   RY   Ræ   Rj   Rl   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyRø   l  s    
c         C   sM   t  j d t j d d Éd } |  j d | |  j | f É } t d Ñ  | É S(   Ns_   simpleFiles() will go away in a future version of Yum.Use returnFileEntries(primary_only=True)
t
   stackleveli   s=   SELECT name as fname FROM files WHERE pkgKey = ? and type = ?Ré   c         S   s   |  d S(   NRπ   (    (   R∫   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR^   }  s    (   t   warningst   warnR   t   YumDeprecationWarningRm   R_   Rª   (   RY   RΩ   Rj   Rl   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   simpleFilesw  s
    	c         C   sÔ   t  | É } t |  j | t É r‹ d | } |  j d | |  j f É } g  |  j | <xÖ | D]z } | d sq q[ n  t  | d É t  | d É t  | d É t  | d É t  | d É f f } |  j | j t  | É É q[ Wn  t j |  | | É S(   NsD   SELECT name, version, release, epoch, flags FROM %s WHERE pkgKey = ?Ré   RU   t   flagsRO   RQ   RS   (	   R!   t
   isinstanceRF   t   tupleRm   R_   Rß   R   t
   returnPrco(   RY   t   prcotypet	   printableRj   Rl   R©   t   prco_set(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR»     s    
!c         C   sª   d } |  j  d | |  j f É } g  } xç | D]Ö } d } | d j É  d k rY d } n  t | d É t | d	 É t | d
 É t | d É t | d É f | f } | j | É q. W| S(   s%   returns requires with pre-require bitsN   SELECT name, version, release, epoch, flags,pre FROM requires WHERE pkgKey = ?Ré   RE   t   pret   TRUEi   t   1RU   R≈   RO   RQ   RS   (   RÕ   i   (   Rm   R_   t   lowerR!   Rß   (   RY   Rj   Rl   RC   R©   RÃ   RÀ   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _requires_with_preë  s    	N(   R   t
   __module__R[   t   propertyt   filesR=   RN   R   Rm   Rõ   R]   Rµ   R∂   R∑   R%   Rº   Rø   Rƒ   R»   R–   (    (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR@   ±   s   			1				t   YumSqlitePackageSackc           B   s˘  e  Z d  Z d Ñ  Z e d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 e d Ñ  É Z
 d Ñ  Z d	 d
 Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z e d Ñ Z d Ñ  Z d Ñ  Z d< d Ñ Z d d Ñ Z d< e d Ñ Z  d Ñ  Z! e d Ñ  É Z" e d Ñ  É Z# d  Ñ  Z$ e e d! Ñ É Z% e d" Ñ  É Z& e d# Ñ  É Z' e e d$ Ñ É Z( e d% Ñ  É Z) e d& Ñ  É Z* e d' Ñ  É Z+ e d( Ñ  É Z, d< d= d) Ñ Z- d< d> d* Ñ Z. e g  e d+ Ñ É Z/ e d, Ñ  É Z0 d- Ñ  Z1 d. Ñ  Z2 d/ Ñ  Z3 d0 Ñ  Z4 e d1 Ñ Z5 e d< d< e d2 Ñ É Z6 e d< d< e d3 Ñ É Z7 e d4 Ñ  É Z8 d< d< e d5 Ñ Z9 e d6 Ñ  É Z: d< d< e d7 Ñ Z; d< d< e d8 Ñ Z< d< e d9 Ñ Z= e d< d< d< d< d< d: Ñ É Z> e d; Ñ  É Z? RS(?   s~    Implementation of a PackageSack that uses sqlite cache instead of fully
    expanded metadata objects to provide information c         C   s÷   t  j j |  | É i  |  _ i  |  _ i  |  _ i  |  _ t É  |  _ t É  |  _	 i  |  _
 i i  d 6i  d 6|  _ i  |  _ i  |  _ i  |  _ t É  |  _ t É  |  _ t É  |  _ d  |  _ g  |  _ i  |  _ t |  _ d  S(   NRD   RC   (   t   yumRepot   YumPackageSackR[   t	   primarydbt   filelistsdbR±   t   excludesR1   t	   _excludest   _exclude_whitelistt   _all_excludest   _search_cachet   _key2pkgt   _pkgname2pkgkeyst   _pkgtup2pkgst   _pkgnames_loadedt   _pkgmatch_failst   _provmatch_failsR=   t   _arch_allowedt   _pkgExcludert   _pkgExcludeIdsR%   t   _pkgobjlist_dirty(   RY   t   packageClass(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR[   ¶  s*    											c         G   s7   t  |  | d É | } | j É  } t | | | å | S(   s6    Exec SQL against an MD of the repo, return a cursor. Rf   (   Rg   Rh   R   (   RY   Ri   RJ   Rj   R   Rk   Rl   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyRm   ø  s    c         C   s#   d } |  j  d | | É j É  d S(   s-    Give a count of pkgIds in the given repo DB s!   SELECT count(pkgId) FROM packagesRé   i    (   Rm   Ró   (   RY   Ri   RJ   Rj   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _sql_MD_pkg_num»  s    c            sU   t  à  d É s t Ç à  j rN t á  f d Ü  à  j É } | à  _ t à  _ n  à  j S(   s{    If the pkgobjlist is dirty (possible pkgs on it which are excluded)
            then clean it, and return the clean list. t
   pkgobjlistc            s   à  j  |  É S(   N(   t   _pkgExcluded(   R∫   (   RY   (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR^   ”  s    (   R   R0   RÁ   t   filterRÍ   R%   (   RY   t   pol(    (   RY   s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _clean_pkgobjlistÕ  s    		c         C   s—   t  } x6 |  j j É  D]% \ } } | |  j k r t } Pq q W| rI d St |  d É rh t |  j É  É Sd } x( |  j D] } | t |  j | É 7} qx Wd } x' |  j D] } | |  j	 d | É 7} q© W| | S(   Ni    RÍ   Ré   (
   R$   R◊   t   itemsR‹   R%   R   t   lenRÓ   RŸ   RÈ   (   RY   t   all_excludedRJ   Rk   t   exclude_numt   pkg_num(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   __len__Ÿ  s     c         C   sµ   t  |  d É r |  ` n  t  |  d É r0 |  ` n  t  |  d É rH |  ` n  t |  _ i  |  _ i  |  _ t É  |  _	 t É  |  _
 t É  |  _ i  |  _ i i  d 6i  d 6|  _ t j É  d  S(   Nt   _memoize_requirest   _memoize_providesRÍ   RD   RC   (   R   Rı   Rˆ   RÍ   R%   RÁ   Rﬁ   Rﬂ   R1   R·   R‚   R„   R‡   R›   R   t   unshare_data(   RY   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   dropCachedDataÓ  s"    							c         C   sº   |  j  É  x; |  j j É  |  j j É  |  j j É  D] } | j É  q4 Wi  |  _ i  |  _ i  |  _ i  |  _ t É  |  _ t É  |  _	 i  |  _
 g  |  _ i  |  _ t |  _ t j j |  É d  S(   N(   R¯   R◊   t   valuesRÿ   R±   t   closeRŸ   R1   R⁄   R€   R‹   RÂ   RÊ   R%   RÁ   R’   R÷   (   RY   t   dataobj(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR˙     s     
								c         C   s   d  S(   N(    (   RY   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   buildIndexes  s    t   errorc         C   s   d  S(   N(    (   RY   t   failure(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _checkIndexes  s    c            så   |  j  j | | f É | |  j k rà |  j | j | d É â  à  d k	 rà |  j à  j } t á  f d Ü  | É } | |  j à  j <qà n  d S(   st    Exclude a package so that _pkgExcluded*() knows it's gone.
            Note that this doesn't update self.exclude. c            s   t  |  É t  à  É k S(   N(   RH   (   R∫   (   t   po(    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR^   (  s    N(   R⁄   t   addRﬁ   R•   R=   R‡   R:   RÏ   (   RY   RJ   R_   t   pos(    (   R   s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _delPackageRK  s    c         C   sô   | j  |  j k r% i  |  j | j  <n  d |  j | j  | j <| j  | j f |  j k rv |  j j | j  | j f É n  |  j | j  | j É t |  _ d  S(   Ni   (	   RJ   RŸ   RP   R_   R€   t   discardR  R$   RÁ   (   RY   t   obj(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt
   delPackage.  s    c         C   se   t  |  j | <| |  j k r) |  j | =n  | |  j k rE |  j | =n  | |  j k ra |  j | =n  d S(   s%    Exclude all packages from the repo. N(   R$   R‹   RŸ   Rﬁ   Rﬂ   (   RY   RJ   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _delAllPackages7  s    c         C   s=   | |  j  k r t S| |  j k r9 | |  j | k r9 t St S(   N(   R‹   R$   RŸ   R%   (   RY   RJ   RP   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt	   _excludedA  s
    "c         C   s8   |  j  r | |  j  k r t S|  j o7 | | f |  j k S(   N(   R‹   R$   R⁄   (   RY   RJ   R_   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _pkgKeyExcludedJ  s    c      
   C   s©  |  j  r" | | f |  j  k r" t S|  j | | É r8 t S|  j d k	 rj | |  j k rj |  j | | É t S|  j sw t Si | j É  d 6| | | | | f d 6t d 6} | j É  } | j É  } | j É  } | j É  } xµ|  j D]™\ }	 }
 } } |	 d k	 r|	 | j	 k rq· n  |
 j
 d d É } t | É d k rTt s· t d |
 É Ç q· n  | \ } } t riq· | d k r≠t | | | | | | | | É rã|  j | | É t Sq· | d	 k r·t | | | | | | | | É rãPqãq· | d
 k r+| d r˙qãt | | | | | | | | É rãt | d <qãq· | d k ru| d sDqãt | | | | | | | | É rãt | d <qãq· t s· t d |
 É Ç q· W|  j  j | | f É t S(   s   Main function to use for "can we use this package" question.
                . Tests repo against allowed repos.
                . Tests pkgKey against allowed packages.
                . Tests arch against allowed arches.
                . Tests addPackageExcluder() calls.
        R(   R:   R;   t   .i   i   s   Bad excluder: t   excludet   includet   markt   washN(   R€   R%   R	  R$   R‰   R=   R  RÂ   Rœ   RH   t   splitR   R0   R?   R  (   RY   RJ   R_   R(   R   R3   R4   R5   R2   RI   R>   R&   R'   t   exSPLITt   exTt   exM(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _pkgExcludedRKNEVRAP  sX    	0 !!
!
!c   	      C   s4   | \ } } } } } |  j  | | | | | | | É S(   sb    Helper function to call _pkgExcludedRKNEVRA.
            Takes a repo, pkgKey and a package tuple(   R  (	   RY   RJ   R_   R:   R(   R5   R   R3   R4   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _pkgExcludedRKTë  s    c   	      C   sW   | d | d | d | d | d f \ } } } } } |  j  | | | | | | | É S(   si    Helper function to call _pkgExcludedRKNEVRA.
            Takes a repo, pkgKey and a dict of package dataRU   RV   RO   RQ   RS   (   R  (	   RY   RJ   R_   R2   R(   R5   R   R3   R4   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _pkgExcludedRKDó  s    *c         C   s   |  j  | j | j | j É S(   sR    Helper function to call _pkgExcludedRKNEVRA.
            Takes a package object. (   R  RJ   R_   R:   (   RY   R   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyRÎ   û  s    c         G   s·  | d k	 r | |  j k r d Sd } d } t r4 nS| j d É rn t | É d k s[ t Ç | d j É  } n| j d É r¢ t | É d k sï t Ç | d } nÂ | j d É r	t | É d k s… t Ç | d j É  } t j | É rát	 j
 t j | É É j } qán~ | j d É r3t | É d k sát Ç nT | j d É r]t | É d k sát Ç n* | j d	 É rát | É d k sát Ç n  |  j j | | | | f É | d k	 r»t |  j É |  j | <n  t É  |  _ t |  _ d S(
   s‚   Add an "excluder" for all packages in the repo/sack. Can basically
            do anything based on nevra, changes lots of exclude decisions from
            "preload package; test; delPackage" into "load excluder".
            Excluderid is used so the caller doesn't have to track
            "have I loaded the excluder for this repo.", it's probably only
            useful when repoid is None ... if it turns out utterly worthless
            then it's still not a huge wart. Ns   .eqi   i    s   .ins   .matchs   .*s   .markeds   .washed(   R=   RÊ   R%   Rî   R   R0   Rœ   R   t   re_globt   ret   compilet   fnmatcht	   translateR&   RÂ   Rß   R1   R€   R$   RÁ   (   RY   RI   t
   excluderidR>   R   R&   R'   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   addPackageExcluder£  s8     !c   	      C   sä  | s t  Ç | r( |  j | | É r( d S| |  j k rT i  |  j | <i  |  j | <n  | |  j | k rGd } |  j d | | | f É j É  } | d k rπ d | | f } t j | Ç n  | rÿ |  j	 | | | É rÿ d S|  j
 | | É } | |  j | | <|  j j | j g  É j | É |  j | j | d g  É } | j | É n4 | r{|  j |  j | | É r{|  j | | É d S|  j | | S(   s:    Lookup a pkg by it's pkgKey, if we don't have it load it sX   SELECT pkgKey, pkgId, name, epoch, version, release, arch FROM packages WHERE pkgKey = ?Ré   s"   pkgKey %s doesn't exist in repo %sRU   N(   R0   R	  R=   Rﬁ   Rﬂ   Rm   Ró   R   R   R  t   pcR‡   R¶   R:   Rß   RÎ   R  (	   RY   RJ   R_   R  Rj   R2   t   msgR   t   pkgkeys(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _packageByKeyÃ  s.    ! c         C   s¯   | s t  Ç | r+ |  j | | | É r+ d S| |  j k rW i  |  j | <i  |  j | <n  | d |  j j | i  É k rÂ |  j | | É } | |  j | | <|  j j | j	 g  É j
 | É |  j | j | d g  É } | j
 | É n  |  j | | d S(   s=    Like _packageByKey() but we already have the data for .pc() R_   RU   N(   R0   R  R=   Rﬁ   Rﬂ   Rñ   R  R‡   R¶   R:   Rß   (   RY   RJ   R_   R2   R  R   R  (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _packageByKeyDataÈ  s    c         C   sö   |  j  | | | É r d S|  j j | É } | d k rT i  |  j | <i  |  j | <n | d | k rs | | d j S| d | d | d | d | d f S(   sb    Like _packageByKeyData() but we don't create the package, we just
            return the pkgtup. R_   RU   RV   RO   RQ   RS   N(   R  R=   Rﬁ   Rñ   Rﬂ   R:   (   RY   RJ   R_   R2   t   prepo(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _pkgtupByKeyData˘  s    c         C   sç   g  } xÄ |  j  D]u } |  j j | i  É j | g  É } | sC q n  x? | D]7 } |  j | | É } | d k rt qJ n  | j | É qJ Wq W| S(   s2    Load all pkgnames from cache, with a given name. N(   R◊   Rﬂ   Rñ   R   R=   Rß   (   RY   t   pkgnamet   retRJ   R  t   pkgkeyt   pkg(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _packagesByName  s    !c         C   s¸   | |  j  k r) | |  j  | k r6 d  Sn g  |  j  | <| |  j k rU i  |  j | <n  | d  k rz t j d | | f Ç n  | d k rñ | |  j | <nN | d k r≤ | |  j | <n2 | d k rŒ | |  j | <n t j d | | f Ç |  j  | j | É d  S(   Ns   Tried to add None %s to %st   metadataRù   R¨   s&   Sorry sqlite does not support %s in %s(	   t   addedRŸ   R=   R   R   R◊   Rÿ   R±   Rß   (   RY   RJ   t   datatypeR˚   t   callback(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   addDict  s     t   likec         C   s   |  j  | d É S(   NRD   (   t
   searchPrco(   RY   RU   t
   query_type(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt	   searchAll3  s    c         C   sÅ   | d k r g  } n  xe | D]] } | rD |  j | | d | É } n |  j | | d É } | d k rl q n  | j | É q W| S(   sB    Takes a cursor and maps the pkgKey rows into a list of packages. R_   N(   R=   R!  R   Rß   (   RY   RJ   Rl   t   pkgst	   have_dataR©   R'  (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _sql_pkgKey2po7  s     	c         C   s7   t  } x* |  j D] } | |  j k r t } Pq q W| S(   s6    Are we going to skip every package in all our repos? (   R$   R*  R‹   R%   (   RY   t   skip_allRJ   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt	   _skip_allD  s    c         C   sÆ   d } t  j j | É } t j | É s0 d } n  g  } xh |  j j É  D]W \ } } | |  j k rg qF n  | j É  } t	 | d | | f É |  j
 | | | É qF Wt j | É S(   Nt   globt   =s1   select DISTINCT pkgKey from files where name %s ?(   t   ost   patht   normpathR   R  R◊   RÔ   R‹   Rh   R   R4  t   unique(   RY   RU   t	   querytypet   resultst   repRk   Rl   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _search_primary_filesM  s    	c         C   sh   xa |  j  j É  D]P \ } } | |  j k r1 q n  | j É  } t | d É x | D] } PqQ Wt Sq Wt S(   sè    Return true if pkg.returnFileEntries(primary_only=True) is fast.
            basically does "CREATE INDEX pkgfiles ON files (pkgKey);" exist. s   PRAGMA index_info(pkgfiles)(   R◊   RÔ   R‹   Rh   R   R%   R$   (   RY   R?  Rk   Rl   R©   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _have_fastReturnFileEntries^  s    c         C   s(   t  |  d É s! |  j É  |  _ n  |  j S(   sb    Is calling pkg.returnFileEntries(primary_only=True) faster than
            using searchFiles(). t   _cached_fRFE(   R   RA  RB  (   RY   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   have_fastReturnFileEntriesq  s    c            s‡  |  j  É  r g  St } t â  d } t j j | É } t j j | É } t j j | É â | sn t j | É rÉ t	 } t	 â  d } n t j à É sõ t	 â  n  | d d k r∏ | d  } n  g  } t j
 | É rÏ t j | É sÏ |  j | É Sn  t |  j É d k rLxH |  j j É  D]4 \ } } | |  j k r2qn  |  j | d d ÉqWn  xk |  j D]` } t | d É rqqVn  |  j d	 | É }	 |  j d | É }
 |	 |
 k r≠t j Ç n  t | _ qVWg  } d
 } | st à É \ } } d | } | j | É | j d | d É nÿ à  sTt à É \ } } d | } | j | É | j d | d É në à d k rÂxu |  j j É  D]d \ } } | |  j k rëqpn  | j É  } | j | É t | d | f | É |  j | | | É qpWt j | É SxÂ |  j j É  D]‘ \ } } | |  j k rqın  | j É  } t | d | | f | d | g É |  j | | | É à  rzt j t j  | É É â n  á  á á f d Ü  } | j! d d | É t | d | | É |  j | | | É qıWt j | É } | S(   sY   search primary if file will be in there, if not, search filelists, use globs, if possibleR7  R8  iˇˇˇˇR°   i    Rú   Rù   t   _checked_filelists_pkgsRé   Rë   s(   dirname = ? and filenames LIKE ? %s and t   %s+   dirname GLOB ? and filenames LIKE ? %s and R#   sQ   SELECT pkgKey FROM filelist
                                   WHERE dirname %s ?sô   select pkgKey from filelist where                     %s length(filetypes) = 1 and                     dirname || ? || filenames                     %s ?c            se   | j  d É } à s% t à | k É St á  f d Ü  | É } x! | D] } à j | É rD d SqD Wd S(   NR°   c            s   d à  |  f S(   Ns   %s/%s(    (   t   f(   t   sql_dirname(    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR^   ‰  s    i   i    (   R  t   intRª   R&   (   RG  t   sql_filenamesR”   t   fnsR&   (   t	   file_globR™   t   name_re(   RG  s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   filelist_globber€  s    RM  i   sú   select pkgKey from filelist where                              %s length(filetypes) > 1                              and filelist_globber(dirname,filenames)("   R6  R$   R9  R:  R;  Rû   t   basenameR   R  R%   t   re_primary_filenameR@  R   Rÿ   R◊   RÔ   R‹   R¢   R   RÈ   R   R   RD  R   Rß   Rh   R   R4  R<  R  R  R  R  t   create_function(   RY   RU   t   strictR7  R=  Rû   R2  RJ   Rk   t   pri_pkgst   fil_pkgst
   sql_paramst   dirname_checkt   patternt   escR?  Rl   RM  (    (   RK  R™   RL  s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   searchFilesx  sí    		


c   
      C   s‚   |  j  É  r g  Sg  } t | É d k  r, | S| j d d É } t | É \ } } d | d | | f } x( | d D] } d | | | | f } qr WxI |  j j É  D]8 \ } } | j É  }	 t |	 | É |  j | |	 | É q¢ W| S(   s7   search arbitrary fields from the primarydb for a stringi   t   's   ''s>   select DISTINCT pkgKey from packages where %s like '%%%s%%'%s i    s   %s or %s like '%%%s%%'%s (	   R6  R   t   replaceR   R◊   RÔ   Rh   R   R4  (
   RY   t   fieldst   searchstringR®   RW  Rj   RF  R?  Rk   Rl   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   searchPrimaryFields˜  s    c         C   s  |  j  É  r g  Sg  } | s$ | r( | St | É t j t | É k r‹ i  } xK | D]C } |  j | | É } x( | D]  } | j | d É d | | <qs WqT Wx: t | d t j d t	 ÉD] } | j
 | | | f É q∑ W| Sd } d }	 g  }
 xÅ | D]y } | j d d É } t | É \ } } d	 | d | | f } x( | d D] } d
 | | | | f } qAW|
 j
 | É qı W| d j |
 É |	 } xÜ |  j j É  D]u \ } } | j É  } t | | É xM | D]E } |  j | | d É } | d k rÛq≈n  | j
 | | d f É q≈WqôW| S(   så   search arbitrary fields from the primarydb for a multiple strings
           return packages, number of items it matched as a list of tuplesi    i   t   keyt   reverses*   select pkgKey, SUM(cumul) AS total from ( s$   )GROUP BY pkgKey ORDER BY total DESCRY  s   ''s@   select pkgKey,1 AS cumul from packages where %s like '%%%s%%'%s s   %s or %s like '%%%s%%'%s s    UNION ALL R_   t   totalN(   R6  R   t	   constantst   PATTERNS_MAXR]  Rñ   t   sortedt   operatort
   itemgetterR$   Rß   RZ  R   t   joinR◊   RÔ   Rh   R   R   R=   (   RY   R[  t   searchstringsR®   t   totR\  t   matchesR   t   unionstringt   endunionstringt   selectst   sRW  Rj   RF  t   totalstringR?  Rk   Rl   R©   R'  (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt"   searchPrimaryFieldsMultipleStrings  sD    ""c      	   C   su  |  j  É  r i  S| r" t É  Ç n  i  } xF|  j j É  D]5\ } } | j É  } t | d É x| D]} t | d É t | d É t | d É t | d É t | d É f } |  j | | d | É r– qd n  t | d É t | d	 É t | d
 É t | d É t | d É f \ } }	 }
 } } t | É } t | |	 |
 | | f f É } | j | g  É j	 | É qd Wq8 W| S(   Nsÿ  select packages.name as name,                packages.pkgKey as pkgKey,                packages.arch as arch, packages.epoch as epoch,                packages.release as release, packages.version as version,                obsoletes.name as oname, obsoletes.epoch as oepoch,                obsoletes.release as orelease, obsoletes.version as oversion,                obsoletes.flags as oflags                from obsoletes,packages where obsoletes.pkgKey = packages.pkgKeyRU   RV   RO   RQ   RS   R_   t   onamet   oflagst   oepocht   oversiont   orelease(
   R6  t   NotImplementedErrorR◊   RÔ   Rh   R   R!   R  R¶   Rß   (   RY   t   newestRA   R?  Rk   Rl   R©   R^  R(   RF  R   R3   R4   t   val(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   returnObsoletesB  s0    "!c         C   sU   xN |  j  j É  D]= \ } } | j É  } t | d | f É x | D] } | SWq Wd  S(   Ns&   select * from packages where pkgId = ?(   R◊   RÔ   Rh   R   (   RY   RP   R?  Rk   Rl   R©   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   getPackageDetailsh  s
    c         C   sê   g  } t  | É d k r | St t | É É } x[ |  j j É  D]J \ } } | j É  } t | d | f É x | D] } | j | É qq Wq> W| S(   Ni    s(   select * from packages where pkgId in %s(   R   R   R«   R◊   RÔ   Rh   R   Rß   (   RY   t
   pkgId_listR2  t   pkgid_queryR?  Rk   Rl   R©   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _getListofPackageDetailsp  s    c   
   	   C   s?  t  |  d | É s.i  } x˚ |  j j É  D]Í \ } } | |  j k rJ q) n  | j É  } t | d | É x© | D]° } t | d É t | d É t | d É t | d É t | d É f f } t | É } | | d f } t | d	 É }	 |	 | f } | j | g  É j | É qn Wq) Wt	 |  d | | É n  t
 |  d | É S(
   Nt	   _memoize_s   select * from %sRU   R≈   RO   RQ   RS   i    R_   (   R   R◊   RÔ   R‹   Rh   R   R!   R¶   Rß   Rc   Rg   (
   RY   R…   t   memoizeR?  Rk   Rl   R∫   Rw  R^  R&  (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _search_get_memoize  s$    !c      	   C   s  |  j  É  r i  St | É } | d k r1 d  } n  t | É t t d  É t f k rp | | t j j | É f } n* t | É t	 t
 f k rö | | | f } n  t | É } t | É } | |  j | k r‘ |  j | | Si  } t r¯ |  j j É  } t } ng  } t } |  j | É }	 x„ |  j j É  D]“ \ }
 } |
 |  j k rDq#n  i  } x] |	 j |
 | f g  É D]C } | \ } } t j j | | É rc| j | g  É j | É qcqcWxH | j É  D]: \ } } |  j |
 | É } | d  k rÁq∑n  | | | <q∑Wq#Wx9| D]1\ }
 } |
 |  j k r!q n  | j É  } t | d | | f É i  } xô | D]ë } t | d É t | d É t | d É t | d É t | d É f f } t | É } t j j | | É rQ| j | d g  É j | É qQqQWxH | j É  D]: \ } } |  j |
 | É } | d  k r#qÛn  | | | <qÛWq W| d	 k sQ| d d
 k ro| sk| |  j | | <n  | St j | É s“x3 |  j | d t ÉD] } | d  d  f g | | <qîW| sŒ| |  j | | <n  | Sx> |  j | É D]- } | d  d  f g | | <| |  j | | <q‚W| S(   Ni    s   select * from %s where name=?RU   R≈   RO   RQ   RS   R_   RD   R°   RQ  (   R6  R	   R=   t   typeR   t   unicodet   rpmUtilst	   miscutilst   stringToVersionR«   t   listR!   R›   R$   R◊   RÔ   R%   R  R‹   Rñ   t   rangeCompareR¶   Rß   t	   iteritemsR   Rh   R   R   RO  RX  R@  (   RY   R…   RU   R≈   RQ   t   reqR®   t   primarydb_itemst   preloadR~  R?  Rk   t   tmpR∫   R&  Rw  R_   t   hitsR'  Rl   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _searchñ  sÜ    	!	 
$c         C   s   |  j  d | | | É S(   NRD   (   Rç  (   RY   RU   R≈   RQ   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   getProvidesÒ  s    c         C   s   |  j  d | | | É S(   NRC   (   Rç  (   RY   RU   R≈   RQ   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   getRequiresÙ  s    c         C   s0  |  j  É  r g  St |  d É } g  } t | É } g  } x^ | D]V } | |  j k rY q> n  | sn | |  j k rá | j |  j | É É q> | j | É q> W| rΩ g  | D] } | j ^ q• } n  | s« | St	 j
 } t | É | k rx0 t | | É D] } | j |  j | | É É qÚ W| Sg  }	 d }
 x | D] } |	 j d É q,W|
 d j |	 É }
 xß |  j j É  D]ñ \ } } | j É  } t | |
 | É | r„xF | D]> } |  j | | d | É } | d k rÃqõn  | j | É qõWqfn  |  j | | | d t ÉqfW| s,|  j j g  | D] } | ^ qÉ n  | S(   sy   return a list of packages matching any of the given names. This is 
           only a match on package name, nothing elseRÍ   s^   select pkgId,pkgKey,name,epoch,version,release,arch
                      from packages where s   name = ?s    OR R_   R3  N(   R6  R   R1   R‚   R·   t   extendR(  Rß   R:   Ra  t   PATTERNS_INDEXED_MAXR   R   t   searchNamesRf  R◊   RÔ   Rh   R   R#  R=   R4  R$   R   (   RY   t   namest   return_pkgtupst   loaded_all_namest
   returnListt
   user_namesR$  R'  t   max_entriest   pat_sqlst   qsqlRU   RJ   Rk   Rl   R©   R:   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyRí  ˜  sP    	&c         C   s  |  j  É  r g  Sy% t j | É \ } } \ } } } Wn( t j k
 r_ } t j t | É Ç n X| } t | É }	 |	 } t }
 d } t j | É s¢ t	 }
 d } n  g  } g  } xY |  j
 j É  D]H \ } } | j É  } t | d | | f | f É |  j | | | É qæ WxÜ | D]~ } t j | É rE| d k rE| j | É qn  |
 sÇ| j | | | | | | f f É rè| j | É qèq| j | É qW| d k r£| St j | É s∂| S| j |  j | É É t j | É rÔ|
 rÔt j | É S| j |  j | É É t j | É S(   s3   return list of packages matching name and prcotype R7  R8  s.   select DISTINCT pkgKey from %s where name %s ?RD   N(   R6  R   t   string_to_prco_tupleR   t	   MiscErrort   PackageSackErrorR	   R$   R  R%   R◊   RÔ   Rh   R   R4  t   re_filenameR=   Rß   t	   checkPrcoRê  R@  RO  R<  RX  (   RY   RU   R…   R(   RF  R   R3   R4   t   n_bt   n_uR7  R=  t   basic_resultsR>  R?  Rk   Rl   R   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR/  3  sJ    %	$c         C   sB   | |  j  k r g  S|  j | d É } | s> |  j  j | É n  | S(   s9   return list of packages providing name (any evr and flag)RD   (   R„   R/  R  (   RY   RU   R%  (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   searchProvidest  s    c         C   s   |  j  | d É S(   s9   return list of packages requiring name (any evr and flag)RC   (   R/  (   RY   RU   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   searchRequires}  s    c         C   s   |  j  | d É S(   s:   return list of packages obsoleting name (any evr and flag)RA   (   R/  (   RY   RU   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   searchObsoletesÅ  s    c         C   s   |  j  | d É S(   s@   return list of packages conflicting with name (any evr and flag)RB   (   R/  (   RY   RU   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   searchConflictsÖ  s    c         C   së  d GHd d1 d Ñ  É  Y} | É  } | d | d | d | d | d f | _  |  | _ | d	 | _ | rm | Si | d
 d 6| d d 6| _ i | d d 6d d 6| d d 6| _ i d d 6| d d 6| d	 d 6| _ i | d d 6| d d 6| _ i | d d 6| d d 6| d  d! 6| _ i	 | d" d" 6| d# d# 6| d$ d% 6| d& d' 6| d( d) 6| d* d+ 6| d, d, 6| d- d. 6| d/ d0 6| _ | S(2   Ns   die die die die die db2classt	   tmpObjectc           B   s   e  Z RS(    (   R   R—   (    (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyRß  å  s   RU   RO   RQ   RS   RV   RP   Rv   t   startRx   t   endR|   t   hrefRë   R    Rz   t   baset   YESt   pkgidR`   RÄ  Rt   t   buildR~   R∏   Rn   t   packageRp   t   archiveRr   t	   installedRè   Rê   RÄ   RÅ   RÇ   RÉ   RÑ   RÖ   RÜ   Rá   Rí   Rà   Râ   Rä   Rã   (    (	   R/   RG   RP   t   hdranget   locationt   checksumt   timet   sizet   info(   RY   Rf   t
   nevra_onlyRß  t   y(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   db2classä  s&    	,	&*'c         C   s†   | s t  j j |  | | | É Sg  } xR |  j j É  D]A \ } } | j É  } t | d | É |  j | | | d t Éq5 W| sì t	 j
 d | Ç n  t j | É S(   NsY   select pkgId,pkgKey,name,epoch,version,release,arch from packages where name=? and arch=?R3  s   No Package Matching %s.%s(   R’   R÷   t   returnNewestByNameArchR◊   RÔ   Rh   R   R4  R$   R   Rù  R   t   newestInList(   RY   t   naTupt   patternst   ignore_caset   allpkgR?  Rk   Rl   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyRª  ¢  s    c         C   s≥   |  j  É  r g  S| s/ t j j |  | | | É Sg  } xU |  j j É  D]D \ } } | j É  } t | d | f É |  j | | | d t	 ÉqE W| s¶ t
 j d | Ç n  t j | É S(   sB  return list of newest packages based on name matching
           this means(in name.arch form): foo.i386 and foo.noarch will
           be compared to each other for highest version.
           Note that given: foo-1.i386; foo-2.i386 and foo-3.x86_64
           The last _two_ pkgs will be returned, not just one of them. sN   select pkgId,pkgKey,name,epoch,version,release,arch from packages where name=?R3  s   No Package Matching %s(   R6  R’   R÷   t   returnNewestByNameR◊   RÔ   Rh   R   R4  R$   R   Rù  R   Rº  (   RY   RU   Ræ  Rø  R¿  R?  Rk   Rl   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR¡  ∏  s    	c         C   s>  |  j  É  r g  g  g  f Sg  } g  } t | É } x– | D]» } t j | É rn t i d d 6| d 6} | } n t i d d 6| d 6} | } xq |  j j É  D]` \ } }	 |	 j É  }
 t |
 | É |  j	 | |
 É } t
 | É rÔ | j | É n  | j | É qú Wq8 Wt j | É } t j | É } t j | É } | | | f S(   NR7  t   opt   qR8  (   R6  RÖ  R   R  t   PARSE_QUERYR◊   RÔ   Rh   R   R4  R   t   removeRê  R<  (   RY   t   pkgspecst   matchedt
   exactmatcht	   unmatchedt   pt   queryt   matchresR?  Rf   Rl   t   pmatches(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   matchPackageNames÷  s,    	c   
      C   s^  | d
 k r g  } n  d d d d d d d g } t } x< | D]4 } t j | É r= | sg | |  j k r= t } Pq= q= Wt j } | sô d g } t j } n  t	 | É | k r¥ g  } n  | r… t
 | É } nÖ g  } t }	 xL | D]D } t j | É r| j | d f É t }	 q‹ | j | d	 f É q‹ W| rH|	 rH| rH| | | t f S| } | | | t f S(   sz   Setup need_full and patterns for _yieldSQLDataList, also see if
           we can get away with just using searchNames(). RU   t   sql_nameArcht   sql_nameVerRelArcht   sql_nameVert   sql_nameVerRelt	   sql_envrat	   sql_nevraR7  R8  N(   R=   R%   R   t   re_full_search_neededR·   R$   Ra  Rb  Rë  R   R   R  Rß   (
   RY   RI   Ræ  Rø  R[  t	   need_fullt   patt   pat_maxRã  t	   need_glob(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _setupPkgObjListÙ  s<    						c         c   sA  g  } g  } xÖ | D]} \ } } | r; | |  j  k r; q n  xR | D]J }	 | rh | j d |	 | f É n | j d |	 | f É | j | É qB Wq W| r• | r• d S| r¡ t d j | É }
 n d }
 xs |  j j É  D]b \ } } | d k s˛ | | j k r◊ | j É  } t	 | |
 | É x | D] } | | f Vq!Wq◊ q◊ Wd S(   s^   Yields all the package data for the given params. Excludes are done
           at this stage. s   %s LIKE ?%ss   %s %s ?Ns    OR sY   select pkgId, pkgKey, name,epoch,version,release,arch
                      from packages(
   R‚   Rß   t   _FULL_PARSE_QUERY_BEGRf  R◊   RÔ   R=   RH   Rh   R   (   RY   RI   Ræ  R[  Rø  Rô  t   pat_dataRV  t   restt   fieldRö  RJ   Rk   Rl   R∫   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _yieldSQLDataList  s*    c         C   s•  g  } |  j  | | | É } | \ } } } } | r@ |  j | É Sx^ |  j | | | | É D]D \ }	 }
 |  j |	 |
 d |
 É } | d k rê qY n  | j | É qY W| rÃ | d k rÃ | |  _ t É  |  _ n  | r| d k r|  j j	 g  | D] } | j
 ^ qÔ É n  | rqx` | D]U \ } } | d k r3qn  x4 | D], } | j
 | k r:|  j j | j
 É Pq:q:WqWn  | s°x' | D] \ } } |  j j | É q~Wn  | S(   sj   Builds a list of packages, only containing nevra information.
           Excludes are done at this stage. R_   R8  Rë   N(   R8  Rë   (   R⁄  Rí  Rﬂ  R!  R=   Rß   RÍ   R1   R·   R   RU   R  R‚   (   RY   RI   Ræ  Rø  Rñ  R2   R÷  R[  Rì  RJ   R∫   R   R◊  R›  R'  (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   _buildPkgObjList<  s8    	)c         C   sı   |  j  É  r g  St |  d É } | r4 |  j É  } n$ |  j | | | É } t |  d É } | rò | rò t } t | | | d d É} | d | d } n  | d k r∏ | r¥ | } n  | Sg  } x0 | D]( } | | j k r‡ q≈ n  | j | É q≈ W| S(   sŒ   Returns a list of packages, only containing nevra information. The
           packages are processed for excludes. Note that the packages are
           always filtered to those matching the patterns/case. RÍ   R<  s   repo-pkgkeyi    i   N(	   R6  R   RÓ   R‡  R%   R   R=   RI   Rß   (   RY   RI   Ræ  Rø  t   internal_pkgoblistRÍ   Rñ  R   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   returnPackagesb  s,    	
c         C   s¸   |  j  É  r g  St |  d É } | r; t j j |  | | É Sd } g  } |  j | | | É } | \ } } } }	 |	 ró g  |  j | É D] }
 |
 j ^ qÑ Sx^ |  j	 | | | | É D]D \ } } |  j
 | | d | É } | d k rÁ q∞ n  | j | É q∞ W| S(   sµ   Returns a list of pkg tuples (n, a, e, v, r), optionally from a
           single repoid. Note that the packages are always filtered to those
           matching the patterns/case. RÍ   R_   N(   R6  R   R’   R÷   t   simplePkgListR=   R⁄  Rí  R:   Rﬂ  R#  Rß   (   RY   Ræ  Rø  R·  RI   Rñ  R2   R÷  R[  Rì  R'  RJ   R∫   R:   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR„  Ö  s&    #c         C   sﬂ  |  j  É  r g  Sg  } | rº xô |  j d | g É D]Ç } t } x] d | f d | f d | f d | f g D]1 \ }	 }
 |
 ri t | |	 É |
 k ri t } Pqi qi W| r2 | j | É q2 q2 W| St } x, | | | | | f D] } | rÿ t } qÿ qÿ W| r˚ | Sd } xÖ d | f d | f d | f d | f d | f g D]P \ }	 }
 |
 r5| d d	 k rn| d
 |	 |
 f } qÖ| d |	 |
 f } q5q5WxO |  j j É  D]> \ } } | j É  } t	 | | É |  j
 | | | d t ÉqôW| S(   s6   return list of pkgobjects matching the nevra requestedRì  RO   RQ   RV   RS   sG   select pkgId,pkgKey,name,epoch,version,release,arch from packages WHERERU   i˚ˇˇˇt   WHEREs    AND %s = "%s"s
    %s = "%s"R3  (   R6  Rí  R$   Rg   R%   Rß   R◊   RÔ   Rh   R   R4  (   RY   RU   RO   RR   RT   RV   Rñ  R'  R&   t   colt   vart   emptyt   argR√  R?  Rk   Rl   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   searchNevra£  s@    ""c   	      C   s  |  j  d k r! t | É |  _  n |  j  j | É |  _  t d Ñ  | É } d j | É } x¶ |  j j É  D]ï \ } } | j É  } | j	 j
 d É sg d |  j  k rß qg n  t } t | d É x( | D]  } | d | k r¡ t } Pq¡ q¡ W| sg |  j | É d Sqg Wd S(   sB   excludes incompatible arches - archlist is a list of compat archesc         S   s   d |  S(   Ns   '%s'(    (   R∫   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR^   ÿ  s    t   ,s   -sourcet   srcs"   SELECT DISTINCT arch FROM packagesi    N(   R‰   R=   R1   t   intersectionRª   Rf  R◊   RÔ   Rh   RH   Rî   R%   R   R$   R  (	   RY   t   archlistt	   sarchlistt
   arch_queryR?  Rk   Rl   t   has_archt   row(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   excludeArchs–  s$    "N(   NNN(   NNN(@   R   R—   R   R[   R   Rm   RÈ   RÓ   RÙ   R¯   R˙   R¸   Rˇ   R  R  R  R  R	  R  R  R  RÎ   R  R$   R   R!  R#  R(  R=   R-  R1  R%   R4  R6  R@  RA  RC  RX  R]  Ro  Rx  Ry  R|  R  Rç  Ré  Rè  Rí  R/  R£  R§  R•  R¶  R∫  Rª  R¡  RŒ  R⁄  Rﬂ  R‡  R‚  R„  RÈ  RÚ  (    (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR‘   ¢  sÄ   											
				A				)					~4%[;A					'!&#,c         C   s   d j  |  É S(   NR°   (   Rf  (   t   filenamelist(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   encodefilenamelist  s    c         C   s   |  j  d d É }  |  j d É S(   Ns   //R°   (   RZ  R  (   t   filenamestring(    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR§   Ù  s    c         C   sD   d } i d d 6d d 6d d 6} x |  D] } | | | 7} q( W| S(   NRë   RF  R∏   t   dt   dirt   gt   ghost(    (   t   filetypelistR®   t	   ft2stringR∫   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   encodefiletypelist˙  s
    c         C   s6   i d d 6d d 6d d 6} g  |  D] } | | ^ q" S(   NR∏   RF  R˜  Rˆ  R˘  R¯  (    (   t   filetypestringt	   string2ftR∫   (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyR£     s    s—  
select pkgKey from packages
where name %(op)s '%(q)s'
   or name || '.' || arch %(op)s '%(q)s'
   or name || '-' || version %(op)s '%(q)s'
   or name || '-' || version || '-' || release %(op)s '%(q)s'
   or name || '-' || version || '-' || release || '.' || arch %(op)s '%(q)s'
   or epoch || ':' || name || '-' || version || '-' || release || '.' || arch %(op)s '%(q)s'
   or name || '-' || epoch || ':' || version || '-' || release || '.' || arch %(op)s '%(q)s'
s‹  
SELECT pkgId,pkgKey,name,epoch,version,release,arch,
  name || "." || arch AS sql_nameArch,
  name || "-" || version || "-" || release || "." || arch AS sql_nameVerRelArch,
  name || "-" || version AS sql_nameVer,
  name || "-" || version || "-" || release AS sql_nameVerRel,
  epoch || ":" || name || "-" || version || "-" || release || "." || arch AS sql_envra,
  name || "-" || epoch || ":" || version || "-" || release || "." || arch AS sql_nevra
  FROM packages
  WHERE
()   R9  t   os.pathR  R’   t   packagesR    R   R   R   R   R   R   R   R   R   t   rpmUtils.miscutilsRÇ  Ra  Rd  t   yum.miscR   t   yum.i18nR   R	   R   R  R¡   R   R!   R)   R7   R?   R@   R÷   R‘   RÙ  R§   R¸  R£   Rƒ  R€  (    (    (    s2   /usr/lib/python2.7/dist-packages/yum/sqlitesack.pyt   <module>   sD   "					DÒˇ ˇ ˇ ˇ ˇ S					                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python2.7/dist-packages/yum/sqlutils.py                                                     0100644 0000000 0000000 00000014426 12451005146 020164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of version 2 of the GNU General Public License
# as published by the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University

"""
utility functions to handle differences in pysqlite versions
These are from Wichert Akkerman <wichert@deephackmode.org>'s python-dhm
http://www.wiggy.net/code/python-dhm
"""

try:
    import sqlite3 as sqlite
except ImportError:
    import sqlite

class TokenizeError(Exception):
    """Tokenizer error class"""
    pass

def Tokenize(str, whitespace=" \t\r\n", quotes="\"", escapes="\\"):
    """String tokenizer

    This function tokenizes a string while taking quotation and
    escaping into account.

      >>> import dhm.strtools
      >>> dhm.strtools.Tokenize("this is a test")
      ['this', 'is', 'a', 'test']
      >>> dhm.strtools.Tokenize("this \"is a\" test")
      ['this', 'is a', 'test']
      >>> dhm.strtools.Tokenize("this \\\"is\\\" a test")
      ['this', '"is"', 'a', 'test']
      >>> dhm.strtools.Tokenize("this \"is a test")
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
        File "/usr/local/lib/python2.2/site-packages/dhm/strtools.py", line 80, in Tokenize
          raise TokenizeError, "Unexpected end of string in quoted text"
      dhm.strtools.TokenizeError: Unexecpted end of string in quoted text

    @param        str: string to tokenize
    @type         str: string
    @param whitespace: whitespace characters seperating tokens
    @type  whitespace: string
    @param     quotes: legal quoting characters
    @type      quotes: string
    @param    escapes: characters which can escape quoting characters
    @type     escapes: string
    @return: list of tokens
    @rtype:  sequence of strings
    """
    (buffer, tokens, curtoken, quote)=(str, [], None, None)

    try:
        while buffer:
            if buffer[0]==quote:
                quote=None
            elif (quote==None) and (buffer[0] in quotes):
                quote=buffer[0]
            elif buffer[0] in whitespace:
                if quote!=None:
                    curtoken+=buffer[0]
                else:
                    tokens.append(curtoken)
                    curtoken=None
                    while buffer[1] in whitespace:
                        buffer=buffer[1:]
            elif buffer[0] in escapes:
                if curtoken==None:
                    curtoken=buffer[1]
                else:
                    curtoken+=buffer[1]
                buffer=buffer[1:]
            else:
                if curtoken==None:
                    curtoken=buffer[0]
                else:
                    curtoken+=buffer[0]

            buffer=buffer[1:]
    except IndexError:
        raise TokenizeError, "Unexpected end of string"
    
    if quote:
        raise TokenizeError, "Unexpected end of string in quoted text"

    if curtoken!=None:
        tokens.append(curtoken)

    return tokens


def QmarkToPyformat(query, params):
    """Convert from qmark to pyformat parameter style.

    The python DB-API 2.0 specifies four different possible parameter
    styles that can be used by drivers. This function converts from the
    qmark style to pyformat style.

    @param  query: SQL query to transform
    @type   query: string
    @param params: arguments to query
    @type  params: sequence of strings
    @return: converted query and parameters
    @rtype:  tuple with the new command and a dictionary of arguments
    """
    tokens=Tokenize(query, quotes="'")
    output=[]
    count=1
    for token in tokens:
        if token.endswith("?"):
            output.append(token[:-1] + "%%(param%d)s" % count)
            count+=1
        elif token.endswith("?,") or token.endswith("?)"):
            ntoken = token[:-2] + "%%(param%d)s" % count
            ntoken += token[-1]
            output.append(ntoken)
            count+=1
        else:
            output.append(token)

    dict={}
    count=1
    for param in params:
        dict["param%d" % count]=param
        count+=1
    
    return (" ".join(output), dict)


def executeSQLPyFormat(cursor, query, params=None):
    """
    Execute a python < 2.5 (external sqlite module) style query.

    @param cursor: A sqlite cursor
    @param query: The query to execute
    @param params: An optional list of parameters to the query
    """
    if params is None:
        return cursor.execute(query)

    # Leading whitespace confuses QmarkToPyformat()
    query = query.strip()
    (q, p) = QmarkToPyformat(query, params)
    return cursor.execute(q, p)

def executeSQLQmark(cursor, query, params=None):
    """
    Execute a python 2.5 (sqlite3) style query.

    @param cursor: A sqlite cursor
    @param query: The query to execute
    @param params: An optional list of parameters to the query
    """
    if params is None:
        return cursor.execute(query)
    
    return cursor.execute(query, params)

if sqlite.version_info[0] > 1:
    executeSQL = executeSQLQmark
else:
    executeSQL = executeSQLPyFormat


def sql_esc(pattern):
    """ Apply SQLite escaping, if needed. Returns pattern and esc. """
    esc = ''
    if "_" in pattern or "%" in pattern:
        esc = ' ESCAPE "!"'
        pattern = pattern.replace("!", "!!")
        pattern = pattern.replace("%", "!%")
        pattern = pattern.replace("_", "!_")
    return (pattern, esc)

def sql_esc_glob(patterns):
    """ Converts patterns to SQL LIKE format, if required (or gives up if
        not possible). """
    ret = []
    for pattern in patterns:
        if '[' in pattern: # LIKE only has % and _, so [abc] can't be done.
            return []      # So Load everything

        # Convert to SQL LIKE format
        (pattern, esc) = sql_esc(pattern)
        pattern = pattern.replace("*", "%")
        pattern = pattern.replace("?", "_")
        ret.append((pattern, esc))
    return ret
                                                                                                                                                                                                                                          usr/lib/python2.7/dist-packages/yum/sqlutils.pyc                                                    0100644 0000000 0000000 00000013150 13077704344 020333  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   s∑   d  Z  y d d l Z Wn e k
 r5 d d l Z n Xd e f d Ñ  É  YZ d d d d Ñ Z d	 Ñ  Z d d
 Ñ Z	 d d Ñ Z
 e j d d k rõ e
 Z n e	 Z d Ñ  Z d Ñ  Z d S(   s´   
utility functions to handle differences in pysqlite versions
These are from Wichert Akkerman <wichert@deephackmode.org>'s python-dhm
http://www.wiggy.net/code/python-dhm
iˇˇˇˇNt   TokenizeErrorc           B   s   e  Z d  Z RS(   s   Tokenizer error class(   t   __name__t
   __module__t   __doc__(    (    (    s0   /usr/lib/python2.7/dist-packages/yum/sqlutils.pyR       s   s    	
s   "s   \c         C   sô  |  g  d d f \ } } } } y,x%| rH| d | k rC d } n¯ | d k rl | d | k rl | d } nœ | d | k r– | d k rô | | d 7} q;| j | É d } xå | d | k rÃ | d } qØ Wnk | d | k r| d k r˘ | d } n | | d 7} | d } n' | d k r-| d } n | | d 7} | d } q$ WWn t k
 rft d Ç n X| ryt d Ç n  | d k rï| j | É n  | S(   sñ  String tokenizer

    This function tokenizes a string while taking quotation and
    escaping into account.

      >>> import dhm.strtools
      >>> dhm.strtools.Tokenize("this is a test")
      ['this', 'is', 'a', 'test']
      >>> dhm.strtools.Tokenize("this "is a" test")
      ['this', 'is a', 'test']
      >>> dhm.strtools.Tokenize("this \"is\" a test")
      ['this', '"is"', 'a', 'test']
      >>> dhm.strtools.Tokenize("this "is a test")
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
        File "/usr/local/lib/python2.2/site-packages/dhm/strtools.py", line 80, in Tokenize
          raise TokenizeError, "Unexpected end of string in quoted text"
      dhm.strtools.TokenizeError: Unexecpted end of string in quoted text

    @param        str: string to tokenize
    @type         str: string
    @param whitespace: whitespace characters seperating tokens
    @type  whitespace: string
    @param     quotes: legal quoting characters
    @type      quotes: string
    @param    escapes: characters which can escape quoting characters
    @type     escapes: string
    @return: list of tokens
    @rtype:  sequence of strings
    i    i   s   Unexpected end of strings'   Unexpected end of string in quoted textN(   t   Nonet   appendt
   IndexErrorR    (   t   strt
   whitespacet   quotest   escapest   buffert   tokenst   curtokent   quote(    (    s0   /usr/lib/python2.7/dist-packages/yum/sqlutils.pyt   Tokenize   s<    		c   	      C   s  t  |  d d É} g  } d } x® | D]† } | j d É r` | j | d  d | É | d 7} q% | j d É s~ | j d É r∏ | d	  d | } | | d 7} | j | É | d 7} q% | j | É q% Wi  } d } x& | D] } | | d
 | <| d 7} q‹ Wd j | É | f S(   sÍ  Convert from qmark to pyformat parameter style.

    The python DB-API 2.0 specifies four different possible parameter
    styles that can be used by drivers. This function converts from the
    qmark style to pyformat style.

    @param  query: SQL query to transform
    @type   query: string
    @param params: arguments to query
    @type  params: sequence of strings
    @return: converted query and parameters
    @rtype:  tuple with the new command and a dictionary of arguments
    R	   t   'i   t   ?iˇˇˇˇs   %%(param%d)ss   ?,s   ?)i˛ˇˇˇs   param%dt    (   R   t   endswithR   t   join(	   t   queryt   paramsR   t   outputt   countt   tokent   ntokent   dictt   param(    (    s0   /usr/lib/python2.7/dist-packages/yum/sqlutils.pyt   QmarkToPyformatg   s&    c         C   sJ   | d k r |  j | É S| j É  } t | | É \ } } |  j | | É S(   s–   
    Execute a python < 2.5 (external sqlite module) style query.

    @param cursor: A sqlite cursor
    @param query: The query to execute
    @param params: An optional list of parameters to the query
    N(   R   t   executet   stripR   (   t   cursorR   R   t   qt   p(    (    s0   /usr/lib/python2.7/dist-packages/yum/sqlutils.pyt   executeSQLPyFormatç   s
    c         C   s)   | d k r |  j | É S|  j | | É S(   sø   
    Execute a python 2.5 (sqlite3) style query.

    @param cursor: A sqlite cursor
    @param query: The query to execute
    @param params: An optional list of parameters to the query
    N(   R   R   (   R    R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/sqlutils.pyt   executeSQLQmarkù   s    i    i   c         C   sg   d } d |  k s d |  k r] d } |  j  d d É }  |  j  d d É }  |  j  d d É }  n  |  | f S(	   s<    Apply SQLite escaping, if needed. Returns pattern and esc. t    t   _t   %s    ESCAPE "!"t   !s   !!s   !%s   !_(   t   replace(   t   patternt   esc(    (    s0   /usr/lib/python2.7/dist-packages/yum/sqlutils.pyt   sql_esc∞   s    c         C   st   g  } xg |  D]_ } d | k r# g  St  | É \ } } | j d d É } | j d d É } | j | | f É q W| S(   sZ    Converts patterns to SQL LIKE format, if required (or gives up if
        not possible). t   [t   *R'   R   R&   (   R,   R)   R   (   t   patternst   retR*   R+   (    (    s0   /usr/lib/python2.7/dist-packages/yum/sqlutils.pyt   sql_esc_glob∫   s    (   R   t   sqlite3t   sqlitet   ImportErrort	   ExceptionR    R   R   R   R#   R$   t   version_infot
   executeSQLR,   R1   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/sqlutils.pyt   <module>   s   H	&		
                                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/dist-packages/yum/transactioninfo.py                                              0100644 0000000 0000000 00000075150 12451005146 021506  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University
# Written by Seth Vidal

# TODOS: make all the package relationships deal with package objects
# search by package object for TransactionData, etc.
# provide a real TransactionData.remove(txmbr) method, It should 
# remove the given txmbr and iterate to remove all those in depedent relationships
# with the given txmbr. 

"""
Classes and functions for manipulating a transaction to be passed
to rpm.
"""

from constants import *
from packageSack import PackageSack, PackageSackVersion
from packages import YumInstalledPackage
from sqlitesack import YumAvailablePackageSqlite
import Errors
import warnings
import misc

class GetProvReqOnlyPackageSack(PackageSack):
    def __init__(self, need_files=False):
        PackageSack.__init__(self)
        self._need_index_files = need_files

    def __addPackageToIndex_primary_files(self, obj):
        for ftype in obj.returnFileTypes(primary_only=True):
            for file in obj.returnFileEntries(ftype, primary_only=True):
                self._addToDictAsList(self.filenames, file, obj)
    def __addPackageToIndex_files(self, obj):
        for ftype in obj.returnFileTypes():
            for file in obj.returnFileEntries(ftype):
                self._addToDictAsList(self.filenames, file, obj)
    def _addPackageToIndex(self, obj):
        for (n, fl, (e,v,r)) in obj.returnPrco('provides'):
            self._addToDictAsList(self.provides, n, obj)
        for (n, fl, (e,v,r)) in obj.returnPrco('requires'):
            self._addToDictAsList(self.requires, n, obj)
        if self._need_index_files:
            self.__addPackageToIndex_files(obj)
        else:
            self.__addPackageToIndex_primary_files(obj)

    def __buildFileIndexes(self):
        for repoid in self.pkgsByRepo:
            for obj in self.pkgsByRepo[repoid]:
                self.__addPackageToIndex_files(obj)
    def searchFiles(self, name):
        if not self._need_index_files and not misc.re_primary_filename(name):
            self._need_index_files = True
            if self.indexesBuilt:
                self.filenames = {}
                self.__buildFileIndexes()

        return PackageSack.searchFiles(self, name)

class TransactionData:
    """Data Structure designed to hold information on a yum Transaction Set"""
    def __init__(self):
        self.flags = []
        self.vsflags = []
        self.probFilterFlags = []
        self.root = '/'
        self.pkgdict = {} # key = pkgtup, val = list of TransactionMember obj
        self._namedict = {} # name -> list of TransactionMember obj
        self._unresolvedMembers = set()
        self.debug = 0
        self.changed = False
        self.installonlypkgs = []
        self.state_counter = 0
        self.conditionals = {} # key = pkgname, val = list of pos to add

        self.rpmdb = None
        self.pkgSack = None
        self.pkgSackPackages = 0
        self.localSack = PackageSack()
        self._inSack = GetProvReqOnlyPackageSack()

        # lists of txmbrs in their states - just placeholders
        self.instgroups = []
        self.removedgroups = []
        self.removed = []
        self.installed = []
        self.updated = []
        self.obsoleted = []
        self.depremoved = []
        self.depinstalled = []
        self.depupdated = []
        self.reinstalled = []
        self.downgraded = []
        self.failed = []
        
    def __len__(self):
        return len(self.pkgdict)
        
    def __iter__(self):
        if hasattr(self.getMembers(), '__iter__'):
            return self.getMembers().__iter__()
        else:
            return iter(self.getMembers())

    def debugprint(self, msg):
        if self.debug:
            print msg

    def getMembersWithState(self, pkgtup=None, output_states=None):
        return filter(lambda p: p.output_state in output_states,
                      self.getMembers(pkgtup))

    def getMembers(self, pkgtup=None):
        """takes an optional package tuple and returns all transaction members 
           matching, no pkgtup means it returns all transaction members"""
        
        returnlist = []

        if pkgtup is None:
            for members in self.pkgdict.itervalues():
                returnlist.extend(members)            
        elif pkgtup in self.pkgdict:
            returnlist.extend(self.pkgdict[pkgtup])
        return returnlist
            
    # The order we resolve things in _matters_, so for sanity sort the list
    # otherwise .i386 can be different to .x86_64 etc.
    def getUnresolvedMembers(self):
        return list(sorted(self._unresolvedMembers))

    def markAsResolved(self, txmbr):
        self._unresolvedMembers.discard(txmbr)

    def resetResolved(self, hard=False):
        if hard or len(self) < len(self._unresolvedMembers):
            self._unresolvedMembers.clear()
            self._unresolvedMembers.update(self.getMembers())
            return True
        return False

    def getMode(self, name=None, arch=None, epoch=None, ver=None, rel=None):
        """returns the mode of the first match from the transaction set, 
           otherwise, returns None"""

        txmbrs = self.matchNaevr(name=name, arch=arch, epoch=epoch, ver=ver, rel=rel)
        if not len(txmbrs):
            return None
        states = []
        for txmbr in txmbrs:
            states.append(txmbr.ts_state)
        
        if 'u' in states:
            return 'u'
        elif 'i' in states:
            return 'i'
        else:
            return states[0]
            
    def matchNaevr(self, name=None, arch=None, epoch=None, ver=None, rel=None):
        """returns the list of packages matching the args above"""
        if name is None:
            txmbrs = self.getMembers()
        else:
            txmbrs = self._namedict.get(name, [])
            if arch is None and epoch is None and ver is None and rel is None:
                return txmbrs[:]

        result = []

        for txmbr in txmbrs:
            (n, a, e, v, r) = txmbr.pkgtup
            # Name is done above
            if arch is not None and arch != a:
                continue
            if epoch is not None and epoch != e:
                continue
            if ver is not None and ver != v:
                continue
            if rel is not None and rel != r:
                continue
            result.append(txmbr)

        return result

    def deselect(self, pattern):
        """ Remove these packages from the transaction. This is more user
            orientated than .remove(). Used from kickstart/install -blah. """

        #  We don't have a returnPackages() here, so just try the "simple" 
        # specifications. Pretty much 100% hit rate on kickstart.
        txmbrs = self.matchNaevr(pattern)
        if not txmbrs:
            na = pattern.rsplit('.', 2)
            if len(na) == 2:
                txmbrs = self.matchNaevr(na[0], na[1])

        if not txmbrs:
            if self.pkgSack is None:
                pkgs = []
            else:
                pkgs = self.pkgSack.returnPackages(patterns=[pattern])
            if not pkgs:
                pkgs = self.rpmdb.returnPackages(patterns=[pattern])

            for pkg in pkgs:
                txmbrs.extend(self.getMembers(pkg.pkgtup))
                #  Now we need to do conditional group packages, so they don't
                # get added later on. This is hacky :(
                for req, cpkgs in self.conditionals.iteritems():
                    if pkg in cpkgs:
                        cpkgs.remove(pkg)
                        self.conditionals[req] = cpkgs

        for txmbr in txmbrs:
            self.remove(txmbr.pkgtup)
        return txmbrs

    def _isLocalPackage(self, txmember):
        # Is this the right criteria?
        # FIXME: This is kinda weird, we really want all local pkgs to be in a
        # special pkgsack before this point ... so that "yum up ./*.rpm" works.
        #  Also FakePackage() sets it off ... which is confusing and not what
        # happens IRL.
        return txmember.ts_state in ('u', 'i') and not isinstance(txmember.po, (YumInstalledPackage, YumAvailablePackageSqlite))

    def _allowedMultipleInstalls(self, po):
        """takes a packageObject, returns 1 or 0 depending on if the package 
           should/can be installed multiple times with different vers
           like kernels and kernel modules, for example"""
           
        if po.name in self.installonlypkgs:
            return True
        
        provides = po.provides_names
        if filter (lambda prov: prov in self.installonlypkgs, provides):
            return True
        
        return False
        
    def add(self, txmember):
        """add a package to the transaction"""
        
        for oldpo in txmember.updates:
            self.addUpdated(oldpo, txmember.po)

        if txmember.pkgtup not in self.pkgdict:
            self.pkgdict[txmember.pkgtup] = []
        else:
            self.debugprint("Package: %s.%s - %s:%s-%s already in ts" % txmember.pkgtup)
            for member in self.pkgdict[txmember.pkgtup]:
                if member.ts_state == txmember.ts_state:
                    self.debugprint("Package in same mode, skipping.")
                    return
        self.pkgdict[txmember.pkgtup].append(txmember)
        self._namedict.setdefault(txmember.name, []).append(txmember)
        self.changed = True
        self.state_counter += 1
        if self._isLocalPackage(txmember):
            self.localSack.addPackage(txmember.po)
        elif isinstance(txmember.po, YumAvailablePackageSqlite):
            self.pkgSackPackages += 1
        if self._inSack is not None and txmember.output_state in TS_INSTALL_STATES:
            if not txmember.po.have_fastReturnFileEntries():
                # In theory we could keep this on if a "small" repo. fails
                self._inSack = None
            else:
                self._inSack.addPackage(txmember.po)

        if txmember.name in self.conditionals:
            for pkg in self.conditionals[txmember.name]:
                if self.rpmdb.contains(po=pkg):
                    continue
                for condtxmbr in self.install_method(po=pkg):
                    condtxmbr.setAsDep(po=txmember.po)

        self._unresolvedMembers.add(txmember)

    def remove(self, pkgtup):
        """remove a package from the transaction"""
        if pkgtup not in self.pkgdict:
            self.debugprint("Package: %s not in ts" %(pkgtup,))
            return
        for txmbr in self.pkgdict[pkgtup]:
            txmbr.po.state = None
            if self._isLocalPackage(txmbr):
                self.localSack.delPackage(txmbr.po)
            elif isinstance(txmbr.po, YumAvailablePackageSqlite):
                self.pkgSackPackages -= 1
            if self._inSack is not None and txmbr.output_state in TS_INSTALL_STATES:
                self._inSack.delPackage(txmbr.po)
            self._namedict[txmbr.name].remove(txmbr)
            self._unresolvedMembers.add(txmbr)
        
        del self.pkgdict[pkgtup]
        if not self._namedict[pkgtup[0]]:
            del self._namedict[pkgtup[0]]
        self.changed = True        
        self.state_counter += 1
    
    def exists(self, pkgtup):
        """tells if the pkg is in the class"""
        if pkgtup in self.pkgdict:
            if len(self.pkgdict[pkgtup]) != 0:
                return 1
        
        return 0

    def isObsoleted(self, pkgtup):
        """true if the pkgtup is marked to be obsoleted"""
        if self.exists(pkgtup):
            for txmbr in self.getMembers(pkgtup=pkgtup):
                if txmbr.output_state == TS_OBSOLETED:
                    return True
        
        return False
                
    def makelists(self, include_reinstall=False, include_downgrade=False):
        """returns lists of transaction Member objects based on mode:
           updated, installed, erased, obsoleted, depupdated, depinstalled
           deperased"""
           
        self.instgroups = []
        self.removedgroups = []
        self.removed = []
        self.installed = []
        self.updated = []
        self.obsoleted = []
        self.depremoved = []
        self.depinstalled = []
        self.depupdated = []
        self.reinstalled = []
        self.downgraded = []
        self.failed = []

        for txmbr in self.getMembers():
            if txmbr.output_state == TS_UPDATE:
                if txmbr.isDep:
                    self.depupdated.append(txmbr)
                else:
                    self.updated.append(txmbr)
                    
            elif txmbr.output_state in (TS_INSTALL, TS_TRUEINSTALL):
                if include_reinstall and txmbr.reinstall:
                    self.reinstalled.append(txmbr)
                    continue

                if include_downgrade and txmbr.downgrades:
                    self.downgraded.append(txmbr)
                    continue

                if txmbr.groups:
                    for g in txmbr.groups:
                        if g not in self.instgroups:
                            self.instgroups.append(g)
                if txmbr.isDep:
                    self.depinstalled.append(txmbr)
                else:
                    self.installed.append(txmbr)
            
            elif txmbr.output_state == TS_ERASE:
                if include_downgrade and txmbr.downgraded_by:
                    continue

                for g in txmbr.groups:
                    if g not in self.instgroups:
                        self.removedgroups.append(g)
                if txmbr.isDep:
                    self.depremoved.append(txmbr)
                else:
                    self.removed.append(txmbr)
                    
            elif txmbr.output_state == TS_OBSOLETED:
                self.obsoleted.append(txmbr)
                
            elif txmbr.output_state == TS_OBSOLETING:
                self.installed.append(txmbr)
            elif txmbr.output_state == TS_FAILED:
                self.failed.append(txmbr)
                
            else:
                pass
    
        self.updated.sort()
        self.installed.sort()
        self.removed.sort()
        self.obsoleted.sort()
        self.depupdated.sort()
        self.depinstalled.sort()
        self.depremoved.sort()
        self.instgroups.sort()
        self.removedgroups.sort()
        self.reinstalled.sort()
        self.downgraded.sort()
        self.failed.sort()

    def addInstall(self, po):
        """adds a package as an install but in mode 'u' to the ts
           takes a packages object and returns a TransactionMember Object"""

        if self._allowedMultipleInstalls(po):
            return self.addTrueInstall(po)
    
        txmbr = TransactionMember(po)
        txmbr.current_state = TS_AVAILABLE
        txmbr.output_state = TS_INSTALL
        txmbr.po.state = TS_INSTALL        
        txmbr.ts_state = 'u'
        txmbr.reason = 'user'

        if self.rpmdb.contains(po=txmbr.po):
            txmbr.reinstall = True
        
        self.findObsoletedByThisMember(txmbr)
        self.add(txmbr)
        return txmbr

    def addTrueInstall(self, po):
        """adds a package as an install
           takes a packages object and returns a TransactionMember Object"""
    
        txmbr = TransactionMember(po)
        txmbr.current_state = TS_AVAILABLE
        txmbr.output_state = TS_TRUEINSTALL
        txmbr.po.state = TS_INSTALL        
        txmbr.ts_state = 'i'
        txmbr.reason = 'user'

        if self.rpmdb.contains(po=txmbr.po):
            txmbr.reinstall = True

        self.add(txmbr)
        return txmbr
    

    def addErase(self, po):
        """adds a package as an erasure
           takes a packages object and returns a TransactionMember Object"""
    
        txmbr = TransactionMember(po)
        txmbr.current_state = TS_INSTALL
        txmbr.output_state = TS_ERASE
        txmbr.po.state = TS_INSTALL
        txmbr.ts_state = 'e'
        self.add(txmbr)
        return txmbr

    def addUpdate(self, po, oldpo=None):
        """adds a package as an update
           takes a packages object and returns a TransactionMember Object"""
        
        if self._allowedMultipleInstalls(po):
            return self.addTrueInstall(po)
            
        txmbr = TransactionMember(po)
        txmbr.current_state = TS_AVAILABLE
        txmbr.output_state = TS_UPDATE
        txmbr.po.state = TS_UPDATE        
        txmbr.ts_state = 'u'
        if oldpo:
            txmbr.relatedto.append((oldpo, 'updates'))
            txmbr.updates.append(oldpo)
            
        self.add(txmbr)
        self.findObsoletedByThisMember(txmbr)
        return txmbr

    def addDowngrade(self, po, oldpo):
        """adds a package as an downgrade takes a packages object and returns
           a pair of TransactionMember Objects"""

        itxmbr = self.addErase(oldpo)
        itxmbr.relatedto.append((po, 'downgradedby'))
        itxmbr.downgraded_by.append(po)

        atxmbr = self.addInstall(po)
        if not atxmbr: # Fail?
            self.remove(itxmbr.pkgtup)
            return None
        atxmbr.relatedto.append((oldpo, 'downgrades'))
        atxmbr.downgrades.append(oldpo)

        return (itxmbr, atxmbr)

    def addUpdated(self, po, updating_po):
        """adds a package as being updated by another pkg
           takes a packages object and returns a TransactionMember Object"""
    
        txmbr = TransactionMember(po)
        txmbr.current_state = TS_INSTALL
        txmbr.output_state =  TS_UPDATED
        txmbr.po.state = TS_UPDATED
        txmbr.ts_state = 'ud'
        txmbr.relatedto.append((updating_po, 'updatedby'))
        txmbr.updated_by.append(updating_po)
        self.add(txmbr)
        return txmbr

    def addObsoleting(self, po, oldpo):
        """adds a package as an obsolete over another pkg
           takes a packages object and returns a TransactionMember Object"""
    
        txmbr = TransactionMember(po)
        txmbr.current_state = TS_AVAILABLE
        txmbr.output_state = TS_OBSOLETING
        txmbr.po.state = TS_OBSOLETING
        txmbr.ts_state = 'u'
        txmbr.relatedto.append((oldpo, 'obsoletes'))
        txmbr.obsoletes.append(oldpo)

        if self.rpmdb.contains(po=txmbr.po):
            txmbr.reinstall = True

        self.add(txmbr)
        return txmbr

    def addObsoleted(self, po, obsoleting_po):
        """adds a package as being obsoleted by another pkg
           takes a packages object and returns a TransactionMember Object"""
    
        txmbr = TransactionMember(po)
        txmbr.current_state = TS_INSTALL
        txmbr.output_state =  TS_OBSOLETED
        txmbr.po.state = TS_OBSOLETED
        txmbr.ts_state = 'od'
        txmbr.relatedto.append((obsoleting_po, 'obsoletedby'))
        txmbr.obsoleted_by.append(obsoleting_po)
        self.add(txmbr)
        for otxmbr in self.getMembersWithState(obsoleting_po.pkgtup,
                                               [TS_OBSOLETING]):
            if po in otxmbr.obsoletes:
                continue
            otxmbr.relatedto.append((po, 'obsoletes'))
            otxmbr.obsoletes.append(po)
        return txmbr


    def setDatabases(self, rpmdb, pkgSack):
        self.rpmdb = rpmdb
        self.pkgSack = pkgSack

    def getNewProvides(self, name, flag=None, version=(None, None, None)):
        """return dict { packages -> list of matching provides }
        searches in packages to be installed"""
        result = { }
        if not self.pkgSackPackages:
            pass
        elif self._inSack is None:
            for pkg, hits in self.pkgSack.getProvides(name, flag, version).iteritems():
                if self.getMembersWithState(pkg.pkgtup, TS_INSTALL_STATES):
                    result[pkg] = hits
        else:
            for pkg, hits in self._inSack.getProvides(name, flag, version).iteritems():
                result[pkg] = hits
        result.update(self.localSack.getProvides(name, flag, version))
        return result

    def getOldProvides(self, name, flag=None, version=(None, None, None)):
        """return dict { packages -> list of matching provides }
        searches in packages already installed and not going to be removed"""
        result = { }
        for pkg, hits in self.rpmdb.getProvides(name, flag, version).iteritems():
            if not self.getMembersWithState(pkg.pkgtup, TS_REMOVE_STATES):
                result[pkg] = hits
        return result

    def getProvides(self, name, flag=None, version=(None, None, None)):
        """return dict { packages -> list of matching provides }"""
        result = self.getOldProvides(name, flag, version)
        result.update(self.getNewProvides(name, flag, version))
        return result

    def getNewRequires(self, name, flag=None, version=(None, None, None)):
        """return dict { packages -> list of matching provides }
        searches in packages to be installed"""
        result = { }
        if not self.pkgSackPackages:
            pass
        elif self._inSack is None:
            for pkg, hits in self.pkgSack.getRequires(name, flag, version).iteritems():
                if self.getMembersWithState(pkg.pkgtup, TS_INSTALL_STATES):
                    result[pkg] = hits
        else:
            for pkg, hits in self._inSack.getRequires(name, flag, version).iteritems():
                result[pkg] = hits

        result.update(self.localSack.getRequires(name, flag, version))
        return result


    def getOldRequires(self, name, flag=None, version=(None, None, None)):
        """return dict { packages -> list of matching provides }
        searches in packages already installed and not going to be removed"""
        result = { }
        for pkg, hits in self.rpmdb.getRequires(name, flag, version).iteritems():
            if not self.getMembersWithState(pkg.pkgtup, TS_REMOVE_STATES):
                result[pkg] = hits
        return result

    def getRequires(self, name, flag=None, version=(None, None, None)):
        """return dict { packages -> list of matching provides }"""
        result = self.getOldRequires(name, flag, version)
        result.update(self.getNewRequires(name, flag, version))
        return result

    def futureRpmDBVersion(self):
        """ Return a simple version for the future rpmdb. Works like
            rpmdb.simpleVersion(main_only=True)[0], but for the state the rpmdb
            will be in after the transaction. """
        pkgs = self.rpmdb.returnPackages()
        _reinstalled_pkgtups = {}
        for txmbr in self.getMembersWithState(None, TS_INSTALL_STATES):
            # reinstalls have to use their "new" checksum data, in case it's
            # different.
            if txmbr.reinstall:
                _reinstalled_pkgtups[txmbr.po.pkgtup] = txmbr.po
            pkgs.append(txmbr.po)

        self.rpmdb.preloadPackageChecksums()
        main = PackageSackVersion()
        pkg_checksum_tups = []
        for pkg in sorted(pkgs):
            if pkg.repoid != 'installed':
                # Paste from PackageSackBase.simpleVersion()
                csum = pkg.returnIdSum()
                main.update(pkg, csum)
                pkg_checksum_tups.append((pkg.pkgtup, csum))
                continue

            # Installed pkg, see if it's about to die
            if self.getMembersWithState(pkg.pkgtup, TS_REMOVE_STATES):
                continue
            # ...or die and be risen again (Zombie!)
            if pkg.pkgtup in _reinstalled_pkgtups:
                continue

            # Paste from rpmdb.simpleVersion()
            ydbi = pkg.yumdb_info
            csum = None
            if 'checksum_type' in ydbi and 'checksum_data' in ydbi:
                csum = (ydbi.checksum_type, ydbi.checksum_data)
            #  We need all the pkgtups, so we even save the ones without a
            # checksum.
            pkg_checksum_tups.append((pkg.pkgtup, csum))
            main.update(pkg, csum)

        self.rpmdb.transactionCachePackageChecksums(pkg_checksum_tups)

        return main
    
    def findObsoletedByThisMember(self, txmbr):
        """addObsoleted() pkgs for anything that this txmbr will obsolete"""
        # this is mostly to keep us in-line with what will ACTUALLY happen
        # when rpm hits the obsoletes, whether we added them or not
        for obs_n in txmbr.po.obsoletes_names:
            for pkg in self.rpmdb.searchNevra(name=obs_n):
                if pkg.obsoletedBy([txmbr.po]):
                    self.addObsoleted(pkg, txmbr.po)
                    txmbr.output_state = TS_OBSOLETING
                    txmbr.po.state = TS_OBSOLETING

class ConditionalTransactionData(TransactionData):
    """A transaction data implementing conditional package addition"""
    def __init__(self):
        warnings.warn("ConditionalTransactionData will go away in a future "
                      "version of Yum.", Errors.YumFutureDeprecationWarning)
        TransactionData.__init__(self)

class SortableTransactionData(TransactionData):
    """A transaction data implementing topological sort on it's members"""
    def __init__(self):
        # Cache of sort
        self._sorted = []
        # Current dependency path
        self.path = []
        # List of loops
        self.loops = []
        TransactionData.__init__(self)

    def _visit(self, txmbr):
        self.path.append(txmbr.name)
        txmbr.sortColour = TX_GREY
        for po in txmbr.depends_on:
            vertex = self.getMembers(pkgtup=po.pkgtup)[0]
            if vertex.sortColour == TX_GREY:
                self._doLoop(vertex.name)
            if vertex.sortColour == TX_WHITE:
                self._visit(vertex)
        txmbr.sortColour = TX_BLACK
        self._sorted.insert(0, txmbr.pkgtup)

    def _doLoop(self, name):
        self.path.append(name)
        loop = self.path[self.path.index(self.path[-1]):]
        if len(loop) > 2:
            self.loops.append(loop)

    def add(self, txmember):
        txmember.sortColour = TX_WHITE
        TransactionData.add(self, txmember)
        self._sorted = []

    def remove(self, pkgtup):
        TransactionData.remove(self, pkgtup)
        self._sorted = []

    def sort(self):
        if self._sorted:
            return self._sorted
        self._sorted = []
        # loop over all members
        for txmbr in self.getMembers():
            if txmbr.sortColour == TX_WHITE:
                self.path = [ ]
                self._visit(txmbr)
        self._sorted.reverse()
        return self._sorted


class TransactionMember:
    """Class to describe a Transaction Member (a pkg to be installed/
       updated/erased)."""
    
    def __init__(self, po):
        # holders for data
        self.po = po # package object
        self.current_state = None # where the package currently is (repo, installed)
        self.ts_state = None # what state to put it into in the transaction set
        self.output_state = None # what state to list if printing it
        self.isDep = 0
        self.reason = 'user' # reason for it to be in the transaction set
        self.process = None #  I think this is used nowhere by nothing - skv 2010/11/03
        self.relatedto = [] # ([relatedpkg, relationship)]
        self.depends_on = []
        self.obsoletes = []
        self.obsoleted_by = []
        self.updates = []
        self.updated_by = []
        self.downgrades = []
        self.downgraded_by = []
        self.reinstall = False
        self.groups = [] # groups it's in
        self._poattr = ['pkgtup', 'repoid', 'name', 'arch', 'epoch', 'version',
                        'release']

        for attr in self._poattr:
            val = getattr(self.po, attr)
            setattr(self, attr, val)

        if po.repoid == 'installed':
            #  We want to load these so that we can auto hardlink in the same
            # new values. Because of the hardlinks it should be really cheap
            # to load them ... although it's still a minor hack.
            po.yumdb_info.get('from_repo')
            po.yumdb_info.get('releasever')
            po.yumdb_info.get('changed_by')

    def setAsDep(self, po=None):
        """sets the transaction member as a dependency and maps the dep into the
           relationship list attribute"""
        
        self.isDep = 1
        if po:
            self.relatedto.append((po, 'dependson'))
            self.depends_on.append(po)

    def __cmp__(self, other):
        return cmp(self.po, other.po)

    def __hash__(self):
        return object.__hash__(self)
            
    def __str__(self):
        return "%s.%s %s:%s-%s - %s" % (self.name, self.arch, self.epoch,
                                        self.version, self.release, self.ts_state)

    def __repr__(self):
        return "<%s : %s (%s)>" % (self.__class__.__name__, str(self),hex(id(self))) 
    
    def _dump(self):
        msg = "mbr: %s,%s,%s,%s,%s %s\n" % (self.name, self.arch, self.epoch, 
                     self.version, self.release, self.current_state)
        msg += "  repo: %s\n" % self.po.repo.id
        msg += "  ts_state: %s\n" % self.ts_state
        msg += "  output_state: %s\n" %  self.output_state
        msg += "  isDep: %s\n" %  bool(self.isDep)
        msg += "  reason: %s\n" % self.reason
        #msg += "  process: %s\n" % self.process
        msg += "  reinstall: %s\n" % bool(self.reinstall)
        
        if self.relatedto:
            msg += "  relatedto:"
            for (po, rel) in self.relatedto:
                pkgorigin = 'a'
                if isinstance(po, YumInstalledPackage):
                    pkgorigin = 'i'
                msg += " %s,%s,%s,%s,%s@%s:%s" % (po.name, po.arch, po.epoch, 
                      po.version, po.release, pkgorigin, rel)
            msg += "\n"
            
        for lst in ['depends_on', 'obsoletes', 'obsoleted_by', 'downgrades',
                    'downgraded_by', 'updates', 'updated_by']:
            thislist = getattr(self, lst)
            if thislist:
                msg += "  %s:" % lst
                for po in thislist:
                    pkgorigin = 'a'
                    if isinstance(po, YumInstalledPackage):
                        pkgorigin = 'i'
                    msg += " %s,%s,%s,%s,%s@%s" % (po.name, po.arch, po.epoch, 
                        po.version, po.release, pkgorigin)
                msg += "\n"
                
        if self.groups:
            msg += "  groups: %s\n" % ' '.join(self.groups)

        return msg
                                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/dist-packages/yum/transactioninfo.pyc                                             0100644 0000000 0000000 00000067525 13077704344 021673  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   s÷   d  Z  d d l Td d l m Z m Z d d l m Z d d l m Z d d l	 Z	 d d l
 Z
 d d l Z d e f d Ñ  É  YZ d	 f  d
 Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d f  d Ñ  É  YZ d S(   sK   
Classes and functions for manipulating a transaction to be passed
to rpm.
iˇˇˇˇ(   t   *(   t   PackageSackt   PackageSackVersion(   t   YumInstalledPackage(   t   YumAvailablePackageSqliteNt   GetProvReqOnlyPackageSackc           B   sA   e  Z e d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   t  j |  É | |  _ d  S(   N(   R   t   __init__t   _need_index_files(   t   selft
   need_files(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR   &   s    c         C   sW   xP | j  d t É D]< } x3 | j | d t ÉD] } |  j |  j | | É q/ Wq Wd  S(   Nt   primary_only(   t   returnFileTypest   Truet   returnFileEntriest   _addToDictAsListt	   filenames(   R   t   objt   ftypet   file(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt!   __addPackageToIndex_primary_files*   s    c         C   sK   xD | j  É  D]6 } x- | j | É D] } |  j |  j | | É q# Wq Wd  S(   N(   R   R   R   R   (   R   R   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   __addPackageToIndex_files.   s    c         C   sÆ   x? | j  d É D]. \ } } \ } } } |  j |  j | | É q Wx? | j  d É D]. \ } } \ } } } |  j |  j | | É qR W|  j rù |  j | É n |  j | É d  S(   Nt   providest   requires(   t
   returnPrcoR   R   R   R   t3   _GetProvReqOnlyPackageSack__addPackageToIndex_filest;   _GetProvReqOnlyPackageSack__addPackageToIndex_primary_files(   R   R   t   nt   flt   et   vt   r(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   _addPackageToIndex2   s    ((	c         C   s=   x6 |  j  D]+ } x" |  j  | D] } |  j | É q Wq
 Wd  S(   N(   t
   pkgsByRepoR   (   R   t   repoidR   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   __buildFileIndexes<   s    c         C   sU   |  j  rE t j | É rE t |  _  |  j rE i  |  _ |  j É  qE n  t j |  | É S(   N(	   R   t   misct   re_primary_filenameR   t   indexesBuiltR   t,   _GetProvReqOnlyPackageSack__buildFileIndexesR   t   searchFiles(   R   t   name(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR'   @   s    			(	   t   __name__t
   __module__t   FalseR   R   R   R   R&   R'   (    (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR   %   s   			
	t   TransactionDatac           B   s©  e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d% d% d Ñ Z d% d Ñ Z	 d Ñ  Z
 d Ñ  Z e d	 Ñ Z d% d% d% d% d% d
 Ñ Z d% d% d% d% d% d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d% d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d% d& d Ñ Z! d% d' d Ñ Z" d% d( d Ñ Z# d% d) d  Ñ Z$ d% d* d! Ñ Z% d% d+ d" Ñ Z& d# Ñ  Z' d$ Ñ  Z( RS(,   sD   Data Structure designed to hold information on a yum Transaction Setc         C   s  g  |  _  g  |  _ g  |  _ d |  _ i  |  _ i  |  _ t É  |  _ d |  _ t	 |  _
 g  |  _ d |  _ i  |  _ d  |  _ d  |  _ d |  _ t É  |  _ t É  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _  g  |  _! d  S(   Nt   /i    ("   t   flagst   vsflagst   probFilterFlagst   roott   pkgdictt	   _namedictt   sett   _unresolvedMemberst   debugR+   t   changedt   installonlypkgst   state_countert   conditionalst   Nonet   rpmdbt   pkgSackt   pkgSackPackagesR   t	   localSackR   t   _inSackt
   instgroupst   removedgroupst   removedt	   installedt   updatedt	   obsoletedt
   depremovedt   depinstalledt
   depupdatedt   reinstalledt
   downgradedt   failed(   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR   K   s:    																									c         C   s   t  |  j É S(   N(   t   lenR2   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   __len__m   s    c         C   s9   t  |  j É  d É r% |  j É  j É  St |  j É  É Sd  S(   Nt   __iter__(   t   hasattrt
   getMembersRO   t   iter(   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRO   p   s    c         C   s   |  j  r | GHn  d  S(   N(   R6   (   R   t   msg(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt
   debugprintv   s    	c            s   t  á  f d Ü  |  j | É É S(   Nc            s   |  j  à  k S(   N(   t   output_state(   t   p(   t   output_states(    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   <lambda>{   s    (   t   filterRQ   (   R   t   pkgtupRW   (    (   RW   s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   getMembersWithStatez   s    c         C   sf   g  } | d k r< xM |  j j É  D] } | j | É q" Wn& | |  j k rb | j |  j | É n  | S(   så   takes an optional package tuple and returns all transaction members 
           matching, no pkgtup means it returns all transaction membersN(   R;   R2   t
   itervaluest   extend(   R   RZ   t
   returnlistt   members(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRQ   ~   s    c         C   s   t  t |  j É É S(   N(   t   listt   sortedR5   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   getUnresolvedMembersç   s    c         C   s   |  j  j | É d  S(   N(   R5   t   discard(   R   t   txmbr(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   markAsResolvedê   s    c         C   sL   | s! t  |  É t  |  j É k  rH |  j j É  |  j j |  j É  É t St S(   N(   RM   R5   t   cleart   updateRQ   R   R+   (   R   t   hard(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   resetResolvedì   s
    !c   	      C   sç   |  j  d | d | d | d | d | É } t | É s: d	 Sg  } x | D] } | j | j É qG Wd | k rq d Sd | k rÅ d S| d Sd	 S(
   sa   returns the mode of the first match from the transaction set, 
           otherwise, returns NoneR(   t   archt   epocht   vert   relt   ut   ii    N(   t
   matchNaevrRM   R;   t   appendt   ts_state(	   R   R(   Rj   Rk   Rl   Rm   t   txmbrst   statesRd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   getModeö   s    *c         C   s  | d k r |  j É  } nJ |  j j | g  É } | d k re | d k re | d k re | d k re | Sg  } x´ | D]£ } | j \ }	 }
 } } } | d k	 rÆ | |
 k rÆ qr n  | d k	 rÃ | | k rÃ qr n  | d k	 rÍ | | k rÍ qr n  | d k	 r| | k rqr n  | j | É qr W| S(   s4   returns the list of packages matching the args aboveN(   R;   RQ   R3   t   getRZ   Rq   (   R   R(   Rj   Rk   Rl   Rm   Rs   t   resultRd   R   t   aR   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRp   ¨   s$    0c   	      C   sK  |  j  | É } | sY | j d d É } t | É d k rY |  j  | d | d É } qY n  | s&|  j d k rw g  } n |  j j d | g É } | s∞ |  j j d | g É } n  xs | D]h } | j |  j | j	 É É xF |  j
 j É  D]5 \ } } | | k rÊ | j | É | |  j
 | <qÊ qÊ Wq∑ Wn  x | D] } |  j | j	 É q-W| S(   sâ    Remove these packages from the transaction. This is more user
            orientated than .remove(). Used from kickstart/install -blah. t   .i   i    i   t   patternsN(   Rp   t   rsplitRM   R=   R;   t   returnPackagesR<   R]   RQ   RZ   R:   t	   iteritemst   remove(	   R   t   patternRs   t   nat   pkgst   pkgt   reqt   cpkgsRd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   deselect∆   s(     	c         C   s&   | j  d k o% t | j t t f É S(   NRn   Ro   (   Rn   Ro   (   Rr   t
   isinstancet   poR   R   (   R   t   txmember(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   _isLocalPackageÁ   s    c            s?   | j  à  j k r t S| j } t á  f d Ü  | É r; t St S(   s¿   takes a packageObject, returns 1 or 0 depending on if the package 
           should/can be installed multiple times with different vers
           like kernels and kernel modules, for examplec            s   |  à  j  k S(   N(   R8   (   t   prov(   R   (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRX   ¯   s    (   R(   R8   R   t   provides_namesRY   R+   (   R   Rá   R   (    (   R   s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   _allowedMultipleInstallsÔ   s    	c         C   s  x$ | j  D] } |  j | | j É q
 W| j |  j k rL g  |  j | j <nR |  j d | j É x; |  j | j D]) } | j | j k rq |  j d É d Sqq W|  j | j j | É |  j j	 | j
 g  É j | É t |  _ |  j d 7_ |  j | É r|  j j | j É n$ t | j t É r5|  j d 7_ n  |  j d k	 rÑ| j t k rÑ| j j É  snd |  _ qÑ|  j j | j É n  | j
 |  j k rˇxf |  j | j
 D]Q } |  j j d | É r»qßn  x- |  j d | É D] } | j d | j É q€WqßWn  |  j j | É d S(   s    add a package to the transactions'   Package: %s.%s - %s:%s-%s already in tss   Package in same mode, skipping.Ni   Rá   (    t   updatest
   addUpdatedRá   RZ   R2   RT   Rr   Rq   R3   t
   setdefaultR(   R   R7   R9   Râ   R?   t
   addPackageRÜ   R   R>   R@   R;   RU   t   TS_INSTALL_STATESt   have_fastReturnFileEntriesR:   R<   t   containst   install_methodt   setAsDepR5   t   add(   R   Rà   t   oldpot   memberRÇ   t	   condtxmbr(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRñ   ˝   s8    	c         C   s7  | |  j  k r' |  j d | f É d Sx≈ |  j  | D]∂ } d | j _ |  j | É rl |  j j | j É n$ t | j t	 É rê |  j
 d 8_
 n  |  j d k	 rƒ | j t k rƒ |  j j | j É n  |  j | j j | É |  j j | É q5 W|  j  | =|  j | d s|  j | d =n  t |  _ |  j d 7_ d S(   s%   remove a package from the transactions   Package: %s not in tsNi   i    (   R2   RT   R;   Rá   t   stateRâ   R?   t
   delPackageRÜ   R   R>   R@   RU   Rë   R3   R(   R~   R5   Rñ   R   R7   R9   (   R   RZ   Rd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR~   #  s$    
	c         C   s3   | |  j  k r/ t |  j  | É d k r/ d Sn  d S(   s    tells if the pkg is in the classi    i   (   R2   RM   (   R   RZ   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   exists9  s    c         C   sF   |  j  | É rB x0 |  j d | É D] } | j t k r" t Sq" Wn  t S(   s,   true if the pkgtup is marked to be obsoletedRZ   (   Rú   RQ   RU   t   TS_OBSOLETEDR   R+   (   R   RZ   Rd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   isObsoletedA  s
    c         C   s   g  |  _  g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _	 g  |  _
 g  |  _ x|  j É  D]} | j t k rΩ | j r™ |  j j | É q||  j j | É qy | j t t f k rç| r˜ | j r˜ |  j	 j | É qy n  | r| j r|  j
 j | É qy n  | j r^x6 | j D]( } | |  j  k r/|  j  j | É q/q/Wn  | j rz|  j j | É q||  j j | É qy | j t k r| r±| j r±qy n  x3 | j D]( } | |  j  k rª|  j j | É qªqªW| j r|  j j | É q||  j j | É qy | j t k r8|  j j | É qy | j t k rZ|  j j | É qy | j t k ry |  j j | É qy qy W|  j j É  |  j j É  |  j j É  |  j j É  |  j j É  |  j j É  |  j j É  |  j  j É  |  j j É  |  j	 j É  |  j
 j É  |  j j É  d S(   sö   returns lists of transaction Member objects based on mode:
           updated, installed, erased, obsoleted, depupdated, depinstalled
           deperasedN(   RA   RB   RC   RD   RE   RF   RG   RH   RI   RJ   RK   RL   RQ   RU   t	   TS_UPDATEt   isDepRq   t
   TS_INSTALLt   TS_TRUEINSTALLt	   reinstallt
   downgradest   groupst   TS_ERASEt   downgraded_byRù   t   TS_OBSOLETINGt	   TS_FAILEDt   sort(   R   t   include_reinstallt   include_downgradeRd   t   g(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt	   makelistsJ  sv    																c         C   sö   |  j  | É r |  j | É St | É } t | _ t | _ t | j _ d | _	 d | _
 |  j j d | j É r| t | _ n  |  j | É |  j | É | S(   sÄ   adds a package as an install but in mode 'u' to the ts
           takes a packages object and returns a TransactionMember ObjectRn   t   userRá   (   Rå   t   addTrueInstallt   TransactionMembert   TS_AVAILABLEt   current_stateR°   RU   Rá   Rö   Rr   t   reasonR<   Rì   R   R£   t   findObsoletedByThisMemberRñ   (   R   Rá   Rd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt
   addInstallô  s    				c         C   sq   t  | É } t | _ t | _ t | j _ d | _ d | _	 |  j
 j d | j É r` t | _ n  |  j | É | S(   sf   adds a package as an install
           takes a packages object and returns a TransactionMember ObjectRo   RØ   Rá   (   R±   R≤   R≥   R¢   RU   R°   Rá   Rö   Rr   R¥   R<   Rì   R   R£   Rñ   (   R   Rá   Rd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR∞   Æ  s    				c         C   sD   t  | É } t | _ t | _ t | j _ d | _ |  j | É | S(   sf   adds a package as an erasure
           takes a packages object and returns a TransactionMember ObjectR   (	   R±   R°   R≥   R¶   RU   Rá   Rö   Rr   Rñ   (   R   Rá   Rd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   addErase¿  s    			c         C   sú   |  j  | É r |  j | É St | É } t | _ t | _ t | j _ d | _	 | r~ | j
 j | d f É | j j | É n  |  j | É |  j | É | S(   se   adds a package as an update
           takes a packages object and returns a TransactionMember ObjectRn   Rç   (   Rå   R∞   R±   R≤   R≥   Rü   RU   Rá   Rö   Rr   t	   relatedtoRq   Rç   Rñ   Rµ   (   R   Rá   Ró   Rd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt	   addUpdateÃ  s    			c         C   sé   |  j  | É } | j j | d f É | j j | É |  j | É } | s^ |  j | j É d S| j j | d f É | j j | É | | f S(   sq   adds a package as an downgrade takes a packages object and returns
           a pair of TransactionMember Objectst   downgradedbyR§   N(	   R∑   R∏   Rq   Rß   R∂   R~   RZ   R;   R§   (   R   Rá   Ró   t   itxmbrt   atxmbr(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   addDowngrade‡  s    c         C   sj   t  | É } t | _ t | _ t | j _ d | _ | j j	 | d f É | j
 j	 | É |  j | É | S(   sx   adds a package as being updated by another pkg
           takes a packages object and returns a TransactionMember Objectt   udt	   updatedby(   R±   R°   R≥   t
   TS_UPDATEDRU   Rá   Rö   Rr   R∏   Rq   t
   updated_byRñ   (   R   Rá   t   updating_poRd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRé   Ò  s    			c         C   sé   t  | É } t | _ t | _ t | j _ d | _ | j j	 | d f É | j
 j	 | É |  j j d | j É r} t | _ n  |  j | É | S(   sx   adds a package as an obsolete over another pkg
           takes a packages object and returns a TransactionMember ObjectRn   t	   obsoletesRá   (   R±   R≤   R≥   R®   RU   Rá   Rö   Rr   R∏   Rq   R√   R<   Rì   R   R£   Rñ   (   R   Rá   Ró   Rd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   addObsoletingˇ  s    			c         C   s»   t  | É } t | _ t | _ t | j _ d | _ | j j	 | d f É | j
 j	 | É |  j | É x[ |  j | j t g É D]A } | | j k rö q n  | j j	 | d f É | j j	 | É q W| S(   sz   adds a package as being obsoleted by another pkg
           takes a packages object and returns a TransactionMember Objectt   odt   obsoletedbyR√   (   R±   R°   R≥   Rù   RU   Rá   Rö   Rr   R∏   Rq   t   obsoleted_byRñ   R[   RZ   R®   R√   (   R   Rá   t   obsoleting_poRd   t   otxmbr(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   addObsoleted  s    			c         C   s   | |  _  | |  _ d  S(   N(   R<   R=   (   R   R<   R=   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   setDatabases&  s    	c         C   s—   i  } |  j  s nú |  j d k ru xä |  j j | | | É j É  D]. \ } } |  j | j t É r@ | | | <q@ q@ Wn9 x6 |  j j | | | É j É  D] \ } } | | | <qî W| j	 |  j
 j | | | É É | S(   sb   return dict { packages -> list of matching provides }
        searches in packages to be installedN(   R>   R@   R;   R=   t   getProvidesR}   R[   RZ   Rë   Rg   R?   (   R   R(   t   flagt   versionRw   RÇ   t   hits(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   getNewProvides*  s    	++c         C   s[   i  } xN |  j  j | | | É j É  D]. \ } } |  j | j t É s% | | | <q% q% W| S(   sÄ   return dict { packages -> list of matching provides }
        searches in packages already installed and not going to be removed(   R<   RÃ   R}   R[   RZ   t   TS_REMOVE_STATES(   R   R(   RÕ   RŒ   Rw   RÇ   Rœ   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   getOldProvides:  s
    +c         C   s5   |  j  | | | É } | j |  j | | | É É | S(   s5   return dict { packages -> list of matching provides }(   R“   Rg   R–   (   R   R(   RÕ   RŒ   Rw   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRÃ   C  s    c         C   s—   i  } |  j  s nú |  j d k ru xä |  j j | | | É j É  D]. \ } } |  j | j t É r@ | | | <q@ q@ Wn9 x6 |  j j | | | É j É  D] \ } } | | | <qî W| j	 |  j
 j | | | É É | S(   sb   return dict { packages -> list of matching provides }
        searches in packages to be installedN(   R>   R@   R;   R=   t   getRequiresR}   R[   RZ   Rë   Rg   R?   (   R   R(   RÕ   RŒ   Rw   RÇ   Rœ   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   getNewRequiresI  s    	++c         C   s[   i  } xN |  j  j | | | É j É  D]. \ } } |  j | j t É s% | | | <q% q% W| S(   sÄ   return dict { packages -> list of matching provides }
        searches in packages already installed and not going to be removed(   R<   R”   R}   R[   RZ   R—   (   R   R(   RÕ   RŒ   Rw   RÇ   Rœ   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   getOldRequires[  s
    +c         C   s5   |  j  | | | É } | j |  j | | | É É | S(   s5   return dict { packages -> list of matching provides }(   R’   Rg   R‘   (   R   R(   RÕ   RŒ   Rw   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR”   d  s    c   	      C   sÅ  |  j  j É  } i  } xI |  j d t É D]5 } | j rM | j | | j j <n  | j | j É q( W|  j  j	 É  t
 É  } g  } xÌ t | É D]ﬂ } | j d k r◊ | j É  } | j | | É | j | j | f É qä n  |  j | j t É rÚ qä n  | j | k rqä n  | j } d } d | k rCd | k rC| j | j f } n  | j | j | f É | j | | É qä W|  j  j | É | S(   s∏    Return a simple version for the future rpmdb. Works like
            rpmdb.simpleVersion(main_only=True)[0], but for the state the rpmdb
            will be in after the transaction. RD   t   checksum_typet   checksum_dataN(   R<   R|   R[   R;   Rë   R£   Rá   RZ   Rq   t   preloadPackageChecksumsR   Ra   R!   t   returnIdSumRg   R—   t
   yumdb_infoR÷   R◊   t    transactionCachePackageChecksums(	   R   RÅ   t   _reinstalled_pkgtupsRd   t   maint   pkg_checksum_tupsRÇ   t   csumt   ydbi(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   futureRpmDBVersionj  s6    			c         C   s{   xt | j  j D]f } x] |  j j d | É D]F } | j | j  g É r) |  j | | j  É t | _ t | j  _ q) q) Wq Wd S(   s>   addObsoleted() pkgs for anything that this txmbr will obsoleteR(   N(	   Rá   t   obsoletes_namesR<   t   searchNevrat   obsoletedByR    R®   RU   Rö   (   R   Rd   t   obs_nRÇ   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRµ   ó  s    	N(   NNN(   NNN(   NNN(   NNN(   NNN(   NNN()   R)   R*   t   __doc__R   RN   RO   RT   R;   R[   RQ   Rb   Re   R+   Ri   Ru   Rp   RÖ   Râ   Rå   Rñ   R~   Rú   Rû   RÆ   R∂   R∞   R∑   Rπ   RΩ   Ré   Rƒ   R    RÀ   R–   R“   RÃ   R‘   R’   R”   R·   Rµ   (    (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR,   I   sJ   	"						!			&				O											-t   ConditionalTransactionDatac           B   s   e  Z d  Z d Ñ  Z RS(   s<   A transaction data implementing conditional package additionc         C   s$   t  j d t j É t j |  É d  S(   NsC   ConditionalTransactionData will go away in a future version of Yum.(   t   warningst   warnt   Errorst   YumFutureDeprecationWarningR,   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR   §  s    	
(   R)   R*   RÊ   R   (    (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRÁ   ¢  s   t   SortableTransactionDatac           B   sD   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s@   A transaction data implementing topological sort on it's membersc         C   s,   g  |  _  g  |  _ g  |  _ t j |  É d  S(   N(   t   _sortedt   patht   loopsR,   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR   ´  s    			c         C   s≠   |  j  j | j É t | _ xk | j D]` } |  j d | j É d } | j t k rg |  j | j É n  | j t	 k r& |  j
 | É q& q& Wt | _ |  j j d | j É d  S(   NRZ   i    (   RÓ   Rq   R(   t   TX_GREYt
   sortColourt
   depends_onRQ   RZ   t   _doLoopt   TX_WHITEt   _visitt   TX_BLACKRÌ   t   insert(   R   Rd   Rá   t   vertex(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRı   ¥  s    		c         C   sY   |  j  j | É |  j  |  j  j |  j  d É } t | É d k rU |  j j | É n  d  S(   Niˇˇˇˇi   (   RÓ   Rq   t   indexRM   RÔ   (   R   R(   t   loop(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRÛ   ¿  s     c         C   s&   t  | _ t j |  | É g  |  _ d  S(   N(   RÙ   RÒ   R,   Rñ   RÌ   (   R   Rà   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRñ   ∆  s    	c         C   s   t  j |  | É g  |  _ d  S(   N(   R,   R~   RÌ   (   R   RZ   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR~   À  s    c         C   sl   |  j  r |  j  Sg  |  _  x< |  j É  D]. } | j t k r& g  |  _ |  j | É q& q& W|  j  j É  |  j  S(   N(   RÌ   RQ   RÒ   RÙ   RÓ   Rı   t   reverse(   R   Rd   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR™   œ  s    			(	   R)   R*   RÊ   R   Rı   RÛ   Rñ   R~   R™   (    (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRÏ   ©  s   						R±   c           B   sP   e  Z d  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(	   sV   Class to describe a Transaction Member (a pkg to be installed/
       updated/erased).c         C   s3  | |  _  d  |  _ d  |  _ d  |  _ d |  _ d |  _ d  |  _ g  |  _ g  |  _	 g  |  _
 g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ t |  _ g  |  _ d d d d d d d	 g |  _ x3 |  j D]( } t |  j  | É } t |  | | É q¡ W| j d
 k r/| j j d É | j j d É | j j d É n  d  S(   Ni    RØ   RZ   R!   R(   Rj   Rk   RŒ   t   releaseRD   t	   from_repot
   releasevert
   changed_by(   Rá   R;   R≥   Rr   RU   R†   R¥   t   processR∏   RÚ   R√   R«   Rç   R¡   R§   Rß   R+   R£   R•   t   _poattrt   getattrt   setattrR!   R⁄   Rv   (   R   Rá   t   attrt   val(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR   ‡  s4    																	c         C   s<   d |  _  | r8 |  j j | d f É |  j j | É n  d S(   sl   sets the transaction member as a dependency and maps the dep into the
           relationship list attributei   t	   dependsonN(   R†   R∏   Rq   RÚ   (   R   Rá   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyRï     s    	c         C   s   t  |  j | j É S(   N(   t   cmpRá   (   R   t   other(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   __cmp__  s    c         C   s   t  j |  É S(   N(   t   objectt   __hash__(   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR    s    c         C   s,   d |  j  |  j |  j |  j |  j |  j f S(   Ns   %s.%s %s:%s-%s - %s(   R(   Rj   Rk   RŒ   R¸   Rr   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   __str__  s    c         C   s)   d |  j  j t |  É t t |  É É f S(   Ns   <%s : %s (%s)>(   t	   __class__R)   t   strt   hext   id(   R   (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   __repr__  s    c      
   C   s  d |  j  |  j |  j |  j |  j |  j f } | d |  j j j 7} | d |  j	 7} | d |  j
 7} | d t |  j É 7} | d |  j 7} | d t |  j É 7} |  j r0| d 7} xg |  j D]\ \ } } d	 } t | t É rÌ d
 } n  | d | j  | j | j | j | j | | f 7} q√ W| d 7} n  x± d d d d d d d g D]î } t |  | É } | rL| d | 7} x[ | D]S } d	 } t | t É r†d
 } n  | d | j  | j | j | j | j | f 7} q|W| d 7} qLqLW|  j r
| d d j |  j É 7} n  | S(   Ns   mbr: %s,%s,%s,%s,%s %s
s     repo: %s
s     ts_state: %s
s     output_state: %s
s     isDep: %s
s     reason: %s
s     reinstall: %s
s     relatedto:Rx   Ro   s    %s,%s,%s,%s,%s@%s:%ss   
RÚ   R√   R«   R§   Rß   Rç   R¡   s     %s:s    %s,%s,%s,%s,%s@%ss     groups: %s
t    (   R(   Rj   Rk   RŒ   R¸   R≥   Rá   t   repoR  Rr   RU   t   boolR†   R¥   R£   R∏   RÜ   R   R  R•   t   join(   R   RS   Rá   Rm   t	   pkgorigint   lstt   thislist(    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   _dump  s@    	
			N(   R)   R*   RÊ   R   R;   Rï   R	  R  R  R  R  (    (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyR±   ‹  s   	"					(   RÊ   t	   constantst   packageSackR   R   t   packagesR   t
   sqlitesackR   RÍ   RË   R#   R   R,   RÁ   RÏ   R±   (    (    (    s7   /usr/lib/python2.7/dist-packages/yum/transactioninfo.pyt   <module>   s   
$ˇ ˇ [3                                                                                                                                                                           usr/lib/python2.7/dist-packages/yum/update_md.py                                                    0100644 0000000 0000000 00000047642 12451005146 020254  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -t
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University 
#
# Seth Vidal <skvidal@linux.duke.edu>
# Luke Macken <lmacken@redhat.com>

"""
Update metadata (updateinfo.xml) parsing.
"""

import sys

from yum.i18n import utf8_text_wrap, to_utf8, to_unicode
from yum.yumRepo import YumRepository
from yum.packages import FakeRepository
from yum.misc import to_xml, decompress, repo_gen_decompress
from yum.misc import cElementTree_iterparse as iterparse 
import Errors

import rpmUtils.miscutils


def safe_iterparse(filename):
    """ Works like iterparse, but hides XML errors (prints a warning). """
    try:
        for event, elem in iterparse(filename):
            yield event, elem
    except SyntaxError: # Bad XML
        print >> sys.stderr, "File is not valid XML:", filename

class UpdateNoticeException(Exception):
    """ An exception thrown for bad UpdateNotice data. """
    pass


class UpdateNotice(object):

    """
    A single update notice (for instance, a security fix).
    """

    def __init__(self, elem=None):
        self._md = {
            'from'             : '',
            'type'             : '',
            'title'            : '',
            'release'          : '',
            'status'           : '',
            'version'          : '',
            'pushcount'        : '',
            'update_id'        : '',
            'issued'           : '',
            'updated'          : '',
            'description'      : '',
            'rights'           : '',
            'severity'         : '',
            'summary'          : '',
            'solution'         : '',
            'references'       : [],
            'pkglist'          : [],
            'reboot_suggested' : False
        }

        if elem:
            self._parse(elem)

    def __getitem__(self, item):
        """ Allows scriptable metadata access (ie: un['update_id']). """
        return self._md.get(item) or None

    def __setitem__(self, item, val):
        self._md[item] = val

    def text(self, skip_data=('files', 'summary', 'rights', 'solution')):
        head = """
===============================================================================
  %(title)s
===============================================================================
  Update ID : %(update_id)s
    Release : %(release)s
       Type : %(type)s
     Status : %(status)s
     Issued : %(issued)s
""" % self._md

        if self._md['updated'] and self._md['updated'] != self._md['issued']:
            head += "    Updated : %s" % self._md['updated']

        # Add our bugzilla references
        bzs = filter(lambda r: r['type'] == 'bugzilla', self._md['references'])
        if len(bzs) and 'bugs' not in skip_data:
            buglist = "       Bugs :"
            for bz in bzs:
                buglist += " %s%s\n\t    :" % (bz['id'], 'title' in bz
                                               and ' - %s' % bz['title'] or '')
            head += buglist[: - 1].rstrip() + '\n'

        # Add our CVE references
        cves = filter(lambda r: r['type'] == 'cve', self._md['references'])
        if len(cves) and 'cves' not in skip_data:
            cvelist = "       CVEs :"
            for cve in cves:
                cvelist += " %s\n\t    :" % cve['id']
            head += cvelist[: - 1].rstrip() + '\n'

        if self._md['summary'] and 'summary' not in skip_data:
            data = utf8_text_wrap(self._md['summary'], width=64,
                                  subsequent_indent=' ' * 12 + ': ')
            head += "    Summary : %s\n" % '\n'.join(data)

        if self._md['description'] and 'description' not in skip_data:
            desc = utf8_text_wrap(self._md['description'], width=64,
                                  subsequent_indent=' ' * 12 + ': ')
            head += "Description : %s\n" % '\n'.join(desc)

        if self._md['solution'] and 'solution' not in skip_data:
            data = utf8_text_wrap(self._md['solution'], width=64,
                                  subsequent_indent=' ' * 12 + ': ')
            head += "   Solution : %s\n" % '\n'.join(data)

        if self._md['rights'] and 'rights' not in skip_data:
            data = utf8_text_wrap(self._md['rights'], width=64,
                                  subsequent_indent=' ' * 12 + ': ')
            head += "     Rights : %s\n" % '\n'.join(data)

        if self._md['severity'] and 'severity' not in skip_data:
            data = utf8_text_wrap(self._md['severity'], width=64,
                                  subsequent_indent=' ' * 12 + ': ')
            head += "   Severity : %s\n" % '\n'.join(data)

        if 'files' in skip_data:
            return head[:-1] # chop the last '\n'

        #  Get a list of arches we care about:
        #XXX ARCH CHANGE - what happens here if we set the arch - we need to
        # pass this in, perhaps
        arches = set(rpmUtils.arch.getArchList())

        filelist = "      Files :"
        for pkg in self._md['pkglist']:
            for file in pkg['packages']:
                if file['arch'] not in arches:
                    continue
                filelist += " %s\n\t    :" % file['filename']
        head += filelist[: - 1].rstrip()

        return head

    def __str__(self):
        return to_utf8(self.text())
    def __unicode__(self):
        return to_unicode(self.text())

    def get_metadata(self):
        """ Return the metadata dict. """
        return self._md

    def _parse(self, elem):
        """
        Parse an update element::

            <!ELEMENT update (id, synopsis?, issued, updated,
                              references, description, rights?,
                              severity?, summary?, solution?, pkglist)>
                <!ATTLIST update type (errata|security) "errata">
                <!ATTLIST update status (final|testing) "final">
                <!ATTLIST update version CDATA #REQUIRED>
                <!ATTLIST update from CDATA #REQUIRED>
        """
        if elem.tag == 'update':
            for attrib in ('from', 'type', 'status', 'version'):
                self._md[attrib] = elem.attrib.get(attrib)
            for child in elem:
                if child.tag == 'id':
                    if not child.text:
                        raise UpdateNoticeException("No id element found")
                    self._md['update_id'] = child.text
                elif child.tag == 'pushcount':
                    self._md['pushcount'] = child.text
                elif child.tag == 'issued':
                    self._md['issued'] = child.attrib.get('date')
                elif child.tag == 'updated':
                    self._md['updated'] = child.attrib.get('date')
                elif child.tag == 'references':
                    self._parse_references(child)
                elif child.tag == 'description':
                    self._md['description'] = child.text
                elif child.tag == 'rights':
                    self._md['rights'] = child.text
                elif child.tag == 'severity':
                    self._md[child.tag] = child.text
                elif child.tag == 'summary':
                    self._md['summary'] = child.text
                elif child.tag == 'solution':
                    self._md['solution'] = child.text
                elif child.tag == 'pkglist':
                    self._parse_pkglist(child)
                elif child.tag == 'title':
                    self._md['title'] = child.text
                elif child.tag == 'release':
                    self._md['release'] = child.text
        else:
            raise UpdateNoticeException('No update element found')

    def _parse_references(self, elem):
        """
        Parse the update references::

            <!ELEMENT references (reference*)>
            <!ELEMENT reference>
                <!ATTLIST reference href CDATA #REQUIRED>
                <!ATTLIST reference type (self|other|cve|bugzilla) "self">
                <!ATTLIST reference id CDATA #IMPLIED>
                <!ATTLIST reference title CDATA #IMPLIED>
        """
        for reference in elem:
            if reference.tag == 'reference':
                data = {}
                for refattrib in ('id', 'href', 'type', 'title'):
                    data[refattrib] = reference.attrib.get(refattrib)
                self._md['references'].append(data)
            else:
                raise UpdateNoticeException('No reference element found')

    def _parse_pkglist(self, elem):
        """
        Parse the package list::

            <!ELEMENT pkglist (collection+)>
            <!ELEMENT collection (name?, package+)>
                <!ATTLIST collection short CDATA #IMPLIED>
                <!ATTLIST collection name CDATA #IMPLIED>
            <!ELEMENT name (#PCDATA)>
        """
        for collection in elem:
            data = { 'packages' : [] }
            if 'short' in collection.attrib:
                data['short'] = collection.attrib.get('short')
            for item in collection:
                if item.tag == 'name':
                    data['name'] = item.text
                elif item.tag == 'package':
                    data['packages'].append(self._parse_package(item))
            self._md['pkglist'].append(data)

    def _parse_package(self, elem):
        """
        Parse an individual package::

            <!ELEMENT package (filename, sum, reboot_suggested)>
                <!ATTLIST package name CDATA #REQUIRED>
                <!ATTLIST package version CDATA #REQUIRED>
                <!ATTLIST package release CDATA #REQUIRED>
                <!ATTLIST package arch CDATA #REQUIRED>
                <!ATTLIST package epoch CDATA #REQUIRED>
                <!ATTLIST package src CDATA #REQUIRED>
            <!ELEMENT reboot_suggested (#PCDATA)>
            <!ELEMENT filename (#PCDATA)>
            <!ELEMENT sum (#PCDATA)>
                <!ATTLIST sum type (md5|sha1) "sha1">
        """
        package = {}
        for pkgfield in ('arch', 'epoch', 'name', 'version', 'release', 'src'):
            package[pkgfield] = elem.attrib.get(pkgfield)

        #  Bad epoch and arch data is the most common (missed) screwups.
        # Deal with bad epoch data.
        if not package['epoch'] or package['epoch'][0] not in '0123456789':
            package['epoch'] = None

        for child in elem:
            if child.tag == 'filename':
                package['filename'] = child.text
            elif child.tag == 'sum':
                package['sum'] = (child.attrib.get('type'), child.text)
            elif child.tag == 'reboot_suggested':
                self._md['reboot_suggested'] = True
        return package

    def xml(self):
        """Generate the xml for this update notice object"""
        msg = """
<update from="%s" status="%s" type="%s" version="%s">
  <id>%s</id>
  <title>%s</title>
  <release>%s</release>
  <issued date="%s"/>
  <description>%s</description>\n""" % (to_xml(self._md['from']),
                to_xml(self._md['status']), to_xml(self._md['type']),
                to_xml(self._md['version']), to_xml(self._md['update_id']),
                to_xml(self._md['title']), to_xml(self._md['release']),
                to_xml(self._md['issued'], attrib=True),
                to_xml(self._md['description']))

        if self._md['summary']:
            msg += """  <summary>%s</summary>\n""" % (to_xml(self._md['summary']))
        if self._md['solution']:
            msg += """  <solution>%s</solution>\n""" % (to_xml(self._md['solution']))
        if self._md['rights']:
            msg += """  <rights>%s</rights>\n""" % (to_xml(self._md['rights']))        
        if self._md['severity']:
            msg += """  <severity>%s</severity>\n""" % (to_xml(self._md['severity']))

        if self._md['references']:
            msg += """  <references>\n"""
            for ref in self._md['references']:
                if ref['title']:
                    msg += """    <reference href="%s" id="%s" title="%s" type="%s"/>\n""" % (
                    to_xml(ref['href'], attrib=True), to_xml(ref['id'], attrib=True),
                    to_xml(ref['title'], attrib=True), to_xml(ref['type'], attrib=True))
                else:
                    msg += """    <reference href="%s" id="%s"  type="%s"/>\n""" % (
                    to_xml(ref['href'], attrib=True), to_xml(ref['id'], attrib=True),
                    to_xml(ref['type'], attrib=True))

            msg += """  </references>\n"""
        
        if self._md['pkglist']:
            msg += """  <pkglist>\n"""
            for coll in self._md['pkglist']:
                msg += """    <collection short="%s">\n      <name>%s</name>\n""" % (
                      to_xml(coll['short'], attrib=True),
                      to_xml(coll['name']))
  
                for pkg in coll['packages']:
                    msg += """      <package arch="%s" name="%s" release="%s" src="%s" version="%s">
        <filename>%s</filename>
      </package>\n""" % (to_xml(pkg['arch'], attrib=True),
                                to_xml(pkg['name'], attrib=True),
                                to_xml(pkg['release'], attrib=True),
                                to_xml(pkg['src'], attrib=True),
                                to_xml(pkg['version'], attrib=True),
                                to_xml(pkg['filename']))
                msg += """    </collection>\n"""
                msg += """  </pkglist>\n"""
        msg += """</update>\n"""
        return msg

def _rpm_tup_vercmp(tup1, tup2):
    """ Compare two "std." tuples, (n, a, e, v, r). """
    return rpmUtils.miscutils.compareEVR((tup1[2], tup1[3], tup1[4]),
                                         (tup2[2], tup2[3], tup2[4]))

class UpdateMetadata(object):

    """
    The root update metadata object.
    """

    def __init__(self, repos=[]):
        self._notices = {}
        self._cache = {}    # a pkg nvr => notice cache for quick lookups
        self._no_cache = {}    # a pkg name only => notice list
        self._repos = []    # list of repo ids that we've parsed
        for repo in repos:
            try: # attempt to grab the updateinfo.xml.gz from the repodata
                self.add(repo)
            except Errors.RepoMDError:
                continue # No metadata found for this repo

    def get_notices(self, name=None):
        """ Return all notices. """
        if name is None:
            return self._notices.values()
        return name in self._no_cache and self._no_cache[name] or []

    notices = property(get_notices)

    def get_notice(self, nvr):
        """
        Retrieve an update notice for a given (name, version, release) string
        or tuple.
        """
        if type(nvr) in (type([]), type(())):
            nvr = '-'.join(nvr)
        return self._cache.get(nvr) or None

    #  The problem with the above "get_notice" is that not everyone updates
    # daily. So if you are at pkg-1, pkg-2 has a security notice, and pkg-3
    # has a BZ fix notice. All you can see is the BZ notice for the new "pkg-3"
    # with the above.
    #  So now instead you lookup based on the _installed_ pkg.pkgtup, and get
    # two notices, in order: [(pkgtup-3, notice), (pkgtup-2, notice)]
    # the reason for the sorting order is that the first match will give you
    # the minimum pkg you need to move to.
    def get_applicable_notices(self, pkgtup):
        """
        Retrieve any update notices which are newer than a
        given std. pkgtup (name, arch, epoch, version, release) tuple.
        Returns: list of (pkgtup, notice) that are newer than the given pkgtup,
                 in the order of newest pkgtups first.
        """
        oldpkgtup = pkgtup
        name = oldpkgtup[0]
        arch = oldpkgtup[1]
        ret = []
        for notice in self.get_notices(name):
            for upkg in notice['pkglist']:
                for pkg in upkg['packages']:
                    if pkg['name'] != name or pkg['arch'] != arch:
                        continue
                    pkgtup = (pkg['name'], pkg['arch'], pkg['epoch'] or '0',
                              pkg['version'], pkg['release'])
                    if _rpm_tup_vercmp(pkgtup, oldpkgtup) <= 0:
                        continue
                    ret.append((pkgtup, notice))
        ret.sort(cmp=_rpm_tup_vercmp, key=lambda x: x[0], reverse=True)
        return ret

    def add_notice(self, un):
        """ Add an UpdateNotice object. This should be fully populated with
            data, esp. update_id and pkglist/packages. """
        if not un or not un["update_id"] or un['update_id'] in self._notices:
            return

        self._notices[un['update_id']] = un
        for pkg in un['pkglist']:
            for filedata in pkg['packages']:
                self._cache['%s-%s-%s' % (filedata['name'],
                                          filedata['version'],
                                          filedata['release'])] = un
                no = self._no_cache.setdefault(filedata['name'], set())
                no.add(un)

    def add(self, obj, mdtype='updateinfo'):
        """ Parse a metadata from a given YumRepository, file, or filename. """
        if not obj:
            raise UpdateNoticeException
        if type(obj) in (type(''), type(u'')):
            unfile = decompress(obj)
            infile = open(unfile, 'rt')

        elif isinstance(obj, YumRepository):
            if obj.id not in self._repos:
                self._repos.append(obj.id)
                md = obj.retrieveMD(mdtype)
                if not md:
                    raise UpdateNoticeException()
                unfile = repo_gen_decompress(md, 'updateinfo.xml')
                infile = open(unfile, 'rt')
        elif isinstance(obj, FakeRepository):
            raise Errors.RepoMDError, "No updateinfo for local pkg"
        else:   # obj is a file object
            infile = obj

        for event, elem in safe_iterparse(infile):
            if elem.tag == 'update':
                try:
                    un = UpdateNotice(elem)
                except UpdateNoticeException, e:
                    print >> sys.stderr, "An update notice is broken, skipping."
                    # what else should we do?
                    continue
                self.add_notice(un)

    def __unicode__(self):
        ret = u''
        for notice in self.notices:
            ret += unicode(notice)
        return ret
    def __str__(self):
        return to_utf8(self.__unicode__())

    def xml(self, fileobj=None):
        msg = """<?xml version="1.0"?>\n<updates>"""
        if fileobj:
            fileobj.write(msg)

        for notice in self._notices.values():
            if fileobj:
                fileobj.write(notice.xml())
            else:
                msg += notice.xml()

        end = """</updates>\n"""
        if fileobj:
            fileobj.write(end)
        else:
            msg += end

        if fileobj:
            return

        return msg


def main():
    """ update_md test function. """
    import yum.misc

    yum.misc.setup_locale()
    def usage():
        print >> sys.stderr, "Usage: %s <update metadata> ..." % sys.argv[0]
        sys.exit(1)

    if len(sys.argv) < 2:
        usage()

    try:
        print sys.argv[1]
        um = UpdateMetadata()
        for srcfile in sys.argv[1:]:
            um.add(srcfile)
        print unicode(um)
    except IOError:
        print >> sys.stderr, "%s: No such file:\'%s\'" % (sys.argv[0],
                                                          sys.argv[1:])
        usage()

if __name__ == '__main__':
    main()
                                                                                              usr/lib/python2.7/dist-packages/yum/update_md.pyc                                                   0100644 0000000 0000000 00000043363 13077704344 020426  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   s	  d  Z  d d l Z d d l m Z m Z m Z d d l m Z d d l m	 Z	 d d l
 m Z m Z m Z d d l
 m Z d d l Z d d l Z d Ñ  Z d	 e f d
 Ñ  É  YZ d e f d Ñ  É  YZ d Ñ  Z d e f d Ñ  É  YZ d Ñ  Z e d k re É  n  d S(   s+   
Update metadata (updateinfo.xml) parsing.
iˇˇˇˇN(   t   utf8_text_wrapt   to_utf8t
   to_unicode(   t   YumRepository(   t   FakeRepository(   t   to_xmlt
   decompresst   repo_gen_decompress(   t   cElementTree_iterparsec         c   sW   y, x% t  |  É D] \ } } | | f Vq WWn$ t k
 rR t j d I|  IJn Xd S(   s@    Works like iterparse, but hides XML errors (prints a warning). s   File is not valid XML:N(   t	   iterparset   SyntaxErrort   syst   stderr(   t   filenamet   eventt   elem(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   safe_iterparse$   s
    t   UpdateNoticeExceptionc           B   s   e  Z d  Z RS(   s0    An exception thrown for bad UpdateNotice data. (   t   __name__t
   __module__t   __doc__(    (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyR   ,   s   t   UpdateNoticec           B   sÄ   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z d	 Ñ  Z d
 Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s@   
    A single update notice (for instance, a security fix).
    c         C   s°   i d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d	 6d d
 6d d 6d d 6d d 6d d 6d d 6d d 6g  d 6g  d 6t  d 6|  _ | rù |  j | É n  d  S(   Nt    t   fromt   typet   titlet   releaset   statust   versiont	   pushcountt	   update_idt   issuedt   updatedt   descriptiont   rightst   severityt   summaryt   solutiont
   referencest   pkglistt   reboot_suggested(   t   Falset   _mdt   _parse(   t   selfR   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   __init__7   s*    c         C   s   |  j  j | É p d S(   s:    Allows scriptable metadata access (ie: un['update_id']). N(   R*   t   gett   None(   R,   t   item(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   __getitem__P   s    c         C   s   | |  j  | <d  S(   N(   R*   (   R,   R0   t   val(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   __setitem__T   s    t   filesR$   R"   R%   c         C   så  d |  j  } |  j  d rL |  j  d |  j  d k rL | d |  j  d 7} n  t d Ñ  |  j  d É } t | É r· d | k r· d } x@ | D]8 } | d	 | d
 d | k r∑ d | d p∫ d f 7} qä W| | d  j É  d 7} n  t d Ñ  |  j  d É } t | É rVd | k rVd } x  | D] } | d | d
 7} qW| | d  j É  d 7} n  |  j  d r®d | k r®t |  j  d d d d d+ É}	 | d d j |	 É 7} n  |  j  d r˙d | k r˙t |  j  d d d d d- É}
 | d d j |
 É 7} n  |  j  d rLd | k rLt |  j  d d d d d/ É}	 | d d j |	 É 7} n  |  j  d  rûd  | k rût |  j  d  d d d d1 É}	 | d! d j |	 É 7} n  |  j  d" rd" | k rt |  j  d" d d d d3 É}	 | d# d j |	 É 7} n  d$ | k r| d  St t j j	 É  É } d% } xR |  j  d& D]C } x: | d' D]. } | d( | k rZq>n  | d | d) 7} q>Wq-W| | d  j É  7} | S(4   Ns,  
===============================================================================
  %(title)s
===============================================================================
  Update ID : %(update_id)s
    Release : %(release)s
       Type : %(type)s
     Status : %(status)s
     Issued : %(issued)s
R    R   s       Updated : %sc         S   s   |  d d k S(   NR   t   bugzilla(    (   t   r(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   <lambda>g   s    R&   t   bugss          Bugs :s    %s%s
	    :t   idR   s    - %sR   iˇˇˇˇs   
c         S   s   |  d d k S(   NR   t   cve(    (   R6   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyR7   p   s    t   cvess          CVEs :s
    %s
	    :R$   t   widthi@   t   subsequent_indentt    i   s   : s       Summary : %s
R!   s   Description : %s
R%   s      Solution : %s
R"   s        Rights : %s
R#   s      Severity : %s
R4   s         Files :R'   t   packagest   archR   s               s               : s               s               : s               s               : s               s               : s               s               : (
   R*   t   filtert   lent   rstripR    t   joint   sett   rpmUtilsR@   t   getArchList(   R,   t	   skip_datat   headt   bzst   buglistt   bzR;   t   cvelistR:   t   datat   desct   archest   filelistt   pkgt   file(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   textW   s^    
'					c         C   s   t  |  j É  É S(   N(   R   RT   (   R,   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   __str__¢   s    c         C   s   t  |  j É  É S(   N(   R   RT   (   R,   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   __unicode__§   s    c         C   s   |  j  S(   s    Return the metadata dict. (   R*   (   R,   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   get_metadataß   s    c         C   s>  | j  d k r.x' d D] } | j j | É |  j | <q Wx˛| D]Á} | j  d k rÄ | j sm t d É Ç n  | j |  j d <q@ | j  d	 k r¢ | j |  j d	 <q@ | j  d
 k rÕ | j j d É |  j d
 <q@ | j  d k r¯ | j j d É |  j d <q@ | j  d k r|  j | É q@ | j  d k r9| j |  j d <q@ | j  d k r[| j |  j d <q@ | j  d k rÄ| j |  j | j  <q@ | j  d k r¢| j |  j d <q@ | j  d k rƒ| j |  j d <q@ | j  d k r„|  j | É q@ | j  d k r| j |  j d <q@ | j  d k r@ | j |  j d <q@ q@ Wn t d É Ç d S(   sÊ  
        Parse an update element::

            <!ELEMENT update (id, synopsis?, issued, updated,
                              references, description, rights?,
                              severity?, summary?, solution?, pkglist)>
                <!ATTLIST update type (errata|security) "errata">
                <!ATTLIST update status (final|testing) "final">
                <!ATTLIST update version CDATA #REQUIRED>
                <!ATTLIST update from CDATA #REQUIRED>
        t   updateR   R   R   R   R9   s   No id element foundR   R   R   t   dateR    R&   R!   R"   R#   R$   R%   R'   R   R   s   No update element foundN(   s   froms   types   statuss   version(   t   tagt   attribR.   R*   RT   R   t   _parse_referencest   _parse_pkglist(   R,   R   R[   t   child(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyR+   ´   sB    	c         C   st   xm | D]e } | j  d k r` i  } x$ d	 D] } | j j | É | | <q) W|  j d j | É q t d É Ç q Wd S(
   sv  
        Parse the update references::

            <!ELEMENT references (reference*)>
            <!ELEMENT reference>
                <!ATTLIST reference href CDATA #REQUIRED>
                <!ATTLIST reference type (self|other|cve|bugzilla) "self">
                <!ATTLIST reference id CDATA #IMPLIED>
                <!ATTLIST reference title CDATA #IMPLIED>
        t	   referenceR9   t   hrefR   R   R&   s   No reference element foundN(   s   idR`   s   types   title(   RZ   R[   R.   R*   t   appendR   (   R,   R   R_   RN   t	   refattrib(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyR\   ⁄   s    c         C   s∫   x≥ | D]´ } i g  d 6} d | j  k rB | j  j d É | d <n  xY | D]Q } | j d k rn | j | d <qI | j d k rI | d j |  j | É É qI qI W|  j d j | É q Wd S(   s'  
        Parse the package list::

            <!ELEMENT pkglist (collection+)>
            <!ELEMENT collection (name?, package+)>
                <!ATTLIST collection short CDATA #IMPLIED>
                <!ATTLIST collection name CDATA #IMPLIED>
            <!ELEMENT name (#PCDATA)>
        R?   t   shortt   namet   packageR'   N(   R[   R.   RZ   RT   Ra   t   _parse_packageR*   (   R,   R   t
   collectionRN   R0   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyR]   Ó   s    
!c         C   s›   i  } x$ d D] } | j  j | É | | <q W| d sL | d d d k rY d | d <n  x} | D]u } | j d	 k rÖ | j | d	 <q` | j d
 k r∂ | j  j d É | j f | d
 <q` | j d k r` t |  j d <q` q` W| S(   s~  
        Parse an individual package::

            <!ELEMENT package (filename, sum, reboot_suggested)>
                <!ATTLIST package name CDATA #REQUIRED>
                <!ATTLIST package version CDATA #REQUIRED>
                <!ATTLIST package release CDATA #REQUIRED>
                <!ATTLIST package arch CDATA #REQUIRED>
                <!ATTLIST package epoch CDATA #REQUIRED>
                <!ATTLIST package src CDATA #REQUIRED>
            <!ELEMENT reboot_suggested (#PCDATA)>
            <!ELEMENT filename (#PCDATA)>
            <!ELEMENT sum (#PCDATA)>
                <!ATTLIST sum type (md5|sha1) "sha1">
        R@   t   epochRd   R   R   t   srci    t
   0123456789R   t   sumR   R(   (   s   archRh   s   names   versions   releaseRi   N(   R[   R.   R/   RZ   RT   t   TrueR*   (   R,   R   Re   t   pkgfieldR^   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyRf     s    "c         C   sG  d t  |  j d É t  |  j d É t  |  j d É t  |  j d É t  |  j d É t  |  j d É t  |  j d É t  |  j d	 d
 t Ét  |  j d É f	 } |  j d rÀ | d t  |  j d É 7} n  |  j d rˆ | d t  |  j d É 7} n  |  j d r!| d t  |  j d É 7} n  |  j d rL| d t  |  j d É 7} n  |  j d r6| d 7} x√ |  j d D]¥ } | d rﬁ| d t  | d d
 t Ét  | d d
 t Ét  | d d
 t Ét  | d d
 t Éf 7} qq| d t  | d d
 t Ét  | d d
 t Ét  | d d
 t Éf 7} qqW| d 7} n  |  j d r9| d 7} xÈ |  j d D]◊ } | d t  | d d
 t Ét  | d É f 7} xå | d  D]Ä } | d! t  | d" d
 t Ét  | d d
 t Ét  | d d
 t Ét  | d# d
 t Ét  | d d
 t Ét  | d$ É f 7} qöW| d% 7} | d& 7} q[Wn  | d' 7} | S((   s.   Generate the xml for this update notice objectsß   
<update from="%s" status="%s" type="%s" version="%s">
  <id>%s</id>
  <title>%s</title>
  <release>%s</release>
  <issued date="%s"/>
  <description>%s</description>
R   R   R   R   R   R   R   R   R[   R!   R$   s     <summary>%s</summary>
R%   s     <solution>%s</solution>
R"   s     <rights>%s</rights>
R#   s     <severity>%s</severity>
R&   s     <references>
s8       <reference href="%s" id="%s" title="%s" type="%s"/>
R`   R9   s.       <reference href="%s" id="%s"  type="%s"/>
s     </references>
R'   s     <pkglist>
s2       <collection short="%s">
      <name>%s</name>
Rc   Rd   R?   sx         <package arch="%s" name="%s" release="%s" src="%s" version="%s">
        <filename>%s</filename>
      </package>
R@   Ri   R   s       </collection>
s     </pkglist>
s
   </update>
(   R   R*   Rl   (   R,   t   msgt   reft   collRR   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   xml%  sV       

&1&


N(   s   filess   summarys   rightss   solution(   R   R   R   R/   R-   R1   R3   RT   RU   RV   RW   R+   R\   R]   Rf   Rq   (    (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyR   1   s   		K				/			"c         C   s=   t  j j |  d |  d |  d f | d | d | d f É S(   s-    Compare two "std." tuples, (n, a, e, v, r). i   i   i   (   RF   t	   miscutilst
   compareEVR(   t   tup1t   tup2(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   _rpm_tup_vercmp`  s    !t   UpdateMetadatac           B   sw   e  Z d  Z g  d Ñ Z d d Ñ Z e e É Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d d Ñ Z d Ñ  Z d	 Ñ  Z d d
 Ñ Z RS(   s*   
    The root update metadata object.
    c         C   sd   i  |  _  i  |  _ i  |  _ g  |  _ x9 | D]1 } y |  j | É Wq+ t j k
 r[ q+ q+ Xq+ Wd  S(   N(   t   _noticest   _cachet	   _no_cachet   _repost   addt   Errorst   RepoMDError(   R,   t   repost   repo(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyR-   k  s    				c         C   s9   | d k r |  j j É  S| |  j k r5 |  j | p8 g  S(   s    Return all notices. N(   R/   Rx   t   valuesRz   (   R,   Rd   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   get_noticesv  s    c         C   sL   t  | É t  g  É t  d É f k r6 d j | É } n  |  j j | É pK d S(   si   
        Retrieve an update notice for a given (name, version, release) string
        or tuple.
        t   -(    N(   R   RD   Ry   R.   R/   (   R,   t   nvr(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt
   get_notice~  s    $c   	   	   C   s
  | } | d } | d } g  } xƒ |  j  | É D]≥ } x™ | d D]û } xï | d D]â } | d | k sR | d | k r~ qR n  | d | d | d pô d | d	 | d
 f } t | | É d k r» qR n  | j | | f É qR WqA Wq0 W| j d t d d Ñ  d t É | S(   s  
        Retrieve any update notices which are newer than a
        given std. pkgtup (name, arch, epoch, version, release) tuple.
        Returns: list of (pkgtup, notice) that are newer than the given pkgtup,
                 in the order of newest pkgtups first.
        i    i   R'   R?   Rd   R@   Rh   t   0R   R   t   cmpt   keyc         S   s   |  d S(   Ni    (    (   t   x(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyR7   §  s    t   reverse(   RÇ   Rv   Ra   t   sortRl   (	   R,   t   pkgtupt	   oldpkgtupRd   R@   t   rett   noticet   upkgRR   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   get_applicable_noticesè  s     

 c      	   C   s∑   | s% | d s% | d |  j  k r) d S| |  j  | d <xv | d D]j } xa | d D]U } | |  j d | d | d | d f <|  j j | d t É  É } | j | É qV WqE Wd S(	   sx    Add an UpdateNotice object. This should be fully populated with
            data, esp. update_id and pkglist/packages. R   NR'   R?   s   %s-%s-%sRd   R   R   (   Rx   Ry   Rz   t
   setdefaultRE   R|   (   R,   t   unRR   t   filedatat   no(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt
   add_noticeß  s    %&t
   updateinfoc   
      C   sd  | s t  Ç n  t | É t d É t d É f k rQ t | É } t | d É } nù t | t É r  | j |  j k rÓ |  j j | j É | j	 | É } | s¶ t  É  Ç n  t
 | d É } t | d É } qÓ n$ t | t É rË t j d Ç n | } xo t | É D]a \ } } | j d k r˚ y t | É } Wn# t  k
 rK}	 t j d IJq˚ n X|  j | É q˚ q˚ Wd S(	   sA    Parse a metadata from a given YumRepository, file, or filename. R   u    t   rts   updateinfo.xmls   No updateinfo for local pkgRX   s%   An update notice is broken, skipping.N(   R   R   R   t   opent
   isinstanceR   R9   R{   Ra   t
   retrieveMDR   R   R}   R~   R   RZ   R   R   R   Rñ   (
   R,   t   objt   mdtypet   unfilet   infilet   mdR   R   Rì   t   e(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyR|   ∂  s0    	$c         C   s.   d } x! |  j  D] } | t | É 7} q W| S(   Nu    (   t   noticest   unicode(   R,   Ré   Rè   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyRV   ’  s    c         C   s   t  |  j É  É S(   N(   R   RV   (   R,   (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyRU   ⁄  s    c         C   sñ   d } | r | j  | É n  xC |  j j É  D]2 } | rN | j  | j É  É q, | | j É  7} q, Wd } | r~ | j  | É n
 | | 7} | rí d  S| S(   Ns   <?xml version="1.0"?>
<updates>s   </updates>
(   t   writeRx   RÅ   Rq   (   R,   t   fileobjRn   Rè   t   end(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyRq   ›  s    
N(   R   R   R   R-   R/   RÇ   t   propertyR¢   RÖ   Rë   Rñ   R|   RV   RU   Rq   (    (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyRw   e  s   					c          C   sŒ   d d l  }  |  j j É  d Ñ  } t t j É d k  rA | É  n  yI t j d GHt É  } x" t j d D] } | j | É qg Wt | É GHWn= t	 k
 r… t j
 d t j d t j d f IJ| É  n Xd S(   s    update_md test function. iˇˇˇˇNc           S   s)   t  j d t  j d IJt  j d É d  S(   Ns   Usage: %s <update metadata> ...i    i   (   R   R   t   argvt   exit(    (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   usage˘  s    i   i   s   %s: No such file:'%s'i    (   t   yum.misct   misct   setup_localeRB   R   R®   Rw   R|   R£   t   IOErrorR   (   t   yumR™   t   umt   srcfile(    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   mainÙ  s    	
	t   __main__(   R   R   t   yum.i18nR    R   R   t   yum.yumRepoR   t   yum.packagesR   R´   R   R   R   R   R	   R}   t   rpmUtils.miscutilsRF   R   t	   ExceptionR   t   objectR   Rv   Rw   R≤   R   (    (    (    s1   /usr/lib/python2.7/dist-packages/yum/update_md.pyt   <module>   s"   	ˇ 0	è	                                                                                                                                                                                                                                                                             usr/lib/python2.7/dist-packages/yum/yumRepo.py                                                      0100644 0000000 0000000 00000221544 12451005146 017745  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University
# Copyright 2007 Red Hat
import os
import re
import time
import types
import urlparse

try:
    urlparse.uses_fragment.append("media")
except AttributeError, err:
    print err

import Errors
from urlgrabber.grabber import URLGrabber
from urlgrabber.grabber import default_grabber
import urlgrabber.mirror
from urlgrabber.grabber import URLGrabError
import repoMDObject
import packageSack
from repos import Repository
import parser
import sqlitecachec
import sqlitesack
from yum import config
from yum import misc
from yum import comps
from constants import *
import metalink

import logging
import logginglevels

import warnings

import glob
import shutil
import stat
import errno
import tempfile

#  If you want yum to _always_ check the MD .sqlite files then set this to
# False (this doesn't affect .xml files or .sqilte files derived from them).
# With this as True yum will only check when a new repomd.xml or
# new MD is downloaded.
#  Note that with atomic MD, we can't have old MD lying around anymore so
# the only way we need this check is if someone does something like:
#   cp primary.sqlite /var/cache/yum/blah
# ...at which point you lose.
skip_old_DBMD_check = True

warnings.simplefilter("ignore", Errors.YumFutureDeprecationWarning)

logger = logging.getLogger("yum.Repos")
verbose_logger = logging.getLogger("yum.verbose.Repos")

class YumPackageSack(packageSack.PackageSack):
    """imports/handles package objects from an mdcache dict object"""
    def __init__(self, packageClass):
        packageSack.PackageSack.__init__(self)
        self.pc = packageClass
        self.added = {}

    def __del__(self):
        self.close()

    def close(self):
        self.added = {}

    def addDict(self, repo, datatype, dataobj, callback=None):
        if repo in self.added:
            if datatype in self.added[repo]:
                return

        total = len(dataobj)
        if datatype == 'metadata':
            current = 0
            for pkgid in dataobj:
                current += 1
                if callback: callback.progressbar(current, total, repo)
                pkgdict = dataobj[pkgid]
                po = self.pc(repo, pkgdict)
                po.id = pkgid
                self._addToDictAsList(self.pkgsByID, pkgid, po)
                self.addPackage(po)

            if repo not in self.added:
                self.added[repo] = []
            self.added[repo].append('metadata')
            # indexes will need to be rebuilt
            self.indexesBuilt = 0

        elif datatype in ['filelists', 'otherdata']:
            if repo in self.added:
                if 'metadata' not in self.added[repo]:
                    raise Errors.RepoError, '%s md for %s imported before primary' \
                           % (datatype, repo.id)
            current = 0
            for pkgid in dataobj:
                current += 1
                if callback: callback.progressbar(current, total, repo)
                pkgdict = dataobj[pkgid]
                if pkgid in self.pkgsByID:
                    for po in self.pkgsByID[pkgid]:
                        po.importFromDict(pkgdict)

            self.added[repo].append(datatype)
            # indexes will need to be rebuilt
            self.indexesBuilt = 0
        else:
            # umm, wtf?
            pass

    def populate(self, repo, mdtype='metadata', callback=None, cacheonly=0):
        if mdtype == 'all':
            data = ['metadata', 'filelists', 'otherdata']
        else:
            data = [ mdtype ]

        if not hasattr(repo, 'cacheHandler'):
            repo.cacheHandler = sqlitecachec.RepodataParserSqlite(
                storedir=repo.cachedir,
                repoid=repo.id,
                callback=callback,
                )
        for item in data:
            if repo in self.added:
                if item in self.added[repo]:
                    continue

            db_fn = None

            if item == 'metadata':
                mydbtype = 'primary_db'
                mymdtype = 'primary'
                repo_get_function = repo.getPrimaryXML
                repo_cache_function = repo.cacheHandler.getPrimary

            elif item == 'filelists':
                mydbtype = 'filelists_db'
                mymdtype = 'filelists'
                repo_get_function = repo.getFileListsXML
                repo_cache_function = repo.cacheHandler.getFilelists

            elif item == 'otherdata':
                mydbtype = 'other_db'
                mymdtype = 'other'
                repo_get_function = repo.getOtherXML
                repo_cache_function = repo.cacheHandler.getOtherdata

            else:
                continue

            if self._check_db_version(repo, mydbtype):
                # see if we have the uncompressed db and check it's checksum vs the openchecksum
                # if not download the compressed file
                # decompress it
                # unlink it

                db_un_fn = self._check_uncompressed_db(repo, mydbtype)
                if not db_un_fn:
                    db_fn = repo._retrieveMD(mydbtype)
                    if db_fn:
                        if not repo.cache:
                            db_un_fn = misc.decompress(db_fn)
                            misc.unlink_f(db_fn)
                            db_un_fn = self._check_uncompressed_db(repo, mydbtype)

                dobj = repo.cacheHandler.open_database(db_un_fn)

            else:
                repo._xml2sqlite_local = True
                xml = repo_get_function()
                xmldata = repo.repoXML.getData(mymdtype)
                (ctype, csum) = xmldata.checksum
                dobj = repo_cache_function(xml, csum)

            if not cacheonly:
                self.addDict(repo, item, dobj, callback)
            del dobj


        # get rid of all this stuff we don't need now
        del repo.cacheHandler

    def _check_uncompressed_db(self, repo, mdtype):
        """return file name of uncompressed db is good, None if not"""
        mydbdata = repo.repoXML.getData(mdtype)
        (r_base, remote) = mydbdata.location
        fname = os.path.basename(remote)
        compressed_fn = repo.cachedir + '/' + fname
        db_un_fn = misc.decompress(compressed_fn, fn_only=True)

        result = None

        repo._preload_md_from_system_cache(os.path.basename(db_un_fn))
        if os.path.exists(db_un_fn):
            if skip_old_DBMD_check and repo._using_old_MD:
                return db_un_fn

            try:
                repo.checkMD(db_un_fn, mdtype, openchecksum=True)
            except URLGrabError:
                if not repo.cache:
                    misc.unlink_f(db_un_fn)
            else:
                result = db_un_fn

        return result

    def _check_db_version(self, repo, mdtype):
        return repo._check_db_version(mdtype)

class YumRepository(Repository, config.RepoConf):
    """
    This is an actual repository object

    Configuration attributes are pulled in from config.RepoConf.
    """

    def __init__(self, repoid):
        config.RepoConf.__init__(self)
        Repository.__init__(self, repoid)

        self.repofile = None
        self.mirrorurls = []
        self._urls = []
        self.enablegroups = 0
        self.groupsfilename = 'yumgroups.xml' # something some freaks might
                                              # eventually want
        self.repoMDFile = 'repodata/repomd.xml'
        self._repoXML = None
        self._using_old_MD = None
        self._oldRepoMDData = {}
        self.cache = 0
        self.mirrorlistparsed = 0
        self.yumvar = {} # empty dict of yumvariables for $string replacement
        self._proxy_dict = {}
        self.metadata_cookie_fn = 'cachecookie'
        self._metadataCurrent = None
        self._metalink = None
        self.groups_added = False
        self.http_headers = {}
        self.repo_config_age = 0 # if we're a repo not from a file then the
                                 # config is very, very old
        # throw in some stubs for things that will be set by the config class
        self.basecachedir = ""
        self.base_persistdir = ""
        self.cost = 1000
        self.copy_local = 0
        # holder for stuff we've grabbed
        self.retrieved = { 'primary':0, 'filelists':0, 'other':0, 'group':0,
                           'updateinfo':0, 'prestodelta' : 0}

        # callbacks
        self.callback = None  # for the grabber
        self.failure_obj = None
        self.mirror_failure_obj = None
        self.interrupt_callback = None
        self._callbacks_changed = False

        # callback function for handling media
        self.mediafunc = None

        # callbacks for gpg key importing and confirmation
        self.gpg_import_func = None
        self.gpgca_import_func = None
        self.confirm_func = None

        #  The reason we want to turn this off are things like repoids
        # called "tmp" in repoquery --repofrompath and/or new1/old1 in repodiff.
        self.timestamp_check = True

        self._sack = None

        self._grabfunc = None
        self._grab = None

    def __cmp__(self, other):
        """ Sort yum repos. by cost, and then by alphanumeric on their id. """
        if other is None:
            return 1
        if hasattr(other, 'cost'):
            ocost = other.cost
        else:
            ocost = 1000
        ret = cmp(self.cost, ocost)
        if ret:
            return ret
        return cmp(self.id, other.id)

    def _getSack(self):
        # FIXME: Note that having the repo hold the sack, which holds "repos"
        # is not only confusing but creates a circular dep.
        #  Atm. we don't leak memory because RepoStorage.close() is called,
        # which calls repo.close() which calls sack.close() which removes the
        # repos from the sack ... thus. breaking the cycle.
        if self._sack is None:
            self._sack = sqlitesack.YumSqlitePackageSack(
                sqlitesack.YumAvailablePackageSqlite)
        return self._sack
    sack = property(_getSack)

    def close(self):
        if self._sack is not None:
            self.sack.close()
        Repository.close(self)

    def _resetSack(self):
        self._sack = None

    def __getProxyDict(self):
        self.doProxyDict()
        if self._proxy_dict:
            return self._proxy_dict
        return None

    # consistent access to how proxy information should look (and ensuring
    # that it's actually determined for the repo)
    proxy_dict = property(__getProxyDict)

    def getPackageSack(self):
        """Returns the instance of this repository's package sack."""
        return self.sack


    def ready(self):
        """Returns true if this repository is setup and ready for use."""
        if hasattr(self, 'metadata_cookie'):
            return self.repoXML is not None
        return False


    def getGroupLocation(self):
        """Returns the location of the group."""
        if 'group_gz' in self.repoXML.fileTypes():
            thisdata = self.repoXML.getData('group_gz')
        else:
            thisdata = self.repoXML.getData('group')
        return thisdata.location

    def __str__(self):
        return self.id

    def _checksum(self, sumtype, file, CHUNK=2**16, checksum_can_fail=False,
                  datasize=None):
        """takes filename, hand back Checksum of it
           sumtype = md5 or sha
           filename = /path/to/file
           CHUNK=65536 by default"""
        try:
            return misc.checksum(sumtype, file, CHUNK, datasize)
        except (Errors.MiscError, EnvironmentError), e:
            if checksum_can_fail:
                return None
            raise Errors.RepoError, 'Error opening file for checksum: %s' % e

    def dump(self):
        output = '[%s]\n' % self.id
        # we exclude all vars which start with _ or are in this list:
        excluded_vars = ('mediafunc', 'sack', 'metalink_data', 'grab', 
                         'grabfunc', 'repoXML', 'cfg', 'retrieved',
                        'mirrorlistparsed', 'gpg_import_func', 
                        'gpgca_import_func', 'failure_obj',
                        'callback', 'confirm_func', 'groups_added', 
                        'interrupt_callback', 'id', 'mirror_failure_obj',
                        'repo_config_age', 'groupsfilename', 'copy_local', 
                        'basecachedir', 'http_headers', 'metadata_cookie',
                        'metadata_cookie_fn', 'quick_enable_disable',
                        'repoMDFile', 'timestamp_check', 'urls', 'mirrorurls',
                        'yumvar', 'repofile')
        for attr in dir(self):
            if attr.startswith('_'):
                continue
            if attr in excluded_vars:
                continue
            if isinstance(getattr(self, attr), types.MethodType):
                continue
            res = getattr(self, attr)
            if not res and type(res) not in (type(False), type(0)):
                res = ''
            if type(res) == types.ListType:
                res = ',\n   '.join(res)
            output = output + '%s = %s\n' % (attr, res)

        return output

    def enablePersistent(self):
        """Persistently enables this repository."""
        self.enable()
        try:
            config.writeRawRepoFile(self,only=['enabled'])
        except IOError, e:
            if e.errno == errno.EACCES:
                logger.warning(e)
            else:
                raise IOError, str(e)

    def disablePersistent(self):
        """Persistently disables this repository."""
        self.disable()
        try:
            config.writeRawRepoFile(self,only=['enabled'])
        except IOError, e:
            if e.errno == errno.EACCES:
                logger.warning(e)
            else:
                raise IOError, str(e)

    def check(self):
        """self-check the repo information  - if we don't have enough to move
           on then raise a repo error"""
        if len(self._urls) < 1 and not self.mediaid:
            raise Errors.RepoError, \
             'Cannot find a valid baseurl for repo: %s' % self.id

    def doProxyDict(self):
        if self._proxy_dict:
            return

        self._proxy_dict = {} # zap it
        proxy_string = None
        empty = (None, '_none_', '')
        if self.proxy not in empty:
            proxy_string = '%s' % self.proxy
            if self.proxy_username not in empty:
                proxy_parsed = urlparse.urlsplit(self.proxy, allow_fragments=0)
                proxy_proto = proxy_parsed[0]
                proxy_host = proxy_parsed[1]
                # http://foo:123 == ('http', 'foo:123', '', '', '')
                # don't turn that into: http://foo:123? - bug#328121
                if proxy_parsed[2] == '':
                    proxy_rest = ''
                else:
                    proxy_rest = proxy_parsed[2] + '?' + proxy_parsed[3]
                proxy_string = '%s://%s@%s%s' % (proxy_proto,
                        self.proxy_username, proxy_host, proxy_rest)

                if self.proxy_password not in empty:
                    proxy_string = '%s://%s:%s@%s%s' % (proxy_proto,
                              self.proxy_username, self.proxy_password,
                              proxy_host, proxy_rest)

        if proxy_string is not None:
            self._proxy_dict['http'] = proxy_string
            self._proxy_dict['https'] = proxy_string
            self._proxy_dict['ftp'] = proxy_string

    def __headersListFromDict(self, cache=True):
        """Convert our dict of headers to a list of 2-tuples for urlgrabber."""
        headers = []

        for key in self.http_headers:
            headers.append((key, self.http_headers[key]))
        if not (cache or 'Pragma' in self.http_headers):
            headers.append(('Pragma', 'no-cache'))

        return headers

    def setupGrab(self):
        warnings.warn('setupGrab() will go away in a future version of Yum.\n',
                Errors.YumFutureDeprecationWarning, stacklevel=2)
        self._setupGrab()

    def _setupGrab(self):
        """sets up the grabber functions with the already stocked in urls for
           the mirror groups"""

        if self.failovermethod == 'roundrobin':
            mgclass = urlgrabber.mirror.MGRandomOrder
        else:
            mgclass = urlgrabber.mirror.MirrorGroup

        ugopts = self._default_grabopts()
        self._grabfunc = URLGrabber(progress_obj=self.callback,
                                    failure_callback=self.failure_obj,
                                    interrupt_callback=self.interrupt_callback,
                                    copy_local=self.copy_local,
                                    reget='simple',
                                    **ugopts)

        self._grab = mgclass(self._grabfunc, self.urls,
                             failure_callback=self.mirror_failure_obj)

    def _default_grabopts(self, cache=True):
        opts = { 'keepalive': self.keepalive,
                 'bandwidth': self.bandwidth,
                 'retry': self.retries,
                 'throttle': self.throttle,
                 'proxies': self.proxy_dict,
                 'timeout': self.timeout,
                 'http_headers': tuple(self.__headersListFromDict(cache=cache)),
                 'ssl_verify_peer': self.sslverify,
                 'ssl_verify_host': self.sslverify,
                 'ssl_ca_cert': self.sslcacert,
                 'ssl_cert': self.sslclientcert,
                 'ssl_key': self.sslclientkey,
                 'user_agent': default_grabber.opts.user_agent,
                 'username': self.username,
                 'password': self.password,
                 }
        return opts

    def _getgrabfunc(self):
        if not self._grabfunc or self._callbacks_changed:
            self._setupGrab()
            self._callbacks_changed = False
        return self._grabfunc

    def _getgrab(self):
        if not self._grab or self._callbacks_changed:
            self._setupGrab()
            self._callbacks_changed = False
        return self._grab

    grabfunc = property(lambda self: self._getgrabfunc())
    grab = property(lambda self: self._getgrab())

    def _dirSetupMkdir_p(self, dpath):
        """make the necessary directory path, if possible, raise on failure"""
        if os.path.exists(dpath) and os.path.isdir(dpath):
            return

        if self.cache:
            raise Errors.RepoError, "Cannot access repository dir %s" % dpath

        try:
            os.makedirs(dpath, mode=0755)
        except OSError, e:
            msg = "%s: %s %s: %s" % ("Error making cache directory",
                                     dpath, "error was", e)
            raise Errors.RepoError, msg

    def dirSetup(self):
        """make the necessary dirs, if possible, raise on failure"""

        cachedir = os.path.join(self.basecachedir, self.id)
        persistdir = os.path.join(self.base_persistdir, self.id)
        pkgdir = os.path.join(cachedir, 'packages')
        hdrdir = os.path.join(cachedir, 'headers')
        self.setAttribute('_dir_setup_cachedir', cachedir)
        self.setAttribute('_dir_setup_pkgdir', pkgdir)
        self.setAttribute('_dir_setup_hdrdir', hdrdir)
        self.setAttribute('_dir_setup_persistdir', persistdir)
        ext=''
        if os.geteuid() != 0:
            ext = '-ro'
        self.setAttribute('_dir_setup_gpgdir', persistdir + '/gpgdir' + ext)
        self.setAttribute('_dir_setup_gpgcadir', persistdir + '/gpgcadir' + ext)

        cookie = self.cachedir + '/' + self.metadata_cookie_fn
        self.setAttribute('_dir_setup_metadata_cookie', cookie)

        for dir in [self.cachedir, self.pkgdir]:
            self._dirSetupMkdir_p(dir)

        # persistdir is really root-only but try the make anyway and just
        # catch the exception
        for dir in [self.persistdir]:
            try:
                self._dirSetupMkdir_p(dir)
            except Errors.RepoError, e:
                pass
                
        # if we're using a cachedir that's not the system one, copy over these
        # basic items from the system one
        self._preload_md_from_system_cache('repomd.xml')
        self._preload_md_from_system_cache('cachecookie')
        self._preload_md_from_system_cache('mirrorlist.txt')
        self._preload_md_from_system_cache('metalink.xml')

    def _dirGetAttr(self, attr):
        """ Make the directory attributes call .dirSetup() if needed. """
        attr = '_dir_setup_' + attr
        if not hasattr(self, attr):
            self.dirSetup()
        return getattr(self, attr)
    def _dirSetAttr(self, attr, val):
        """ Make the directory attributes call .dirSetup() if needed. """
        attr = '_dir_setup_' + attr
        if not hasattr(self, attr):
            self.dirSetup()

        if attr == '_dir_setup_pkgdir':
            if not hasattr(self, '_old_pkgdirs'):
                self._old_pkgdirs = []
            self._old_pkgdirs.append(getattr(self, attr))

        ret = setattr(self, attr, val)
        if attr in ('_dir_setup_pkgdir', ):
            self._dirSetupMkdir_p(val)
        return ret
    cachedir = property(lambda self: self._dirGetAttr('cachedir'))
    persistdir = property(lambda self: self._dirGetAttr('persistdir'))

    pkgdir   = property(lambda self: self._dirGetAttr('pkgdir'),
                        lambda self, x: self._dirSetAttr('pkgdir', x))
    hdrdir   = property(lambda self: self._dirGetAttr('hdrdir'),
                        lambda self, x: self._dirSetAttr('hdrdir', x))
    gpgdir   = property(lambda self: self._dirGetAttr('gpgdir'),
                        lambda self, x: self._dirSetAttr('gpgdir', x))
    gpgcadir   = property(lambda self: self._dirGetAttr('gpgcadir'),  
                        lambda self, x: self._dirSetAttr('gpgcadir', x))
    metadata_cookie = property(lambda self: self._dirGetAttr('metadata_cookie'))

    def baseurlSetup(self):
        warnings.warn('baseurlSetup() will go away in a future version of Yum.\n',
                Errors.YumFutureDeprecationWarning, stacklevel=2)
        self._baseurlSetup()

    def _hack_mirrorlist_for_anaconda(self):
        #  Anaconda doesn't like having mirrorlist and metalink, so we allow
        # mirrorlist to act like metalink. Except we'd really like to know which
        # we have without parsing it ... and want to store it in the right
        # place etc.
        #  So here is #1 hack: see if the metalin kis unset and the mirrorlist
        # URL contains the string "metalink", if it does we copy it over.
        if self.metalink:
            return
        if not self.mirrorlist:
            return
        if self.mirrorlist.find("metalink") == -1:
            return
        self.metalink = self.mirrorlist

    def _baseurlSetup(self):
        """go through the baseurls and mirrorlists and populate self.urls
           with valid ones, run  self.check() at the end to make sure it worked"""

        self.baseurl = self._replace_and_check_url(self.baseurl)
        # FIXME: We put all the mirrors in .baseurl as well as
        # .urls for backward compat. (see bottom of func). So we'll save this
        # out for repolist -v ... or anything else wants to know the baseurl
        self._orig_baseurl = self.baseurl

        mirrorurls = []
        self._hack_mirrorlist_for_anaconda()
        if self.metalink and not self.mirrorlistparsed:
            # FIXME: This is kind of lying to API callers
            mirrorurls.extend(list(self.metalink_data.urls()))
            self.mirrorlistparsed = True
        if self.mirrorlist and not self.mirrorlistparsed:
            mirrorurls.extend(self._getMirrorList())
            self.mirrorlistparsed = True

        self.mirrorurls = self._replace_and_check_url(mirrorurls)
        self._urls = self.baseurl + self.mirrorurls
        # if our mirrorlist is just screwed then make sure we unlink a mirrorlist cache
        if len(self._urls) < 1:
            if hasattr(self, 'mirrorlist_file') and os.path.exists(self.mirrorlist_file):
                if not self.cache:
                    try:
                        misc.unlink_f(self.mirrorlist_file)
                    except (IOError, OSError), e:
                        print 'Could not delete bad mirrorlist file: %s - %s' % (self.mirrorlist_file, e)
                    else:
                        print 'removing mirrorlist with no valid mirrors: %s' % self.mirrorlist_file
        # store them all back in baseurl for compat purposes
        self.baseurl = self._urls
        self.check()

    def _replace_and_check_url(self, url_list):
        goodurls = []
        skipped = None
        for url in url_list:
            # obvious bogons get ignored b/c, we could get more interesting checks but <shrug>
            if url in ['', None]:
                continue
            url = parser.varReplace(url, self.yumvar)
            if url[-1] != '/':
                url= url + '/'
            try:
                # This started throwing ValueErrors, BZ 666826
                (s,b,p,q,f,o) = urlparse.urlparse(url)
            except (ValueError, IndexError, KeyError), e:
                s = 'blah'

            if s not in ['http', 'ftp', 'file', 'https']:
                skipped = url
                continue
            else:
                goodurls.append(url)

        if skipped is not None:
            # Caller cleans up for us.
            if goodurls:
                print 'YumRepo Warning: Some mirror URLs are not using ftp, http[s] or file.\n Eg. %s' % misc.to_utf8(skipped)
            else: # And raises in this case
                print 'YumRepo Error: All mirror URLs are not using ftp, http[s] or file.\n Eg. %s' % misc.to_utf8(skipped)
        return goodurls

    def _geturls(self):
        if not self._urls:
            self._baseurlSetup()
        return self._urls

    urls = property(fget=lambda self: self._geturls(),
                    fset=lambda self, value: setattr(self, "_urls", value),
                    fdel=lambda self: setattr(self, "_urls", None))

    def _getMetalink(self):
        if not self._metalink:
            self.metalink_filename = self.cachedir + '/' + 'metalink.xml'
            local = self.metalink_filename + '.tmp'
            if not self._metalinkCurrent():
                url = misc.to_utf8(self.metalink)
                ugopts = self._default_grabopts()
                try:
                    ug = URLGrabber(progress_obj = self.callback, **ugopts)
                    result = ug.urlgrab(url, local, text=self.id + "/metalink")

                except urlgrabber.grabber.URLGrabError, e:
                    if not os.path.exists(self.metalink_filename):
                        msg = ("Cannot retrieve metalink for repository: %s. "
                               "Please verify its path and try again" % self )
                        raise Errors.RepoError, msg
                    #  Now, we have an old usable metalink, so we can't move to
                    # a newer repomd.xml ... or checksums won't match.
                    print "Could not get metalink %s error was\n%s: %s" % (url, e.args[0], misc.to_unicode(e.args[1]))                    
                    self._metadataCurrent = True

            if not self._metadataCurrent:
                try:
                    self._metalink = metalink.MetaLinkRepoMD(result)
                    shutil.move(result, self.metalink_filename)
                except metalink.MetaLinkRepoErrorParseFail, e:
                    # Downloaded file failed to parse, revert (dito. above):
                    print "Could not parse metalink %s error was \n%s"%(url, e)
                    self._metadataCurrent = True
                    misc.unlink_f(result)

            if self._metadataCurrent:
                self._metalink = metalink.MetaLinkRepoMD(self.metalink_filename)

        return self._metalink

    metalink_data = property(fget=lambda self: self._getMetalink(),
                             fset=lambda self, value: setattr(self, "_metalink",
                                                              value),
                             fdel=lambda self: setattr(self, "_metalink", None))

    def _getFile(self, url=None, relative=None, local=None, start=None, end=None,
            copy_local=None, checkfunc=None, text=None, reget='simple', 
            cache=True, size=None):
        """retrieve file from the mirrorgroup for the repo
           relative to local, optionally get range from
           start to end, also optionally retrieve from a specific baseurl"""

        # if local or relative is None: raise an exception b/c that shouldn't happen
        # if url is not None - then do a grab from the complete url - not through
        # the mirror, raise errors as need be
        # if url is None do a grab via the mirror group/grab for the repo
        # return the path to the local file

        # if copylocal isn't specified pickup the repo-defined attr
        if copy_local is None:
            copy_local = self.copy_local

        if local is None or relative is None:
            raise Errors.RepoError, \
                  "get request for Repo %s, gave no source or dest" % self.id

        if self.cache == 1:
            if os.path.exists(local): # FIXME - we should figure out a way
                return local          # to run the checkfunc from here

            else: # ain't there - raise
                raise Errors.RepoError, \
                    "Caching enabled but no local cache of %s from %s" % (local,

                           self)

        if url:
            (scheme, netloc, path, query, fragid) = urlparse.urlsplit(url)

        if self.mediaid and self.mediafunc:
            discnum = 1
            if url:
                if scheme == "media" and fragid:
                    discnum = int(fragid)
            try:
                # FIXME: we need to figure out what really matters to
                # pass to the media grabber function here
                result = self.mediafunc(local = local, checkfunc = checkfunc, relative = relative, text = text, copy_local = copy_local, url = url, mediaid = self.mediaid, name = self.name, discnum = discnum, range = (start, end))
                return result
            except Errors.MediaError, e:
                verbose_logger.log(logginglevels.DEBUG_2, "Error getting package from media; falling back to url %s" %(e,))

        if url and scheme != "media":
            ugopts = self._default_grabopts(cache=cache)
            ug = URLGrabber(progress_obj = self.callback,
                            copy_local = copy_local,
                            reget = reget,
                            failure_callback = self.failure_obj,
                            interrupt_callback=self.interrupt_callback,
                            checkfunc=checkfunc,
                            size=size,
                            **ugopts)

            remote = url + '/' + relative

            try:
                result = ug.urlgrab(misc.to_utf8(remote), local,
                                    text=misc.to_utf8(text),
                                    range=(start, end),
                                    )
            except URLGrabError, e:
                errstr = "failed to retrieve %s from %s\nerror was %s" % (relative, self.id, e)
                if self.mirrorurls:
                    errstr +="\n  You could try running: yum clean expire-cache"
                    errstr +="\n  To get a new set of mirrors."
                if e.errno == 256:
                    raise Errors.NoMoreMirrorsRepoError, errstr
                else:
                    raise Errors.RepoError, errstr


        else:
            headers = tuple(self.__headersListFromDict(cache=cache))
            try:
                result = self.grab.urlgrab(misc.to_utf8(relative), local,
                                           text = misc.to_utf8(text),
                                           range = (start, end),
                                           copy_local=copy_local,
                                           reget = reget,
                                           checkfunc=checkfunc,
                                           http_headers=headers,
                                           size=size
                                           )
            except URLGrabError, e:
                errstr = "failure: %s from %s: %s" % (relative, self.id, e)
                if e.errno == 256:
                    raise Errors.NoMoreMirrorsRepoError, errstr
                else:
                    raise Errors.RepoError, errstr

        return result
    __get = _getFile

    def getPackage(self, package, checkfunc=None, text=None, cache=True):
        remote = package.relativepath
        local = package.localPkg()
        basepath = package.basepath

        if self._preload_pkg_from_system_cache(package):
            if package.verifyLocalPkg():
                return local
            misc.unlink_f(local)

        return self._getFile(url=basepath,
                        relative=remote,
                        local=local,
                        checkfunc=checkfunc,
                        text=text,
                        cache=cache,
                        size=package.size,
                        )

    def getHeader(self, package, checkfunc = None, reget = 'simple',
            cache = True):

        remote = package.relativepath
        local =  package.localHdr()
        start = package.hdrstart
        end = package.hdrend
        size = end-start
        basepath = package.basepath
        # yes, I know, don't ask
        if not os.path.exists(self.hdrdir):
            os.makedirs(self.hdrdir)

        return self._getFile(url=basepath, relative=remote, local=local, start=start,
                        reget=None, end=end, checkfunc=checkfunc, copy_local=1,
                        cache=cache, size=size,
                        )

    def metadataCurrent(self):
        """Check if there is a metadata_cookie and check its age. If the
        age of the cookie is less than metadata_expire time then return true
        else return False. This result is cached, so that metalink/repomd.xml
        are synchronized."""
        if self._metadataCurrent is not None:
            return self._metadataCurrent

        mC_def = self.withinCacheAge(self.metadata_cookie, self.metadata_expire)
        if not mC_def: # Normal path...
            self._metadataCurrent = mC_def
            return mC_def

        # Edge cases, both repomd.xml and metalink (if used). Must exist.
        repomdfn = self.cachedir + '/' + 'repomd.xml'
        if not os.path.exists(repomdfn):
            self._metadataCurrent = False
            return False

        self._hack_mirrorlist_for_anaconda()
        mlfn = self.cachedir + '/' + 'metalink.xml'
        if self.metalink and not os.path.exists(mlfn):
            self._metadataCurrent = False
            return False

        self._metadataCurrent = True
        return True

    #  The metalink _shouldn't_ be newer than the repomd.xml or the checksums
    # will be off, but we only really care when we are downloading the
    # repomd.xml ... so keep it in mind that they can be off on disk.
    #  Also see _getMetalink()
    def _metalinkCurrent(self):
        if self._metadataCurrent is not None:
            return self._metadataCurrent

        if self.cache and not os.path.exists(self.metalink_filename):
            raise Errors.RepoError, 'Cannot find metalink.xml file for %s' %self

        if self.cache:
            self._metadataCurrent = True
        elif not os.path.exists(self.metalink_filename):
            self._metadataCurrent = False
        elif self.withinCacheAge(self.metadata_cookie, self.metadata_expire):
            self._metadataCurrent = True
        else:
            self._metadataCurrent = False
        return self._metadataCurrent

    def withinCacheAge(self, myfile, expiration_time):
        """check if any file is older than a certain amount of time. Used for
           the cachecookie and the mirrorlist
           return True if w/i the expiration time limit
           false if the time limit has expired

           Additionally compare the file to age of the newest .repo or yum.conf
           file. If any of them are newer then invalidate the cache
           """

        # -1 is special and should never get refreshed
        if expiration_time == -1 and os.path.exists(myfile):
            return True
        val = False
        if os.path.exists(myfile):
            cookie_info = os.stat(myfile)
            if cookie_info[8] + expiration_time > time.time():
                val = True
            # WE ARE FROM THE FUTURE!!!!
            elif cookie_info[8] > time.time():
                val = False

            # make sure none of our config files for this repo are newer than
            # us
            if cookie_info[8] < int(self.repo_config_age):
                val = False

        return val

    def setMetadataCookie(self):
        """if possible, set touch the metadata_cookie file"""

        check = self.metadata_cookie
        if not os.path.exists(self.metadata_cookie):
            check = self.cachedir

        if os.access(check, os.W_OK):
            fo = open(self.metadata_cookie, 'w+')
            fo.close()
            del fo

    def setup(self, cache, mediafunc = None, gpg_import_func=None, confirm_func=None, gpgca_import_func=None):
        try:
            self.cache = cache
            self.mediafunc = mediafunc
            self.gpg_import_func = gpg_import_func
            self.gpgca_import_func = gpgca_import_func
            self.confirm_func = confirm_func
        except Errors.RepoError, e:
            raise
        if not self.mediafunc and self.mediaid and not self.mirrorlist and not self.baseurl:
            verbose_logger.log(logginglevels.DEBUG_2, "Disabling media repo for non-media-aware frontend")
            self.enabled = False
            self.skip_if_unavailable = True

    def _cachingRepoXML(self, local):
        """ Should we cache the current repomd.xml """
        if self.cache and not os.path.exists(local):
            raise Errors.RepoError, 'Cannot find repomd.xml file for %s' % self
        if self.cache or self.metadataCurrent():
            return True
        return False

    def _getFileRepoXML(self, local, text=None, grab_can_fail=None):
        """ Call _getFile() for the repomd.xml file. """
        checkfunc = (self._checkRepoXML, (), {})
        if grab_can_fail is None:
            grab_can_fail = 'old_repo_XML' in self._oldRepoMDData
        tfname = ''
        try:
            # This is named so that "yum clean metadata" picks it up
            tfname = tempfile.mktemp(prefix='repomd', suffix="tmp.xml",
                                     dir=os.path.dirname(local))
            result = self._getFile(relative=self.repoMDFile,
                                   local=tfname,
                                   copy_local=1,
                                   text=text,
                                   reget=None,
                                   checkfunc=checkfunc,
                                   cache=self.http_caching == 'all',
                                   size=102400) # setting max size as 100K

        except URLGrabError, e:
            misc.unlink_f(tfname)
            if grab_can_fail:
                return None
            raise Errors.RepoError, 'Error downloading file %s: %s' % (local, e)
        except (Errors.NoMoreMirrorsRepoError, Errors.RepoError):
            misc.unlink_f(tfname)
            if grab_can_fail:
                return None
            raise

        # This should always work...
        try:
            os.rename(result, local)
        except:
            # But in case it doesn't...
            misc.unlink_f(tfname)
            if grab_can_fail:
                return None
            raise Errors.RepoError, 'Error renaming file %s to %s' % (result,
                                                                      local)
        return local

    def _parseRepoXML(self, local, parse_can_fail=None):
        """ Parse the repomd.xml file. """
        try:
            return repoMDObject.RepoMD(self.id, local)
        except Errors.RepoMDError, e:
            if parse_can_fail is None:
                parse_can_fail = 'old_repo_XML' in self._oldRepoMDData
            if parse_can_fail:
                return None
            raise Errors.RepoError, 'Error importing repomd.xml from %s: %s' % (self, e)

    def _saveOldRepoXML(self, local):
        """ If we have an older repomd.xml file available, save it out. """
        # Cleanup old trash...
        for fname in glob.glob(self.cachedir + "/*.old.tmp"):
            misc.unlink_f(fname)

        if os.path.exists(local):
            old_local = local + '.old.tmp' # locked, so this is ok
            shutil.copy2(local, old_local)
            xml = self._parseRepoXML(old_local, True)
            if xml is None:
                return None
            self._oldRepoMDData = {'old_repo_XML' : xml, 'local' : local,
                                   'old_local' : old_local, 'new_MD_files' : []}
            return xml
        return None

    def _revertOldRepoXML(self):
        """ If we have older data available, revert to it. """

        #  If we can't do a timestamp check, then we can be looking at a
        # completely different repo. from last time ... ergo. we can't revert.
        #  We still want the old data, so we don't download twice. So we
        # pretend everything is good until the revert.
        if not self.timestamp_check:
            raise Errors.RepoError, "Can't download or revert repomd.xml"

        if 'old_repo_XML' not in self._oldRepoMDData:
            self._oldRepoMDData = {}
            return

        # Unique names mean the rename doesn't work anymore.
        for fname in self._oldRepoMDData['new_MD_files']:
            misc.unlink_f(fname)

        old_data = self._oldRepoMDData
        self._oldRepoMDData = {}

        if 'old_local' in old_data:
            os.rename(old_data['old_local'], old_data['local'])

        self._repoXML = old_data['old_repo_XML']

        if 'old_MD_files' not in old_data:
            return
        for revert in old_data['old_MD_files']:
            os.rename(revert + '.old.tmp', revert)

    def _doneOldRepoXML(self):
        """ Done with old data, delete it. """
        old_data = self._oldRepoMDData
        self._oldRepoMDData = {}

        if 'old_local' in old_data:
            misc.unlink_f(old_data['old_local'])

        if 'old_MD_files' not in old_data:
            return
        for revert in old_data['old_MD_files']:
            misc.unlink_f(revert + '.old.tmp')

    def _get_mdtype_data(self, mdtype, repoXML=None):
        if repoXML is None:
            repoXML = self.repoXML

        if mdtype == 'group' and 'group_gz' in repoXML.fileTypes():
            mdtype = 'group_gz'
        if (mdtype in ['other', 'filelists', 'primary'] and
            self._check_db_version(mdtype + '_db', repoXML=repoXML)):
            mdtype += '_db'

        return (mdtype, repoXML.repoData.get(mdtype))

    def _get_mdtype_fname(self, data, compressed=False):
        (r_base, remote) = data.location
        local = self.cachedir + '/' + os.path.basename(remote)

        if compressed: # DB file, we need the uncompressed version
            local = misc.decompress(local, fn_only=True)
        return local

    def _groupCheckDataMDNewer(self):
        """ We check the timestamps, if any of the timestamps for the
            "new" data is older than what we have ... we revert. """

        if 'old_repo_XML' not in self._oldRepoMDData:
            return True
        old_repo_XML = self._oldRepoMDData['old_repo_XML']

        if (self.timestamp_check and
            old_repo_XML.timestamp > self.repoXML.timestamp):
            logger.warning("Not using downloaded repomd.xml because it is "
                           "older than what we have:\n"
                           "  Current   : %s\n  Downloaded: %s" %
                           (time.ctime(old_repo_XML.timestamp),
                            time.ctime(self.repoXML.timestamp)))
            return False
        return True

    @staticmethod
    def _checkRepoXMLMetalink(repoXML, repomd):
        """ Check parsed repomd.xml against metalink.repomd data. """
        if repoXML.timestamp != repomd.timestamp:
            return False
        if repoXML.length != repomd.size:
            return False

        done = False
        for checksum in repoXML.checksums:
            if checksum not in repomd.chksums:
                continue

            if repoXML.checksums[checksum] != repomd.chksums[checksum]:
                return False

            #  All checksums should be trusted, but if we have more than one
            # then we might as well check them all ... paranoia is good.
            done = True

        return done

    def _checkRepoMetalink(self, repoXML=None, metalink_data=None):
        """ Check the repomd.xml against the metalink data, if we have it. """

        if repoXML is None:
            repoXML = self._repoXML
        if metalink_data is None:
            metalink_data = self.metalink_data

        if self._checkRepoXMLMetalink(repoXML, metalink_data.repomd):
            return True

        # FIXME: We probably want to skip to the first mirror which has the
        # latest repomd.xml, but say "if we can't find one, use the newest old
        # repomd.xml" ... alas. that's not so easy to do in urlgrabber atm.
        for repomd in self.metalink_data.old_repomds:
            if self._checkRepoXMLMetalink(repoXML, repomd):
                verbose_logger.log(logginglevels.DEBUG_2,
                                   "Using older repomd.xml\n"
                                   "  Latest: %s\n"
                                   "  Using: %s" %
                                   (time.ctime(metalink_data.repomd.timestamp),
                                    time.ctime(repomd.timestamp)))
                return True
        return False

    def _latestRepoXML(self, local):
        """ Save the Old Repo XML, and if it exists check to see if it's the
            latest available given the metalink data. """

        oxml = self._saveOldRepoXML(local)
        if not oxml: # No old repomd.xml data
            return False

        self._hack_mirrorlist_for_anaconda()
        if not self.metalink: # Nothing to check it against
            return False

        # Get the latest metalink, and the latest repomd data from it
        repomd = self.metalink_data.repomd

        if self.timestamp_check and oxml.timestamp > repomd.timestamp:
            #  We have something "newer" than the latest, and have timestamp
            # checking which will kill anything passing the metalink check.
            return True

        # Do we have the latest repomd already
        return self._checkRepoXMLMetalink(oxml, repomd)

    def _commonLoadRepoXML(self, text, mdtypes=None):
        """ Common LoadRepoXML for instant and group, returns False if you
            should just return. """
        local  = self.cachedir + '/repomd.xml'
        if self._repoXML is not None:
            return False

        if self._cachingRepoXML(local):
            caching = True
            result = local
        else:
            caching = False
            if self._latestRepoXML(local):
                result = local
                old_data = self._oldRepoMDData
                self._repoXML = old_data['old_repo_XML']
            else:
                result = self._getFileRepoXML(local, text)
                if result is None:
                    # Ignore this as we have a copy
                    self._revertOldRepoXML()
                    return False

            # if we have a 'fresh' repomd.xml then update the cookie
            self.setMetadataCookie()

        if self._repoXML is None:
            self._repoXML = self._parseRepoXML(result)
        if self._repoXML is None:
            self._revertOldRepoXML()
            return False

        self._using_old_MD = caching
        if caching:
            return False # Skip any work.

        if not self._groupCheckDataMDNewer():
            self._revertOldRepoXML()
            return False
        return True

    def _check_db_version(self, mdtype, repoXML=None):
        if repoXML is None:
            repoXML = self.repoXML
        if mdtype in repoXML.repoData:
            if DBVERSION == repoXML.repoData[mdtype].dbversion:
                return True
        return False

    # mmdtype is unused, but in theory was == primary
    # dbmtype == primary_db etc.
    def _groupCheckDataMDValid(self, data, dbmdtype, mmdtype, file_check=False):
        """ Check that we already have this data, and that it's valid. Given
            the DB mdtype and the main mdtype (no _db suffix). """

        if data is None:
            return None

        if not file_check:
            compressed = dbmdtype.endswith("_db")
            local = self._get_mdtype_fname(data, compressed)
        else:
            compressed = False
            local = self._get_mdtype_fname(data, False)
            if not os.path.exists(local):
                local = misc.decompress(local, fn_only=True)
                compressed = True
        #  If we can, make a copy of the system-wide-cache version of this file,
        # note that we often don't get here. So we also do this in
        # YumPackageSack.populate ... and we look for the uncompressed versions
        # in retrieveMD.
        self._preload_md_from_system_cache(os.path.basename(local))
        if not self._checkMD(local, dbmdtype, openchecksum=compressed,
                             data=data, check_can_fail=True):
            return None

        return local

    def _commonRetrieveDataMD(self, mdtypes=None):
        """ Retrieve any listed mdtypes, and revert if there was a failure.
            Also put any of the non-valid mdtype files from the old_repo_XML
            into the delete list, this means metadata can change filename
            without us leaking it. """

        def _mdtype_eq(omdtype, odata, nmdtype, ndata):
            """ Check if two returns from _get_mdtype_data() are equal. """
            if ndata is None:
                return False
            if omdtype != nmdtype:
                return False
            if odata.checksum != ndata.checksum:
                return False
            #  If we turn --unique-md-filenames on without chaning the data,
            # then we'll get different filenames, but the same checksum.
            #  Atm. just say they are different, to make sure we delete the
            # old files.
            orname = os.path.basename(odata.location[1])
            nrname = os.path.basename(ndata.location[1])
            if orname != nrname:
                return False
            return True

        all_mdtypes = self.retrieved.keys()
        if mdtypes is None:
            mdtypes = all_mdtypes

        reverts = []
        if 'old_repo_XML' not in self._oldRepoMDData:
            old_repo_XML = None
        else:
            old_repo_XML = self._oldRepoMDData['old_repo_XML']
            self._oldRepoMDData['old_MD_files'] = reverts

        # Inited twice atm. ... sue me
        self._oldRepoMDData['new_MD_files'] = []
        downloading_with_size = []
        downloading_no_size   = []
        for mdtype in all_mdtypes:
            (nmdtype, ndata) = self._get_mdtype_data(mdtype)

            if old_repo_XML:
                (omdtype, odata) = self._get_mdtype_data(mdtype,
                                                         repoXML=old_repo_XML)
                local = self._groupCheckDataMDValid(odata, omdtype,mdtype,True)
                if local:
                    if _mdtype_eq(omdtype, odata, nmdtype, ndata):
                        continue # If they are the same do nothing

                    # Move this version, we _may_ get a new one.
                    # We delete it on success, revert it back on failure.
                    # We don't copy as we know it's bad due to above test.
                    os.rename(local, local + '.old.tmp')
                    reverts.append(local)

                    #  This is the super easy way. We just to see if a generated
                    # file is there for all files, but it should always work.
                    #  And anyone who is giving us MD with blah and blah.sqlite
                    # which are different types, can play a game I like to call
                    # "come here, ouch".
                    gen_local = local + '.sqlite'
                    if os.path.exists(gen_local):
                        os.rename(gen_local, gen_local + '.old.tmp')
                        reverts.append(gen_local)

            if ndata is None: # Doesn't exist in this repo
                continue

            if mdtype not in mdtypes:
                continue

            # No old repomd data, but we might still have uncompressed MD
            if self._groupCheckDataMDValid(ndata, nmdtype, mdtype):
                continue

            if ndata.size is None:
                downloading_no_size.append((ndata, nmdtype))
            else:
                downloading_with_size.append((ndata, nmdtype))

        if len(downloading_with_size) == 1:
            downloading_no_size.extend(downloading_with_size)
            downloading_with_size = []

        remote_size = 0
        local_size  = 0
        for (ndata, nmdtype) in downloading_with_size: # Get total size...
            remote_size += int(ndata.size)

        for (ndata, nmdtype) in downloading_with_size:
            urlgrabber.progress.text_meter_total_size(remote_size, local_size)
            if not self._retrieveMD(nmdtype, retrieve_can_fail=True):
                self._revertOldRepoXML()
                return False
            local_size += int(ndata.size)
        urlgrabber.progress.text_meter_total_size(0)
        for (ndata, nmdtype) in downloading_no_size:
            if not self._retrieveMD(nmdtype, retrieve_can_fail=True):
                self._revertOldRepoXML()
                return False

        for (ndata, nmdtype) in downloading_with_size + downloading_no_size:
            local = self._get_mdtype_fname(ndata, False)
            if nmdtype.endswith("_db"): # Uncompress any compressed files
                dl_local = local
                local = misc.decompress(dl_local)
                misc.unlink_f(dl_local)
            self._oldRepoMDData['new_MD_files'].append(local)

        self._doneOldRepoXML()
        return True

    def _groupLoadRepoXML(self, text=None, mdtypes=None):
        """ Retrieve the new repomd.xml from the repository, then check it
            and parse it. If it fails we revert to the old version and pretend
            that is fine. If the new repomd.xml requires new version of files
            that we have, like updateinfo.xml, we download those too and if any
            of those fail, we again revert everything and pretend old data is
            good. """

        if self._commonLoadRepoXML(text):
            self._commonRetrieveDataMD(mdtypes)

    def _mdpolicy2mdtypes(self):
        md_groups = {'instant'       : [],
                     'group:primary' : ['primary'],
                     'group:small'   : ["primary", "updateinfo"],
                     'group:main'    : ["primary", "group", "filelists",
                                        "updateinfo", "prestodelta"]}
        mdtypes = set()
        if type(self.mdpolicy) in types.StringTypes:
            mdtypes.update(md_groups.get(self.mdpolicy, [self.mdpolicy]))
        else:
            for mdpolicy in self.mdpolicy:
                mdtypes.update(md_groups.get(mdpolicy, [mdpolicy]))

        if not mdtypes or 'group:all' in mdtypes:
            mdtypes = None
        else:
            mdtypes = sorted(list(mdtypes))
        return mdtypes

    def _loadRepoXML(self, text=None):
        """retrieve/check/read in repomd.xml from the repository"""
        try:
            return self._groupLoadRepoXML(text, self._mdpolicy2mdtypes())
        except KeyboardInterrupt:
            self._revertOldRepoXML() # Undo metadata cookie?
            raise
        raise Errors.RepoError, 'Bad loadRepoXML policy: %s' % (self.mdpolicy)

    def _getRepoXML(self):
        if self._repoXML:
            return self._repoXML
        try:
            self._loadRepoXML(text=self)
        except Errors.RepoError, e:
            msg = ("Cannot retrieve repository metadata (repomd.xml) for repository: %s. "
                  "Please verify its path and try again" % self )
            raise Errors.RepoError, msg
        return self._repoXML


    repoXML = property(fget=lambda self: self._getRepoXML(),
                       fset=lambda self, val: setattr(self, "_repoXML", val),
                       fdel=lambda self: setattr(self, "_repoXML", None))

    def _checkRepoXML(self, fo):
        if type(fo) is types.InstanceType:
            filepath = fo.filename
        else:
            filepath = fo

        if self.repo_gpgcheck and not self._override_sigchecks:

            if misc.gpgme is None:
                raise URLGrabError(-1, 'pygpgme is not working so repomd.xml can not be verified for %s' % (self))

            sigfile = self.cachedir + '/repomd.xml.asc'
            try:
                result = self._getFile(relative='repodata/repomd.xml.asc',
                                       copy_local=1,
                                       local = sigfile,
                                       text='%s/signature' % self.id,
                                       reget=None,
                                       checkfunc=None,
                                       cache=self.http_caching == 'all',
                                       size=102400)
            except URLGrabError, e:
                raise URLGrabError(-1, 'Error finding signature for repomd.xml for %s: %s' % (self, e))
            valid = misc.valid_detached_sig(result, filepath, self.gpgdir)
            if not valid and self.gpg_import_func:
                try:
                    self.gpg_import_func(self, self.confirm_func)
                except Errors.YumBaseError, e:
                    raise URLGrabError(-1, 'Gpg Keys not imported, cannot verify repomd.xml for repo %s' % (self))
                valid = misc.valid_detached_sig(result, filepath, self.gpgdir)

            if not valid:
                raise URLGrabError(-1, 'repomd.xml signature could not be verified for %s' % (self))

        try:
            repoXML = repoMDObject.RepoMD(self.id, filepath)
        except Errors.RepoMDError, e:
            raise URLGrabError(-1, 'Error importing repomd.xml for %s: %s' % (self, e))

        self._hack_mirrorlist_for_anaconda()
        if self.metalink and not self._checkRepoMetalink(repoXML):
            raise URLGrabError(-1, 'repomd.xml does not match metalink for %s' %
                               self)


    def checkMD(self, fn, mdtype, openchecksum=False):
        """check the metadata type against its checksum"""
        return self._checkMD(fn, mdtype, openchecksum)

    def _checkMD(self, fn, mdtype, openchecksum=False,
                 data=None, check_can_fail=False):
        """ Internal function, use .checkMD() from outside yum. """

        thisdata = data # So the argument name is nicer
        if thisdata is None:
            thisdata = self.repoXML.getData(mdtype)

        # Note openchecksum means do it after you've uncompressed the data.
        if openchecksum:
            (r_ctype, r_csum) = thisdata.openchecksum # get the remote checksum
            size = thisdata.opensize
        else:
            (r_ctype, r_csum) = thisdata.checksum # get the remote checksum
            size = thisdata.size

        if type(fn) == types.InstanceType: # this is an urlgrabber check
            file = fn.filename
        else:
            file = fn

        if size is not None:
            size = int(size)

        try: # get the local checksum
            l_csum = self._checksum(r_ctype, file, datasize=size)
        except Errors.RepoError, e:
            if check_can_fail:
                return None
            raise URLGrabError(-3, 'Error performing checksum')

        if l_csum == r_csum:
            return 1
        else:
            if check_can_fail:
                return None
            raise URLGrabError(-1, 'Metadata file does not match checksum')



    def retrieveMD(self, mdtype):
        """base function to retrieve metadata files from the remote url
           returns the path to the local metadata file of a 'mdtype'
           mdtype can be 'primary', 'filelists', 'other' or 'group'."""
        return self._retrieveMD(mdtype)

    def _retrieveMD(self, mdtype, retrieve_can_fail=False):
        """ Internal function, use .retrieveMD() from outside yum. """
        #  Note that this can raise Errors.RepoMDError if mdtype doesn't exist
        # for this repo.
        # FIXME - maybe retrieveMD should call decompress() after we've checked
        # the checksum by default? since we're never acting on compressed MD
        thisdata = self.repoXML.getData(mdtype)

        (r_base, remote) = thisdata.location
        fname = os.path.basename(remote)
        local = self.cachedir + '/' + fname

        if self.retrieved.get(mdtype):
            # got it, move along
            return local

        if self.cache == 1:
            if os.path.exists(local):
                try:
                    self.checkMD(local, mdtype)
                except URLGrabError, e:
                    raise Errors.RepoError, \
                        "Caching enabled and local cache: %s does not match checksum" % local
                else:
                    return local

            else: # ain't there - raise
                raise Errors.RepoError, \
                    "Caching enabled but no local cache of %s from %s" % (local,
                           self)

        if (os.path.exists(local) or
            self._preload_md_from_system_cache(os.path.basename(local))):
            if self._checkMD(local, mdtype, check_can_fail=True):
                self.retrieved[mdtype] = 1
                return local # it's the same return the local one

        try:
            checkfunc = (self.checkMD, (mdtype,), {})
            text = "%s/%s" % (self.id, mdtype)
            if thisdata.size is None:
                reget = None
            else:
                reget = 'simple'
                if os.path.exists(local):
                    if os.stat(local).st_size >= int(thisdata.size):
                        misc.unlink_f(local)
            local = self._getFile(relative=remote,
                                  local=local, 
                                  copy_local=1,
                                  reget=reget,
                                  checkfunc=checkfunc, 
                                  text=text,
                                  cache=self.http_caching == 'all',
                                  size=thisdata.size)
        except (Errors.NoMoreMirrorsRepoError, Errors.RepoError):
            if retrieve_can_fail:
                return None
            raise
        except URLGrabError, e:
            if retrieve_can_fail:
                return None
            raise Errors.RepoError, \
                "Could not retrieve %s matching remote checksum from %s" % (local, self)
        else:
            self.retrieved[mdtype] = 1
            return local


    def getPrimaryXML(self):
        """this gets you the path to the primary.xml file, retrieving it if we
           need a new one"""

        return self.retrieveMD('primary')


    def getFileListsXML(self):
        """this gets you the path to the filelists.xml file, retrieving it if we
           need a new one"""

        return self.retrieveMD('filelists')

    def getOtherXML(self):
        return self.retrieveMD('other')

    def getGroups(self):
        """gets groups and returns group file path for the repository, if there
           is none it returns None"""
        if 'group_gz' in self.repoXML.fileTypes():
            return self._retrieveMD('group_gz', retrieve_can_fail=True)
        return self._retrieveMD('group', retrieve_can_fail=True)

    def setCallback(self, callback):
        self.callback = callback
        self._callbacks_changed = True

    def setFailureObj(self, failure_obj):
        self.failure_obj = failure_obj
        self._callbacks_changed = True

    def setMirrorFailureObj(self, failure_obj):
        self.mirror_failure_obj = failure_obj
        self._callbacks_changed = True

    def setInterruptCallback(self, callback):
        self.interrupt_callback = callback
        self._callbacks_changed = True

    def _readMirrorList(self, fo, url=None):
        """ read the mirror list from the specified file object """
        returnlist = []

        content = []
        if fo is not None:
            try:
                content = fo.readlines()
            except Exception, e:
                if url is None: # Shouldn't happen
                    url = "<unknown>"
                print "Could not read mirrorlist %s, error was \n%s" %(url, e)
                content = []
            for line in content:
                if re.match('\s*(#|$)', line):
                    continue
                mirror = line.rstrip() # no more trailing \n's
                mirror = mirror.replace('$ARCH', '$BASEARCH')
                returnlist.append(mirror)

        return (returnlist, content)

    def _getMirrorList(self):
        """retrieve an up2date-style mirrorlist file from our mirrorlist url,
           also save the file to the local repo dir and use that if cache expiry
           not expired

           we also s/$ARCH/$BASEARCH/ and move along
           return the baseurls from the mirrorlist file
           """
        self.mirrorlist_file = self.cachedir + '/' + 'mirrorlist.txt'
        fo = None

        cacheok = False
        if self.withinCacheAge(self.mirrorlist_file, self.mirrorlist_expire):
            cacheok = True
            fo = open(self.mirrorlist_file, 'r')
            url = 'file://' + self.mirrorlist_file # just to keep self._readMirrorList(fo,url) happy
        else:
            url = self.mirrorlist
            scheme = urlparse.urlparse(url)[0]
            if scheme == '':
                url = 'file://' + url
            ugopts = self._default_grabopts()
            try:
                fo = urlgrabber.grabber.urlopen(url, **ugopts)
            except urlgrabber.grabber.URLGrabError, e:
                print "Could not retrieve mirrorlist %s error was\n%s: %s" % (url, e.args[0], misc.to_unicode(e.args[1]))
                fo = None

        (returnlist, content) = self._readMirrorList(fo, url)

        if returnlist:
            if not self.cache and not cacheok:
                output = open(self.mirrorlist_file, 'w')
                for line in content:
                    output.write(line)
                output.close()
        elif not cacheok and os.path.exists(self.mirrorlist_file):
            # New mirror file failed, so use the old one (better than nothing)
            os.utime(self.mirrorlist_file, None)
            return self._readMirrorList(open(self.mirrorlist_file, 'r'))[0]

        return returnlist

    def _preload_file(self, fn, destfn):
        """attempts to copy the file, if possible"""
        # don't copy it if the copy in our users dir is newer or equal
        if not os.path.exists(fn):
            return False
        if os.path.exists(destfn):
            if os.stat(fn)[stat.ST_CTIME] <= os.stat(destfn)[stat.ST_CTIME]:
                return False
        shutil.copy2(fn, destfn)
        return True

    def _preload_file_from_system_cache(self, filename, subdir='',
                                        destfn=None):
        """attempts to copy the file from the system-wide cache,
           if possible"""
        if not hasattr(self, 'old_base_cache_dir'):
            return False
        if self.old_base_cache_dir == "":
            return False

        glob_repo_cache_dir=os.path.join(self.old_base_cache_dir, self.id)
        if not os.path.exists(glob_repo_cache_dir):
            return False
        if os.path.normpath(glob_repo_cache_dir) == os.path.normpath(self.cachedir):
            return False

        # Try to copy whatever file it is
        fn = glob_repo_cache_dir   + '/' + subdir + os.path.basename(filename)
        if destfn is None:
            destfn = self.cachedir + '/' + subdir + os.path.basename(filename)
        return self._preload_file(fn, destfn)

    def _preload_md_from_system_cache(self, filename):
        """attempts to copy the metadata file from the system-wide cache,
           if possible"""
        return self._preload_file_from_system_cache(filename)
    
    def _preload_pkg_from_system_cache(self, pkg):
        """attempts to copy the package from the system-wide cache,
           if possible"""
        pname  = os.path.basename(pkg.localPkg())
        destfn = os.path.join(self.pkgdir, pname)
        if self._preload_file_from_system_cache(pkg.localPkg(),
                                                subdir='packages/',
                                                destfn=destfn):
            return True

        if not hasattr(self, '_old_pkgdirs'):
            return False
        for opkgdir in self._old_pkgdirs:
            if self._preload_file(os.path.join(opkgdir, pname), destfn):
                return True
        return False

    def _verify_md(self):
        problems = []
        print 'verifying md'
        try:
            md_types = self.repoXML.fileTypes()
        except Errors.RepoError, e:
            prb = RepoVerifyProblem(1, "failed to load repomd.xml", str(e))
            problems.append(prb)
            return problems

        for md_type in md_types:
            print 'verifying %s' % md_type
            try:
                self.retrieveMD(md_type)
            except Errors.RepoError, e:
                msg = "%s metadata missing or does not match checksum" % md_type
                prb = RepoVerifyProblem(2, msg, str(e))
                problems.append(prb)

        return problems

    def _verify_comps(self):
        print 'verifying comps'
        problems = []
        # grab the comps for this repo
        # run the xmllint on it
        # chuck it into a comps object
        # make sure it parses

        grpfile = self.getGroups()

        # open it up as a file object so iterparse can cope with our compressed file
        if grpfile is not None:
            grpfile = misc.decompress(grpfile)
        try:
            c = comps.Comps()
            c.add(grpfile)
        except (Errors.GroupsError, Errors.CompsException), e:
            msg = "comps file failed to add"
            prb = RepoVerifyProblem(REPO_PROBLEM_COMPS, msg, str(e))
            problems.add(prb)
        else:
            if c.compscount == 0:
                msg = "no groups in comps"
                prb = RepoVerifyProblem(REPO_PROBLEM_COMPS, msg, "")
                problems.add(prb)

        return problems

    def _verify_packages(self):
        return []

    def verify(self, items=['repodata', 'comps']):
        """download/verify the specified items
           @items = ['repodata', 'comps'] can include: repodata, comps, packages
        """
        problems = []
        if 'repodata' in items:
            problems.extend(self._verify_md())
        if 'comps' in items:        
            if self.enablegroups:
                problems.extend(self._verify_comps())
        if 'packages' in items:
            problems.extend(self._verify_packages())
        # what else can we verify?

        return problems


def getMirrorList(mirrorlist, pdict = None):
    warnings.warn('getMirrorList() will go away in a future version of Yum.\n',
            Errors.YumFutureDeprecationWarning, stacklevel=2)
    """retrieve an up2date-style mirrorlist file from a url,
       we also s/$ARCH/$BASEARCH/ and move along
       returns a list of the urls from that file"""

    returnlist = []
    if hasattr(urlgrabber.grabber, 'urlopen'):
        urlresolver = urlgrabber.grabber
    else:
        import urllib
        urlresolver = urllib

    scheme = urlparse.urlparse(mirrorlist)[0]
    if scheme == '':
        url = 'file://' + mirrorlist
    else:
        url = mirrorlist

    try:
        fo = urlresolver.urlopen(url, proxies=pdict)
    except urlgrabber.grabber.URLGrabError, e:
        print "Could not retrieve mirrorlist %s error was\n%s: %s" % (url, e.args[0], misc.to_unicode(e.args[1]))
        fo = None

    if fo is not None:
        content = fo.readlines()
        for line in content:
            if re.match('\s*(#|$)', line):
                continue
            mirror = line.rstrip() # no more trailing \n's
            mirror = mirror.replace('$ARCH', '$BASEARCH')
            returnlist.append(mirror)

    return returnlist

class RepoVerifyProblem:
    """ Holder for each "problem" we find with a repo.verify(). """
    
    def __init__(self, type, msg, details, fake=False):
        self.type           = type
        self.message        = msg
        self.details        = details
        self.fake           = fake
                                                                                                                                                            usr/lib/python2.7/dist-packages/yum/yumRepo.pyc                                                     0100644 0000000 0000000 00000161616 13077704344 020126  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
f
§Tc           @   s4  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z y e j j d É Wn e k
 rj Z e GHn Xd  d l	 Z	 d  d l
 m Z d  d l
 m Z d  d l Z d  d l
 m Z d  d l Z d  d l Z d  d l m Z d  d l Z d  d l Z d  d l Z d  d l m Z d  d l m Z d  d	 l m Z d  d
 l Td  d l Z d  d l Z d  d l Z d  d l Z d  d l  Z  d  d l! Z! d  d l" Z" d  d l# Z# d  d l$ Z$ e% Z& e j' d e	 j( É e j) d É Z* e j) d É Z+ d e j, f d Ñ  É  YZ- d e e j. f d Ñ  É  YZ/ e0 d Ñ Z1 d f  d Ñ  É  YZ2 d S(   iˇˇˇˇNt   media(   t
   URLGrabber(   t   default_grabber(   t   URLGrabError(   t
   Repository(   t   config(   t   misc(   t   comps(   t   *t   ignores	   yum.Reposs   yum.verbose.Repost   YumPackageSackc           B   sY   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d
 d Ñ Z d d
 d d Ñ Z d Ñ  Z	 d	 Ñ  Z
 RS(   s;   imports/handles package objects from an mdcache dict objectc         C   s&   t  j j |  É | |  _ i  |  _ d  S(   N(   t   packageSackt   PackageSackt   __init__t   pct   added(   t   selft   packageClass(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR   I   s    	c         C   s   |  j  É  d  S(   N(   t   close(   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   __del__N   s    c         C   s   i  |  _  d  S(   N(   R   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR   Q   s    c   
      C   sÙ  | |  j  k r) | |  j  | k r) d  Sn  t | É } | d k rd } x| | D]t } | d 7} | rz | j | | | É n  | | } |  j | | É }	 | |	 _ |  j |  j | |	 É |  j |	 É qN W| |  j  k rÂ g  |  j  | <n  |  j  | j d É d |  _	 nÎ | d k r| |  j  k rRd |  j  | k rRt
 j d | | j f Ç qRn  d } xu | D]m } | d 7} | rã| j | | | É n  | | } | |  j k r_x% |  j | D] }	 |	 j | É q≤Wq_q_W|  j  | j | É d |  _	 n  d  S(   Nt   metadatai    i   t	   filelistst	   otherdatas$   %s md for %s imported before primary(   R   R   (   R   t   lent   progressbarR   t   idt   _addToDictAsListt   pkgsByIDt
   addPackaget   appendt   indexesBuiltt   Errorst	   RepoErrort   importFromDict(
   R   t   repot   datatypet   dataobjt   callbackt   totalt   currentt   pkgidt   pkgdictt   po(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   addDictT   sH    
 
		
 
R   i    c         C   s7  | d k r d d d g } n	 | g } t  | d É s` t j d | j d | j d | É | _ n  x | D]¬} | |  j k rò | |  j | k rò qg qò n  d  } | d k rŒ d	 } d
 }	 | j }
 | j j	 } nc | d k r˛ d } d }	 | j
 }
 | j j } n3 | d k rg d } d }	 | j }
 | j j } n qg |  j | | É r≈|  j | | É } | s∞| j | É } | r∞| j s≠t j | É } t j | É |  j | | É } q≠q∞n  | j j | É } nB t | _ |
 É  } | j j |	 É } | j \ } } | | | É } | s&|  j | | | | É n  ~ qg W| ` d  S(   Nt   allR   R   R   t   cacheHandlert   storedirt   repoidR%   t
   primary_dbt   primaryt   filelists_dbt   other_dbt   other(   t   hasattrt   sqlitecachect   RepodataParserSqlitet   cachedirR   R-   R   t   Nonet   getPrimaryXMLt
   getPrimaryt   getFileListsXMLt   getFilelistst   getOtherXMLt   getOtherdatat   _check_db_versiont   _check_uncompressed_dbt   _retrieveMDt   cacheR   t
   decompresst   unlink_ft   open_databaset   Truet   _xml2sqlite_localt   repoXMLt   getDatat   checksumR+   (   R   R"   t   mdtypeR%   t	   cacheonlyt   datat   itemt   db_fnt   mydbtypet   mymdtypet   repo_get_functiont   repo_cache_functiont   db_un_fnt   dobjt   xmlt   xmldatat   ctypet   csum(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   populateÄ   s`    											c   
      C   sÒ   | j  j | É } | j \ } } t j j | É } | j d | } t j | d t	 É} d }	 | j t j j | É É t j j | É rÌ t rù | j rù | Sy | j | | d t	 ÉWn* t k
 r„ | j sÍ t j | É qÍ qÌ X| }	 n  |	 S(   s8   return file name of uncompressed db is good, None if nott   /t   fn_onlyt   openchecksumN(   RI   RJ   t   locationt   ost   patht   basenameR8   R   RD   RG   R9   t   _preload_md_from_system_cachet   existst   skip_old_DBMD_checkt   _using_old_MDt   checkMDR   RC   RE   (
   R   R"   RL   t   mydbdatat   r_baset   remotet   fnamet   compressed_fnRU   t   result(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRA   »   s"    		c         C   s   | j  | É S(   N(   R@   (   R   R"   RL   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR@   ·   s    N(   t   __name__t
   __module__t   __doc__R   R   R   R9   R+   R[   RA   R@   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR
   G   s   			,H	t   YumRepositoryc           B   s¡  e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z e e É Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 e e
 É Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z ds e dt d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z d Ñ  Z d Ñ  Z e d Ñ Z d Ñ  Z d Ñ  Z e d Ñ  É Z e d Ñ  É Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ e d Ñ  É Z% e d  Ñ  É Z& e d! Ñ  d" Ñ  É Z' e d# Ñ  d$ Ñ  É Z( e d% Ñ  d& Ñ  É Z) e d' Ñ  d( Ñ  É Z* e d) Ñ  É Z+ d* Ñ  Z, d+ Ñ  Z- d, Ñ  Z. d- Ñ  Z/ d. Ñ  Z0 e d/ d0 Ñ  d1 d2 Ñ  d3 d4 Ñ  É Z1 d5 Ñ  Z2 e d/ d6 Ñ  d1 d7 Ñ  d3 d8 Ñ  É Z3 dt dt dt dt dt dt dt dt d9 e dt d: Ñ Z4 e4 Z5 dt dt e d; Ñ Z6 dt d9 e d< Ñ Z7 d= Ñ  Z8 d> Ñ  Z9 d? Ñ  Z: d@ Ñ  Z; dt dt dt dt dA Ñ Z< dB Ñ  Z= dt dt dC Ñ Z> dt dD Ñ Z? dE Ñ  Z@ dF Ñ  ZA dG Ñ  ZB dt dH Ñ ZC e dI Ñ ZD dJ Ñ  ZE eF dK Ñ  É ZG dt dt dL Ñ ZH dM Ñ  ZI dt dN Ñ ZJ dt dO Ñ ZK e dP Ñ ZL dt dQ Ñ ZM dt dt dR Ñ ZN dS Ñ  ZO dt dT Ñ ZP dU Ñ  ZQ e d/ dV Ñ  d1 dW Ñ  d3 dX Ñ  É ZR dY Ñ  ZS e dZ Ñ ZT e dt e d[ Ñ ZU d\ Ñ  ZV e d] Ñ ZW d^ Ñ  ZX d_ Ñ  ZY d` Ñ  ZZ da Ñ  Z[ db Ñ  Z\ dc Ñ  Z] dd Ñ  Z^ de Ñ  Z_ dt df Ñ Z` dg Ñ  Za dh Ñ  Zb di dt dj Ñ Zc dk Ñ  Zd dl Ñ  Ze dm Ñ  Zf dn Ñ  Zg do Ñ  Zh dp dq g dr Ñ Zi RS(u   so   
    This is an actual repository object

    Configuration attributes are pulled in from config.RepoConf.
    c         C   sõ  t  j j |  É t j |  | É d  |  _ g  |  _ g  |  _ d |  _ d |  _	 d |  _
 d  |  _ d  |  _ i  |  _ d |  _ d |  _ i  |  _ i  |  _ d |  _ d  |  _ d  |  _ t |  _ i  |  _ d |  _ d |  _ d |  _ d |  _ d |  _ i d d 6d d 6d d	 6d d
 6d d 6d d 6|  _ d  |  _ d  |  _ d  |  _  d  |  _! t |  _" d  |  _# d  |  _$ d  |  _% d  |  _& t' |  _( d  |  _) d  |  _* d  |  _+ d  S(   Ni    s   yumgroups.xmls   repodata/repomd.xmlt   cachecookiet    iË  R1   R   R4   t   groupt
   updateinfot   prestodelta(,   R   t   RepoConfR   R   R9   t   repofilet
   mirrorurlst   _urlst   enablegroupst   groupsfilenamet
   repoMDFilet   _repoXMLRf   t   _oldRepoMDDataRC   t   mirrorlistparsedt   yumvart   _proxy_dictt   metadata_cookie_fnt   _metadataCurrentt	   _metalinkt   Falset   groups_addedt   http_headerst   repo_config_aget   basecachedirt   base_persistdirt   costt
   copy_localt	   retrievedR%   t   failure_objt   mirror_failure_objt   interrupt_callbackt   _callbacks_changedt	   mediafunct   gpg_import_funct   gpgca_import_funct   confirm_funcRG   t   timestamp_checkt   _sackt	   _grabfunct   _grab(   R   R/   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR   Î   sP    																																			c         C   s`   | d k r d St | d É r+ | j } n d } t |  j | É } | rM | St |  j | j É S(   s@    Sort yum repos. by cost, and then by alphanumeric on their id. i   Rå   iË  N(   R9   R5   Rå   t   cmpR   (   R   R4   t   ocostt   ret(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   __cmp__%  s    c         C   s.   |  j  d  k r' t j t j É |  _  n  |  j  S(   N(   Rò   R9   t
   sqlitesackt   YumSqlitePackageSackt   YumAvailablePackageSqlite(   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _getSack2  s    c         C   s0   |  j  d  k	 r |  j j É  n  t j |  É d  S(   N(   Rò   R9   t   sackR   R   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR   >  s    c         C   s   d  |  _ d  S(   N(   R9   Rò   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt
   _resetSackC  s    c         C   s   |  j  É  |  j r |  j Sd  S(   N(   t   doProxyDictRÇ   R9   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   __getProxyDictF  s    
	c         C   s   |  j  S(   s7   Returns the instance of this repository's package sack.(   R£   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   getPackageSackP  s    c         C   s    t  |  d É r |  j d k	 St S(   s;   Returns true if this repository is setup and ready for use.t   metadata_cookieN(   R5   RI   R9   RÜ   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   readyU  s    c         C   sC   d |  j  j É  k r* |  j  j d É } n |  j  j d É } | j S(   s"   Returns the location of the group.t   group_gzRt   (   RI   t	   fileTypesRJ   R_   (   R   t   thisdata(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   getGroupLocation\  s    c         C   s   |  j  S(   N(   R   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   __str__d  s    i   i   c         C   sW   y t  j | | | | É SWn6 t j t f k
 rR } | r? d St j d | Ç n Xd S(   sé   takes filename, hand back Checksum of it
           sumtype = md5 or sha
           filename = /path/to/file
           CHUNK=65536 by defaults#   Error opening file for checksum: %sN(   R   RK   R   t	   MiscErrort   EnvironmentErrorR9   R    (   R   t   sumtypet   filet   CHUNKt   checksum_can_failt   datasizet   e(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt	   _checksumg  s    c          C   sÙ   d |  j  } d' } x⁄ t |  É D]Ã } | j d" É r; q  n  | | k rM q  n  t t |  | É t j É rn q  n  t |  | É } | r± t | É t t É t d# É f k r± d$ } n  t | É t j	 k rÿ d% j
 | É } n  | d& | | f } q  W| S((   Ns   [%s]
Rì   R£   t   metalink_datat   grabt   grabfuncRI   t   cfgRé   RÄ   Rî   Rï   Rè   R%   Rñ   Rá   Rë   R   Rê   Râ   R|   Rç   Rä   Rà   R®   RÉ   t   quick_enable_disableR}   Ró   t   urlsRy   RÅ   Rx   t   _i    Rs   s   ,
   s   %s = %s
(    s	   mediafuncs   sacks   metalink_datas   grabs   grabfuncs   repoXMLRª   s	   retrieveds   mirrorlistparseds   gpg_import_funcs   gpgca_import_funcs   failure_objs   callbacks   confirm_funcs   groups_addeds   interrupt_callbacks   ids   mirror_failure_objs   repo_config_ages   groupsfilenames
   copy_locals   basecachedirs   http_headerss   metadata_cookies   metadata_cookie_fnRº   s
   repoMDFiles   timestamp_checks   urlss
   mirrorurlss   yumvars   repofile(   R   t   dirt
   startswitht
   isinstancet   getattrt   typest
   MethodTypet   typeRÜ   t   ListTypet   join(   R   t   outputt   excluded_varst   attrt   res(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   dumpt  s4              +	c         C   so   |  j  É  y t j |  d d g ÉWnD t k
 rj } | j t j k rX t j | É qk t t | É Ç n Xd S(   s%   Persistently enables this repository.t   onlyt   enabledN(	   t   enableR   t   writeRawRepoFilet   IOErrort   errnot   EACCESt   loggert   warningt   str(   R   R∂   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   enablePersistentí  s    
c         C   so   |  j  É  y t j |  d d g ÉWnD t k
 rj } | j t j k rX t j | É qk t t | É Ç n Xd S(   s&   Persistently disables this repository.RÕ   RŒ   N(	   t   disableR   R–   R—   R“   R”   R‘   R’   R÷   (   R   R∂   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   disablePersistentù  s    
c         C   s9   t  |  j É d k  r5 |  j r5 t j d |  j Ç n  d S(   sh   self-check the repo information  - if we don't have enough to move
           on then raise a repo errori   s(   Cannot find a valid baseurl for repo: %sN(   R   Rz   t   mediaidR   R    R   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   check®  s    c         C   s2  |  j  r d  Si  |  _  d  } d } |  j | k r¯ d |  j } |  j | k r¯ t j |  j d d É} | d } | d } | d d k rí d } n | d d | d	 } d
 | |  j | | f } |  j | k rı d | |  j |  j | | f } qı q¯ n  | d  k	 r.| |  j  d <| |  j  d <| |  j  d <n  d  S(   Nt   _none_Rs   s   %st   allow_fragmentsi    i   i   t   ?i   s   %s://%s@%s%ss   %s://%s:%s@%s%st   httpt   httpst   ftp(   NR‹   Rs   (   RÇ   R9   t   proxyt   proxy_usernamet   urlparset   urlsplitt   proxy_password(   R   t   proxy_stringt   emptyt   proxy_parsedt   proxy_protot
   proxy_hostt
   proxy_rest(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR•   Ø  s0    		

	c         C   s]   g  } x+ |  j  D]  } | j | |  j  | f É q W| pF d |  j  k sY | j d É n  | S(   sA   Convert our dict of headers to a list of 2-tuples for urlgrabber.t   Pragmas   no-cache(   RÌ   s   no-cache(   Rà   R   (   R   RC   t   headerst   key(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   __headersListFromDictœ  s    c         C   s'   t  j d t j d d É|  j É  d  S(   Ns5   setupGrab() will go away in a future version of Yum.
t
   stackleveli   (   t   warningst   warnR   t   YumFutureDeprecationWarningt
   _setupGrab(   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt	   setupGrab⁄  s    	c         C   sî   |  j  d k r t j j } n t j j } |  j É  } t d |  j d |  j d |  j	 d |  j
 d d | ç |  _ | |  j |  j d |  j É|  _ d S(	   s_   sets up the grabber functions with the already stocked in urls for
           the mirror groupst
   roundrobint   progress_objt   failure_callbackRë   Rç   t   regett   simpleN(   t   failovermethodt
   urlgrabbert   mirrort   MGRandomOrdert   MirrorGroupt   _default_graboptsR   R%   Rè   Rë   Rç   Rô   RΩ   Rê   Rö   (   R   t   mgclasst   ugopts(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRı   ﬂ  s    			c         C   s≤   i |  j  d 6|  j d 6|  j d 6|  j d 6|  j d 6|  j d 6t |  j d | É É d 6|  j d	 6|  j d
 6|  j	 d 6|  j
 d 6|  j d 6t j j d 6|  j d 6|  j d 6} | S(   Nt	   keepalivet	   bandwidtht   retryt   throttlet   proxiest   timeoutRC   Rà   t   ssl_verify_peert   ssl_verify_hostt   ssl_ca_certt   ssl_certt   ssl_keyt
   user_agentt   usernamet   password(   R  R  t   retriesR  t
   proxy_dictR	  t   tuplet#   _YumRepository__headersListFromDictt	   sslverifyt	   sslcacertt   sslclientcertt   sslclientkeyR   t   optsR  R  R  (   R   RC   R  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  Û  s     










c         C   s0   |  j  s |  j r) |  j É  t |  _ n  |  j  S(   N(   Rô   Rí   Rı   RÜ   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _getgrabfunc  s    
c         C   s0   |  j  s |  j r) |  j É  t |  _ n  |  j  S(   N(   Rö   Rí   Rı   RÜ   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _getgrab  s    
c         C   s
   |  j  É  S(   N(   R  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   <lambda>  s    c         C   s
   |  j  É  S(   N(   R  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR    s    c         C   só   t  j j | É r( t  j j | É r( d S|  j rD t j d | Ç n  y t  j | d d ÉWn5 t k
 rí } d d | d | f } t j | Ç n Xd S(   s@   make the necessary directory path, if possible, raise on failureNs   Cannot access repository dir %st   modeiÌ  s   %s: %s %s: %ss   Error making cache directorys	   error was(	   R`   Ra   Rd   t   isdirRC   R   R    t   makedirst   OSError(   R   t   dpathR∂   t   msg(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _dirSetupMkdir_p  s    $	c   	      C   s∏  t  j j |  j |  j É } t  j j |  j |  j É } t  j j | d É } t  j j | d É } |  j d | É |  j d | É |  j d | É |  j d | É d } t  j É  d k r¡ d	 } n  |  j d
 | d | É |  j d | d | É |  j d |  j	 } |  j d | É x' |  j |  j
 g D] } |  j | É q(Wx> |  j g D]0 } y |  j | É WqLt j k
 r{} qLXqLW|  j d É |  j d É |  j d É |  j d É d S(   s6   make the necessary dirs, if possible, raise on failuret   packagesRÓ   t   _dir_setup_cachedirt   _dir_setup_pkgdirt   _dir_setup_hdrdirt   _dir_setup_persistdirRs   i    s   -rot   _dir_setup_gpgdirs   /gpgdirt   _dir_setup_gpgcadirs	   /gpgcadirR\   t   _dir_setup_metadata_cookies
   repomd.xmlRr   s   mirrorlist.txts   metalink.xmlN(   R`   Ra   R«   Rä   R   Rã   t   setAttributet   geteuidR8   RÉ   t   pkgdirR$  t
   persistdirR   R    Rc   (	   R   R8   R0  R/  t   hdrdirt   extt   cookieRø   R∂   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   dirSetup$  s4    	c         C   s3   d | } t  |  | É s& |  j É  n  t |  | É S(   s;    Make the directory attributes call .dirSetup() if needed. t   _dir_setup_(   R5   R4  R¬   (   R   R    (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _dirGetAttrJ  s    
c         C   sõ   d | } t  |  | É s& |  j É  n  | d k ri t  |  d É sM g  |  _ n  |  j j t |  | É É n  t |  | | É } | d k ró |  j | É n  | S(   s;    Make the directory attributes call .dirSetup() if needed. R5  R'  t   _old_pkgdirs(   s   _dir_setup_pkgdir(   R5   R4  R7  R   R¬   t   setattrR$  (   R   R    t   valRù   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _dirSetAttrP  s    
c         C   s   |  j  d É S(   NR8   (   R6  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  _  s    c         C   s   |  j  d É S(   NR0  (   R6  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  `  s    c         C   s   |  j  d É S(   NR/  (   R6  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  b  s    c         C   s   |  j  d | É S(   NR/  (   R:  (   R   t   x(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  c  s    c         C   s   |  j  d É S(   NR1  (   R6  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  d  s    c         C   s   |  j  d | É S(   NR1  (   R:  (   R   R;  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  e  s    c         C   s   |  j  d É S(   Nt   gpgdir(   R6  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  f  s    c         C   s   |  j  d | É S(   NR<  (   R:  (   R   R;  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  g  s    c         C   s   |  j  d É S(   Nt   gpgcadir(   R6  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  h  s    c         C   s   |  j  d | É S(   NR=  (   R:  (   R   R;  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  i  s    c         C   s   |  j  d É S(   NR®   (   R6  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  j  s    c         C   s'   t  j d t j d d É|  j É  d  S(   Ns8   baseurlSetup() will go away in a future version of Yum.
RÒ   i   (   RÚ   RÛ   R   RÙ   t   _baseurlSetup(   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   baseurlSetupl  s    	c         C   sF   |  j  r d  S|  j s d  S|  j j d É d k r6 d  S|  j |  _  d  S(   Nt   metalinkiˇˇˇˇ(   R@  t
   mirrorlistt   find(   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _hack_mirrorlist_for_anacondaq  s    		c         C   sv  |  j  |  j É |  _ |  j |  _ g  } |  j É  |  j rl |  j rl | j t |  j j	 É  É É t
 |  _ n  |  j rû |  j rû | j |  j É  É t
 |  _ n  |  j  | É |  _ |  j |  j |  _ t |  j É d k  r\t |  d É r\t j j |  j É r\|  j sYy t j |  j É Wn+ t t f k
 rF} d |  j | f GHqVXd |  j GHqYq\n  |  j |  _ |  j É  d S(   sé   go through the baseurls and mirrorlists and populate self.urls
           with valid ones, run  self.check() at the end to make sure it workedi   t   mirrorlist_files-   Could not delete bad mirrorlist file: %s - %ss-   removing mirrorlist with no valid mirrors: %sN(   t   _replace_and_check_urlt   baseurlt   _orig_baseurlRC  R@  RÄ   t   extendt   listR∏   RΩ   RG   RA  t   _getMirrorListRy   Rz   R   R5   R`   Ra   Rd   RD  RC   R   RE   R—   R!  R€   (   R   Ry   R∂   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR>  Ä  s,    
$	c         C   s  g  } d  } x¡ | D]π } | d k r+ q n  t j | |  j É } | d d k r] | d } n  y% t j | É \ } } } } }	 }
 Wn" t t t f k
 r¶ } d } n X| d k rø | } q q | j | É q W| d  k	 r| r˜ d	 t	 j
 | É GHqd
 t	 j
 | É GHn  | S(   NRs   iˇˇˇˇR\   t   blahRﬂ   R·   R≤   R‡   sM   YumRepo Warning: Some mirror URLs are not using ftp, http[s] or file.
 Eg. %ssJ   YumRepo Error: All mirror URLs are not using ftp, http[s] or file.
 Eg. %s(   Rs   N(   s   https   ftps   files   https(   R9   t   parsert
   varReplaceRÅ   R‰   t
   ValueErrort
   IndexErrort   KeyErrorR   R   t   to_utf8(   R   t   url_listt   goodurlst   skippedt   urlt   st   bt   pt   qt   ft   oR∂   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRE  §  s*    %
c         C   s   |  j  s |  j É  n  |  j  S(   N(   Rz   R>  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _geturls¬  s    	t   fgetc         C   s
   |  j  É  S(   N(   R\  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  «  s    t   fsetc         C   s   t  |  d | É S(   NRz   (   R8  (   R   t   value(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  »  s    t   fdelc         C   s   t  |  d d  É S(   NRz   (   R8  R9   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  …  s    c         C   s©  |  j  s¢|  j d d |  _ |  j d } |  j É  st j |  j É } |  j É  } y8 t d |  j	 | ç } | j
 | | d |  j d É} Wqt j j k
 r} t j j |  j É s“ d |  } t j | Ç n  d | | j d	 t j | j d
 É f GHt |  _ qXn  |  j s~y) t j | É |  _  t j | |  j É Wq~t j k
 rz} d | | f GHt |  _ t j | É q~Xn  |  j r¢t j |  j É |  _  q¢n  |  j  S(   NR\   s   metalink.xmls   .tmpR¯   t   texts	   /metalinksQ   Cannot retrieve metalink for repository: %s. Please verify its path and try agains*   Could not get metalink %s error was
%s: %si    i   s)   Could not parse metalink %s error was 
%s(   RÖ   R8   t   metalink_filenamet   _metalinkCurrentR   RQ  R@  R  R   R%   t   urlgrabR   R˝   t   grabberR   R`   Ra   Rd   R   R    t   argst
   to_unicodeRG   RÑ   t   MetaLinkRepoMDt   shutilt   movet   MetaLinkRepoErrorParseFailRE   (   R   t   localRU  R  t   ugRm   R∂   R#  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _getMetalinkÀ  s6    	#)			c         C   s
   |  j  É  S(   N(   Rn  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  Ô  s    c         C   s   t  |  d | É S(   NRÖ   (   R8  (   R   R_  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR    s   	c         C   s   t  |  d d  É S(   NRÖ   (   R8  R9   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  Ú  s    R˚   c         C   sp  | d k r |  j } n  | d k s0 | d k rF t j d |  j Ç n  |  j d k rÑ t j j | É rk | St j d | |  f Ç n  | r´ t	 j
 | É \ } } } } } n  |  j r|  j rd } | rÌ | d k rÌ | rÌ t | É } qÌ n  y\ |  j d | d | d | d | d	 | d
 | d |  j d |  j d | d | | f É 
} | SWqt j k
 r{} t j t j d | f É qXn  | r£| d k r£|  j d |
 É } t d |  j d	 | d |	 d |  j d |  j d | d | | ç } | d | } y: | j t j | É | d t j | É d | | f É} Wqlt k
 rü} d | |  j | f } |  j rr| d 7} | d 7} n  | j d k rêt j | Ç q†t j | Ç qlXn… t  |  j! d |
 É É } y[ |  j" j t j | É | d t j | É d | | f d	 | d |	 d | d | d | É} WnS t k
 rk} d | |  j | f } | j d k r\t j | Ç qlt j | Ç n X| S(   s±   retrieve file from the mirrorgroup for the repo
           relative to local, optionally get range from
           start to end, also optionally retrieve from a specific baseurls/   get request for Repo %s, gave no source or desti   s0   Caching enabled but no local cache of %s from %sR    Rl  t	   checkfunct   relativeRa  Rç   RU  R⁄   t   namet   discnumt   ranges8   Error getting package from media; falling back to url %sRC   R¯   R˙   R˘   Rë   t   sizeR\   s*   failed to retrieve %s from %s
error was %ss0   
  You could try running: yum clean expire-caches   
  To get a new set of mirrors.i   Rà   s   failure: %s from %s: %sN(#   R9   Rç   R   R    R   RC   R`   Ra   Rd   R‰   RÂ   R⁄   Rì   t   intRq  t
   MediaErrort   verbose_loggert   logt   logginglevelst   DEBUG_2R  R   R%   Rè   Rë   Rd  R   RQ  R   Ry   R“   t   NoMoreMirrorsRepoErrorR  R  Rπ   (   R   RU  Rp  Rl  t   startt   endRç   Ro  Ra  R˙   RC   Rt  t   schemet   netlocRa   t   queryt   fragidRr  Rm   R∂   R  Rm  Rj   t   errstrRÓ   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _getFileÙ  s|    !T!				
c         C   sÑ   | j  } | j É  } | j } |  j | É rM | j É  r= | St j | É n  |  j d | d | d | d | d | d | d | j É S(   NRU  Rp  Rl  Ro  Ra  RC   Rt  (	   t   relativepatht   localPkgt   basepatht   _preload_pkg_from_system_cachet   verifyLocalPkgR   RE   RÉ  Rt  (   R   t   packageRo  Ra  RC   Rj   Rl  RÜ  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt
   getPackageV  s    		c         C   s®   | j  } | j É  } | j } | j } | | }	 | j }
 t j j |  j É sb t j	 |  j É n  |  j
 d |
 d | d | d | d d  d | d | d d	 d
 | d |	 É 
S(   NRU  Rp  Rl  R|  R˙   R}  Ro  Rç   i   RC   Rt  (   RÑ  t   localHdrt   hdrstartt   hdrendRÜ  R`   Ra   Rd   R1  R   RÉ  R9   (   R   Râ  Ro  R˙   RC   Rj   Rl  R|  R}  Rt  RÜ  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt	   getHeaderi  s    			
	!c         C   s¬   |  j  d k	 r |  j  S|  j |  j |  j É } | sA | |  _  | S|  j d d } t j j | É sq t	 |  _  t	 S|  j
 É  |  j d d } |  j rµ t j j | É rµ t	 |  _  t	 St |  _  t S(   sÚ   Check if there is a metadata_cookie and check its age. If the
        age of the cookie is less than metadata_expire time then return true
        else return False. This result is cached, so that metalink/repomd.xml
        are synchronized.R\   s
   repomd.xmls   metalink.xmlN(   RÑ   R9   t   withinCacheAgeR®   t   metadata_expireR8   R`   Ra   Rd   RÜ   RC  R@  RG   (   R   t   mC_deft   repomdfnt   mlfn(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   metadataCurrent{  s"    		
		c         C   s≤   |  j  d  k	 r |  j  S|  j rH t j j |  j É rH t j d |  Ç n  |  j r] t	 |  _  nN t j j |  j É s~ t
 |  _  n- |  j |  j |  j É r¢ t	 |  _  n	 t
 |  _  |  j  S(   Ns$   Cannot find metalink.xml file for %s(   RÑ   R9   RC   R`   Ra   Rd   Rb  R   R    RG   RÜ   Rè  R®   Rê  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRc  õ  s    		c         C   s¥   | d k r" t  j j | É r" t St } t  j j | É r∞ t  j | É } | d | t j É  k rl t } n | d t j É  k rã t } n  | d t |  j É k  r∞ t } q∞ n  | S(   sx  check if any file is older than a certain amount of time. Used for
           the cachecookie and the mirrorlist
           return True if w/i the expiration time limit
           false if the time limit has expired

           Additionally compare the file to age of the newest .repo or yum.conf
           file. If any of them are newer then invalidate the cache
           iˇˇˇˇi   (	   R`   Ra   Rd   RG   RÜ   t   statt   timeRu  Râ   (   R   t   myfilet   expiration_timeR9  t   cookie_info(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRè  ¨  s    		c         C   se   |  j  } t j j |  j  É s* |  j } n  t j | t j É ra t |  j  d É } | j É  ~ n  d S(   s/   if possible, set touch the metadata_cookie files   w+N(	   R®   R`   Ra   Rd   R8   t   accesst   W_OKt   openR   (   R   R€   t   fo(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   setMetadataCookie…  s    	
c         C   s†   y1 | |  _  | |  _ | |  _ | |  _ | |  _ Wn t j k
 rL } Ç  n X|  j rú |  j rú |  j rú |  j	 rú t
 j t j d É t |  _ t |  _ n  d  S(   Ns1   Disabling media repo for non-media-aware frontend(   RC   Rì   Rî   Rï   Rñ   R   R    R⁄   RA  RF  Rw  Rx  Ry  Rz  RÜ   RŒ   RG   t   skip_if_unavailable(   R   RC   Rì   Rî   Rñ   Rï   R∂   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   setup’  s    				'	c         C   sL   |  j  r/ t j j | É r/ t j d |  Ç n  |  j  sD |  j É  rH t St S(   s(    Should we cache the current repomd.xml s"   Cannot find repomd.xml file for %s(	   RC   R`   Ra   Rd   R   R    Rî  RG   RÜ   (   R   Rl  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _cachingRepoXML„  s
    c         C   st  |  j  d i  f } | d k r0 d |  j k } n  d } yv t j d d d d d t j j | É É } |  j d |  j	 d	 | d
 d d | d d d | d |  j
 d k d d É } Wnv t k
 rÓ } t j | É | r’ d St j d | | f Ç n7 t j t j f k
 r$t j | É | rd SÇ  n Xy t j | | É Wn4 t j | É | rVd St j d | | f Ç n X| S(   s*    Call _getFile() for the repomd.xml file. t   old_repo_XMLRs   t   prefixt   repomdt   suffixs   tmp.xmlRø   Rp  Rl  Rç   i   Ra  R˙   Ro  RC   R,   Rt  i ê s   Error downloading file %s: %ss   Error renaming file %s to %s(    N(   t   _checkRepoXMLR9   R   t   tempfilet   mktempR`   Ra   t   dirnameRÉ  R}   t   http_cachingR   R   RE   R   R    R{  t   rename(   R   Rl  Ra  t   grab_can_failRo  t   tfnameRm   R∂   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _getFileRepoXMLÎ  sD    c         C   sr   y t  j |  j | É SWnT t j k
 rm } | d k rJ d |  j k } n  | rT d St j d |  | f Ç n Xd S(   s    Parse the repomd.xml file. R¢  s&   Error importing repomd.xml from %s: %sN(   t   repoMDObjectt   RepoMDR   R   t   RepoMDErrorR9   R   R    (   R   Rl  t   parse_can_failR∂   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _parseRepoXML  s    c         C   s©   x+ t  j  |  j d É D] } t j | É q Wt j j | É r• | d } t j | | É |  j	 | t
 É } | d k r| d Si | d 6| d 6| d 6g  d 6|  _ | Sd S(   s=    If we have an older repomd.xml file available, save it out. s
   /*.old.tmps   .old.tmpR¢  Rl  t	   old_localt   new_MD_filesN(   t   globR8   R   RE   R`   Ra   Rd   Ri  t   copy2R≥  RG   R9   R   (   R   Rl  Rk   R¥  RW   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _saveOldRepoXML   s    
c         C   s‹   |  j  s t j d Ç n  d |  j k r4 i  |  _ d Sx" |  j d D] } t j | É qB W|  j } i  |  _ d | k rí t j | d | d É n  | d |  _ d | k rØ d Sx& | d D] } t j | d | É q∫ Wd S(	   s0    If we have older data available, revert to it. s#   Can't download or revert repomd.xmlR¢  NRµ  R¥  Rl  t   old_MD_filess   .old.tmp(	   Ró   R   R    R   R   RE   R`   R´  R~   (   R   Rk   t   old_datat   revert(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _revertOldRepoXML1  s     				c         C   sl   |  j  } i  |  _  d | k r2 t j | d É n  d | k rB d Sx# | d D] } t j | d É qM Wd S(   s     Done with old data, delete it. R¥  Rπ  Ns   .old.tmp(   R   R   RE   (   R   R∫  Rª  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _doneOldRepoXMLP  s    		c         C   sá   | d  k r |  j } n  | d k r? d | j É  k r? d } n  | d k rq |  j | d d | Érq | d 7} n  | | j j | É f S(	   NRt   R™   R4   R   R1   t   _dbRI   (   s   others	   filelistss   primary(   R9   RI   R´   R@   t   repoDatat   get(   R   RL   RI   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _get_mdtype_data]  s    	c         C   sN   | j  \ } } |  j d t j j | É } | rJ t j | d t É} n  | S(   NR\   R]   (   R_   R8   R`   Ra   Rb   R   RD   RG   (   R   RN   t
   compressedRi   Rj   Rl  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _get_mdtype_fnamei  s
    c         C   sx   d |  j  k r t S|  j  d } |  j rt | j |  j j k rt t j d t j | j É t j |  j j É f É t	 St S(   s|    We check the timestamps, if any of the timestamps for the
            "new" data is older than what we have ... we revert. R¢  sh   Not using downloaded repomd.xml because it is older than what we have:
  Current   : %s
  Downloaded: %s(
   R   RG   Ró   t	   timestampRI   R‘   R’   Rñ  t   ctimeRÜ   (   R   R¢  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _groupCheckDataMDNewerq  s    		c         C   sÉ   |  j  | j  k r t S|  j | j k r, t St } xJ |  j D]? } | | j k rW q< n  |  j | | j | k ru t St } q< W| S(   s7    Check parsed repomd.xml against metalink.repomd data. (   Rƒ  RÜ   t   lengthRt  t	   checksumst   chksumsRG   (   RI   R§  t   doneRK   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _checkRepoXMLMetalinkÉ  s    
c         C   s≤   | d k r |  j } n  | d k r0 |  j } n  |  j | | j É rI t Sxb |  j j D]T } |  j | | É rV t j t	 j
 d t j | j j É t j | j É f É t SqV Wt S(   s@    Check the repomd.xml against the metalink data, if we have it. s/   Using older repomd.xml
  Latest: %s
  Using: %sN(   R9   R~   R∏   RÀ  R§  RG   t   old_repomdsRw  Rx  Ry  Rz  Rñ  R≈  Rƒ  RÜ   (   R   RI   R∏   R§  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _checkRepoMetalinkô  s    c         C   sk   |  j  | É } | s t S|  j É  |  j s0 t S|  j j } |  j r[ | j | j k r[ t S|  j	 | | É S(   sx    Save the Old Repo XML, and if it exists check to see if it's the
            latest available given the metalink data. (
   R∏  RÜ   RC  R@  R∏   R§  Ró   Rƒ  RG   RÀ  (   R   Rl  t   oxmlR§  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _latestRepoXML≤  s    
	c         C   s  |  j  d } |  j d k	 r  t S|  j | É r> t } | } nj t } |  j | É rr | } |  j } | d |  _ n, |  j | | É } | d k rû |  j	 É  t S|  j
 É  |  j d k rÃ |  j | É |  _ n  |  j d k rÈ |  j	 É  t S| |  _ | r¸ t S|  j É  s|  j	 É  t St S(   s`    Common LoadRepoXML for instant and group, returns False if you
            should just return. s   /repomd.xmlR¢  N(   R8   R~   R9   RÜ   R°  RG   Rœ  R   RÆ  Rº  Rû  R≥  Rf   R∆  (   R   Ra  t   mdtypesRl  t   cachingRm   R∫  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _commonLoadRepoXML…  s8    		


	
c         C   sH   | d  k r |  j } n  | | j k rD t | j | j k rD t Sn  t S(   N(   R9   RI   Rø  t	   DBVERSIONt	   dbversionRG   RÜ   (   R   RL   RI   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR@   Ú  s    c      	   C   s«   | d k r d S| s: | j d É } |  j | | É } nH t } |  j | t É } t j j | É sÇ t j | d t	 É} t	 } n  |  j
 t j j | É É |  j | | d | d | d t	 És√ d S| S(   sÅ    Check that we already have this data, and that it's valid. Given
            the DB mdtype and the main mdtype (no _db suffix). Ræ  R]   R^   RN   t   check_can_failN(   R9   t   endswithR√  RÜ   R`   Ra   Rd   R   RD   RG   Rc   Rb   t   _checkMD(   R   RN   t   dbmdtypet   mmdtypet
   file_checkR¬  Rl  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _groupCheckDataMDValid¸  s    	c         C   sg  d Ñ  } |  j  j É  } | d k r- | } n  g  } d |  j k rK d } n |  j d } | |  j d <g  |  j d <g  } g  } x[| D]S} |  j | É \ }	 }
 | ra|  j | d | É\ } } |  j | | | t É } | ra| | | |	 |
 É r˙ qÖ n  t j | | d É | j	 | É | d } t j
 j | É r^t j | | d É | j	 | É q^qan  |
 d k rsqÖ n  | | k rÖqÖ n  |  j |
 |	 | É r†qÖ n  |
 j d k r≈| j	 |
 |	 f É qÖ | j	 |
 |	 f É qÖ Wt | É d k r| j | É g  } n  d	 } d	 } x' | D] \ }
 }	 | t |
 j É 7} qWx] | D]U \ }
 }	 t j j | | É |  j |	 d
 t ÉsÉ|  j É  t S| t |
 j É 7} qAWt j j d	 É x7 | D]/ \ }
 }	 |  j |	 d
 t És±|  j É  t Sq±Wxr | | D]f \ }
 }	 |  j |
 t É } |	 j d É rA| } t j | É } t j | É n  |  j d j	 | É qÔW|  j É  t S(   s˚    Retrieve any listed mdtypes, and revert if there was a failure.
            Also put any of the non-valid mdtype files from the old_repo_XML
            into the delete list, this means metadata can change filename
            without us leaking it. c         S   s|   | d k r t S|  | k r  t S| j | j k r6 t St j j | j d É } t j j | j d É } | | k rx t St S(   s9    Check if two returns from _get_mdtype_data() are equal. i   N(   R9   RÜ   RK   R`   Ra   Rb   R_   RG   (   t   omdtypet   odatat   nmdtypet   ndatat   ornamet   nrname(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt
   _mdtype_eq  s    R¢  Rπ  Rµ  RI   s   .old.tmps   .sqlitei   i    t   retrieve_can_failRæ  N(   Ré   t   keysR9   R   R¡  R€  RG   R`   R´  R   Ra   Rd   Rt  R   RH  Ru  R˝   t   progresst   text_meter_total_sizeRB   Rº  RÜ   R√  R÷  R   RD   RE   RΩ  (   R   R–  R‚  t   all_mdtypest   revertsR¢  t   downloading_with_sizet   downloading_no_sizeRL   Rﬁ  Rﬂ  R‹  R›  Rl  t	   gen_localt   remote_sizet
   local_sizet   dl_local(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _commonRetrieveDataMD  s~    			
	


c         C   s#   |  j  | É r |  j | É n  d S(   sç   Retrieve the new repomd.xml from the repository, then check it
            and parse it. If it fails we revert to the old version and pretend
            that is fine. If the new repomd.xml requires new version of files
            that we have, like updateinfo.xml, we download those too and if any
            of those fail, we again revert everything and pretend old data is
            good. N(   R“  RÔ  (   R   Ra  R–  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _groupLoadRepoXMLà  s    c         C   s‚   i g  d 6d g d 6d d g d 6d d d d d g d	 6} t  É  } t |  j É t j k rÄ | j | j |  j |  j g É É n0 x- |  j D]" } | j | j | | g É É qä W| s√ d
 | k rÃ d  } n t t	 | É É } | S(   Nt   instantR1   s   group:primaryRu   s   group:smallRt   R   Rv   s
   group:mains	   group:all(
   t   setR≈   t   mdpolicyR√   t   StringTypest   updateR¿  R9   t   sortedRI  (   R   t	   md_groupsR–  RÛ  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _mdpolicy2mdtypesì  s    

		% 	c         C   sR   y |  j  | |  j É  É SWn t k
 r: |  j É  Ç  n Xt j d |  j Ç d S(   s5   retrieve/check/read in repomd.xml from the repositorys   Bad loadRepoXML policy: %sN(   R  R¯  t   KeyboardInterruptRº  R   R    RÛ  (   R   Ra  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _loadRepoXML¶  s    
c         C   sZ   |  j  r |  j  Sy |  j d |  É Wn, t j k
 rR } d |  } t j | Ç n X|  j  S(   NRa  si   Cannot retrieve repository metadata (repomd.xml) for repository: %s. Please verify its path and try again(   R~   R˙  R   R    (   R   R∂   R#  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _getRepoXMLØ  s    	c         C   s
   |  j  É  S(   N(   R˚  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  ª  s    c         C   s   t  |  d | É S(   NR~   (   R8  (   R   R9  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  º  s    c         C   s   t  |  d d  É S(   NR~   (   R8  R9   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR  Ω  s    c         C   s  t  | É t j k r! | j } n | } |  j rê|  j rêt j d  k r_ t	 d d |  É Ç n  |  j
 d } yP |  j d d d d d | d	 d
 |  j d d  d d  d |  j d k d d É } Wn, t	 k
 rÍ } t	 d d |  | f É Ç n Xt j | | |  j É } | rq|  j rqy |  j |  |  j É Wn) t j k
 rU} t	 d d |  É Ç n Xt j | | |  j É } n  | sêt	 d d |  É Ç qên  y t j |  j | É } Wn/ t j k
 r⁄} t	 d d |  | f É Ç n X|  j É  |  j r|  j | É rt	 d d |  É Ç n  d  S(   Niˇˇˇˇs?   pygpgme is not working so repomd.xml can not be verified for %ss   /repomd.xml.ascRp  s   repodata/repomd.xml.ascRç   i   Rl  Ra  s   %s/signatureR˙   Ro  RC   R,   Rt  i ê s1   Error finding signature for repomd.xml for %s: %ss;   Gpg Keys not imported, cannot verify repomd.xml for repo %ss1   repomd.xml signature could not be verified for %ss%   Error importing repomd.xml for %s: %ss)   repomd.xml does not match metalink for %s(   R≈   R√   t   InstanceTypet   filenamet   repo_gpgcheckt   _override_sigchecksR   t   gpgmeR9   R   R8   RÉ  R   R™  t   valid_detached_sigR<  Rî   Rñ   R   t   YumBaseErrorRØ  R∞  R±  RC  R@  RÕ  (   R   Rù  t   filepatht   sigfileRm   R∂   t   validRI   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR¶  ø  sF    
	c         C   s   |  j  | | | É S(   s,   check the metadata type against its checksum(   R◊  (   R   t   fnRL   R^   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRg   Ï  s    c         C   s  | } | d k r' |  j j | É } n  | rH | j \ } } | j }	 n | j \ } } | j }	 t | É t j	 k rÅ | j
 }
 n | }
 |	 d k	 r¢ t |	 É }	 n  y |  j | |
 d |	 É} Wn/ t j k
 rÔ } | r› d St d d É Ç n X| | k r d S| r
d St d d É Ç d S(   s5    Internal function, use .checkMD() from outside yum. Rµ   i˝ˇˇˇs   Error performing checksumi   iˇˇˇˇs%   Metadata file does not match checksumN(   R9   RI   RJ   R^   t   opensizeRK   Rt  R≈   R√   R¸  R˝  Ru  R∑   R   R    R   (   R   R  RL   R^   RN   R’  R¨   t   r_ctypet   r_csumRt  R≤   t   l_csumR∂   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR◊    s0    	c         C   s   |  j  | É S(   s∆   base function to retrieve metadata files from the remote url
           returns the path to the local metadata file of a 'mdtype'
           mdtype can be 'primary', 'filelists', 'other' or 'group'.(   RB   (   R   RL   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt
   retrieveMD  s    c         C   sz  |  j  j | É } | j \ } } t j j | É } |  j d | } |  j j | É rZ | S|  j	 d k r’ t j j
 | É rº y |  j | | É Wn# t k
 r¥ } t j d | Ç q“ X| Sq’ t j d | |  f Ç n  t j j
 | É s|  j t j j | É É r.|  j | | d t Ér.d |  j | <| Sn  yÿ |  j | f i  f }	 d |  j | f }
 | j d k rqd } nL d } t j j
 | É rΩt j | É j t | j É k rΩt j | É qΩn  |  j d | d	 | d
 d d | d |	 d |
 d |  j d k d | j É } Wn\ t j t j f k
 r2| r,d SÇ  nD t k
 rd} | rKd St j d | |  f Ç n Xd |  j | <| Sd S(   s8    Internal function, use .retrieveMD() from outside yum. R\   i   s;   Caching enabled and local cache: %s does not match checksums0   Caching enabled but no local cache of %s from %sR’  s   %s/%sR˚   Rp  Rl  Rç   R˙   Ro  Ra  RC   R,   Rt  s6   Could not retrieve %s matching remote checksum from %sN(   RI   RJ   R_   R`   Ra   Rb   R8   Ré   R¿  RC   Rd   Rg   R   R   R    Rc   R◊  RG   R   Rt  R9   Rï  t   st_sizeRu  R   RE   RÉ  R™  R{  (   R   RL   R„  R¨   Ri   Rj   Rk   Rl  R∂   Ro  Ra  R˙   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRB     sd    	!c         C   s   |  j  d É S(   s]   this gets you the path to the primary.xml file, retrieving it if we
           need a new oneR1   (   R  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR:   c  s    c         C   s   |  j  d É S(   s_   this gets you the path to the filelists.xml file, retrieving it if we
           need a new oneR   (   R  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR<   j  s    c         C   s   |  j  d É S(   NR4   (   R  (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR>   p  s    c         C   s;   d |  j  j É  k r( |  j d d t ÉS|  j d d t ÉS(   sg   gets groups and returns group file path for the repository, if there
           is none it returns NoneR™   R„  Rt   (   RI   R´   RB   RG   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt	   getGroupss  s    c         C   s   | |  _  t |  _ d  S(   N(   R%   RG   Rí   (   R   R%   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   setCallbackz  s    	c         C   s   | |  _  t |  _ d  S(   N(   Rè   RG   Rí   (   R   Rè   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   setFailureObj~  s    	c         C   s   | |  _  t |  _ d  S(   N(   Rê   RG   Rí   (   R   Rè   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   setMirrorFailureObjÇ  s    	c         C   s   | |  _  t |  _ d  S(   N(   Rë   RG   Rí   (   R   R%   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   setInterruptCallbackÜ  s    	c         C   s…   g  } g  } | d k	 rø y | j É  } Wn= t k
 rg } | d k rO d } n  d | | f GHg  } n XxT | D]I } t j d | É rç qo n  | j É  } | j d d É } | j | É qo Wn  | | f S(   s5    read the mirror list from the specified file object s	   <unknown>s+   Could not read mirrorlist %s, error was 
%ss   \s*(#|$)s   $ARCHs	   $BASEARCHN(   R9   t	   readlinest	   Exceptiont   ret   matcht   rstript   replaceR   (   R   Rù  RU  t
   returnlistt   contentR∂   t   lineR˛   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _readMirrorListä  s"    	
c         C   sƒ  |  j  d d |  _ d
 } t } |  j |  j |  j É r` t } t |  j d É } d |  j } n• |  j } t	 j	 | É d } | d k rï d | } n  |  j
 É  } y t j j | | ç } WnH t j j k
 r} d | | j d t j | j d É f GHd
 } n X|  j | | É \ } } | rt|  j r¿| r¿t |  j d	 É }	 x | D] }
 |	 j |
 É qMW|	 j É  q¿nL | r¿t j j |  j É r¿t j |  j d
 É |  j t |  j d É É d S| S(   s$  retrieve an up2date-style mirrorlist file from our mirrorlist url,
           also save the file to the local repo dir and use that if cache expiry
           not expired

           we also s/$ARCH/$BASEARCH/ and move along
           return the baseurls from the mirrorlist file
           R\   s   mirrorlist.txtt   rs   file://i    Rs   s1   Could not retrieve mirrorlist %s error was
%s: %si   t   wN(   R8   RD  R9   RÜ   Rè  t   mirrorlist_expireRG   Rú  RA  R‰   R  R˝   Re  t   urlopenR   Rf  R   Rg  R  RC   t   writeR   R`   Ra   Rd   t   utime(   R   Rù  t   cacheokRU  R~  R  R∂   R  R  R»   R  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRJ  †  s8    	)
c         C   so   t  j j | É s t St  j j | É r[ t  j | É t j t  j | É t j k r[ t Sn  t j | | É t S(   s&   attempts to copy the file, if possible(	   R`   Ra   Rd   RÜ   Rï  t   ST_CTIMERi  R∑  RG   (   R   R  t   destfn(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _preload_fileÀ  s    ,Rs   c         C   s‡   t  |  d É s t S|  j d k r& t St j j |  j |  j É } t j j | É sW t St j j | É t j j |  j	 É k rÇ t S| d | t j j
 | É } | d k r– |  j	 d | t j j
 | É } n  |  j | | É S(   sL   attempts to copy the file from the system-wide cache,
           if possiblet   old_base_cache_dirRs   R\   N(   R5   RÜ   R&  R`   Ra   R«   R   Rd   t   normpathR8   Rb   R9   R%  (   R   R˝  t   subdirR$  t   glob_repo_cache_dirR  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _preload_file_from_system_cache÷  s    '$c         C   s   |  j  | É S(   sU   attempts to copy the metadata file from the system-wide cache,
           if possible(   R*  (   R   R˝  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRc   Î  s    c         C   s•   t  j j | j É  É } t  j j |  j | É } |  j | j É  d d d | ÉrU t St |  d É sh t	 Sx6 |  j
 D]+ } |  j t  j j | | É | É rr t Sqr Wt	 S(   sO   attempts to copy the package from the system-wide cache,
           if possibleR(  s	   packages/R$  R7  (   R`   Ra   Rb   RÖ  R«   R/  R*  RG   R5   RÜ   R7  R%  (   R   t   pkgt   pnameR$  t   opkgdir(    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRá    s    	!c         C   s‘   g  } d GHy |  j  j É  } Wn< t j k
 r\ } t d d t | É É } | j | É | SXxp | D]h } d | GHy |  j | É Wqd t j k
 rÀ } d | } t d | t | É É } | j | É qd Xqd W| S(   Ns   verifying mdi   s   failed to load repomd.xmls   verifying %ss.   %s metadata missing or does not match checksumi   (   RI   R´   R   R    t   RepoVerifyProblemR÷   R   R  (   R   t   problemst   md_typesR∂   t   prbt   md_typeR#  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt
   _verify_md  s"    	
c         C   s⁄   d GHg  } |  j  É  } | d  k	 r5 t j | É } n  y t j É  } | j | É WnJ t j t j	 f k
 rû } d } t
 t | t | É É } | j | É n8 X| j d k r÷ d } t
 t | d É } | j | É n  | S(   Ns   verifying compss   comps file failed to addi    s   no groups in compsRs   (   R  R9   R   RD   R   t   Compst   addR   t   GroupsErrort   CompsExceptionR.  t   REPO_PROBLEM_COMPSR÷   t
   compscount(   R   R/  t   grpfilet   cR∂   R#  R1  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _verify_comps  s"    c         C   s   g  S(   N(    (   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   _verify_packages2  s    t   repodataR   c         C   s|   g  } d | k r( | j  |  j É  É n  d | k rV |  j rV | j  |  j É  É qV n  d | k rx | j  |  j É  É n  | S(   s}   download/verify the specified items
           @items = ['repodata', 'comps'] can include: repodata, comps, packages
        R>  R   R%  (   RH  R3  R{   R<  R=  (   R   t   itemsR/  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   verify5  s    	i   N(j   Rn   Ro   Rp   R   Rû   R¢   t   propertyR£   R   R§   t   _YumRepository__getProxyDictR  Rß   R©   R≠   RÆ   RÜ   R9   R∑   RÃ   R◊   RŸ   R€   R•   RG   R  Rˆ   Rı   R  R  R  R∫   Rπ   R$  R4  R6  R:  R8   R0  R/  R1  R<  R=  R®   R?  RC  R>  RE  R\  RΩ   Rn  R∏   RÉ  t   _YumRepository__getRä  Ré  Rî  Rc  Rè  Rû  R†  R°  RÆ  R≥  R∏  Rº  RΩ  R¡  R√  R∆  t   staticmethodRÀ  RÕ  Rœ  R“  R@   R€  RÔ  R  R¯  R˙  R˚  RI   R¶  Rg   R◊  R  RB   R:   R<   R>   R  R  R  R  R  R  RJ  R%  R*  Rc   Rá  R3  R<  R=  R@  (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyRq   ‰   sÊ   	:		
												 						&									$				$	^	 				*					)
q					-'	E									+						c         C   sX  t  j d t j d d Ég  } t t j d É r= t j } n d d  l } | } t j |  É d } | d k r{ d |  } n |  } y | j	 | d	 | É} WnH t j j
 k
 r‰ } d
 | | j d t j | j d É f GHd  } n X| d  k	 rT| j É  }	 xT |	 D]I }
 t j d |
 É r"qn  |
 j É  } | j d d É } | j | É qWn  | S(   Ns9   getMirrorList() will go away in a future version of Yum.
RÒ   i   R  iˇˇˇˇi    Rs   s   file://R  s1   Could not retrieve mirrorlist %s error was
%s: %si   s   \s*(#|$)s   $ARCHs	   $BASEARCH(   RÚ   RÛ   R   RÙ   R5   R˝   Re  t   urllibR‰   R  R   Rf  R   Rg  R9   R  R  R  R  R  R   (   RA  t   pdictR  t   urlresolverRE  R~  RU  Rù  R∂   R  R  R˛   (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   getMirrorListF  s2    	)
R.  c           B   s   e  Z d  Z e d Ñ Z RS(   s9    Holder for each "problem" we find with a repo.verify(). c         C   s(   | |  _  | |  _ | |  _ | |  _ d  S(   N(   R≈   t   messaget   detailst   fake(   R   R≈   R#  RJ  RK  (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR   n  s    			(   Rn   Ro   Rp   RÜ   R   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyR.  k  s   (3   R`   R  Rñ  R√   R‰   t   uses_fragmentR   t   AttributeErrort   errR   t   urlgrabber.grabberR   R   t   urlgrabber.mirrorR˝   R   RØ  R   t   reposR   RL  R6   Rü   t   yumR   R   R   t	   constantsR@  t   loggingRy  RÚ   R∂  Ri  Rï  R“   Rß  RG   Re   t   simplefilterRÙ   t	   getLoggerR‘   Rw  R   R
   Rw   Rq   R9   RH  R.  (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/yumRepo.pyt   <module>   s\   	

ùˇ ˇ ˇ ˇ ˇ ˇ h%                                                                                                                  usr/lib/python2.7/dist-packages/yum_metadata_parser-1.1.4.egg-info                                  0120777 0000000 0000000 00000000000 12153200036 035070  2../../../share/pyshared/yum_metadata_parser-1.1.4.egg-info                                          ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python2.7/distutils/                                                                        0040755 0000000 0000000 00000000000 13077704274 014436  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python2.7/distutils/README                                                                  0100644 0000000 0000000 00000000447 12734733743 015322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        This directory contains the Distutils package.

There's a full documentation available at:

    http://docs.python.org/distutils/

The Distutils-SIG web page is also a good starting point:

    http://www.python.org/sigs/distutils-sig/

WARNING : Distutils must remain compatible with 2.3

$Id$
                                                                                                                                                                                                                         usr/lib/python2.7/distutils/__init__.py                                                             0100644 0000000 0000000 00000000521 12734733743 016544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils

The main package for the Python Module Distribution Utilities.  Normally
used from a setup script as

   from distutils.core import setup

   setup (...)
"""

__revision__ = "$Id$"

# Distutils version
#
# Updated automatically by the Python release process.
#
#--start constants--
__version__ = "2.7.9"
#--end constants--
                                                                                                                                                                               usr/lib/python2.7/distutils/__init__.pyc                                                            0100644 0000000 0000000 00000000577 13077704274 016720  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s   d  Z  d Z d Z d S(   s•   distutils

The main package for the Python Module Distribution Utilities.  Normally
used from a setup script as

   from distutils.core import setup

   setup (...)
s   $Id$s   2.7.9N(   t   __doc__t   __revision__t   __version__(    (    (    s(   /usr/lib/python2.7/distutils/__init__.pyt   <module>	   s                                                                                                                                    usr/lib/python2.7/distutils/archive_util.py                                                         0100644 0000000 0000000 00000017216 12734733743 017474  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.archive_util

Utility functions for creating archive files (tarballs, zip files,
that sort of thing)."""

__revision__ = "$Id$"

import os
from warnings import warn
import sys

from distutils.errors import DistutilsExecError
from distutils.spawn import spawn
from distutils.dir_util import mkpath
from distutils import log

try:
    from pwd import getpwnam
except ImportError:
    getpwnam = None

try:
    from grp import getgrnam
except ImportError:
    getgrnam = None

def _get_gid(name):
    """Returns a gid, given a group name."""
    if getgrnam is None or name is None:
        return None
    try:
        result = getgrnam(name)
    except KeyError:
        result = None
    if result is not None:
        return result[2]
    return None

def _get_uid(name):
    """Returns an uid, given a user name."""
    if getpwnam is None or name is None:
        return None
    try:
        result = getpwnam(name)
    except KeyError:
        result = None
    if result is not None:
        return result[2]
    return None

def make_tarball(base_name, base_dir, compress="gzip", verbose=0, dry_run=0,
                 owner=None, group=None):
    """Create a (possibly compressed) tar file from all the files under
    'base_dir'.

    'compress' must be "gzip" (the default), "compress", "bzip2", or None.
    (compress will be deprecated in Python 3.2)

    'owner' and 'group' can be used to define an owner and a group for the
    archive that is being built. If not provided, the current owner and group
    will be used.

    The output tar file will be named 'base_dir' +  ".tar", possibly plus
    the appropriate compression extension (".gz", ".bz2" or ".Z").

    Returns the output filename.
    """
    tar_compression = {'gzip': 'gz', 'bzip2': 'bz2', None: '', 'compress': ''}
    compress_ext = {'gzip': '.gz', 'bzip2': '.bz2', 'compress': '.Z'}

    # flags for compression program, each element of list will be an argument
    if compress is not None and compress not in compress_ext.keys():
        raise ValueError, \
              ("bad value for 'compress': must be None, 'gzip', 'bzip2' "
               "or 'compress'")

    archive_name = base_name + '.tar'
    if compress != 'compress':
        archive_name += compress_ext.get(compress, '')

    mkpath(os.path.dirname(archive_name), dry_run=dry_run)

    # creating the tarball
    import tarfile  # late import so Python build itself doesn't break

    log.info('Creating tar archive')

    uid = _get_uid(owner)
    gid = _get_gid(group)

    def _set_uid_gid(tarinfo):
        if gid is not None:
            tarinfo.gid = gid
            tarinfo.gname = group
        if uid is not None:
            tarinfo.uid = uid
            tarinfo.uname = owner
        return tarinfo

    if not dry_run:
        tar = tarfile.open(archive_name, 'w|%s' % tar_compression[compress])
        try:
            tar.add(base_dir, filter=_set_uid_gid)
        finally:
            tar.close()

    # compression using `compress`
    if compress == 'compress':
        warn("'compress' will be deprecated.", PendingDeprecationWarning)
        # the option varies depending on the platform
        compressed_name = archive_name + compress_ext[compress]
        if sys.platform == 'win32':
            cmd = [compress, archive_name, compressed_name]
        else:
            cmd = [compress, '-f', archive_name]
        spawn(cmd, dry_run=dry_run)
        return compressed_name

    return archive_name

def make_zipfile(base_name, base_dir, verbose=0, dry_run=0):
    """Create a zip file from all the files under 'base_dir'.

    The output zip file will be named 'base_name' + ".zip".  Uses either the
    "zipfile" Python module (if available) or the InfoZIP "zip" utility
    (if installed and found on the default search path).  If neither tool is
    available, raises DistutilsExecError.  Returns the name of the output zip
    file.
    """
    try:
        import zipfile
    except ImportError:
        zipfile = None

    zip_filename = base_name + ".zip"
    mkpath(os.path.dirname(zip_filename), dry_run=dry_run)

    # If zipfile module is not available, try spawning an external
    # 'zip' command.
    if zipfile is None:
        if verbose:
            zipoptions = "-r"
        else:
            zipoptions = "-rq"

        try:
            spawn(["zip", zipoptions, zip_filename, base_dir],
                  dry_run=dry_run)
        except DistutilsExecError:
            # XXX really should distinguish between "couldn't find
            # external 'zip' command" and "zip failed".
            raise DistutilsExecError, \
                  ("unable to create zip file '%s': "
                   "could neither import the 'zipfile' module nor "
                   "find a standalone zip utility") % zip_filename

    else:
        log.info("creating '%s' and adding '%s' to it",
                 zip_filename, base_dir)

        if not dry_run:
            zip = zipfile.ZipFile(zip_filename, "w",
                                  compression=zipfile.ZIP_DEFLATED)

            for dirpath, dirnames, filenames in os.walk(base_dir):
                for name in filenames:
                    path = os.path.normpath(os.path.join(dirpath, name))
                    if os.path.isfile(path):
                        zip.write(path, path)
                        log.info("adding '%s'" % path)
            zip.close()

    return zip_filename

ARCHIVE_FORMATS = {
    'gztar': (make_tarball, [('compress', 'gzip')], "gzip'ed tar-file"),
    'bztar': (make_tarball, [('compress', 'bzip2')], "bzip2'ed tar-file"),
    'ztar':  (make_tarball, [('compress', 'compress')], "compressed tar file"),
    'tar':   (make_tarball, [('compress', None)], "uncompressed tar file"),
    'zip':   (make_zipfile, [],"ZIP file")
    }

def check_archive_formats(formats):
    """Returns the first format from the 'format' list that is unknown.

    If all formats are known, returns None
    """
    for format in formats:
        if format not in ARCHIVE_FORMATS:
            return format
    return None

def make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,
                 dry_run=0, owner=None, group=None):
    """Create an archive file (eg. zip or tar).

    'base_name' is the name of the file to create, minus any format-specific
    extension; 'format' is the archive format: one of "zip", "tar", "ztar",
    or "gztar".

    'root_dir' is a directory that will be the root directory of the
    archive; ie. we typically chdir into 'root_dir' before creating the
    archive.  'base_dir' is the directory where we start archiving from;
    ie. 'base_dir' will be the common prefix of all files and
    directories in the archive.  'root_dir' and 'base_dir' both default
    to the current directory.  Returns the name of the archive file.

    'owner' and 'group' are used when creating a tar archive. By default,
    uses the current owner and group.
    """
    save_cwd = os.getcwd()
    if root_dir is not None:
        log.debug("changing into '%s'", root_dir)
        base_name = os.path.abspath(base_name)
        if not dry_run:
            os.chdir(root_dir)

    if base_dir is None:
        base_dir = os.curdir

    kwargs = {'dry_run': dry_run}

    try:
        format_info = ARCHIVE_FORMATS[format]
    except KeyError:
        raise ValueError, "unknown archive format '%s'" % format

    func = format_info[0]
    for arg, val in format_info[1]:
        kwargs[arg] = val

    if format != 'zip':
        kwargs['owner'] = owner
        kwargs['group'] = group

    try:
        filename = func(base_name, base_dir, **kwargs)
    finally:
        if root_dir is not None:
            log.debug("changing back to '%s'", save_cwd)
            os.chdir(save_cwd)

    return filename
                                                                                                                                                                                                                                                                                                                                                                                  usr/lib/python2.7/distutils/archive_util.pyc                                                        0100644 0000000 0000000 00000016420 13077704274 017631  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   sì  d  Z  d Z d d l Z d d l m Z d d l Z d d l m Z d d l m	 Z	 d d l
 m Z d d l m Z y d d	 l m Z Wn e k
 r° d Z n Xy d d
 l m Z Wn e k
 rœ d Z n Xd Ñ  Z d Ñ  Z d d d d d d Ñ Z d d d Ñ Z i e d g d f d 6e d  g d f d 6e d! g d f d 6e d" g d f d 6e g  d f d 6Z d Ñ  Z d d d d d d d Ñ Z d S(#   so   distutils.archive_util

Utility functions for creating archive files (tarballs, zip files,
that sort of thing).s   $Id$iˇˇˇˇN(   t   warn(   t   DistutilsExecError(   t   spawn(   t   mkpath(   t   log(   t   getpwnam(   t   getgrnamc         C   s^   t  d k s |  d k r d Sy t  |  É } Wn t k
 rE d } n X| d k	 rZ | d Sd S(   s"   Returns a gid, given a group name.i   N(   R   t   Nonet   KeyError(   t   namet   result(    (    s,   /usr/lib/python2.7/distutils/archive_util.pyt   _get_gid   s    
c         C   s^   t  d k s |  d k r d Sy t  |  É } Wn t k
 rE d } n X| d k	 rZ | d Sd S(   s"   Returns an uid, given a user name.i   N(   R   R   R   (   R	   R
   (    (    s,   /usr/lib/python2.7/distutils/archive_util.pyt   _get_uid'   s    
t   gzipi    c            s≤  i d d 6d d 6d d 6d d 6} i d d 6d d 6d	 d 6} | d k	 rg | | j É  k rg t d
 Ç n  |  d }	 | d k rñ |	 | j | d É 7}	 n  t t j j |	 É d | Éd d l }
 t	 j
 d É t à É â t à É â  á  á á á f d Ü  } | sC|
 j |	 d | | É } z | j | d | ÉWd | j É  Xn  | d k rÆt d t É |	 | | } t j d k rã| |	 | g } n | d |	 g } t | d | É| S|	 S(   s-  Create a (possibly compressed) tar file from all the files under
    'base_dir'.

    'compress' must be "gzip" (the default), "compress", "bzip2", or None.
    (compress will be deprecated in Python 3.2)

    'owner' and 'group' can be used to define an owner and a group for the
    archive that is being built. If not provided, the current owner and group
    will be used.

    The output tar file will be named 'base_dir' +  ".tar", possibly plus
    the appropriate compression extension (".gz", ".bz2" or ".Z").

    Returns the output filename.
    t   gzR   t   bz2t   bzip2t    t   compresss   .gzs   .bz2s   .ZsE   bad value for 'compress': must be None, 'gzip', 'bzip2' or 'compress's   .tart   dry_runiˇˇˇˇNs   Creating tar archivec            sF   à  d  k	 r! à  |  _ à |  _ n  à d  k	 rB à |  _ à |  _ n  |  S(   N(   R   t   gidt   gnamet   uidt   uname(   t   tarinfo(   R   t   groupt   ownerR   (    s,   /usr/lib/python2.7/distutils/archive_util.pyt   _set_uid_gid[   s    		s   w|%st   filters   'compress' will be deprecated.t   win32s   -f(   R   t   keyst
   ValueErrort   getR   t   ost   patht   dirnamet   tarfileR   t   infoR   R   t   opent   addt   closeR    t   PendingDeprecationWarningt   syst   platformR   (   t	   base_namet   base_dirR   t   verboseR   R   R   t   tar_compressiont   compress_extt   archive_nameR$   R   t   tart   compressed_namet   cmd(    (   R   R   R   R   s,   /usr/lib/python2.7/distutils/archive_util.pyt   make_tarball3   s8    "	
	c         C   sÖ  y d d l  } Wn t k
 r) d } n X|  d } t t j j | É d | É| d k rµ | rk d } n d } y  t d | | | g d | ÉWqÅt k
 r± t d | Ç qÅXnÃ t	 j
 d	 | | É | sÅ| j | d
 d | j É} xà t j | É D]w \ } }	 }
 xe |
 D]] } t j j t j j | | É É } t j j | É r| j | | É t	 j
 d | É qqWq˘ W| j É  n  | S(   sv  Create a zip file from all the files under 'base_dir'.

    The output zip file will be named 'base_name' + ".zip".  Uses either the
    "zipfile" Python module (if available) or the InfoZIP "zip" utility
    (if installed and found on the default search path).  If neither tool is
    available, raises DistutilsExecError.  Returns the name of the output zip
    file.
    iˇˇˇˇNs   .zipR   s   -rs   -rqt   zipsk   unable to create zip file '%s': could neither import the 'zipfile' module nor find a standalone zip utilitys#   creating '%s' and adding '%s' to itt   wt   compressions   adding '%s'(   t   zipfilet   ImportErrorR   R   R!   R"   R#   R   R   R   R%   t   ZipFilet   ZIP_DEFLATEDt   walkt   normpatht   joint   isfilet   writeR(   (   R,   R-   R.   R   R9   t   zip_filenamet
   zipoptionsR6   t   dirpatht   dirnamest	   filenamesR	   R"   (    (    s,   /usr/lib/python2.7/distutils/archive_util.pyt   make_zipfiley   s<    	

		
!R   s   gzip'ed tar-filet   gztarR   s   bzip2'ed tar-filet   bztars   compressed tar filet   ztars   uncompressed tar fileR2   s   ZIP fileR6   c         C   s%   x |  D] } | t  k r | Sq Wd S(   sq   Returns the first format from the 'format' list that is unknown.

    If all formats are known, returns None
    N(   t   ARCHIVE_FORMATSR   (   t   formatst   format(    (    s,   /usr/lib/python2.7/distutils/archive_util.pyt   check_archive_formats∑   s    c         C   sC  t  j É  } | d	 k	 rS t j d | É t  j j |  É }  | sS t  j | É qS n  | d	 k rk t  j } n  i | d 6}	 y t	 | }
 Wn t
 k
 r¶ t d | Ç n X|
 d } x" |
 d D] \ } } | |	 | <qº W| d k r˘ | |	 d <| |	 d <n  z | |  | |	 ç } Wd	 | d	 k	 r>t j d
 | É t  j | É n  X| S(   sÍ  Create an archive file (eg. zip or tar).

    'base_name' is the name of the file to create, minus any format-specific
    extension; 'format' is the archive format: one of "zip", "tar", "ztar",
    or "gztar".

    'root_dir' is a directory that will be the root directory of the
    archive; ie. we typically chdir into 'root_dir' before creating the
    archive.  'base_dir' is the directory where we start archiving from;
    ie. 'base_dir' will be the common prefix of all files and
    directories in the archive.  'root_dir' and 'base_dir' both default
    to the current directory.  Returns the name of the archive file.

    'owner' and 'group' are used when creating a tar archive. By default,
    uses the current owner and group.
    s   changing into '%s'R   s   unknown archive format '%s'i    i   R6   R   R   Ns   changing back to '%s'(   R!   t   getcwdR   R   t   debugR"   t   abspatht   chdirt   curdirRK   R   R   (   R,   RM   t   root_dirR-   R.   R   R   R   t   save_cwdt   kwargst   format_infot   funct   argt   valt   filename(    (    s,   /usr/lib/python2.7/distutils/archive_util.pyt   make_archive¡   s2    

(   s   compresss   gzip(   s   compresss   bzip2(   s   compresss   compress(   s   compressN(   t   __doc__t   __revision__R!   t   warningsR    R*   t   distutils.errorsR   t   distutils.spawnR   t   distutils.dir_utilR   t	   distutilsR   t   pwdR   R:   R   t   grpR   R   R   R5   RG   RK   RN   R\   (    (    (    s,   /usr/lib/python2.7/distutils/archive_util.pyt   <module>   s<   

			E6	
	                                                                                                                                                                                                                                                usr/lib/python2.7/distutils/bcppcompiler.py                                                         0100644 0000000 0000000 00000035135 12734733743 017475  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.bcppcompiler

Contains BorlandCCompiler, an implementation of the abstract CCompiler class
for the Borland C++ compiler.
"""

# This implementation by Lyle Johnson, based on the original msvccompiler.py
# module and using the directions originally published by Gordon Williams.

# XXX looks like there's a LOT of overlap between these two classes:
# someone should sit down and factor out the common code as
# WindowsCCompiler!  --GPW

__revision__ = "$Id$"

import os

from distutils.errors import (DistutilsExecError, CompileError, LibError,
                              LinkError, UnknownFileError)
from distutils.ccompiler import CCompiler, gen_preprocess_options
from distutils.file_util import write_file
from distutils.dep_util import newer
from distutils import log

class BCPPCompiler(CCompiler) :
    """Concrete class that implements an interface to the Borland C/C++
    compiler, as defined by the CCompiler abstract class.
    """

    compiler_type = 'bcpp'

    # Just set this so CCompiler's constructor doesn't barf.  We currently
    # don't use the 'set_executables()' bureaucracy provided by CCompiler,
    # as it really isn't necessary for this sort of single-compiler class.
    # Would be nice to have a consistent interface with UnixCCompiler,
    # though, so it's worth thinking about.
    executables = {}

    # Private class data (need to distinguish C from C++ source for compiler)
    _c_extensions = ['.c']
    _cpp_extensions = ['.cc', '.cpp', '.cxx']

    # Needed for the filename generation methods provided by the
    # base class, CCompiler.
    src_extensions = _c_extensions + _cpp_extensions
    obj_extension = '.obj'
    static_lib_extension = '.lib'
    shared_lib_extension = '.dll'
    static_lib_format = shared_lib_format = '%s%s'
    exe_extension = '.exe'


    def __init__ (self,
                  verbose=0,
                  dry_run=0,
                  force=0):

        CCompiler.__init__ (self, verbose, dry_run, force)

        # These executables are assumed to all be in the path.
        # Borland doesn't seem to use any special registry settings to
        # indicate their installation locations.

        self.cc = "bcc32.exe"
        self.linker = "ilink32.exe"
        self.lib = "tlib.exe"

        self.preprocess_options = None
        self.compile_options = ['/tWM', '/O2', '/q', '/g0']
        self.compile_options_debug = ['/tWM', '/Od', '/q', '/g0']

        self.ldflags_shared = ['/Tpd', '/Gn', '/q', '/x']
        self.ldflags_shared_debug = ['/Tpd', '/Gn', '/q', '/x']
        self.ldflags_static = []
        self.ldflags_exe = ['/Gn', '/q', '/x']
        self.ldflags_exe_debug = ['/Gn', '/q', '/x','/r']


    # -- Worker methods ------------------------------------------------

    def compile(self, sources,
                output_dir=None, macros=None, include_dirs=None, debug=0,
                extra_preargs=None, extra_postargs=None, depends=None):

        macros, objects, extra_postargs, pp_opts, build = \
                self._setup_compile(output_dir, macros, include_dirs, sources,
                                    depends, extra_postargs)
        compile_opts = extra_preargs or []
        compile_opts.append ('-c')
        if debug:
            compile_opts.extend (self.compile_options_debug)
        else:
            compile_opts.extend (self.compile_options)

        for obj in objects:
            try:
                src, ext = build[obj]
            except KeyError:
                continue
            # XXX why do the normpath here?
            src = os.path.normpath(src)
            obj = os.path.normpath(obj)
            # XXX _setup_compile() did a mkpath() too but before the normpath.
            # Is it possible to skip the normpath?
            self.mkpath(os.path.dirname(obj))

            if ext == '.res':
                # This is already a binary file -- skip it.
                continue # the 'for' loop
            if ext == '.rc':
                # This needs to be compiled to a .res file -- do it now.
                try:
                    self.spawn (["brcc32", "-fo", obj, src])
                except DistutilsExecError, msg:
                    raise CompileError, msg
                continue # the 'for' loop

            # The next two are both for the real compiler.
            if ext in self._c_extensions:
                input_opt = ""
            elif ext in self._cpp_extensions:
                input_opt = "-P"
            else:
                # Unknown file type -- no extra options.  The compiler
                # will probably fail, but let it just in case this is a
                # file the compiler recognizes even if we don't.
                input_opt = ""

            output_opt = "-o" + obj

            # Compiler command line syntax is: "bcc32 [options] file(s)".
            # Note that the source file names must appear at the end of
            # the command line.
            try:
                self.spawn ([self.cc] + compile_opts + pp_opts +
                            [input_opt, output_opt] +
                            extra_postargs + [src])
            except DistutilsExecError, msg:
                raise CompileError, msg

        return objects

    # compile ()


    def create_static_lib (self,
                           objects,
                           output_libname,
                           output_dir=None,
                           debug=0,
                           target_lang=None):

        (objects, output_dir) = self._fix_object_args (objects, output_dir)
        output_filename = \
            self.library_filename (output_libname, output_dir=output_dir)

        if self._need_link (objects, output_filename):
            lib_args = [output_filename, '/u'] + objects
            if debug:
                pass                    # XXX what goes here?
            try:
                self.spawn ([self.lib] + lib_args)
            except DistutilsExecError, msg:
                raise LibError, msg
        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    # create_static_lib ()


    def link (self,
              target_desc,
              objects,
              output_filename,
              output_dir=None,
              libraries=None,
              library_dirs=None,
              runtime_library_dirs=None,
              export_symbols=None,
              debug=0,
              extra_preargs=None,
              extra_postargs=None,
              build_temp=None,
              target_lang=None):

        # XXX this ignores 'build_temp'!  should follow the lead of
        # msvccompiler.py

        (objects, output_dir) = self._fix_object_args (objects, output_dir)
        (libraries, library_dirs, runtime_library_dirs) = \
            self._fix_lib_args (libraries, library_dirs, runtime_library_dirs)

        if runtime_library_dirs:
            log.warn("I don't know what to do with 'runtime_library_dirs': %s",
                     str(runtime_library_dirs))

        if output_dir is not None:
            output_filename = os.path.join (output_dir, output_filename)

        if self._need_link (objects, output_filename):

            # Figure out linker args based on type of target.
            if target_desc == CCompiler.EXECUTABLE:
                startup_obj = 'c0w32'
                if debug:
                    ld_args = self.ldflags_exe_debug[:]
                else:
                    ld_args = self.ldflags_exe[:]
            else:
                startup_obj = 'c0d32'
                if debug:
                    ld_args = self.ldflags_shared_debug[:]
                else:
                    ld_args = self.ldflags_shared[:]


            # Create a temporary exports file for use by the linker
            if export_symbols is None:
                def_file = ''
            else:
                head, tail = os.path.split (output_filename)
                modname, ext = os.path.splitext (tail)
                temp_dir = os.path.dirname(objects[0]) # preserve tree structure
                def_file = os.path.join (temp_dir, '%s.def' % modname)
                contents = ['EXPORTS']
                for sym in (export_symbols or []):
                    contents.append('  %s=_%s' % (sym, sym))
                self.execute(write_file, (def_file, contents),
                             "writing %s" % def_file)

            # Borland C++ has problems with '/' in paths
            objects2 = map(os.path.normpath, objects)
            # split objects in .obj and .res files
            # Borland C++ needs them at different positions in the command line
            objects = [startup_obj]
            resources = []
            for file in objects2:
                (base, ext) = os.path.splitext(os.path.normcase(file))
                if ext == '.res':
                    resources.append(file)
                else:
                    objects.append(file)


            for l in library_dirs:
                ld_args.append("/L%s" % os.path.normpath(l))
            ld_args.append("/L.") # we sometimes use relative paths

            # list of object files
            ld_args.extend(objects)

            # XXX the command-line syntax for Borland C++ is a bit wonky;
            # certain filenames are jammed together in one big string, but
            # comma-delimited.  This doesn't mesh too well with the
            # Unix-centric attitude (with a DOS/Windows quoting hack) of
            # 'spawn()', so constructing the argument list is a bit
            # awkward.  Note that doing the obvious thing and jamming all
            # the filenames and commas into one argument would be wrong,
            # because 'spawn()' would quote any filenames with spaces in
            # them.  Arghghh!.  Apparently it works fine as coded...

            # name of dll/exe file
            ld_args.extend([',',output_filename])
            # no map file and start libraries
            ld_args.append(',,')

            for lib in libraries:
                # see if we find it and if there is a bcpp specific lib
                # (xxx_bcpp.lib)
                libfile = self.find_library_file(library_dirs, lib, debug)
                if libfile is None:
                    ld_args.append(lib)
                    # probably a BCPP internal library -- don't warn
                else:
                    # full name which prefers bcpp_xxx.lib over xxx.lib
                    ld_args.append(libfile)

            # some default libraries
            ld_args.append ('import32')
            ld_args.append ('cw32mt')

            # def file for export symbols
            ld_args.extend([',',def_file])
            # add resource files
            ld_args.append(',')
            ld_args.extend(resources)


            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)

            self.mkpath (os.path.dirname (output_filename))
            try:
                self.spawn ([self.linker] + ld_args)
            except DistutilsExecError, msg:
                raise LinkError, msg

        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    # link ()

    # -- Miscellaneous methods -----------------------------------------


    def find_library_file (self, dirs, lib, debug=0):
        # List of effective library names to try, in order of preference:
        # xxx_bcpp.lib is better than xxx.lib
        # and xxx_d.lib is better than xxx.lib if debug is set
        #
        # The "_bcpp" suffix is to handle a Python installation for people
        # with multiple compilers (primarily Distutils hackers, I suspect
        # ;-).  The idea is they'd have one static library for each
        # compiler they care about, since (almost?) every Windows compiler
        # seems to have a different format for static libraries.
        if debug:
            dlib = (lib + "_d")
            try_names = (dlib + "_bcpp", lib + "_bcpp", dlib, lib)
        else:
            try_names = (lib + "_bcpp", lib)

        for dir in dirs:
            for name in try_names:
                libfile = os.path.join(dir, self.library_filename(name))
                if os.path.exists(libfile):
                    return libfile
        else:
            # Oops, didn't find it in *any* of 'dirs'
            return None

    # overwrite the one from CCompiler to support rc and res-files
    def object_filenames (self,
                          source_filenames,
                          strip_dir=0,
                          output_dir=''):
        if output_dir is None: output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            # use normcase to make sure '.rc' is really '.rc' and not '.RC'
            (base, ext) = os.path.splitext (os.path.normcase(src_name))
            if ext not in (self.src_extensions + ['.rc','.res']):
                raise UnknownFileError, \
                      "unknown file type '%s' (from '%s')" % \
                      (ext, src_name)
            if strip_dir:
                base = os.path.basename (base)
            if ext == '.res':
                # these can go unchanged
                obj_names.append (os.path.join (output_dir, base + ext))
            elif ext == '.rc':
                # these need to be compiled to .res-files
                obj_names.append (os.path.join (output_dir, base + '.res'))
            else:
                obj_names.append (os.path.join (output_dir,
                                            base + self.obj_extension))
        return obj_names

    # object_filenames ()

    def preprocess (self,
                    source,
                    output_file=None,
                    macros=None,
                    include_dirs=None,
                    extra_preargs=None,
                    extra_postargs=None):

        (_, macros, include_dirs) = \
            self._fix_compile_args(None, macros, include_dirs)
        pp_opts = gen_preprocess_options(macros, include_dirs)
        pp_args = ['cpp32.exe'] + pp_opts
        if output_file is not None:
            pp_args.append('-o' + output_file)
        if extra_preargs:
            pp_args[:0] = extra_preargs
        if extra_postargs:
            pp_args.extend(extra_postargs)
        pp_args.append(source)

        # We need to preprocess: either we're being forced to, or the
        # source file is newer than the target (or the target doesn't
        # exist).
        if self.force or output_file is None or newer(source, output_file):
            if output_file:
                self.mkpath(os.path.dirname(output_file))
            try:
                self.spawn(pp_args)
            except DistutilsExecError, msg:
                print msg
                raise CompileError, msg

    # preprocess()
                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python2.7/distutils/bcppcompiler.pyc                                                        0100644 0000000 0000000 00000017270 13077704274 017636  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
„∑sWc           @   s†   d  Z  d Z d d l Z d d l m Z m Z m Z m Z m Z d d l	 m
 Z
 m Z d d l m Z d d l m Z d d l m Z d	 e
 f d
 Ñ  É  YZ d S(   sÉ   distutils.bcppcompiler

Contains BorlandCCompiler, an implementation of the abstract CCompiler class
for the Borland C++ compiler.
s   $Id$iˇˇˇˇN(   t   DistutilsExecErrort   CompileErrort   LibErrort	   LinkErrort   UnknownFileError(   t	   CCompilert   gen_preprocess_options(   t
   write_file(   t   newer(   t   logt   BCPPCompilerc           B   s˙   e  Z d  Z d Z i  Z d g Z d d d g Z e e Z d Z d Z	 d Z
 d	 Z Z d
 Z d d d d Ñ Z d d d d d d d d Ñ Z d d d d Ñ Z d d d d d d d d d d d Ñ
 Z d d Ñ Z d d d Ñ Z d d d d d d Ñ Z RS(   s   Concrete class that implements an interface to the Borland C/C++
    compiler, as defined by the CCompiler abstract class.
    t   bcpps   .cs   .ccs   .cpps   .cxxs   .objs   .libs   .dlls   %s%ss   .exei    c         C   s¬   t  j |  | | | É d |  _ d |  _ d |  _ d  |  _ d d d d g |  _ d d d d g |  _ d	 d
 d d g |  _	 d	 d
 d d g |  _
 g  |  _ d
 d d g |  _ d
 d d d g |  _ d  S(   Ns	   bcc32.exes   ilink32.exes   tlib.exes   /tWMs   /O2s   /qs   /g0s   /Ods   /Tpds   /Gns   /xs   /r(   R   t   __init__t   cct   linkert   libt   Nonet   preprocess_optionst   compile_optionst   compile_options_debugt   ldflags_sharedt   ldflags_shared_debugt   ldflags_statict   ldflags_exet   ldflags_exe_debug(   t   selft   verboset   dry_runt   force(    (    s,   /usr/lib/python2.7/distutils/bcppcompiler.pyR   5   s    					c	         C   sﬂ  |  j  | | | | | | É \ } }	 } }
 } | p6 g  } | j d É | r_ | j |  j É n | j |  j É xi|	 D]a} y | | \ } } Wn t k
 r¶ qv n Xt j j | É } t j j | É } |  j	 t j j
 | É É | d k rˆ qv n  | d k rDy |  j d d | | g É Wqv t k
 r=} t | Ç qv Xqv n  | |  j k r\d } n | |  j k rtd } n d } d | } y4 |  j |  j g | |
 | | g | | g É Wqv t k
 r÷} t | Ç qv Xqv W|	 S(	   Ns   -cs   .ress   .rct   brcc32s   -fot    s   -Ps   -o(   t   _setup_compilet   appendt   extendR   R   t   KeyErrort   ost   patht   normpatht   mkpatht   dirnamet   spawnR    R   t   _c_extensionst   _cpp_extensionsR   (   R   t   sourcest
   output_dirt   macrost   include_dirst   debugt   extra_preargst   extra_postargst   dependst   objectst   pp_optst   buildt   compile_optst   objt   srct   extt   msgt	   input_optt
   output_opt(    (    s,   /usr/lib/python2.7/distutils/bcppcompiler.pyt   compileQ   sF    		
.c   	      C   s©   |  j  | | É \ } } |  j | d | É} |  j | | É rï | d g | } | rX n  y |  j |  j g | É Wq• t k
 rë } t | Ç q• Xn t j d | É d  S(   NR,   s   /us   skipping %s (up-to-date)(	   t   _fix_object_argst   library_filenamet
   _need_linkR(   R   R    R   R	   R/   (	   R   R3   t   output_libnameR,   R/   t   target_langt   output_filenamet   lib_argsR:   (    (    s,   /usr/lib/python2.7/distutils/bcppcompiler.pyt   create_static_libí   s    c          C   sæ  |  j  | | É \ } } |  j | | | É \ } } } | rU t j d t | É É n  | d  k	 ry t j j | | É } n  |  j	 | | É r™| t
 j k r¿ d } |	 r≥ |  j } q„ |  j } n# d } |	 rŸ |  j } n
 |  j } | d  k r¯ d } n≥ t j j | É \ } } t j j | É \ } } t j j | d É } t j j | d | É } d g } x+ | plg  D] } | j d | | f É qmW|  j t | | f d	 | É t t j j | É } | g } g  } x[ | D]S } t j j t j j | É É \ } } | d
 k r| j | É q÷| j | É q÷Wx+ | D]# } | j d t j j | É É q4W| j d É | j | É | j d | g É | j d É xL | D]D } |  j | | |	 É } | d  k r”| j | É qú| j | É qúW| j d É | j d É | j d | g É | j d É | j | É |
 r>|
 | d *n  | rT| j | É n  |  j t j j | É É y |  j |  j g | É Wq∫t k
 r¶} t | Ç q∫Xn t j  d | É d  S(   Ns7   I don't know what to do with 'runtime_library_dirs': %st   c0w32t   c0d32R   i    s   %s.deft   EXPORTSs     %s=_%ss
   writing %ss   .ress   /L%ss   /L.t   ,s   ,,t   import32t   cw32mts   skipping %s (up-to-date)(!   R>   t   _fix_lib_argsR	   t   warnt   strR   R#   R$   t   joinR@   R   t
   EXECUTABLER   R   R   R   t   splitt   splitextR'   R    t   executeR   t   mapR%   t   normcaseR!   t   find_library_fileR&   R(   R   R    R   R/   (    R   t   target_descR3   RC   R,   t	   librariest   library_dirst   runtime_library_dirst   export_symbolsR/   R0   R1   t
   build_tempRB   t   startup_objt   ld_argst   def_filet   headt   tailt   modnameR9   t   temp_dirt   contentst   symt   objects2t	   resourcest   filet   baset   lR   t   libfileR:   (    (    s,   /usr/lib/python2.7/distutils/bcppcompiler.pyt   link´   s|    	
			$!c   	      C   sõ   | r- | d } | d | d | | f } n | d | f } xW | D]K } xB | D]: } t  j j | |  j | É É } t  j j | É rQ | SqQ WqD Wd  Sd  S(   Nt   _dt   _bcpp(   R#   R$   RO   R?   t   existsR   (	   R   t   dirsR   R/   t   dlibt	   try_namest   dirt   nameRk   (    (    s,   /usr/lib/python2.7/distutils/bcppcompiler.pyRV   4  s    

R   c         C   s  | d  k r d } n  g  } x˝ | D]ı } t j j t j j | É É \ } } | |  j d d g k r{ t d | | f Ç n  | rñ t j j | É } n  | d k r≈ | j t j j	 | | | É É q" | d k rÙ | j t j j	 | | d É É q" | j t j j	 | | |  j
 É É q" W| S(   NR   s   .rcs   .ress"   unknown file type '%s' (from '%s')(   R   R#   R$   RR   RU   t   src_extensionsR   t   basenameR    RO   t   obj_extension(   R   t   source_filenamest	   strip_dirR,   t	   obj_namest   src_nameRi   R9   (    (    s,   /usr/lib/python2.7/distutils/bcppcompiler.pyt   object_filenamesN  s$     	$##c         C   s  |  j  d  | | É \ } } } t | | É } d g | }	 | d  k	 rZ |	 j d | É n  | rm | |	 d *n  | rÉ |	 j | É n  |	 j | É |  j s¥ | d  k s¥ t | | É r| r÷ |  j t j	 j
 | É É n  y |  j |	 É Wqt k
 r
}
 |
 GHt |
 Ç qXn  d  S(   Ns	   cpp32.exes   -oi    (   t   _fix_compile_argsR   R   R    R!   R   R   R&   R#   R$   R'   R(   R    R   (   R   t   sourcet   output_fileR-   R.   R0   R1   t   _R4   t   pp_argsR:   (    (    s,   /usr/lib/python2.7/distutils/bcppcompiler.pyt
   preprocessj  s$    	$N(   t   __name__t
   __module__t   __doc__t   compiler_typet   executablesR)   R*   Ru   Rw   t   static_lib_extensiont   shared_lib_extensiont   static_lib_formatt   shared_lib_formatt   exe_extensionR   R   R=   RE   Rl   RV   R|   RÇ   (    (    (    s,   /usr/lib/python2.7/distutils/bcppcompiler.pyR
      sJ   	

B|(   RÖ   t   __revision__R#   t   distutils.errorsR    R   R   R   R   t   distutils.ccompilerR   R   t   distutils.file_utilR   t   distutils.dep_utilR   t	   distutilsR	   R
   (    (    (    s,   /usr/lib/python2.7/distutils/bcppcompiler.pyt   <module>   s   	(                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/distutils/ccompiler.py                                                            0100644 0000000 0000000 00000133051 12734733743 016767  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.ccompiler

Contains CCompiler, an abstract base class that defines the interface
for the Distutils compiler abstraction model."""

__revision__ = "$Id$"

import sys
import os
import re

from distutils.errors import (CompileError, LinkError, UnknownFileError,
                              DistutilsPlatformError, DistutilsModuleError)
from distutils.spawn import spawn
from distutils.file_util import move_file
from distutils.dir_util import mkpath
from distutils.dep_util import newer_group
from distutils.util import split_quoted, execute
from distutils import log
# following import is for backward compatibility
from distutils.sysconfig import customize_compiler

class CCompiler:
    """Abstract base class to define the interface that must be implemented
    by real compiler classes.  Also has some utility methods used by
    several compiler classes.

    The basic idea behind a compiler abstraction class is that each
    instance can be used for all the compile/link steps in building a
    single project.  Thus, attributes common to all of those compile and
    link steps -- include directories, macros to define, libraries to link
    against, etc. -- are attributes of the compiler instance.  To allow for
    variability in how individual files are treated, most of those
    attributes may be varied on a per-compilation or per-link basis.
    """

    # 'compiler_type' is a class attribute that identifies this class.  It
    # keeps code that wants to know what kind of compiler it's dealing with
    # from having to import all possible compiler classes just to do an
    # 'isinstance'.  In concrete CCompiler subclasses, 'compiler_type'
    # should really, really be one of the keys of the 'compiler_class'
    # dictionary (see below -- used by the 'new_compiler()' factory
    # function) -- authors of new compiler interface classes are
    # responsible for updating 'compiler_class'!
    compiler_type = None

    # XXX things not handled by this compiler abstraction model:
    #   * client can't provide additional options for a compiler,
    #     e.g. warning, optimization, debugging flags.  Perhaps this
    #     should be the domain of concrete compiler abstraction classes
    #     (UnixCCompiler, MSVCCompiler, etc.) -- or perhaps the base
    #     class should have methods for the common ones.
    #   * can't completely override the include or library searchg
    #     path, ie. no "cc -I -Idir1 -Idir2" or "cc -L -Ldir1 -Ldir2".
    #     I'm not sure how widely supported this is even by Unix
    #     compilers, much less on other platforms.  And I'm even less
    #     sure how useful it is; maybe for cross-compiling, but
    #     support for that is a ways off.  (And anyways, cross
    #     compilers probably have a dedicated binary with the
    #     right paths compiled in.  I hope.)
    #   * can't do really freaky things with the library list/library
    #     dirs, e.g. "-Ldir1 -lfoo -Ldir2 -lfoo" to link against
    #     different versions of libfoo.a in different locations.  I
    #     think this is useless without the ability to null out the
    #     library search path anyways.


    # Subclasses that rely on the standard filename generation methods
    # implemented below should override these; see the comment near
    # those methods ('object_filenames()' et. al.) for details:
    src_extensions = None               # list of strings
    obj_extension = None                # string
    static_lib_extension = None
    shared_lib_extension = None         # string
    static_lib_format = None            # format string
    shared_lib_format = None            # prob. same as static_lib_format
    exe_extension = None                # string

    # Default language settings. language_map is used to detect a source
    # file or Extension target language, checking source filenames.
    # language_order is used to detect the language precedence, when deciding
    # what language to use when mixing source types. For example, if some
    # extension has two files with ".c" extension, and one with ".cpp", it
    # is still linked as c++.
    language_map = {".c"   : "c",
                    ".cc"  : "c++",
                    ".cpp" : "c++",
                    ".cxx" : "c++",
                    ".m"   : "objc",
                   }
    language_order = ["c++", "objc", "c"]

    def __init__ (self, verbose=0, dry_run=0, force=0):
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose

        # 'output_dir': a common output directory for object, library,
        # shared object, and shared library files
        self.output_dir = None

        # 'macros': a list of macro definitions (or undefinitions).  A
        # macro definition is a 2-tuple (name, value), where the value is
        # either a string or None (no explicit value).  A macro
        # undefinition is a 1-tuple (name,).
        self.macros = []

        # 'include_dirs': a list of directories to search for include files
        self.include_dirs = []

        # 'libraries': a list of libraries to include in any link
        # (library names, not filenames: eg. "foo" not "libfoo.a")
        self.libraries = []

        # 'library_dirs': a list of directories to search for libraries
        self.library_dirs = []

        # 'runtime_library_dirs': a list of directories to search for
        # shared libraries/objects at runtime
        self.runtime_library_dirs = []

        # 'objects': a list of object files (or similar, such as explicitly
        # named library files) to include on any link
        self.objects = []

        for key in self.executables.keys():
            self.set_executable(key, self.executables[key])

    def set_executables(self, **args):
        """Define the executables (and options for them) that will be run
        to perform the various stages of compilation.  The exact set of
        executables that may be specified here depends on the compiler
        class (via the 'executables' class attribute), but most will have:
          compiler      the C/C++ compiler
          linker_so     linker used to create shared objects and libraries
          linker_exe    linker used to create binary executables
          archiver      static library creator

        On platforms with a command-line (Unix, DOS/Windows), each of these
        is a string that will be split into executable name and (optional)
        list of arguments.  (Splitting the string is done similarly to how
        Unix shells operate: words are delimited by spaces, but quotes and
        backslashes can override this.  See
        'distutils.util.split_quoted()'.)
        """

        # Note that some CCompiler implementation classes will define class
        # attributes 'cpp', 'cc', etc. with hard-coded executable names;
        # this is appropriate when a compiler class is for exactly one
        # compiler/OS combination (eg. MSVCCompiler).  Other compiler
        # classes (UnixCCompiler, in particular) are driven by information
        # discovered at run-time, since there are many different ways to do
        # basically the same things with Unix C compilers.

        for key in args.keys():
            if key not in self.executables:
                raise ValueError, \
                      "unknown executable '%s' for class %s" % \
                      (key, self.__class__.__name__)
            self.set_executable(key, args[key])

    def set_executable(self, key, value):
        if isinstance(value, str):
            setattr(self, key, split_quoted(value))
        else:
            setattr(self, key, value)

    def _find_macro(self, name):
        i = 0
        for defn in self.macros:
            if defn[0] == name:
                return i
            i = i + 1
        return None

    def _check_macro_definitions(self, definitions):
        """Ensures that every element of 'definitions' is a valid macro
        definition, ie. either (name,value) 2-tuple or a (name,) tuple.  Do
        nothing if all definitions are OK, raise TypeError otherwise.
        """
        for defn in definitions:
            if not (isinstance(defn, tuple) and
                    (len (defn) == 1 or
                     (len (defn) == 2 and
                      (isinstance(defn[1], str) or defn[1] is None))) and
                    isinstance(defn[0], str)):
                raise TypeError, \
                      ("invalid macro definition '%s': " % defn) + \
                      "must be tuple (string,), (string, string), or " + \
                      "(string, None)"


    # -- Bookkeeping methods -------------------------------------------

    def define_macro(self, name, value=None):
        """Define a preprocessor macro for all compilations driven by this
        compiler object.  The optional parameter 'value' should be a
        string; if it is not supplied, then the macro will be defined
        without an explicit value and the exact outcome depends on the
        compiler used (XXX true? does ANSI say anything about this?)
        """
        # Delete from the list of macro definitions/undefinitions if
        # already there (so that this one will take precedence).
        i = self._find_macro (name)
        if i is not None:
            del self.macros[i]

        defn = (name, value)
        self.macros.append (defn)

    def undefine_macro(self, name):
        """Undefine a preprocessor macro for all compilations driven by
        this compiler object.  If the same macro is defined by
        'define_macro()' and undefined by 'undefine_macro()' the last call
        takes precedence (including multiple redefinitions or
        undefinitions).  If the macro is redefined/undefined on a
        per-compilation basis (ie. in the call to 'compile()'), then that
        takes precedence.
        """
        # Delete from the list of macro definitions/undefinitions if
        # already there (so that this one will take precedence).
        i = self._find_macro (name)
        if i is not None:
            del self.macros[i]

        undefn = (name,)
        self.macros.append (undefn)

    def add_include_dir(self, dir):
        """Add 'dir' to the list of directories that will be searched for
        header files.  The compiler is instructed to search directories in
        the order in which they are supplied by successive calls to
        'add_include_dir()'.
        """
        self.include_dirs.append (dir)

    def set_include_dirs(self, dirs):
        """Set the list of directories that will be searched to 'dirs' (a
        list of strings).  Overrides any preceding calls to
        'add_include_dir()'; subsequence calls 