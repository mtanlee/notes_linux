
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech 3"
.TH Mail::SPF::Mech 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech \- SPF record mechanism base class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech\fR represents a mechanism within an \s-1SPF\s0
record.  Mail::SPF::Mech cannot be instantiated directly.  Create an instance
of a concrete sub-class instead.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
A \fIstring\fR denoting the unparsed text of the mechanism.
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
A single-character \fIstring\fR denoting the qualifier of the mechanism.  Any of
the following may be specified: \fB'+'\fR (\f(CW\*(C`Pass\*(C'\fR), \fB'\-'\fR (\f(CW\*(C`Fail\*(C'\fR),
\&\fB'~'\fR (\f(CW\*(C`SoftFail\*(C'\fR), \fB'?'\fR (\f(CW\*(C`Neutral\*(C'\fR).  See \s-1RFC 4408, 4.6.2\s0 and 2.5, for
their meanings.  Defaults to \fB'+'\fR.
.IP "\fBname\fR" 4
.IX Item "name"
A \fIstring\fR denoting the name of the mechanism.  \fIRequired\fR if a generic
\&\fIMail::SPF::Mech\fR object (as opposed to a specific sub-class) is being
constructed.
.IP "\fBip_network\fR" 4
.IX Item "ip_network"
A \fINetAddr::IP\fR object denoting an optional \s-1IP\s0 address network parameter of
the mechanism.  Can be either an IPv4 or an IPv6 address, with an optional
network prefix length.  IPv4\-mapped IPv6 addresses (e.g. '::ffff:192.168.0.1')
must \fInot\fR be specified directly, but as plain IPv4 addresses.
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
Either a plain \fIstring\fR or a \fIMail::SPF::MacroString\fR object denoting an
optional \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.IP "\fBipv4_prefix_length\fR" 4
.IX Item "ipv4_prefix_length"
.PD 0
.IP "\fBipv6_prefix_length\fR" 4
.IX Item "ipv6_prefix_length"
.PD
A \fIstring\fR denoting an optional IPv4 or IPv6 network prefix length for the
\&\f(CW\*(C`domain_spec\*(C'\fR of the mechanism.  Note that these options do not apply to the
\&\f(CW\*(C`ip_network\*(C'\fR option, which already includes an optional network prefix
length.
.RE
.RS 4
.Sp
Other options may be specified by sub-classes of Mail::SPF::Mech.
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR: returns \fIstring\fR" 4
.IX Item "default_qualifier: returns string"
Returns the default qualifier, i.e. \fB'+'\fR.
.IP "\fBdefault_ipv4_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "default_ipv4_prefix_length: returns integer"
Returns the default IPv4 network prefix length, i.e. \fB32\fR.
.IP "\fBdefault_ipv6_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "default_ipv6_prefix_length: returns integer"
Returns the default IPv6 network prefix length, i.e. \fB128\fR.
.IP "\fBqualifier_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "qualifier_pattern: returns Regexp"
Returns a regular expression that matches any legal mechanism qualifier, i.e. \fB'+'\fR,
\&\fB'\-'\fR, \fB'~'\fR, or \fB'?'\fR.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
\&\fIAbstract\fR.  Returns the name of the mechanism.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Mech.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches any legal mechanism name.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the mechanism.  Throws a
\&\fIMail::SPF::ENoUnparsedText\fR exception if the mechanism was created
synthetically instead of being parsed, and no text was provided.
.IP "\fBqualifier\fR: returns \fIstring\fR" 4
.IX Item "qualifier: returns string"
Returns the qualifier of the mechanism.  See the description of the \f(CW\*(C`new\*(C'\fR
constructor's \f(CW\*(C`qualifier\*(C'\fR option.
.IP "\fBparams\fR: returns \fIstring\fR" 4
.IX Item "params: returns string"
\&\fIAbstract\fR.  Returns the mechanism's parameters formatted as a string.
.Sp
A sub-class of Mail::SPF::Mech does not have to implement this method if it
supports no parameters.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Formats the mechanism's qualifier, name, and parameters as a string and returns
it.  (A qualifier that matches the default of \fB'+'\fR is omitted.)  You can
simply use a Mail::SPF::Mech object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\*(R"\s0.
.ie n .IP "\fBdomain($server, \fB$request\fB)\fR: returns \fIstring\fR" 4
.el .IP "\fBdomain($server, \f(CB$request\fB)\fR: returns \fIstring\fR" 4
.IX Item "domain($server, $request): returns string"
Returns the target domain of the mechanism.  Depending on whether the mechanism
does have an explicit \f(CW\*(C`domain_spec\*(C'\fR parameter, this is either the
macro-expanded \f(CW\*(C`domain_spec\*(C'\fR parameter, or the request's authority domain
(see \*(L"authority_domain\*(R" in Mail::SPF::Request) otherwise.  Both a
\&\fIMail::SPF::Server\fR and a \fIMail::SPF::Request\fR object are required for
resolving the target domain.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.IX Item "match($server, $request): returns boolean; throws Mail::SPF::Result::Error"
\&\fIAbstract\fR.  Checks whether the mechanism matches the parameters of the given
request (see Mail::SPF::Request) and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  In any case, takes both a \fIMail::SPF::Server\fR and a
\&\fIMail::SPF::Request\fR object.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Mech.
.ie n .IP "\fBmatch_in_domain($server, \fB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.el .IP "\fBmatch_in_domain($server, \f(CB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.IX Item "match_in_domain($server, $request): returns boolean; throws Mail::SPF::Result::Error"
.PD 0
.ie n .IP "\fBmatch_in_domain($server, \fB$request\fB, \f(BI$domain\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.el .IP "\fBmatch_in_domain($server, \f(CB$request\fB, \f(CB$domain\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.IX Item "match_in_domain($server, $request, $domain): returns boolean; throws Mail::SPF::Result::Error"
.PD
Checks whether the mechanism's target domain name (that is, any of its \s-1DNS \s0\f(CW\*(C`A\*(C'\fR
or \f(CW\*(C`AAAA\*(C'\fR records) matches the given request's \s-1IP\s0 address (see
\&\*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  If an explicit domain is specified, it is used instead of the
mechanism's target domain.  The mechanism's \s-1IP\s0 network prefix lengths are
respected when matching \s-1DNS\s0 address records against the request's \s-1IP\s0 address.
See \s-1RFC 4408, 5,\s0 for the exact algorithm used.
.Sp
This method exists mainly for the convenience of sub-classes of
Mail::SPF::Mech.
.ie n .IP "\fBexplain($server, \fB$request\fB, \f(BI$result\fB)\fR" 4
.el .IP "\fBexplain($server, \f(CB$request\fB, \f(CB$result\fB)\fR" 4
.IX Item "explain($server, $request, $result)"
Locally generates an explanation for why the mechanism caused the given result,
and stores it in the given request object's state.
.Sp
There is no need to override this method in sub-classes.  See the
\&\*(L"explanation_template\*(R" method.
.ie n .IP "\fBexplanation_template($server, \fB$request\fB, \f(BI$result\fB)\fR: returns \fIstring\fR" 4
.el .IP "\fBexplanation_template($server, \f(CB$request\fB, \f(CB$result\fB)\fR: returns \fIstring\fR" 4
.IX Item "explanation_template($server, $request, $result): returns string"
Returns a macro string template for a locally generated explanation for why the
mechanism caused the given result object.
.Sp
Sub-classes should either define an \f(CW\*(C`explanation_templates_by_result_code\*(C'\fR
hash constant with their own templates, or override this method.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Mech object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR method is
used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF::Mech::All,
Mail::SPF::Mech::IP4,
Mail::SPF::Mech::IP6,
Mail::SPF::Mech::A,
Mail::SPF::Mech::MX,
Mail::SPF::Mech::PTR,
Mail::SPF::Mech::Exists,
Mail::SPF::Mech::Include
.PP
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::A.3pm                       0100644 0001750 0001750 00000017710 12566242050 024166  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::A 3"
.TH Mail::SPF::Mech::A 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::A \- SPF record "a" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::A\fR represents an \s-1SPF\s0 record mechanism of
type \f(CW\*(C`a\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::A\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::A"
Creates a new \s-1SPF\s0 record \f(CW\*(C`a\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.IP "\fBipv4_prefix_length\fR" 4
.IX Item "ipv4_prefix_length"
.IP "\fBipv6_prefix_length\fR" 4
.IX Item "ipv6_prefix_length"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::A\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::A\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::A; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`a\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv4_prefix_length\fR" 4
.IX Item "default_ipv4_prefix_length"
.IP "\fBdefault_ipv6_prefix_length\fR" 4
.IX Item "default_ipv6_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'a'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'a'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBdomain\fR" 4
.IX Item "domain"
.IP "\fBmatch_in_domain\fR" 4
.IX Item "match_in_domain"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.IP "\fBipv4_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv4_prefix_length: returns integer"
Returns the IPv4 network prefix length of the mechanism.
.IP "\fBipv6_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv6_prefix_length: returns integer"
Returns the IPv6 network prefix length of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether the mechanism's target domain name (that is, any of its \s-1DNS \s0\f(CW\*(C`A\*(C'\fR
or \f(CW\*(C`AAAA\*(C'\fR host addresses) matches the given request's \s-1IP\s0 address (see
\&\*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  The mechanism's \s-1IP\s0 network prefix lengths are respected when
matching address records against the request's \s-1IP\s0 address.  See \s-1RFC 4408, 5,\s0
for the exact algorithm used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::A5.16.3pm                   0100644 0001750 0001750 00000017367 12566242062 024513  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::A 3"
.TH Mail::SPF::Mech::A 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::A \- SPF record "a" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::A\fR represents an \s-1SPF\s0 record mechanism of
type \f(CW\*(C`a\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::A\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::A"
Creates a new \s-1SPF\s0 record \f(CW\*(C`a\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.IP "\fBipv4_prefix_length\fR" 4
.IX Item "ipv4_prefix_length"
.IP "\fBipv6_prefix_length\fR" 4
.IX Item "ipv6_prefix_length"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::A\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::A\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::A; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`a\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv4_prefix_length\fR" 4
.IX Item "default_ipv4_prefix_length"
.IP "\fBdefault_ipv6_prefix_length\fR" 4
.IX Item "default_ipv6_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'a'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'a'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBdomain\fR" 4
.IX Item "domain"
.IP "\fBmatch_in_domain\fR" 4
.IX Item "match_in_domain"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.IP "\fBipv4_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv4_prefix_length: returns integer"
Returns the IPv4 network prefix length of the mechanism.
.IP "\fBipv6_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv6_prefix_length: returns integer"
Returns the IPv6 network prefix length of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether the mechanism's target domain name (that is, any of its \s-1DNS\s0 \f(CW\*(C`A\*(C'\fR
or \f(CW\*(C`AAAA\*(C'\fR host addresses) matches the given request's \s-1IP\s0 address (see
\&\*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  The mechanism's \s-1IP\s0 network prefix lengths are respected when
matching address records against the request's \s-1IP\s0 address.  See \s-1RFC\s0 4408, 5,
for the exact algorithm used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::A5.18.3pm                   0100644 0001750 0001750 00000017710 12566242050 024502  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::A 3"
.TH Mail::SPF::Mech::A 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::A \- SPF record "a" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::A\fR represents an \s-1SPF\s0 record mechanism of
type \f(CW\*(C`a\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::A\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::A"
Creates a new \s-1SPF\s0 record \f(CW\*(C`a\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.IP "\fBipv4_prefix_length\fR" 4
.IX Item "ipv4_prefix_length"
.IP "\fBipv6_prefix_length\fR" 4
.IX Item "ipv6_prefix_length"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::A\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::A\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::A; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`a\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv4_prefix_length\fR" 4
.IX Item "default_ipv4_prefix_length"
.IP "\fBdefault_ipv6_prefix_length\fR" 4
.IX Item "default_ipv6_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'a'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'a'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBdomain\fR" 4
.IX Item "domain"
.IP "\fBmatch_in_domain\fR" 4
.IX Item "match_in_domain"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.IP "\fBipv4_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv4_prefix_length: returns integer"
Returns the IPv4 network prefix length of the mechanism.
.IP "\fBipv6_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv6_prefix_length: returns integer"
Returns the IPv6 network prefix length of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether the mechanism's target domain name (that is, any of its \s-1DNS \s0\f(CW\*(C`A\*(C'\fR
or \f(CW\*(C`AAAA\*(C'\fR host addresses) matches the given request's \s-1IP\s0 address (see
\&\*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  The mechanism's \s-1IP\s0 network prefix lengths are respected when
matching address records against the request's \s-1IP\s0 address.  See \s-1RFC 4408, 5,\s0
for the exact algorithm used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::All.3pm                     0100644 0001750 0001750 00000015243 12566242051 024516  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::All 3"
.TH Mail::SPF::Mech::All 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::All \- SPF record "all" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::All\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`all\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew\fR: returns \fIMail::SPF::Mech::All\fR" 4
.IX Item "new: returns Mail::SPF::Mech::All"
Creates a new \s-1SPF\s0 record \f(CW\*(C`all\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::All\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::All\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::All; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`all\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'all'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'all'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBname\fR" 4
.IX Item "name"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Returns \fBtrue\fR because the \f(CW\*(C`all\*(C'\fR mechanism always matches.  See \s-1RFC 4408,
5.1,\s0 for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::All5.16.3pm                 0100644 0001750 0001750 00000014722 12566242063 025034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::All 3"
.TH Mail::SPF::Mech::All 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::All \- SPF record "all" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::All\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`all\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew\fR: returns \fIMail::SPF::Mech::All\fR" 4
.IX Item "new: returns Mail::SPF::Mech::All"
Creates a new \s-1SPF\s0 record \f(CW\*(C`all\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::All\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::All\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::All; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`all\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'all'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'all'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBname\fR" 4
.IX Item "name"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Returns \fBtrue\fR because the \f(CW\*(C`all\*(C'\fR mechanism always matches.  See \s-1RFC\s0 4408,
5.1, for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::All5.18.3pm                 0100644 0001750 0001750 00000015243 12566242051 025032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::All 3"
.TH Mail::SPF::Mech::All 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::All \- SPF record "all" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::All\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`all\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew\fR: returns \fIMail::SPF::Mech::All\fR" 4
.IX Item "new: returns Mail::SPF::Mech::All"
Creates a new \s-1SPF\s0 record \f(CW\*(C`all\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::All\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::All\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::All; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`all\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'all'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'all'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBname\fR" 4
.IX Item "name"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Returns \fBtrue\fR because the \f(CW\*(C`all\*(C'\fR mechanism always matches.  See \s-1RFC 4408,
5.1,\s0 for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::Exists.3pm                  0100644 0001750 0001750 00000016066 12566242050 025270  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::Exists 3"
.TH Mail::SPF::Mech::Exists 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::Exists \- SPF record "exists" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::Exists\fR represents an \s-1SPF\s0 record
mechanism of type \f(CW\*(C`exists\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::Exists\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::Exists"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exists\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::Exists\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::Exists\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::Exists; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exists\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'exists'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'exists'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether a \s-1DNS \s0\f(CW\*(C`A\*(C'\fR record exists for the mechanism's target domain name,
and returns \fBtrue\fR if one does, or \fBfalse\fR otherwise.  See \s-1RFC 4408, 5.7,\s0 for
details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::Exists5.16.3pm              0100644 0001750 0001750 00000015545 12566242063 025607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::Exists 3"
.TH Mail::SPF::Mech::Exists 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::Exists \- SPF record "exists" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::Exists\fR represents an \s-1SPF\s0 record
mechanism of type \f(CW\*(C`exists\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::Exists\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::Exists"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exists\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::Exists\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::Exists\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::Exists; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exists\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'exists'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'exists'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether a \s-1DNS\s0 \f(CW\*(C`A\*(C'\fR record exists for the mechanism's target domain name,
and returns \fBtrue\fR if one does, or \fBfalse\fR otherwise.  See \s-1RFC\s0 4408, 5.7, for
details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::Exists5.18.3pm              0100644 0001750 0001750 00000016066 12566242050 025604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::Exists 3"
.TH Mail::SPF::Mech::Exists 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::Exists \- SPF record "exists" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::Exists\fR represents an \s-1SPF\s0 record
mechanism of type \f(CW\*(C`exists\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::Exists\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::Exists"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exists\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::Exists\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::Exists\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::Exists; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exists\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'exists'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'exists'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether a \s-1DNS \s0\f(CW\*(C`A\*(C'\fR record exists for the mechanism's target domain name,
and returns \fBtrue\fR if one does, or \fBfalse\fR otherwise.  See \s-1RFC 4408, 5.7,\s0 for
details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::IP4.3pm                     0100644 0001750 0001750 00000016147 12566242051 024406  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::IP4 3"
.TH Mail::SPF::Mech::IP4 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::IP4 \- SPF record "ip4" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::IP4\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`ip4\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::IP4\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::IP4"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip4\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBip_network\fR" 4
.IX Item "ip_network"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::IP4\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::IP4\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::IP4; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip4\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv4_prefix_length\fR" 4
.IX Item "default_ipv4_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'ip4'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'ip4'\fR.
.PP
See Mail::SPF::Mech for other supported class methods.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBip_network\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_network: returns NetAddr::IP"
Returns the \s-1IP\s0 address network parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Returns \fBtrue\fR if the mechanism's \f(CW\*(C`ip_network\*(C'\fR equals or contains the given
request's \s-1IP\s0 address, or \fBfalse\fR otherwise.  See \s-1RFC 4408, 5.6,\s0 for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::IP45.16.3pm                 0100644 0001750 0001750 00000015626 12566242062 024723  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::IP4 3"
.TH Mail::SPF::Mech::IP4 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::IP4 \- SPF record "ip4" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::IP4\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`ip4\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::IP4\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::IP4"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip4\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBip_network\fR" 4
.IX Item "ip_network"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::IP4\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::IP4\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::IP4; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip4\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv4_prefix_length\fR" 4
.IX Item "default_ipv4_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'ip4'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'ip4'\fR.
.PP
See Mail::SPF::Mech for other supported class methods.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBip_network\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_network: returns NetAddr::IP"
Returns the \s-1IP\s0 address network parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Returns \fBtrue\fR if the mechanism's \f(CW\*(C`ip_network\*(C'\fR equals or contains the given
request's \s-1IP\s0 address, or \fBfalse\fR otherwise.  See \s-1RFC\s0 4408, 5.6, for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::IP45.18.3pm                 0100644 0001750 0001750 00000016147 12566242051 024722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::IP4 3"
.TH Mail::SPF::Mech::IP4 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::IP4 \- SPF record "ip4" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::IP4\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`ip4\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::IP4\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::IP4"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip4\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBip_network\fR" 4
.IX Item "ip_network"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::IP4\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::IP4\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::IP4; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip4\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv4_prefix_length\fR" 4
.IX Item "default_ipv4_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'ip4'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'ip4'\fR.
.PP
See Mail::SPF::Mech for other supported class methods.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBip_network\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_network: returns NetAddr::IP"
Returns the \s-1IP\s0 address network parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Returns \fBtrue\fR if the mechanism's \f(CW\*(C`ip_network\*(C'\fR equals or contains the given
request's \s-1IP\s0 address, or \fBfalse\fR otherwise.  See \s-1RFC 4408, 5.6,\s0 for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::IP6.3pm                     0100644 0001750 0001750 00000016054 12566242051 024405  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::IP6 3"
.TH Mail::SPF::Mech::IP6 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::IP6 \- SPF record "ip6" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::IP6\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`ip6\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::IP6\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::IP6"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip6\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBip_network\fR" 4
.IX Item "ip_network"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::IP6\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::IP6\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::IP6; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip6\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv6_prefix_length\fR" 4
.IX Item "default_ipv6_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'ip6'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'ip6'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBip_network\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_network: returns NetAddr::IP"
Returns the \s-1IP\s0 address network parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Returns \fBtrue\fR if the mechanism's \f(CW\*(C`ip_network\*(C'\fR equals or contains the given
request's \s-1IP\s0 address, or \fBfalse\fR otherwise.  See \s-1RFC 4408, 5.6,\s0 for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::IP65.16.3pm                 0100644 0001750 0001750 00000015533 12566242063 024723  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::IP6 3"
.TH Mail::SPF::Mech::IP6 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::IP6 \- SPF record "ip6" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::IP6\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`ip6\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::IP6\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::IP6"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip6\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBip_network\fR" 4
.IX Item "ip_network"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::IP6\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::IP6\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::IP6; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip6\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv6_prefix_length\fR" 4
.IX Item "default_ipv6_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'ip6'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'ip6'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBip_network\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_network: returns NetAddr::IP"
Returns the \s-1IP\s0 address network parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Returns \fBtrue\fR if the mechanism's \f(CW\*(C`ip_network\*(C'\fR equals or contains the given
request's \s-1IP\s0 address, or \fBfalse\fR otherwise.  See \s-1RFC\s0 4408, 5.6, for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::IP65.18.3pm                 0100644 0001750 0001750 00000016054 12566242051 024721  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::IP6 3"
.TH Mail::SPF::Mech::IP6 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::IP6 \- SPF record "ip6" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::IP6\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`ip6\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::IP6\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::IP6"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip6\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBip_network\fR" 4
.IX Item "ip_network"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::IP6\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::IP6\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::IP6; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ip6\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv6_prefix_length\fR" 4
.IX Item "default_ipv6_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'ip6'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'ip6'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBip_network\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_network: returns NetAddr::IP"
Returns the \s-1IP\s0 address network parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Returns \fBtrue\fR if the mechanism's \f(CW\*(C`ip_network\*(C'\fR equals or contains the given
request's \s-1IP\s0 address, or \fBfalse\fR otherwise.  See \s-1RFC 4408, 5.6,\s0 for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::Include.3pm                 0100644 0001750 0001750 00000017107 12566242051 025372  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::Include 3"
.TH Mail::SPF::Mech::Include 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::Include \- SPF record "include" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::Include\fR represents an \s-1SPF\s0 record
mechanism of type \f(CW\*(C`include\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::Include\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::Include"
Creates a new \s-1SPF\s0 record \f(CW\*(C`include\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::Include\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::Include\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::Include; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`include\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'include'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'include'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Performs a recursive \s-1SPF\s0 check using the given \s-1SPF\s0 server and request objects
and substituting the mechanism's target domain name for the request's authority
domain.  The result of the recursive \s-1SPF\s0 check is translated as follows:
.Sp
.Vb 9
\&     Recursive result | Effect
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     pass             | return true
\&     fail             | return false
\&     softfail         | return false
\&     neutral          | return false
\&     none             | throw PermError
\&     permerror        | throw PermError
\&     temperror        | throw TempError
.Ve
.Sp
See \s-1RFC 4408, 5.2,\s0 for the exact algorithm used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::Include5.16.3pm             0100644 0001750 0001750 00000016566 12566242063 025717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::Include 3"
.TH Mail::SPF::Mech::Include 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::Include \- SPF record "include" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::Include\fR represents an \s-1SPF\s0 record
mechanism of type \f(CW\*(C`include\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::Include\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::Include"
Creates a new \s-1SPF\s0 record \f(CW\*(C`include\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::Include\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::Include\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::Include; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`include\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'include'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'include'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Performs a recursive \s-1SPF\s0 check using the given \s-1SPF\s0 server and request objects
and substituting the mechanism's target domain name for the request's authority
domain.  The result of the recursive \s-1SPF\s0 check is translated as follows:
.Sp
.Vb 9
\&     Recursive result | Effect
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     pass             | return true
\&     fail             | return false
\&     softfail         | return false
\&     neutral          | return false
\&     none             | throw PermError
\&     permerror        | throw PermError
\&     temperror        | throw TempError
.Ve
.Sp
See \s-1RFC\s0 4408, 5.2, for the exact algorithm used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::Include5.18.3pm             0100644 0001750 0001750 00000017107 12566242051 025706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::Include 3"
.TH Mail::SPF::Mech::Include 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::Include \- SPF record "include" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::Include\fR represents an \s-1SPF\s0 record
mechanism of type \f(CW\*(C`include\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::Include\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::Include"
Creates a new \s-1SPF\s0 record \f(CW\*(C`include\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::Include\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::Include\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::Include; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`include\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'include'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'include'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Performs a recursive \s-1SPF\s0 check using the given \s-1SPF\s0 server and request objects
and substituting the mechanism's target domain name for the request's authority
domain.  The result of the recursive \s-1SPF\s0 check is translated as follows:
.Sp
.Vb 9
\&     Recursive result | Effect
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     pass             | return true
\&     fail             | return false
\&     softfail         | return false
\&     neutral          | return false
\&     none             | throw PermError
\&     permerror        | throw PermError
\&     temperror        | throw TempError
.Ve
.Sp
See \s-1RFC 4408, 5.2,\s0 for the exact algorithm used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::MX.3pm                      0100644 0001750 0001750 00000017752 12566242051 024341  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::MX 3"
.TH Mail::SPF::Mech::MX 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::MX \- SPF record "mx" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::MX\fR represents an \s-1SPF\s0 record mechanism of
type \f(CW\*(C`mx\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::MX\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::MX"
Creates a new \s-1SPF\s0 record \f(CW\*(C`mx\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.IP "\fBipv4_prefix_length\fR" 4
.IX Item "ipv4_prefix_length"
.IP "\fBipv6_prefix_length\fR" 4
.IX Item "ipv6_prefix_length"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::MX\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::MX\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::MX; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`mx\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv4_prefix_length\fR" 4
.IX Item "default_ipv4_prefix_length"
.IP "\fBdefault_ipv6_prefix_length\fR" 4
.IX Item "default_ipv6_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'mx'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'mx'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBdomain\fR" 4
.IX Item "domain"
.IP "\fBmatch_in_domain\fR" 4
.IX Item "match_in_domain"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.IP "\fBipv4_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv4_prefix_length: returns integer"
Returns the IPv4 network prefix length of the mechanism.
.IP "\fBipv6_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv6_prefix_length: returns integer"
Returns the IPv6 network prefix length of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether any \s-1MX\s0 hosts of the mechanism's target domain name (that is, any
of the host addresses of its \s-1DNS \s0\f(CW\*(C`MX\*(C'\fR records) matches the given request's \s-1IP\s0
address (see \*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does,
or \fBfalse\fR otherwise.  The mechanism's \s-1IP\s0 network prefix lengths are respected
when matching address records against the request's \s-1IP\s0 address.  See \s-1RFC 4408,
5\s0 and 5.4, for the exact algorithm used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::MX5.16.3pm                  0100644 0001750 0001750 00000017431 12566242063 024650  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::MX 3"
.TH Mail::SPF::Mech::MX 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::MX \- SPF record "mx" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::MX\fR represents an \s-1SPF\s0 record mechanism of
type \f(CW\*(C`mx\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::MX\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::MX"
Creates a new \s-1SPF\s0 record \f(CW\*(C`mx\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.IP "\fBipv4_prefix_length\fR" 4
.IX Item "ipv4_prefix_length"
.IP "\fBipv6_prefix_length\fR" 4
.IX Item "ipv6_prefix_length"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::MX\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::MX\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::MX; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`mx\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv4_prefix_length\fR" 4
.IX Item "default_ipv4_prefix_length"
.IP "\fBdefault_ipv6_prefix_length\fR" 4
.IX Item "default_ipv6_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'mx'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'mx'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBdomain\fR" 4
.IX Item "domain"
.IP "\fBmatch_in_domain\fR" 4
.IX Item "match_in_domain"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.IP "\fBipv4_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv4_prefix_length: returns integer"
Returns the IPv4 network prefix length of the mechanism.
.IP "\fBipv6_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv6_prefix_length: returns integer"
Returns the IPv6 network prefix length of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether any \s-1MX\s0 hosts of the mechanism's target domain name (that is, any
of the host addresses of its \s-1DNS\s0 \f(CW\*(C`MX\*(C'\fR records) matches the given request's \s-1IP\s0
address (see \*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does,
or \fBfalse\fR otherwise.  The mechanism's \s-1IP\s0 network prefix lengths are respected
when matching address records against the request's \s-1IP\s0 address.  See \s-1RFC\s0 4408,
5 and 5.4, for the exact algorithm used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::MX5.18.3pm                  0100644 0001750 0001750 00000017752 12566242051 024655  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::MX 3"
.TH Mail::SPF::Mech::MX 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::MX \- SPF record "mx" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::MX\fR represents an \s-1SPF\s0 record mechanism of
type \f(CW\*(C`mx\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::MX\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::MX"
Creates a new \s-1SPF\s0 record \f(CW\*(C`mx\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.IP "\fBipv4_prefix_length\fR" 4
.IX Item "ipv4_prefix_length"
.IP "\fBipv6_prefix_length\fR" 4
.IX Item "ipv6_prefix_length"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::MX\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::MX\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::MX; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`mx\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBdefault_ipv4_prefix_length\fR" 4
.IX Item "default_ipv4_prefix_length"
.IP "\fBdefault_ipv6_prefix_length\fR" 4
.IX Item "default_ipv6_prefix_length"
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'mx'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'mx'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBdomain\fR" 4
.IX Item "domain"
.IP "\fBmatch_in_domain\fR" 4
.IX Item "match_in_domain"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.IP "\fBipv4_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv4_prefix_length: returns integer"
Returns the IPv4 network prefix length of the mechanism.
.IP "\fBipv6_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "ipv6_prefix_length: returns integer"
Returns the IPv6 network prefix length of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether any \s-1MX\s0 hosts of the mechanism's target domain name (that is, any
of the host addresses of its \s-1DNS \s0\f(CW\*(C`MX\*(C'\fR records) matches the given request's \s-1IP\s0
address (see \*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does,
or \fBfalse\fR otherwise.  The mechanism's \s-1IP\s0 network prefix lengths are respected
when matching address records against the request's \s-1IP\s0 address.  See \s-1RFC 4408,
5\s0 and 5.4, for the exact algorithm used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::PTR.3pm                     0100644 0001750 0001750 00000016355 12566242051 024460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::PTR 3"
.TH Mail::SPF::Mech::PTR 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::PTR \- SPF record "ptr" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::PTR\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`ptr\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::PTR\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::PTR"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ptr\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::PTR\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::PTR\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::PTR; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ptr\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'ptr'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'ptr'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether the mechanism's target domain name, or a sub-domain thereof, is
a \*(L"valid\*(R" domain name for the given request's \s-1IP\s0 address (see
\&\*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  See \*(L"valid_domain_for_ip_address\*(R" in Mail::SPF::Util for how domains
are validated.  See \s-1RFC 4408, 5.5,\s0 for the description of an equivalent
algorithm.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::PTR5.16.3pm                 0100644 0001750 0001750 00000016034 12566242062 024766  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::PTR 3"
.TH Mail::SPF::Mech::PTR 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::PTR \- SPF record "ptr" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::PTR\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`ptr\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::PTR\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::PTR"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ptr\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::PTR\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::PTR\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::PTR; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ptr\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'ptr'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'ptr'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether the mechanism's target domain name, or a sub-domain thereof, is
a \*(L"valid\*(R" domain name for the given request's \s-1IP\s0 address (see
\&\*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  See \*(L"valid_domain_for_ip_address\*(R" in Mail::SPF::Util for how domains
are validated.  See \s-1RFC\s0 4408, 5.5, for the description of an equivalent
algorithm.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech::PTR5.18.3pm                 0100644 0001750 0001750 00000016355 12566242051 024774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech::PTR 3"
.TH Mail::SPF::Mech::PTR 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech::PTR \- SPF record "ptr" mechanism class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech::PTR\fR represents an \s-1SPF\s0 record mechanism
of type \f(CW\*(C`ptr\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech::PTR\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech::PTR"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ptr\*(C'\fR mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.PD 0
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
.PD
See \*(L"new\*(R" in Mail::SPF::Mech.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech::PTR\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech::PTR\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech::PTR; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
Creates a new \s-1SPF\s0 record \f(CW\*(C`ptr\*(C'\fR mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBqualifier_pattern\fR" 4
.IX Item "qualifier_pattern"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'ptr'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a mechanism name of \fB'ptr'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
.IP "\fBparams\fR" 4
.IX Item "params"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR" 4
.IX Item "match($server, $request): returns boolean"
Checks whether the mechanism's target domain name, or a sub-domain thereof, is
a \*(L"valid\*(R" domain name for the given request's \s-1IP\s0 address (see
\&\*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  See \*(L"valid_domain_for_ip_address\*(R" in Mail::SPF::Util for how domains
are validated.  See \s-1RFC 4408, 5.5,\s0 for the description of an equivalent
algorithm.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mod.3pm                           0100644 0001750 0001750 00000031334 12566242050 023542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mod 3"
.TH Mail::SPF::Mod 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mod \- SPF record modifier base class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mod\fR represents a modifier within an \s-1SPF\s0
record.  Mail::SPF::Mod cannot be instantiated directly.  Create an instance of
a concrete sub-class instead.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mod\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mod"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record modifier object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
A \fIstring\fR denoting the unparsed text of the modifier.
.IP "\fBname\fR" 4
.IX Item "name"
A \fIstring\fR denoting the name of the modifier.  \fIRequired\fR if a generic
\&\fIMail::SPF::Mod\fR object (as opposed to a specific sub-class) is being
constructed.
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
Either a plain \fIstring\fR or a \fIMail::SPF::MacroString\fR object denoting an
optional \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mod\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mod\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mod; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMod"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record modifier object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches any legal modifier name.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the modifier.  Throws a
\&\fIMail::SPF::ENoUnparsedText\fR exception if the modifier was created
synthetically instead of being parsed, and no text was provided.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns the name of the modifier.
.IP "\fBparams\fR: returns \fIstring\fR" 4
.IX Item "params: returns string"
\&\fIAbstract\fR.  Returns the modifier's parameters formatted as a string.
.Sp
A sub-class of Mail::SPF::Mod does not have to implement this method if it
supports no parameters, although this is highly unlikely.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Formats the modifier's name and parameters as a string and returns it.  You can
simply use a Mail::SPF::Mod object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\*(R"\s0.
.IP "\fBprocess\fR: throws \fIMail::SPF::Result\fR, \fIMail::SPF::Result::Error\fR, \fIMail::SPF::Exception\fR" 4
.IX Item "process: throws Mail::SPF::Result, Mail::SPF::Result::Error, Mail::SPF::Exception"
\&\fIAbstract\fR.  Processes the modifier.  What that means depends on the actual
implementation in sub-classes.  See \*(L"\s-1MODIFIER TYPES\*(R"\s0 below.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Mod.
.SH "MODIFIER TYPES"
.IX Header "MODIFIER TYPES"
There are different basic types of modifiers, which are described below.  All
of them are provided by the \fBMail::SPF::Mod\fR module.
.SS "Global modifiers \- \fBMail::SPF::GlobalMod\fP"
.IX Subsection "Global modifiers - Mail::SPF::GlobalMod"
\&\fBSPFv1\fR (\s-1RFC 4408\s0) only knows \*(L"global\*(R" modifiers.  A global modifier may
appear anywhere in an \s-1SPF\s0 record, but only once.  During evaluation of the
record, global modifiers are processed after the last mechanism has been
evaluated and an \s-1SPF\s0 result has been determined.
.PP
The following additional class method is provided by \fBMail::SPF::GlobalMod\fR:
.IP "\fBprecedence\fR: returns \fIreal\fR" 4
.IX Item "precedence: returns real"
\&\fIAbstract\fR.  Returns a \fIreal\fR number between \fB0\fR and \fB1\fR denoting the
precedence of the type of the global modifier.  Global modifiers present in an
\&\s-1SPF\s0 record are processed in the order of their precedence values, \fB0\fR meaning
\&\*(L"first\*(R".
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::GlobalMod.
.PP
The following specific instance method is provided by \fBMail::SPF::GlobalMod\fR:
.ie n .IP "\fBprocess($server, \fB$request\fB, \f(BI$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB, \f(CB$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "process($server, $request, $result): throws Mail::SPF::Result"
\&\fIAbstract\fR.  Processes the modifier.  What that means depends on the actual
implementation in sub-classes.  Takes both a \fIMail::SPF::Server\fR and a
\&\fIMail::SPF::Request\fR object.  As global modifiers are generally processed
\&\fIafter\fR an \s-1SPF\s0 result has already been determined, takes also the current
\&\fIMail::SPF::Result\fR.  If the modifier wishes to modify the \s-1SPF\s0 result, it may
throw a different \fIMail::SPF::Result\fR object.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::GlobalMod.
.SS "Positional modifiers \- \fBMail::SPF::PositionalMod\fP"
.IX Subsection "Positional modifiers - Mail::SPF::PositionalMod"
\&\fBSender \s-1ID\s0\fR (\s-1RFC 4406\s0) introduces the concept of \*(L"positional\*(R" modifiers.
According to \s-1RFC 4406,\s0 a positional modifier must follow a mechanism and
applies to that, and only that, mechanism.  However, because this definition is
not very useful, and because no positional modifiers have been defined based on
it as of yet, \fBMail::SPF\fR deviates from \s-1RFC 4406\s0 as follows:
.PP
A positional modifier may appear anywhere in an \s-1SPF\s0 record, and it is stateful,
i.e. it applies to all mechanisms and modifiers that follow it.  Positional
modifiers are generally multiple, i.e. they may appear any number of times
throughout the record.  During evaluation of the record, positional modifiers
are processed at exactly the time when they are encountered by the evaluator.
Consequently, all positional modifiers are processed before an \s-1SPF\s0 result is
determined.
.PP
The following specific instance method is provided by
\&\fBMail::SPF::PositionalMod\fR:
.ie n .IP "\fBprocess($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result::Error\fR, \fIMail::SPF::Exception\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result::Error\fR, \fIMail::SPF::Exception\fR" 4
.IX Item "process($server, $request): throws Mail::SPF::Result::Error, Mail::SPF::Exception"
\&\fIAbstract\fR.  Processes the modifier.  What that means depends on the actual
implementation in sub-classes.  Takes both a \fIMail::SPF::Server\fR and a
\&\fIMail::SPF::Request\fR object.  As global modifiers are generally processed
\&\fIbefore\fR an \s-1SPF\s0 result has been determined, no result object is available to
the modifier.  The modifier can (at least at this time) not directly modify the
final \s-1SPF\s0 result, however it may throw an exception to signal an error
condition.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::PositionalMod.
.SS "Unknown modifiers \- \fBMail::SPF::UnknownMod\fP"
.IX Subsection "Unknown modifiers - Mail::SPF::UnknownMod"
Both \fBSPFv1\fR and \fBSender \s-1ID\s0\fR allow unknown modifiers to appear in \s-1SPF\s0 records
in order to allow new modifiers to be introduced without breaking existing
implementations.  Obviously, unknown modifiers are neither global nor
positional, but they may appear any number of times throughout the record and
are simply ignored during evaluation of the record.
.PP
Also obviously, \fBMail::SPF::UnknownMod\fR does not support a \f(CW\*(C`process\*(C'\fR method.
.PP
The following specific instance method is provided by
\&\fBMail::SPF::UnknownMod\fR:
.IP "\fBparams\fR: returns \fIstring\fR" 4
.IX Item "params: returns string"
Returns the modifier's unparsed value as a string.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Mod object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR method is
used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF::Mod::Redirect, Mail::SPF::Mod::Exp
.PP
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mod5.16.3pm                       0100644 0001750 0001750 00000031022 12566242063 024052  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mod 3"
.TH Mail::SPF::Mod 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mod \- SPF record modifier base class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mod\fR represents a modifier within an \s-1SPF\s0
record.  Mail::SPF::Mod cannot be instantiated directly.  Create an instance of
a concrete sub-class instead.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mod\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mod"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record modifier object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
A \fIstring\fR denoting the unparsed text of the modifier.
.IP "\fBname\fR" 4
.IX Item "name"
A \fIstring\fR denoting the name of the modifier.  \fIRequired\fR if a generic
\&\fIMail::SPF::Mod\fR object (as opposed to a specific sub-class) is being
constructed.
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
Either a plain \fIstring\fR or a \fIMail::SPF::MacroString\fR object denoting an
optional \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mod\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mod\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mod; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMod"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record modifier object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches any legal modifier name.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the modifier.  Throws a
\&\fIMail::SPF::ENoUnparsedText\fR exception if the modifier was created
synthetically instead of being parsed, and no text was provided.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns the name of the modifier.
.IP "\fBparams\fR: returns \fIstring\fR" 4
.IX Item "params: returns string"
\&\fIAbstract\fR.  Returns the modifier's parameters formatted as a string.
.Sp
A sub-class of Mail::SPF::Mod does not have to implement this method if it
supports no parameters, although this is highly unlikely.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Formats the modifier's name and parameters as a string and returns it.  You can
simply use a Mail::SPF::Mod object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\s0\*(R".
.IP "\fBprocess\fR: throws \fIMail::SPF::Result\fR, \fIMail::SPF::Result::Error\fR, \fIMail::SPF::Exception\fR" 4
.IX Item "process: throws Mail::SPF::Result, Mail::SPF::Result::Error, Mail::SPF::Exception"
\&\fIAbstract\fR.  Processes the modifier.  What that means depends on the actual
implementation in sub-classes.  See \*(L"\s-1MODIFIER\s0 \s-1TYPES\s0\*(R" below.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Mod.
.SH "MODIFIER TYPES"
.IX Header "MODIFIER TYPES"
There are different basic types of modifiers, which are described below.  All
of them are provided by the \fBMail::SPF::Mod\fR module.
.SS "Global modifiers \- \fBMail::SPF::GlobalMod\fP"
.IX Subsection "Global modifiers - Mail::SPF::GlobalMod"
\&\fBSPFv1\fR (\s-1RFC\s0 4408) only knows \*(L"global\*(R" modifiers.  A global modifier may
appear anywhere in an \s-1SPF\s0 record, but only once.  During evaluation of the
record, global modifiers are processed after the last mechanism has been
evaluated and an \s-1SPF\s0 result has been determined.
.PP
The following additional class method is provided by \fBMail::SPF::GlobalMod\fR:
.IP "\fBprecedence\fR: returns \fIreal\fR" 4
.IX Item "precedence: returns real"
\&\fIAbstract\fR.  Returns a \fIreal\fR number between \fB0\fR and \fB1\fR denoting the
precedence of the type of the global modifier.  Global modifiers present in an
\&\s-1SPF\s0 record are processed in the order of their precedence values, \fB0\fR meaning
\&\*(L"first\*(R".
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::GlobalMod.
.PP
The following specific instance method is provided by \fBMail::SPF::GlobalMod\fR:
.ie n .IP "\fBprocess($server, \fB$request\fB, \f(BI$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB, \f(CB$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "process($server, $request, $result): throws Mail::SPF::Result"
\&\fIAbstract\fR.  Processes the modifier.  What that means depends on the actual
implementation in sub-classes.  Takes both a \fIMail::SPF::Server\fR and a
\&\fIMail::SPF::Request\fR object.  As global modifiers are generally processed
\&\fIafter\fR an \s-1SPF\s0 result has already been determined, takes also the current
\&\fIMail::SPF::Result\fR.  If the modifier wishes to modify the \s-1SPF\s0 result, it may
throw a different \fIMail::SPF::Result\fR object.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::GlobalMod.
.SS "Positional modifiers \- \fBMail::SPF::PositionalMod\fP"
.IX Subsection "Positional modifiers - Mail::SPF::PositionalMod"
\&\fBSender \s-1ID\s0\fR (\s-1RFC\s0 4406) introduces the concept of \*(L"positional\*(R" modifiers.
According to \s-1RFC\s0 4406, a positional modifier must follow a mechanism and
applies to that, and only that, mechanism.  However, because this definition is
not very useful, and because no positional modifiers have been defined based on
it as of yet, \fBMail::SPF\fR deviates from \s-1RFC\s0 4406 as follows:
.PP
A positional modifier may appear anywhere in an \s-1SPF\s0 record, and it is stateful,
i.e. it applies to all mechanisms and modifiers that follow it.  Positional
modifiers are generally multiple, i.e. they may appear any number of times
throughout the record.  During evaluation of the record, positional modifiers
are processed at exactly the time when they are encountered by the evaluator.
Consequently, all positional modifiers are processed before an \s-1SPF\s0 result is
determined.
.PP
The following specific instance method is provided by
\&\fBMail::SPF::PositionalMod\fR:
.ie n .IP "\fBprocess($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result::Error\fR, \fIMail::SPF::Exception\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result::Error\fR, \fIMail::SPF::Exception\fR" 4
.IX Item "process($server, $request): throws Mail::SPF::Result::Error, Mail::SPF::Exception"
\&\fIAbstract\fR.  Processes the modifier.  What that means depends on the actual
implementation in sub-classes.  Takes both a \fIMail::SPF::Server\fR and a
\&\fIMail::SPF::Request\fR object.  As global modifiers are generally processed
\&\fIbefore\fR an \s-1SPF\s0 result has been determined, no result object is available to
the modifier.  The modifier can (at least at this time) not directly modify the
final \s-1SPF\s0 result, however it may throw an exception to signal an error
condition.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::PositionalMod.
.SS "Unknown modifiers \- \fBMail::SPF::UnknownMod\fP"
.IX Subsection "Unknown modifiers - Mail::SPF::UnknownMod"
Both \fBSPFv1\fR and \fBSender \s-1ID\s0\fR allow unknown modifiers to appear in \s-1SPF\s0 records
in order to allow new modifiers to be introduced without breaking existing
implementations.  Obviously, unknown modifiers are neither global nor
positional, but they may appear any number of times throughout the record and
are simply ignored during evaluation of the record.
.PP
Also obviously, \fBMail::SPF::UnknownMod\fR does not support a \f(CW\*(C`process\*(C'\fR method.
.PP
The following specific instance method is provided by
\&\fBMail::SPF::UnknownMod\fR:
.IP "\fBparams\fR: returns \fIstring\fR" 4
.IX Item "params: returns string"
Returns the modifier's unparsed value as a string.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Mod object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR method is
used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF::Mod::Redirect, Mail::SPF::Mod::Exp
.PP
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mod5.18.3pm                       0100644 0001750 0001750 00000031334 12566242050 024056  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mod 3"
.TH Mail::SPF::Mod 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mod \- SPF record modifier base class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mod\fR represents a modifier within an \s-1SPF\s0
record.  Mail::SPF::Mod cannot be instantiated directly.  Create an instance of
a concrete sub-class instead.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mod\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mod"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record modifier object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
A \fIstring\fR denoting the unparsed text of the modifier.
.IP "\fBname\fR" 4
.IX Item "name"
A \fIstring\fR denoting the name of the modifier.  \fIRequired\fR if a generic
\&\fIMail::SPF::Mod\fR object (as opposed to a specific sub-class) is being
constructed.
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
Either a plain \fIstring\fR or a \fIMail::SPF::MacroString\fR object denoting an
optional \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mod\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mod\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mod; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMod"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record modifier object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches any legal modifier name.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the modifier.  Throws a
\&\fIMail::SPF::ENoUnparsedText\fR exception if the modifier was created
synthetically instead of being parsed, and no text was provided.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns the name of the modifier.
.IP "\fBparams\fR: returns \fIstring\fR" 4
.IX Item "params: returns string"
\&\fIAbstract\fR.  Returns the modifier's parameters formatted as a string.
.Sp
A sub-class of Mail::SPF::Mod does not have to implement this method if it
supports no parameters, although this is highly unlikely.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Formats the modifier's name and parameters as a string and returns it.  You can
simply use a Mail::SPF::Mod object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\*(R"\s0.
.IP "\fBprocess\fR: throws \fIMail::SPF::Result\fR, \fIMail::SPF::Result::Error\fR, \fIMail::SPF::Exception\fR" 4
.IX Item "process: throws Mail::SPF::Result, Mail::SPF::Result::Error, Mail::SPF::Exception"
\&\fIAbstract\fR.  Processes the modifier.  What that means depends on the actual
implementation in sub-classes.  See \*(L"\s-1MODIFIER TYPES\*(R"\s0 below.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Mod.
.SH "MODIFIER TYPES"
.IX Header "MODIFIER TYPES"
There are different basic types of modifiers, which are described below.  All
of them are provided by the \fBMail::SPF::Mod\fR module.
.SS "Global modifiers \- \fBMail::SPF::GlobalMod\fP"
.IX Subsection "Global modifiers - Mail::SPF::GlobalMod"
\&\fBSPFv1\fR (\s-1RFC 4408\s0) only knows \*(L"global\*(R" modifiers.  A global modifier may
appear anywhere in an \s-1SPF\s0 record, but only once.  During evaluation of the
record, global modifiers are processed after the last mechanism has been
evaluated and an \s-1SPF\s0 result has been determined.
.PP
The following additional class method is provided by \fBMail::SPF::GlobalMod\fR:
.IP "\fBprecedence\fR: returns \fIreal\fR" 4
.IX Item "precedence: returns real"
\&\fIAbstract\fR.  Returns a \fIreal\fR number between \fB0\fR and \fB1\fR denoting the
precedence of the type of the global modifier.  Global modifiers present in an
\&\s-1SPF\s0 record are processed in the order of their precedence values, \fB0\fR meaning
\&\*(L"first\*(R".
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::GlobalMod.
.PP
The following specific instance method is provided by \fBMail::SPF::GlobalMod\fR:
.ie n .IP "\fBprocess($server, \fB$request\fB, \f(BI$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB, \f(CB$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "process($server, $request, $result): throws Mail::SPF::Result"
\&\fIAbstract\fR.  Processes the modifier.  What that means depends on the actual
implementation in sub-classes.  Takes both a \fIMail::SPF::Server\fR and a
\&\fIMail::SPF::Request\fR object.  As global modifiers are generally processed
\&\fIafter\fR an \s-1SPF\s0 result has already been determined, takes also the current
\&\fIMail::SPF::Result\fR.  If the modifier wishes to modify the \s-1SPF\s0 result, it may
throw a different \fIMail::SPF::Result\fR object.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::GlobalMod.
.SS "Positional modifiers \- \fBMail::SPF::PositionalMod\fP"
.IX Subsection "Positional modifiers - Mail::SPF::PositionalMod"
\&\fBSender \s-1ID\s0\fR (\s-1RFC 4406\s0) introduces the concept of \*(L"positional\*(R" modifiers.
According to \s-1RFC 4406,\s0 a positional modifier must follow a mechanism and
applies to that, and only that, mechanism.  However, because this definition is
not very useful, and because no positional modifiers have been defined based on
it as of yet, \fBMail::SPF\fR deviates from \s-1RFC 4406\s0 as follows:
.PP
A positional modifier may appear anywhere in an \s-1SPF\s0 record, and it is stateful,
i.e. it applies to all mechanisms and modifiers that follow it.  Positional
modifiers are generally multiple, i.e. they may appear any number of times
throughout the record.  During evaluation of the record, positional modifiers
are processed at exactly the time when they are encountered by the evaluator.
Consequently, all positional modifiers are processed before an \s-1SPF\s0 result is
determined.
.PP
The following specific instance method is provided by
\&\fBMail::SPF::PositionalMod\fR:
.ie n .IP "\fBprocess($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result::Error\fR, \fIMail::SPF::Exception\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result::Error\fR, \fIMail::SPF::Exception\fR" 4
.IX Item "process($server, $request): throws Mail::SPF::Result::Error, Mail::SPF::Exception"
\&\fIAbstract\fR.  Processes the modifier.  What that means depends on the actual
implementation in sub-classes.  Takes both a \fIMail::SPF::Server\fR and a
\&\fIMail::SPF::Request\fR object.  As global modifiers are generally processed
\&\fIbefore\fR an \s-1SPF\s0 result has been determined, no result object is available to
the modifier.  The modifier can (at least at this time) not directly modify the
final \s-1SPF\s0 result, however it may throw an exception to signal an error
condition.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::PositionalMod.
.SS "Unknown modifiers \- \fBMail::SPF::UnknownMod\fP"
.IX Subsection "Unknown modifiers - Mail::SPF::UnknownMod"
Both \fBSPFv1\fR and \fBSender \s-1ID\s0\fR allow unknown modifiers to appear in \s-1SPF\s0 records
in order to allow new modifiers to be introduced without breaking existing
implementations.  Obviously, unknown modifiers are neither global nor
positional, but they may appear any number of times throughout the record and
are simply ignored during evaluation of the record.
.PP
Also obviously, \fBMail::SPF::UnknownMod\fR does not support a \f(CW\*(C`process\*(C'\fR method.
.PP
The following specific instance method is provided by
\&\fBMail::SPF::UnknownMod\fR:
.IP "\fBparams\fR: returns \fIstring\fR" 4
.IX Item "params: returns string"
Returns the modifier's unparsed value as a string.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Mod object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR method is
used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF::Mod::Redirect, Mail::SPF::Mod::Exp
.PP
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mod::Exp.3pm                      0100644 0001750 0001750 00000015743 12566242050 024411  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mod::Exp 3"
.TH Mail::SPF::Mod::Exp 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mod::Exp \- SPF record "exp" modifier class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mod::Exp\fR represents an \s-1SPF\s0 record modifier of
type \f(CW\*(C`exp\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mod::Exp\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mod::Exp"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exp\*(C'\fR modifier object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
See \*(L"new\*(R" in Mail::SPF::Mod.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mod::Exp\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mod::Exp\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mod::Exp; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMod"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exp\*(C'\fR modifier object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'exp'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a modifier name of \fB'exp'\fR.
.IP "\fBprecedence\fR: returns \fIreal\fR" 4
.IX Item "precedence: returns real"
Returns a precedence value of \fB0.2\fR.  See \*(L"precedence\*(R" in Mail::SPF::Mod.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBparams\fR" 4
.IX Item "params"
See \*(L"params\*(R" in Mail::SPF::Mod.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the modifier.
.ie n .IP "\fBprocess($server, \fB$request\fB, \f(BI$result\fB)\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB, \f(CB$result\fB)\fR" 4
.IX Item "process($server, $request, $result)"
If the given \s-1SPF\s0 result is a \f(CW\*(C`fail\*(C'\fR result, retrieves the authority domain's
explanation string from the modifier's target domain and attaches it to the \s-1SPF\s0
result.  If an error occurs during the retrieval of the explanation string,
does nothing, as if the modifier was not present.  See \s-1RFC 4408, 6.2,\s0 for
details.
.PP
See Mail::SPF::Mod for other supported instance methods.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Mod, Mail::SPF::Term, Mail::SPF::Record
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mod::Exp5.16.3pm                  0100644 0001750 0001750 00000015422 12566242063 024721  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mod::Exp 3"
.TH Mail::SPF::Mod::Exp 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mod::Exp \- SPF record "exp" modifier class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mod::Exp\fR represents an \s-1SPF\s0 record modifier of
type \f(CW\*(C`exp\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mod::Exp\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mod::Exp"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exp\*(C'\fR modifier object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
See \*(L"new\*(R" in Mail::SPF::Mod.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mod::Exp\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mod::Exp\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mod::Exp; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMod"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exp\*(C'\fR modifier object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'exp'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a modifier name of \fB'exp'\fR.
.IP "\fBprecedence\fR: returns \fIreal\fR" 4
.IX Item "precedence: returns real"
Returns a precedence value of \fB0.2\fR.  See \*(L"precedence\*(R" in Mail::SPF::Mod.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBparams\fR" 4
.IX Item "params"
See \*(L"params\*(R" in Mail::SPF::Mod.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the modifier.
.ie n .IP "\fBprocess($server, \fB$request\fB, \f(BI$result\fB)\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB, \f(CB$result\fB)\fR" 4
.IX Item "process($server, $request, $result)"
If the given \s-1SPF\s0 result is a \f(CW\*(C`fail\*(C'\fR result, retrieves the authority domain's
explanation string from the modifier's target domain and attaches it to the \s-1SPF\s0
result.  If an error occurs during the retrieval of the explanation string,
does nothing, as if the modifier was not present.  See \s-1RFC\s0 4408, 6.2, for
details.
.PP
See Mail::SPF::Mod for other supported instance methods.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Mod, Mail::SPF::Term, Mail::SPF::Record
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mod::Exp5.18.3pm                  0100644 0001750 0001750 00000015743 12566242050 024725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mod::Exp 3"
.TH Mail::SPF::Mod::Exp 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mod::Exp \- SPF record "exp" modifier class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mod::Exp\fR represents an \s-1SPF\s0 record modifier of
type \f(CW\*(C`exp\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mod::Exp\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mod::Exp"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exp\*(C'\fR modifier object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
See \*(L"new\*(R" in Mail::SPF::Mod.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mod::Exp\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mod::Exp\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mod::Exp; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMod"
Creates a new \s-1SPF\s0 record \f(CW\*(C`exp\*(C'\fR modifier object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'exp'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a modifier name of \fB'exp'\fR.
.IP "\fBprecedence\fR: returns \fIreal\fR" 4
.IX Item "precedence: returns real"
Returns a precedence value of \fB0.2\fR.  See \*(L"precedence\*(R" in Mail::SPF::Mod.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBparams\fR" 4
.IX Item "params"
See \*(L"params\*(R" in Mail::SPF::Mod.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the modifier.
.ie n .IP "\fBprocess($server, \fB$request\fB, \f(BI$result\fB)\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB, \f(CB$result\fB)\fR" 4
.IX Item "process($server, $request, $result)"
If the given \s-1SPF\s0 result is a \f(CW\*(C`fail\*(C'\fR result, retrieves the authority domain's
explanation string from the modifier's target domain and attaches it to the \s-1SPF\s0
result.  If an error occurs during the retrieval of the explanation string,
does nothing, as if the modifier was not present.  See \s-1RFC 4408, 6.2,\s0 for
details.
.PP
See Mail::SPF::Mod for other supported instance methods.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Mod, Mail::SPF::Term, Mail::SPF::Record
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mod::Redirect.3pm                 0100644 0001750 0001750 00000016465 12566242051 025421  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mod::Redirect 3"
.TH Mail::SPF::Mod::Redirect 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mod::Redirect \- SPF record "redirect" modifier class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mod::Redirect\fR represents an \s-1SPF\s0 record
modifier of type \f(CW\*(C`redirect\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mod::Redirect\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mod::Redirect"
Creates a new \s-1SPF\s0 record \f(CW\*(C`redirect\*(C'\fR modifier object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
See \*(L"new\*(R" in Mail::SPF::Mod.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mod::Redirect\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mod::Redirect\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mod::Redirect; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMod"
Creates a new \s-1SPF\s0 record \f(CW\*(C`redirect\*(C'\fR modifier object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'redirect'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a modifier name of \fB'redirect'\fR.
.IP "\fBprecedence\fR: returns \fIreal\fR" 4
.IX Item "precedence: returns real"
Returns a precedence value of \fB0.8\fR.  See \*(L"precedence\*(R" in Mail::SPF::Mod.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBparams\fR" 4
.IX Item "params"
See \*(L"params\*(R" in Mail::SPF::Mod.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the modifier.
.ie n .IP "\fBprocess($server, \fB$request\fB, \f(BI$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB, \f(CB$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "process($server, $request, $result): throws Mail::SPF::Result"
If no mechanism matched during the evaluation of the current \s-1SPF\s0 record,
performs a recursive \s-1SPF\s0 check using the given \s-1SPF\s0 server and request objects
and substituting the modifier's target domain name for the request's authority
domain.  The result of the recursive \s-1SPF\s0 check is then thrown as the result of
the current record's evaluation.  However, if the target domain has no
acceptable \s-1SPF\s0 record, a \f(CW\*(C`permerror\*(C'\fR result is thrown.  See \s-1RFC 4408, 6.1,\s0 for
details.
.PP
See Mail::SPF::Mod for other supported instance methods.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Mod, Mail::SPF::Term, Mail::SPF::Record
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mod::Redirect5.16.3pm             0100644 0001750 0001750 00000016144 12566242063 025730  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mod::Redirect 3"
.TH Mail::SPF::Mod::Redirect 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mod::Redirect \- SPF record "redirect" modifier class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mod::Redirect\fR represents an \s-1SPF\s0 record
modifier of type \f(CW\*(C`redirect\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mod::Redirect\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mod::Redirect"
Creates a new \s-1SPF\s0 record \f(CW\*(C`redirect\*(C'\fR modifier object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
See \*(L"new\*(R" in Mail::SPF::Mod.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mod::Redirect\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mod::Redirect\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mod::Redirect; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMod"
Creates a new \s-1SPF\s0 record \f(CW\*(C`redirect\*(C'\fR modifier object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'redirect'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a modifier name of \fB'redirect'\fR.
.IP "\fBprecedence\fR: returns \fIreal\fR" 4
.IX Item "precedence: returns real"
Returns a precedence value of \fB0.8\fR.  See \*(L"precedence\*(R" in Mail::SPF::Mod.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBparams\fR" 4
.IX Item "params"
See \*(L"params\*(R" in Mail::SPF::Mod.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the modifier.
.ie n .IP "\fBprocess($server, \fB$request\fB, \f(BI$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB, \f(CB$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "process($server, $request, $result): throws Mail::SPF::Result"
If no mechanism matched during the evaluation of the current \s-1SPF\s0 record,
performs a recursive \s-1SPF\s0 check using the given \s-1SPF\s0 server and request objects
and substituting the modifier's target domain name for the request's authority
domain.  The result of the recursive \s-1SPF\s0 check is then thrown as the result of
the current record's evaluation.  However, if the target domain has no
acceptable \s-1SPF\s0 record, a \f(CW\*(C`permerror\*(C'\fR result is thrown.  See \s-1RFC\s0 4408, 6.1, for
details.
.PP
See Mail::SPF::Mod for other supported instance methods.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Mod, Mail::SPF::Term, Mail::SPF::Record
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mod::Redirect5.18.3pm             0100644 0001750 0001750 00000016465 12566242051 025735  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mod::Redirect 3"
.TH Mail::SPF::Mod::Redirect 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mod::Redirect \- SPF record "redirect" modifier class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mod::Redirect\fR represents an \s-1SPF\s0 record
modifier of type \f(CW\*(C`redirect\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mod::Redirect\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mod::Redirect"
Creates a new \s-1SPF\s0 record \f(CW\*(C`redirect\*(C'\fR modifier object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
See \*(L"new\*(R" in Mail::SPF::Mod.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mod::Redirect\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mod::Redirect\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMod\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mod::Redirect; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMod"
Creates a new \s-1SPF\s0 record \f(CW\*(C`redirect\*(C'\fR modifier object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
Returns \fB'redirect'\fR.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches a modifier name of \fB'redirect'\fR.
.IP "\fBprecedence\fR: returns \fIreal\fR" 4
.IX Item "precedence: returns real"
Returns a precedence value of \fB0.8\fR.  See \*(L"precedence\*(R" in Mail::SPF::Mod.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBparams\fR" 4
.IX Item "params"
See \*(L"params\*(R" in Mail::SPF::Mod.
.IP "\fBdomain_spec\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "domain_spec: returns Mail::SPF::MacroString"
Returns the \f(CW\*(C`domain\-spec\*(C'\fR parameter of the modifier.
.ie n .IP "\fBprocess($server, \fB$request\fB, \f(BI$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBprocess($server, \f(CB$request\fB, \f(CB$result\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "process($server, $request, $result): throws Mail::SPF::Result"
If no mechanism matched during the evaluation of the current \s-1SPF\s0 record,
performs a recursive \s-1SPF\s0 check using the given \s-1SPF\s0 server and request objects
and substituting the modifier's target domain name for the request's authority
domain.  The result of the recursive \s-1SPF\s0 check is then thrown as the result of
the current record's evaluation.  However, if the target domain has no
acceptable \s-1SPF\s0 record, a \f(CW\*(C`permerror\*(C'\fR result is thrown.  See \s-1RFC 4408, 6.1,\s0 for
details.
.PP
See Mail::SPF::Mod for other supported instance methods.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Mod, Mail::SPF::Term, Mail::SPF::Record
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Query.3pm                         0100644 0001750 0001750 00000056174 12566242017 024144  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Query 3"
.TH Mail::SPF::Query 3 "2006-02-26" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Query \- query Sender Policy Framework for an IP,email,helo
.SH "VERSION"
.IX Header "VERSION"
1.999.1
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    my $query = new Mail::SPF::Query (ip => "127.0.0.1", sender=>\*(Aqfoo@example.com\*(Aq, helo=>"somehost.example.com", trusted=>0, guess=>0);
\&    my ($result,           # pass | fail | softfail | neutral | none | error | unknown [mechanism]
\&        $smtp_comment,     # "please see http://www.openspf.org/why.html?..."  when rejecting, return this string to the SMTP client
\&        $header_comment,   # prepend_header("Received\-SPF" => "$result ($header_comment)")
\&        $spf_record,       # "v=spf1 ..." original SPF record for the domain
\&       ) = $query\->result();
\&
\&    if    ($result eq "pass") { "Domain is not forged. Apply RHSBL and content filters." }
\&    elsif ($result eq "fail") { "Domain is forged. Reject or save to spambox." }
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
The \s-1SPF\s0 protocol relies on sender domains to describe their designated outbound
mailers in \s-1DNS. \s0 Given an email address, Mail::SPF::Query determines the
legitimacy of an \s-1SMTP\s0 client \s-1IP\s0 address.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
There are two ways to use Mail::SPF::Query.  Your choice depends on whether the
domains your server is an \s-1MX\s0 for have secondary MXes which your server doesn't
know about.
.PP
The first and more common style, calling \->\fIresult()\fR, is suitable when all mail
is received directly from the originator's \s-1MTA. \s0 If the domains you receive do
not have secondary \s-1MX\s0 entries, this is appropriate.  This style of use is
outlined in the \s-1SYNOPSIS\s0 above.  This is the common case.
.PP
The second style is more complex, but works when your server receives mail from
secondary MXes.  This performs checks as each recipient is handled.  If the
message is coming from a valid \s-1MX\s0 secondary for a recipient, then the \s-1SPF\s0 check
is not performed, and a \*(L"pass\*(R" response is returned right away.  To do this,
call \f(CW\*(C`result2()\*(C'\fR and \f(CW\*(C`message_result2()\*(C'\fR instead of \f(CW\*(C`result()\*(C'\fR.
.PP
If you do not know what a secondary \s-1MX\s0 is, you probably don't have one.  Use
the first style.
.PP
You can try out Mail::SPF::Query on the command line with the following
command:
.PP
.Vb 3
\&    perl \-MMail::SPF::Query \-le \*(Aqprint for Mail::SPF::Query\->new(
\&        helo => shift, ipv4 => shift, sender => shift)\->result\*(Aq \e
\&        helohost.example.com 1.2.3.4 user@example.com
.Ve
.SH "BUGS"
.IX Header "BUGS"
Mail::SPF::Query tries to implement the \s-1SPF\s0 specification (see \*(L"\s-1SEE ALSO\*(R"\s0)
as close as reasonably possible given that M:S:Q has been the very first \s-1SPF\s0
implementation and has changed with the \s-1SPF\s0 specification over time.  As a
result, M:S:Q has various known deficiencies that cannot be corrected with
reasonably little effort:
.IP "\(bu" 4
\&\fBUnable to query \s-1HELO\s0 and \s-1MAIL FROM\s0 separately.\fR  M:S:Q is not designed to
support the \fIseparate\fR querying of the \s-1HELO\s0 and \s-1MAIL FROM\s0 identities.  Passing
the \s-1HELO\s0 identity as the \f(CW\*(C`sender\*(C'\fR argument for a stand-alone \s-1HELO\s0 check might
generally work but could yield unexpected results.
.IP "\(bu" 4
\&\fBNo IPv6 support.\fR  IPv6 is not supported.  \f(CW\*(C`ip6\*(C'\fR mechanisms in \s-1SPF\s0 records
and everywhere else are simply ignored.
.IP "\(bu" 4
\&\fBResult explanation may be inappropriate for local policy results.\fR  If a
query result was caused by anything other than a real \s-1SPF\s0 record (i.e. local
policy, overrides, fallbacks, etc.), and no custom \f(CW\*(C`default_explanation\*(C'\fR was
specified, the domain's explanation or M:S:Q's hard-coded default explanation
will still be returned.  Be aware that in this case the explanation may not
correctly explain the reason for such an artificial result.
.SH "NON-STANDARD FEATURES"
.IX Header "NON-STANDARD FEATURES"
Also due to its long history, M:S:Q does have some legacy features that are not
parts of the official \s-1SPF\s0 specification, most notably \fIbest guess processing\fR
and \fItrusted forwarder accreditation checking\fR.  Please be careful when using
these \fInon-standard\fR features or when reproducing them in your own \s-1SPF\s0
implementation, as they may cause unexpected results.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """Mail::SPF::Query\->new()"""
.el .SS "\f(CWMail::SPF::Query\->new()\fP"
.IX Subsection "Mail::SPF::Query->new()"
.Vb 4
\&    my $query = eval { new Mail::SPF::Query (
\&        ip          => \*(Aq127.0.0.1\*(Aq,
\&        sender      => \*(Aqfoo@example.com\*(Aq,
\&        helo        => \*(Aqhost.example.com\*(Aq,
\&
\&        # Optional parameters:
\&        debug       => 1, debuglog => sub { print STDERR "@_\en" },
\&        local       => \*(Aqextra mechanisms\*(Aq,
\&        trusted     => 1,                   # do trusted forwarder processing
\&        guess       => 1,                   # do best guess if no SPF record
\&        default_explanation => \*(AqPlease see http://spf.my.isp/spferror.html for details\*(Aq,
\&        max_lookup_count    => 10,          # total number of SPF includes/redirects
\&        sanitize    => 0,                   # do not sanitize all returned strings
\&        myhostname  => \*(Aqfoo.example.com\*(Aq,   # prepended to header_comment
\&        override    => {   \*(Aqexample.net\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq,
\&                         \*(Aq*.example.net\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq },
\&        fallback    => {   \*(Aqexample.org\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq,
\&                         \*(Aq*.example.org\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq }
\&    ) };
\&
\&    if ($@) { warn "bad input to Mail::SPF::Query: $@" }
.Ve
.PP
Set \f(CW\*(C`trusted=>1\*(C'\fR to turned on \f(CW\*(C`trusted\-forwarder.org\*(C'\fR accreditation
checking.  The mechanism \f(CW\*(C`include:spf.trusted\-forwarder.org\*(C'\fR is used just
before a \f(CW\*(C`\-all\*(C'\fR or \f(CW\*(C`?all\*(C'\fR.  The precise circumstances are somewhat more
complicated, but it does get the case of \f(CW\*(C`v=spf1 \-all\*(C'\fR right \*(-- i.e.
\&\f(CW\*(C`trusted\-forwarder.org\*(C'\fR is not checked.  \fBThis is a non-standard feature.\fR
.PP
Set \f(CW\*(C`guess=>1\*(C'\fR to turned on automatic best guess processing.  This will
use the best_guess \s-1SPF\s0 record when one cannot be found in the \s-1DNS. \s0 Note that
this can only return \f(CW\*(C`pass\*(C'\fR or \f(CW\*(C`neutral\*(C'\fR.  The \f(CW\*(C`trusted\*(C'\fR and \f(CW\*(C`local\*(C'\fR flags
also operate when the best_guess is being used.  \fBThis is a non-standard
feature.\fR
.PP
Set \f(CW\*(C`local=>\*(Aqinclude:local.domain\*(Aq\*(C'\fR to include some extra processing just
before a \f(CW\*(C`\-all\*(C'\fR or \f(CW\*(C`?all\*(C'\fR.  The local processing happens just before the
trusted forwarder processing.  \fBThis is a non-standard feature.\fR
.PP
Set \f(CW\*(C`default_explanation\*(C'\fR to a string to be used if the \s-1SPF\s0 record does not
provide a specific explanation. The default value will direct the user to a
page at www.openspf.org with the following message:
.PP
.Vb 1
\&    Please see http://www.openspf.org/why.html?sender=%{S}&ip=%{I}&receiver=%{R}
.Ve
.PP
Note that the string has macro substitution performed.
.PP
Set \f(CW\*(C`sanitize\*(C'\fR to 0 to get all the returned strings unsanitized.
Alternatively, pass a function reference and this function will be used to
sanitize the returned values.  The function must take a single string argument
and return a single string which contains the sanitized result.
.PP
Set \f(CW\*(C`debug=>1\*(C'\fR to watch the queries happen.
.PP
Set \f(CW\*(C`override\*(C'\fR to define \s-1SPF\s0 records for domains that do publish but which you
want to override anyway.  Wildcards are supported.  \fBThis is a non-standard
feature.\fR
.PP
Set \f(CW\*(C`fallback\*(C'\fR to define \*(L"pretend\*(R" \s-1SPF\s0 records for domains that don't publish
them yet.  Wildcards are supported.  \fBThis is a non-standard feature.\fR
.PP
Note: domain name arguments to override and fallback need to be in all
lowercase.
.ie n .SS """$query\->result()"""
.el .SS "\f(CW$query\->result()\fP"
.IX Subsection "$query->result()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment, $spf_record, $detail) = $query\->result();
.Ve
.PP
\&\f(CW$result\fR will be one of \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR, \f(CW\*(C`softfail\*(C'\fR, \f(CW\*(C`neutral\*(C'\fR, \f(CW\*(C`none\*(C'\fR,
\&\f(CW\*(C`error\*(C'\fR or \f(CW\*(C`unknown [...]\*(C'\fR:
.ie n .IP """pass""" 4
.el .IP "\f(CWpass\fR" 4
.IX Item "pass"
The client \s-1IP\s0 address is an authorized mailer for the sender.  The mail should
be accepted subject to local policy regarding the sender.
.ie n .IP """fail""" 4
.el .IP "\f(CWfail\fR" 4
.IX Item "fail"
The client \s-1IP\s0 address is not an authorized mailer, and the sender wants you to
reject the transaction for fear of forgery.
.ie n .IP """softfail""" 4
.el .IP "\f(CWsoftfail\fR" 4
.IX Item "softfail"
The client \s-1IP\s0 address is not an authorized mailer, but the sender prefers that
you accept the transaction because it isn't absolutely sure all its users are
mailing through approved servers.  The \f(CW\*(C`softfail\*(C'\fR status is often used during
initial deployment of \s-1SPF\s0 records by a domain.
.ie n .IP """neutral""" 4
.el .IP "\f(CWneutral\fR" 4
.IX Item "neutral"
The sender makes no assertion about the status of the client \s-1IP.\s0
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
There is no \s-1SPF\s0 record for this domain.
.ie n .IP """error""" 4
.el .IP "\f(CWerror\fR" 4
.IX Item "error"
The \s-1DNS\s0 lookup encountered a temporary error during processing.
.ie n .IP """unknown [...]""" 4
.el .IP "\f(CWunknown [...]\fR" 4
.IX Item "unknown [...]"
The domain has a configuration error in the published data or defines a
mechanism that this library does not understand.  If the data contained an
unrecognized mechanism, it will be presented following \*(L"unknown\*(R".  You should
test for unknown using a regexp \f(CW\*(C`/^unknown/\*(C'\fR rather than \f(CW\*(C`eq "unknown"\*(C'\fR.
.PP
Results are cached internally for a default of 120 seconds.  You can call
\&\f(CW\*(C`\->result()\*(C'\fR repeatedly; subsequent lookups won't hit your \s-1DNS.\s0
.PP
\&\f(CW\*(C`smtp_comment\*(C'\fR should be displayed to the \s-1SMTP\s0 client.
.PP
\&\f(CW\*(C`header_comment\*(C'\fR goes into a \f(CW\*(C`Received\-SPF\*(C'\fR header, like so:
.PP
.Vb 1
\&    Received\-SPF: $result ($header_comment)
.Ve
.PP
\&\f(CW\*(C`spf_record\*(C'\fR shows the original \s-1SPF\s0 record fetched for the query.  If there is
no \s-1SPF\s0 record, it is blank.  Otherwise, it will start with \f(CW\*(C`v=spf1\*(C'\fR and
contain the \s-1SPF\s0 mechanisms and such that describe the domain.
.PP
Note that the strings returned by this method (and most of the other methods)
are (at least partially) under the control of the sender's domain.  This means
that, if the sender is an attacker, the contents can be assumed to be hostile.
The various methods that return these strings make sure that (by default) the
strings returned contain only characters in the range 32 \- 126.  This behavior
can be changed by setting \f(CW\*(C`sanitize\*(C'\fR to 0 to turn off sanitization entirely.
You can also set \f(CW\*(C`sanitize\*(C'\fR to a function reference to perform custom
sanitization.  In particular, assume that \f(CW\*(C`smtp_comment\*(C'\fR might contain a
newline character.
.PP
\&\f(CW\*(C`detail\*(C'\fR is a hash of all the foregoing result elements, plus extra data
returned by the \s-1SPF\s0 result.
.PP
\&\fIWhy the weird duplication?\fR  In the beginning, \f(CW\*(C`result()\*(C'\fR returned only one
value, the \f(CW$result\fR.  Then \f(CW$smtp_comment\fR and \f(CW$header_comment\fR came
along.  Then \f(CW$spf_record\fR.  Past a certain number of positional results, it
makes more sense to have a hash.  But we didn't want to break backwards
compatibility, so we just declared that the fifth result would be a hash and
future return value would go in there.
.PP
The keys of the hash are:
.PP
.Vb 6
\&    result
\&    smtp_comment
\&    header_comment
\&    header_pairs
\&    spf_record
\&    modifiers
.Ve
.ie n .SS """$query\->result2()"""
.el .SS "\f(CW$query\->result2()\fP"
.IX Subsection "$query->result2()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment, $spf_record) = $query\->result2(\*(Aqrecipient@domain\*(Aq, \*(Aqrecipient2@domain\*(Aq);
.Ve
.PP
\&\f(CW\*(C`result2()\*(C'\fR does everything that \f(CW\*(C`result()\*(C'\fR does, but it first checks to see if
the sending system is a recognized \s-1MX\s0 secondary for the recipient(s).  If so,
then it returns \f(CW\*(C`pass\*(C'\fR and does not perform the \s-1SPF\s0 query.  Note that the
sending system may be a \s-1MX\s0 secondary for some (but not all) of the recipients
for a multi-recipient message, which is why result2 takes an argument list.
See also \f(CW\*(C`message_result2()\*(C'\fR.
.PP
\&\fBThis is a non-standard feature.\fR  \fBThis feature is also deprecated, because
exemption of trusted relays, such as secondary MXes, should really be performed
by the software that uses this library before doing an \s-1SPF\s0 check.\fR
.PP
\&\f(CW$result\fR will be one of \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR, \f(CW\*(C`neutral [...]\*(C'\fR, or \f(CW\*(C`unknown\*(C'\fR.
See \f(CW\*(C`result()\*(C'\fR above for meanings.
.PP
If you have secondary MXes and if you are unable to explicitly white-list them
before \s-1SPF\s0 tests occur, you can use this method in place of \f(CW\*(C`result()\*(C'\fR,
calling it as many times as there are recipients, or just providing all the
recipients at one time.
.PP
\&\f(CW\*(C`smtp_comment\*(C'\fR can be displayed to the \s-1SMTP\s0 client.
.PP
For example:
.PP
.Vb 3
\&    my $query = new Mail::SPF::Query (ip => "127.0.0.1",
\&                                      sender=>\*(Aqfoo@example.com\*(Aq,
\&                                      helo=>"somehost.example.com");
\&
\&    ...
\&
\&    my ($result, $smtp_comment, $header_comment);
\&
\&    ($result, $smtp_comment, $header_comment) = $query\->result2(\*(Aqrecip1@example.com\*(Aq);
\&    # return suitable error code based on $result eq \*(Aqfail\*(Aq or not
\&
\&    ($result, $smtp_comment, $header_comment) = $query\->result2(\*(Aqrecip2@example.org\*(Aq);
\&    # return suitable error code based on $result eq \*(Aqfail\*(Aq or not
\&
\&    ($result, $smtp_comment, $header_comment) = $query\->message_result2();
\&    # return suitable error if $result eq \*(Aqfail\*(Aq
\&    # prefix message with "Received\-SPF: $result ($header_comment)"
.Ve
.ie n .SS """$query\->message_result2()"""
.el .SS "\f(CW$query\->message_result2()\fP"
.IX Subsection "$query->message_result2()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment, $spf_record) = $query\->message_result2();
.Ve
.PP
\&\f(CW\*(C`message_result2()\*(C'\fR returns an overall status for the message after zero or
more calls to \f(CW\*(C`result2()\*(C'\fR.  It will always be the last status returned by
\&\f(CW\*(C`result2()\*(C'\fR, or the status returned by \f(CW\*(C`result()\*(C'\fR if \f(CW\*(C`result2()\*(C'\fR was never
called.
.PP
\&\f(CW$result\fR will be one of \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR, \f(CW\*(C`neutral [...]\*(C'\fR, or \f(CW\*(C`error\*(C'\fR.  See
\&\f(CW\*(C`result()\*(C'\fR above for meanings.
.ie n .SS """$query\->best_guess()"""
.el .SS "\f(CW$query\->best_guess()\fP"
.IX Subsection "$query->best_guess()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment) = $query\->best_guess();
.Ve
.PP
When a domain does not publish an \s-1SPF\s0 record, this library can produce an
educated guess anyway.
.PP
It pretends the domain defined A, \s-1MX,\s0 and \s-1PTR\s0 mechanisms, plus a few others.
The default set of directives is
.PP
.Vb 1
\&    a/24 mx/24 ptr
.Ve
.PP
That default set will return either \*(L"pass\*(R" or \*(L"neutral\*(R".
.PP
If you want to experiment with a different default, you can pass it as an
argument: \f(CW\*(C`$query\->best_guess("a mx ptr")\*(C'\fR
.PP
\&\fBThis is a non-standard feature.\fR  \fBThis method is also deprecated.\fR  You
should set \f(CW\*(C`guess=>1\*(C'\fR on the \f(CW\*(C`new()\*(C'\fR method instead.
.ie n .SS """$query\->trusted_forwarder()"""
.el .SS "\f(CW$query\->trusted_forwarder()\fP"
.IX Subsection "$query->trusted_forwarder()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment) = $query\->best_guess();
.Ve
.PP
It is possible that the message is coming through a known-good relay like
\&\f(CW\*(C`acm.org\*(C'\fR or \f(CW\*(C`pobox.com\*(C'\fR.  During the transitional period, many legitimate
services may appear to forge a sender address: for example, a news website may
have a \*(L"send me this article in email\*(R" link.
.PP
The \f(CW\*(C`trusted\-forwarder.org\*(C'\fR domain is a white-list of known-good hosts that
either forward mail or perform benign envelope sender forgery:
.PP
.Vb 1
\&    include:spf.trusted\-forwarder.org
.Ve
.PP
This will return either \*(L"pass\*(R" or \*(L"neutral\*(R".
.PP
\&\fBThis is a non-standard feature.\fR  \fBThis method is also deprecated.\fR  You
should set \f(CW\*(C`trusted=>1\*(C'\fR on the \f(CW\*(C`new()\*(C'\fR method instead.
.ie n .SS """$query\->sanitize(\*(Aqstring\*(Aq)"""
.el .SS "\f(CW$query\->sanitize(\*(Aqstring\*(Aq)\fP"
.IX Subsection "$query->sanitize(string)"
This applies the sanitization rules for the particular query object. These
rules are controlled by the \f(CW\*(C`sanitize\*(C'\fR parameter to the c<\fInew()\fR> method.
.ie n .SS """strict_sanitize(\*(Aqstring\*(Aq)"""
.el .SS "\f(CWstrict_sanitize(\*(Aqstring\*(Aq)\fP"
.IX Subsection "strict_sanitize(string)"
This ensures that all the characters in the returned string are printable.  All
whitespace is converted into spaces, and all other non-printable characters are
converted into question marks.  This is probably over-aggressive for many
applications.
.PP
This function is used by default when the \f(CW\*(C`sanitize\*(C'\fR option is passed to the
\&\f(CW\*(C`new()\*(C'\fR method.
.PP
\&\fBThis function is not a class method.\fR
.ie n .SS """$query\->debuglog()"""
.el .SS "\f(CW$query\->debuglog()\fP"
.IX Subsection "$query->debuglog()"
Subclasses may override this with their own debug logger.  \f(CW\*(C`Log::Dispatch\*(C'\fR is
recommended.
.PP
Alternatively, pass the \f(CW\*(C`new()\*(C'\fR constructor a \f(CW\*(C`debuglog => sub { ... }\*(C'\fR
callback, and we'll pass debugging lines to that.
.SH "WARNINGS"
.IX Header "WARNINGS"
Mail::Query::SPF should only be used at the point where messages are received
from the Internet.  The underlying assumption is that the sender of the e\-mail
is sending the message directly to you or one of your secondary MXes.  If your
\&\s-1MTA\s0 does not have an exhaustive list of secondary MXes, then the \f(CW\*(C`result2()\*(C'\fR
and \f(CW\*(C`message_result2()\*(C'\fR methods can be used.  These methods take care to
permit mail from secondary MXes.
.SH "AUTHORS"
.IX Header "AUTHORS"
Meng Weng Wong <mengwong+spf@pobox.com>, Philip Gladstone, Julian Mehnle
<julian@mehnle.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
About \s-1SPF: \s0<http://www.openspf.org>
.PP
Mail::SPF::Query: <http://search.cpan.org/dist/Mail\-SPF\-Query>
.PP
The latest release of the \s-1SPF\s0 specification: <http://www.openspf.org/spf\-classic\-current.txt>
                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Query5.16.3pm                     0100644 0001750 0001750 00000056032 12566242015 024445  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Query 3"
.TH Mail::SPF::Query 3 "2006-02-26" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Query \- query Sender Policy Framework for an IP,email,helo
.SH "VERSION"
.IX Header "VERSION"
1.999.1
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    my $query = new Mail::SPF::Query (ip => "127.0.0.1", sender=>\*(Aqfoo@example.com\*(Aq, helo=>"somehost.example.com", trusted=>0, guess=>0);
\&    my ($result,           # pass | fail | softfail | neutral | none | error | unknown [mechanism]
\&        $smtp_comment,     # "please see http://www.openspf.org/why.html?..."  when rejecting, return this string to the SMTP client
\&        $header_comment,   # prepend_header("Received\-SPF" => "$result ($header_comment)")
\&        $spf_record,       # "v=spf1 ..." original SPF record for the domain
\&       ) = $query\->result();
\&
\&    if    ($result eq "pass") { "Domain is not forged. Apply RHSBL and content filters." }
\&    elsif ($result eq "fail") { "Domain is forged. Reject or save to spambox." }
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
The \s-1SPF\s0 protocol relies on sender domains to describe their designated outbound
mailers in \s-1DNS\s0.  Given an email address, Mail::SPF::Query determines the
legitimacy of an \s-1SMTP\s0 client \s-1IP\s0 address.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
There are two ways to use Mail::SPF::Query.  Your choice depends on whether the
domains your server is an \s-1MX\s0 for have secondary MXes which your server doesn't
know about.
.PP
The first and more common style, calling \->\fIresult()\fR, is suitable when all mail
is received directly from the originator's \s-1MTA\s0.  If the domains you receive do
not have secondary \s-1MX\s0 entries, this is appropriate.  This style of use is
outlined in the \s-1SYNOPSIS\s0 above.  This is the common case.
.PP
The second style is more complex, but works when your server receives mail from
secondary MXes.  This performs checks as each recipient is handled.  If the
message is coming from a valid \s-1MX\s0 secondary for a recipient, then the \s-1SPF\s0 check
is not performed, and a \*(L"pass\*(R" response is returned right away.  To do this,
call \f(CW\*(C`result2()\*(C'\fR and \f(CW\*(C`message_result2()\*(C'\fR instead of \f(CW\*(C`result()\*(C'\fR.
.PP
If you do not know what a secondary \s-1MX\s0 is, you probably don't have one.  Use
the first style.
.PP
You can try out Mail::SPF::Query on the command line with the following
command:
.PP
.Vb 3
\&    perl \-MMail::SPF::Query \-le \*(Aqprint for Mail::SPF::Query\->new(
\&        helo => shift, ipv4 => shift, sender => shift)\->result\*(Aq \e
\&        helohost.example.com 1.2.3.4 user@example.com
.Ve
.SH "BUGS"
.IX Header "BUGS"
Mail::SPF::Query tries to implement the \s-1SPF\s0 specification (see \*(L"\s-1SEE\s0 \s-1ALSO\s0\*(R")
as close as reasonably possible given that M:S:Q has been the very first \s-1SPF\s0
implementation and has changed with the \s-1SPF\s0 specification over time.  As a
result, M:S:Q has various known deficiencies that cannot be corrected with
reasonably little effort:
.IP "\(bu" 4
\&\fBUnable to query \s-1HELO\s0 and \s-1MAIL\s0 \s-1FROM\s0 separately.\fR  M:S:Q is not designed to
support the \fIseparate\fR querying of the \s-1HELO\s0 and \s-1MAIL\s0 \s-1FROM\s0 identities.  Passing
the \s-1HELO\s0 identity as the \f(CW\*(C`sender\*(C'\fR argument for a stand-alone \s-1HELO\s0 check might
generally work but could yield unexpected results.
.IP "\(bu" 4
\&\fBNo IPv6 support.\fR  IPv6 is not supported.  \f(CW\*(C`ip6\*(C'\fR mechanisms in \s-1SPF\s0 records
and everywhere else are simply ignored.
.IP "\(bu" 4
\&\fBResult explanation may be inappropriate for local policy results.\fR  If a
query result was caused by anything other than a real \s-1SPF\s0 record (i.e. local
policy, overrides, fallbacks, etc.), and no custom \f(CW\*(C`default_explanation\*(C'\fR was
specified, the domain's explanation or M:S:Q's hard-coded default explanation
will still be returned.  Be aware that in this case the explanation may not
correctly explain the reason for such an artificial result.
.SH "NON-STANDARD FEATURES"
.IX Header "NON-STANDARD FEATURES"
Also due to its long history, M:S:Q does have some legacy features that are not
parts of the official \s-1SPF\s0 specification, most notably \fIbest guess processing\fR
and \fItrusted forwarder accreditation checking\fR.  Please be careful when using
these \fInon-standard\fR features or when reproducing them in your own \s-1SPF\s0
implementation, as they may cause unexpected results.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """Mail::SPF::Query\->new()"""
.el .SS "\f(CWMail::SPF::Query\->new()\fP"
.IX Subsection "Mail::SPF::Query->new()"
.Vb 4
\&    my $query = eval { new Mail::SPF::Query (
\&        ip          => \*(Aq127.0.0.1\*(Aq,
\&        sender      => \*(Aqfoo@example.com\*(Aq,
\&        helo        => \*(Aqhost.example.com\*(Aq,
\&
\&        # Optional parameters:
\&        debug       => 1, debuglog => sub { print STDERR "@_\en" },
\&        local       => \*(Aqextra mechanisms\*(Aq,
\&        trusted     => 1,                   # do trusted forwarder processing
\&        guess       => 1,                   # do best guess if no SPF record
\&        default_explanation => \*(AqPlease see http://spf.my.isp/spferror.html for details\*(Aq,
\&        max_lookup_count    => 10,          # total number of SPF includes/redirects
\&        sanitize    => 0,                   # do not sanitize all returned strings
\&        myhostname  => \*(Aqfoo.example.com\*(Aq,   # prepended to header_comment
\&        override    => {   \*(Aqexample.net\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq,
\&                         \*(Aq*.example.net\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq },
\&        fallback    => {   \*(Aqexample.org\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq,
\&                         \*(Aq*.example.org\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq }
\&    ) };
\&
\&    if ($@) { warn "bad input to Mail::SPF::Query: $@" }
.Ve
.PP
Set \f(CW\*(C`trusted=>1\*(C'\fR to turned on \f(CW\*(C`trusted\-forwarder.org\*(C'\fR accreditation
checking.  The mechanism \f(CW\*(C`include:spf.trusted\-forwarder.org\*(C'\fR is used just
before a \f(CW\*(C`\-all\*(C'\fR or \f(CW\*(C`?all\*(C'\fR.  The precise circumstances are somewhat more
complicated, but it does get the case of \f(CW\*(C`v=spf1 \-all\*(C'\fR right \*(-- i.e.
\&\f(CW\*(C`trusted\-forwarder.org\*(C'\fR is not checked.  \fBThis is a non-standard feature.\fR
.PP
Set \f(CW\*(C`guess=>1\*(C'\fR to turned on automatic best guess processing.  This will
use the best_guess \s-1SPF\s0 record when one cannot be found in the \s-1DNS\s0.  Note that
this can only return \f(CW\*(C`pass\*(C'\fR or \f(CW\*(C`neutral\*(C'\fR.  The \f(CW\*(C`trusted\*(C'\fR and \f(CW\*(C`local\*(C'\fR flags
also operate when the best_guess is being used.  \fBThis is a non-standard
feature.\fR
.PP
Set \f(CW\*(C`local=>\*(Aqinclude:local.domain\*(Aq\*(C'\fR to include some extra processing just
before a \f(CW\*(C`\-all\*(C'\fR or \f(CW\*(C`?all\*(C'\fR.  The local processing happens just before the
trusted forwarder processing.  \fBThis is a non-standard feature.\fR
.PP
Set \f(CW\*(C`default_explanation\*(C'\fR to a string to be used if the \s-1SPF\s0 record does not
provide a specific explanation. The default value will direct the user to a
page at www.openspf.org with the following message:
.PP
.Vb 1
\&    Please see http://www.openspf.org/why.html?sender=%{S}&ip=%{I}&receiver=%{R}
.Ve
.PP
Note that the string has macro substitution performed.
.PP
Set \f(CW\*(C`sanitize\*(C'\fR to 0 to get all the returned strings unsanitized.
Alternatively, pass a function reference and this function will be used to
sanitize the returned values.  The function must take a single string argument
and return a single string which contains the sanitized result.
.PP
Set \f(CW\*(C`debug=>1\*(C'\fR to watch the queries happen.
.PP
Set \f(CW\*(C`override\*(C'\fR to define \s-1SPF\s0 records for domains that do publish but which you
want to override anyway.  Wildcards are supported.  \fBThis is a non-standard
feature.\fR
.PP
Set \f(CW\*(C`fallback\*(C'\fR to define \*(L"pretend\*(R" \s-1SPF\s0 records for domains that don't publish
them yet.  Wildcards are supported.  \fBThis is a non-standard feature.\fR
.PP
Note: domain name arguments to override and fallback need to be in all
lowercase.
.ie n .SS """$query\->result()"""
.el .SS "\f(CW$query\->result()\fP"
.IX Subsection "$query->result()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment, $spf_record, $detail) = $query\->result();
.Ve
.PP
\&\f(CW$result\fR will be one of \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR, \f(CW\*(C`softfail\*(C'\fR, \f(CW\*(C`neutral\*(C'\fR, \f(CW\*(C`none\*(C'\fR,
\&\f(CW\*(C`error\*(C'\fR or \f(CW\*(C`unknown [...]\*(C'\fR:
.ie n .IP """pass""" 4
.el .IP "\f(CWpass\fR" 4
.IX Item "pass"
The client \s-1IP\s0 address is an authorized mailer for the sender.  The mail should
be accepted subject to local policy regarding the sender.
.ie n .IP """fail""" 4
.el .IP "\f(CWfail\fR" 4
.IX Item "fail"
The client \s-1IP\s0 address is not an authorized mailer, and the sender wants you to
reject the transaction for fear of forgery.
.ie n .IP """softfail""" 4
.el .IP "\f(CWsoftfail\fR" 4
.IX Item "softfail"
The client \s-1IP\s0 address is not an authorized mailer, but the sender prefers that
you accept the transaction because it isn't absolutely sure all its users are
mailing through approved servers.  The \f(CW\*(C`softfail\*(C'\fR status is often used during
initial deployment of \s-1SPF\s0 records by a domain.
.ie n .IP """neutral""" 4
.el .IP "\f(CWneutral\fR" 4
.IX Item "neutral"
The sender makes no assertion about the status of the client \s-1IP\s0.
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
There is no \s-1SPF\s0 record for this domain.
.ie n .IP """error""" 4
.el .IP "\f(CWerror\fR" 4
.IX Item "error"
The \s-1DNS\s0 lookup encountered a temporary error during processing.
.ie n .IP """unknown [...]""" 4
.el .IP "\f(CWunknown [...]\fR" 4
.IX Item "unknown [...]"
The domain has a configuration error in the published data or defines a
mechanism that this library does not understand.  If the data contained an
unrecognized mechanism, it will be presented following \*(L"unknown\*(R".  You should
test for unknown using a regexp \f(CW\*(C`/^unknown/\*(C'\fR rather than \f(CW\*(C`eq "unknown"\*(C'\fR.
.PP
Results are cached internally for a default of 120 seconds.  You can call
\&\f(CW\*(C`\->result()\*(C'\fR repeatedly; subsequent lookups won't hit your \s-1DNS\s0.
.PP
\&\f(CW\*(C`smtp_comment\*(C'\fR should be displayed to the \s-1SMTP\s0 client.
.PP
\&\f(CW\*(C`header_comment\*(C'\fR goes into a \f(CW\*(C`Received\-SPF\*(C'\fR header, like so:
.PP
.Vb 1
\&    Received\-SPF: $result ($header_comment)
.Ve
.PP
\&\f(CW\*(C`spf_record\*(C'\fR shows the original \s-1SPF\s0 record fetched for the query.  If there is
no \s-1SPF\s0 record, it is blank.  Otherwise, it will start with \f(CW\*(C`v=spf1\*(C'\fR and
contain the \s-1SPF\s0 mechanisms and such that describe the domain.
.PP
Note that the strings returned by this method (and most of the other methods)
are (at least partially) under the control of the sender's domain.  This means
that, if the sender is an attacker, the contents can be assumed to be hostile.
The various methods that return these strings make sure that (by default) the
strings returned contain only characters in the range 32 \- 126.  This behavior
can be changed by setting \f(CW\*(C`sanitize\*(C'\fR to 0 to turn off sanitization entirely.
You can also set \f(CW\*(C`sanitize\*(C'\fR to a function reference to perform custom
sanitization.  In particular, assume that \f(CW\*(C`smtp_comment\*(C'\fR might contain a
newline character.
.PP
\&\f(CW\*(C`detail\*(C'\fR is a hash of all the foregoing result elements, plus extra data
returned by the \s-1SPF\s0 result.
.PP
\&\fIWhy the weird duplication?\fR  In the beginning, \f(CW\*(C`result()\*(C'\fR returned only one
value, the \f(CW$result\fR.  Then \f(CW$smtp_comment\fR and \f(CW$header_comment\fR came
along.  Then \f(CW$spf_record\fR.  Past a certain number of positional results, it
makes more sense to have a hash.  But we didn't want to break backwards
compatibility, so we just declared that the fifth result would be a hash and
future return value would go in there.
.PP
The keys of the hash are:
.PP
.Vb 6
\&    result
\&    smtp_comment
\&    header_comment
\&    header_pairs
\&    spf_record
\&    modifiers
.Ve
.ie n .SS """$query\->result2()"""
.el .SS "\f(CW$query\->result2()\fP"
.IX Subsection "$query->result2()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment, $spf_record) = $query\->result2(\*(Aqrecipient@domain\*(Aq, \*(Aqrecipient2@domain\*(Aq);
.Ve
.PP
\&\f(CW\*(C`result2()\*(C'\fR does everything that \f(CW\*(C`result()\*(C'\fR does, but it first checks to see if
the sending system is a recognized \s-1MX\s0 secondary for the recipient(s).  If so,
then it returns \f(CW\*(C`pass\*(C'\fR and does not perform the \s-1SPF\s0 query.  Note that the
sending system may be a \s-1MX\s0 secondary for some (but not all) of the recipients
for a multi-recipient message, which is why result2 takes an argument list.
See also \f(CW\*(C`message_result2()\*(C'\fR.
.PP
\&\fBThis is a non-standard feature.\fR  \fBThis feature is also deprecated, because
exemption of trusted relays, such as secondary MXes, should really be performed
by the software that uses this library before doing an \s-1SPF\s0 check.\fR
.PP
\&\f(CW$result\fR will be one of \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR, \f(CW\*(C`neutral [...]\*(C'\fR, or \f(CW\*(C`unknown\*(C'\fR.
See \f(CW\*(C`result()\*(C'\fR above for meanings.
.PP
If you have secondary MXes and if you are unable to explicitly white-list them
before \s-1SPF\s0 tests occur, you can use this method in place of \f(CW\*(C`result()\*(C'\fR,
calling it as many times as there are recipients, or just providing all the
recipients at one time.
.PP
\&\f(CW\*(C`smtp_comment\*(C'\fR can be displayed to the \s-1SMTP\s0 client.
.PP
For example:
.PP
.Vb 3
\&    my $query = new Mail::SPF::Query (ip => "127.0.0.1",
\&                                      sender=>\*(Aqfoo@example.com\*(Aq,
\&                                      helo=>"somehost.example.com");
\&
\&    ...
\&
\&    my ($result, $smtp_comment, $header_comment);
\&
\&    ($result, $smtp_comment, $header_comment) = $query\->result2(\*(Aqrecip1@example.com\*(Aq);
\&    # return suitable error code based on $result eq \*(Aqfail\*(Aq or not
\&
\&    ($result, $smtp_comment, $header_comment) = $query\->result2(\*(Aqrecip2@example.org\*(Aq);
\&    # return suitable error code based on $result eq \*(Aqfail\*(Aq or not
\&
\&    ($result, $smtp_comment, $header_comment) = $query\->message_result2();
\&    # return suitable error if $result eq \*(Aqfail\*(Aq
\&    # prefix message with "Received\-SPF: $result ($header_comment)"
.Ve
.ie n .SS """$query\->message_result2()"""
.el .SS "\f(CW$query\->message_result2()\fP"
.IX Subsection "$query->message_result2()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment, $spf_record) = $query\->message_result2();
.Ve
.PP
\&\f(CW\*(C`message_result2()\*(C'\fR returns an overall status for the message after zero or
more calls to \f(CW\*(C`result2()\*(C'\fR.  It will always be the last status returned by
\&\f(CW\*(C`result2()\*(C'\fR, or the status returned by \f(CW\*(C`result()\*(C'\fR if \f(CW\*(C`result2()\*(C'\fR was never
called.
.PP
\&\f(CW$result\fR will be one of \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR, \f(CW\*(C`neutral [...]\*(C'\fR, or \f(CW\*(C`error\*(C'\fR.  See
\&\f(CW\*(C`result()\*(C'\fR above for meanings.
.ie n .SS """$query\->best_guess()"""
.el .SS "\f(CW$query\->best_guess()\fP"
.IX Subsection "$query->best_guess()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment) = $query\->best_guess();
.Ve
.PP
When a domain does not publish an \s-1SPF\s0 record, this library can produce an
educated guess anyway.
.PP
It pretends the domain defined A, \s-1MX\s0, and \s-1PTR\s0 mechanisms, plus a few others.
The default set of directives is
.PP
.Vb 1
\&    a/24 mx/24 ptr
.Ve
.PP
That default set will return either \*(L"pass\*(R" or \*(L"neutral\*(R".
.PP
If you want to experiment with a different default, you can pass it as an
argument: \f(CW\*(C`$query\->best_guess("a mx ptr")\*(C'\fR
.PP
\&\fBThis is a non-standard feature.\fR  \fBThis method is also deprecated.\fR  You
should set \f(CW\*(C`guess=>1\*(C'\fR on the \f(CW\*(C`new()\*(C'\fR method instead.
.ie n .SS """$query\->trusted_forwarder()"""
.el .SS "\f(CW$query\->trusted_forwarder()\fP"
.IX Subsection "$query->trusted_forwarder()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment) = $query\->best_guess();
.Ve
.PP
It is possible that the message is coming through a known-good relay like
\&\f(CW\*(C`acm.org\*(C'\fR or \f(CW\*(C`pobox.com\*(C'\fR.  During the transitional period, many legitimate
services may appear to forge a sender address: for example, a news website may
have a \*(L"send me this article in email\*(R" link.
.PP
The \f(CW\*(C`trusted\-forwarder.org\*(C'\fR domain is a white-list of known-good hosts that
either forward mail or perform benign envelope sender forgery:
.PP
.Vb 1
\&    include:spf.trusted\-forwarder.org
.Ve
.PP
This will return either \*(L"pass\*(R" or \*(L"neutral\*(R".
.PP
\&\fBThis is a non-standard feature.\fR  \fBThis method is also deprecated.\fR  You
should set \f(CW\*(C`trusted=>1\*(C'\fR on the \f(CW\*(C`new()\*(C'\fR method instead.
.ie n .SS """$query\->sanitize(\*(Aqstring\*(Aq)"""
.el .SS "\f(CW$query\->sanitize(\*(Aqstring\*(Aq)\fP"
.IX Subsection "$query->sanitize(string)"
This applies the sanitization rules for the particular query object. These
rules are controlled by the \f(CW\*(C`sanitize\*(C'\fR parameter to the c<\fInew()\fR> method.
.ie n .SS """strict_sanitize(\*(Aqstring\*(Aq)"""
.el .SS "\f(CWstrict_sanitize(\*(Aqstring\*(Aq)\fP"
.IX Subsection "strict_sanitize(string)"
This ensures that all the characters in the returned string are printable.  All
whitespace is converted into spaces, and all other non-printable characters are
converted into question marks.  This is probably over-aggressive for many
applications.
.PP
This function is used by default when the \f(CW\*(C`sanitize\*(C'\fR option is passed to the
\&\f(CW\*(C`new()\*(C'\fR method.
.PP
\&\fBThis function is not a class method.\fR
.ie n .SS """$query\->debuglog()"""
.el .SS "\f(CW$query\->debuglog()\fP"
.IX Subsection "$query->debuglog()"
Subclasses may override this with their own debug logger.  \f(CW\*(C`Log::Dispatch\*(C'\fR is
recommended.
.PP
Alternatively, pass the \f(CW\*(C`new()\*(C'\fR constructor a \f(CW\*(C`debuglog => sub { ... }\*(C'\fR
callback, and we'll pass debugging lines to that.
.SH "WARNINGS"
.IX Header "WARNINGS"
Mail::Query::SPF should only be used at the point where messages are received
from the Internet.  The underlying assumption is that the sender of the e\-mail
is sending the message directly to you or one of your secondary MXes.  If your
\&\s-1MTA\s0 does not have an exhaustive list of secondary MXes, then the \f(CW\*(C`result2()\*(C'\fR
and \f(CW\*(C`message_result2()\*(C'\fR methods can be used.  These methods take care to
permit mail from secondary MXes.
.SH "AUTHORS"
.IX Header "AUTHORS"
Meng Weng Wong <mengwong+spf@pobox.com>, Philip Gladstone, Julian Mehnle
<julian@mehnle.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
About \s-1SPF:\s0 <http://www.openspf.org>
.PP
Mail::SPF::Query: http://search.cpan.org/dist/Mail\-SPF\-Query <http://search.cpan.org/dist/Mail-SPF-Query>
.PP
The latest release of the \s-1SPF\s0 specification: http://www.openspf.org/spf\-classic\-current.txt <http://www.openspf.org/spf-classic-current.txt>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Query5.18.3pm                     0100644 0001750 0001750 00000056174 12566242017 024460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Query 3"
.TH Mail::SPF::Query 3 "2006-02-26" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Query \- query Sender Policy Framework for an IP,email,helo
.SH "VERSION"
.IX Header "VERSION"
1.999.1
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    my $query = new Mail::SPF::Query (ip => "127.0.0.1", sender=>\*(Aqfoo@example.com\*(Aq, helo=>"somehost.example.com", trusted=>0, guess=>0);
\&    my ($result,           # pass | fail | softfail | neutral | none | error | unknown [mechanism]
\&        $smtp_comment,     # "please see http://www.openspf.org/why.html?..."  when rejecting, return this string to the SMTP client
\&        $header_comment,   # prepend_header("Received\-SPF" => "$result ($header_comment)")
\&        $spf_record,       # "v=spf1 ..." original SPF record for the domain
\&       ) = $query\->result();
\&
\&    if    ($result eq "pass") { "Domain is not forged. Apply RHSBL and content filters." }
\&    elsif ($result eq "fail") { "Domain is forged. Reject or save to spambox." }
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
The \s-1SPF\s0 protocol relies on sender domains to describe their designated outbound
mailers in \s-1DNS. \s0 Given an email address, Mail::SPF::Query determines the
legitimacy of an \s-1SMTP\s0 client \s-1IP\s0 address.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
There are two ways to use Mail::SPF::Query.  Your choice depends on whether the
domains your server is an \s-1MX\s0 for have secondary MXes which your server doesn't
know about.
.PP
The first and more common style, calling \->\fIresult()\fR, is suitable when all mail
is received directly from the originator's \s-1MTA. \s0 If the domains you receive do
not have secondary \s-1MX\s0 entries, this is appropriate.  This style of use is
outlined in the \s-1SYNOPSIS\s0 above.  This is the common case.
.PP
The second style is more complex, but works when your server receives mail from
secondary MXes.  This performs checks as each recipient is handled.  If the
message is coming from a valid \s-1MX\s0 secondary for a recipient, then the \s-1SPF\s0 check
is not performed, and a \*(L"pass\*(R" response is returned right away.  To do this,
call \f(CW\*(C`result2()\*(C'\fR and \f(CW\*(C`message_result2()\*(C'\fR instead of \f(CW\*(C`result()\*(C'\fR.
.PP
If you do not know what a secondary \s-1MX\s0 is, you probably don't have one.  Use
the first style.
.PP
You can try out Mail::SPF::Query on the command line with the following
command:
.PP
.Vb 3
\&    perl \-MMail::SPF::Query \-le \*(Aqprint for Mail::SPF::Query\->new(
\&        helo => shift, ipv4 => shift, sender => shift)\->result\*(Aq \e
\&        helohost.example.com 1.2.3.4 user@example.com
.Ve
.SH "BUGS"
.IX Header "BUGS"
Mail::SPF::Query tries to implement the \s-1SPF\s0 specification (see \*(L"\s-1SEE ALSO\*(R"\s0)
as close as reasonably possible given that M:S:Q has been the very first \s-1SPF\s0
implementation and has changed with the \s-1SPF\s0 specification over time.  As a
result, M:S:Q has various known deficiencies that cannot be corrected with
reasonably little effort:
.IP "\(bu" 4
\&\fBUnable to query \s-1HELO\s0 and \s-1MAIL FROM\s0 separately.\fR  M:S:Q is not designed to
support the \fIseparate\fR querying of the \s-1HELO\s0 and \s-1MAIL FROM\s0 identities.  Passing
the \s-1HELO\s0 identity as the \f(CW\*(C`sender\*(C'\fR argument for a stand-alone \s-1HELO\s0 check might
generally work but could yield unexpected results.
.IP "\(bu" 4
\&\fBNo IPv6 support.\fR  IPv6 is not supported.  \f(CW\*(C`ip6\*(C'\fR mechanisms in \s-1SPF\s0 records
and everywhere else are simply ignored.
.IP "\(bu" 4
\&\fBResult explanation may be inappropriate for local policy results.\fR  If a
query result was caused by anything other than a real \s-1SPF\s0 record (i.e. local
policy, overrides, fallbacks, etc.), and no custom \f(CW\*(C`default_explanation\*(C'\fR was
specified, the domain's explanation or M:S:Q's hard-coded default explanation
will still be returned.  Be aware that in this case the explanation may not
correctly explain the reason for such an artificial result.
.SH "NON-STANDARD FEATURES"
.IX Header "NON-STANDARD FEATURES"
Also due to its long history, M:S:Q does have some legacy features that are not
parts of the official \s-1SPF\s0 specification, most notably \fIbest guess processing\fR
and \fItrusted forwarder accreditation checking\fR.  Please be careful when using
these \fInon-standard\fR features or when reproducing them in your own \s-1SPF\s0
implementation, as they may cause unexpected results.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """Mail::SPF::Query\->new()"""
.el .SS "\f(CWMail::SPF::Query\->new()\fP"
.IX Subsection "Mail::SPF::Query->new()"
.Vb 4
\&    my $query = eval { new Mail::SPF::Query (
\&        ip          => \*(Aq127.0.0.1\*(Aq,
\&        sender      => \*(Aqfoo@example.com\*(Aq,
\&        helo        => \*(Aqhost.example.com\*(Aq,
\&
\&        # Optional parameters:
\&        debug       => 1, debuglog => sub { print STDERR "@_\en" },
\&        local       => \*(Aqextra mechanisms\*(Aq,
\&        trusted     => 1,                   # do trusted forwarder processing
\&        guess       => 1,                   # do best guess if no SPF record
\&        default_explanation => \*(AqPlease see http://spf.my.isp/spferror.html for details\*(Aq,
\&        max_lookup_count    => 10,          # total number of SPF includes/redirects
\&        sanitize    => 0,                   # do not sanitize all returned strings
\&        myhostname  => \*(Aqfoo.example.com\*(Aq,   # prepended to header_comment
\&        override    => {   \*(Aqexample.net\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq,
\&                         \*(Aq*.example.net\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq },
\&        fallback    => {   \*(Aqexample.org\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq,
\&                         \*(Aq*.example.org\*(Aq => \*(Aqv=spf1 a mx \-all\*(Aq }
\&    ) };
\&
\&    if ($@) { warn "bad input to Mail::SPF::Query: $@" }
.Ve
.PP
Set \f(CW\*(C`trusted=>1\*(C'\fR to turned on \f(CW\*(C`trusted\-forwarder.org\*(C'\fR accreditation
checking.  The mechanism \f(CW\*(C`include:spf.trusted\-forwarder.org\*(C'\fR is used just
before a \f(CW\*(C`\-all\*(C'\fR or \f(CW\*(C`?all\*(C'\fR.  The precise circumstances are somewhat more
complicated, but it does get the case of \f(CW\*(C`v=spf1 \-all\*(C'\fR right \*(-- i.e.
\&\f(CW\*(C`trusted\-forwarder.org\*(C'\fR is not checked.  \fBThis is a non-standard feature.\fR
.PP
Set \f(CW\*(C`guess=>1\*(C'\fR to turned on automatic best guess processing.  This will
use the best_guess \s-1SPF\s0 record when one cannot be found in the \s-1DNS. \s0 Note that
this can only return \f(CW\*(C`pass\*(C'\fR or \f(CW\*(C`neutral\*(C'\fR.  The \f(CW\*(C`trusted\*(C'\fR and \f(CW\*(C`local\*(C'\fR flags
also operate when the best_guess is being used.  \fBThis is a non-standard
feature.\fR
.PP
Set \f(CW\*(C`local=>\*(Aqinclude:local.domain\*(Aq\*(C'\fR to include some extra processing just
before a \f(CW\*(C`\-all\*(C'\fR or \f(CW\*(C`?all\*(C'\fR.  The local processing happens just before the
trusted forwarder processing.  \fBThis is a non-standard feature.\fR
.PP
Set \f(CW\*(C`default_explanation\*(C'\fR to a string to be used if the \s-1SPF\s0 record does not
provide a specific explanation. The default value will direct the user to a
page at www.openspf.org with the following message:
.PP
.Vb 1
\&    Please see http://www.openspf.org/why.html?sender=%{S}&ip=%{I}&receiver=%{R}
.Ve
.PP
Note that the string has macro substitution performed.
.PP
Set \f(CW\*(C`sanitize\*(C'\fR to 0 to get all the returned strings unsanitized.
Alternatively, pass a function reference and this function will be used to
sanitize the returned values.  The function must take a single string argument
and return a single string which contains the sanitized result.
.PP
Set \f(CW\*(C`debug=>1\*(C'\fR to watch the queries happen.
.PP
Set \f(CW\*(C`override\*(C'\fR to define \s-1SPF\s0 records for domains that do publish but which you
want to override anyway.  Wildcards are supported.  \fBThis is a non-standard
feature.\fR
.PP
Set \f(CW\*(C`fallback\*(C'\fR to define \*(L"pretend\*(R" \s-1SPF\s0 records for domains that don't publish
them yet.  Wildcards are supported.  \fBThis is a non-standard feature.\fR
.PP
Note: domain name arguments to override and fallback need to be in all
lowercase.
.ie n .SS """$query\->result()"""
.el .SS "\f(CW$query\->result()\fP"
.IX Subsection "$query->result()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment, $spf_record, $detail) = $query\->result();
.Ve
.PP
\&\f(CW$result\fR will be one of \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR, \f(CW\*(C`softfail\*(C'\fR, \f(CW\*(C`neutral\*(C'\fR, \f(CW\*(C`none\*(C'\fR,
\&\f(CW\*(C`error\*(C'\fR or \f(CW\*(C`unknown [...]\*(C'\fR:
.ie n .IP """pass""" 4
.el .IP "\f(CWpass\fR" 4
.IX Item "pass"
The client \s-1IP\s0 address is an authorized mailer for the sender.  The mail should
be accepted subject to local policy regarding the sender.
.ie n .IP """fail""" 4
.el .IP "\f(CWfail\fR" 4
.IX Item "fail"
The client \s-1IP\s0 address is not an authorized mailer, and the sender wants you to
reject the transaction for fear of forgery.
.ie n .IP """softfail""" 4
.el .IP "\f(CWsoftfail\fR" 4
.IX Item "softfail"
The client \s-1IP\s0 address is not an authorized mailer, but the sender prefers that
you accept the transaction because it isn't absolutely sure all its users are
mailing through approved servers.  The \f(CW\*(C`softfail\*(C'\fR status is often used during
initial deployment of \s-1SPF\s0 records by a domain.
.ie n .IP """neutral""" 4
.el .IP "\f(CWneutral\fR" 4
.IX Item "neutral"
The sender makes no assertion about the status of the client \s-1IP.\s0
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
There is no \s-1SPF\s0 record for this domain.
.ie n .IP """error""" 4
.el .IP "\f(CWerror\fR" 4
.IX Item "error"
The \s-1DNS\s0 lookup encountered a temporary error during processing.
.ie n .IP """unknown [...]""" 4
.el .IP "\f(CWunknown [...]\fR" 4
.IX Item "unknown [...]"
The domain has a configuration error in the published data or defines a
mechanism that this library does not understand.  If the data contained an
unrecognized mechanism, it will be presented following \*(L"unknown\*(R".  You should
test for unknown using a regexp \f(CW\*(C`/^unknown/\*(C'\fR rather than \f(CW\*(C`eq "unknown"\*(C'\fR.
.PP
Results are cached internally for a default of 120 seconds.  You can call
\&\f(CW\*(C`\->result()\*(C'\fR repeatedly; subsequent lookups won't hit your \s-1DNS.\s0
.PP
\&\f(CW\*(C`smtp_comment\*(C'\fR should be displayed to the \s-1SMTP\s0 client.
.PP
\&\f(CW\*(C`header_comment\*(C'\fR goes into a \f(CW\*(C`Received\-SPF\*(C'\fR header, like so:
.PP
.Vb 1
\&    Received\-SPF: $result ($header_comment)
.Ve
.PP
\&\f(CW\*(C`spf_record\*(C'\fR shows the original \s-1SPF\s0 record fetched for the query.  If there is
no \s-1SPF\s0 record, it is blank.  Otherwise, it will start with \f(CW\*(C`v=spf1\*(C'\fR and
contain the \s-1SPF\s0 mechanisms and such that describe the domain.
.PP
Note that the strings returned by this method (and most of the other methods)
are (at least partially) under the control of the sender's domain.  This means
that, if the sender is an attacker, the contents can be assumed to be hostile.
The various methods that return these strings make sure that (by default) the
strings returned contain only characters in the range 32 \- 126.  This behavior
can be changed by setting \f(CW\*(C`sanitize\*(C'\fR to 0 to turn off sanitization entirely.
You can also set \f(CW\*(C`sanitize\*(C'\fR to a function reference to perform custom
sanitization.  In particular, assume that \f(CW\*(C`smtp_comment\*(C'\fR might contain a
newline character.
.PP
\&\f(CW\*(C`detail\*(C'\fR is a hash of all the foregoing result elements, plus extra data
returned by the \s-1SPF\s0 result.
.PP
\&\fIWhy the weird duplication?\fR  In the beginning, \f(CW\*(C`result()\*(C'\fR returned only one
value, the \f(CW$result\fR.  Then \f(CW$smtp_comment\fR and \f(CW$header_comment\fR came
along.  Then \f(CW$spf_record\fR.  Past a certain number of positional results, it
makes more sense to have a hash.  But we didn't want to break backwards
compatibility, so we just declared that the fifth result would be a hash and
future return value would go in there.
.PP
The keys of the hash are:
.PP
.Vb 6
\&    result
\&    smtp_comment
\&    header_comment
\&    header_pairs
\&    spf_record
\&    modifiers
.Ve
.ie n .SS """$query\->result2()"""
.el .SS "\f(CW$query\->result2()\fP"
.IX Subsection "$query->result2()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment, $spf_record) = $query\->result2(\*(Aqrecipient@domain\*(Aq, \*(Aqrecipient2@domain\*(Aq);
.Ve
.PP
\&\f(CW\*(C`result2()\*(C'\fR does everything that \f(CW\*(C`result()\*(C'\fR does, but it first checks to see if
the sending system is a recognized \s-1MX\s0 secondary for the recipient(s).  If so,
then it returns \f(CW\*(C`pass\*(C'\fR and does not perform the \s-1SPF\s0 query.  Note that the
sending system may be a \s-1MX\s0 secondary for some (but not all) of the recipients
for a multi-recipient message, which is why result2 takes an argument list.
See also \f(CW\*(C`message_result2()\*(C'\fR.
.PP
\&\fBThis is a non-standard feature.\fR  \fBThis feature is also deprecated, because
exemption of trusted relays, such as secondary MXes, should really be performed
by the software that uses this library before doing an \s-1SPF\s0 check.\fR
.PP
\&\f(CW$result\fR will be one of \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR, \f(CW\*(C`neutral [...]\*(C'\fR, or \f(CW\*(C`unknown\*(C'\fR.
See \f(CW\*(C`result()\*(C'\fR above for meanings.
.PP
If you have secondary MXes and if you are unable to explicitly white-list them
before \s-1SPF\s0 tests occur, you can use this method in place of \f(CW\*(C`result()\*(C'\fR,
calling it as many times as there are recipients, or just providing all the
recipients at one time.
.PP
\&\f(CW\*(C`smtp_comment\*(C'\fR can be displayed to the \s-1SMTP\s0 client.
.PP
For example:
.PP
.Vb 3
\&    my $query = new Mail::SPF::Query (ip => "127.0.0.1",
\&                                      sender=>\*(Aqfoo@example.com\*(Aq,
\&                                      helo=>"somehost.example.com");
\&
\&    ...
\&
\&    my ($result, $smtp_comment, $header_comment);
\&
\&    ($result, $smtp_comment, $header_comment) = $query\->result2(\*(Aqrecip1@example.com\*(Aq);
\&    # return suitable error code based on $result eq \*(Aqfail\*(Aq or not
\&
\&    ($result, $smtp_comment, $header_comment) = $query\->result2(\*(Aqrecip2@example.org\*(Aq);
\&    # return suitable error code based on $result eq \*(Aqfail\*(Aq or not
\&
\&    ($result, $smtp_comment, $header_comment) = $query\->message_result2();
\&    # return suitable error if $result eq \*(Aqfail\*(Aq
\&    # prefix message with "Received\-SPF: $result ($header_comment)"
.Ve
.ie n .SS """$query\->message_result2()"""
.el .SS "\f(CW$query\->message_result2()\fP"
.IX Subsection "$query->message_result2()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment, $spf_record) = $query\->message_result2();
.Ve
.PP
\&\f(CW\*(C`message_result2()\*(C'\fR returns an overall status for the message after zero or
more calls to \f(CW\*(C`result2()\*(C'\fR.  It will always be the last status returned by
\&\f(CW\*(C`result2()\*(C'\fR, or the status returned by \f(CW\*(C`result()\*(C'\fR if \f(CW\*(C`result2()\*(C'\fR was never
called.
.PP
\&\f(CW$result\fR will be one of \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR, \f(CW\*(C`neutral [...]\*(C'\fR, or \f(CW\*(C`error\*(C'\fR.  See
\&\f(CW\*(C`result()\*(C'\fR above for meanings.
.ie n .SS """$query\->best_guess()"""
.el .SS "\f(CW$query\->best_guess()\fP"
.IX Subsection "$query->best_guess()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment) = $query\->best_guess();
.Ve
.PP
When a domain does not publish an \s-1SPF\s0 record, this library can produce an
educated guess anyway.
.PP
It pretends the domain defined A, \s-1MX,\s0 and \s-1PTR\s0 mechanisms, plus a few others.
The default set of directives is
.PP
.Vb 1
\&    a/24 mx/24 ptr
.Ve
.PP
That default set will return either \*(L"pass\*(R" or \*(L"neutral\*(R".
.PP
If you want to experiment with a different default, you can pass it as an
argument: \f(CW\*(C`$query\->best_guess("a mx ptr")\*(C'\fR
.PP
\&\fBThis is a non-standard feature.\fR  \fBThis method is also deprecated.\fR  You
should set \f(CW\*(C`guess=>1\*(C'\fR on the \f(CW\*(C`new()\*(C'\fR method instead.
.ie n .SS """$query\->trusted_forwarder()"""
.el .SS "\f(CW$query\->trusted_forwarder()\fP"
.IX Subsection "$query->trusted_forwarder()"
.Vb 1
\&    my ($result, $smtp_comment, $header_comment) = $query\->best_guess();
.Ve
.PP
It is possible that the message is coming through a known-good relay like
\&\f(CW\*(C`acm.org\*(C'\fR or \f(CW\*(C`pobox.com\*(C'\fR.  During the transitional period, many legitimate
services may appear to forge a sender address: for example, a news website may
have a \*(L"send me this article in email\*(R" link.
.PP
The \f(CW\*(C`trusted\-forwarder.org\*(C'\fR domain is a white-list of known-good hosts that
either forward mail or perform benign envelope sender forgery:
.PP
.Vb 1
\&    include:spf.trusted\-forwarder.org
.Ve
.PP
This will return either \*(L"pass\*(R" or \*(L"neutral\*(R".
.PP
\&\fBThis is a non-standard feature.\fR  \fBThis method is also deprecated.\fR  You
should set \f(CW\*(C`trusted=>1\*(C'\fR on the \f(CW\*(C`new()\*(C'\fR method instead.
.ie n .SS """$query\->sanitize(\*(Aqstring\*(Aq)"""
.el .SS "\f(CW$query\->sanitize(\*(Aqstring\*(Aq)\fP"
.IX Subsection "$query->sanitize(string)"
This applies the sanitization rules for the particular query object. These
rules are controlled by the \f(CW\*(C`sanitize\*(C'\fR parameter to the c<\fInew()\fR> method.
.ie n .SS """strict_sanitize(\*(Aqstring\*(Aq)"""
.el .SS "\f(CWstrict_sanitize(\*(Aqstring\*(Aq)\fP"
.IX Subsection "strict_sanitize(string)"
This ensures that all the characters in the returned string are printable.  All
whitespace is converted into spaces, and all other non-printable characters are
converted into question marks.  This is probably over-aggressive for many
applications.
.PP
This function is used by default when the \f(CW\*(C`sanitize\*(C'\fR option is passed to the
\&\f(CW\*(C`new()\*(C'\fR method.
.PP
\&\fBThis function is not a class method.\fR
.ie n .SS """$query\->debuglog()"""
.el .SS "\f(CW$query\->debuglog()\fP"
.IX Subsection "$query->debuglog()"
Subclasses may override this with their own debug logger.  \f(CW\*(C`Log::Dispatch\*(C'\fR is
recommended.
.PP
Alternatively, pass the \f(CW\*(C`new()\*(C'\fR constructor a \f(CW\*(C`debuglog => sub { ... }\*(C'\fR
callback, and we'll pass debugging lines to that.
.SH "WARNINGS"
.IX Header "WARNINGS"
Mail::Query::SPF should only be used at the point where messages are received
from the Internet.  The underlying assumption is that the sender of the e\-mail
is sending the message directly to you or one of your secondary MXes.  If your
\&\s-1MTA\s0 does not have an exhaustive list of secondary MXes, then the \f(CW\*(C`result2()\*(C'\fR
and \f(CW\*(C`message_result2()\*(C'\fR methods can be used.  These methods take care to
permit mail from secondary MXes.
.SH "AUTHORS"
.IX Header "AUTHORS"
Meng Weng Wong <mengwong+spf@pobox.com>, Philip Gladstone, Julian Mehnle
<julian@mehnle.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
About \s-1SPF: \s0<http://www.openspf.org>
.PP
Mail::SPF::Query: <http://search.cpan.org/dist/Mail\-SPF\-Query>
.PP
The latest release of the \s-1SPF\s0 specification: <http://www.openspf.org/spf\-classic\-current.txt>
                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Record.3pm                        0100644 0001750 0001750 00000026061 12566242051 024243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Record 3"
.TH Mail::SPF::Record 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Record \- Abstract base class for SPF records
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Creating a record from a string"
.IX Subsection "Creating a record from a string"
.Vb 1
\&    use Mail::SPF::v1::Record;
\&
\&    my $record = Mail::SPF::v1::Record\->new_from_string("v=spf1 a mx \-all");
.Ve
.SS "Creating a record synthetically"
.IX Subsection "Creating a record synthetically"
.Vb 1
\&    use Mail::SPF::v2::Record;
\&
\&    my $record = Mail::SPF::v2::Record\->new(
\&        scopes      => [\*(Aqmfrom\*(Aq, \*(Aqpra\*(Aq],
\&        terms       => [
\&            Mail::SPF::Mech::A\->new(),
\&            Mail::SPF::Mech::MX\->new(),
\&            Mail::SPF::Mech::All\->new(qualifier => \*(Aq\-\*(Aq)
\&        ],
\&        global_mods => [
\&            Mail::SPF::Mod::Exp\->new(domain_spec => \*(Aqspf\-exp.example.com\*(Aq)
\&        ]
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Record\fR is an abstract base class for \s-1SPF\s0 records.  It cannot be
instantiated directly.  Create an instance of a concrete sub-class instead.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Record\fR" 4
.IX Item "new(%options): returns Mail::SPF::Record"
Creates a new \s-1SPF\s0 record object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
A \fIstring\fR denoting the unparsed text of the record.
.IP "\fBscopes\fR" 4
.IX Item "scopes"
A reference to an \fIarray\fR of \fIstring\fRs denoting the scopes that are covered
by the record (see the description of the \f(CW\*(C`scope\*(C'\fR option of
Mail::SPF::Request's \f(CW\*(C`new\*(C'\fR constructor).
.IP "\fBterms\fR" 4
.IX Item "terms"
A reference to an \fIarray\fR of \fIMail::SPF::Term\fR (i.e. \fIMail::SPF::Mech\fR or
\&\fIMail::SPF::Mod\fR) objects that make up the record.  \fIMail::SPF::GlobalMod\fR
objects must not be included here, but should be specified using the
\&\f(CW\*(C`global_mods\*(C'\fR option instead.
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
A reference to an \fIarray\fR of \fIMail::SPF::GlobalMod\fR objects that are global
modifiers of the record.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Record; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidRecordVersion, Mail::SPF::ESyntaxError"
Creates a new \s-1SPF\s0 record object by parsing the string and any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBversion_tag_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "version_tag_pattern: returns Regexp"
\&\fIAbstract\fR.  Returns a regular expression that matches a legal version tag.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Record.
.IP "\fBdefault_qualifier\fR: returns \fIstring\fR" 4
.IX Item "default_qualifier: returns string"
Returns the default qualifier, i.e. \fB'+'\fR.
.IP "\fBresults_by_qualifier\fR: returns \fIhash\fR of \fIstring\fR" 4
.IX Item "results_by_qualifier: returns hash of string"
Returns a reference to a hash that maps qualifiers to result codes as follows:
.Sp
.Vb 6
\&     Qualifier | Result code
\&    \-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-
\&         +     | pass
\&         \-     | fail
\&         ~     | softfail
\&         ?     | neutral
.Ve
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the record.  Throws a \fIMail::SPF::ENoUnparsedText\fR
exception if the record was created synthetically instead of being parsed, and
no text was provided.
.IP "\fBversion_tag\fR: returns \fIstring\fR" 4
.IX Item "version_tag: returns string"
\&\fIAbstract\fR.  Returns the version tag of the record.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Record.
.IP "\fBscopes\fR: returns \fIlist\fR of \fIstring\fR" 4
.IX Item "scopes: returns list of string"
Returns a list of the scopes that are covered by the record.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`scopes\*(C'\fR option.
.IP "\fBterms\fR: returns \fIlist\fR of \fIMail::SPF::Term\fR" 4
.IX Item "terms: returns list of Mail::SPF::Term"
Returns a list of the terms that make up the record, excluding any global
modifiers, which are returned by the \f(CW\*(C`global_mods\*(C'\fR method.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`terms\*(C'\fR option.
.IP "\fBglobal_mods\fR: returns \fIlist\fR of \fIMail::SPF::GlobalMod\fR" 4
.IX Item "global_mods: returns list of Mail::SPF::GlobalMod"
Returns a list of the global modifiers of the record, ordered ascending by
modifier precedence.  See the description of the \*(L"new\*(R" constructor's
\&\f(CW\*(C`global_mods\*(C'\fR option.
.IP "\fBglobal_mod($mod_name)\fR: returns \fIMail::SPF::GlobalMod\fR" 4
.IX Item "global_mod($mod_name): returns Mail::SPF::GlobalMod"
Returns the global modifier of the given name if it is present in the record.
Returns \fBundef\fR otherwise.  Use this method if you wish to retrieve a specific
global modifier as opposed to getting all of them.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Returns the record's version tag and terms (including the global modifiers)
formatted as a string.  You can simply use a Mail::SPF::Record object as a
string for the same effect, see \*(L"\s-1OVERLOADING\*(R"\s0.
.ie n .IP "\fBeval($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBeval($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "eval($server, $request): throws Mail::SPF::Result"
Evaluates the \s-1SPF\s0 record in the context of the request parameters represented
by the given \fIMail::SPF::Request\fR object.  The given \fIMail::SPF::Server\fR
object is used for performing \s-1DNS\s0 look-ups.  Throws a \fIMail::SPF::Result\fR
object matching the outcome of the evaluation; see Mail::SPF::Result.  See
\&\s-1RFC 4408, 4.6\s0 and 4.7, for the exact algorithm used.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Record object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR method
is used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::v1::Record, Mail::SPF::v2::Record,
Mail::SPF::Term, Mail::SPF::Mech, Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Record5.16.3pm                    0100644 0001750 0001750 00000025540 12566242063 024561  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Record 3"
.TH Mail::SPF::Record 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Record \- Abstract base class for SPF records
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Creating a record from a string"
.IX Subsection "Creating a record from a string"
.Vb 1
\&    use Mail::SPF::v1::Record;
\&
\&    my $record = Mail::SPF::v1::Record\->new_from_string("v=spf1 a mx \-all");
.Ve
.SS "Creating a record synthetically"
.IX Subsection "Creating a record synthetically"
.Vb 1
\&    use Mail::SPF::v2::Record;
\&
\&    my $record = Mail::SPF::v2::Record\->new(
\&        scopes      => [\*(Aqmfrom\*(Aq, \*(Aqpra\*(Aq],
\&        terms       => [
\&            Mail::SPF::Mech::A\->new(),
\&            Mail::SPF::Mech::MX\->new(),
\&            Mail::SPF::Mech::All\->new(qualifier => \*(Aq\-\*(Aq)
\&        ],
\&        global_mods => [
\&            Mail::SPF::Mod::Exp\->new(domain_spec => \*(Aqspf\-exp.example.com\*(Aq)
\&        ]
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Record\fR is an abstract base class for \s-1SPF\s0 records.  It cannot be
instantiated directly.  Create an instance of a concrete sub-class instead.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Record\fR" 4
.IX Item "new(%options): returns Mail::SPF::Record"
Creates a new \s-1SPF\s0 record object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
A \fIstring\fR denoting the unparsed text of the record.
.IP "\fBscopes\fR" 4
.IX Item "scopes"
A reference to an \fIarray\fR of \fIstring\fRs denoting the scopes that are covered
by the record (see the description of the \f(CW\*(C`scope\*(C'\fR option of
Mail::SPF::Request's \f(CW\*(C`new\*(C'\fR constructor).
.IP "\fBterms\fR" 4
.IX Item "terms"
A reference to an \fIarray\fR of \fIMail::SPF::Term\fR (i.e. \fIMail::SPF::Mech\fR or
\&\fIMail::SPF::Mod\fR) objects that make up the record.  \fIMail::SPF::GlobalMod\fR
objects must not be included here, but should be specified using the
\&\f(CW\*(C`global_mods\*(C'\fR option instead.
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
A reference to an \fIarray\fR of \fIMail::SPF::GlobalMod\fR objects that are global
modifiers of the record.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Record; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidRecordVersion, Mail::SPF::ESyntaxError"
Creates a new \s-1SPF\s0 record object by parsing the string and any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBversion_tag_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "version_tag_pattern: returns Regexp"
\&\fIAbstract\fR.  Returns a regular expression that matches a legal version tag.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Record.
.IP "\fBdefault_qualifier\fR: returns \fIstring\fR" 4
.IX Item "default_qualifier: returns string"
Returns the default qualifier, i.e. \fB'+'\fR.
.IP "\fBresults_by_qualifier\fR: returns \fIhash\fR of \fIstring\fR" 4
.IX Item "results_by_qualifier: returns hash of string"
Returns a reference to a hash that maps qualifiers to result codes as follows:
.Sp
.Vb 6
\&     Qualifier | Result code
\&    \-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-
\&         +     | pass
\&         \-     | fail
\&         ~     | softfail
\&         ?     | neutral
.Ve
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the record.  Throws a \fIMail::SPF::ENoUnparsedText\fR
exception if the record was created synthetically instead of being parsed, and
no text was provided.
.IP "\fBversion_tag\fR: returns \fIstring\fR" 4
.IX Item "version_tag: returns string"
\&\fIAbstract\fR.  Returns the version tag of the record.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Record.
.IP "\fBscopes\fR: returns \fIlist\fR of \fIstring\fR" 4
.IX Item "scopes: returns list of string"
Returns a list of the scopes that are covered by the record.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`scopes\*(C'\fR option.
.IP "\fBterms\fR: returns \fIlist\fR of \fIMail::SPF::Term\fR" 4
.IX Item "terms: returns list of Mail::SPF::Term"
Returns a list of the terms that make up the record, excluding any global
modifiers, which are returned by the \f(CW\*(C`global_mods\*(C'\fR method.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`terms\*(C'\fR option.
.IP "\fBglobal_mods\fR: returns \fIlist\fR of \fIMail::SPF::GlobalMod\fR" 4
.IX Item "global_mods: returns list of Mail::SPF::GlobalMod"
Returns a list of the global modifiers of the record, ordered ascending by
modifier precedence.  See the description of the \*(L"new\*(R" constructor's
\&\f(CW\*(C`global_mods\*(C'\fR option.
.IP "\fBglobal_mod($mod_name)\fR: returns \fIMail::SPF::GlobalMod\fR" 4
.IX Item "global_mod($mod_name): returns Mail::SPF::GlobalMod"
Returns the global modifier of the given name if it is present in the record.
Returns \fBundef\fR otherwise.  Use this method if you wish to retrieve a specific
global modifier as opposed to getting all of them.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Returns the record's version tag and terms (including the global modifiers)
formatted as a string.  You can simply use a Mail::SPF::Record object as a
string for the same effect, see \*(L"\s-1OVERLOADING\s0\*(R".
.ie n .IP "\fBeval($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBeval($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "eval($server, $request): throws Mail::SPF::Result"
Evaluates the \s-1SPF\s0 record in the context of the request parameters represented
by the given \fIMail::SPF::Request\fR object.  The given \fIMail::SPF::Server\fR
object is used for performing \s-1DNS\s0 look-ups.  Throws a \fIMail::SPF::Result\fR
object matching the outcome of the evaluation; see Mail::SPF::Result.  See
\&\s-1RFC\s0 4408, 4.6 and 4.7, for the exact algorithm used.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Record object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR method
is used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::v1::Record, Mail::SPF::v2::Record,
Mail::SPF::Term, Mail::SPF::Mech, Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Record5.18.3pm                    0100644 0001750 0001750 00000026061 12566242051 024557  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Record 3"
.TH Mail::SPF::Record 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Record \- Abstract base class for SPF records
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Creating a record from a string"
.IX Subsection "Creating a record from a string"
.Vb 1
\&    use Mail::SPF::v1::Record;
\&
\&    my $record = Mail::SPF::v1::Record\->new_from_string("v=spf1 a mx \-all");
.Ve
.SS "Creating a record synthetically"
.IX Subsection "Creating a record synthetically"
.Vb 1
\&    use Mail::SPF::v2::Record;
\&
\&    my $record = Mail::SPF::v2::Record\->new(
\&        scopes      => [\*(Aqmfrom\*(Aq, \*(Aqpra\*(Aq],
\&        terms       => [
\&            Mail::SPF::Mech::A\->new(),
\&            Mail::SPF::Mech::MX\->new(),
\&            Mail::SPF::Mech::All\->new(qualifier => \*(Aq\-\*(Aq)
\&        ],
\&        global_mods => [
\&            Mail::SPF::Mod::Exp\->new(domain_spec => \*(Aqspf\-exp.example.com\*(Aq)
\&        ]
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Record\fR is an abstract base class for \s-1SPF\s0 records.  It cannot be
instantiated directly.  Create an instance of a concrete sub-class instead.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Record\fR" 4
.IX Item "new(%options): returns Mail::SPF::Record"
Creates a new \s-1SPF\s0 record object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
A \fIstring\fR denoting the unparsed text of the record.
.IP "\fBscopes\fR" 4
.IX Item "scopes"
A reference to an \fIarray\fR of \fIstring\fRs denoting the scopes that are covered
by the record (see the description of the \f(CW\*(C`scope\*(C'\fR option of
Mail::SPF::Request's \f(CW\*(C`new\*(C'\fR constructor).
.IP "\fBterms\fR" 4
.IX Item "terms"
A reference to an \fIarray\fR of \fIMail::SPF::Term\fR (i.e. \fIMail::SPF::Mech\fR or
\&\fIMail::SPF::Mod\fR) objects that make up the record.  \fIMail::SPF::GlobalMod\fR
objects must not be included here, but should be specified using the
\&\f(CW\*(C`global_mods\*(C'\fR option instead.
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
A reference to an \fIarray\fR of \fIMail::SPF::GlobalMod\fR objects that are global
modifiers of the record.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Record; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidRecordVersion, Mail::SPF::ESyntaxError"
Creates a new \s-1SPF\s0 record object by parsing the string and any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBversion_tag_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "version_tag_pattern: returns Regexp"
\&\fIAbstract\fR.  Returns a regular expression that matches a legal version tag.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Record.
.IP "\fBdefault_qualifier\fR: returns \fIstring\fR" 4
.IX Item "default_qualifier: returns string"
Returns the default qualifier, i.e. \fB'+'\fR.
.IP "\fBresults_by_qualifier\fR: returns \fIhash\fR of \fIstring\fR" 4
.IX Item "results_by_qualifier: returns hash of string"
Returns a reference to a hash that maps qualifiers to result codes as follows:
.Sp
.Vb 6
\&     Qualifier | Result code
\&    \-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-
\&         +     | pass
\&         \-     | fail
\&         ~     | softfail
\&         ?     | neutral
.Ve
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the record.  Throws a \fIMail::SPF::ENoUnparsedText\fR
exception if the record was created synthetically instead of being parsed, and
no text was provided.
.IP "\fBversion_tag\fR: returns \fIstring\fR" 4
.IX Item "version_tag: returns string"
\&\fIAbstract\fR.  Returns the version tag of the record.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Record.
.IP "\fBscopes\fR: returns \fIlist\fR of \fIstring\fR" 4
.IX Item "scopes: returns list of string"
Returns a list of the scopes that are covered by the record.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`scopes\*(C'\fR option.
.IP "\fBterms\fR: returns \fIlist\fR of \fIMail::SPF::Term\fR" 4
.IX Item "terms: returns list of Mail::SPF::Term"
Returns a list of the terms that make up the record, excluding any global
modifiers, which are returned by the \f(CW\*(C`global_mods\*(C'\fR method.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`terms\*(C'\fR option.
.IP "\fBglobal_mods\fR: returns \fIlist\fR of \fIMail::SPF::GlobalMod\fR" 4
.IX Item "global_mods: returns list of Mail::SPF::GlobalMod"
Returns a list of the global modifiers of the record, ordered ascending by
modifier precedence.  See the description of the \*(L"new\*(R" constructor's
\&\f(CW\*(C`global_mods\*(C'\fR option.
.IP "\fBglobal_mod($mod_name)\fR: returns \fIMail::SPF::GlobalMod\fR" 4
.IX Item "global_mod($mod_name): returns Mail::SPF::GlobalMod"
Returns the global modifier of the given name if it is present in the record.
Returns \fBundef\fR otherwise.  Use this method if you wish to retrieve a specific
global modifier as opposed to getting all of them.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Returns the record's version tag and terms (including the global modifiers)
formatted as a string.  You can simply use a Mail::SPF::Record object as a
string for the same effect, see \*(L"\s-1OVERLOADING\*(R"\s0.
.ie n .IP "\fBeval($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBeval($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "eval($server, $request): throws Mail::SPF::Result"
Evaluates the \s-1SPF\s0 record in the context of the request parameters represented
by the given \fIMail::SPF::Request\fR object.  The given \fIMail::SPF::Server\fR
object is used for performing \s-1DNS\s0 look-ups.  Throws a \fIMail::SPF::Result\fR
object matching the outcome of the evaluation; see Mail::SPF::Result.  See
\&\s-1RFC 4408, 4.6\s0 and 4.7, for the exact algorithm used.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Record object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR method
is used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::v1::Record, Mail::SPF::v2::Record,
Mail::SPF::Term, Mail::SPF::Mech, Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Request.3pm                       0100644 0001750 0001750 00000035226 12566242051 024460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Request 3"
.TH Mail::SPF::Request 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Request \- SPF request class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF;
\&
\&    my $request = Mail::SPF::Request\->new(
\&        versions    => [1, 2],              # optional
\&        scope       => \*(Aqmfrom\*(Aq,             # or \*(Aqhelo\*(Aq, \*(Aqpra\*(Aq
\&        identity    => \*(Aqfred@example.com\*(Aq,
\&        ip_address  => \*(Aq192.168.0.1\*(Aq,
\&        helo_identity                       # optional,
\&                    => \*(Aqmta.example.com\*(Aq    #   for %{h} macro expansion
\&    );
\&
\&    my @versions    = $request\->versions;
\&    my $scope       = $request\->scope;
\&    my $authority_domain
\&                    = $request\->authority_domain;
\&    my $identity    = $request\->identity;   # \*(Aqlocalpart@domain\*(Aq or \*(Aqdomain\*(Aq
\&    my $domain      = $request\->domain;
\&    my $localpart   = $request\->localpart;
\&    my $ip_address  = $request\->ip_address;     # IPv4 or IPv6 address
\&    my $ip_address_v6                           # native IPv6 address or
\&                    = $request\->ip_address_v6;  #   IPv4\-mapped IPv6 address
\&    my $helo_identity                           # additional HELO identity
\&                    = $request\->helo_identity;  #   for non\-HELO scopes
\&
\&    my $record      = $request\->record;
\&        # the record selected during processing of the request, may be undef
\&
\&    $request\->state(field => \*(Aqvalue\*(Aq);
\&    my $value = $request\->state(\*(Aqfield\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Request\fR represents an \s-1SPF\s0 request.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "new(%options): returns Mail::SPF::Request"
Creates a new \s-1SPF\s0 request object.  The request is considered the
\&\fIroot-request\fR for any subsequent sub-requests (see the \*(L"new_sub_request\*(R"
constructor).
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBversions\fR" 4
.IX Item "versions"
A reference to an \fIarray\fR of \fIinteger\fRs listing the versions of \s-1SPF\s0 records
that may be used for the \s-1SPF\s0 check.  Only those record versions that cover the
desired scope will actually be used.  At least one applicable version must be
specified.  For a single record version, a simple scalar may be specified
instead of an array-ref.  Defaults to all versions that cover the desired scope
(see below); defaults to \fB[1, 2]\fR for the default scope of \fB'mfrom'\fR.
.Sp
The following versions are supported:
.RS 4
.IP "\fB1\fR" 4
.IX Item "1"
Use \f(CW\*(C`v=spf1\*(C'\fR records.
.IP "\fB2\fR" 4
.IX Item "2"
Use \f(CW\*(C`spf2.0\*(C'\fR records.
.RE
.RS 4
.Sp
\&\fIExample\fR:  A value of \fB1\fR (or \fB[1]\fR) means that only \f(CW\*(C`v=spf1\*(C'\fR records
should be used for the \s-1SPF\s0 check.  If at the same time a scope of \fB'pra'\fR is
specified, a \fIMail::SPF::EInvalidScope\fR exception will be thrown as \f(CW\*(C`v=spf1\*(C'\fR
records do not cover the \s-1PRA\s0 scope.
.RE
.IP "\fBscope\fR" 4
.IX Item "scope"
A string denoting the authorization scope of the identity that should be
checked.  Defaults to \fB'mfrom'\fR.  The following scope values are supported:
.RS 4
.IP "\fB'helo'\fR" 4
.IX Item "'helo'"
The given identity is the \f(CW\*(C`HELO\*(C'\fR parameter of an \s-1SMTP\s0 transaction (\s-1RFC 2821\s0)
and should be checked against \s-1SPF\s0 records that cover the \f(CW\*(C`helo\*(C'\fR scope
(\f(CW\*(C`v=spf1\*(C'\fR).  See the SPFv1 specification (\s-1RFC 4408\s0) for the formal definition
of the \f(CW\*(C`HELO\*(C'\fR scope.
.IP "\fB'mfrom'\fR" 4
.IX Item "'mfrom'"
The given identity is the \f(CW\*(C`MAIL FROM\*(C'\fR parameter of an \s-1SMTP\s0 transaction (\s-1RFC
2821\s0), and should be checked against \s-1SPF\s0 records that cover the \f(CW\*(C`mfrom\*(C'\fR scope
(\f(CW\*(C`v=spf1\*(C'\fR and \f(CW\*(C`spf2.0/mfrom\*(C'\fR).  See the SPFv1 specification (\s-1RFC 4408\s0) for
the formal definition of the \f(CW\*(C`MAIL FROM\*(C'\fR scope.
.Sp
\&\fINote\fR:  In the case of an empty \f(CW\*(C`MAIL FROM\*(C'\fR \s-1SMTP\s0 transaction parameter (\f(CW\*(C`MAIL FROM:<>\*(C'\fR), you should perform a check with the \f(CW\*(C`helo\*(C'\fR scope instead.
.IP "\fB'pra'\fR" 4
.IX Item "'pra'"
The given identity is the \*(L"Purported Responsible Address\*(R" of an internet
message (\s-1RFC 2822\s0) and should be checked against \s-1SPF\s0 records that cover the
\&\f(CW\*(C`pra\*(C'\fR scope (\f(CW\*(C`spf2.0/pra\*(C'\fR).  See the \s-1PRA\s0 specification (\s-1RFC 4407\s0) for the
formal definition of the \s-1PRA\s0 scope.
.RE
.RS 4
.RE
.IP "\fBauthority_domain\fR" 4
.IX Item "authority_domain"
A string denoting the domain name that should be queried for sender policy
records.  Defaults to the domain of the \f(CW\*(C`identity\*(C'\fR option.  There is usually
no need to specify the \f(CW\*(C`authority_domain\*(C'\fR option.
.IP "\fBidentity\fR" 4
.IX Item "identity"
\&\fIRequired\fR.  A string denoting the sender identity whose authorization should
be checked.  This is a domain name for the \f(CW\*(C`helo\*(C'\fR scope, and an e\-mail address
for the \f(CW\*(C`mfrom\*(C'\fR and \f(CW\*(C`pra\*(C'\fR scopes.
.Sp
\&\fINote\fR:  An empty identity must not be passed.  In the case of an empty \f(CW\*(C`MAIL
FROM\*(C'\fR \s-1SMTP\s0 transaction parameter, you should perform a check with the \f(CW\*(C`helo\*(C'\fR
scope instead.
.IP "\fBip_address\fR" 4
.IX Item "ip_address"
\&\fIRequired\fR for checks with the \f(CW\*(C`helo\*(C'\fR, \f(CW\*(C`mfrom\*(C'\fR, and \f(CW\*(C`pra\*(C'\fR scopes.  Either a
string or a \fINetAddr::IP\fR object denoting the \s-1IP\s0 address of the host claiming
the identity that is being checked.  Can be either an IPv4 or an IPv6 address.
An IPv4\-mapped IPv6 address (e.g. '::ffff:192.168.0.1') is treated as an IPv4
address.
.IP "\fBhelo_identity\fR" 4
.IX Item "helo_identity"
A string denoting the \f(CW\*(C`HELO\*(C'\fR \s-1SMTP\s0 transaction parameter in the case that the
main identity is of a scope other than \f(CW\*(C`helo\*(C'\fR.  This identity is then used
merely for the expansion of \f(CW\*(C`%{h}\*(C'\fR macros during the policy evaluation of the
main identity.  Defaults to \fBundef\fR, which will be expanded to \fB'unknown'\fR.
If the main identity is of the \f(CW\*(C`helo\*(C'\fR scope, this option is unused.
.RE
.RS 4
.RE
.IP "\fBnew_sub_request(%options)\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "new_sub_request(%options): returns Mail::SPF::Request"
Must be invoked on an existing request object.  Creates a new sub-request
object by cloning the invoked request, which is then considered the new
request's \fIsuper-request\fR.  Any specified options (see the \*(L"new\*(R"
constructor) override the parameters of the super-request.  There is usually no
need to specify any options \fIbesides\fR the \f(CW\*(C`authority_domain\*(C'\fR option.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBroot_request\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "root_request: returns Mail::SPF::Request"
Returns the root of the request's chain of super-requests.  Specifically,
returns the request itself if it has no super-requests.
.IP "\fBsuper_request\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "super_request: returns Mail::SPF::Request"
Returns the super-request of the request, or \fBundef\fR if there is none.
.IP "\fBversions\fR: returns \fIlist\fR of \fIstring\fR" 4
.IX Item "versions: returns list of string"
Returns a list of the \s-1SPF\s0 record versions that are used for request.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`versions\*(C'\fR option.
.IP "\fBscope\fR: returns \fIstring\fR" 4
.IX Item "scope: returns string"
Returns the scope of the request.  See the description of the \*(L"new\*(R"
constructor's \f(CW\*(C`scope\*(C'\fR option.
.IP "\fBauthority_domain\fR: returns \fIstring\fR" 4
.IX Item "authority_domain: returns string"
Returns the authority domain of the request.  See the description of the
\&\*(L"new\*(R" constructor's \f(CW\*(C`authority_domain\*(C'\fR option.
.IP "\fBidentity\fR: returns \fIstring\fR" 4
.IX Item "identity: returns string"
Returns the identity of the request.  See the description of the \*(L"new\*(R"
constructor's \f(CW\*(C`identity\*(C'\fR option.
.IP "\fBdomain\fR: returns \fIstring\fR" 4
.IX Item "domain: returns string"
Returns the identity domain of the request.  See the description of the
\&\*(L"new\*(R" constructor's \f(CW\*(C`identity\*(C'\fR option.
.IP "\fBlocalpart\fR: returns \fIstring\fR" 4
.IX Item "localpart: returns string"
Returns the identity localpart of the request.  See the description of the
\&\*(L"new\*(R" constructor's \f(CW\*(C`identity\*(C'\fR option.
.IP "\fBip_address\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_address: returns NetAddr::IP"
Returns the \s-1IP\s0 address of the request as a \fINetAddr::IP\fR object.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`ip_address\*(C'\fR option.
.IP "\fBip_address_v6\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_address_v6: returns NetAddr::IP"
Like the \f(CW\*(C`ip_address\*(C'\fR method, however, an IPv4 address is returned as an
IPv4\-mapped IPv6 address (e.g. '::ffff:192.168.0.1') to facilitate uniform
processing.
.IP "\fBhelo_identity\fR: returns \fIstring\fR" 4
.IX Item "helo_identity: returns string"
Returns the \f(CW\*(C`HELO\*(C'\fR \s-1SMTP\s0 transaction parameter of the request.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`helo_identity\*(C'\fR option.
.IP "\fBrecord\fR: returns \fIMail::SPF::Record\fR" 4
.IX Item "record: returns Mail::SPF::Record"
Returns the \s-1SPF\s0 record selected during the processing of the request, or
\&\fBundef\fR if there is none.
.IP "\fBstate($field)\fR: returns anything" 4
.IX Item "state($field): returns anything"
.PD 0
.ie n .IP "\fBstate($field, \fB$value\fB)\fR: returns anything" 4
.el .IP "\fBstate($field, \f(CB$value\fB)\fR: returns anything" 4
.IX Item "state($field, $value): returns anything"
.PD
Provides an interface for storing temporary state information with the request
object.  This is primarily meant to be used internally by \fIMail::SPF::Server\fR
and other Mail::SPF classes.
.Sp
If \f(CW$value\fR is specified, stores it in a state field named \f(CW$field\fR.  Returns
the current (new) value of the state field named \f(CW$field\fR.  This method may be
used as an lvalue.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Server
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Request5.16.3pm                   0100644 0001750 0001750 00000034705 12566242062 024775  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Request 3"
.TH Mail::SPF::Request 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Request \- SPF request class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF;
\&
\&    my $request = Mail::SPF::Request\->new(
\&        versions    => [1, 2],              # optional
\&        scope       => \*(Aqmfrom\*(Aq,             # or \*(Aqhelo\*(Aq, \*(Aqpra\*(Aq
\&        identity    => \*(Aqfred@example.com\*(Aq,
\&        ip_address  => \*(Aq192.168.0.1\*(Aq,
\&        helo_identity                       # optional,
\&                    => \*(Aqmta.example.com\*(Aq    #   for %{h} macro expansion
\&    );
\&
\&    my @versions    = $request\->versions;
\&    my $scope       = $request\->scope;
\&    my $authority_domain
\&                    = $request\->authority_domain;
\&    my $identity    = $request\->identity;   # \*(Aqlocalpart@domain\*(Aq or \*(Aqdomain\*(Aq
\&    my $domain      = $request\->domain;
\&    my $localpart   = $request\->localpart;
\&    my $ip_address  = $request\->ip_address;     # IPv4 or IPv6 address
\&    my $ip_address_v6                           # native IPv6 address or
\&                    = $request\->ip_address_v6;  #   IPv4\-mapped IPv6 address
\&    my $helo_identity                           # additional HELO identity
\&                    = $request\->helo_identity;  #   for non\-HELO scopes
\&
\&    my $record      = $request\->record;
\&        # the record selected during processing of the request, may be undef
\&
\&    $request\->state(field => \*(Aqvalue\*(Aq);
\&    my $value = $request\->state(\*(Aqfield\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Request\fR represents an \s-1SPF\s0 request.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "new(%options): returns Mail::SPF::Request"
Creates a new \s-1SPF\s0 request object.  The request is considered the
\&\fIroot-request\fR for any subsequent sub-requests (see the \*(L"new_sub_request\*(R"
constructor).
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBversions\fR" 4
.IX Item "versions"
A reference to an \fIarray\fR of \fIinteger\fRs listing the versions of \s-1SPF\s0 records
that may be used for the \s-1SPF\s0 check.  Only those record versions that cover the
desired scope will actually be used.  At least one applicable version must be
specified.  For a single record version, a simple scalar may be specified
instead of an array-ref.  Defaults to all versions that cover the desired scope
(see below); defaults to \fB[1, 2]\fR for the default scope of \fB'mfrom'\fR.
.Sp
The following versions are supported:
.RS 4
.IP "\fB1\fR" 4
.IX Item "1"
Use \f(CW\*(C`v=spf1\*(C'\fR records.
.IP "\fB2\fR" 4
.IX Item "2"
Use \f(CW\*(C`spf2.0\*(C'\fR records.
.RE
.RS 4
.Sp
\&\fIExample\fR:  A value of \fB1\fR (or \fB[1]\fR) means that only \f(CW\*(C`v=spf1\*(C'\fR records
should be used for the \s-1SPF\s0 check.  If at the same time a scope of \fB'pra'\fR is
specified, a \fIMail::SPF::EInvalidScope\fR exception will be thrown as \f(CW\*(C`v=spf1\*(C'\fR
records do not cover the \s-1PRA\s0 scope.
.RE
.IP "\fBscope\fR" 4
.IX Item "scope"
A string denoting the authorization scope of the identity that should be
checked.  Defaults to \fB'mfrom'\fR.  The following scope values are supported:
.RS 4
.IP "\fB'helo'\fR" 4
.IX Item "'helo'"
The given identity is the \f(CW\*(C`HELO\*(C'\fR parameter of an \s-1SMTP\s0 transaction (\s-1RFC\s0 2821)
and should be checked against \s-1SPF\s0 records that cover the \f(CW\*(C`helo\*(C'\fR scope
(\f(CW\*(C`v=spf1\*(C'\fR).  See the SPFv1 specification (\s-1RFC\s0 4408) for the formal definition
of the \f(CW\*(C`HELO\*(C'\fR scope.
.IP "\fB'mfrom'\fR" 4
.IX Item "'mfrom'"
The given identity is the \f(CW\*(C`MAIL FROM\*(C'\fR parameter of an \s-1SMTP\s0 transaction (\s-1RFC\s0
2821), and should be checked against \s-1SPF\s0 records that cover the \f(CW\*(C`mfrom\*(C'\fR scope
(\f(CW\*(C`v=spf1\*(C'\fR and \f(CW\*(C`spf2.0/mfrom\*(C'\fR).  See the SPFv1 specification (\s-1RFC\s0 4408) for
the formal definition of the \f(CW\*(C`MAIL FROM\*(C'\fR scope.
.Sp
\&\fINote\fR:  In the case of an empty \f(CW\*(C`MAIL FROM\*(C'\fR \s-1SMTP\s0 transaction parameter (\f(CW\*(C`MAIL FROM:<>\*(C'\fR), you should perform a check with the \f(CW\*(C`helo\*(C'\fR scope instead.
.IP "\fB'pra'\fR" 4
.IX Item "'pra'"
The given identity is the \*(L"Purported Responsible Address\*(R" of an internet
message (\s-1RFC\s0 2822) and should be checked against \s-1SPF\s0 records that cover the
\&\f(CW\*(C`pra\*(C'\fR scope (\f(CW\*(C`spf2.0/pra\*(C'\fR).  See the \s-1PRA\s0 specification (\s-1RFC\s0 4407) for the
formal definition of the \s-1PRA\s0 scope.
.RE
.RS 4
.RE
.IP "\fBauthority_domain\fR" 4
.IX Item "authority_domain"
A string denoting the domain name that should be queried for sender policy
records.  Defaults to the domain of the \f(CW\*(C`identity\*(C'\fR option.  There is usually
no need to specify the \f(CW\*(C`authority_domain\*(C'\fR option.
.IP "\fBidentity\fR" 4
.IX Item "identity"
\&\fIRequired\fR.  A string denoting the sender identity whose authorization should
be checked.  This is a domain name for the \f(CW\*(C`helo\*(C'\fR scope, and an e\-mail address
for the \f(CW\*(C`mfrom\*(C'\fR and \f(CW\*(C`pra\*(C'\fR scopes.
.Sp
\&\fINote\fR:  An empty identity must not be passed.  In the case of an empty \f(CW\*(C`MAIL
FROM\*(C'\fR \s-1SMTP\s0 transaction parameter, you should perform a check with the \f(CW\*(C`helo\*(C'\fR
scope instead.
.IP "\fBip_address\fR" 4
.IX Item "ip_address"
\&\fIRequired\fR for checks with the \f(CW\*(C`helo\*(C'\fR, \f(CW\*(C`mfrom\*(C'\fR, and \f(CW\*(C`pra\*(C'\fR scopes.  Either a
string or a \fINetAddr::IP\fR object denoting the \s-1IP\s0 address of the host claiming
the identity that is being checked.  Can be either an IPv4 or an IPv6 address.
An IPv4\-mapped IPv6 address (e.g. '::ffff:192.168.0.1') is treated as an IPv4
address.
.IP "\fBhelo_identity\fR" 4
.IX Item "helo_identity"
A string denoting the \f(CW\*(C`HELO\*(C'\fR \s-1SMTP\s0 transaction parameter in the case that the
main identity is of a scope other than \f(CW\*(C`helo\*(C'\fR.  This identity is then used
merely for the expansion of \f(CW\*(C`%{h}\*(C'\fR macros during the policy evaluation of the
main identity.  Defaults to \fBundef\fR, which will be expanded to \fB'unknown'\fR.
If the main identity is of the \f(CW\*(C`helo\*(C'\fR scope, this option is unused.
.RE
.RS 4
.RE
.IP "\fBnew_sub_request(%options)\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "new_sub_request(%options): returns Mail::SPF::Request"
Must be invoked on an existing request object.  Creates a new sub-request
object by cloning the invoked request, which is then considered the new
request's \fIsuper-request\fR.  Any specified options (see the \*(L"new\*(R"
constructor) override the parameters of the super-request.  There is usually no
need to specify any options \fIbesides\fR the \f(CW\*(C`authority_domain\*(C'\fR option.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBroot_request\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "root_request: returns Mail::SPF::Request"
Returns the root of the request's chain of super-requests.  Specifically,
returns the request itself if it has no super-requests.
.IP "\fBsuper_request\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "super_request: returns Mail::SPF::Request"
Returns the super-request of the request, or \fBundef\fR if there is none.
.IP "\fBversions\fR: returns \fIlist\fR of \fIstring\fR" 4
.IX Item "versions: returns list of string"
Returns a list of the \s-1SPF\s0 record versions that are used for request.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`versions\*(C'\fR option.
.IP "\fBscope\fR: returns \fIstring\fR" 4
.IX Item "scope: returns string"
Returns the scope of the request.  See the description of the \*(L"new\*(R"
constructor's \f(CW\*(C`scope\*(C'\fR option.
.IP "\fBauthority_domain\fR: returns \fIstring\fR" 4
.IX Item "authority_domain: returns string"
Returns the authority domain of the request.  See the description of the
\&\*(L"new\*(R" constructor's \f(CW\*(C`authority_domain\*(C'\fR option.
.IP "\fBidentity\fR: returns \fIstring\fR" 4
.IX Item "identity: returns string"
Returns the identity of the request.  See the description of the \*(L"new\*(R"
constructor's \f(CW\*(C`identity\*(C'\fR option.
.IP "\fBdomain\fR: returns \fIstring\fR" 4
.IX Item "domain: returns string"
Returns the identity domain of the request.  See the description of the
\&\*(L"new\*(R" constructor's \f(CW\*(C`identity\*(C'\fR option.
.IP "\fBlocalpart\fR: returns \fIstring\fR" 4
.IX Item "localpart: returns string"
Returns the identity localpart of the request.  See the description of the
\&\*(L"new\*(R" constructor's \f(CW\*(C`identity\*(C'\fR option.
.IP "\fBip_address\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_address: returns NetAddr::IP"
Returns the \s-1IP\s0 address of the request as a \fINetAddr::IP\fR object.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`ip_address\*(C'\fR option.
.IP "\fBip_address_v6\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_address_v6: returns NetAddr::IP"
Like the \f(CW\*(C`ip_address\*(C'\fR method, however, an IPv4 address is returned as an
IPv4\-mapped IPv6 address (e.g. '::ffff:192.168.0.1') to facilitate uniform
processing.
.IP "\fBhelo_identity\fR: returns \fIstring\fR" 4
.IX Item "helo_identity: returns string"
Returns the \f(CW\*(C`HELO\*(C'\fR \s-1SMTP\s0 transaction parameter of the request.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`helo_identity\*(C'\fR option.
.IP "\fBrecord\fR: returns \fIMail::SPF::Record\fR" 4
.IX Item "record: returns Mail::SPF::Record"
Returns the \s-1SPF\s0 record selected during the processing of the request, or
\&\fBundef\fR if there is none.
.IP "\fBstate($field)\fR: returns anything" 4
.IX Item "state($field): returns anything"
.PD 0
.ie n .IP "\fBstate($field, \fB$value\fB)\fR: returns anything" 4
.el .IP "\fBstate($field, \f(CB$value\fB)\fR: returns anything" 4
.IX Item "state($field, $value): returns anything"
.PD
Provides an interface for storing temporary state information with the request
object.  This is primarily meant to be used internally by \fIMail::SPF::Server\fR
and other Mail::SPF classes.
.Sp
If \f(CW$value\fR is specified, stores it in a state field named \f(CW$field\fR.  Returns
the current (new) value of the state field named \f(CW$field\fR.  This method may be
used as an lvalue.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Server
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Request5.18.3pm                   0100644 0001750 0001750 00000035226 12566242051 024774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Request 3"
.TH Mail::SPF::Request 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Request \- SPF request class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF;
\&
\&    my $request = Mail::SPF::Request\->new(
\&        versions    => [1, 2],              # optional
\&        scope       => \*(Aqmfrom\*(Aq,             # or \*(Aqhelo\*(Aq, \*(Aqpra\*(Aq
\&        identity    => \*(Aqfred@example.com\*(Aq,
\&        ip_address  => \*(Aq192.168.0.1\*(Aq,
\&        helo_identity                       # optional,
\&                    => \*(Aqmta.example.com\*(Aq    #   for %{h} macro expansion
\&    );
\&
\&    my @versions    = $request\->versions;
\&    my $scope       = $request\->scope;
\&    my $authority_domain
\&                    = $request\->authority_domain;
\&    my $identity    = $request\->identity;   # \*(Aqlocalpart@domain\*(Aq or \*(Aqdomain\*(Aq
\&    my $domain      = $request\->domain;
\&    my $localpart   = $request\->localpart;
\&    my $ip_address  = $request\->ip_address;     # IPv4 or IPv6 address
\&    my $ip_address_v6                           # native IPv6 address or
\&                    = $request\->ip_address_v6;  #   IPv4\-mapped IPv6 address
\&    my $helo_identity                           # additional HELO identity
\&                    = $request\->helo_identity;  #   for non\-HELO scopes
\&
\&    my $record      = $request\->record;
\&        # the record selected during processing of the request, may be undef
\&
\&    $request\->state(field => \*(Aqvalue\*(Aq);
\&    my $value = $request\->state(\*(Aqfield\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Request\fR represents an \s-1SPF\s0 request.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "new(%options): returns Mail::SPF::Request"
Creates a new \s-1SPF\s0 request object.  The request is considered the
\&\fIroot-request\fR for any subsequent sub-requests (see the \*(L"new_sub_request\*(R"
constructor).
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBversions\fR" 4
.IX Item "versions"
A reference to an \fIarray\fR of \fIinteger\fRs listing the versions of \s-1SPF\s0 records
that may be used for the \s-1SPF\s0 check.  Only those record versions that cover the
desired scope will actually be used.  At least one applicable version must be
specified.  For a single record version, a simple scalar may be specified
instead of an array-ref.  Defaults to all versions that cover the desired scope
(see below); defaults to \fB[1, 2]\fR for the default scope of \fB'mfrom'\fR.
.Sp
The following versions are supported:
.RS 4
.IP "\fB1\fR" 4
.IX Item "1"
Use \f(CW\*(C`v=spf1\*(C'\fR records.
.IP "\fB2\fR" 4
.IX Item "2"
Use \f(CW\*(C`spf2.0\*(C'\fR records.
.RE
.RS 4
.Sp
\&\fIExample\fR:  A value of \fB1\fR (or \fB[1]\fR) means that only \f(CW\*(C`v=spf1\*(C'\fR records
should be used for the \s-1SPF\s0 check.  If at the same time a scope of \fB'pra'\fR is
specified, a \fIMail::SPF::EInvalidScope\fR exception will be thrown as \f(CW\*(C`v=spf1\*(C'\fR
records do not cover the \s-1PRA\s0 scope.
.RE
.IP "\fBscope\fR" 4
.IX Item "scope"
A string denoting the authorization scope of the identity that should be
checked.  Defaults to \fB'mfrom'\fR.  The following scope values are supported:
.RS 4
.IP "\fB'helo'\fR" 4
.IX Item "'helo'"
The given identity is the \f(CW\*(C`HELO\*(C'\fR parameter of an \s-1SMTP\s0 transaction (\s-1RFC 2821\s0)
and should be checked against \s-1SPF\s0 records that cover the \f(CW\*(C`helo\*(C'\fR scope
(\f(CW\*(C`v=spf1\*(C'\fR).  See the SPFv1 specification (\s-1RFC 4408\s0) for the formal definition
of the \f(CW\*(C`HELO\*(C'\fR scope.
.IP "\fB'mfrom'\fR" 4
.IX Item "'mfrom'"
The given identity is the \f(CW\*(C`MAIL FROM\*(C'\fR parameter of an \s-1SMTP\s0 transaction (\s-1RFC
2821\s0), and should be checked against \s-1SPF\s0 records that cover the \f(CW\*(C`mfrom\*(C'\fR scope
(\f(CW\*(C`v=spf1\*(C'\fR and \f(CW\*(C`spf2.0/mfrom\*(C'\fR).  See the SPFv1 specification (\s-1RFC 4408\s0) for
the formal definition of the \f(CW\*(C`MAIL FROM\*(C'\fR scope.
.Sp
\&\fINote\fR:  In the case of an empty \f(CW\*(C`MAIL FROM\*(C'\fR \s-1SMTP\s0 transaction parameter (\f(CW\*(C`MAIL FROM:<>\*(C'\fR), you should perform a check with the \f(CW\*(C`helo\*(C'\fR scope instead.
.IP "\fB'pra'\fR" 4
.IX Item "'pra'"
The given identity is the \*(L"Purported Responsible Address\*(R" of an internet
message (\s-1RFC 2822\s0) and should be checked against \s-1SPF\s0 records that cover the
\&\f(CW\*(C`pra\*(C'\fR scope (\f(CW\*(C`spf2.0/pra\*(C'\fR).  See the \s-1PRA\s0 specification (\s-1RFC 4407\s0) for the
formal definition of the \s-1PRA\s0 scope.
.RE
.RS 4
.RE
.IP "\fBauthority_domain\fR" 4
.IX Item "authority_domain"
A string denoting the domain name that should be queried for sender policy
records.  Defaults to the domain of the \f(CW\*(C`identity\*(C'\fR option.  There is usually
no need to specify the \f(CW\*(C`authority_domain\*(C'\fR option.
.IP "\fBidentity\fR" 4
.IX Item "identity"
\&\fIRequired\fR.  A string denoting the sender identity whose authorization should
be checked.  This is a domain name for the \f(CW\*(C`helo\*(C'\fR scope, and an e\-mail address
for the \f(CW\*(C`mfrom\*(C'\fR and \f(CW\*(C`pra\*(C'\fR scopes.
.Sp
\&\fINote\fR:  An empty identity must not be passed.  In the case of an empty \f(CW\*(C`MAIL
FROM\*(C'\fR \s-1SMTP\s0 transaction parameter, you should perform a check with the \f(CW\*(C`helo\*(C'\fR
scope instead.
.IP "\fBip_address\fR" 4
.IX Item "ip_address"
\&\fIRequired\fR for checks with the \f(CW\*(C`helo\*(C'\fR, \f(CW\*(C`mfrom\*(C'\fR, and \f(CW\*(C`pra\*(C'\fR scopes.  Either a
string or a \fINetAddr::IP\fR object denoting the \s-1IP\s0 address of the host claiming
the identity that is being checked.  Can be either an IPv4 or an IPv6 address.
An IPv4\-mapped IPv6 address (e.g. '::ffff:192.168.0.1') is treated as an IPv4
address.
.IP "\fBhelo_identity\fR" 4
.IX Item "helo_identity"
A string denoting the \f(CW\*(C`HELO\*(C'\fR \s-1SMTP\s0 transaction parameter in the case that the
main identity is of a scope other than \f(CW\*(C`helo\*(C'\fR.  This identity is then used
merely for the expansion of \f(CW\*(C`%{h}\*(C'\fR macros during the policy evaluation of the
main identity.  Defaults to \fBundef\fR, which will be expanded to \fB'unknown'\fR.
If the main identity is of the \f(CW\*(C`helo\*(C'\fR scope, this option is unused.
.RE
.RS 4
.RE
.IP "\fBnew_sub_request(%options)\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "new_sub_request(%options): returns Mail::SPF::Request"
Must be invoked on an existing request object.  Creates a new sub-request
object by cloning the invoked request, which is then considered the new
request's \fIsuper-request\fR.  Any specified options (see the \*(L"new\*(R"
constructor) override the parameters of the super-request.  There is usually no
need to specify any options \fIbesides\fR the \f(CW\*(C`authority_domain\*(C'\fR option.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBroot_request\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "root_request: returns Mail::SPF::Request"
Returns the root of the request's chain of super-requests.  Specifically,
returns the request itself if it has no super-requests.
.IP "\fBsuper_request\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "super_request: returns Mail::SPF::Request"
Returns the super-request of the request, or \fBundef\fR if there is none.
.IP "\fBversions\fR: returns \fIlist\fR of \fIstring\fR" 4
.IX Item "versions: returns list of string"
Returns a list of the \s-1SPF\s0 record versions that are used for request.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`versions\*(C'\fR option.
.IP "\fBscope\fR: returns \fIstring\fR" 4
.IX Item "scope: returns string"
Returns the scope of the request.  See the description of the \*(L"new\*(R"
constructor's \f(CW\*(C`scope\*(C'\fR option.
.IP "\fBauthority_domain\fR: returns \fIstring\fR" 4
.IX Item "authority_domain: returns string"
Returns the authority domain of the request.  See the description of the
\&\*(L"new\*(R" constructor's \f(CW\*(C`authority_domain\*(C'\fR option.
.IP "\fBidentity\fR: returns \fIstring\fR" 4
.IX Item "identity: returns string"
Returns the identity of the request.  See the description of the \*(L"new\*(R"
constructor's \f(CW\*(C`identity\*(C'\fR option.
.IP "\fBdomain\fR: returns \fIstring\fR" 4
.IX Item "domain: returns string"
Returns the identity domain of the request.  See the description of the
\&\*(L"new\*(R" constructor's \f(CW\*(C`identity\*(C'\fR option.
.IP "\fBlocalpart\fR: returns \fIstring\fR" 4
.IX Item "localpart: returns string"
Returns the identity localpart of the request.  See the description of the
\&\*(L"new\*(R" constructor's \f(CW\*(C`identity\*(C'\fR option.
.IP "\fBip_address\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_address: returns NetAddr::IP"
Returns the \s-1IP\s0 address of the request as a \fINetAddr::IP\fR object.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`ip_address\*(C'\fR option.
.IP "\fBip_address_v6\fR: returns \fINetAddr::IP\fR" 4
.IX Item "ip_address_v6: returns NetAddr::IP"
Like the \f(CW\*(C`ip_address\*(C'\fR method, however, an IPv4 address is returned as an
IPv4\-mapped IPv6 address (e.g. '::ffff:192.168.0.1') to facilitate uniform
processing.
.IP "\fBhelo_identity\fR: returns \fIstring\fR" 4
.IX Item "helo_identity: returns string"
Returns the \f(CW\*(C`HELO\*(C'\fR \s-1SMTP\s0 transaction parameter of the request.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`helo_identity\*(C'\fR option.
.IP "\fBrecord\fR: returns \fIMail::SPF::Record\fR" 4
.IX Item "record: returns Mail::SPF::Record"
Returns the \s-1SPF\s0 record selected during the processing of the request, or
\&\fBundef\fR if there is none.
.IP "\fBstate($field)\fR: returns anything" 4
.IX Item "state($field): returns anything"
.PD 0
.ie n .IP "\fBstate($field, \fB$value\fB)\fR: returns anything" 4
.el .IP "\fBstate($field, \f(CB$value\fB)\fR: returns anything" 4
.IX Item "state($field, $value): returns anything"
.PD
Provides an interface for storing temporary state information with the request
object.  This is primarily meant to be used internally by \fIMail::SPF::Server\fR
and other Mail::SPF classes.
.Sp
If \f(CW$value\fR is specified, stores it in a state field named \f(CW$field\fR.  Returns
the current (new) value of the state field named \f(CW$field\fR.  This method may be
used as an lvalue.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Server
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Result.3pm                        0100644 0001750 0001750 00000036773 12566242050 024315  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Result 3"
.TH Mail::SPF::Result 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Result \- SPF result class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
For the general usage of \fIMail::SPF::Result\fR objects in code that calls
Mail::SPF, see Mail::SPF.  For the detailed interface of \fIMail::SPF::Result\fR
and its derivatives, see below.
.SS "Throwing results"
.IX Subsection "Throwing results"
.Vb 3
\&    package Mail::SPF::Foo;
\&    use Error \*(Aq:try\*(Aq;
\&    use Mail::SPF::Result;
\&
\&    sub foo {
\&        if (...) {
\&            $server\->throw_result(\*(Aqpass\*(Aq, $request)
\&        }
\&        else {
\&            $server\->throw_result(\*(Aqpermerror\*(Aq, $request, \*(AqInvalid foo\*(Aq);
\&        }
\&    }
.Ve
.SS "Catching results"
.IX Subsection "Catching results"
.Vb 3
\&    package Mail::SPF::Bar;
\&    use Error \*(Aq:try\*(Aq;
\&    use Mail::SPF::Foo;
\&
\&    try {
\&        Mail::SPF::Foo\->foo();
\&    }
\&    catch Mail::SPF::Result with {
\&        my ($result) = @_;
\&        ...
\&    };
.Ve
.SS "Using results"
.IX Subsection "Using results"
.Vb 7
\&    my $result_name     = $result\->name;
\&    my $result_code     = $result\->code;
\&    my $request         = $result\->request;
\&    my $local_exp       = $result\->local_explanation;
\&    my $authority_exp   = $result\->authority_explanation
\&        if $result\->can(\*(Aqauthority_explanation\*(Aq);
\&    my $spf_header      = $result\->received_spf_header;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Result\fR represents the result of an \s-1SPF\s0
request.
.PP
There is usually no need to construct an \s-1SPF\s0 result object directly using the
\&\f(CW\*(C`new\*(C'\fR constructor.  Instead, use the \f(CW\*(C`throw\*(C'\fR class method to signal to the
calling code that a definite \s-1SPF\s0 result has been determined.  In other words,
use Mail::SPF::Result and its derivatives just like exceptions.  See Error
or \*(L"eval\*(R" in perlfunc for how to handle exceptions in Perl.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.ie n .IP "\fBnew($server, \fB$request\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.el .IP "\fBnew($server, \f(CB$request\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.IX Item "new($server, $request): returns Mail::SPF::Result"
.PD 0
.ie n .IP "\fBnew($server, \fB$request\fB, \f(BI$text\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.el .IP "\fBnew($server, \f(CB$request\fB, \f(CB$text\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.IX Item "new($server, $request, $text): returns Mail::SPF::Result"
.PD
Creates a new \s-1SPF\s0 result object and associates the given \fIMail::SPF::Server\fR
and \fIMail::SPF::Request\fR objects with it.  An optional result text may be
specified.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.ie n .IP "\fBthrow($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request): throws Mail::SPF::Result"
.PD 0
.ie n .IP "\fBthrow($server, \fB$request\fB, \f(BI$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB, \f(CB$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request, $text): throws Mail::SPF::Result"
.PD
Throws a new \s-1SPF\s0 result object, associating the given \fIMail::SPF::Server\fR and
\&\fIMail::SPF::Request\fR objects with it.  An optional result text may be
specified.
.Sp
\&\fINote\fR:  Do not write code invoking \f(CW\*(C`throw\*(C'\fR on \fIliteral\fR result class names
as this would ignore any derivative result classes provided by \fBMail::SPF\fR
extension modules.  Invoke the \f(CW\*(C`throw_result\*(C'\fR
method on a \fIMail::SPF::Server\fR object instead.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
\&\fIAbstract\fR.  Returns the result name of the result class (or object).  For
classes of the \fIMail::SPF::Result::*\fR hierarchy, this roughly corresponds to
the trailing part of the class name.  For example, returns \f(CW\*(C`neutral\-by\-default\*(C'\fR
if invoked on \fIMail::SPF::Result::NeutralByDefault\fR.  Also see the \*(L"code\*(R"
method.  This method may also be used as an instance method.
.Sp
This method must be implemented by sub-classes of Mail::SPF::Result for which
the result \fIname\fR differs from the result \fIcode\fR.
.IP "\fBclass\fR: returns \fIclass\fR" 4
.IX Item "class: returns class"
.PD 0
.IP "\fBclass($name)\fR: returns \fIclass\fR" 4
.IX Item "class($name): returns class"
.PD
Maps the given result name to the corresponding \fIMail::SPF::Result::*\fR class,
or returns the result base class (the class on which it is invoked) if no
result name is given.  If an unknown result name is specified, returns
\&\fBundef\fR.
.IP "\fBisa_by_name($name)\fR: returns \fIboolean\fR" 4
.IX Item "isa_by_name($name): returns boolean"
If the class (or object) on which this method is invoked represents the given
result name (or a derivative name), returns \fBtrue\fR.  Returns \fBfalse\fR
otherwise.  This method may also be used as an instance method.
.Sp
For example, \f(CW\*(C`Mail::SPF::Result::NeutralByDefault\->isa_by_name(\*(Aqneutral\*(Aq)\*(C'\fR
returns \fBtrue\fR.
.IP "\fBcode\fR: returns \fIstring\fR" 4
.IX Item "code: returns string"
\&\fIAbstract\fR.  Returns the basic \s-1SPF\s0 result code (\f(CW"pass"\fR, \f(CW"fail"\fR,
\&\f(CW"softfail"\fR, \f(CW"neutral"\fR, \f(CW"none"\fR, \f(CW"error"\fR, \f(CW"permerror"\fR,
\&\f(CW"temperror"\fR) of the result class on which it is invoked.  All valid result
codes are valid result names as well, the reverse however does not apply.  This
method may also be used as an instance method.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Result.
.IP "\fBis_code($code)\fR: returns \fIboolean\fR" 4
.IX Item "is_code($code): returns boolean"
If the class (or object) on which this method is invoked represents the given
result code, returns \fBtrue\fR.  Returns \fBfalse\fR otherwise.  This method may
also be used as an instance method.
.Sp
\&\fINote\fR:  The \*(L"isa_by_name\*(R" method provides a superset of this method's
functionality.
.IP "\fBreceived_spf_header_name\fR: returns \fIstring\fR" 4
.IX Item "received_spf_header_name: returns string"
Returns \fB'Received\-SPF'\fR as the field name for \f(CW\*(C`Received\-SPF\*(C'\fR header fields.
This method should be overridden by \fBMail::SPF\fR extension modules that provide
non-standard features (such as local policy) with the capacity to dilute the
purity of \s-1SPF\s0 results, in order not to deceive users of the header field into
mistaking it as an indication of a natural \s-1SPF\s0 result.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBthrow\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw: throws Mail::SPF::Result"
.PD 0
.ie n .IP "\fBthrow($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request): throws Mail::SPF::Result"
.ie n .IP "\fBthrow($server, \fB$request\fB, \f(BI$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB, \f(CB$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request, $text): throws Mail::SPF::Result"
.PD
Re-throws an existing \s-1SPF\s0 result object.  If \fIMail::SPF::Server\fR and
\&\fIMail::SPF::Request\fR objects are specified, associates them with the result
object, replacing the prior server and request objects.  If a result text is
specified as well, overrides the prior result text.
.IP "\fBserver\fR: returns \fIMail::SPF::Server\fR" 4
.IX Item "server: returns Mail::SPF::Server"
Returns the Mail::SPF server object that produced the result at hand.
.IP "\fBrequest\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "request: returns Mail::SPF::Request"
Returns the \s-1SPF\s0 request that led to the result at hand.
.IP "\fBtext\fR: returns \fIstring\fR" 4
.IX Item "text: returns string"
Returns the text message of the result object.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Returns the result's name and text message formatted as a string.  You can
simply use a Mail::SPF::Result object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\*(R"\s0.
.IP "\fBlocal_explanation\fR: returns \fIstring\fR; throws \fIMail::SPF::EDNSError\fR, \fIMail::SPF::EInvalidMacroString\fR" 4
.IX Item "local_explanation: returns string; throws Mail::SPF::EDNSError, Mail::SPF::EInvalidMacroString"
Returns a locally generated explanation for the result.
.Sp
The local explanation is prefixed with the authority domain whose sender policy
is responsible for the result.  If the responsible sender policy referred to
another domain's policy (using the \f(CW\*(C`include\*(C'\fR mechanism or the \f(CW\*(C`redirect\*(C'\fR
modifier), that other domain which is \fIdirectly\fR responsible for the result is
also included in the local explanation's head.  For example:
.Sp
.Vb 1
\&    example.com: <local\-explanation>
.Ve
.Sp
The authority domain \f(CW\*(C`example.com\*(C'\fR's sender policy is directly responsible for
the result.
.Sp
.Vb 1
\&    example.com ... other.example.org: <local\-explanation>
.Ve
.Sp
The authority domain \f(CW\*(C`example.com\*(C'\fR (directly or indirectly) referred to the
domain \f(CW\*(C`other.example.org\*(C'\fR, whose sender policy then led to the result.
.IP "\fBreceived_spf_header\fR: returns \fIstring\fR" 4
.IX Item "received_spf_header: returns string"
Returns a string containing an appropriate \f(CW\*(C`Received\-SPF\*(C'\fR header field for the
result object.  The header field is not line-wrapped and contains no trailing
newline character.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Result object is used as a \fIstring\fR, the \*(L"stringify\*(R" method
is used to convert the object into a string.
.SH "RESULT CLASSES"
.IX Header "RESULT CLASSES"
The following result classes are provided:
.IP "\(bu" 4
\&\fIMail::SPF::Result::Pass\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::Fail\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::SoftFail\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::Neutral\fR
.RS 4
.IP "\(bu" 4
\&\fIMail::SPF::Result::NeutralByDefault\fR
.Sp
This is a special case of the \f(CW\*(C`neutral\*(C'\fR result that is thrown as a default
when \*(L"falling off\*(R" the end of the record during evaluation.  See \s-1RFC 4408,
4.7.\s0
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fIMail::SPF::Result::None\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::Error\fR
.RS 4
.IP "\(bu" 4
\&\fIMail::SPF::Result::PermError\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::TempError\fR
.RE
.RS 4
.RE
.PP
The following result classes have additional functionality:
.IP "\fIMail::SPF::Result::Fail\fR" 4
.IX Item "Mail::SPF::Result::Fail"
The following additional instance method is provided:
.RS 4
.IP "\fBauthority_explanation\fR: returns \fIstring\fR; throws \fIMail::SPF::EDNSError\fR, \fIMail::SPF::EInvalidMacroString\fR" 4
.IX Item "authority_explanation: returns string; throws Mail::SPF::EDNSError, Mail::SPF::EInvalidMacroString"
Returns the authority domain's explanation for the result.  Be aware that the
authority domain may be a malicious party and thus the authority explanation
should not be trusted blindly.  See \s-1RFC 4408, 10.5,\s0 for a detailed discussion
of this issue.
.RE
.RS 4
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Server, Error, \*(L"eval\*(R" in perlfunc
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>
     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Result5.16.3pm                    0100644 0001750 0001750 00000036452 12566242063 024625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Result 3"
.TH Mail::SPF::Result 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Result \- SPF result class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
For the general usage of \fIMail::SPF::Result\fR objects in code that calls
Mail::SPF, see Mail::SPF.  For the detailed interface of \fIMail::SPF::Result\fR
and its derivatives, see below.
.SS "Throwing results"
.IX Subsection "Throwing results"
.Vb 3
\&    package Mail::SPF::Foo;
\&    use Error \*(Aq:try\*(Aq;
\&    use Mail::SPF::Result;
\&
\&    sub foo {
\&        if (...) {
\&            $server\->throw_result(\*(Aqpass\*(Aq, $request)
\&        }
\&        else {
\&            $server\->throw_result(\*(Aqpermerror\*(Aq, $request, \*(AqInvalid foo\*(Aq);
\&        }
\&    }
.Ve
.SS "Catching results"
.IX Subsection "Catching results"
.Vb 3
\&    package Mail::SPF::Bar;
\&    use Error \*(Aq:try\*(Aq;
\&    use Mail::SPF::Foo;
\&
\&    try {
\&        Mail::SPF::Foo\->foo();
\&    }
\&    catch Mail::SPF::Result with {
\&        my ($result) = @_;
\&        ...
\&    };
.Ve
.SS "Using results"
.IX Subsection "Using results"
.Vb 7
\&    my $result_name     = $result\->name;
\&    my $result_code     = $result\->code;
\&    my $request         = $result\->request;
\&    my $local_exp       = $result\->local_explanation;
\&    my $authority_exp   = $result\->authority_explanation
\&        if $result\->can(\*(Aqauthority_explanation\*(Aq);
\&    my $spf_header      = $result\->received_spf_header;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Result\fR represents the result of an \s-1SPF\s0
request.
.PP
There is usually no need to construct an \s-1SPF\s0 result object directly using the
\&\f(CW\*(C`new\*(C'\fR constructor.  Instead, use the \f(CW\*(C`throw\*(C'\fR class method to signal to the
calling code that a definite \s-1SPF\s0 result has been determined.  In other words,
use Mail::SPF::Result and its derivatives just like exceptions.  See Error
or \*(L"eval\*(R" in perlfunc for how to handle exceptions in Perl.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.ie n .IP "\fBnew($server, \fB$request\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.el .IP "\fBnew($server, \f(CB$request\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.IX Item "new($server, $request): returns Mail::SPF::Result"
.PD 0
.ie n .IP "\fBnew($server, \fB$request\fB, \f(BI$text\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.el .IP "\fBnew($server, \f(CB$request\fB, \f(CB$text\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.IX Item "new($server, $request, $text): returns Mail::SPF::Result"
.PD
Creates a new \s-1SPF\s0 result object and associates the given \fIMail::SPF::Server\fR
and \fIMail::SPF::Request\fR objects with it.  An optional result text may be
specified.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.ie n .IP "\fBthrow($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request): throws Mail::SPF::Result"
.PD 0
.ie n .IP "\fBthrow($server, \fB$request\fB, \f(BI$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB, \f(CB$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request, $text): throws Mail::SPF::Result"
.PD
Throws a new \s-1SPF\s0 result object, associating the given \fIMail::SPF::Server\fR and
\&\fIMail::SPF::Request\fR objects with it.  An optional result text may be
specified.
.Sp
\&\fINote\fR:  Do not write code invoking \f(CW\*(C`throw\*(C'\fR on \fIliteral\fR result class names
as this would ignore any derivative result classes provided by \fBMail::SPF\fR
extension modules.  Invoke the \f(CW\*(C`throw_result\*(C'\fR
method on a \fIMail::SPF::Server\fR object instead.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
\&\fIAbstract\fR.  Returns the result name of the result class (or object).  For
classes of the \fIMail::SPF::Result::*\fR hierarchy, this roughly corresponds to
the trailing part of the class name.  For example, returns \f(CW\*(C`neutral\-by\-default\*(C'\fR
if invoked on \fIMail::SPF::Result::NeutralByDefault\fR.  Also see the \*(L"code\*(R"
method.  This method may also be used as an instance method.
.Sp
This method must be implemented by sub-classes of Mail::SPF::Result for which
the result \fIname\fR differs from the result \fIcode\fR.
.IP "\fBclass\fR: returns \fIclass\fR" 4
.IX Item "class: returns class"
.PD 0
.IP "\fBclass($name)\fR: returns \fIclass\fR" 4
.IX Item "class($name): returns class"
.PD
Maps the given result name to the corresponding \fIMail::SPF::Result::*\fR class,
or returns the result base class (the class on which it is invoked) if no
result name is given.  If an unknown result name is specified, returns
\&\fBundef\fR.
.IP "\fBisa_by_name($name)\fR: returns \fIboolean\fR" 4
.IX Item "isa_by_name($name): returns boolean"
If the class (or object) on which this method is invoked represents the given
result name (or a derivative name), returns \fBtrue\fR.  Returns \fBfalse\fR
otherwise.  This method may also be used as an instance method.
.Sp
For example, \f(CW\*(C`Mail::SPF::Result::NeutralByDefault\->isa_by_name(\*(Aqneutral\*(Aq)\*(C'\fR
returns \fBtrue\fR.
.IP "\fBcode\fR: returns \fIstring\fR" 4
.IX Item "code: returns string"
\&\fIAbstract\fR.  Returns the basic \s-1SPF\s0 result code (\f(CW"pass"\fR, \f(CW"fail"\fR,
\&\f(CW"softfail"\fR, \f(CW"neutral"\fR, \f(CW"none"\fR, \f(CW"error"\fR, \f(CW"permerror"\fR,
\&\f(CW"temperror"\fR) of the result class on which it is invoked.  All valid result
codes are valid result names as well, the reverse however does not apply.  This
method may also be used as an instance method.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Result.
.IP "\fBis_code($code)\fR: returns \fIboolean\fR" 4
.IX Item "is_code($code): returns boolean"
If the class (or object) on which this method is invoked represents the given
result code, returns \fBtrue\fR.  Returns \fBfalse\fR otherwise.  This method may
also be used as an instance method.
.Sp
\&\fINote\fR:  The \*(L"isa_by_name\*(R" method provides a superset of this method's
functionality.
.IP "\fBreceived_spf_header_name\fR: returns \fIstring\fR" 4
.IX Item "received_spf_header_name: returns string"
Returns \fB'Received\-SPF'\fR as the field name for \f(CW\*(C`Received\-SPF\*(C'\fR header fields.
This method should be overridden by \fBMail::SPF\fR extension modules that provide
non-standard features (such as local policy) with the capacity to dilute the
purity of \s-1SPF\s0 results, in order not to deceive users of the header field into
mistaking it as an indication of a natural \s-1SPF\s0 result.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBthrow\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw: throws Mail::SPF::Result"
.PD 0
.ie n .IP "\fBthrow($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request): throws Mail::SPF::Result"
.ie n .IP "\fBthrow($server, \fB$request\fB, \f(BI$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB, \f(CB$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request, $text): throws Mail::SPF::Result"
.PD
Re-throws an existing \s-1SPF\s0 result object.  If \fIMail::SPF::Server\fR and
\&\fIMail::SPF::Request\fR objects are specified, associates them with the result
object, replacing the prior server and request objects.  If a result text is
specified as well, overrides the prior result text.
.IP "\fBserver\fR: returns \fIMail::SPF::Server\fR" 4
.IX Item "server: returns Mail::SPF::Server"
Returns the Mail::SPF server object that produced the result at hand.
.IP "\fBrequest\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "request: returns Mail::SPF::Request"
Returns the \s-1SPF\s0 request that led to the result at hand.
.IP "\fBtext\fR: returns \fIstring\fR" 4
.IX Item "text: returns string"
Returns the text message of the result object.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Returns the result's name and text message formatted as a string.  You can
simply use a Mail::SPF::Result object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\s0\*(R".
.IP "\fBlocal_explanation\fR: returns \fIstring\fR; throws \fIMail::SPF::EDNSError\fR, \fIMail::SPF::EInvalidMacroString\fR" 4
.IX Item "local_explanation: returns string; throws Mail::SPF::EDNSError, Mail::SPF::EInvalidMacroString"
Returns a locally generated explanation for the result.
.Sp
The local explanation is prefixed with the authority domain whose sender policy
is responsible for the result.  If the responsible sender policy referred to
another domain's policy (using the \f(CW\*(C`include\*(C'\fR mechanism or the \f(CW\*(C`redirect\*(C'\fR
modifier), that other domain which is \fIdirectly\fR responsible for the result is
also included in the local explanation's head.  For example:
.Sp
.Vb 1
\&    example.com: <local\-explanation>
.Ve
.Sp
The authority domain \f(CW\*(C`example.com\*(C'\fR's sender policy is directly responsible for
the result.
.Sp
.Vb 1
\&    example.com ... other.example.org: <local\-explanation>
.Ve
.Sp
The authority domain \f(CW\*(C`example.com\*(C'\fR (directly or indirectly) referred to the
domain \f(CW\*(C`other.example.org\*(C'\fR, whose sender policy then led to the result.
.IP "\fBreceived_spf_header\fR: returns \fIstring\fR" 4
.IX Item "received_spf_header: returns string"
Returns a string containing an appropriate \f(CW\*(C`Received\-SPF\*(C'\fR header field for the
result object.  The header field is not line-wrapped and contains no trailing
newline character.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Result object is used as a \fIstring\fR, the \*(L"stringify\*(R" method
is used to convert the object into a string.
.SH "RESULT CLASSES"
.IX Header "RESULT CLASSES"
The following result classes are provided:
.IP "\(bu" 4
\&\fIMail::SPF::Result::Pass\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::Fail\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::SoftFail\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::Neutral\fR
.RS 4
.IP "\(bu" 4
\&\fIMail::SPF::Result::NeutralByDefault\fR
.Sp
This is a special case of the \f(CW\*(C`neutral\*(C'\fR result that is thrown as a default
when \*(L"falling off\*(R" the end of the record during evaluation.  See \s-1RFC\s0 4408,
4.7.
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fIMail::SPF::Result::None\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::Error\fR
.RS 4
.IP "\(bu" 4
\&\fIMail::SPF::Result::PermError\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::TempError\fR
.RE
.RS 4
.RE
.PP
The following result classes have additional functionality:
.IP "\fIMail::SPF::Result::Fail\fR" 4
.IX Item "Mail::SPF::Result::Fail"
The following additional instance method is provided:
.RS 4
.IP "\fBauthority_explanation\fR: returns \fIstring\fR; throws \fIMail::SPF::EDNSError\fR, \fIMail::SPF::EInvalidMacroString\fR" 4
.IX Item "authority_explanation: returns string; throws Mail::SPF::EDNSError, Mail::SPF::EInvalidMacroString"
Returns the authority domain's explanation for the result.  Be aware that the
authority domain may be a malicious party and thus the authority explanation
should not be trusted blindly.  See \s-1RFC\s0 4408, 10.5, for a detailed discussion
of this issue.
.RE
.RS 4
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Server, Error, \*(L"eval\*(R" in perlfunc
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>
                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Result5.18.3pm                    0100644 0001750 0001750 00000036773 12566242050 024631  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Result 3"
.TH Mail::SPF::Result 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Result \- SPF result class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
For the general usage of \fIMail::SPF::Result\fR objects in code that calls
Mail::SPF, see Mail::SPF.  For the detailed interface of \fIMail::SPF::Result\fR
and its derivatives, see below.
.SS "Throwing results"
.IX Subsection "Throwing results"
.Vb 3
\&    package Mail::SPF::Foo;
\&    use Error \*(Aq:try\*(Aq;
\&    use Mail::SPF::Result;
\&
\&    sub foo {
\&        if (...) {
\&            $server\->throw_result(\*(Aqpass\*(Aq, $request)
\&        }
\&        else {
\&            $server\->throw_result(\*(Aqpermerror\*(Aq, $request, \*(AqInvalid foo\*(Aq);
\&        }
\&    }
.Ve
.SS "Catching results"
.IX Subsection "Catching results"
.Vb 3
\&    package Mail::SPF::Bar;
\&    use Error \*(Aq:try\*(Aq;
\&    use Mail::SPF::Foo;
\&
\&    try {
\&        Mail::SPF::Foo\->foo();
\&    }
\&    catch Mail::SPF::Result with {
\&        my ($result) = @_;
\&        ...
\&    };
.Ve
.SS "Using results"
.IX Subsection "Using results"
.Vb 7
\&    my $result_name     = $result\->name;
\&    my $result_code     = $result\->code;
\&    my $request         = $result\->request;
\&    my $local_exp       = $result\->local_explanation;
\&    my $authority_exp   = $result\->authority_explanation
\&        if $result\->can(\*(Aqauthority_explanation\*(Aq);
\&    my $spf_header      = $result\->received_spf_header;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Result\fR represents the result of an \s-1SPF\s0
request.
.PP
There is usually no need to construct an \s-1SPF\s0 result object directly using the
\&\f(CW\*(C`new\*(C'\fR constructor.  Instead, use the \f(CW\*(C`throw\*(C'\fR class method to signal to the
calling code that a definite \s-1SPF\s0 result has been determined.  In other words,
use Mail::SPF::Result and its derivatives just like exceptions.  See Error
or \*(L"eval\*(R" in perlfunc for how to handle exceptions in Perl.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.ie n .IP "\fBnew($server, \fB$request\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.el .IP "\fBnew($server, \f(CB$request\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.IX Item "new($server, $request): returns Mail::SPF::Result"
.PD 0
.ie n .IP "\fBnew($server, \fB$request\fB, \f(BI$text\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.el .IP "\fBnew($server, \f(CB$request\fB, \f(CB$text\fB)\fR: returns \fIMail::SPF::Result\fR" 4
.IX Item "new($server, $request, $text): returns Mail::SPF::Result"
.PD
Creates a new \s-1SPF\s0 result object and associates the given \fIMail::SPF::Server\fR
and \fIMail::SPF::Request\fR objects with it.  An optional result text may be
specified.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.ie n .IP "\fBthrow($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request): throws Mail::SPF::Result"
.PD 0
.ie n .IP "\fBthrow($server, \fB$request\fB, \f(BI$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB, \f(CB$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request, $text): throws Mail::SPF::Result"
.PD
Throws a new \s-1SPF\s0 result object, associating the given \fIMail::SPF::Server\fR and
\&\fIMail::SPF::Request\fR objects with it.  An optional result text may be
specified.
.Sp
\&\fINote\fR:  Do not write code invoking \f(CW\*(C`throw\*(C'\fR on \fIliteral\fR result class names
as this would ignore any derivative result classes provided by \fBMail::SPF\fR
extension modules.  Invoke the \f(CW\*(C`throw_result\*(C'\fR
method on a \fIMail::SPF::Server\fR object instead.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
\&\fIAbstract\fR.  Returns the result name of the result class (or object).  For
classes of the \fIMail::SPF::Result::*\fR hierarchy, this roughly corresponds to
the trailing part of the class name.  For example, returns \f(CW\*(C`neutral\-by\-default\*(C'\fR
if invoked on \fIMail::SPF::Result::NeutralByDefault\fR.  Also see the \*(L"code\*(R"
method.  This method may also be used as an instance method.
.Sp
This method must be implemented by sub-classes of Mail::SPF::Result for which
the result \fIname\fR differs from the result \fIcode\fR.
.IP "\fBclass\fR: returns \fIclass\fR" 4
.IX Item "class: returns class"
.PD 0
.IP "\fBclass($name)\fR: returns \fIclass\fR" 4
.IX Item "class($name): returns class"
.PD
Maps the given result name to the corresponding \fIMail::SPF::Result::*\fR class,
or returns the result base class (the class on which it is invoked) if no
result name is given.  If an unknown result name is specified, returns
\&\fBundef\fR.
.IP "\fBisa_by_name($name)\fR: returns \fIboolean\fR" 4
.IX Item "isa_by_name($name): returns boolean"
If the class (or object) on which this method is invoked represents the given
result name (or a derivative name), returns \fBtrue\fR.  Returns \fBfalse\fR
otherwise.  This method may also be used as an instance method.
.Sp
For example, \f(CW\*(C`Mail::SPF::Result::NeutralByDefault\->isa_by_name(\*(Aqneutral\*(Aq)\*(C'\fR
returns \fBtrue\fR.
.IP "\fBcode\fR: returns \fIstring\fR" 4
.IX Item "code: returns string"
\&\fIAbstract\fR.  Returns the basic \s-1SPF\s0 result code (\f(CW"pass"\fR, \f(CW"fail"\fR,
\&\f(CW"softfail"\fR, \f(CW"neutral"\fR, \f(CW"none"\fR, \f(CW"error"\fR, \f(CW"permerror"\fR,
\&\f(CW"temperror"\fR) of the result class on which it is invoked.  All valid result
codes are valid result names as well, the reverse however does not apply.  This
method may also be used as an instance method.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Result.
.IP "\fBis_code($code)\fR: returns \fIboolean\fR" 4
.IX Item "is_code($code): returns boolean"
If the class (or object) on which this method is invoked represents the given
result code, returns \fBtrue\fR.  Returns \fBfalse\fR otherwise.  This method may
also be used as an instance method.
.Sp
\&\fINote\fR:  The \*(L"isa_by_name\*(R" method provides a superset of this method's
functionality.
.IP "\fBreceived_spf_header_name\fR: returns \fIstring\fR" 4
.IX Item "received_spf_header_name: returns string"
Returns \fB'Received\-SPF'\fR as the field name for \f(CW\*(C`Received\-SPF\*(C'\fR header fields.
This method should be overridden by \fBMail::SPF\fR extension modules that provide
non-standard features (such as local policy) with the capacity to dilute the
purity of \s-1SPF\s0 results, in order not to deceive users of the header field into
mistaking it as an indication of a natural \s-1SPF\s0 result.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBthrow\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw: throws Mail::SPF::Result"
.PD 0
.ie n .IP "\fBthrow($server, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request): throws Mail::SPF::Result"
.ie n .IP "\fBthrow($server, \fB$request\fB, \f(BI$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow($server, \f(CB$request\fB, \f(CB$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw($server, $request, $text): throws Mail::SPF::Result"
.PD
Re-throws an existing \s-1SPF\s0 result object.  If \fIMail::SPF::Server\fR and
\&\fIMail::SPF::Request\fR objects are specified, associates them with the result
object, replacing the prior server and request objects.  If a result text is
specified as well, overrides the prior result text.
.IP "\fBserver\fR: returns \fIMail::SPF::Server\fR" 4
.IX Item "server: returns Mail::SPF::Server"
Returns the Mail::SPF server object that produced the result at hand.
.IP "\fBrequest\fR: returns \fIMail::SPF::Request\fR" 4
.IX Item "request: returns Mail::SPF::Request"
Returns the \s-1SPF\s0 request that led to the result at hand.
.IP "\fBtext\fR: returns \fIstring\fR" 4
.IX Item "text: returns string"
Returns the text message of the result object.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Returns the result's name and text message formatted as a string.  You can
simply use a Mail::SPF::Result object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\*(R"\s0.
.IP "\fBlocal_explanation\fR: returns \fIstring\fR; throws \fIMail::SPF::EDNSError\fR, \fIMail::SPF::EInvalidMacroString\fR" 4
.IX Item "local_explanation: returns string; throws Mail::SPF::EDNSError, Mail::SPF::EInvalidMacroString"
Returns a locally generated explanation for the result.
.Sp
The local explanation is prefixed with the authority domain whose sender policy
is responsible for the result.  If the responsible sender policy referred to
another domain's policy (using the \f(CW\*(C`include\*(C'\fR mechanism or the \f(CW\*(C`redirect\*(C'\fR
modifier), that other domain which is \fIdirectly\fR responsible for the result is
also included in the local explanation's head.  For example:
.Sp
.Vb 1
\&    example.com: <local\-explanation>
.Ve
.Sp
The authority domain \f(CW\*(C`example.com\*(C'\fR's sender policy is directly responsible for
the result.
.Sp
.Vb 1
\&    example.com ... other.example.org: <local\-explanation>
.Ve
.Sp
The authority domain \f(CW\*(C`example.com\*(C'\fR (directly or indirectly) referred to the
domain \f(CW\*(C`other.example.org\*(C'\fR, whose sender policy then led to the result.
.IP "\fBreceived_spf_header\fR: returns \fIstring\fR" 4
.IX Item "received_spf_header: returns string"
Returns a string containing an appropriate \f(CW\*(C`Received\-SPF\*(C'\fR header field for the
result object.  The header field is not line-wrapped and contains no trailing
newline character.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Result object is used as a \fIstring\fR, the \*(L"stringify\*(R" method
is used to convert the object into a string.
.SH "RESULT CLASSES"
.IX Header "RESULT CLASSES"
The following result classes are provided:
.IP "\(bu" 4
\&\fIMail::SPF::Result::Pass\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::Fail\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::SoftFail\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::Neutral\fR
.RS 4
.IP "\(bu" 4
\&\fIMail::SPF::Result::NeutralByDefault\fR
.Sp
This is a special case of the \f(CW\*(C`neutral\*(C'\fR result that is thrown as a default
when \*(L"falling off\*(R" the end of the record during evaluation.  See \s-1RFC 4408,
4.7.\s0
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fIMail::SPF::Result::None\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::Error\fR
.RS 4
.IP "\(bu" 4
\&\fIMail::SPF::Result::PermError\fR
.IP "\(bu" 4
\&\fIMail::SPF::Result::TempError\fR
.RE
.RS 4
.RE
.PP
The following result classes have additional functionality:
.IP "\fIMail::SPF::Result::Fail\fR" 4
.IX Item "Mail::SPF::Result::Fail"
The following additional instance method is provided:
.RS 4
.IP "\fBauthority_explanation\fR: returns \fIstring\fR; throws \fIMail::SPF::EDNSError\fR, \fIMail::SPF::EInvalidMacroString\fR" 4
.IX Item "authority_explanation: returns string; throws Mail::SPF::EDNSError, Mail::SPF::EInvalidMacroString"
Returns the authority domain's explanation for the result.  Be aware that the
authority domain may be a malicious party and thus the authority explanation
should not be trusted blindly.  See \s-1RFC 4408, 10.5,\s0 for a detailed discussion
of this issue.
.RE
.RS 4
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Server, Error, \*(L"eval\*(R" in perlfunc
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>
     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::SenderIPAddrMech.3pm              0100644 0001750 0001750 00000012070 12566242050 026060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::SenderIPAddrMech 3"
.TH Mail::SPF::SenderIPAddrMech 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::SenderIPAddrMech \- Abstract base class for SPF record mechanisms
that operate on the SMTP sender's IP address
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::SenderIPAddrMech\fR is an abstract base class for \s-1SPF\s0 record
mechanisms that operate on the \s-1SMTP\s0 sender's \s-1IP\s0 address.  It cannot be
instantiated directly.  Create an instance of a concrete sub-class instead.
.SS "Constructors"
.IX Subsection "Constructors"
See \*(L"Constructors\*(R" in Mail::SPF::Mech.
.SS "Class methods"
.IX Subsection "Class methods"
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.SS "Instance methods"
.IX Subsection "Instance methods"
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Mech
.PP
Mail::SPF::Mech::IP4,
Mail::SPF::Mech::IP6,
Mail::SPF::Mech::A,
Mail::SPF::Mech::MX,
Mail::SPF::Mech::PTR
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::SenderIPAddrMech5.16.3pm          0100644 0001750 0001750 00000011547 12566242062 026405  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::SenderIPAddrMech 3"
.TH Mail::SPF::SenderIPAddrMech 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::SenderIPAddrMech \- Abstract base class for SPF record mechanisms
that operate on the SMTP sender's IP address
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::SenderIPAddrMech\fR is an abstract base class for \s-1SPF\s0 record
mechanisms that operate on the \s-1SMTP\s0 sender's \s-1IP\s0 address.  It cannot be
instantiated directly.  Create an instance of a concrete sub-class instead.
.SS "Constructors"
.IX Subsection "Constructors"
See \*(L"Constructors\*(R" in Mail::SPF::Mech.
.SS "Class methods"
.IX Subsection "Class methods"
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.SS "Instance methods"
.IX Subsection "Instance methods"
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Mech
.PP
Mail::SPF::Mech::IP4,
Mail::SPF::Mech::IP6,
Mail::SPF::Mech::A,
Mail::SPF::Mech::MX,
Mail::SPF::Mech::PTR
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>
                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::SenderIPAddrMech5.18.3pm          0100644 0001750 0001750 00000012070 12566242050 026374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::SenderIPAddrMech 3"
.TH Mail::SPF::SenderIPAddrMech 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::SenderIPAddrMech \- Abstract base class for SPF record mechanisms
that operate on the SMTP sender's IP address
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::SenderIPAddrMech\fR is an abstract base class for \s-1SPF\s0 record
mechanisms that operate on the \s-1SMTP\s0 sender's \s-1IP\s0 address.  It cannot be
instantiated directly.  Create an instance of a concrete sub-class instead.
.SS "Constructors"
.IX Subsection "Constructors"
See \*(L"Constructors\*(R" in Mail::SPF::Mech.
.SS "Class methods"
.IX Subsection "Class methods"
See \*(L"Class methods\*(R" in Mail::SPF::Mech.
.SS "Instance methods"
.IX Subsection "Instance methods"
See \*(L"Instance methods\*(R" in Mail::SPF::Mech.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Mech
.PP
Mail::SPF::Mech::IP4,
Mail::SPF::Mech::IP6,
Mail::SPF::Mech::A,
Mail::SPF::Mech::MX,
Mail::SPF::Mech::PTR
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Server.3pm                        0100644 0001750 0001750 00000051337 12566242051 024277  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Server 3"
.TH Mail::SPF::Server 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Server \- Server class for processing SPF requests
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF;
\&
\&    my $spf_server  = Mail::SPF::Server\->new(
\&        # Optional custom default for authority explanation:
\&        default_authority_explanation =>
\&            \*(AqSee http://www.%{d}/why/id=%{S};ip=%{I};r=%{R}\*(Aq
\&    );
\&
\&    my $result      = $spf_server\->process($request);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Server\fR is a server class for processing \s-1SPF\s0 requests.  Each
server instance can be configured with specific processing parameters.  Also,
the default \fINet::DNS::Resolver\fR \s-1DNS\s0 resolver used for making \s-1DNS\s0 look-ups can
be overridden with a custom resolver object.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Server\fR" 4
.IX Item "new(%options): returns Mail::SPF::Server"
Creates a new server object for processing \s-1SPF\s0 requests.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBdefault_authority_explanation\fR" 4
.IX Item "default_authority_explanation"
A \fIstring\fR denoting the default (not macro-expanded) authority explanation
string to use if the authority domain does not specify an explanation string of
its own.  Defaults to:
.Sp
.Vb 1
\&    \*(AqPlease see http://www.openspf.org/Why?s=%{_scope};id=%{S};ip=%{C};r=%{R}\*(Aq
.Ve
.Sp
As can be seen from the default, a non-standard \f(CW\*(C`_scope\*(C'\fR pseudo macro is
supported that expands to the name of the identity's scope.  (Note: Do \fInot\fR
use any non-standard macros in explanation strings published in \s-1DNS.\s0)
.IP "\fBhostname\fR" 4
.IX Item "hostname"
A \fIstring\fR denoting the local system's fully qualified host name that should
be used for expanding the \f(CW\*(C`r\*(C'\fR macro in explanation strings.  Defaults to the
system's configured host name.
.IP "\fBdns_resolver\fR" 4
.IX Item "dns_resolver"
An optional \s-1DNS\s0 resolver object.  If none is specified, a new \fINet::DNS::Resolver\fR
object is used.  The resolver object may be of a different class, but it must
provide an interface similar to \fINet::DNS::Resolver\fR \*(-- at least the \f(CW\*(C`send\*(C'\fR
and \f(CW\*(C`errorstring\*(C'\fR methods must be supported, and the \f(CW\*(C`send\*(C'\fR method must
return either an object of class \fINet::DNS::Packet\fR, or, in the case of an
error, \fBundef\fR.
.IP "\fBquery_rr_types\fR" 4
.IX Item "query_rr_types"
For which \s-1RR\s0 types to query when looking up and selecting \s-1SPF\s0 records.  The
following values are supported:
.RS 4
.IP "\fBMail::SPF::Server\->query_rr_type_all\fR" 4
.IX Item "Mail::SPF::Server->query_rr_type_all"
Both \f(CW\*(C`TXT\*(C'\fR and \f(CW\*(C`SPF\*(C'\fR type RRs.
.IP "\fBMail::SPF::Server\->query_rr_type_txt\fR (default)" 4
.IX Item "Mail::SPF::Server->query_rr_type_txt (default)"
\&\f(CW\*(C`TXT\*(C'\fR type RRs only.
.IP "\fBMail::SPF::Server\->query_rr_type_spf\fR" 4
.IX Item "Mail::SPF::Server->query_rr_type_spf"
\&\f(CW\*(C`SPF\*(C'\fR type RRs only.
.RE
.RS 4
.Sp
For years \fBMail::SPF\fR has defaulted to looking up both \f(CW\*(C`SPF\*(C'\fR and \f(CW\*(C`TXT\*(C'\fR type
RRs as recommended by \s-1RFC 4408. \s0 Experience has shown, however, that a
significant portion of name servers suffer from serious brain damage with
regard to the handling of queries for \s-1RR\s0 types that are unknown to them, such
as the \f(CW\*(C`SPF\*(C'\fR \s-1RR\s0 type.  Consequently \fBMail::SPF\fR now defaults to looking up
only \f(CW\*(C`TXT\*(C'\fR type RRs.  This may be overridden by setting the \fBquery_rr_types\fR
option.
.Sp
See \s-1RFC 4408, 3.1.1,\s0 for a discussion of the topic, as well as the description
of the \*(L"select_record\*(R" method.
.RE
.IP "\fBmax_dns_interactive_terms\fR" 4
.IX Item "max_dns_interactive_terms"
An \fIinteger\fR denoting the maximum number of terms (mechanisms and modifiers)
per \s-1SPF\s0 check that perform \s-1DNS\s0 look-ups, as defined in \s-1RFC 4408, 10.1,\s0
paragraph 6.  If \fBundef\fR is specified, there is no limit on the number of such
terms.  Defaults to \fB10\fR, which is the value defined in \s-1RFC 4408.\s0
.Sp
A value above the default is \fIstrongly discouraged\fR for security reasons.  A
value below the default has implications with regard to the predictability of
\&\s-1SPF\s0 results.  Only deviate from the default if you know what you are doing!
.IP "\fBmax_name_lookups_per_term\fR" 4
.IX Item "max_name_lookups_per_term"
An \fIinteger\fR denoting the maximum number of \s-1DNS\s0 name look-ups per term
(mechanism or modifier), as defined in \s-1RFC 4408, 10.1,\s0 paragraph 7.  If
\&\fBundef\fR is specified, there is no limit on the number of look-ups performed.
Defaults to \fB10\fR, which is the value defined in \s-1RFC 4408.\s0
.Sp
A value above the default is \fIstrongly discouraged\fR for security reasons.  A
value below the default has implications with regard to the predictability of
\&\s-1SPF\s0 results.  Only deviate from the default if you know what you are doing!
.IP "\fBmax_name_lookups_per_mx_mech\fR" 4
.IX Item "max_name_lookups_per_mx_mech"
.PD 0
.IP "\fBmax_name_lookups_per_ptr_mech\fR" 4
.IX Item "max_name_lookups_per_ptr_mech"
.PD
An \fIinteger\fR denoting the maximum number of \s-1DNS\s0 name look-ups per \fBmx\fR or \fBptr\fR
mechanism, respectively.  Defaults to the value of the \f(CW\*(C`max_name_lookups_per_term\*(C'\fR
option.  See there for additional information and security notes.
.IP "\fBmax_void_dns_lookups\fR" 4
.IX Item "max_void_dns_lookups"
An \fIinteger\fR denoting the maximum number of \*(L"void\*(R" \s-1DNS\s0 look-ups per \s-1SPF\s0 check,
i.e. the number of \s-1DNS\s0 look-ups that were caused by DNS-interactive terms and
macros (as defined in \s-1RFC 4408, 10.1,\s0 paragraphs 6 and 7) and that are allowed
to return an empty answer with \s-1RCODE 0\s0 or \s-1RCODE 3 \s0(\f(CW\*(C`NXDOMAIN\*(C'\fR) before
processing is aborted with a \f(CW\*(C`permerror\*(C'\fR result.  If \fBundef\fR is specified,
there is no stricter limit on the number of void \s-1DNS\s0 look-ups beyond the usual
processing limits.  Defaults to \fB2\fR.
.Sp
Specifically, the \s-1DNS\s0 look-ups that are subject to this limit are those caused
by the \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`mx\*(C'\fR, \f(CW\*(C`ptr\*(C'\fR, and \f(CW\*(C`exists\*(C'\fR mechanisms and the \f(CW\*(C`p\*(C'\fR macro.
.Sp
A value of \fB2\fR is likely to prevent effective DoS attacks against third-party
victim domains.  However, a definite limit may cause \f(CW\*(C`permerror\*(C'\fR results even
with certain (overly complex) innocent sender policies where useful results
would normally be returned.
.RE
.RS 4
.RE
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBresult_class\fR: returns \fIclass\fR" 4
.IX Item "result_class: returns class"
.PD 0
.IP "\fBresult_class($name)\fR: returns \fIclass\fR" 4
.IX Item "result_class($name): returns class"
.PD
Returns a \fIMail::SPF::Result\fR descendent class determined from the given
result name via the server's inherent result base class, or returns the
server's inherent result base class if no result name is given.  This method
may also be used as an instance method.
.Sp
\&\fINote\fR:  Do not write code invoking class methods on \fIliteral\fR result class
names as this would ignore any derivative result classes provided by
\&\fBMail::SPF\fR extension modules.
.ie n .IP "\fBthrow_result($name, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow_result($name, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw_result($name, $request): throws Mail::SPF::Result"
.PD 0
.ie n .IP "\fBthrow_result($name, \fB$request\fB, \f(BI$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow_result($name, \f(CB$request\fB, \f(CB$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw_result($name, $request, $text): throws Mail::SPF::Result"
.PD
Throws a \fIMail::SPF::Result\fR descendant determined from the given result name
via the server's inherent result base class, passing an optional result text
and associating the given \fIMail::SPF::Request\fR object with the result object.
This method may also be used as an instance method.
.Sp
\&\fINote\fR:  Do not write code invoking \f(CW\*(C`throw\*(C'\fR on \fIliteral\fR result class names
as this would ignore any derivative result classes provided by \fBMail::SPF\fR
extension modules.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBprocess($request)\fR: returns \fIMail::SPF::Result\fR" 4
.IX Item "process($request): returns Mail::SPF::Result"
Processes the given \fIMail::SPF::Request\fR object, queries the authoritative
domain for an \s-1SPF\s0 sender policy (see the description of the \*(L"select_record\*(R"
method), evaluates the policy with regard to the given identity and other
request parameters, and returns a \fIMail::SPF::Result\fR object denoting the
result of the policy evaluation.  See \s-1RFC 4408, 4,\s0 and \s-1RFC 4406, 4,\s0 for
details.
.IP "\fBselect_record($request)\fR: returns \fIMail::SPF::Record\fR; throws \fIMail::SPF::EDNSError\fR, \fIMail::SPF::ENoAcceptableRecord\fR, \fIMail::SPF::ERedundantAcceptableRecords\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "select_record($request): returns Mail::SPF::Record; throws Mail::SPF::EDNSError, Mail::SPF::ENoAcceptableRecord, Mail::SPF::ERedundantAcceptableRecords, Mail::SPF::ESyntaxError"
Queries the authority domain of the given \fIMail::SPF::Request\fR object for \s-1SPF\s0
sender policy records and, if multiple records are available, selects the
record of the highest acceptable record version that covers the requested
scope.
.Sp
More precisely, the following algorithm is performed (assuming that both \f(CW\*(C`TXT\*(C'\fR
and \f(CW\*(C`SPF\*(C'\fR \s-1RR\s0 types are being queried):
.RS 4
.IP "1." 4
Determine the authority domain, the set of acceptable \s-1SPF\s0 record versions, and
the identity scope from the given request object.
.IP "2." 4
Query the authority domain for \s-1SPF\s0 records of the \f(CW\*(C`SPF\*(C'\fR \s-1DNS RR\s0 type,
discarding any records that are of an inacceptable version or do not cover the
desired scope.
.Sp
If this yields no \s-1SPF\s0 records, query the authority domain for \s-1SPF\s0 records of
the \f(CW\*(C`TXT\*(C'\fR \s-1DNS RR\s0 type, discarding any records that are of an inacceptable
version or do not cover the desired scope.
.Sp
If still no acceptable \s-1SPF\s0 records could be found, throw a
\&\fIMail::SPF::ENoAcceptableRecord\fR exception.
.IP "3." 4
Discard all records but those of the highest acceptable version found.
.Sp
If exactly one record remains, return it.  Otherwise, throw a
\&\fIMail::SPF::ERedundantAcceptableRecords\fR exception.
.RE
.RS 4
.Sp
If the querying of either \s-1RR\s0 type has been disabled via the \*(L"new\*(R"
constructor's \f(CW\*(C`query_rr_types\*(C'\fR option, the respective part in step 2 will
be skipped.
.Sp
\&\fIMail::SPF::EDNSError\fR exceptions due to \s-1DNS\s0 look-ups and
\&\fIMail::SPF::ESyntaxError\fR exceptions due to invalid acceptable records may
also be thrown.
.RE
.ie n .IP "\fBget_acceptable_records_from_packet($packet, \fB$rr_type\fB, \e@versions, \f(BI$scope\fB, \f(CB$domain\fB)\fR: returns \fIlist\fR of \fIMail::SPF::Record\fR" 4
.el .IP "\fBget_acceptable_records_from_packet($packet, \f(CB$rr_type\fB, \e@versions, \f(CB$scope\fB, \f(CB$domain\fB)\fR: returns \fIlist\fR of \fIMail::SPF::Record\fR" 4
.IX Item "get_acceptable_records_from_packet($packet, $rr_type, @versions, $scope, $domain): returns list of Mail::SPF::Record"
Filters from the given \fINet::DNS::Packet\fR object all resource records of the
given \s-1RR\s0 type and for the given domain name, discarding any records that are
not \s-1SPF\s0 records at all, that are of an inacceptable \s-1SPF\s0 record version, or that
do not cover the given scope.  Returns a list of acceptable records.
.ie n .IP "\fBdns_lookup($domain, \fB$rr_type\fB)\fR: returns \fINet::DNS::Packet\fR; throws \fIMail::SPF::EDNSTimeout\fR, \fIMail::SPF::EDNSError\fR" 4
.el .IP "\fBdns_lookup($domain, \f(CB$rr_type\fB)\fR: returns \fINet::DNS::Packet\fR; throws \fIMail::SPF::EDNSTimeout\fR, \fIMail::SPF::EDNSError\fR" 4
.IX Item "dns_lookup($domain, $rr_type): returns Net::DNS::Packet; throws Mail::SPF::EDNSTimeout, Mail::SPF::EDNSError"
Queries the \s-1DNS\s0 using the configured resolver for resource records of the
desired type at the specified domain and returns a \fINet::DNS::Packet\fR object
if an answer packet was received.  Throws a \fIMail::SPF::EDNSTimeout\fR exception
if a \s-1DNS\s0 time-out occurred.  Throws a \fIMail::SPF::EDNSError\fR exception if an
error (other than \s-1RCODE 3 AKA \s0\f(CW\*(C`NXDOMAIN\*(C'\fR) occurred.
.IP "\fBcount_dns_interactive_term($request)\fR: throws \fIMail::SPF::EProcessingLimitExceeded\fR" 4
.IX Item "count_dns_interactive_term($request): throws Mail::SPF::EProcessingLimitExceeded"
Increments by one the count of DNS-interactive mechanisms and modifiers that
have been processed so far during the evaluation of the given
\&\fIMail::SPF::Request\fR object.  If this exceeds the configured limit (see the
\&\*(L"new\*(R" constructor's \f(CW\*(C`max_dns_interactive_terms\*(C'\fR option), throws a
\&\fIMail::SPF::EProcessingLimitExceeded\fR exception.
.Sp
This method is supposed to be called by the \f(CW\*(C`match\*(C'\fR and \f(CW\*(C`process\*(C'\fR methods of
\&\fIMail::SPF::Mech\fR and \fIMail::SPF::Mod\fR sub-classes before (and only if) they
do any \s-1DNS\s0 look-ups.
.IP "\fBcount_void_dns_lookup($request)\fR: throws \fIMail::SPF::EProcessingLimitExceeded\fR" 4
.IX Item "count_void_dns_lookup($request): throws Mail::SPF::EProcessingLimitExceeded"
Increments by one the count of \*(L"void\*(R" \s-1DNS\s0 look-ups that have occurred so far
during the evaluation of the given \fIMail::SPF::Request\fR object.  If this
exceeds the configured limit (see the \*(L"new\*(R" constructor's \f(CW\*(C`max_void_dns_lookups\*(C'\fR
option), throws a \fIMail::SPF::EProcessingLimitExceeded\fR exception.
.Sp
This method is supposed to be called by any code after any calls to the
\&\*(L"dns_lookup\*(R" method whenever (i) no answer records were returned, and (ii)
this fact is a possible indication of a DoS attack against a third-party victim
domain, and (iii) the number of \*(L"void\*(R" look-ups is not already constrained
otherwise (as for example is the case with the \f(CW\*(C`include\*(C'\fR mechanism and the
\&\f(CW\*(C`redirect\*(C'\fR modifier).  Specifically, this applies to look-ups performed by the
\&\f(CW\*(C`a\*(C'\fR, \f(CW\*(C`mx\*(C'\fR, \f(CW\*(C`ptr\*(C'\fR, and \f(CW\*(C`exists\*(C'\fR mechanisms and the \f(CW\*(C`p\*(C'\fR macro.
.IP "\fBdefault_authority_explanation\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "default_authority_explanation: returns Mail::SPF::MacroString"
Returns the default authority explanation as a \fIMacroString\fR object.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`default_authority_explanation\*(C'\fR
option.
.IP "\fBhostname\fR: returns \fIstring\fR" 4
.IX Item "hostname: returns string"
Returns the local system's host name.  See the description of the \*(L"new\*(R"
constructor's \f(CW\*(C`hostname\*(C'\fR option.
.IP "\fBdns_resolver\fR: returns \fINet::DNS::Resolver\fR or compatible object" 4
.IX Item "dns_resolver: returns Net::DNS::Resolver or compatible object"
Returns the \s-1DNS\s0 resolver object of the server object.  See the description of
the \*(L"new\*(R" constructor's \f(CW\*(C`dns_resolver\*(C'\fR option.
.IP "\fBquery_rr_types\fR: returns \fIinteger\fR" 4
.IX Item "query_rr_types: returns integer"
Returns a value denoting the \s-1RR\s0 types for which to query when looking up and
selecting \s-1SPF\s0 records.  See the description of the \*(L"new\*(R" constructor's
\&\f(CW\*(C`query_rr_types\*(C'\fR option.
.IP "\fBmax_dns_interactive_terms\fR: returns \fIinteger\fR" 4
.IX Item "max_dns_interactive_terms: returns integer"
.PD 0
.IP "\fBmax_name_lookups_per_term\fR: returns \fIinteger\fR" 4
.IX Item "max_name_lookups_per_term: returns integer"
.IP "\fBmax_name_lookups_per_mx_mech\fR: returns \fIinteger\fR" 4
.IX Item "max_name_lookups_per_mx_mech: returns integer"
.IP "\fBmax_name_lookups_per_ptr_mech\fR: returns \fIinteger\fR" 4
.IX Item "max_name_lookups_per_ptr_mech: returns integer"
.IP "\fBmax_void_dns_lookups\fR: returns \fIinteger\fR" 4
.IX Item "max_void_dns_lookups: returns integer"
.PD
Return the limit values of the server object.  See the description of the
\&\*(L"new\*(R" constructor's corresponding options.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Request, Mail::SPF::Result
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Server5.16.3pm                    0100644 0001750 0001750 00000050513 12566242063 024607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Server 3"
.TH Mail::SPF::Server 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Server \- Server class for processing SPF requests
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF;
\&
\&    my $spf_server  = Mail::SPF::Server\->new(
\&        # Optional custom default for authority explanation:
\&        default_authority_explanation =>
\&            \*(AqSee http://www.%{d}/why/id=%{S};ip=%{I};r=%{R}\*(Aq
\&    );
\&
\&    my $result      = $spf_server\->process($request);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Server\fR is a server class for processing \s-1SPF\s0 requests.  Each
server instance can be configured with specific processing parameters.  Also,
the default \fINet::DNS::Resolver\fR \s-1DNS\s0 resolver used for making \s-1DNS\s0 look-ups can
be overridden with a custom resolver object.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Server\fR" 4
.IX Item "new(%options): returns Mail::SPF::Server"
Creates a new server object for processing \s-1SPF\s0 requests.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBdefault_authority_explanation\fR" 4
.IX Item "default_authority_explanation"
A \fIstring\fR denoting the default (not macro-expanded) authority explanation
string to use if the authority domain does not specify an explanation string of
its own.  Defaults to:
.Sp
.Vb 1
\&    \*(AqPlease see http://www.openspf.net/Why?s=%{_scope};id=%{S};ip=%{C};r=%{R}\*(Aq
.Ve
.Sp
As can be seen from the default, a non-standard \f(CW\*(C`_scope\*(C'\fR pseudo macro is
supported that expands to the name of the identity's scope.  (Note: Do \fInot\fR
use any non-standard macros in explanation strings published in \s-1DNS\s0.)
.IP "\fBhostname\fR" 4
.IX Item "hostname"
A \fIstring\fR denoting the local system's fully qualified host name that should
be used for expanding the \f(CW\*(C`r\*(C'\fR macro in explanation strings.  Defaults to the
system's configured host name.
.IP "\fBdns_resolver\fR" 4
.IX Item "dns_resolver"
An optional \s-1DNS\s0 resolver object.  If none is specified, a new \fINet::DNS::Resolver\fR
object is used.  The resolver object may be of a different class, but it must
provide an interface similar to \fINet::DNS::Resolver\fR \*(-- at least the \f(CW\*(C`send\*(C'\fR
and \f(CW\*(C`errorstring\*(C'\fR methods must be supported, and the \f(CW\*(C`send\*(C'\fR method must
return either an object of class \fINet::DNS::Packet\fR, or, in the case of an
error, \fBundef\fR.
.IP "\fBquery_rr_types\fR" 4
.IX Item "query_rr_types"
For which \s-1RR\s0 types to query when looking up and selecting \s-1SPF\s0 records.  The
following values are supported:
.RS 4
.IP "\fBMail::SPF::Server\->query_rr_type_all\fR (default)" 4
.IX Item "Mail::SPF::Server->query_rr_type_all (default)"
Both \f(CW\*(C`SPF\*(C'\fR and \f(CW\*(C`TXT\*(C'\fR type RRs.
.IP "\fBMail::SPF::Server\->query_rr_type_spf\fR" 4
.IX Item "Mail::SPF::Server->query_rr_type_spf"
\&\f(CW\*(C`SPF\*(C'\fR type RRs only.
.IP "\fBMail::SPF::Server\->query_rr_type_txt\fR" 4
.IX Item "Mail::SPF::Server->query_rr_type_txt"
\&\f(CW\*(C`TXT\*(C'\fR type RRs only.
.RE
.RS 4
.Sp
Some (few) name servers suffer from serious brain damage with regard to the
handling of queries for \s-1RR\s0 types that are unknown to them, such as the \f(CW\*(C`SPF\*(C'\fR
\&\s-1RR\s0 type, so some (few) \fBMail::SPF\fR users have expressed the desire for a way
to disable the retrieval of \f(CW\*(C`SPF\*(C'\fR type RRs.  It is, however, a better idea to
pressure the manufacturers of such broken name servers into fixing their
products.
.Sp
See \s-1RFC\s0 4408, 3.1.1, for a discussion of the topic, as well as the description
of the \*(L"select_record\*(R" method.
.RE
.IP "\fBmax_dns_interactive_terms\fR" 4
.IX Item "max_dns_interactive_terms"
An \fIinteger\fR denoting the maximum number of terms (mechanisms and modifiers)
per \s-1SPF\s0 check that perform \s-1DNS\s0 look-ups, as defined in \s-1RFC\s0 4408, 10.1,
paragraph 6.  If \fBundef\fR is specified, there is no limit on the number of such
terms.  Defaults to \fB10\fR, which is the value defined in \s-1RFC\s0 4408.
.Sp
A value above the default is \fIstrongly discouraged\fR for security reasons.  A
value below the default has implications with regard to the predictability of
\&\s-1SPF\s0 results.  Only deviate from the default if you know what you are doing!
.IP "\fBmax_name_lookups_per_term\fR" 4
.IX Item "max_name_lookups_per_term"
An \fIinteger\fR denoting the maximum number of \s-1DNS\s0 name look-ups per term
(mechanism or modifier), as defined in \s-1RFC\s0 4408, 10.1, paragraph 7.  If
\&\fBundef\fR is specified, there is no limit on the number of look-ups performed.
Defaults to \fB10\fR, which is the value defined in \s-1RFC\s0 4408.
.Sp
A value above the default is \fIstrongly discouraged\fR for security reasons.  A
value below the default has implications with regard to the predictability of
\&\s-1SPF\s0 results.  Only deviate from the default if you know what you are doing!
.IP "\fBmax_name_lookups_per_mx_mech\fR" 4
.IX Item "max_name_lookups_per_mx_mech"
.PD 0
.IP "\fBmax_name_lookups_per_ptr_mech\fR" 4
.IX Item "max_name_lookups_per_ptr_mech"
.PD
An \fIinteger\fR denoting the maximum number of \s-1DNS\s0 name look-ups per \fBmx\fR or \fBptr\fR
mechanism, respectively.  Defaults to the value of the \f(CW\*(C`max_name_lookups_per_term\*(C'\fR
option.  See there for additional information and security notes.
.IP "\fBmax_void_dns_lookups\fR" 4
.IX Item "max_void_dns_lookups"
An \fIinteger\fR denoting the maximum number of \*(L"void\*(R" \s-1DNS\s0 look-ups per \s-1SPF\s0 check,
i.e. the number of \s-1DNS\s0 look-ups that were caused by DNS-interactive terms and
macros (as defined in \s-1RFC\s0 4408, 10.1, paragraphs 6 and 7) and that are allowed
to return an empty answer with \s-1RCODE\s0 0 or \s-1RCODE\s0 3 (\f(CW\*(C`NXDOMAIN\*(C'\fR) before
processing is aborted with a \f(CW\*(C`permerror\*(C'\fR result.  If \fBundef\fR is specified,
there is no stricter limit on the number of void \s-1DNS\s0 look-ups beyond the usual
processing limits.  Defaults to \fB2\fR.
.Sp
Specifically, the \s-1DNS\s0 look-ups that are subject to this limit are those caused
by the \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`mx\*(C'\fR, \f(CW\*(C`ptr\*(C'\fR, and \f(CW\*(C`exists\*(C'\fR mechanisms and the \f(CW\*(C`p\*(C'\fR macro.
.Sp
A value of \fB2\fR is likely to prevent effective DoS attacks against third-party
victim domains.  However, a definite limit may cause \f(CW\*(C`permerror\*(C'\fR results even
with certain (overly complex) innocent sender policies where useful results
would normally be returned.
.RE
.RS 4
.RE
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBresult_class\fR: returns \fIclass\fR" 4
.IX Item "result_class: returns class"
.PD 0
.IP "\fBresult_class($name)\fR: returns \fIclass\fR" 4
.IX Item "result_class($name): returns class"
.PD
Returns a \fIMail::SPF::Result\fR descendent class determined from the given
result name via the server's inherent result base class, or returns the
server's inherent result base class if no result name is given.  This method
may also be used as an instance method.
.Sp
\&\fINote\fR:  Do not write code invoking class methods on \fIliteral\fR result class
names as this would ignore any derivative result classes provided by
\&\fBMail::SPF\fR extension modules.
.ie n .IP "\fBthrow_result($name, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow_result($name, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw_result($name, $request): throws Mail::SPF::Result"
.PD 0
.ie n .IP "\fBthrow_result($name, \fB$request\fB, \f(BI$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow_result($name, \f(CB$request\fB, \f(CB$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw_result($name, $request, $text): throws Mail::SPF::Result"
.PD
Throws a \fIMail::SPF::Result\fR descendant determined from the given result name
via the server's inherent result base class, passing an optional result text
and associating the given \fIMail::SPF::Request\fR object with the result object.
This method may also be used as an instance method.
.Sp
\&\fINote\fR:  Do not write code invoking \f(CW\*(C`throw\*(C'\fR on \fIliteral\fR result class names
as this would ignore any derivative result classes provided by \fBMail::SPF\fR
extension modules.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBprocess($request)\fR: returns \fIMail::SPF::Result\fR" 4
.IX Item "process($request): returns Mail::SPF::Result"
Processes the given \fIMail::SPF::Request\fR object, queries the authoritative
domain for an \s-1SPF\s0 sender policy (see the description of the \*(L"select_record\*(R"
method), evaluates the policy with regard to the given identity and other
request parameters, and returns a \fIMail::SPF::Result\fR object denoting the
result of the policy evaluation.  See \s-1RFC\s0 4408, 4, and \s-1RFC\s0 4406, 4, for
details.
.IP "\fBselect_record($request)\fR: returns \fIMail::SPF::Record\fR; throws \fIMail::SPF::EDNSError\fR, \fIMail::SPF::ENoAcceptableRecord\fR, \fIMail::SPF::ERedundantAcceptableRecords\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "select_record($request): returns Mail::SPF::Record; throws Mail::SPF::EDNSError, Mail::SPF::ENoAcceptableRecord, Mail::SPF::ERedundantAcceptableRecords, Mail::SPF::ESyntaxError"
Queries the authority domain of the given \fIMail::SPF::Request\fR object for \s-1SPF\s0
sender policy records and, if multiple records are available, selects the
record of the highest acceptable record version that covers the requested
scope.
.Sp
More precisely, the following algorithm is performed:
.RS 4
.IP "1." 4
Determine the authority domain, the set of acceptable \s-1SPF\s0 record versions, and
the identity scope from the given request object.
.IP "2." 4
Query the authority domain for \s-1SPF\s0 records of the \f(CW\*(C`SPF\*(C'\fR \s-1DNS\s0 \s-1RR\s0 type,
discarding any records that are of an inacceptable version or do not cover the
desired scope.
.Sp
If this yields no \s-1SPF\s0 records, query the authority domain for \s-1SPF\s0 records of
the \f(CW\*(C`TXT\*(C'\fR \s-1DNS\s0 \s-1RR\s0 type, discarding any records that are of an inacceptable
version or do not cover the desired scope.
.Sp
If still no acceptable \s-1SPF\s0 records could be found, throw a
\&\fIMail::SPF::ENoAcceptableRecord\fR exception.
.IP "3." 4
Discard all records but those of the highest acceptable version found.
.Sp
If exactly one record remains, return it.  Otherwise, throw a
\&\fIMail::SPF::ERedundantAcceptableRecords\fR exception.
.RE
.RS 4
.Sp
If the querying of either \s-1RR\s0 type has been disabled via the \*(L"new\*(R"
constructor's \f(CW\*(C`query_rr_types\*(C'\fR option, the respective part in step 2 will
be skipped.
.Sp
\&\fIMail::SPF::EDNSError\fR exceptions due to \s-1DNS\s0 look-ups and
\&\fIMail::SPF::ESyntaxError\fR exceptions due to invalid acceptable records may
also be thrown.
.RE
.ie n .IP "\fBget_acceptable_records_from_packet($packet, \fB$rr_type\fB, \e@versions, \f(BI$scope\fB, \f(CB$domain\fB)\fR: returns \fIlist\fR of \fIMail::SPF::Record\fR" 4
.el .IP "\fBget_acceptable_records_from_packet($packet, \f(CB$rr_type\fB, \e@versions, \f(CB$scope\fB, \f(CB$domain\fB)\fR: returns \fIlist\fR of \fIMail::SPF::Record\fR" 4
.IX Item "get_acceptable_records_from_packet($packet, $rr_type, @versions, $scope, $domain): returns list of Mail::SPF::Record"
Filters from the given \fINet::DNS::Packet\fR object all resource records of the
given \s-1RR\s0 type and for the given domain name, discarding any records that are
not \s-1SPF\s0 records at all, that are of an inacceptable \s-1SPF\s0 record version, or that
do not cover the given scope.  Returns a list of acceptable records.
.ie n .IP "\fBdns_lookup($domain, \fB$rr_type\fB)\fR: returns \fINet::DNS::Packet\fR; throws \fIMail::SPF::EDNSTimeout\fR, \fIMail::SPF::EDNSError\fR" 4
.el .IP "\fBdns_lookup($domain, \f(CB$rr_type\fB)\fR: returns \fINet::DNS::Packet\fR; throws \fIMail::SPF::EDNSTimeout\fR, \fIMail::SPF::EDNSError\fR" 4
.IX Item "dns_lookup($domain, $rr_type): returns Net::DNS::Packet; throws Mail::SPF::EDNSTimeout, Mail::SPF::EDNSError"
Queries the \s-1DNS\s0 using the configured resolver for resource records of the
desired type at the specified domain and returns a \fINet::DNS::Packet\fR object
if an answer packet was received.  Throws a \fIMail::SPF::EDNSTimeout\fR exception
if a \s-1DNS\s0 time-out occurred.  Throws a \fIMail::SPF::EDNSError\fR exception if an
error (other than \s-1RCODE\s0 3 \s-1AKA\s0 \f(CW\*(C`NXDOMAIN\*(C'\fR) occurred.
.IP "\fBcount_dns_interactive_term($request)\fR: throws \fIMail::SPF::EProcessingLimitExceeded\fR" 4
.IX Item "count_dns_interactive_term($request): throws Mail::SPF::EProcessingLimitExceeded"
Increments by one the count of DNS-interactive mechanisms and modifiers that
have been processed so far during the evaluation of the given
\&\fIMail::SPF::Request\fR object.  If this exceeds the configured limit (see the
\&\*(L"new\*(R" constructor's \f(CW\*(C`max_dns_interactive_terms\*(C'\fR option), throws a
\&\fIMail::SPF::EProcessingLimitExceeded\fR exception.
.Sp
This method is supposed to be called by the \f(CW\*(C`match\*(C'\fR and \f(CW\*(C`process\*(C'\fR methods of
\&\fIMail::SPF::Mech\fR and \fIMail::SPF::Mod\fR sub-classes before (and only if) they
do any \s-1DNS\s0 look-ups.
.IP "\fBcount_void_dns_lookup($request)\fR: throws \fIMail::SPF::EProcessingLimitExceeded\fR" 4
.IX Item "count_void_dns_lookup($request): throws Mail::SPF::EProcessingLimitExceeded"
Increments by one the count of \*(L"void\*(R" \s-1DNS\s0 look-ups that have occurred so far
during the evaluation of the given \fIMail::SPF::Request\fR object.  If this
exceeds the configured limit (see the \*(L"new\*(R" constructor's \f(CW\*(C`max_void_dns_lookups\*(C'\fR
option), throws a \fIMail::SPF::EProcessingLimitExceeded\fR exception.
.Sp
This method is supposed to be called by any code after any calls to the
\&\*(L"dns_lookup\*(R" method whenever (i) no answer records were returned, and (ii)
this fact is a possible indication of a DoS attack against a third-party victim
domain, and (iii) the number of \*(L"void\*(R" look-ups is not already constrained
otherwise (as for example is the case with the \f(CW\*(C`include\*(C'\fR mechanism and the
\&\f(CW\*(C`redirect\*(C'\fR modifier).  Specifically, this applies to look-ups performed by the
\&\f(CW\*(C`a\*(C'\fR, \f(CW\*(C`mx\*(C'\fR, \f(CW\*(C`ptr\*(C'\fR, and \f(CW\*(C`exists\*(C'\fR mechanisms and the \f(CW\*(C`p\*(C'\fR macro.
.IP "\fBdefault_authority_explanation\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "default_authority_explanation: returns Mail::SPF::MacroString"
Returns the default authority explanation as a \fIMacroString\fR object.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`default_authority_explanation\*(C'\fR
option.
.IP "\fBhostname\fR: returns \fIstring\fR" 4
.IX Item "hostname: returns string"
Returns the local system's host name.  See the description of the \*(L"new\*(R"
constructor's \f(CW\*(C`hostname\*(C'\fR option.
.IP "\fBdns_resolver\fR: returns \fINet::DNS::Resolver\fR or compatible object" 4
.IX Item "dns_resolver: returns Net::DNS::Resolver or compatible object"
Returns the \s-1DNS\s0 resolver object of the server object.  See the description of
the \*(L"new\*(R" constructor's \f(CW\*(C`dns_resolver\*(C'\fR option.
.IP "\fBquery_rr_types\fR: returns \fIinteger\fR" 4
.IX Item "query_rr_types: returns integer"
Returns a value denoting the \s-1RR\s0 types for which to query when looking up and
selecting \s-1SPF\s0 records.  See the description of the \*(L"new\*(R" constructor's
\&\f(CW\*(C`query_rr_types\*(C'\fR option.
.IP "\fBmax_dns_interactive_terms\fR: returns \fIinteger\fR" 4
.IX Item "max_dns_interactive_terms: returns integer"
.PD 0
.IP "\fBmax_name_lookups_per_term\fR: returns \fIinteger\fR" 4
.IX Item "max_name_lookups_per_term: returns integer"
.IP "\fBmax_name_lookups_per_mx_mech\fR: returns \fIinteger\fR" 4
.IX Item "max_name_lookups_per_mx_mech: returns integer"
.IP "\fBmax_name_lookups_per_ptr_mech\fR: returns \fIinteger\fR" 4
.IX Item "max_name_lookups_per_ptr_mech: returns integer"
.IP "\fBmax_void_dns_lookups\fR: returns \fIinteger\fR" 4
.IX Item "max_void_dns_lookups: returns integer"
.PD
Return the limit values of the server object.  See the description of the
\&\*(L"new\*(R" constructor's corresponding options.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Request, Mail::SPF::Result
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Server5.18.3pm                    0100644 0001750 0001750 00000051337 12566242051 024613  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Server 3"
.TH Mail::SPF::Server 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Server \- Server class for processing SPF requests
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF;
\&
\&    my $spf_server  = Mail::SPF::Server\->new(
\&        # Optional custom default for authority explanation:
\&        default_authority_explanation =>
\&            \*(AqSee http://www.%{d}/why/id=%{S};ip=%{I};r=%{R}\*(Aq
\&    );
\&
\&    my $result      = $spf_server\->process($request);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Server\fR is a server class for processing \s-1SPF\s0 requests.  Each
server instance can be configured with specific processing parameters.  Also,
the default \fINet::DNS::Resolver\fR \s-1DNS\s0 resolver used for making \s-1DNS\s0 look-ups can
be overridden with a custom resolver object.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Server\fR" 4
.IX Item "new(%options): returns Mail::SPF::Server"
Creates a new server object for processing \s-1SPF\s0 requests.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBdefault_authority_explanation\fR" 4
.IX Item "default_authority_explanation"
A \fIstring\fR denoting the default (not macro-expanded) authority explanation
string to use if the authority domain does not specify an explanation string of
its own.  Defaults to:
.Sp
.Vb 1
\&    \*(AqPlease see http://www.openspf.org/Why?s=%{_scope};id=%{S};ip=%{C};r=%{R}\*(Aq
.Ve
.Sp
As can be seen from the default, a non-standard \f(CW\*(C`_scope\*(C'\fR pseudo macro is
supported that expands to the name of the identity's scope.  (Note: Do \fInot\fR
use any non-standard macros in explanation strings published in \s-1DNS.\s0)
.IP "\fBhostname\fR" 4
.IX Item "hostname"
A \fIstring\fR denoting the local system's fully qualified host name that should
be used for expanding the \f(CW\*(C`r\*(C'\fR macro in explanation strings.  Defaults to the
system's configured host name.
.IP "\fBdns_resolver\fR" 4
.IX Item "dns_resolver"
An optional \s-1DNS\s0 resolver object.  If none is specified, a new \fINet::DNS::Resolver\fR
object is used.  The resolver object may be of a different class, but it must
provide an interface similar to \fINet::DNS::Resolver\fR \*(-- at least the \f(CW\*(C`send\*(C'\fR
and \f(CW\*(C`errorstring\*(C'\fR methods must be supported, and the \f(CW\*(C`send\*(C'\fR method must
return either an object of class \fINet::DNS::Packet\fR, or, in the case of an
error, \fBundef\fR.
.IP "\fBquery_rr_types\fR" 4
.IX Item "query_rr_types"
For which \s-1RR\s0 types to query when looking up and selecting \s-1SPF\s0 records.  The
following values are supported:
.RS 4
.IP "\fBMail::SPF::Server\->query_rr_type_all\fR" 4
.IX Item "Mail::SPF::Server->query_rr_type_all"
Both \f(CW\*(C`TXT\*(C'\fR and \f(CW\*(C`SPF\*(C'\fR type RRs.
.IP "\fBMail::SPF::Server\->query_rr_type_txt\fR (default)" 4
.IX Item "Mail::SPF::Server->query_rr_type_txt (default)"
\&\f(CW\*(C`TXT\*(C'\fR type RRs only.
.IP "\fBMail::SPF::Server\->query_rr_type_spf\fR" 4
.IX Item "Mail::SPF::Server->query_rr_type_spf"
\&\f(CW\*(C`SPF\*(C'\fR type RRs only.
.RE
.RS 4
.Sp
For years \fBMail::SPF\fR has defaulted to looking up both \f(CW\*(C`SPF\*(C'\fR and \f(CW\*(C`TXT\*(C'\fR type
RRs as recommended by \s-1RFC 4408. \s0 Experience has shown, however, that a
significant portion of name servers suffer from serious brain damage with
regard to the handling of queries for \s-1RR\s0 types that are unknown to them, such
as the \f(CW\*(C`SPF\*(C'\fR \s-1RR\s0 type.  Consequently \fBMail::SPF\fR now defaults to looking up
only \f(CW\*(C`TXT\*(C'\fR type RRs.  This may be overridden by setting the \fBquery_rr_types\fR
option.
.Sp
See \s-1RFC 4408, 3.1.1,\s0 for a discussion of the topic, as well as the description
of the \*(L"select_record\*(R" method.
.RE
.IP "\fBmax_dns_interactive_terms\fR" 4
.IX Item "max_dns_interactive_terms"
An \fIinteger\fR denoting the maximum number of terms (mechanisms and modifiers)
per \s-1SPF\s0 check that perform \s-1DNS\s0 look-ups, as defined in \s-1RFC 4408, 10.1,\s0
paragraph 6.  If \fBundef\fR is specified, there is no limit on the number of such
terms.  Defaults to \fB10\fR, which is the value defined in \s-1RFC 4408.\s0
.Sp
A value above the default is \fIstrongly discouraged\fR for security reasons.  A
value below the default has implications with regard to the predictability of
\&\s-1SPF\s0 results.  Only deviate from the default if you know what you are doing!
.IP "\fBmax_name_lookups_per_term\fR" 4
.IX Item "max_name_lookups_per_term"
An \fIinteger\fR denoting the maximum number of \s-1DNS\s0 name look-ups per term
(mechanism or modifier), as defined in \s-1RFC 4408, 10.1,\s0 paragraph 7.  If
\&\fBundef\fR is specified, there is no limit on the number of look-ups performed.
Defaults to \fB10\fR, which is the value defined in \s-1RFC 4408.\s0
.Sp
A value above the default is \fIstrongly discouraged\fR for security reasons.  A
value below the default has implications with regard to the predictability of
\&\s-1SPF\s0 results.  Only deviate from the default if you know what you are doing!
.IP "\fBmax_name_lookups_per_mx_mech\fR" 4
.IX Item "max_name_lookups_per_mx_mech"
.PD 0
.IP "\fBmax_name_lookups_per_ptr_mech\fR" 4
.IX Item "max_name_lookups_per_ptr_mech"
.PD
An \fIinteger\fR denoting the maximum number of \s-1DNS\s0 name look-ups per \fBmx\fR or \fBptr\fR
mechanism, respectively.  Defaults to the value of the \f(CW\*(C`max_name_lookups_per_term\*(C'\fR
option.  See there for additional information and security notes.
.IP "\fBmax_void_dns_lookups\fR" 4
.IX Item "max_void_dns_lookups"
An \fIinteger\fR denoting the maximum number of \*(L"void\*(R" \s-1DNS\s0 look-ups per \s-1SPF\s0 check,
i.e. the number of \s-1DNS\s0 look-ups that were caused by DNS-interactive terms and
macros (as defined in \s-1RFC 4408, 10.1,\s0 paragraphs 6 and 7) and that are allowed
to return an empty answer with \s-1RCODE 0\s0 or \s-1RCODE 3 \s0(\f(CW\*(C`NXDOMAIN\*(C'\fR) before
processing is aborted with a \f(CW\*(C`permerror\*(C'\fR result.  If \fBundef\fR is specified,
there is no stricter limit on the number of void \s-1DNS\s0 look-ups beyond the usual
processing limits.  Defaults to \fB2\fR.
.Sp
Specifically, the \s-1DNS\s0 look-ups that are subject to this limit are those caused
by the \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`mx\*(C'\fR, \f(CW\*(C`ptr\*(C'\fR, and \f(CW\*(C`exists\*(C'\fR mechanisms and the \f(CW\*(C`p\*(C'\fR macro.
.Sp
A value of \fB2\fR is likely to prevent effective DoS attacks against third-party
victim domains.  However, a definite limit may cause \f(CW\*(C`permerror\*(C'\fR results even
with certain (overly complex) innocent sender policies where useful results
would normally be returned.
.RE
.RS 4
.RE
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBresult_class\fR: returns \fIclass\fR" 4
.IX Item "result_class: returns class"
.PD 0
.IP "\fBresult_class($name)\fR: returns \fIclass\fR" 4
.IX Item "result_class($name): returns class"
.PD
Returns a \fIMail::SPF::Result\fR descendent class determined from the given
result name via the server's inherent result base class, or returns the
server's inherent result base class if no result name is given.  This method
may also be used as an instance method.
.Sp
\&\fINote\fR:  Do not write code invoking class methods on \fIliteral\fR result class
names as this would ignore any derivative result classes provided by
\&\fBMail::SPF\fR extension modules.
.ie n .IP "\fBthrow_result($name, \fB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow_result($name, \f(CB$request\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw_result($name, $request): throws Mail::SPF::Result"
.PD 0
.ie n .IP "\fBthrow_result($name, \fB$request\fB, \f(BI$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.el .IP "\fBthrow_result($name, \f(CB$request\fB, \f(CB$text\fB)\fR: throws \fIMail::SPF::Result\fR" 4
.IX Item "throw_result($name, $request, $text): throws Mail::SPF::Result"
.PD
Throws a \fIMail::SPF::Result\fR descendant determined from the given result name
via the server's inherent result base class, passing an optional result text
and associating the given \fIMail::SPF::Request\fR object with the result object.
This method may also be used as an instance method.
.Sp
\&\fINote\fR:  Do not write code invoking \f(CW\*(C`throw\*(C'\fR on \fIliteral\fR result class names
as this would ignore any derivative result classes provided by \fBMail::SPF\fR
extension modules.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBprocess($request)\fR: returns \fIMail::SPF::Result\fR" 4
.IX Item "process($request): returns Mail::SPF::Result"
Processes the given \fIMail::SPF::Request\fR object, queries the authoritative
domain for an \s-1SPF\s0 sender policy (see the description of the \*(L"select_record\*(R"
method), evaluates the policy with regard to the given identity and other
request parameters, and returns a \fIMail::SPF::Result\fR object denoting the
result of the policy evaluation.  See \s-1RFC 4408, 4,\s0 and \s-1RFC 4406, 4,\s0 for
details.
.IP "\fBselect_record($request)\fR: returns \fIMail::SPF::Record\fR; throws \fIMail::SPF::EDNSError\fR, \fIMail::SPF::ENoAcceptableRecord\fR, \fIMail::SPF::ERedundantAcceptableRecords\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "select_record($request): returns Mail::SPF::Record; throws Mail::SPF::EDNSError, Mail::SPF::ENoAcceptableRecord, Mail::SPF::ERedundantAcceptableRecords, Mail::SPF::ESyntaxError"
Queries the authority domain of the given \fIMail::SPF::Request\fR object for \s-1SPF\s0
sender policy records and, if multiple records are available, selects the
record of the highest acceptable record version that covers the requested
scope.
.Sp
More precisely, the following algorithm is performed (assuming that both \f(CW\*(C`TXT\*(C'\fR
and \f(CW\*(C`SPF\*(C'\fR \s-1RR\s0 types are being queried):
.RS 4
.IP "1." 4
Determine the authority domain, the set of acceptable \s-1SPF\s0 record versions, and
the identity scope from the given request object.
.IP "2." 4
Query the authority domain for \s-1SPF\s0 records of the \f(CW\*(C`SPF\*(C'\fR \s-1DNS RR\s0 type,
discarding any records that are of an inacceptable version or do not cover the
desired scope.
.Sp
If this yields no \s-1SPF\s0 records, query the authority domain for \s-1SPF\s0 records of
the \f(CW\*(C`TXT\*(C'\fR \s-1DNS RR\s0 type, discarding any records that are of an inacceptable
version or do not cover the desired scope.
.Sp
If still no acceptable \s-1SPF\s0 records could be found, throw a
\&\fIMail::SPF::ENoAcceptableRecord\fR exception.
.IP "3." 4
Discard all records but those of the highest acceptable version found.
.Sp
If exactly one record remains, return it.  Otherwise, throw a
\&\fIMail::SPF::ERedundantAcceptableRecords\fR exception.
.RE
.RS 4
.Sp
If the querying of either \s-1RR\s0 type has been disabled via the \*(L"new\*(R"
constructor's \f(CW\*(C`query_rr_types\*(C'\fR option, the respective part in step 2 will
be skipped.
.Sp
\&\fIMail::SPF::EDNSError\fR exceptions due to \s-1DNS\s0 look-ups and
\&\fIMail::SPF::ESyntaxError\fR exceptions due to invalid acceptable records may
also be thrown.
.RE
.ie n .IP "\fBget_acceptable_records_from_packet($packet, \fB$rr_type\fB, \e@versions, \f(BI$scope\fB, \f(CB$domain\fB)\fR: returns \fIlist\fR of \fIMail::SPF::Record\fR" 4
.el .IP "\fBget_acceptable_records_from_packet($packet, \f(CB$rr_type\fB, \e@versions, \f(CB$scope\fB, \f(CB$domain\fB)\fR: returns \fIlist\fR of \fIMail::SPF::Record\fR" 4
.IX Item "get_acceptable_records_from_packet($packet, $rr_type, @versions, $scope, $domain): returns list of Mail::SPF::Record"
Filters from the given \fINet::DNS::Packet\fR object all resource records of the
given \s-1RR\s0 type and for the given domain name, discarding any records that are
not \s-1SPF\s0 records at all, that are of an inacceptable \s-1SPF\s0 record version, or that
do not cover the given scope.  Returns a list of acceptable records.
.ie n .IP "\fBdns_lookup($domain, \fB$rr_type\fB)\fR: returns \fINet::DNS::Packet\fR; throws \fIMail::SPF::EDNSTimeout\fR, \fIMail::SPF::EDNSError\fR" 4
.el .IP "\fBdns_lookup($domain, \f(CB$rr_type\fB)\fR: returns \fINet::DNS::Packet\fR; throws \fIMail::SPF::EDNSTimeout\fR, \fIMail::SPF::EDNSError\fR" 4
.IX Item "dns_lookup($domain, $rr_type): returns Net::DNS::Packet; throws Mail::SPF::EDNSTimeout, Mail::SPF::EDNSError"
Queries the \s-1DNS\s0 using the configured resolver for resource records of the
desired type at the specified domain and returns a \fINet::DNS::Packet\fR object
if an answer packet was received.  Throws a \fIMail::SPF::EDNSTimeout\fR exception
if a \s-1DNS\s0 time-out occurred.  Throws a \fIMail::SPF::EDNSError\fR exception if an
error (other than \s-1RCODE 3 AKA \s0\f(CW\*(C`NXDOMAIN\*(C'\fR) occurred.
.IP "\fBcount_dns_interactive_term($request)\fR: throws \fIMail::SPF::EProcessingLimitExceeded\fR" 4
.IX Item "count_dns_interactive_term($request): throws Mail::SPF::EProcessingLimitExceeded"
Increments by one the count of DNS-interactive mechanisms and modifiers that
have been processed so far during the evaluation of the given
\&\fIMail::SPF::Request\fR object.  If this exceeds the configured limit (see the
\&\*(L"new\*(R" constructor's \f(CW\*(C`max_dns_interactive_terms\*(C'\fR option), throws a
\&\fIMail::SPF::EProcessingLimitExceeded\fR exception.
.Sp
This method is supposed to be called by the \f(CW\*(C`match\*(C'\fR and \f(CW\*(C`process\*(C'\fR methods of
\&\fIMail::SPF::Mech\fR and \fIMail::SPF::Mod\fR sub-classes before (and only if) they
do any \s-1DNS\s0 look-ups.
.IP "\fBcount_void_dns_lookup($request)\fR: throws \fIMail::SPF::EProcessingLimitExceeded\fR" 4
.IX Item "count_void_dns_lookup($request): throws Mail::SPF::EProcessingLimitExceeded"
Increments by one the count of \*(L"void\*(R" \s-1DNS\s0 look-ups that have occurred so far
during the evaluation of the given \fIMail::SPF::Request\fR object.  If this
exceeds the configured limit (see the \*(L"new\*(R" constructor's \f(CW\*(C`max_void_dns_lookups\*(C'\fR
option), throws a \fIMail::SPF::EProcessingLimitExceeded\fR exception.
.Sp
This method is supposed to be called by any code after any calls to the
\&\*(L"dns_lookup\*(R" method whenever (i) no answer records were returned, and (ii)
this fact is a possible indication of a DoS attack against a third-party victim
domain, and (iii) the number of \*(L"void\*(R" look-ups is not already constrained
otherwise (as for example is the case with the \f(CW\*(C`include\*(C'\fR mechanism and the
\&\f(CW\*(C`redirect\*(C'\fR modifier).  Specifically, this applies to look-ups performed by the
\&\f(CW\*(C`a\*(C'\fR, \f(CW\*(C`mx\*(C'\fR, \f(CW\*(C`ptr\*(C'\fR, and \f(CW\*(C`exists\*(C'\fR mechanisms and the \f(CW\*(C`p\*(C'\fR macro.
.IP "\fBdefault_authority_explanation\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "default_authority_explanation: returns Mail::SPF::MacroString"
Returns the default authority explanation as a \fIMacroString\fR object.  See the
description of the \*(L"new\*(R" constructor's \f(CW\*(C`default_authority_explanation\*(C'\fR
option.
.IP "\fBhostname\fR: returns \fIstring\fR" 4
.IX Item "hostname: returns string"
Returns the local system's host name.  See the description of the \*(L"new\*(R"
constructor's \f(CW\*(C`hostname\*(C'\fR option.
.IP "\fBdns_resolver\fR: returns \fINet::DNS::Resolver\fR or compatible object" 4
.IX Item "dns_resolver: returns Net::DNS::Resolver or compatible object"
Returns the \s-1DNS\s0 resolver object of the server object.  See the description of
the \*(L"new\*(R" constructor's \f(CW\*(C`dns_resolver\*(C'\fR option.
.IP "\fBquery_rr_types\fR: returns \fIinteger\fR" 4
.IX Item "query_rr_types: returns integer"
Returns a value denoting the \s-1RR\s0 types for which to query when looking up and
selecting \s-1SPF\s0 records.  See the description of the \*(L"new\*(R" constructor's
\&\f(CW\*(C`query_rr_types\*(C'\fR option.
.IP "\fBmax_dns_interactive_terms\fR: returns \fIinteger\fR" 4
.IX Item "max_dns_interactive_terms: returns integer"
.PD 0
.IP "\fBmax_name_lookups_per_term\fR: returns \fIinteger\fR" 4
.IX Item "max_name_lookups_per_term: returns integer"
.IP "\fBmax_name_lookups_per_mx_mech\fR: returns \fIinteger\fR" 4
.IX Item "max_name_lookups_per_mx_mech: returns integer"
.IP "\fBmax_name_lookups_per_ptr_mech\fR: returns \fIinteger\fR" 4
.IX Item "max_name_lookups_per_ptr_mech: returns integer"
.IP "\fBmax_void_dns_lookups\fR: returns \fIinteger\fR" 4
.IX Item "max_void_dns_lookups: returns integer"
.PD
Return the limit values of the server object.  See the description of the
\&\*(L"new\*(R" constructor's corresponding options.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Request, Mail::SPF::Result
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Term.3pm                          0100644 0001750 0001750 00000014410 12566242050 023726  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Term 3"
.TH Mail::SPF::Term 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Term \- SPF record term class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Term\fR represents a term within an \s-1SPF\s0 record.
Mail::SPF::Term cannot be instantiated directly.  Create an instance of a
concrete sub-class instead.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Term\fR" 4
.IX Item "new(%options): returns Mail::SPF::Term"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record term object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs, however Mail::SPF::Term itself specifies
no constructor options.
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Term\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidTerm\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Term\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidTerm\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Term; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidTerm"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record term object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches any legal name for an \s-1SPF\s0 record
term.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the term.  Throws a \fIMail::SPF::ENoUnparsedText\fR
exception if the term was created synthetically instead of being parsed, and no
text was provided.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
\&\fIAbstract\fR.  Returns the name of the term.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Mech, Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Term5.16.3pm                      0100644 0001750 0001750 00000014067 12566242063 024254  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Term 3"
.TH Mail::SPF::Term 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Term \- SPF record term class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Term\fR represents a term within an \s-1SPF\s0 record.
Mail::SPF::Term cannot be instantiated directly.  Create an instance of a
concrete sub-class instead.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Term\fR" 4
.IX Item "new(%options): returns Mail::SPF::Term"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record term object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs, however Mail::SPF::Term itself specifies
no constructor options.
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Term\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidTerm\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Term\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidTerm\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Term; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidTerm"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record term object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches any legal name for an \s-1SPF\s0 record
term.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the term.  Throws a \fIMail::SPF::ENoUnparsedText\fR
exception if the term was created synthetically instead of being parsed, and no
text was provided.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
\&\fIAbstract\fR.  Returns the name of the term.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Mech, Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Term5.18.3pm                      0100644 0001750 0001750 00000014410 12566242050 024242  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Term 3"
.TH Mail::SPF::Term 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Term \- SPF record term class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Term\fR represents a term within an \s-1SPF\s0 record.
Mail::SPF::Term cannot be instantiated directly.  Create an instance of a
concrete sub-class instead.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Term\fR" 4
.IX Item "new(%options): returns Mail::SPF::Term"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record term object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs, however Mail::SPF::Term itself specifies
no constructor options.
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Term\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidTerm\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Term\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidTerm\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Term; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidTerm"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record term object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches any legal name for an \s-1SPF\s0 record
term.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the term.  Throws a \fIMail::SPF::ENoUnparsedText\fR
exception if the term was created synthetically instead of being parsed, and no
text was provided.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
\&\fIAbstract\fR.  Returns the name of the term.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Mech, Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Util.3pm                          0100644 0001750 0001750 00000023302 12566242050 023734  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Util 3"
.TH Mail::SPF::Util 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Util \- Mail::SPF utility class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF::Util;
\&
\&    $hostname = Mail::SPF::Util\->hostname;
\&
\&    $ipv6_address_v4mapped =
\&        Mail::SPF::Util\->ipv4_address_to_ipv6($ipv4_address);
\&
\&    $ipv4_address =
\&        Mail::SPF::Util\->ipv6_address_to_ipv4($ipv6_address_v4mapped);
\&
\&    $is_v4mapped =
\&        Mail::SPF::Util\->ipv6_address_is_ipv4_mapped($ipv6_address);
\&
\&    $ip_address_string  = Mail::SPF::Util\->ip_address_to_string($ip_address);
\&    $reverse_name       = Mail::SPF::Util\->ip_address_reverse($ip_address);
\&
\&    $validated_domain = Mail::SPF::Util\->valid_domain_for_ip_address(
\&        $spf_server, $request,
\&        $ip_address, $domain,
\&        $find_best_match,       # defaults to false
\&        $accept_any_domain      # defaults to false
\&    );
\&
\&    $sanitized_string = Mail::SPF::Util\->sanitize_string($string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Util\fR is Mail::SPF's utility class.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBhostname\fR: returns \fIstring\fR" 4
.IX Item "hostname: returns string"
Returns the fully qualified domain name (\s-1FQDN\s0) of the local host.
.IP "\fBipv4_address_to_ipv6($ipv4_address)\fR: returns \fINetAddr::IP\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ipv4_address_to_ipv6($ipv4_address): returns NetAddr::IP; throws Mail::SPF::EInvalidOptionValue"
Converts the specified \fINetAddr::IP\fR IPv4 address into an IPv4\-mapped IPv6
address.  Throws a \fIMail::SPF::EInvalidOptionValue\fR exception if the specified
\&\s-1IP\s0 address is not an IPv4 address.
.IP "\fBipv6_address_to_ipv4($ipv6_address)\fR: returns \fINetAddr::IP\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ipv6_address_to_ipv4($ipv6_address): returns NetAddr::IP; throws Mail::SPF::EInvalidOptionValue"
Converts the specified \fINetAddr::IP\fR IPv4\-mapped IPv6 address into a proper
IPv4 address.  Throws a \fIMail::SPF::EInvalidOptionValue\fR exception if the
specified \s-1IP\s0 address is not an IPv4\-mapped IPv6 address.
.IP "\fBipv6_address_is_ipv4_mapped($ipv6_address)\fR: returns \fIboolean\fR" 4
.IX Item "ipv6_address_is_ipv4_mapped($ipv6_address): returns boolean"
Returns \fBtrue\fR if the specified \fINetAddr::IP\fR IPv6 address is an IPv4\-mapped
address, \fBfalse\fR otherwise.
.IP "\fBip_address_to_string($ip_address)\fR: returns \fIstring\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ip_address_to_string($ip_address): returns string; throws Mail::SPF::EInvalidOptionValue"
Returns the given \fINetAddr::IP\fR IPv4 or IPv6 address compactly formatted as a
\&\fIstring\fR.  For IPv4 addresses, this is equivalent to calling  NetAddr::IP's
\&\f(CW\*(C`addr\*(C'\fR  method.  For IPv6 addresses, this is equivalent to
calling  NetAddr::IP's \f(CW\*(C`short\*(C'\fR  method.  Throws a
\&\fIMail::SPF::EInvalidOptionValue\fR exception if the specified object is not a
\&\fINetAddr::IP\fR IPv4 or IPv6 address object.
.IP "\fBip_address_reverse($ip_address)\fR: returns \fIstring\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ip_address_reverse($ip_address): returns string; throws Mail::SPF::EInvalidOptionValue"
Returns the \f(CW\*(C`in\-addr.arpa.\*(C'\fR/\f(CW\*(C`ip6.arpa.\*(C'\fR reverse notation of the given
\&\fINetAddr::IP\fR IPv4 or IPv6 address.  Throws a \fIMail::SPF::EInvalidOptionValue\fR
exception if the specified object is not a \fINetAddr::IP\fR IPv4 or IPv6 address
object.
.ie n .IP "\fBvalid_domain_for_ip_address($server, \fB$request\fB, \f(BI$ip_address\fB, \f(CB$domain\fB, \f(CB$find_best_match\fB = false, \f(CB$accept_any_domain\fB = false)\fR: returns \fIstring\fR or \fBundef\fR" 4
.el .IP "\fBvalid_domain_for_ip_address($server, \f(CB$request\fB, \f(CB$ip_address\fB, \f(CB$domain\fB, \f(CB$find_best_match\fB = false, \f(CB$accept_any_domain\fB = false)\fR: returns \fIstring\fR or \fBundef\fR" 4
.IX Item "valid_domain_for_ip_address($server, $request, $ip_address, $domain, $find_best_match = false, $accept_any_domain = false): returns string or undef"
Finds a valid domain name for the given \fINetAddr::IP\fR \s-1IP\s0 address that matches
the given domain or a sub-domain thereof.  A domain name is valid for the given
\&\s-1IP\s0 address if the \s-1IP\s0 address reverse-maps to that domain name in \s-1DNS,\s0 and the
domain name in turn forward-maps to the \s-1IP\s0 address.  Uses the given
\&\fIMail::SPF::Server\fR and \fIMail::SPF::Request\fR objects to perform \s-1DNS\s0 look-ups.
Returns the validated domain name.
.Sp
If \f(CW$find_best_match\fR is \fBtrue\fR, the one domain name is selected that best
matches the given domain name, preferring direct matches over sub-domain
matches.  Defaults to \fBfalse\fR.
.Sp
If \f(CW$accept_any_domain\fR is \fBtrue\fR, \fIany\fR domain names are considered
acceptable, even if they differ completely from the given domain name (which
is then effectively unused unless a best match is requested).  Defaults to
\&\fBfalse\fR.
.IP "\fBsanitize_string($string)\fR: returns \fIstring\fR or \fBundef\fR" 4
.IX Item "sanitize_string($string): returns string or undef"
Replaces all non-printable or non-ascii characters in a string with their
hex-escaped representation (e.g., \f(CW\*(C`\ex00\*(C'\fR).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 157:" 4
.IX Item "Around line 157:"
L<> starts or ends with whitespace
.Sp
L<> starts or ends with whitespace
                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Util5.16.3pm                      0100644 0001750 0001750 00000022370 12566242063 024256  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Util 3"
.TH Mail::SPF::Util 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Util \- Mail::SPF utility class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF::Util;
\&
\&    $hostname = Mail::SPF::Util\->hostname;
\&
\&    $ipv6_address_v4mapped =
\&        Mail::SPF::Util\->ipv4_address_to_ipv6($ipv4_address);
\&
\&    $ipv4_address =
\&        Mail::SPF::Util\->ipv6_address_to_ipv4($ipv6_address_v4mapped);
\&
\&    $is_v4mapped =
\&        Mail::SPF::Util\->ipv6_address_is_ipv4_mapped($ipv6_address);
\&
\&    $ip_address_string  = Mail::SPF::Util\->ip_address_to_string($ip_address);
\&    $reverse_name       = Mail::SPF::Util\->ip_address_reverse($ip_address);
\&
\&    $validated_domain = Mail::SPF::Util\->valid_domain_for_ip_address(
\&        $spf_server, $request,
\&        $ip_address, $domain,
\&        $find_best_match,       # defaults to false
\&        $accept_any_domain      # defaults to false
\&    );
\&
\&    $sanitized_string = Mail::SPF::Util\->sanitize_string($string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Util\fR is Mail::SPF's utility class.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBhostname\fR: returns \fIstring\fR" 4
.IX Item "hostname: returns string"
Returns the fully qualified domain name (\s-1FQDN\s0) of the local host.
.IP "\fBipv4_address_to_ipv6($ipv4_address)\fR: returns \fINetAddr::IP\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ipv4_address_to_ipv6($ipv4_address): returns NetAddr::IP; throws Mail::SPF::EInvalidOptionValue"
Converts the specified \fINetAddr::IP\fR IPv4 address into an IPv4\-mapped IPv6
address.  Throws a \fIMail::SPF::EInvalidOptionValue\fR exception if the specified
\&\s-1IP\s0 address is not an IPv4 address.
.IP "\fBipv6_address_to_ipv4($ipv6_address)\fR: returns \fINetAddr::IP\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ipv6_address_to_ipv4($ipv6_address): returns NetAddr::IP; throws Mail::SPF::EInvalidOptionValue"
Converts the specified \fINetAddr::IP\fR IPv4\-mapped IPv6 address into a proper
IPv4 address.  Throws a \fIMail::SPF::EInvalidOptionValue\fR exception if the
specified \s-1IP\s0 address is not an IPv4\-mapped IPv6 address.
.IP "\fBipv6_address_is_ipv4_mapped($ipv6_address)\fR: returns \fIboolean\fR" 4
.IX Item "ipv6_address_is_ipv4_mapped($ipv6_address): returns boolean"
Returns \fBtrue\fR if the specified \fINetAddr::IP\fR IPv6 address is an IPv4\-mapped
address, \fBfalse\fR otherwise.
.IP "\fBip_address_to_string($ip_address)\fR: returns \fIstring\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ip_address_to_string($ip_address): returns string; throws Mail::SPF::EInvalidOptionValue"
Returns the given \fINetAddr::IP\fR IPv4 or IPv6 address compactly formatted as a
\&\fIstring\fR.  For IPv4 addresses, this is equivalent to calling  NetAddr::IP's
\&\f(CW\*(C`addr\*(C'\fR  method.  For IPv6 addresses, this is equivalent to
calling  NetAddr::IP's \f(CW\*(C`short\*(C'\fR  method.  Throws a
\&\fIMail::SPF::EInvalidOptionValue\fR exception if the specified object is not a
\&\fINetAddr::IP\fR IPv4 or IPv6 address object.
.IP "\fBip_address_reverse($ip_address)\fR: returns \fIstring\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ip_address_reverse($ip_address): returns string; throws Mail::SPF::EInvalidOptionValue"
Returns the \f(CW\*(C`in\-addr.arpa.\*(C'\fR/\f(CW\*(C`ip6.arpa.\*(C'\fR reverse notation of the given
\&\fINetAddr::IP\fR IPv4 or IPv6 address.  Throws a \fIMail::SPF::EInvalidOptionValue\fR
exception if the specified object is not a \fINetAddr::IP\fR IPv4 or IPv6 address
object.
.ie n .IP "\fBvalid_domain_for_ip_address($server, \fB$request\fB, \f(BI$ip_address\fB, \f(CB$domain\fB, \f(CB$find_best_match\fB = false, \f(CB$accept_any_domain\fB = false)\fR: returns \fIstring\fR or \fBundef\fR" 4
.el .IP "\fBvalid_domain_for_ip_address($server, \f(CB$request\fB, \f(CB$ip_address\fB, \f(CB$domain\fB, \f(CB$find_best_match\fB = false, \f(CB$accept_any_domain\fB = false)\fR: returns \fIstring\fR or \fBundef\fR" 4
.IX Item "valid_domain_for_ip_address($server, $request, $ip_address, $domain, $find_best_match = false, $accept_any_domain = false): returns string or undef"
Finds a valid domain name for the given \fINetAddr::IP\fR \s-1IP\s0 address that matches
the given domain or a sub-domain thereof.  A domain name is valid for the given
\&\s-1IP\s0 address if the \s-1IP\s0 address reverse-maps to that domain name in \s-1DNS\s0, and the
domain name in turn forward-maps to the \s-1IP\s0 address.  Uses the given
\&\fIMail::SPF::Server\fR and \fIMail::SPF::Request\fR objects to perform \s-1DNS\s0 look-ups.
Returns the validated domain name.
.Sp
If \f(CW$find_best_match\fR is \fBtrue\fR, the one domain name is selected that best
matches the given domain name, preferring direct matches over sub-domain
matches.  Defaults to \fBfalse\fR.
.Sp
If \f(CW$accept_any_domain\fR is \fBtrue\fR, \fIany\fR domain names are considered
acceptable, even if they differ completely from the given domain name (which
is then effectively unused unless a best match is requested).  Defaults to
\&\fBfalse\fR.
.IP "\fBsanitize_string($string)\fR: returns \fIstring\fR or \fBundef\fR" 4
.IX Item "sanitize_string($string): returns string or undef"
Replaces all non-printable or non-ascii characters in a string with their
hex-escaped representation (e.g., \f(CW\*(C`\ex00\*(C'\fR).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Util5.18.3pm                      0100644 0001750 0001750 00000023302 12566242050 024250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Util 3"
.TH Mail::SPF::Util 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Util \- Mail::SPF utility class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF::Util;
\&
\&    $hostname = Mail::SPF::Util\->hostname;
\&
\&    $ipv6_address_v4mapped =
\&        Mail::SPF::Util\->ipv4_address_to_ipv6($ipv4_address);
\&
\&    $ipv4_address =
\&        Mail::SPF::Util\->ipv6_address_to_ipv4($ipv6_address_v4mapped);
\&
\&    $is_v4mapped =
\&        Mail::SPF::Util\->ipv6_address_is_ipv4_mapped($ipv6_address);
\&
\&    $ip_address_string  = Mail::SPF::Util\->ip_address_to_string($ip_address);
\&    $reverse_name       = Mail::SPF::Util\->ip_address_reverse($ip_address);
\&
\&    $validated_domain = Mail::SPF::Util\->valid_domain_for_ip_address(
\&        $spf_server, $request,
\&        $ip_address, $domain,
\&        $find_best_match,       # defaults to false
\&        $accept_any_domain      # defaults to false
\&    );
\&
\&    $sanitized_string = Mail::SPF::Util\->sanitize_string($string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Util\fR is Mail::SPF's utility class.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBhostname\fR: returns \fIstring\fR" 4
.IX Item "hostname: returns string"
Returns the fully qualified domain name (\s-1FQDN\s0) of the local host.
.IP "\fBipv4_address_to_ipv6($ipv4_address)\fR: returns \fINetAddr::IP\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ipv4_address_to_ipv6($ipv4_address): returns NetAddr::IP; throws Mail::SPF::EInvalidOptionValue"
Converts the specified \fINetAddr::IP\fR IPv4 address into an IPv4\-mapped IPv6
address.  Throws a \fIMail::SPF::EInvalidOptionValue\fR exception if the specified
\&\s-1IP\s0 address is not an IPv4 address.
.IP "\fBipv6_address_to_ipv4($ipv6_address)\fR: returns \fINetAddr::IP\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ipv6_address_to_ipv4($ipv6_address): returns NetAddr::IP; throws Mail::SPF::EInvalidOptionValue"
Converts the specified \fINetAddr::IP\fR IPv4\-mapped IPv6 address into a proper
IPv4 address.  Throws a \fIMail::SPF::EInvalidOptionValue\fR exception if the
specified \s-1IP\s0 address is not an IPv4\-mapped IPv6 address.
.IP "\fBipv6_address_is_ipv4_mapped($ipv6_address)\fR: returns \fIboolean\fR" 4
.IX Item "ipv6_address_is_ipv4_mapped($ipv6_address): returns boolean"
Returns \fBtrue\fR if the specified \fINetAddr::IP\fR IPv6 address is an IPv4\-mapped
address, \fBfalse\fR otherwise.
.IP "\fBip_address_to_string($ip_address)\fR: returns \fIstring\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ip_address_to_string($ip_address): returns string; throws Mail::SPF::EInvalidOptionValue"
Returns the given \fINetAddr::IP\fR IPv4 or IPv6 address compactly formatted as a
\&\fIstring\fR.  For IPv4 addresses, this is equivalent to calling  NetAddr::IP's
\&\f(CW\*(C`addr\*(C'\fR  method.  For IPv6 addresses, this is equivalent to
calling  NetAddr::IP's \f(CW\*(C`short\*(C'\fR  method.  Throws a
\&\fIMail::SPF::EInvalidOptionValue\fR exception if the specified object is not a
\&\fINetAddr::IP\fR IPv4 or IPv6 address object.
.IP "\fBip_address_reverse($ip_address)\fR: returns \fIstring\fR; throws \fIMail::SPF::EInvalidOptionValue\fR" 4
.IX Item "ip_address_reverse($ip_address): returns string; throws Mail::SPF::EInvalidOptionValue"
Returns the \f(CW\*(C`in\-addr.arpa.\*(C'\fR/\f(CW\*(C`ip6.arpa.\*(C'\fR reverse notation of the given
\&\fINetAddr::IP\fR IPv4 or IPv6 address.  Throws a \fIMail::SPF::EInvalidOptionValue\fR
exception if the specified object is not a \fINetAddr::IP\fR IPv4 or IPv6 address
object.
.ie n .IP "\fBvalid_domain_for_ip_address($server, \fB$request\fB, \f(BI$ip_address\fB, \f(CB$domain\fB, \f(CB$find_best_match\fB = false, \f(CB$accept_any_domain\fB = false)\fR: returns \fIstring\fR or \fBundef\fR" 4
.el .IP "\fBvalid_domain_for_ip_address($server, \f(CB$request\fB, \f(CB$ip_address\fB, \f(CB$domain\fB, \f(CB$find_best_match\fB = false, \f(CB$accept_any_domain\fB = false)\fR: returns \fIstring\fR or \fBundef\fR" 4
.IX Item "valid_domain_for_ip_address($server, $request, $ip_address, $domain, $find_best_match = false, $accept_any_domain = false): returns string or undef"
Finds a valid domain name for the given \fINetAddr::IP\fR \s-1IP\s0 address that matches
the given domain or a sub-domain thereof.  A domain name is valid for the given
\&\s-1IP\s0 address if the \s-1IP\s0 address reverse-maps to that domain name in \s-1DNS,\s0 and the
domain name in turn forward-maps to the \s-1IP\s0 address.  Uses the given
\&\fIMail::SPF::Server\fR and \fIMail::SPF::Request\fR objects to perform \s-1DNS\s0 look-ups.
Returns the validated domain name.
.Sp
If \f(CW$find_best_match\fR is \fBtrue\fR, the one domain name is selected that best
matches the given domain name, preferring direct matches over sub-domain
matches.  Defaults to \fBfalse\fR.
.Sp
If \f(CW$accept_any_domain\fR is \fBtrue\fR, \fIany\fR domain names are considered
acceptable, even if they differ completely from the given domain name (which
is then effectively unused unless a best match is requested).  Defaults to
\&\fBfalse\fR.
.IP "\fBsanitize_string($string)\fR: returns \fIstring\fR or \fBundef\fR" 4
.IX Item "sanitize_string($string): returns string or undef"
Replaces all non-printable or non-ascii characters in a string with their
hex-escaped representation (e.g., \f(CW\*(C`\ex00\*(C'\fR).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 157:" 4
.IX Item "Around line 157:"
L<> starts or ends with whitespace
.Sp
L<> starts or ends with whitespace
                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::v1::Record.3pm                    0100644 0001750 0001750 00000016000 12566242050 024665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::v1::Record 3"
.TH Mail::SPF::v1::Record 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::v1::Record \- SPFv1 record class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Mail::SPF::Record.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::v1::Record\fR represents an \fBSPFv1\fR (\f(CW\*(C`v=spf1\*(C'\fR)
record.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::v1::Record\fR" 4
.IX Item "new(%options): returns Mail::SPF::v1::Record"
Creates a new SPFv1 record object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.PD
See \*(L"new\*(R" in Mail::SPF::Record.
.IP "\fBscopes\fR" 4
.IX Item "scopes"
See \*(L"new\*(R" in Mail::SPF::Record.  Since SPFv1 records always implicitly cover the
\&\f(CW\*(C`helo\*(C'\fR and \f(CW\*(C`mfrom\*(C'\fR scopes, this option must either be exactly \fB['helo',
\&'mfrom']\fR (or \fB['mfrom', 'helo']\fR) or be omitted.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::v1::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::v1::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::v1::Record; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidRecordVersion, Mail::SPF::ESyntaxError"
Creates a new SPFv1 record object by parsing the string and any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBversion_tag_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "version_tag_pattern: returns Regexp"
Returns a regular expression that matches a version tag of \fB'v=spf1'\fR.
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBresults_by_qualifier\fR" 4
.IX Item "results_by_qualifier"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Record.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBscopes\fR" 4
.IX Item "scopes"
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.IP "\fBglobal_mod\fR" 4
.IX Item "global_mod"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBeval\fR" 4
.IX Item "eval"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Record.
.IP "\fBversion_tag\fR: returns \fIstring\fR" 4
.IX Item "version_tag: returns string"
Returns \fB'v=spf1'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech,
Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::v1::Record5.16.3pm                0100644 0001750 0001750 00000015457 12566242063 025222  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::v1::Record 3"
.TH Mail::SPF::v1::Record 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::v1::Record \- SPFv1 record class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Mail::SPF::Record.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::v1::Record\fR represents an \fBSPFv1\fR (\f(CW\*(C`v=spf1\*(C'\fR)
record.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::v1::Record\fR" 4
.IX Item "new(%options): returns Mail::SPF::v1::Record"
Creates a new SPFv1 record object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.PD
See \*(L"new\*(R" in Mail::SPF::Record.
.IP "\fBscopes\fR" 4
.IX Item "scopes"
See \*(L"new\*(R" in Mail::SPF::Record.  Since SPFv1 records always implicitly cover the
\&\f(CW\*(C`helo\*(C'\fR and \f(CW\*(C`mfrom\*(C'\fR scopes, this option must either be exactly \fB['helo',
\&'mfrom']\fR (or \fB['mfrom', 'helo']\fR) or be omitted.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::v1::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::v1::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::v1::Record; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidRecordVersion, Mail::SPF::ESyntaxError"
Creates a new SPFv1 record object by parsing the string and any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBversion_tag_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "version_tag_pattern: returns Regexp"
Returns a regular expression that matches a version tag of \fB'v=spf1'\fR.
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBresults_by_qualifier\fR" 4
.IX Item "results_by_qualifier"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Record.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBscopes\fR" 4
.IX Item "scopes"
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.IP "\fBglobal_mod\fR" 4
.IX Item "global_mod"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBeval\fR" 4
.IX Item "eval"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Record.
.IP "\fBversion_tag\fR: returns \fIstring\fR" 4
.IX Item "version_tag: returns string"
Returns \fB'v=spf1'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech,
Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::v1::Record5.18.3pm                0100644 0001750 0001750 00000016000 12566242050 025201  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::v1::Record 3"
.TH Mail::SPF::v1::Record 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::v1::Record \- SPFv1 record class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Mail::SPF::Record.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::v1::Record\fR represents an \fBSPFv1\fR (\f(CW\*(C`v=spf1\*(C'\fR)
record.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::v1::Record\fR" 4
.IX Item "new(%options): returns Mail::SPF::v1::Record"
Creates a new SPFv1 record object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.PD
See \*(L"new\*(R" in Mail::SPF::Record.
.IP "\fBscopes\fR" 4
.IX Item "scopes"
See \*(L"new\*(R" in Mail::SPF::Record.  Since SPFv1 records always implicitly cover the
\&\f(CW\*(C`helo\*(C'\fR and \f(CW\*(C`mfrom\*(C'\fR scopes, this option must either be exactly \fB['helo',
\&'mfrom']\fR (or \fB['mfrom', 'helo']\fR) or be omitted.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::v1::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::v1::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::v1::Record; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidRecordVersion, Mail::SPF::ESyntaxError"
Creates a new SPFv1 record object by parsing the string and any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBversion_tag_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "version_tag_pattern: returns Regexp"
Returns a regular expression that matches a version tag of \fB'v=spf1'\fR.
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBresults_by_qualifier\fR" 4
.IX Item "results_by_qualifier"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Record.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBscopes\fR" 4
.IX Item "scopes"
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.IP "\fBglobal_mod\fR" 4
.IX Item "global_mod"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBeval\fR" 4
.IX Item "eval"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Record.
.IP "\fBversion_tag\fR: returns \fIstring\fR" 4
.IX Item "version_tag: returns string"
Returns \fB'v=spf1'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech,
Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::v2::Record.3pm                    0100644 0001750 0001750 00000016470 12566242050 024701  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::v2::Record 3"
.TH Mail::SPF::v2::Record 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::v2::Record \- Sender ID ("spf2.0") record class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Mail::SPF::Record.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::v2::Record\fR represents a \fBSender \s-1ID\s0\fR
(\f(CW\*(C`spf2.0\*(C'\fR) record.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::v2::Record\fR" 4
.IX Item "new(%options): returns Mail::SPF::v2::Record"
Creates a new Sender \s-1ID \s0(\*(L"spf2.0\*(R") record object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.PD
See \*(L"new\*(R" in Mail::SPF::Record.
.IP "\fBscopes\fR" 4
.IX Item "scopes"
\&\fIRequired\fR.  See \*(L"new\*(R" in Mail::SPF::Record.  The \fB'mfrom'\fR and \fB'pra'\fR scopes
are supported.  There is no default.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::v2::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::v2::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::v2::Record; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidRecordVersion, Mail::SPF::ESyntaxError"
Creates a new Sender \s-1ID \s0(\*(L"spf2.0\*(R") record object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBversion_tag_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "version_tag_pattern: returns Regexp"
Returns a regular expression that matches a version tag of \fB'spf2.0/'\fR plus a
comma-separated list of any of the \fB'mfrom'\fR and \fB'pra'\fR scopes.  The
following are valid version tags:
.Sp
.Vb 4
\&    spf2.0/mfrom
\&    spf2.0/pra
\&    spf2.0/mfrom,pra
\&    spf2.0/pra,mfrom
.Ve
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBresults_by_qualifier\fR" 4
.IX Item "results_by_qualifier"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Record.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBscopes\fR" 4
.IX Item "scopes"
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.IP "\fBglobal_mod\fR" 4
.IX Item "global_mod"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBeval\fR" 4
.IX Item "eval"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Record.
.IP "\fBversion_tag\fR: returns \fIstring\fR" 4
.IX Item "version_tag: returns string"
Returns \fB'spf2.0/'\fR plus a comma-separated list of the scopes of the record.
See \*(L"version_tag_pattern\*(R" for a list of possible return values.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech,
Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::v2::Record5.16.3pm                0100644 0001750 0001750 00000016147 12566242063 025220  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::v2::Record 3"
.TH Mail::SPF::v2::Record 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::v2::Record \- Sender ID ("spf2.0") record class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Mail::SPF::Record.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::v2::Record\fR represents a \fBSender \s-1ID\s0\fR
(\f(CW\*(C`spf2.0\*(C'\fR) record.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::v2::Record\fR" 4
.IX Item "new(%options): returns Mail::SPF::v2::Record"
Creates a new Sender \s-1ID\s0 (\*(L"spf2.0\*(R") record object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.PD
See \*(L"new\*(R" in Mail::SPF::Record.
.IP "\fBscopes\fR" 4
.IX Item "scopes"
\&\fIRequired\fR.  See \*(L"new\*(R" in Mail::SPF::Record.  The \fB'mfrom'\fR and \fB'pra'\fR scopes
are supported.  There is no default.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::v2::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::v2::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::v2::Record; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidRecordVersion, Mail::SPF::ESyntaxError"
Creates a new Sender \s-1ID\s0 (\*(L"spf2.0\*(R") record object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBversion_tag_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "version_tag_pattern: returns Regexp"
Returns a regular expression that matches a version tag of \fB'spf2.0/'\fR plus a
comma-separated list of any of the \fB'mfrom'\fR and \fB'pra'\fR scopes.  The
following are valid version tags:
.Sp
.Vb 4
\&    spf2.0/mfrom
\&    spf2.0/pra
\&    spf2.0/mfrom,pra
\&    spf2.0/pra,mfrom
.Ve
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBresults_by_qualifier\fR" 4
.IX Item "results_by_qualifier"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Record.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBscopes\fR" 4
.IX Item "scopes"
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.IP "\fBglobal_mod\fR" 4
.IX Item "global_mod"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBeval\fR" 4
.IX Item "eval"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Record.
.IP "\fBversion_tag\fR: returns \fIstring\fR" 4
.IX Item "version_tag: returns string"
Returns \fB'spf2.0/'\fR plus a comma-separated list of the scopes of the record.
See \*(L"version_tag_pattern\*(R" for a list of possible return values.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech,
Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::v2::Record5.18.3pm                0100644 0001750 0001750 00000016470 12566242050 025215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::v2::Record 3"
.TH Mail::SPF::v2::Record 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::v2::Record \- Sender ID ("spf2.0") record class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Mail::SPF::Record.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::v2::Record\fR represents a \fBSender \s-1ID\s0\fR
(\f(CW\*(C`spf2.0\*(C'\fR) record.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::v2::Record\fR" 4
.IX Item "new(%options): returns Mail::SPF::v2::Record"
Creates a new Sender \s-1ID \s0(\*(L"spf2.0\*(R") record object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.PD
See \*(L"new\*(R" in Mail::SPF::Record.
.IP "\fBscopes\fR" 4
.IX Item "scopes"
\&\fIRequired\fR.  See \*(L"new\*(R" in Mail::SPF::Record.  The \fB'mfrom'\fR and \fB'pra'\fR scopes
are supported.  There is no default.
.RE
.RS 4
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::v2::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::v2::Record\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidRecordVersion\fR, \fIMail::SPF::ESyntaxError\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::v2::Record; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidRecordVersion, Mail::SPF::ESyntaxError"
Creates a new Sender \s-1ID \s0(\*(L"spf2.0\*(R") record object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBversion_tag_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "version_tag_pattern: returns Regexp"
Returns a regular expression that matches a version tag of \fB'spf2.0/'\fR plus a
comma-separated list of any of the \fB'mfrom'\fR and \fB'pra'\fR scopes.  The
following are valid version tags:
.Sp
.Vb 4
\&    spf2.0/mfrom
\&    spf2.0/pra
\&    spf2.0/mfrom,pra
\&    spf2.0/pra,mfrom
.Ve
.IP "\fBdefault_qualifier\fR" 4
.IX Item "default_qualifier"
.PD 0
.IP "\fBresults_by_qualifier\fR" 4
.IX Item "results_by_qualifier"
.PD
See \*(L"Class methods\*(R" in Mail::SPF::Record.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR" 4
.IX Item "text"
.PD 0
.IP "\fBscopes\fR" 4
.IX Item "scopes"
.IP "\fBterms\fR" 4
.IX Item "terms"
.IP "\fBglobal_mods\fR" 4
.IX Item "global_mods"
.IP "\fBglobal_mod\fR" 4
.IX Item "global_mod"
.IP "\fBstringify\fR" 4
.IX Item "stringify"
.IP "\fBeval\fR" 4
.IX Item "eval"
.PD
See \*(L"Instance methods\*(R" in Mail::SPF::Record.
.IP "\fBversion_tag\fR: returns \fIstring\fR" 4
.IX Item "version_tag: returns string"
Returns \fB'spf2.0/'\fR plus a comma-separated list of the scopes of the record.
See \*(L"version_tag_pattern\*(R" for a list of possible return values.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term, Mail::SPF::Mech,
Mail::SPF::Mod
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Send.3pm                               0100644 0001750 0001750 00000017456 12566241445 023177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Send 3"
.TH Mail::Send 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Send \- Simple electronic mail interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  require Mail::Send;
\&
\&  $msg = Mail::Send\->new;
\&  $msg = Mail::Send\->new(Subject => \*(Aqexample\*(Aq, To => \*(Aqtimbo\*(Aq);
\&
\&  $msg\->to(\*(Aquser@host\*(Aq);
\&  $msg\->to(\*(Aquser@host\*(Aq, \*(Aquser2@example.com\*(Aq);
\&  $msg\->subject(\*(Aqexample subject\*(Aq);
\&  $msg\->cc(\*(Aquser@host\*(Aq);
\&  $msg\->bcc(\*(Aqsomeone@else\*(Aq);
\&
\&  $msg\->set($header, @values);
\&  $msg\->add($header, @values);
\&  $msg\->delete($header);
\&
\&  # Launch mailer and set headers. The filehandle returned
\&  # by open() is an instance of the Mail::Mailer class.
\&  # Arguments to the open() method are passed to the Mail::Mailer
\&  # constructor.
\&
\&  $fh = $msg\->open;   # some default mailer
\&  $fh = $msg\->open(\*(Aqsendmail\*(Aq); # explicit
\&  print $fh "Body of message";
\&  $fh\->close          # complete the message and send it
\&      or die "couldn\*(Aqt send whole message: $!\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mail::Send creates e\-mail messages without using the Mail::Header
knowledge, which means that all escaping and folding must be done by
you!  Simplicity has its price.
.PP
When you have time, take a look at Mail::Transport
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Send\->\fBnew\fR(\s-1PAIRS\s0)" 4
.IX Item "Mail::Send->new(PAIRS)"
A list of header fields (provided as key-value \s-1PAIRS\s0) can be
used to initialize the object.
.SS "Header fields"
.IX Subsection "Header fields"
.ie n .IP "$obj\->\fBadd\fR(\s-1FIELDNAME, VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1FIELDNAME, VALUES\s0)" 4
.IX Item "$obj->add(FIELDNAME, VALUES)"
Add values to the list of defined values for the \s-1FIELDNAME.\s0
.ie n .IP "$obj\->\fBbcc\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBbcc\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->bcc(VALUES)"
.PD 0
.ie n .IP "$obj\->\fBcc\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcc\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->cc(VALUES)"
.ie n .IP "$obj\->\fBdelete\fR(\s-1FIELDNAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1FIELDNAME\s0)" 4
.IX Item "$obj->delete(FIELDNAME)"
.ie n .IP "$obj\->\fBset\fR(\s-1FIELDNAME, VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1FIELDNAME, VALUES\s0)" 4
.IX Item "$obj->set(FIELDNAME, VALUES)"
.PD
\&\s-1VALUES\s0 will replace the old values for the \s-1FIELDNAME. \s0 Returned is
the \s-1LIST\s0 of values after modification.
.ie n .IP "$obj\->\fBsubject\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsubject\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->subject(VALUES)"
.PD 0
.ie n .IP "$obj\->\fBto\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBto\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->to(VALUES)"
.PD
.SS "Sending"
.IX Subsection "Sending"
.ie n .IP "$obj\->\fBopen\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBopen\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->open(OPTIONS)"
The \s-1OPTIONS\s0 are used to initiate a mailer object via
\&\fIMail::Mailer::new()\fR.  Then \fIMail::Mailer::open()\fR is called
with the knowledge collected in this Mail::Send object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Send5.16.3pm                           0100644 0001750 0001750 00000017171 12566241445 023503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Send 3"
.TH Mail::Send 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Send \- Simple electronic mail interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  require Mail::Send;
\&
\&  $msg = Mail::Send\->new;
\&  $msg = Mail::Send\->new(Subject => \*(Aqexample\*(Aq, To => \*(Aqtimbo\*(Aq);
\&
\&  $msg\->to(\*(Aquser@host\*(Aq);
\&  $msg\->to(\*(Aquser@host\*(Aq, \*(Aquser2@example.com\*(Aq);
\&  $msg\->subject(\*(Aqexample subject\*(Aq);
\&  $msg\->cc(\*(Aquser@host\*(Aq);
\&  $msg\->bcc(\*(Aqsomeone@else\*(Aq);
\&
\&  $msg\->set($header, @values);
\&  $msg\->add($header, @values);
\&  $msg\->delete($header);
\&
\&  # Launch mailer and set headers. The filehandle returned
\&  # by open() is an instance of the Mail::Mailer class.
\&  # Arguments to the open() method are passed to the Mail::Mailer
\&  # constructor.
\&
\&  $fh = $msg\->open;   # some default mailer
\&  $fh = $msg\->open(\*(Aqsendmail\*(Aq); # explicit
\&  print $fh "Body of message";
\&  $fh\->close          # complete the message and send it
\&      or die "couldn\*(Aqt send whole message: $!\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mail::Send creates e\-mail messages without using the Mail::Header
knowledge, which means that all escaping and folding must be done by
you!  Simplicity has its price.
.PP
When you have time, take a look at Mail::Transport
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Send\->\fBnew\fR(\s-1PAIRS\s0)" 4
.IX Item "Mail::Send->new(PAIRS)"
A list of header fields (provided as key-value \s-1PAIRS\s0) can be
used to initialize the object.
.SS "Header fields"
.IX Subsection "Header fields"
.ie n .IP "$obj\->\fBadd\fR(\s-1FIELDNAME\s0, \s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1FIELDNAME\s0, \s-1VALUES\s0)" 4
.IX Item "$obj->add(FIELDNAME, VALUES)"
Add values to the list of defined values for the \s-1FIELDNAME\s0.
.ie n .IP "$obj\->\fBbcc\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBbcc\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->bcc(VALUES)"
.PD 0
.ie n .IP "$obj\->\fBcc\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcc\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->cc(VALUES)"
.ie n .IP "$obj\->\fBdelete\fR(\s-1FIELDNAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1FIELDNAME\s0)" 4
.IX Item "$obj->delete(FIELDNAME)"
.ie n .IP "$obj\->\fBset\fR(\s-1FIELDNAME\s0, \s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1FIELDNAME\s0, \s-1VALUES\s0)" 4
.IX Item "$obj->set(FIELDNAME, VALUES)"
.PD
\&\s-1VALUES\s0 will replace the old values for the \s-1FIELDNAME\s0.  Returned is
the \s-1LIST\s0 of values after modification.
.ie n .IP "$obj\->\fBsubject\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsubject\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->subject(VALUES)"
.PD 0
.ie n .IP "$obj\->\fBto\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBto\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->to(VALUES)"
.PD
.SS "Sending"
.IX Subsection "Sending"
.ie n .IP "$obj\->\fBopen\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBopen\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->open(OPTIONS)"
The \s-1OPTIONS\s0 are used to initiate a mailer object via
\&\fIMail::Mailer::new()\fR.  Then \fIMail::Mailer::open()\fR is called
with the knowledge collected in this Mail::Send object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Send5.18.3pm                           0100644 0001750 0001750 00000017456 12566241445 023513  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Send 3"
.TH Mail::Send 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Send \- Simple electronic mail interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  require Mail::Send;
\&
\&  $msg = Mail::Send\->new;
\&  $msg = Mail::Send\->new(Subject => \*(Aqexample\*(Aq, To => \*(Aqtimbo\*(Aq);
\&
\&  $msg\->to(\*(Aquser@host\*(Aq);
\&  $msg\->to(\*(Aquser@host\*(Aq, \*(Aquser2@example.com\*(Aq);
\&  $msg\->subject(\*(Aqexample subject\*(Aq);
\&  $msg\->cc(\*(Aquser@host\*(Aq);
\&  $msg\->bcc(\*(Aqsomeone@else\*(Aq);
\&
\&  $msg\->set($header, @values);
\&  $msg\->add($header, @values);
\&  $msg\->delete($header);
\&
\&  # Launch mailer and set headers. The filehandle returned
\&  # by open() is an instance of the Mail::Mailer class.
\&  # Arguments to the open() method are passed to the Mail::Mailer
\&  # constructor.
\&
\&  $fh = $msg\->open;   # some default mailer
\&  $fh = $msg\->open(\*(Aqsendmail\*(Aq); # explicit
\&  print $fh "Body of message";
\&  $fh\->close          # complete the message and send it
\&      or die "couldn\*(Aqt send whole message: $!\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mail::Send creates e\-mail messages without using the Mail::Header
knowledge, which means that all escaping and folding must be done by
you!  Simplicity has its price.
.PP
When you have time, take a look at Mail::Transport
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Send\->\fBnew\fR(\s-1PAIRS\s0)" 4
.IX Item "Mail::Send->new(PAIRS)"
A list of header fields (provided as key-value \s-1PAIRS\s0) can be
used to initialize the object.
.SS "Header fields"
.IX Subsection "Header fields"
.ie n .IP "$obj\->\fBadd\fR(\s-1FIELDNAME, VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1FIELDNAME, VALUES\s0)" 4
.IX Item "$obj->add(FIELDNAME, VALUES)"
Add values to the list of defined values for the \s-1FIELDNAME.\s0
.ie n .IP "$obj\->\fBbcc\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBbcc\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->bcc(VALUES)"
.PD 0
.ie n .IP "$obj\->\fBcc\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcc\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->cc(VALUES)"
.ie n .IP "$obj\->\fBdelete\fR(\s-1FIELDNAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1FIELDNAME\s0)" 4
.IX Item "$obj->delete(FIELDNAME)"
.ie n .IP "$obj\->\fBset\fR(\s-1FIELDNAME, VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1FIELDNAME, VALUES\s0)" 4
.IX Item "$obj->set(FIELDNAME, VALUES)"
.PD
\&\s-1VALUES\s0 will replace the old values for the \s-1FIELDNAME. \s0 Returned is
the \s-1LIST\s0 of values after modification.
.ie n .IP "$obj\->\fBsubject\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsubject\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->subject(VALUES)"
.PD 0
.ie n .IP "$obj\->\fBto\fR(\s-1VALUES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBto\fR(\s-1VALUES\s0)" 4
.IX Item "$obj->to(VALUES)"
.PD
.SS "Sending"
.IX Subsection "Sending"
.ie n .IP "$obj\->\fBopen\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBopen\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->open(OPTIONS)"
The \s-1OPTIONS\s0 are used to initiate a mailer object via
\&\fIMail::Mailer::new()\fR.  Then \fIMail::Mailer::open()\fR is called
with the knowledge collected in this Mail::Send object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Util.3pm                               0100644 0001750 0001750 00000016701 12566241445 023213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Util 3"
.TH Mail::Util 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Util \- mail utility functions
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Util
\&   is a Exporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::Util qw( ... );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package provides several mail related utility functions. Any function
required must by explicitly listed on the use line to be exported into
the calling package.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\fBmailaddress\fR([\s-1ADDRESS\s0])" 4
.IX Item "mailaddress([ADDRESS])"
Return a guess at the current users mail address. The user can force
the return value by setting the \s-1MAILADDRESS\s0 environment variable.
[2.10] You may set the \s-1ADDRESS\s0 via the parameter.
.Sp
\&\s-1WARNING:\s0
When not supplied via the environment variable, <mailaddress> looks at
various configuration files and other environmental data. Although this
seems to be smart behavior, this is not predictable enough (\s-1IMHO\s0) to
be used.  Please set the \s-1MAILADDRESS\s0 explicitly, and do not trust on
the \*(L"automatic detection\*(R", even when that produces a correct address
(on the moment)
.Sp
example:
.Sp
.Vb 2
\& # in your main script
\& $ENV{MAILADDRESS} = \*(Aqme@example.com\*(Aq;
\&
\& # everywhere else
\& use Mail::Util \*(Aqmailaddress\*(Aq;
\& print mailaddress;
\&
\& # since v2.10
\& mailaddress "me@example.com";
.Ve
.IP "\fBmaildomain\fR()" 4
.IX Item "maildomain()"
Attempt to determine the current user mail domain string via the following
methods
.RS 4
.IP "\(bu" 4
Look for the \s-1MAILDOMAIN\s0 environment variable, which can be set from outside the program.  This is by far the best way to configure the domain.
.IP "\(bu" 4
Look for a sendmail.cf file and extract \s-1DH\s0 parameter
.IP "\(bu" 4
Look for a smail config file and usr the first host defined in hostname(s)
.IP "\(bu" 4
Try an \s-1SMTP\s0 connect (if Net::SMTP exists) first to mailhost then localhost
.IP "\(bu" 4
Use value from Net::Domain::domainname (if Net::Domain exists)
.RE
.RS 4
.Sp
\&\s-1WARNING:\s0
On modern machines, there is only one good way to provide information to
this method: the first; always explicitly configure the \s-1MAILDOMAIN.\s0
.Sp
example:
.Sp
.Vb 2
\& # in your main script
\& $ENV{MAILDOMAIN} = \*(Aqexample.com\*(Aq;
\&
\& # everywhere else
\& use Mail::Util \*(Aqmaildomain\*(Aq;
\& print maildomain;
.Ve
.RE
.IP "\fBread_mbox\fR(\s-1FILE\s0)" 4
.IX Item "read_mbox(FILE)"
Read \s-1FILE,\s0 a binmail mailbox file, and return a list of  references.
Each reference is a reference to an array containing one message.
.Sp
\&\s-1WARNING:\s0
This method does not quote lines which accidentally also start with the
message separator \f(CW\*(C`From\*(C'\fR, so this implementation can be considered
broken.  See Mail::Box::Mbox
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Util5.16.3pm                           0100644 0001750 0001750 00000016355 12566241445 023532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Util 3"
.TH Mail::Util 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Util \- mail utility functions
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Util
\&   is a Exporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::Util qw( ... );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package provides several mail related utility functions. Any function
required must by explicitly listed on the use line to be exported into
the calling package.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\fBmailaddress\fR([\s-1ADDRESS\s0])" 4
.IX Item "mailaddress([ADDRESS])"
Return a guess at the current users mail address. The user can force
the return value by setting the \s-1MAILADDRESS\s0 environment variable.
[2.10] You may set the \s-1ADDRESS\s0 via the parameter.
.Sp
\&\s-1WARNING:\s0
When not supplied via the environment variable, <mailaddress> looks at
various configuration files and other environmental data. Although this
seems to be smart behavior, this is not predictable enough (\s-1IMHO\s0) to
be used.  Please set the \s-1MAILADDRESS\s0 explicitly, and do not trust on
the \*(L"automatic detection\*(R", even when that produces a correct address
(on the moment)
.Sp
example:
.Sp
.Vb 2
\& # in your main script
\& $ENV{MAILADDRESS} = \*(Aqme@example.com\*(Aq;
\&
\& # everywhere else
\& use Mail::Util \*(Aqmailaddress\*(Aq;
\& print mailaddress;
\&
\& # since v2.10
\& mailaddress "me@example.com";
.Ve
.IP "\fBmaildomain\fR()" 4
.IX Item "maildomain()"
Attempt to determine the current uers mail domain string via the following
methods
.RS 4
.IP "\(bu" 4
Look for the \s-1MAILDOMAIN\s0 enviroment variable, which can be set from outside the program.  This is by far the best way to configure the domain.
.IP "\(bu" 4
Look for a sendmail.cf file and extract \s-1DH\s0 parameter
.IP "\(bu" 4
Look for a smail config file and usr the first host defined in hostname(s)
.IP "\(bu" 4
Try an \s-1SMTP\s0 connect (if Net::SMTP exists) first to mailhost then localhost
.IP "\(bu" 4
Use value from Net::Domain::domainname (if Net::Domain exists)
.RE
.RS 4
.Sp
\&\s-1WARNING:\s0
On modern machines, there is only one good way to provide information to
this method: the first; always explicitly configure the \s-1MAILDOMAIN\s0.
.Sp
example:
.Sp
.Vb 2
\& # in your main script
\& $ENV{MAILDOMAIN} = \*(Aqexample.com\*(Aq;
\&
\& # everywhere else
\& use Mail::Util \*(Aqmaildomain\*(Aq;
\& print maildomain;
.Ve
.RE
.IP "\fBread_mbox\fR(\s-1FILE\s0)" 4
.IX Item "read_mbox(FILE)"
Read \s-1FILE\s0, a binmail mailbox file, and return a list of  references.
Each reference is a reference to an array containg one message.
.Sp
\&\s-1WARNING:\s0
This method does not quote lines which accidentally also start with the
message separator \f(CW\*(C`From\*(C'\fR, so this implementation can be considered
broken.  See Mail::Box::Mbox
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Util5.18.3pm                           0100644 0001750 0001750 00000016701 12566241445 023527  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Util 3"
.TH Mail::Util 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Util \- mail utility functions
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Util
\&   is a Exporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::Util qw( ... );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package provides several mail related utility functions. Any function
required must by explicitly listed on the use line to be exported into
the calling package.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\fBmailaddress\fR([\s-1ADDRESS\s0])" 4
.IX Item "mailaddress([ADDRESS])"
Return a guess at the current users mail address. The user can force
the return value by setting the \s-1MAILADDRESS\s0 environment variable.
[2.10] You may set the \s-1ADDRESS\s0 via the parameter.
.Sp
\&\s-1WARNING:\s0
When not supplied via the environment variable, <mailaddress> looks at
various configuration files and other environmental data. Although this
seems to be smart behavior, this is not predictable enough (\s-1IMHO\s0) to
be used.  Please set the \s-1MAILADDRESS\s0 explicitly, and do not trust on
the \*(L"automatic detection\*(R", even when that produces a correct address
(on the moment)
.Sp
example:
.Sp
.Vb 2
\& # in your main script
\& $ENV{MAILADDRESS} = \*(Aqme@example.com\*(Aq;
\&
\& # everywhere else
\& use Mail::Util \*(Aqmailaddress\*(Aq;
\& print mailaddress;
\&
\& # since v2.10
\& mailaddress "me@example.com";
.Ve
.IP "\fBmaildomain\fR()" 4
.IX Item "maildomain()"
Attempt to determine the current user mail domain string via the following
methods
.RS 4
.IP "\(bu" 4
Look for the \s-1MAILDOMAIN\s0 environment variable, which can be set from outside the program.  This is by far the best way to configure the domain.
.IP "\(bu" 4
Look for a sendmail.cf file and extract \s-1DH\s0 parameter
.IP "\(bu" 4
Look for a smail config file and usr the first host defined in hostname(s)
.IP "\(bu" 4
Try an \s-1SMTP\s0 connect (if Net::SMTP exists) first to mailhost then localhost
.IP "\(bu" 4
Use value from Net::Domain::domainname (if Net::Domain exists)
.RE
.RS 4
.Sp
\&\s-1WARNING:\s0
On modern machines, there is only one good way to provide information to
this method: the first; always explicitly configure the \s-1MAILDOMAIN.\s0
.Sp
example:
.Sp
.Vb 2
\& # in your main script
\& $ENV{MAILDOMAIN} = \*(Aqexample.com\*(Aq;
\&
\& # everywhere else
\& use Mail::Util \*(Aqmaildomain\*(Aq;
\& print maildomain;
.Ve
.RE
.IP "\fBread_mbox\fR(\s-1FILE\s0)" 4
.IX Item "read_mbox(FILE)"
Read \s-1FILE,\s0 a binmail mailbox file, and return a list of  references.
Each reference is a reference to an array containing one message.
.Sp
\&\s-1WARNING:\s0
This method does not quote lines which accidentally also start with the
message separator \f(CW\*(C`From\*(C'\fR, so this implementation can be considered
broken.  See Mail::Box::Mbox
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Math::BigFloat.3pm                           0100644 0001750 0001750 00000075507 12566207460 024004  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigFloat 3pm"
.TH Math::BigFloat 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigFloat \- Arbitrary size floating point math package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Math::BigFloat;
\&
\& # Number creation
\& my $x = Math::BigFloat\->new($str);     # defaults to 0
\& my $y = $x\->copy();                    # make a true copy
\& my $nan  = Math::BigFloat\->bnan();     # create a NotANumber
\& my $zero = Math::BigFloat\->bzero();    # create a +0
\& my $inf = Math::BigFloat\->binf();      # create a +inf
\& my $inf = Math::BigFloat\->binf(\*(Aq\-\*(Aq);   # create a \-inf
\& my $one = Math::BigFloat\->bone();      # create a +1
\& my $mone = Math::BigFloat\->bone(\*(Aq\-\*(Aq);  # create a \-1
\&
\& my $pi = Math::BigFloat\->bpi(100);     # PI to 100 digits
\&
\& # the following examples compute their result to 100 digits accuracy:
\& my $cos  = Math::BigFloat\->new(1)\->bcos(100);        # cosinus(1)
\& my $sin  = Math::BigFloat\->new(1)\->bsin(100);        # sinus(1)
\& my $atan = Math::BigFloat\->new(1)\->batan(100);       # arcus tangens(1)
\&
\& my $atan2 = Math::BigFloat\->new(  1 )\->batan2( 1 ,100); # batan(1)
\& my $atan2 = Math::BigFloat\->new(  1 )\->batan2( 8 ,100); # batan(1/8)
\& my $atan2 = Math::BigFloat\->new( \-2 )\->batan2( 1 ,100); # batan(\-2)
\&
\& # Testing
\& $x\->is_zero();          # true if arg is +0
\& $x\->is_nan();           # true if arg is NaN
\& $x\->is_one();           # true if arg is +1
\& $x\->is_one(\*(Aq\-\*(Aq);        # true if arg is \-1
\& $x\->is_odd();           # true if odd, false for even
\& $x\->is_even();          # true if even, false for odd
\& $x\->is_pos();           # true if >= 0
\& $x\->is_neg();           # true if <  0
\& $x\->is_inf(sign);       # true if +inf, or \-inf (default is \*(Aq+\*(Aq)
\&
\& $x\->bcmp($y);           # compare numbers (undef,<0,=0,>0)
\& $x\->bacmp($y);          # compare absolutely (undef,<0,=0,>0)
\& $x\->sign();             # return the sign, either +,\- or NaN
\& $x\->digit($n);          # return the nth digit, counting from right
\& $x\->digit(\-$n);         # return the nth digit, counting from left 
\&
\& # The following all modify their first argument. If you want to pre\-
\& # serve $x, use $z = $x\->copy()\->bXXX($y); See under L</CAVEATS> for
\& # necessary when mixing $a = $b assignments with non\-overloaded math.
\&
\& # set 
\& $x\->bzero();            # set $i to 0
\& $x\->bnan();             # set $i to NaN
\& $x\->bone();             # set $x to +1
\& $x\->bone(\*(Aq\-\*(Aq);          # set $x to \-1
\& $x\->binf();             # set $x to inf
\& $x\->binf(\*(Aq\-\*(Aq);          # set $x to \-inf
\&
\& $x\->bneg();             # negation
\& $x\->babs();             # absolute value
\& $x\->bnorm();            # normalize (no\-op)
\& $x\->bnot();             # two\*(Aqs complement (bit wise not)
\& $x\->binc();             # increment x by 1
\& $x\->bdec();             # decrement x by 1
\&
\& $x\->badd($y);           # addition (add $y to $x)
\& $x\->bsub($y);           # subtraction (subtract $y from $x)
\& $x\->bmul($y);           # multiplication (multiply $x by $y)
\& $x\->bdiv($y);           # divide, set $x to quotient
\&                         # return (quo,rem) or quo if scalar
\&
\& $x\->bmod($y);           # modulus ($x % $y)
\& $x\->bpow($y);           # power of arguments ($x ** $y)
\& $x\->bmodpow($exp,$mod); # modular exponentiation (($num**$exp) % $mod))
\& $x\->blsft($y, $n);      # left shift by $y places in base $n
\& $x\->brsft($y, $n);      # right shift by $y places in base $n
\&                         # returns (quo,rem) or quo if in scalar context
\&
\& $x\->blog();             # logarithm of $x to base e (Euler\*(Aqs number)
\& $x\->blog($base);        # logarithm of $x to base $base (f.i. 2)
\& $x\->bexp();             # calculate e ** $x where e is Euler\*(Aqs number
\&
\& $x\->band($y);           # bit\-wise and
\& $x\->bior($y);           # bit\-wise inclusive or
\& $x\->bxor($y);           # bit\-wise exclusive or
\& $x\->bnot();             # bit\-wise not (two\*(Aqs complement)
\&
\& $x\->bsqrt();            # calculate square\-root
\& $x\->broot($y);          # $y\*(Aqth root of $x (e.g. $y == 3 => cubic root)
\& $x\->bfac();             # factorial of $x (1*2*3*4*..$x)
\&
\& $x\->bround($N);         # accuracy: preserve $N digits
\& $x\->bfround($N);        # precision: round to the $Nth digit
\&
\& $x\->bfloor();           # return integer less or equal than $x
\& $x\->bceil();            # return integer greater or equal than $x
\&
\&  # The following do not modify their arguments:
\&
\& bgcd(@values);          # greatest common divisor
\& blcm(@values);          # lowest common multiplicator
\&
\& $x\->bstr();             # return string
\& $x\->bsstr();            # return string in scientific notation
\&
\& $x\->as_int();           # return $x as BigInt 
\& $x\->exponent();         # return exponent as BigInt
\& $x\->mantissa();         # return mantissa as BigInt
\& $x\->parts();            # return (mantissa,exponent) as BigInt
\&
\& $x\->length();           # number of digits (w/o sign and \*(Aq.\*(Aq)
\& ($l,$f) = $x\->length(); # number of digits, and length of fraction
\&
\& $x\->precision();        # return P of $x (or global, if P of $x undef)
\& $x\->precision($n);      # set P of $x to $n
\& $x\->accuracy();         # return A of $x (or global, if A of $x undef)
\& $x\->accuracy($n);       # set A $x to $n
\&
\& # these get/set the appropriate global value for all BigFloat objects
\& Math::BigFloat\->precision();   # Precision
\& Math::BigFloat\->accuracy();    # Accuracy
\& Math::BigFloat\->round_mode();  # rounding mode
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded if you
declare your big floating point numbers as
.PP
.Vb 1
\&  $i = new Math::BigFloat \*(Aq12_3.456_789_123_456_789E\-2\*(Aq;
.Ve
.PP
Operations with overloaded operators preserve the arguments, which is
exactly what you expect.
.SS "Canonical notation"
.IX Subsection "Canonical notation"
Input to these routines are either BigFloat objects, or strings of the
following four forms:
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+\e.\ed*$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+E[+\-]?\ed+$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed*\e.\ed+E[+\-]?\ed+$/\*(C'\fR
.PP
all with optional leading and trailing zeros and/or spaces. Additionally,
numbers are allowed to have an underscore between any two digits.
.PP
Empty strings as well as other illegal numbers results in 'NaN'.
.PP
\&\fIbnorm()\fR on a BigFloat object is now effectively a no-op, since the numbers 
are always stored in normalized form. On a string, it creates a BigFloat 
object.
.SS "Output"
.IX Subsection "Output"
Output values are BigFloat objects (normalized), except for \fIbstr()\fR and \fIbsstr()\fR.
.PP
The string output will always have leading and trailing zeros stripped and drop
a plus sign. \f(CW\*(C`bstr()\*(C'\fR will give you always the form with a decimal point,
while \f(CW\*(C`bsstr()\*(C'\fR (s for scientific) gives you the scientific notation.
.PP
.Vb 6
\&        Input                   bstr()          bsstr()
\&        \*(Aq\-0\*(Aq                    \*(Aq0\*(Aq             \*(Aq0E1\*(Aq
\&        \*(Aq  \-123 123 123\*(Aq        \*(Aq\-123123123\*(Aq    \*(Aq\-123123123E0\*(Aq
\&        \*(Aq00.0123\*(Aq               \*(Aq0.0123\*(Aq        \*(Aq123E\-4\*(Aq
\&        \*(Aq123.45E\-2\*(Aq             \*(Aq1.2345\*(Aq        \*(Aq12345E\-4\*(Aq
\&        \*(Aq10E+3\*(Aq                 \*(Aq10000\*(Aq         \*(Aq1E4\*(Aq
.Ve
.PP
Some routines (\f(CW\*(C`is_odd()\*(C'\fR, \f(CW\*(C`is_even()\*(C'\fR, \f(CW\*(C`is_zero()\*(C'\fR, \f(CW\*(C`is_one()\*(C'\fR,
\&\f(CW\*(C`is_nan()\*(C'\fR) return true or false, while others (\f(CW\*(C`bcmp()\*(C'\fR, \f(CW\*(C`bacmp()\*(C'\fR)
return either undef, <0, 0 or >0 and are suited for sort.
.PP
Actual math is done by using the class defined with \f(CW\*(C`with => Class;\*(C'\fR (which
defaults to BigInts) to represent the mantissa and exponent.
.PP
The sign \f(CW\*(C`/^[+\-]$/\*(C'\fR is stored separately. The string 'NaN' is used to 
represent the result when input arguments are not numbers, as well as 
the result of dividing by zero.
.ie n .SS """mantissa()"", ""exponent()"" and ""parts()"""
.el .SS "\f(CWmantissa()\fP, \f(CWexponent()\fP and \f(CWparts()\fP"
.IX Subsection "mantissa(), exponent() and parts()"
\&\f(CW\*(C`mantissa()\*(C'\fR and \f(CW\*(C`exponent()\*(C'\fR return the said parts of the BigFloat 
as BigInts such that:
.PP
.Vb 4
\&        $m = $x\->mantissa();
\&        $e = $x\->exponent();
\&        $y = $m * ( 10 ** $e );
\&        print "ok\en" if $x == $y;
.Ve
.PP
\&\f(CW\*(C`($m,$e) = $x\->parts();\*(C'\fR is just a shortcut giving you both of them.
.PP
A zero is represented and returned as \f(CW0E1\fR, \fBnot\fR \f(CW0E0\fR (after Knuth).
.PP
Currently the mantissa is reduced as much as possible, favouring higher
exponents over lower ones (e.g. returning 1e7 instead of 10e6 or 10000000e0).
This might change in the future, so do not depend on it.
.SS "Accuracy vs. Precision"
.IX Subsection "Accuracy vs. Precision"
See also: Rounding.
.PP
Math::BigFloat supports both precision (rounding to a certain place before or
after the dot) and accuracy (rounding to a certain number of digits). For a
full documentation, examples and tips on these topics please see the large
section about rounding in Math::BigInt.
.PP
Since things like \f(CWsqrt(2)\fR or \f(CW\*(C`1 / 3\*(C'\fR must presented with a limited
accuracy lest a operation consumes all resources, each operation produces
no more than the requested number of digits.
.PP
If there is no global precision or accuracy set, \fBand\fR the operation in
question was not called with a requested precision or accuracy, \fBand\fR the
input \f(CW$x\fR has no accuracy or precision set, then a fallback parameter will
be used. For historical reasons, it is called \f(CW\*(C`div_scale\*(C'\fR and can be accessed
via:
.PP
.Vb 2
\&        $d = Math::BigFloat\->div_scale();       # query
\&        Math::BigFloat\->div_scale($n);          # set to $n digits
.Ve
.PP
The default value for \f(CW\*(C`div_scale\*(C'\fR is 40.
.PP
In case the result of one operation has more digits than specified,
it is rounded. The rounding mode taken is either the default mode, or the one
supplied to the operation after the \fIscale\fR:
.PP
.Vb 7
\&    $x = Math::BigFloat\->new(2);
\&    Math::BigFloat\->accuracy(5);              # 5 digits max
\&    $y = $x\->copy()\->bdiv(3);                 # will give 0.66667
\&    $y = $x\->copy()\->bdiv(3,6);               # will give 0.666667
\&    $y = $x\->copy()\->bdiv(3,6,undef,\*(Aqodd\*(Aq);   # will give 0.666667
\&    Math::BigFloat\->round_mode(\*(Aqzero\*(Aq);
\&    $y = $x\->copy()\->bdiv(3,6);               # will also give 0.666667
.Ve
.PP
Note that \f(CW\*(C`Math::BigFloat\->accuracy()\*(C'\fR and \f(CW\*(C`Math::BigFloat\->precision()\*(C'\fR
set the global variables, and thus \fBany\fR newly created number will be subject
to the global rounding \fBimmediately\fR. This means that in the examples above, the
\&\f(CW3\fR as argument to \f(CW\*(C`bdiv()\*(C'\fR will also get an accuracy of \fB5\fR.
.PP
It is less confusing to either calculate the result fully, and afterwards
round it explicitly, or use the additional parameters to the math
functions like so:
.PP
.Vb 4
\&        use Math::BigFloat;
\&        $x = Math::BigFloat\->new(2);
\&        $y = $x\->copy()\->bdiv(3);
\&        print $y\->bround(5),"\en";               # will give 0.66667
\&
\&        or
\&
\&        use Math::BigFloat;
\&        $x = Math::BigFloat\->new(2);
\&        $y = $x\->copy()\->bdiv(3,5);             # will give 0.66667
\&        print "$y\en";
.Ve
.SS "Rounding"
.IX Subsection "Rounding"
.IP "ffround ( +$scale )" 2
.IX Item "ffround ( +$scale )"
Rounds to the \f(CW$scale\fR'th place left from the '.', counting from the dot.
The first digit is numbered 1.
.IP "ffround ( \-$scale )" 2
.IX Item "ffround ( -$scale )"
Rounds to the \f(CW$scale\fR'th place right from the '.', counting from the dot.
.IP "ffround ( 0 )" 2
.IX Item "ffround ( 0 )"
Rounds to an integer.
.IP "fround  ( +$scale )" 2
.IX Item "fround ( +$scale )"
Preserves accuracy to \f(CW$scale\fR digits from the left (aka significant digits)
and pads the rest with zeros. If the number is between 1 and \-1, the
significant digits count from the first non-zero after the '.'
.IP "fround  ( \-$scale ) and fround ( 0 )" 2
.IX Item "fround ( -$scale ) and fround ( 0 )"
These are effectively no-ops.
.PP
All rounding functions take as a second parameter a rounding mode from one of
the following: 'even', 'odd', '+inf', '\-inf', 'zero', 'trunc' or 'common'.
.PP
The default rounding mode is 'even'. By using
\&\f(CW\*(C`Math::BigFloat\->round_mode($round_mode);\*(C'\fR you can get and set the default
mode for subsequent rounding. The usage of \f(CW\*(C`$Math::BigFloat::$round_mode\*(C'\fR is
no longer supported.
The second parameter to the round functions then overrides the default
temporarily.
.PP
The \f(CW\*(C`as_number()\*(C'\fR function returns a BigInt from a Math::BigFloat. It uses
\&'trunc' as rounding mode to make it equivalent to:
.PP
.Vb 2
\&        $x = 2.5;
\&        $y = int($x) + 2;
.Ve
.PP
You can override this by passing the desired rounding mode as parameter to
\&\f(CW\*(C`as_number()\*(C'\fR:
.PP
.Vb 2
\&        $x = Math::BigFloat\->new(2.5);
\&        $y = $x\->as_number(\*(Aqodd\*(Aq);      # $y = 3
.Ve
.SH "METHODS"
.IX Header "METHODS"
Math::BigFloat supports all methods that Math::BigInt supports, except it
calculates non-integer results when possible. Please see Math::BigInt
for a full description of each method. Below are just the most important
differences:
.SS "accuracy"
.IX Subsection "accuracy"
.Vb 3
\&        $x\->accuracy(5);             # local for $x
\&        CLASS\->accuracy(5);          # global for all members of CLASS
\&                                     # Note: This also applies to new()!
\&
\&        $A = $x\->accuracy();         # read out accuracy that affects $x
\&        $A = CLASS\->accuracy();      # read out global accuracy
.Ve
.PP
Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to \fInew()\fR!
.PP
Warning! The accuracy \fIsticks\fR, e.g. once you created a number under the
influence of \f(CW\*(C`CLASS\->accuracy($A)\*(C'\fR, all results from math operations with
that number will also be rounded.
.PP
In most cases, you should probably round the results explicitly using one of
\&\*(L"\fIround()\fR\*(R" in Math::BigInt, \*(L"\fIbround()\fR\*(R" in Math::BigInt or \*(L"\fIbfround()\fR\*(R" in Math::BigInt or by passing the desired accuracy
to the math operation as additional parameter:
.PP
.Vb 4
\&        my $x = Math::BigInt\->new(30000);
\&        my $y = Math::BigInt\->new(7);
\&        print scalar $x\->copy()\->bdiv($y, 2);           # print 4300
\&        print scalar $x\->copy()\->bdiv($y)\->bround(2);   # print 4300
.Ve
.SS "\fIprecision()\fP"
.IX Subsection "precision()"
.Vb 4
\&        $x\->precision(\-2);      # local for $x, round at the second
\&                                # digit right of the dot
\&        $x\->precision(2);       # ditto, round at the second digit left
\&                                # of the dot
\&
\&        CLASS\->precision(5);    # Global for all members of CLASS
\&                                # This also applies to new()!
\&        CLASS\->precision(\-5);   # ditto
\&
\&        $P = CLASS\->precision();    # read out global precision
\&        $P = $x\->precision();       # read out precision that affects $x
.Ve
.PP
Note: You probably want to use \*(L"accuracy\*(R" instead. With \*(L"accuracy\*(R" you
set the number of digits each result should have, with \*(L"\fIprecision()\fR\*(R" you
set the place where to round!
.SS "\fIbexp()\fP"
.IX Subsection "bexp()"
.Vb 1
\&        $x\->bexp($accuracy);            # calculate e ** X
.Ve
.PP
Calculates the expression \f(CW\*(C`e ** $x\*(C'\fR where \f(CW\*(C`e\*(C'\fR is Euler's number.
.PP
This method was added in v1.82 of Math::BigInt (April 2007).
.SS "\fIbnok()\fP"
.IX Subsection "bnok()"
.Vb 1
\&        $x\->bnok($y);   # x over y (binomial coefficient n over k)
.Ve
.PP
Calculates the binomial coefficient n over k, also called the \*(L"choose\*(R"
function. The result is equivalent to:
.PP
.Vb 3
\&        ( n )      n!
\&        | \- |  = \-\-\-\-\-\-\-
\&        ( k )    k!(n\-k)!
.Ve
.PP
This method was added in v1.84 of Math::BigInt (April 2007).
.SS "\fIbpi()\fP"
.IX Subsection "bpi()"
.Vb 1
\&        print Math::BigFloat\->bpi(100), "\en";
.Ve
.PP
Calculate \s-1PI\s0 to N digits (including the 3 before the dot). The result is
rounded according to the current rounding mode, which defaults to \*(L"even\*(R".
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbcos()\fP"
.IX Subsection "bcos()"
.Vb 2
\&        my $x = Math::BigFloat\->new(1);
\&        print $x\->bcos(100), "\en";
.Ve
.PP
Calculate the cosinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbsin()\fP"
.IX Subsection "bsin()"
.Vb 2
\&        my $x = Math::BigFloat\->new(1);
\&        print $x\->bsin(100), "\en";
.Ve
.PP
Calculate the sinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan2()\fP"
.IX Subsection "batan2()"
.Vb 3
\&        my $y = Math::BigFloat\->new(2);
\&        my $x = Math::BigFloat\->new(3);
\&        print $y\->batan2($x), "\en";
.Ve
.PP
Calculate the arcus tanges of \f(CW$y\fR divided by \f(CW$x\fR, modifying \f(CW$y\fR in place.
See also \*(L"\fIbatan()\fR\*(R".
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan()\fP"
.IX Subsection "batan()"
.Vb 2
\&        my $x = Math::BigFloat\->new(1);
\&        print $x\->batan(100), "\en";
.Ve
.PP
Calculate the arcus tanges of \f(CW$x\fR, modifying \f(CW$x\fR in place. See also \*(L"\fIbatan2()\fR\*(R".
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbmuladd()\fP"
.IX Subsection "bmuladd()"
.Vb 1
\&        $x\->bmuladd($y,$z);
.Ve
.PP
Multiply \f(CW$x\fR by \f(CW$y\fR, and then add \f(CW$z\fR to the result.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SH "Autocreating constants"
.IX Header "Autocreating constants"
After \f(CW\*(C`use Math::BigFloat \*(Aq:constant\*(Aq\*(C'\fR all the floating point constants
in the given scope are converted to \f(CW\*(C`Math::BigFloat\*(C'\fR. This conversion
happens at compile time.
.PP
In particular
.PP
.Vb 1
\&  perl \-MMath::BigFloat=:constant \-e \*(Aqprint 2E\-100,"\en"\*(Aq
.Ve
.PP
prints the value of \f(CW\*(C`2E\-100\*(C'\fR. Note that without conversion of 
constants the expression 2E\-100 will be calculated as normal floating point 
number.
.PP
Please note that ':constant' does not affect integer constants, nor binary 
nor hexadecimal constants. Use bignum or Math::BigInt to get this to
work.
.SS "Math library"
.IX Subsection "Math library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqGMP\*(Aq;
.Ve
.PP
\&\fBNote\fR: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.
.PP
Note: The keyword 'lib' will warn when the requested library could not be
loaded. To suppress the warning use 'try' instead:
.PP
.Vb 1
\&        use Math::BigFloat try => \*(AqGMP\*(Aq;
.Ve
.PP
If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:
.PP
.Vb 1
\&        use Math::BigFloat only => \*(AqGMP,Pari\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
See the respective low-level library documentation for further details.
.PP
Please note that Math::BigFloat does \fBnot\fR use the denoted library itself,
but it merely passes the lib argument to Math::BigInt. So, instead of the need
to do:
.PP
.Vb 2
\&        use Math::BigInt lib => \*(AqGMP\*(Aq;
\&        use Math::BigFloat;
.Ve
.PP
you can roll it all into one line:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqGMP\*(Aq;
.Ve
.PP
It is also possible to just require Math::BigFloat:
.PP
.Vb 1
\&        require Math::BigFloat;
.Ve
.PP
This will load the necessary things (like BigInt) when they are needed, and
automatically.
.PP
See Math::BigInt for more details than you ever wanted to know about using
a different low-level library.
.SS "Using Math::BigInt::Lite"
.IX Subsection "Using Math::BigInt::Lite"
For backwards compatibility reasons it is still possible to
request a different storage class for use with Math::BigFloat:
.PP
.Vb 1
\&        use Math::BigFloat with => \*(AqMath::BigInt::Lite\*(Aq;
.Ve
.PP
However, this request is ignored, as the current code now uses the low-level
math library for directly storing the number parts.
.SH "EXPORTS"
.IX Header "EXPORTS"
\&\f(CW\*(C`Math::BigFloat\*(C'\fR exports nothing by default, but can export the \f(CW\*(C`bpi()\*(C'\fR method:
.PP
.Vb 1
\&        use Math::BigFloat qw/bpi/;
\&
\&        print bpi(10), "\en";
.Ve
.SH "BUGS"
.IX Header "BUGS"
Please see the file \s-1BUGS\s0 in the \s-1CPAN\s0 distribution Math::BigInt for known bugs.
.SH "CAVEATS"
.IX Header "CAVEATS"
Do not try to be clever to insert some operations in between switching
libraries:
.PP
.Vb 4
\&    require Math::BigFloat;
\&    my $matter = Math::BigFloat\->bone() + 4;    # load BigInt and Calc
\&    Math::BigFloat\->import( lib => \*(AqPari\*(Aq );    # load Pari, too
\&    my $anti_matter = Math::BigFloat\->bone()+4; # now use Pari
.Ve
.PP
This will create objects with numbers stored in two different backend libraries,
and \fB\s-1VERY BAD THINGS\s0\fR will happen when you use these together:
.PP
.Vb 1
\&        my $flash_and_bang = $matter + $anti_matter;    # Don\*(Aqt do this!
.Ve
.IP "stringify, \fIbstr()\fR" 1
.IX Item "stringify, bstr()"
Both stringify and \fIbstr()\fR now drop the leading '+'. The old code would return
\&'+1.23', the new returns '1.23'. See the documentation in Math::BigInt for
reasoning and details.
.IP "bdiv" 1
.IX Item "bdiv"
The following will probably not print what you expect:
.Sp
.Vb 1
\&        print $c\->bdiv(123.456),"\en";
.Ve
.Sp
It prints both quotient and remainder since print works in list context. Also,
\&\fIbdiv()\fR will modify \f(CW$c\fR, so be careful. You probably want to use
.Sp
.Vb 2
\&    print $c / 123.456,"\en";
\&    print scalar $c\->bdiv(123.456),"\en";  # or if you want to modify $c
.Ve
.Sp
instead.
.IP "brsft" 1
.IX Item "brsft"
The following will probably not print what you expect:
.Sp
.Vb 2
\&        my $c = Math::BigFloat\->new(\*(Aq3.14159\*(Aq);
\&        print $c\->brsft(3,10),"\en";     # prints 0.00314153.1415
.Ve
.Sp
It prints both quotient and remainder, since print calls \f(CW\*(C`brsft()\*(C'\fR in list
context. Also, \f(CW\*(C`$c\->brsft()\*(C'\fR will modify \f(CW$c\fR, so be careful.
You probably want to use
.Sp
.Vb 3
\&        print scalar $c\->copy()\->brsft(3,10),"\en";
\&        # or if you really want to modify $c
\&        print scalar $c\->brsft(3,10),"\en";
.Ve
.Sp
instead.
.IP "Modifying and =" 1
.IX Item "Modifying and ="
Beware of:
.Sp
.Vb 2
\&        $x = Math::BigFloat\->new(5);
\&        $y = $x;
.Ve
.Sp
It will not do what you think, e.g. making a copy of \f(CW$x\fR. Instead it just makes
a second reference to the \fBsame\fR object and stores it in \f(CW$y\fR. Thus anything
that modifies \f(CW$x\fR will modify \f(CW$y\fR (except overloaded math operators), and vice
versa. See Math::BigInt for details and how to avoid that.
.IP "bpow" 1
.IX Item "bpow"
\&\f(CW\*(C`bpow()\*(C'\fR now modifies the first argument, unlike the old code which left
it alone and only returned the result. This is to be consistent with
\&\f(CW\*(C`badd()\*(C'\fR etc. The first will modify \f(CW$x\fR, the second one won't:
.Sp
.Vb 3
\&        print bpow($x,$i),"\en";         # modify $x
\&        print $x\->bpow($i),"\en";        # ditto
\&        print $x ** $i,"\en";            # leave $x alone
.Ve
.IP "\fIprecision()\fR vs. \fIaccuracy()\fR" 1
.IX Item "precision() vs. accuracy()"
A common pitfall is to use \*(L"\fIprecision()\fR\*(R" when you want to round a result to
a certain number of digits:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    Math::BigFloat\->precision(4);            # does not do what you
\&                                             # think it does
\&    my $x = Math::BigFloat\->new(12345);      # rounds $x to "12000"!
\&    print "$x\en";                            # print "12000"
\&    my $y = Math::BigFloat\->new(3);          # rounds $y to "0"!
\&    print "$y\en";                            # print "0"
\&    $z = $x / $y;                            # 12000 / 0 => NaN!
\&    print "$z\en";
\&    print $z\->precision(),"\en";              # 4
.Ve
.Sp
Replacing \*(L"\fIprecision()\fR\*(R" with \*(L"accuracy\*(R" is probably not what you want, either:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    Math::BigFloat\->accuracy(4);             # enables global rounding:
\&    my $x = Math::BigFloat\->new(123456);     # rounded immediately
\&                                             #   to "12350"
\&    print "$x\en";                            # print "123500"
\&    my $y = Math::BigFloat\->new(3);          # rounded to "3
\&    print "$y\en";                            # print "3"
\&    print $z = $x\->copy()\->bdiv($y),"\en";    # 41170
\&    print $z\->accuracy(),"\en";               # 4
.Ve
.Sp
What you want to use instead is:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    my $x = Math::BigFloat\->new(123456);     # no rounding
\&    print "$x\en";                            # print "123456"
\&    my $y = Math::BigFloat\->new(3);          # no rounding
\&    print "$y\en";                            # print "3"
\&    print $z = $x\->copy()\->bdiv($y,4),"\en";  # 41150
\&    print $z\->accuracy(),"\en";               # undef
.Ve
.Sp
In addition to computing what you expected, the last example also does \fBnot\fR
\&\*(L"taint\*(R" the result with an accuracy or precision setting, which would
influence any further operation.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigInt, Math::BigRat and Math::Big as well as
Math::BigInt::Pari and  Math::BigInt::GMP.
.PP
The pragmas bignum, bigint and bigrat might also be of interest
because they solve the autoupgrading/downgrading issue, at least partly.
.PP
The package at <http://search.cpan.org/~tels/Math\-BigInt> contains
more documentation including a full version history, testcases, empty
subclass files and benchmarks.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels <http://bloodgate.com> in 2001 \- 2006, and still
at it in 2007.
                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Math::BigFloat5.16.3pm                       0100644 0001750 0001750 00000075306 12566207436 024316  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigFloat 3pm"
.TH Math::BigFloat 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigFloat \- Arbitrary size floating point math package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Math::BigFloat;
\&
\& # Number creation
\& my $x = Math::BigFloat\->new($str);     # defaults to 0
\& my $y = $x\->copy();                    # make a true copy
\& my $nan  = Math::BigFloat\->bnan();     # create a NotANumber
\& my $zero = Math::BigFloat\->bzero();    # create a +0
\& my $inf = Math::BigFloat\->binf();      # create a +inf
\& my $inf = Math::BigFloat\->binf(\*(Aq\-\*(Aq);   # create a \-inf
\& my $one = Math::BigFloat\->bone();      # create a +1
\& my $mone = Math::BigFloat\->bone(\*(Aq\-\*(Aq);  # create a \-1
\&
\& my $pi = Math::BigFloat\->bpi(100);     # PI to 100 digits
\&
\& # the following examples compute their result to 100 digits accuracy:
\& my $cos  = Math::BigFloat\->new(1)\->bcos(100);        # cosinus(1)
\& my $sin  = Math::BigFloat\->new(1)\->bsin(100);        # sinus(1)
\& my $atan = Math::BigFloat\->new(1)\->batan(100);       # arcus tangens(1)
\&
\& my $atan2 = Math::BigFloat\->new(  1 )\->batan2( 1 ,100); # batan(1)
\& my $atan2 = Math::BigFloat\->new(  1 )\->batan2( 8 ,100); # batan(1/8)
\& my $atan2 = Math::BigFloat\->new( \-2 )\->batan2( 1 ,100); # batan(\-2)
\&
\& # Testing
\& $x\->is_zero();          # true if arg is +0
\& $x\->is_nan();           # true if arg is NaN
\& $x\->is_one();           # true if arg is +1
\& $x\->is_one(\*(Aq\-\*(Aq);        # true if arg is \-1
\& $x\->is_odd();           # true if odd, false for even
\& $x\->is_even();          # true if even, false for odd
\& $x\->is_pos();           # true if >= 0
\& $x\->is_neg();           # true if <  0
\& $x\->is_inf(sign);       # true if +inf, or \-inf (default is \*(Aq+\*(Aq)
\&
\& $x\->bcmp($y);           # compare numbers (undef,<0,=0,>0)
\& $x\->bacmp($y);          # compare absolutely (undef,<0,=0,>0)
\& $x\->sign();             # return the sign, either +,\- or NaN
\& $x\->digit($n);          # return the nth digit, counting from right
\& $x\->digit(\-$n);         # return the nth digit, counting from left 
\&
\& # The following all modify their first argument. If you want to pre\-
\& # serve $x, use $z = $x\->copy()\->bXXX($y); See under L</CAVEATS> for
\& # necessary when mixing $a = $b assignments with non\-overloaded math.
\&
\& # set 
\& $x\->bzero();            # set $i to 0
\& $x\->bnan();             # set $i to NaN
\& $x\->bone();             # set $x to +1
\& $x\->bone(\*(Aq\-\*(Aq);          # set $x to \-1
\& $x\->binf();             # set $x to inf
\& $x\->binf(\*(Aq\-\*(Aq);          # set $x to \-inf
\&
\& $x\->bneg();             # negation
\& $x\->babs();             # absolute value
\& $x\->bnorm();            # normalize (no\-op)
\& $x\->bnot();             # two\*(Aqs complement (bit wise not)
\& $x\->binc();             # increment x by 1
\& $x\->bdec();             # decrement x by 1
\&
\& $x\->badd($y);           # addition (add $y to $x)
\& $x\->bsub($y);           # subtraction (subtract $y from $x)
\& $x\->bmul($y);           # multiplication (multiply $x by $y)
\& $x\->bdiv($y);           # divide, set $x to quotient
\&                         # return (quo,rem) or quo if scalar
\&
\& $x\->bmod($y);           # modulus ($x % $y)
\& $x\->bpow($y);           # power of arguments ($x ** $y)
\& $x\->bmodpow($exp,$mod); # modular exponentiation (($num**$exp) % $mod))
\& $x\->blsft($y, $n);      # left shift by $y places in base $n
\& $x\->brsft($y, $n);      # right shift by $y places in base $n
\&                         # returns (quo,rem) or quo if in scalar context
\&
\& $x\->blog();             # logarithm of $x to base e (Euler\*(Aqs number)
\& $x\->blog($base);        # logarithm of $x to base $base (f.i. 2)
\& $x\->bexp();             # calculate e ** $x where e is Euler\*(Aqs number
\&
\& $x\->band($y);           # bit\-wise and
\& $x\->bior($y);           # bit\-wise inclusive or
\& $x\->bxor($y);           # bit\-wise exclusive or
\& $x\->bnot();             # bit\-wise not (two\*(Aqs complement)
\&
\& $x\->bsqrt();            # calculate square\-root
\& $x\->broot($y);          # $y\*(Aqth root of $x (e.g. $y == 3 => cubic root)
\& $x\->bfac();             # factorial of $x (1*2*3*4*..$x)
\&
\& $x\->bround($N);         # accuracy: preserve $N digits
\& $x\->bfround($N);        # precision: round to the $Nth digit
\&
\& $x\->bfloor();           # return integer less or equal than $x
\& $x\->bceil();            # return integer greater or equal than $x
\&
\&  # The following do not modify their arguments:
\&
\& bgcd(@values);          # greatest common divisor
\& blcm(@values);          # lowest common multiplicator
\&
\& $x\->bstr();             # return string
\& $x\->bsstr();            # return string in scientific notation
\&
\& $x\->as_int();           # return $x as BigInt 
\& $x\->exponent();         # return exponent as BigInt
\& $x\->mantissa();         # return mantissa as BigInt
\& $x\->parts();            # return (mantissa,exponent) as BigInt
\&
\& $x\->length();           # number of digits (w/o sign and \*(Aq.\*(Aq)
\& ($l,$f) = $x\->length(); # number of digits, and length of fraction
\&
\& $x\->precision();        # return P of $x (or global, if P of $x undef)
\& $x\->precision($n);      # set P of $x to $n
\& $x\->accuracy();         # return A of $x (or global, if A of $x undef)
\& $x\->accuracy($n);       # set A $x to $n
\&
\& # these get/set the appropriate global value for all BigFloat objects
\& Math::BigFloat\->precision();   # Precision
\& Math::BigFloat\->accuracy();    # Accuracy
\& Math::BigFloat\->round_mode();  # rounding mode
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded if you
declare your big floating point numbers as
.PP
.Vb 1
\&  $i = new Math::BigFloat \*(Aq12_3.456_789_123_456_789E\-2\*(Aq;
.Ve
.PP
Operations with overloaded operators preserve the arguments, which is
exactly what you expect.
.SS "Canonical notation"
.IX Subsection "Canonical notation"
Input to these routines are either BigFloat objects, or strings of the
following four forms:
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+\e.\ed*$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+E[+\-]?\ed+$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed*\e.\ed+E[+\-]?\ed+$/\*(C'\fR
.PP
all with optional leading and trailing zeros and/or spaces. Additionally,
numbers are allowed to have an underscore between any two digits.
.PP
Empty strings as well as other illegal numbers results in 'NaN'.
.PP
\&\fIbnorm()\fR on a BigFloat object is now effectively a no-op, since the numbers 
are always stored in normalized form. On a string, it creates a BigFloat 
object.
.SS "Output"
.IX Subsection "Output"
Output values are BigFloat objects (normalized), except for \fIbstr()\fR and \fIbsstr()\fR.
.PP
The string output will always have leading and trailing zeros stripped and drop
a plus sign. \f(CW\*(C`bstr()\*(C'\fR will give you always the form with a decimal point,
while \f(CW\*(C`bsstr()\*(C'\fR (s for scientific) gives you the scientific notation.
.PP
.Vb 6
\&        Input                   bstr()          bsstr()
\&        \*(Aq\-0\*(Aq                    \*(Aq0\*(Aq             \*(Aq0E1\*(Aq
\&        \*(Aq  \-123 123 123\*(Aq        \*(Aq\-123123123\*(Aq    \*(Aq\-123123123E0\*(Aq
\&        \*(Aq00.0123\*(Aq               \*(Aq0.0123\*(Aq        \*(Aq123E\-4\*(Aq
\&        \*(Aq123.45E\-2\*(Aq             \*(Aq1.2345\*(Aq        \*(Aq12345E\-4\*(Aq
\&        \*(Aq10E+3\*(Aq                 \*(Aq10000\*(Aq         \*(Aq1E4\*(Aq
.Ve
.PP
Some routines (\f(CW\*(C`is_odd()\*(C'\fR, \f(CW\*(C`is_even()\*(C'\fR, \f(CW\*(C`is_zero()\*(C'\fR, \f(CW\*(C`is_one()\*(C'\fR,
\&\f(CW\*(C`is_nan()\*(C'\fR) return true or false, while others (\f(CW\*(C`bcmp()\*(C'\fR, \f(CW\*(C`bacmp()\*(C'\fR)
return either undef, <0, 0 or >0 and are suited for sort.
.PP
Actual math is done by using the class defined with \f(CW\*(C`with => Class;\*(C'\fR (which
defaults to BigInts) to represent the mantissa and exponent.
.PP
The sign \f(CW\*(C`/^[+\-]$/\*(C'\fR is stored separately. The string 'NaN' is used to 
represent the result when input arguments are not numbers, as well as 
the result of dividing by zero.
.ie n .SS """mantissa()"", ""exponent()"" and ""parts()"""
.el .SS "\f(CWmantissa()\fP, \f(CWexponent()\fP and \f(CWparts()\fP"
.IX Subsection "mantissa(), exponent() and parts()"
\&\f(CW\*(C`mantissa()\*(C'\fR and \f(CW\*(C`exponent()\*(C'\fR return the said parts of the BigFloat 
as BigInts such that:
.PP
.Vb 4
\&        $m = $x\->mantissa();
\&        $e = $x\->exponent();
\&        $y = $m * ( 10 ** $e );
\&        print "ok\en" if $x == $y;
.Ve
.PP
\&\f(CW\*(C`($m,$e) = $x\->parts();\*(C'\fR is just a shortcut giving you both of them.
.PP
A zero is represented and returned as \f(CW0E1\fR, \fBnot\fR \f(CW0E0\fR (after Knuth).
.PP
Currently the mantissa is reduced as much as possible, favouring higher
exponents over lower ones (e.g. returning 1e7 instead of 10e6 or 10000000e0).
This might change in the future, so do not depend on it.
.SS "Accuracy vs. Precision"
.IX Subsection "Accuracy vs. Precision"
See also: Rounding.
.PP
Math::BigFloat supports both precision (rounding to a certain place before or
after the dot) and accuracy (rounding to a certain number of digits). For a
full documentation, examples and tips on these topics please see the large
section about rounding in Math::BigInt.
.PP
Since things like \f(CWsqrt(2)\fR or \f(CW\*(C`1 / 3\*(C'\fR must presented with a limited
accuracy lest a operation consumes all resources, each operation produces
no more than the requested number of digits.
.PP
If there is no global precision or accuracy set, \fBand\fR the operation in
question was not called with a requested precision or accuracy, \fBand\fR the
input \f(CW$x\fR has no accuracy or precision set, then a fallback parameter will
be used. For historical reasons, it is called \f(CW\*(C`div_scale\*(C'\fR and can be accessed
via:
.PP
.Vb 2
\&        $d = Math::BigFloat\->div_scale();       # query
\&        Math::BigFloat\->div_scale($n);          # set to $n digits
.Ve
.PP
The default value for \f(CW\*(C`div_scale\*(C'\fR is 40.
.PP
In case the result of one operation has more digits than specified,
it is rounded. The rounding mode taken is either the default mode, or the one
supplied to the operation after the \fIscale\fR:
.PP
.Vb 7
\&    $x = Math::BigFloat\->new(2);
\&    Math::BigFloat\->accuracy(5);              # 5 digits max
\&    $y = $x\->copy()\->bdiv(3);                 # will give 0.66667
\&    $y = $x\->copy()\->bdiv(3,6);               # will give 0.666667
\&    $y = $x\->copy()\->bdiv(3,6,undef,\*(Aqodd\*(Aq);   # will give 0.666667
\&    Math::BigFloat\->round_mode(\*(Aqzero\*(Aq);
\&    $y = $x\->copy()\->bdiv(3,6);               # will also give 0.666667
.Ve
.PP
Note that \f(CW\*(C`Math::BigFloat\->accuracy()\*(C'\fR and \f(CW\*(C`Math::BigFloat\->precision()\*(C'\fR
set the global variables, and thus \fBany\fR newly created number will be subject
to the global rounding \fBimmediately\fR. This means that in the examples above, the
\&\f(CW3\fR as argument to \f(CW\*(C`bdiv()\*(C'\fR will also get an accuracy of \fB5\fR.
.PP
It is less confusing to either calculate the result fully, and afterwards
round it explicitly, or use the additional parameters to the math
functions like so:
.PP
.Vb 4
\&        use Math::BigFloat;
\&        $x = Math::BigFloat\->new(2);
\&        $y = $x\->copy()\->bdiv(3);
\&        print $y\->bround(5),"\en";               # will give 0.66667
\&
\&        or
\&
\&        use Math::BigFloat;
\&        $x = Math::BigFloat\->new(2);
\&        $y = $x\->copy()\->bdiv(3,5);             # will give 0.66667
\&        print "$y\en";
.Ve
.SS "Rounding"
.IX Subsection "Rounding"
.IP "ffround ( +$scale )" 2
.IX Item "ffround ( +$scale )"
Rounds to the \f(CW$scale\fR'th place left from the '.', counting from the dot.
The first digit is numbered 1.
.IP "ffround ( \-$scale )" 2
.IX Item "ffround ( -$scale )"
Rounds to the \f(CW$scale\fR'th place right from the '.', counting from the dot.
.IP "ffround ( 0 )" 2
.IX Item "ffround ( 0 )"
Rounds to an integer.
.IP "fround  ( +$scale )" 2
.IX Item "fround  ( +$scale )"
Preserves accuracy to \f(CW$scale\fR digits from the left (aka significant digits)
and pads the rest with zeros. If the number is between 1 and \-1, the
significant digits count from the first non-zero after the '.'
.IP "fround  ( \-$scale ) and fround ( 0 )" 2
.IX Item "fround  ( -$scale ) and fround ( 0 )"
These are effectively no-ops.
.PP
All rounding functions take as a second parameter a rounding mode from one of
the following: 'even', 'odd', '+inf', '\-inf', 'zero', 'trunc' or 'common'.
.PP
The default rounding mode is 'even'. By using
\&\f(CW\*(C`Math::BigFloat\->round_mode($round_mode);\*(C'\fR you can get and set the default
mode for subsequent rounding. The usage of \f(CW\*(C`$Math::BigFloat::$round_mode\*(C'\fR is
no longer supported.
The second parameter to the round functions then overrides the default
temporarily.
.PP
The \f(CW\*(C`as_number()\*(C'\fR function returns a BigInt from a Math::BigFloat. It uses
\&'trunc' as rounding mode to make it equivalent to:
.PP
.Vb 2
\&        $x = 2.5;
\&        $y = int($x) + 2;
.Ve
.PP
You can override this by passing the desired rounding mode as parameter to
\&\f(CW\*(C`as_number()\*(C'\fR:
.PP
.Vb 2
\&        $x = Math::BigFloat\->new(2.5);
\&        $y = $x\->as_number(\*(Aqodd\*(Aq);      # $y = 3
.Ve
.SH "METHODS"
.IX Header "METHODS"
Math::BigFloat supports all methods that Math::BigInt supports, except it
calculates non-integer results when possible. Please see Math::BigInt
for a full description of each method. Below are just the most important
differences:
.SS "accuracy"
.IX Subsection "accuracy"
.Vb 3
\&        $x\->accuracy(5);             # local for $x
\&        CLASS\->accuracy(5);          # global for all members of CLASS
\&                                     # Note: This also applies to new()!
\&
\&        $A = $x\->accuracy();         # read out accuracy that affects $x
\&        $A = CLASS\->accuracy();      # read out global accuracy
.Ve
.PP
Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to \fInew()\fR!
.PP
Warning! The accuracy \fIsticks\fR, e.g. once you created a number under the
influence of \f(CW\*(C`CLASS\->accuracy($A)\*(C'\fR, all results from math operations with
that number will also be rounded.
.PP
In most cases, you should probably round the results explicitly using one of
\&\*(L"\fIround()\fR\*(R" in Math::BigInt, \*(L"\fIbround()\fR\*(R" in Math::BigInt or \*(L"\fIbfround()\fR\*(R" in Math::BigInt or by passing the desired accuracy
to the math operation as additional parameter:
.PP
.Vb 4
\&        my $x = Math::BigInt\->new(30000);
\&        my $y = Math::BigInt\->new(7);
\&        print scalar $x\->copy()\->bdiv($y, 2);           # print 4300
\&        print scalar $x\->copy()\->bdiv($y)\->bround(2);   # print 4300
.Ve
.SS "\fIprecision()\fP"
.IX Subsection "precision()"
.Vb 4
\&        $x\->precision(\-2);      # local for $x, round at the second
\&                                # digit right of the dot
\&        $x\->precision(2);       # ditto, round at the second digit left
\&                                # of the dot
\&
\&        CLASS\->precision(5);    # Global for all members of CLASS
\&                                # This also applies to new()!
\&        CLASS\->precision(\-5);   # ditto
\&
\&        $P = CLASS\->precision();    # read out global precision
\&        $P = $x\->precision();       # read out precision that affects $x
.Ve
.PP
Note: You probably want to use \*(L"accuracy\*(R" instead. With \*(L"accuracy\*(R" you
set the number of digits each result should have, with \*(L"\fIprecision()\fR\*(R" you
set the place where to round!
.SS "\fIbexp()\fP"
.IX Subsection "bexp()"
.Vb 1
\&        $x\->bexp($accuracy);            # calculate e ** X
.Ve
.PP
Calculates the expression \f(CW\*(C`e ** $x\*(C'\fR where \f(CW\*(C`e\*(C'\fR is Euler's number.
.PP
This method was added in v1.82 of Math::BigInt (April 2007).
.SS "\fIbnok()\fP"
.IX Subsection "bnok()"
.Vb 1
\&        $x\->bnok($y);   # x over y (binomial coefficient n over k)
.Ve
.PP
Calculates the binomial coefficient n over k, also called the \*(L"choose\*(R"
function. The result is equivalent to:
.PP
.Vb 3
\&        ( n )      n!
\&        | \- |  = \-\-\-\-\-\-\-
\&        ( k )    k!(n\-k)!
.Ve
.PP
This method was added in v1.84 of Math::BigInt (April 2007).
.SS "\fIbpi()\fP"
.IX Subsection "bpi()"
.Vb 1
\&        print Math::BigFloat\->bpi(100), "\en";
.Ve
.PP
Calculate \s-1PI\s0 to N digits (including the 3 before the dot). The result is
rounded according to the current rounding mode, which defaults to \*(L"even\*(R".
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbcos()\fP"
.IX Subsection "bcos()"
.Vb 2
\&        my $x = Math::BigFloat\->new(1);
\&        print $x\->bcos(100), "\en";
.Ve
.PP
Calculate the cosinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbsin()\fP"
.IX Subsection "bsin()"
.Vb 2
\&        my $x = Math::BigFloat\->new(1);
\&        print $x\->bsin(100), "\en";
.Ve
.PP
Calculate the sinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan2()\fP"
.IX Subsection "batan2()"
.Vb 3
\&        my $y = Math::BigFloat\->new(2);
\&        my $x = Math::BigFloat\->new(3);
\&        print $y\->batan2($x), "\en";
.Ve
.PP
Calculate the arcus tanges of \f(CW$y\fR divided by \f(CW$x\fR, modifying \f(CW$y\fR in place.
See also \*(L"\fIbatan()\fR\*(R".
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan()\fP"
.IX Subsection "batan()"
.Vb 2
\&        my $x = Math::BigFloat\->new(1);
\&        print $x\->batan(100), "\en";
.Ve
.PP
Calculate the arcus tanges of \f(CW$x\fR, modifying \f(CW$x\fR in place. See also \*(L"\fIbatan2()\fR\*(R".
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbmuladd()\fP"
.IX Subsection "bmuladd()"
.Vb 1
\&        $x\->bmuladd($y,$z);
.Ve
.PP
Multiply \f(CW$x\fR by \f(CW$y\fR, and then add \f(CW$z\fR to the result.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SH "Autocreating constants"
.IX Header "Autocreating constants"
After \f(CW\*(C`use Math::BigFloat \*(Aq:constant\*(Aq\*(C'\fR all the floating point constants
in the given scope are converted to \f(CW\*(C`Math::BigFloat\*(C'\fR. This conversion
happens at compile time.
.PP
In particular
.PP
.Vb 1
\&  perl \-MMath::BigFloat=:constant \-e \*(Aqprint 2E\-100,"\en"\*(Aq
.Ve
.PP
prints the value of \f(CW\*(C`2E\-100\*(C'\fR. Note that without conversion of 
constants the expression 2E\-100 will be calculated as normal floating point 
number.
.PP
Please note that ':constant' does not affect integer constants, nor binary 
nor hexadecimal constants. Use bignum or Math::BigInt to get this to
work.
.SS "Math library"
.IX Subsection "Math library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqGMP\*(Aq;
.Ve
.PP
\&\fBNote\fR: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.
.PP
Note: The keyword 'lib' will warn when the requested library could not be
loaded. To suppress the warning use 'try' instead:
.PP
.Vb 1
\&        use Math::BigFloat try => \*(AqGMP\*(Aq;
.Ve
.PP
If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:
.PP
.Vb 1
\&        use Math::BigFloat only => \*(AqGMP,Pari\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
See the respective low-level library documentation for further details.
.PP
Please note that Math::BigFloat does \fBnot\fR use the denoted library itself,
but it merely passes the lib argument to Math::BigInt. So, instead of the need
to do:
.PP
.Vb 2
\&        use Math::BigInt lib => \*(AqGMP\*(Aq;
\&        use Math::BigFloat;
.Ve
.PP
you can roll it all into one line:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqGMP\*(Aq;
.Ve
.PP
It is also possible to just require Math::BigFloat:
.PP
.Vb 1
\&        require Math::BigFloat;
.Ve
.PP
This will load the necessary things (like BigInt) when they are needed, and
automatically.
.PP
See Math::BigInt for more details than you ever wanted to know about using
a different low-level library.
.SS "Using Math::BigInt::Lite"
.IX Subsection "Using Math::BigInt::Lite"
For backwards compatibility reasons it is still possible to
request a different storage class for use with Math::BigFloat:
.PP
.Vb 1
\&        use Math::BigFloat with => \*(AqMath::BigInt::Lite\*(Aq;
.Ve
.PP
However, this request is ignored, as the current code now uses the low-level
math library for directly storing the number parts.
.SH "EXPORTS"
.IX Header "EXPORTS"
\&\f(CW\*(C`Math::BigFloat\*(C'\fR exports nothing by default, but can export the \f(CW\*(C`bpi()\*(C'\fR method:
.PP
.Vb 1
\&        use Math::BigFloat qw/bpi/;
\&
\&        print bpi(10), "\en";
.Ve
.SH "BUGS"
.IX Header "BUGS"
Please see the file \s-1BUGS\s0 in the \s-1CPAN\s0 distribution Math::BigInt for known bugs.
.SH "CAVEATS"
.IX Header "CAVEATS"
Do not try to be clever to insert some operations in between switching
libraries:
.PP
.Vb 4
\&    require Math::BigFloat;
\&    my $matter = Math::BigFloat\->bone() + 4;    # load BigInt and Calc
\&    Math::BigFloat\->import( lib => \*(AqPari\*(Aq );    # load Pari, too
\&    my $anti_matter = Math::BigFloat\->bone()+4; # now use Pari
.Ve
.PP
This will create objects with numbers stored in two different backend libraries,
and \fB\s-1VERY\s0 \s-1BAD\s0 \s-1THINGS\s0\fR will happen when you use these together:
.PP
.Vb 1
\&        my $flash_and_bang = $matter + $anti_matter;    # Don\*(Aqt do this!
.Ve
.IP "stringify, \fIbstr()\fR" 1
.IX Item "stringify, bstr()"
Both stringify and \fIbstr()\fR now drop the leading '+'. The old code would return
\&'+1.23', the new returns '1.23'. See the documentation in Math::BigInt for
reasoning and details.
.IP "bdiv" 1
.IX Item "bdiv"
The following will probably not print what you expect:
.Sp
.Vb 1
\&        print $c\->bdiv(123.456),"\en";
.Ve
.Sp
It prints both quotient and remainder since print works in list context. Also,
\&\fIbdiv()\fR will modify \f(CW$c\fR, so be careful. You probably want to use
.Sp
.Vb 2
\&    print $c / 123.456,"\en";
\&    print scalar $c\->bdiv(123.456),"\en";  # or if you want to modify $c
.Ve
.Sp
instead.
.IP "brsft" 1
.IX Item "brsft"
The following will probably not print what you expect:
.Sp
.Vb 2
\&        my $c = Math::BigFloat\->new(\*(Aq3.14159\*(Aq);
\&        print $c\->brsft(3,10),"\en";     # prints 0.00314153.1415
.Ve
.Sp
It prints both quotient and remainder, since print calls \f(CW\*(C`brsft()\*(C'\fR in list
context. Also, \f(CW\*(C`$c\->brsft()\*(C'\fR will modify \f(CW$c\fR, so be careful.
You probably want to use
.Sp
.Vb 3
\&        print scalar $c\->copy()\->brsft(3,10),"\en";
\&        # or if you really want to modify $c
\&        print scalar $c\->brsft(3,10),"\en";
.Ve
.Sp
instead.
.IP "Modifying and =" 1
.IX Item "Modifying and ="
Beware of:
.Sp
.Vb 2
\&        $x = Math::BigFloat\->new(5);
\&        $y = $x;
.Ve
.Sp
It will not do what you think, e.g. making a copy of \f(CW$x\fR. Instead it just makes
a second reference to the \fBsame\fR object and stores it in \f(CW$y\fR. Thus anything
that modifies \f(CW$x\fR will modify \f(CW$y\fR (except overloaded math operators), and vice
versa. See Math::BigInt for details and how to avoid that.
.IP "bpow" 1
.IX Item "bpow"
\&\f(CW\*(C`bpow()\*(C'\fR now modifies the first argument, unlike the old code which left
it alone and only returned the result. This is to be consistent with
\&\f(CW\*(C`badd()\*(C'\fR etc. The first will modify \f(CW$x\fR, the second one won't:
.Sp
.Vb 3
\&        print bpow($x,$i),"\en";         # modify $x
\&        print $x\->bpow($i),"\en";        # ditto
\&        print $x ** $i,"\en";            # leave $x alone
.Ve
.IP "\fIprecision()\fR vs. \fIaccuracy()\fR" 1
.IX Item "precision() vs. accuracy()"
A common pitfall is to use \*(L"\fIprecision()\fR\*(R" when you want to round a result to
a certain number of digits:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    Math::BigFloat\->precision(4);            # does not do what you
\&                                             # think it does
\&    my $x = Math::BigFloat\->new(12345);      # rounds $x to "12000"!
\&    print "$x\en";                            # print "12000"
\&    my $y = Math::BigFloat\->new(3);          # rounds $y to "0"!
\&    print "$y\en";                            # print "0"
\&    $z = $x / $y;                            # 12000 / 0 => NaN!
\&    print "$z\en";
\&    print $z\->precision(),"\en";              # 4
.Ve
.Sp
Replacing \*(L"\fIprecision()\fR\*(R" with \*(L"accuracy\*(R" is probably not what you want, either:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    Math::BigFloat\->accuracy(4);             # enables global rounding:
\&    my $x = Math::BigFloat\->new(123456);     # rounded immediately
\&                                             #   to "12350"
\&    print "$x\en";                            # print "123500"
\&    my $y = Math::BigFloat\->new(3);          # rounded to "3
\&    print "$y\en";                            # print "3"
\&    print $z = $x\->copy()\->bdiv($y),"\en";    # 41170
\&    print $z\->accuracy(),"\en";               # 4
.Ve
.Sp
What you want to use instead is:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    my $x = Math::BigFloat\->new(123456);     # no rounding
\&    print "$x\en";                            # print "123456"
\&    my $y = Math::BigFloat\->new(3);          # no rounding
\&    print "$y\en";                            # print "3"
\&    print $z = $x\->copy()\->bdiv($y,4),"\en";  # 41150
\&    print $z\->accuracy(),"\en";               # undef
.Ve
.Sp
In addition to computing what you expected, the last example also does \fBnot\fR
\&\*(L"taint\*(R" the result with an accuracy or precision setting, which would
influence any further operation.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigInt, Math::BigRat and Math::Big as well as
Math::BigInt::BitVect, Math::BigInt::Pari and  Math::BigInt::GMP.
.PP
The pragmas bignum, bigint and bigrat might also be of interest
because they solve the autoupgrading/downgrading issue, at least partly.
.PP
The package at http://search.cpan.org/~tels/Math\-BigInt <http://search.cpan.org/~tels/Math-BigInt> contains
more documentation including a full version history, testcases, empty
subclass files and benchmarks.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels <http://bloodgate.com> in 2001 \- 2006, and still
at it in 2007.
                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Math::BigFloat5.18.3pm                       0100644 0001750 0001750 00000075507 12566207460 024320  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigFloat 3pm"
.TH Math::BigFloat 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigFloat \- Arbitrary size floating point math package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Math::BigFloat;
\&
\& # Number creation
\& my $x = Math::BigFloat\->new($str);     # defaults to 0
\& my $y = $x\->copy();                    # make a true copy
\& my $nan  = Math::BigFloat\->bnan();     # create a NotANumber
\& my $zero = Math::BigFloat\->bzero();    # create a +0
\& my $inf = Math::BigFloat\->binf();      # create a +inf
\& my $inf = Math::BigFloat\->binf(\*(Aq\-\*(Aq);   # create a \-inf
\& my $one = Math::BigFloat\->bone();      # create a +1
\& my $mone = Math::BigFloat\->bone(\*(Aq\-\*(Aq);  # create a \-1
\&
\& my $pi = Math::BigFloat\->bpi(100);     # PI to 100 digits
\&
\& # the following examples compute their result to 100 digits accuracy:
\& my $cos  = Math::BigFloat\->new(1)\->bcos(100);        # cosinus(1)
\& my $sin  = Math::BigFloat\->new(1)\->bsin(100);        # sinus(1)
\& my $atan = Math::BigFloat\->new(1)\->batan(100);       # arcus tangens(1)
\&
\& my $atan2 = Math::BigFloat\->new(  1 )\->batan2( 1 ,100); # batan(1)
\& my $atan2 = Math::BigFloat\->new(  1 )\->batan2( 8 ,100); # batan(1/8)
\& my $atan2 = Math::BigFloat\->new( \-2 )\->batan2( 1 ,100); # batan(\-2)
\&
\& # Testing
\& $x\->is_zero();          # true if arg is +0
\& $x\->is_nan();           # true if arg is NaN
\& $x\->is_one();           # true if arg is +1
\& $x\->is_one(\*(Aq\-\*(Aq);        # true if arg is \-1
\& $x\->is_odd();           # true if odd, false for even
\& $x\->is_even();          # true if even, false for odd
\& $x\->is_pos();           # true if >= 0
\& $x\->is_neg();           # true if <  0
\& $x\->is_inf(sign);       # true if +inf, or \-inf (default is \*(Aq+\*(Aq)
\&
\& $x\->bcmp($y);           # compare numbers (undef,<0,=0,>0)
\& $x\->bacmp($y);          # compare absolutely (undef,<0,=0,>0)
\& $x\->sign();             # return the sign, either +,\- or NaN
\& $x\->digit($n);          # return the nth digit, counting from right
\& $x\->digit(\-$n);         # return the nth digit, counting from left 
\&
\& # The following all modify their first argument. If you want to pre\-
\& # serve $x, use $z = $x\->copy()\->bXXX($y); See under L</CAVEATS> for
\& # necessary when mixing $a = $b assignments with non\-overloaded math.
\&
\& # set 
\& $x\->bzero();            # set $i to 0
\& $x\->bnan();             # set $i to NaN
\& $x\->bone();             # set $x to +1
\& $x\->bone(\*(Aq\-\*(Aq);          # set $x to \-1
\& $x\->binf();             # set $x to inf
\& $x\->binf(\*(Aq\-\*(Aq);          # set $x to \-inf
\&
\& $x\->bneg();             # negation
\& $x\->babs();             # absolute value
\& $x\->bnorm();            # normalize (no\-op)
\& $x\->bnot();             # two\*(Aqs complement (bit wise not)
\& $x\->binc();             # increment x by 1
\& $x\->bdec();             # decrement x by 1
\&
\& $x\->badd($y);           # addition (add $y to $x)
\& $x\->bsub($y);           # subtraction (subtract $y from $x)
\& $x\->bmul($y);           # multiplication (multiply $x by $y)
\& $x\->bdiv($y);           # divide, set $x to quotient
\&                         # return (quo,rem) or quo if scalar
\&
\& $x\->bmod($y);           # modulus ($x % $y)
\& $x\->bpow($y);           # power of arguments ($x ** $y)
\& $x\->bmodpow($exp,$mod); # modular exponentiation (($num**$exp) % $mod))
\& $x\->blsft($y, $n);      # left shift by $y places in base $n
\& $x\->brsft($y, $n);      # right shift by $y places in base $n
\&                         # returns (quo,rem) or quo if in scalar context
\&
\& $x\->blog();             # logarithm of $x to base e (Euler\*(Aqs number)
\& $x\->blog($base);        # logarithm of $x to base $base (f.i. 2)
\& $x\->bexp();             # calculate e ** $x where e is Euler\*(Aqs number
\&
\& $x\->band($y);           # bit\-wise and
\& $x\->bior($y);           # bit\-wise inclusive or
\& $x\->bxor($y);           # bit\-wise exclusive or
\& $x\->bnot();             # bit\-wise not (two\*(Aqs complement)
\&
\& $x\->bsqrt();            # calculate square\-root
\& $x\->broot($y);          # $y\*(Aqth root of $x (e.g. $y == 3 => cubic root)
\& $x\->bfac();             # factorial of $x (1*2*3*4*..$x)
\&
\& $x\->bround($N);         # accuracy: preserve $N digits
\& $x\->bfround($N);        # precision: round to the $Nth digit
\&
\& $x\->bfloor();           # return integer less or equal than $x
\& $x\->bceil();            # return integer greater or equal than $x
\&
\&  # The following do not modify their arguments:
\&
\& bgcd(@values);          # greatest common divisor
\& blcm(@values);          # lowest common multiplicator
\&
\& $x\->bstr();             # return string
\& $x\->bsstr();            # return string in scientific notation
\&
\& $x\->as_int();           # return $x as BigInt 
\& $x\->exponent();         # return exponent as BigInt
\& $x\->mantissa();         # return mantissa as BigInt
\& $x\->parts();            # return (mantissa,exponent) as BigInt
\&
\& $x\->length();           # number of digits (w/o sign and \*(Aq.\*(Aq)
\& ($l,$f) = $x\->length(); # number of digits, and length of fraction
\&
\& $x\->precision();        # return P of $x (or global, if P of $x undef)
\& $x\->precision($n);      # set P of $x to $n
\& $x\->accuracy();         # return A of $x (or global, if A of $x undef)
\& $x\->accuracy($n);       # set A $x to $n
\&
\& # these get/set the appropriate global value for all BigFloat objects
\& Math::BigFloat\->precision();   # Precision
\& Math::BigFloat\->accuracy();    # Accuracy
\& Math::BigFloat\->round_mode();  # rounding mode
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded if you
declare your big floating point numbers as
.PP
.Vb 1
\&  $i = new Math::BigFloat \*(Aq12_3.456_789_123_456_789E\-2\*(Aq;
.Ve
.PP
Operations with overloaded operators preserve the arguments, which is
exactly what you expect.
.SS "Canonical notation"
.IX Subsection "Canonical notation"
Input to these routines are either BigFloat objects, or strings of the
following four forms:
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+\e.\ed*$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+E[+\-]?\ed+$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed*\e.\ed+E[+\-]?\ed+$/\*(C'\fR
.PP
all with optional leading and trailing zeros and/or spaces. Additionally,
numbers are allowed to have an underscore between any two digits.
.PP
Empty strings as well as other illegal numbers results in 'NaN'.
.PP
\&\fIbnorm()\fR on a BigFloat object is now effectively a no-op, since the numbers 
are always stored in normalized form. On a string, it creates a BigFloat 
object.
.SS "Output"
.IX Subsection "Output"
Output values are BigFloat objects (normalized), except for \fIbstr()\fR and \fIbsstr()\fR.
.PP
The string output will always have leading and trailing zeros stripped and drop
a plus sign. \f(CW\*(C`bstr()\*(C'\fR will give you always the form with a decimal point,
while \f(CW\*(C`bsstr()\*(C'\fR (s for scientific) gives you the scientific notation.
.PP
.Vb 6
\&        Input                   bstr()          bsstr()
\&        \*(Aq\-0\*(Aq                    \*(Aq0\*(Aq             \*(Aq0E1\*(Aq
\&        \*(Aq  \-123 123 123\*(Aq        \*(Aq\-123123123\*(Aq    \*(Aq\-123123123E0\*(Aq
\&        \*(Aq00.0123\*(Aq               \*(Aq0.0123\*(Aq        \*(Aq123E\-4\*(Aq
\&        \*(Aq123.45E\-2\*(Aq             \*(Aq1.2345\*(Aq        \*(Aq12345E\-4\*(Aq
\&        \*(Aq10E+3\*(Aq                 \*(Aq10000\*(Aq         \*(Aq1E4\*(Aq
.Ve
.PP
Some routines (\f(CW\*(C`is_odd()\*(C'\fR, \f(CW\*(C`is_even()\*(C'\fR, \f(CW\*(C`is_zero()\*(C'\fR, \f(CW\*(C`is_one()\*(C'\fR,
\&\f(CW\*(C`is_nan()\*(C'\fR) return true or false, while others (\f(CW\*(C`bcmp()\*(C'\fR, \f(CW\*(C`bacmp()\*(C'\fR)
return either undef, <0, 0 or >0 and are suited for sort.
.PP
Actual math is done by using the class defined with \f(CW\*(C`with => Class;\*(C'\fR (which
defaults to BigInts) to represent the mantissa and exponent.
.PP
The sign \f(CW\*(C`/^[+\-]$/\*(C'\fR is stored separately. The string 'NaN' is used to 
represent the result when input arguments are not numbers, as well as 
the result of dividing by zero.
.ie n .SS """mantissa()"", ""exponent()"" and ""parts()"""
.el .SS "\f(CWmantissa()\fP, \f(CWexponent()\fP and \f(CWparts()\fP"
.IX Subsection "mantissa(), exponent() and parts()"
\&\f(CW\*(C`mantissa()\*(C'\fR and \f(CW\*(C`exponent()\*(C'\fR return the said parts of the BigFloat 
as BigInts such that:
.PP
.Vb 4
\&        $m = $x\->mantissa();
\&        $e = $x\->exponent();
\&        $y = $m * ( 10 ** $e );
\&        print "ok\en" if $x == $y;
.Ve
.PP
\&\f(CW\*(C`($m,$e) = $x\->parts();\*(C'\fR is just a shortcut giving you both of them.
.PP
A zero is represented and returned as \f(CW0E1\fR, \fBnot\fR \f(CW0E0\fR (after Knuth).
.PP
Currently the mantissa is reduced as much as possible, favouring higher
exponents over lower ones (e.g. returning 1e7 instead of 10e6 or 10000000e0).
This might change in the future, so do not depend on it.
.SS "Accuracy vs. Precision"
.IX Subsection "Accuracy vs. Precision"
See also: Rounding.
.PP
Math::BigFloat supports both precision (rounding to a certain place before or
after the dot) and accuracy (rounding to a certain number of digits). For a
full documentation, examples and tips on these topics please see the large
section about rounding in Math::BigInt.
.PP
Since things like \f(CWsqrt(2)\fR or \f(CW\*(C`1 / 3\*(C'\fR must presented with a limited
accuracy lest a operation consumes all resources, each operation produces
no more than the requested number of digits.
.PP
If there is no global precision or accuracy set, \fBand\fR the operation in
question was not called with a requested precision or accuracy, \fBand\fR the
input \f(CW$x\fR has no accuracy or precision set, then a fallback parameter will
be used. For historical reasons, it is called \f(CW\*(C`div_scale\*(C'\fR and can be accessed
via:
.PP
.Vb 2
\&        $d = Math::BigFloat\->div_scale();       # query
\&        Math::BigFloat\->div_scale($n);          # set to $n digits
.Ve
.PP
The default value for \f(CW\*(C`div_scale\*(C'\fR is 40.
.PP
In case the result of one operation has more digits than specified,
it is rounded. The rounding mode taken is either the default mode, or the one
supplied to the operation after the \fIscale\fR:
.PP
.Vb 7
\&    $x = Math::BigFloat\->new(2);
\&    Math::BigFloat\->accuracy(5);              # 5 digits max
\&    $y = $x\->copy()\->bdiv(3);                 # will give 0.66667
\&    $y = $x\->copy()\->bdiv(3,6);               # will give 0.666667
\&    $y = $x\->copy()\->bdiv(3,6,undef,\*(Aqodd\*(Aq);   # will give 0.666667
\&    Math::BigFloat\->round_mode(\*(Aqzero\*(Aq);
\&    $y = $x\->copy()\->bdiv(3,6);               # will also give 0.666667
.Ve
.PP
Note that \f(CW\*(C`Math::BigFloat\->accuracy()\*(C'\fR and \f(CW\*(C`Math::BigFloat\->precision()\*(C'\fR
set the global variables, and thus \fBany\fR newly created number will be subject
to the global rounding \fBimmediately\fR. This means that in the examples above, the
\&\f(CW3\fR as argument to \f(CW\*(C`bdiv()\*(C'\fR will also get an accuracy of \fB5\fR.
.PP
It is less confusing to either calculate the result fully, and afterwards
round it explicitly, or use the additional parameters to the math
functions like so:
.PP
.Vb 4
\&        use Math::BigFloat;
\&        $x = Math::BigFloat\->new(2);
\&        $y = $x\->copy()\->bdiv(3);
\&        print $y\->bround(5),"\en";               # will give 0.66667
\&
\&        or
\&
\&        use Math::BigFloat;
\&        $x = Math::BigFloat\->new(2);
\&        $y = $x\->copy()\->bdiv(3,5);             # will give 0.66667
\&        print "$y\en";
.Ve
.SS "Rounding"
.IX Subsection "Rounding"
.IP "ffround ( +$scale )" 2
.IX Item "ffround ( +$scale )"
Rounds to the \f(CW$scale\fR'th place left from the '.', counting from the dot.
The first digit is numbered 1.
.IP "ffround ( \-$scale )" 2
.IX Item "ffround ( -$scale )"
Rounds to the \f(CW$scale\fR'th place right from the '.', counting from the dot.
.IP "ffround ( 0 )" 2
.IX Item "ffround ( 0 )"
Rounds to an integer.
.IP "fround  ( +$scale )" 2
.IX Item "fround ( +$scale )"
Preserves accuracy to \f(CW$scale\fR digits from the left (aka significant digits)
and pads the rest with zeros. If the number is between 1 and \-1, the
significant digits count from the first non-zero after the '.'
.IP "fround  ( \-$scale ) and fround ( 0 )" 2
.IX Item "fround ( -$scale ) and fround ( 0 )"
These are effectively no-ops.
.PP
All rounding functions take as a second parameter a rounding mode from one of
the following: 'even', 'odd', '+inf', '\-inf', 'zero', 'trunc' or 'common'.
.PP
The default rounding mode is 'even'. By using
\&\f(CW\*(C`Math::BigFloat\->round_mode($round_mode);\*(C'\fR you can get and set the default
mode for subsequent rounding. The usage of \f(CW\*(C`$Math::BigFloat::$round_mode\*(C'\fR is
no longer supported.
The second parameter to the round functions then overrides the default
temporarily.
.PP
The \f(CW\*(C`as_number()\*(C'\fR function returns a BigInt from a Math::BigFloat. It uses
\&'trunc' as rounding mode to make it equivalent to:
.PP
.Vb 2
\&        $x = 2.5;
\&        $y = int($x) + 2;
.Ve
.PP
You can override this by passing the desired rounding mode as parameter to
\&\f(CW\*(C`as_number()\*(C'\fR:
.PP
.Vb 2
\&        $x = Math::BigFloat\->new(2.5);
\&        $y = $x\->as_number(\*(Aqodd\*(Aq);      # $y = 3
.Ve
.SH "METHODS"
.IX Header "METHODS"
Math::BigFloat supports all methods that Math::BigInt supports, except it
calculates non-integer results when possible. Please see Math::BigInt
for a full description of each method. Below are just the most important
differences:
.SS "accuracy"
.IX Subsection "accuracy"
.Vb 3
\&        $x\->accuracy(5);             # local for $x
\&        CLASS\->accuracy(5);          # global for all members of CLASS
\&                                     # Note: This also applies to new()!
\&
\&        $A = $x\->accuracy();         # read out accuracy that affects $x
\&        $A = CLASS\->accuracy();      # read out global accuracy
.Ve
.PP
Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to \fInew()\fR!
.PP
Warning! The accuracy \fIsticks\fR, e.g. once you created a number under the
influence of \f(CW\*(C`CLASS\->accuracy($A)\*(C'\fR, all results from math operations with
that number will also be rounded.
.PP
In most cases, you should probably round the results explicitly using one of
\&\*(L"\fIround()\fR\*(R" in Math::BigInt, \*(L"\fIbround()\fR\*(R" in Math::BigInt or \*(L"\fIbfround()\fR\*(R" in Math::BigInt or by passing the desired accuracy
to the math operation as additional parameter:
.PP
.Vb 4
\&        my $x = Math::BigInt\->new(30000);
\&        my $y = Math::BigInt\->new(7);
\&        print scalar $x\->copy()\->bdiv($y, 2);           # print 4300
\&        print scalar $x\->copy()\->bdiv($y)\->bround(2);   # print 4300
.Ve
.SS "\fIprecision()\fP"
.IX Subsection "precision()"
.Vb 4
\&        $x\->precision(\-2);      # local for $x, round at the second
\&                                # digit right of the dot
\&        $x\->precision(2);       # ditto, round at the second digit left
\&                                # of the dot
\&
\&        CLASS\->precision(5);    # Global for all members of CLASS
\&                                # This also applies to new()!
\&        CLASS\->precision(\-5);   # ditto
\&
\&        $P = CLASS\->precision();    # read out global precision
\&        $P = $x\->precision();       # read out precision that affects $x
.Ve
.PP
Note: You probably want to use \*(L"accuracy\*(R" instead. With \*(L"accuracy\*(R" you
set the number of digits each result should have, with \*(L"\fIprecision()\fR\*(R" you
set the place where to round!
.SS "\fIbexp()\fP"
.IX Subsection "bexp()"
.Vb 1
\&        $x\->bexp($accuracy);            # calculate e ** X
.Ve
.PP
Calculates the expression \f(CW\*(C`e ** $x\*(C'\fR where \f(CW\*(C`e\*(C'\fR is Euler's number.
.PP
This method was added in v1.82 of Math::BigInt (April 2007).
.SS "\fIbnok()\fP"
.IX Subsection "bnok()"
.Vb 1
\&        $x\->bnok($y);   # x over y (binomial coefficient n over k)
.Ve
.PP
Calculates the binomial coefficient n over k, also called the \*(L"choose\*(R"
function. The result is equivalent to:
.PP
.Vb 3
\&        ( n )      n!
\&        | \- |  = \-\-\-\-\-\-\-
\&        ( k )    k!(n\-k)!
.Ve
.PP
This method was added in v1.84 of Math::BigInt (April 2007).
.SS "\fIbpi()\fP"
.IX Subsection "bpi()"
.Vb 1
\&        print Math::BigFloat\->bpi(100), "\en";
.Ve
.PP
Calculate \s-1PI\s0 to N digits (including the 3 before the dot). The result is
rounded according to the current rounding mode, which defaults to \*(L"even\*(R".
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbcos()\fP"
.IX Subsection "bcos()"
.Vb 2
\&        my $x = Math::BigFloat\->new(1);
\&        print $x\->bcos(100), "\en";
.Ve
.PP
Calculate the cosinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbsin()\fP"
.IX Subsection "bsin()"
.Vb 2
\&        my $x = Math::BigFloat\->new(1);
\&        print $x\->bsin(100), "\en";
.Ve
.PP
Calculate the sinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan2()\fP"
.IX Subsection "batan2()"
.Vb 3
\&        my $y = Math::BigFloat\->new(2);
\&        my $x = Math::BigFloat\->new(3);
\&        print $y\->batan2($x), "\en";
.Ve
.PP
Calculate the arcus tanges of \f(CW$y\fR divided by \f(CW$x\fR, modifying \f(CW$y\fR in place.
See also \*(L"\fIbatan()\fR\*(R".
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan()\fP"
.IX Subsection "batan()"
.Vb 2
\&        my $x = Math::BigFloat\->new(1);
\&        print $x\->batan(100), "\en";
.Ve
.PP
Calculate the arcus tanges of \f(CW$x\fR, modifying \f(CW$x\fR in place. See also \*(L"\fIbatan2()\fR\*(R".
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbmuladd()\fP"
.IX Subsection "bmuladd()"
.Vb 1
\&        $x\->bmuladd($y,$z);
.Ve
.PP
Multiply \f(CW$x\fR by \f(CW$y\fR, and then add \f(CW$z\fR to the result.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SH "Autocreating constants"
.IX Header "Autocreating constants"
After \f(CW\*(C`use Math::BigFloat \*(Aq:constant\*(Aq\*(C'\fR all the floating point constants
in the given scope are converted to \f(CW\*(C`Math::BigFloat\*(C'\fR. This conversion
happens at compile time.
.PP
In particular
.PP
.Vb 1
\&  perl \-MMath::BigFloat=:constant \-e \*(Aqprint 2E\-100,"\en"\*(Aq
.Ve
.PP
prints the value of \f(CW\*(C`2E\-100\*(C'\fR. Note that without conversion of 
constants the expression 2E\-100 will be calculated as normal floating point 
number.
.PP
Please note that ':constant' does not affect integer constants, nor binary 
nor hexadecimal constants. Use bignum or Math::BigInt to get this to
work.
.SS "Math library"
.IX Subsection "Math library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqGMP\*(Aq;
.Ve
.PP
\&\fBNote\fR: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.
.PP
Note: The keyword 'lib' will warn when the requested library could not be
loaded. To suppress the warning use 'try' instead:
.PP
.Vb 1
\&        use Math::BigFloat try => \*(AqGMP\*(Aq;
.Ve
.PP
If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:
.PP
.Vb 1
\&        use Math::BigFloat only => \*(AqGMP,Pari\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
See the respective low-level library documentation for further details.
.PP
Please note that Math::BigFloat does \fBnot\fR use the denoted library itself,
but it merely passes the lib argument to Math::BigInt. So, instead of the need
to do:
.PP
.Vb 2
\&        use Math::BigInt lib => \*(AqGMP\*(Aq;
\&        use Math::BigFloat;
.Ve
.PP
you can roll it all into one line:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqGMP\*(Aq;
.Ve
.PP
It is also possible to just require Math::BigFloat:
.PP
.Vb 1
\&        require Math::BigFloat;
.Ve
.PP
This will load the necessary things (like BigInt) when they are needed, and
automatically.
.PP
See Math::BigInt for more details than you ever wanted to know about using
a different low-level library.
.SS "Using Math::BigInt::Lite"
.IX Subsection "Using Math::BigInt::Lite"
For backwards compatibility reasons it is still possible to
request a different storage class for use with Math::BigFloat:
.PP
.Vb 1
\&        use Math::BigFloat with => \*(AqMath::BigInt::Lite\*(Aq;
.Ve
.PP
However, this request is ignored, as the current code now uses the low-level
math library for directly storing the number parts.
.SH "EXPORTS"
.IX Header "EXPORTS"
\&\f(CW\*(C`Math::BigFloat\*(C'\fR exports nothing by default, but can export the \f(CW\*(C`bpi()\*(C'\fR method:
.PP
.Vb 1
\&        use Math::BigFloat qw/bpi/;
\&
\&        print bpi(10), "\en";
.Ve
.SH "BUGS"
.IX Header "BUGS"
Please see the file \s-1BUGS\s0 in the \s-1CPAN\s0 distribution Math::BigInt for known bugs.
.SH "CAVEATS"
.IX Header "CAVEATS"
Do not try to be clever to insert some operations in between switching
libraries:
.PP
.Vb 4
\&    require Math::BigFloat;
\&    my $matter = Math::BigFloat\->bone() + 4;    # load BigInt and Calc
\&    Math::BigFloat\->import( lib => \*(AqPari\*(Aq );    # load Pari, too
\&    my $anti_matter = Math::BigFloat\->bone()+4; # now use Pari
.Ve
.PP
This will create objects with numbers stored in two different backend libraries,
and \fB\s-1VERY BAD THINGS\s0\fR will happen when you use these together:
.PP
.Vb 1
\&        my $flash_and_bang = $matter + $anti_matter;    # Don\*(Aqt do this!
.Ve
.IP "stringify, \fIbstr()\fR" 1
.IX Item "stringify, bstr()"
Both stringify and \fIbstr()\fR now drop the leading '+'. The old code would return
\&'+1.23', the new returns '1.23'. See the documentation in Math::BigInt for
reasoning and details.
.IP "bdiv" 1
.IX Item "bdiv"
The following will probably not print what you expect:
.Sp
.Vb 1
\&        print $c\->bdiv(123.456),"\en";
.Ve
.Sp
It prints both quotient and remainder since print works in list context. Also,
\&\fIbdiv()\fR will modify \f(CW$c\fR, so be careful. You probably want to use
.Sp
.Vb 2
\&    print $c / 123.456,"\en";
\&    print scalar $c\->bdiv(123.456),"\en";  # or if you want to modify $c
.Ve
.Sp
instead.
.IP "brsft" 1
.IX Item "brsft"
The following will probably not print what you expect:
.Sp
.Vb 2
\&        my $c = Math::BigFloat\->new(\*(Aq3.14159\*(Aq);
\&        print $c\->brsft(3,10),"\en";     # prints 0.00314153.1415
.Ve
.Sp
It prints both quotient and remainder, since print calls \f(CW\*(C`brsft()\*(C'\fR in list
context. Also, \f(CW\*(C`$c\->brsft()\*(C'\fR will modify \f(CW$c\fR, so be careful.
You probably want to use
.Sp
.Vb 3
\&        print scalar $c\->copy()\->brsft(3,10),"\en";
\&        # or if you really want to modify $c
\&        print scalar $c\->brsft(3,10),"\en";
.Ve
.Sp
instead.
.IP "Modifying and =" 1
.IX Item "Modifying and ="
Beware of:
.Sp
.Vb 2
\&        $x = Math::BigFloat\->new(5);
\&        $y = $x;
.Ve
.Sp
It will not do what you think, e.g. making a copy of \f(CW$x\fR. Instead it just makes
a second reference to the \fBsame\fR object and stores it in \f(CW$y\fR. Thus anything
that modifies \f(CW$x\fR will modify \f(CW$y\fR (except overloaded math operators), and vice
versa. See Math::BigInt for details and how to avoid that.
.IP "bpow" 1
.IX Item "bpow"
\&\f(CW\*(C`bpow()\*(C'\fR now modifies the first argument, unlike the old code which left
it alone and only returned the result. This is to be consistent with
\&\f(CW\*(C`badd()\*(C'\fR etc. The first will modify \f(CW$x\fR, the second one won't:
.Sp
.Vb 3
\&        print bpow($x,$i),"\en";         # modify $x
\&        print $x\->bpow($i),"\en";        # ditto
\&        print $x ** $i,"\en";            # leave $x alone
.Ve
.IP "\fIprecision()\fR vs. \fIaccuracy()\fR" 1
.IX Item "precision() vs. accuracy()"
A common pitfall is to use \*(L"\fIprecision()\fR\*(R" when you want to round a result to
a certain number of digits:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    Math::BigFloat\->precision(4);            # does not do what you
\&                                             # think it does
\&    my $x = Math::BigFloat\->new(12345);      # rounds $x to "12000"!
\&    print "$x\en";                            # print "12000"
\&    my $y = Math::BigFloat\->new(3);          # rounds $y to "0"!
\&    print "$y\en";                            # print "0"
\&    $z = $x / $y;                            # 12000 / 0 => NaN!
\&    print "$z\en";
\&    print $z\->precision(),"\en";              # 4
.Ve
.Sp
Replacing \*(L"\fIprecision()\fR\*(R" with \*(L"accuracy\*(R" is probably not what you want, either:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    Math::BigFloat\->accuracy(4);             # enables global rounding:
\&    my $x = Math::BigFloat\->new(123456);     # rounded immediately
\&                                             #   to "12350"
\&    print "$x\en";                            # print "123500"
\&    my $y = Math::BigFloat\->new(3);          # rounded to "3
\&    print "$y\en";                            # print "3"
\&    print $z = $x\->copy()\->bdiv($y),"\en";    # 41170
\&    print $z\->accuracy(),"\en";               # 4
.Ve
.Sp
What you want to use instead is:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    my $x = Math::BigFloat\->new(123456);     # no rounding
\&    print "$x\en";                            # print "123456"
\&    my $y = Math::BigFloat\->new(3);          # no rounding
\&    print "$y\en";                            # print "3"
\&    print $z = $x\->copy()\->bdiv($y,4),"\en";  # 41150
\&    print $z\->accuracy(),"\en";               # undef
.Ve
.Sp
In addition to computing what you expected, the last example also does \fBnot\fR
\&\*(L"taint\*(R" the result with an accuracy or precision setting, which would
influence any further operation.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigInt, Math::BigRat and Math::Big as well as
Math::BigInt::Pari and  Math::BigInt::GMP.
.PP
The pragmas bignum, bigint and bigrat might also be of interest
because they solve the autoupgrading/downgrading issue, at least partly.
.PP
The package at <http://search.cpan.org/~tels/Math\-BigInt> contains
more documentation including a full version history, testcases, empty
subclass files and benchmarks.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels <http://bloodgate.com> in 2001 \- 2006, and still
at it in 2007.
                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Math::BigInt.3pm                             0100644 0001750 0001750 00000253626 12566207460 023471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigInt 3pm"
.TH Math::BigInt 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigInt \- Arbitrary size integer/float math package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::BigInt;
\&
\&  # or make it faster with huge numbers: install (optional)
\&  # Math::BigInt::GMP and always use (it will fall back to
\&  # pure Perl if the GMP library is not installed):
\&  # (See also the L<MATH LIBRARY> section!)
\&
\&  # will warn if Math::BigInt::GMP cannot be found
\&  use Math::BigInt lib => \*(AqGMP\*(Aq;
\&
\&  # to suppress the warning use this:
\&  # use Math::BigInt try => \*(AqGMP\*(Aq;
\&
\&  # dies if GMP cannot be loaded:
\&  # use Math::BigInt only => \*(AqGMP\*(Aq;
\&
\&  my $str = \*(Aq1234567890\*(Aq;
\&  my @values = (64,74,18);
\&  my $n = 1; my $sign = \*(Aq\-\*(Aq;
\&
\&  # Number creation     
\&  my $x = Math::BigInt\->new($str);      # defaults to 0
\&  my $y = $x\->copy();                   # make a true copy
\&  my $nan  = Math::BigInt\->bnan();      # create a NotANumber
\&  my $zero = Math::BigInt\->bzero();     # create a +0
\&  my $inf = Math::BigInt\->binf();       # create a +inf
\&  my $inf = Math::BigInt\->binf(\*(Aq\-\*(Aq);    # create a \-inf
\&  my $one = Math::BigInt\->bone();       # create a +1
\&  my $mone = Math::BigInt\->bone(\*(Aq\-\*(Aq);   # create a \-1
\&
\&  my $pi = Math::BigInt\->bpi();         # returns \*(Aq3\*(Aq
\&                                        # see Math::BigFloat::bpi()
\&
\&  $h = Math::BigInt\->new(\*(Aq0x123\*(Aq);      # from hexadecimal
\&  $b = Math::BigInt\->new(\*(Aq0b101\*(Aq);      # from binary
\&  $o = Math::BigInt\->from_oct(\*(Aq0101\*(Aq);  # from octal
\&
\&  # Testing (don\*(Aqt modify their arguments)
\&  # (return true if the condition is met, otherwise false)
\&
\&  $x\->is_zero();        # if $x is +0
\&  $x\->is_nan();         # if $x is NaN
\&  $x\->is_one();         # if $x is +1
\&  $x\->is_one(\*(Aq\-\*(Aq);      # if $x is \-1
\&  $x\->is_odd();         # if $x is odd
\&  $x\->is_even();        # if $x is even
\&  $x\->is_pos();         # if $x > 0
\&  $x\->is_neg();         # if $x < 0
\&  $x\->is_inf($sign);    # if $x is +inf, or \-inf (sign is default \*(Aq+\*(Aq)
\&  $x\->is_int();         # if $x is an integer (not a float)
\&
\&  # comparing and digit/sign extraction
\&  $x\->bcmp($y);         # compare numbers (undef,<0,=0,>0)
\&  $x\->bacmp($y);        # compare absolutely (undef,<0,=0,>0)
\&  $x\->sign();           # return the sign, either +,\- or NaN
\&  $x\->digit($n);        # return the nth digit, counting from right
\&  $x\->digit(\-$n);       # return the nth digit, counting from left
\&
\&  # The following all modify their first argument. If you want to pre\-
\&  # serve $x, use $z = $x\->copy()\->bXXX($y); See under L<CAVEATS> for
\&  # why this is necessary when mixing $a = $b assignments with non\-over\-
\&  # loaded math.
\&
\&  $x\->bzero();          # set $x to 0
\&  $x\->bnan();           # set $x to NaN
\&  $x\->bone();           # set $x to +1
\&  $x\->bone(\*(Aq\-\*(Aq);        # set $x to \-1
\&  $x\->binf();           # set $x to inf
\&  $x\->binf(\*(Aq\-\*(Aq);        # set $x to \-inf
\&
\&  $x\->bneg();           # negation
\&  $x\->babs();           # absolute value
\&  $x\->bsgn();           # sign function (\-1, 0, 1, or NaN)
\&  $x\->bnorm();          # normalize (no\-op in BigInt)
\&  $x\->bnot();           # two\*(Aqs complement (bit wise not)
\&  $x\->binc();           # increment $x by 1
\&  $x\->bdec();           # decrement $x by 1
\&
\&  $x\->badd($y);         # addition (add $y to $x)
\&  $x\->bsub($y);         # subtraction (subtract $y from $x)
\&  $x\->bmul($y);         # multiplication (multiply $x by $y)
\&  $x\->bdiv($y);         # divide, set $x to quotient
\&                        # return (quo,rem) or quo if scalar
\&
\&  $x\->bmuladd($y,$z);   # $x = $x * $y + $z
\&
\&  $x\->bmod($y);            # modulus (x % y)
\&  $x\->bmodpow($y,$mod);    # modular exponentiation (($x ** $y) % $mod)
\&  $x\->bmodinv($mod);       # modular multiplicative inverse
\&  $x\->bpow($y);            # power of arguments (x ** y)
\&  $x\->blsft($y);           # left shift in base 2
\&  $x\->brsft($y);           # right shift in base 2
\&                           # returns (quo,rem) or quo if in sca\-
\&                           # lar context
\&  $x\->blsft($y,$n);        # left shift by $y places in base $n
\&  $x\->brsft($y,$n);        # right shift by $y places in base $n
\&                           # returns (quo,rem) or quo if in sca\-
\&                           # lar context
\&
\&  $x\->band($y);            # bitwise and
\&  $x\->bior($y);            # bitwise inclusive or
\&  $x\->bxor($y);            # bitwise exclusive or
\&  $x\->bnot();              # bitwise not (two\*(Aqs complement)
\&
\&  $x\->bsqrt();             # calculate square\-root
\&  $x\->broot($y);           # $y\*(Aqth root of $x (e.g. $y == 3 => cubic root)
\&  $x\->bfac();              # factorial of $x (1*2*3*4*..$x)
\&
\&  $x\->bnok($y);            # x over y (binomial coefficient n over k)
\&
\&  $x\->blog();              # logarithm of $x to base e (Euler\*(Aqs number)
\&  $x\->blog($base);         # logarithm of $x to base $base (f.i. 2)
\&  $x\->bexp();              # calculate e ** $x where e is Euler\*(Aqs number
\&
\&  $x\->round($A,$P,$mode);  # round to accuracy or precision using
\&                           # mode $mode
\&  $x\->bround($n);          # accuracy: preserve $n digits
\&  $x\->bfround($n);         # $n > 0: round $nth digits,
\&                           # $n < 0: round to the $nth digit after the
\&                           # dot, no\-op for BigInts
\&
\&  # The following do not modify their arguments in BigInt (are no\-ops),
\&  # but do so in BigFloat:
\&
\&  $x\->bfloor();            # return integer less or equal than $x
\&  $x\->bceil();             # return integer greater or equal than $x
\&
\&  # The following do not modify their arguments:
\&
\&  # greatest common divisor (no OO style)
\&  my $gcd = Math::BigInt::bgcd(@values);
\&  # lowest common multiple (no OO style)
\&  my $lcm = Math::BigInt::blcm(@values);
\&
\&  $x\->length();            # return number of digits in number
\&  ($xl,$f) = $x\->length(); # length of number and length of fraction
\&                           # part, latter is always 0 digits long
\&                           # for BigInts
\&
\&  $x\->exponent();         # return exponent as BigInt
\&  $x\->mantissa();         # return (signed) mantissa as BigInt
\&  $x\->parts();            # return (mantissa,exponent) as BigInt
\&  $x\->copy();             # make a true copy of $x (unlike $y = $x;)
\&  $x\->as_int();           # return as BigInt (in BigInt: same as copy())
\&  $x\->numify();           # return as scalar (might overflow!)
\&
\&  # conversion to string (do not modify their argument)
\&  $x\->bstr();         # normalized string (e.g. \*(Aq3\*(Aq)
\&  $x\->bsstr();        # norm. string in scientific notation (e.g. \*(Aq3E0\*(Aq)
\&  $x\->as_hex();       # as signed hexadecimal string with prefixed 0x
\&  $x\->as_bin();       # as signed binary string with prefixed 0b
\&  $x\->as_oct();       # as signed octal string with prefixed 0
\&
\&
\&  # precision and accuracy (see section about rounding for more)
\&  $x\->precision();       # return P of $x (or global, if P of $x undef)
\&  $x\->precision($n);     # set P of $x to $n
\&  $x\->accuracy();        # return A of $x (or global, if A of $x undef)
\&  $x\->accuracy($n);      # set A $x to $n
\&
\&  # Global methods
\&  Math::BigInt\->precision();   # get/set global P for all BigInt objects
\&  Math::BigInt\->accuracy();    # get/set global A for all BigInt objects
\&  Math::BigInt\->round_mode();  # get/set global round mode, one of
\&                               # \*(Aqeven\*(Aq, \*(Aqodd\*(Aq, \*(Aq+inf\*(Aq, \*(Aq\-inf\*(Aq, \*(Aqzero\*(Aq,
\&                               # \*(Aqtrunc\*(Aq or \*(Aqcommon\*(Aq
\&  Math::BigInt\->config();      # return hash containing configuration
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded if you
declare your big integers as
.PP
.Vb 1
\&  $i = new Math::BigInt \*(Aq123_456_789_123_456_789\*(Aq;
.Ve
.PP
Operations with overloaded operators preserve the arguments which is
exactly what you expect.
.IP "Input" 2
.IX Item "Input"
Input values to these routines may be any string, that looks like a number
and results in an integer, including hexadecimal and binary numbers.
.Sp
Scalars holding numbers may also be passed, but note that non-integer numbers
may already have lost precision due to the conversion to float. Quote
your input if you want BigInt to see all the digits:
.Sp
.Vb 2
\&        $x = Math::BigInt\->new(12345678890123456789);   # bad
\&        $x = Math::BigInt\->new(\*(Aq12345678901234567890\*(Aq); # good
.Ve
.Sp
You can include one underscore between any two digits.
.Sp
This means integer values like 1.01E2 or even 1000E\-2 are also accepted.
Non-integer values result in NaN.
.Sp
Hexadecimal (prefixed with \*(L"0x\*(R") and binary numbers (prefixed with \*(L"0b\*(R")
are accepted, too. Please note that octal numbers are not recognized
by \fInew()\fR, so the following will print \*(L"123\*(R":
.Sp
.Vb 1
\&        perl \-MMath::BigInt \-le \*(Aqprint Math::BigInt\->new("0123")\*(Aq
.Ve
.Sp
To convert an octal number, use \fIfrom_oct()\fR;
.Sp
.Vb 1
\&        perl \-MMath::BigInt \-le \*(Aqprint Math::BigInt\->from_oct("0123")\*(Aq
.Ve
.Sp
Currently, \fIMath::BigInt::new()\fR defaults to 0, while Math::BigInt::new('')
results in 'NaN'. This might change in the future, so use always the following
explicit forms to get a zero or NaN:
.Sp
.Vb 2
\&        $zero = Math::BigInt\->bzero();
\&        $nan = Math::BigInt\->bnan();
.Ve
.Sp
\&\f(CW\*(C`bnorm()\*(C'\fR on a BigInt object is now effectively a no-op, since the numbers 
are always stored in normalized form. If passed a string, creates a BigInt 
object from the input.
.IP "Output" 2
.IX Item "Output"
Output values are BigInt objects (normalized), except for the methods which
return a string (see \*(L"\s-1SYNOPSIS\*(R"\s0).
.Sp
Some routines (\f(CW\*(C`is_odd()\*(C'\fR, \f(CW\*(C`is_even()\*(C'\fR, \f(CW\*(C`is_zero()\*(C'\fR, \f(CW\*(C`is_one()\*(C'\fR,
\&\f(CW\*(C`is_nan()\*(C'\fR, etc.) return true or false, while others (\f(CW\*(C`bcmp()\*(C'\fR, \f(CW\*(C`bacmp()\*(C'\fR)
return either undef (if NaN is involved), <0, 0 or >0 and are suited for sort.
.SH "METHODS"
.IX Header "METHODS"
Each of the methods below (except \fIconfig()\fR, \fIaccuracy()\fR and \fIprecision()\fR)
accepts three additional parameters. These arguments \f(CW$A\fR, \f(CW$P\fR and \f(CW$R\fR
are \f(CW\*(C`accuracy\*(C'\fR, \f(CW\*(C`precision\*(C'\fR and \f(CW\*(C`round_mode\*(C'\fR. Please see the section about
\&\*(L"\s-1ACCURACY\s0 and \s-1PRECISION\*(R"\s0 for more information.
.SS "\fIconfig()\fP"
.IX Subsection "config()"
.Vb 1
\&        use Data::Dumper;
\&
\&        print Dumper ( Math::BigInt\->config() );
\&        print Math::BigInt\->config()\->{lib},"\en";
.Ve
.PP
Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.
.PP
.Vb 10
\&        key           Description
\&                      Example
\&        ============================================================
\&        lib           Name of the low\-level math library
\&                      Math::BigInt::Calc
\&        lib_version   Version of low\-level math library (see \*(Aqlib\*(Aq)
\&                      0.30
\&        class         The class name of config() you just called
\&                      Math::BigInt
\&        upgrade       To which class math operations might be upgraded
\&                      Math::BigFloat
\&        downgrade     To which class math operations might be downgraded
\&                      undef
\&        precision     Global precision
\&                      undef
\&        accuracy      Global accuracy
\&                      undef
\&        round_mode    Global round mode
\&                      even
\&        version       version number of the class you used
\&                      1.61
\&        div_scale     Fallback accuracy for div
\&                      40
\&        trap_nan      If true, traps creation of NaN via croak()
\&                      1
\&        trap_inf      If true, traps creation of +inf/\-inf via croak()
\&                      1
.Ve
.PP
The following values can be set by passing \f(CW\*(C`config()\*(C'\fR a reference to a hash:
.PP
.Vb 2
\&        trap_inf trap_nan
\&        upgrade downgrade precision accuracy round_mode div_scale
.Ve
.PP
Example:
.PP
.Vb 3
\&        $new_cfg = Math::BigInt\->config(
\&            { trap_inf => 1, precision => 5 }
\&        );
.Ve
.SS "\fIaccuracy()\fP"
.IX Subsection "accuracy()"
.Vb 3
\&    $x\->accuracy(5);         # local for $x
\&    CLASS\->accuracy(5);      # global for all members of CLASS
\&                             # Note: This also applies to new()!
\&
\&    $A = $x\->accuracy();     # read out accuracy that affects $x
\&    $A = CLASS\->accuracy();  # read out global accuracy
.Ve
.PP
Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to \fInew()\fR!
.PP
Warning! The accuracy \fIsticks\fR, e.g. once you created a number under the
influence of \f(CW\*(C`CLASS\->accuracy($A)\*(C'\fR, all results from math operations with
that number will also be rounded.
.PP
In most cases, you should probably round the results explicitly using one of
\&\*(L"\fIround()\fR\*(R", \*(L"\fIbround()\fR\*(R" or \*(L"\fIbfround()\fR\*(R" or by passing the desired accuracy
to the math operation as additional parameter:
.PP
.Vb 4
\&    my $x = Math::BigInt\->new(30000);
\&    my $y = Math::BigInt\->new(7);
\&    print scalar $x\->copy()\->bdiv($y, 2);               # print 4300
\&    print scalar $x\->copy()\->bdiv($y)\->bround(2);       # print 4300
.Ve
.PP
Please see the section about \*(L"\s-1ACCURACY\s0 and \s-1PRECISION\*(R"\s0 for further details.
.PP
Value must be greater than zero. Pass an undef value to disable it:
.PP
.Vb 2
\&    $x\->accuracy(undef);
\&    Math::BigInt\->accuracy(undef);
.Ve
.PP
Returns the current accuracy. For \f(CW\*(C`$x\->accuracy()\*(C'\fR it will return either
the local accuracy, or if not defined, the global. This means the return value
represents the accuracy that will be in effect for \f(CW$x:\fR
.PP
.Vb 10
\&    $y = Math::BigInt\->new(1234567);       # unrounded
\&    print Math::BigInt\->accuracy(4),"\en";  # set 4, print 4
\&    $x = Math::BigInt\->new(123456);        # $x will be automatic\-
\&                                           # ally rounded!
\&    print "$x $y\en";                       # \*(Aq123500 1234567\*(Aq
\&    print $x\->accuracy(),"\en";             # will be 4
\&    print $y\->accuracy(),"\en";             # also 4, since global is 4
\&    print Math::BigInt\->accuracy(5),"\en";  # set to 5, print 5
\&    print $x\->accuracy(),"\en";             # still 4
\&    print $y\->accuracy(),"\en";             # 5, since global is 5
.Ve
.PP
Note: Works also for subclasses like Math::BigFloat. Each class has it's own
globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.
.SS "\fIprecision()\fP"
.IX Subsection "precision()"
.Vb 4
\&    $x\->precision(\-2);          # local for $x, round at the second
\&                                # digit right of the dot
\&    $x\->precision(2);           # ditto, round at the second digit left
\&                                # of the dot
\&
\&    CLASS\->precision(5);        # Global for all members of CLASS
\&                                # This also applies to new()!
\&    CLASS\->precision(\-5);       # ditto
\&
\&    $P = CLASS\->precision();    # read out global precision
\&    $P = $x\->precision();       # read out precision that affects $x
.Ve
.PP
Note: You probably want to use \*(L"\fIaccuracy()\fR\*(R" instead. With \*(L"\fIaccuracy()\fR\*(R" you
set the number of digits each result should have, with \*(L"\fIprecision()\fR\*(R" you
set the place where to round!
.PP
\&\f(CW\*(C`precision()\*(C'\fR sets or gets the global or local precision, aka at which digit
before or after the dot to round all results. A set global precision also
applies to all newly created numbers!
.PP
In Math::BigInt, passing a negative number precision has no effect since no
numbers have digits after the dot. In Math::BigFloat, it will round all
results to P digits after the dot.
.PP
Please see the section about \*(L"\s-1ACCURACY\s0 and \s-1PRECISION\*(R"\s0 for further details.
.PP
Pass an undef value to disable it:
.PP
.Vb 2
\&    $x\->precision(undef);
\&    Math::BigInt\->precision(undef);
.Ve
.PP
Returns the current precision. For \f(CW\*(C`$x\->precision()\*(C'\fR it will return either
the local precision of \f(CW$x\fR, or if not defined, the global. This means the return
value represents the prevision that will be in effect for \f(CW$x:\fR
.PP
.Vb 4
\&    $y = Math::BigInt\->new(1234567);        # unrounded
\&    print Math::BigInt\->precision(4),"\en";  # set 4, print 4
\&    $x = Math::BigInt\->new(123456);      # will be automatically rounded
\&    print $x;                               # print "120000"!
.Ve
.PP
Note: Works also for subclasses like Math::BigFloat. Each class has its
own globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.
.SS "\fIbrsft()\fP"
.IX Subsection "brsft()"
.Vb 1
\&        $x\->brsft($y,$n);
.Ve
.PP
Shifts \f(CW$x\fR right by \f(CW$y\fR in base \f(CW$n\fR. Default is base 2, used are usually 10 and
2, but others work, too.
.PP
Right shifting usually amounts to dividing \f(CW$x\fR by \f(CW$n\fR ** \f(CW$y\fR and truncating the
result:
.PP
.Vb 4
\&        $x = Math::BigInt\->new(10);
\&        $x\->brsft(1);                   # same as $x >> 1: 5
\&        $x = Math::BigInt\->new(1234);
\&        $x\->brsft(2,10);                # result 12
.Ve
.PP
There is one exception, and that is base 2 with negative \f(CW$x:\fR
.PP
.Vb 2
\&        $x = Math::BigInt\->new(\-5);
\&        print $x\->brsft(1);
.Ve
.PP
This will print \-3, not \-2 (as it would if you divide \-5 by 2 and truncate the
result).
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&        $x = Math::BigInt\->new($str,$A,$P,$R);
.Ve
.PP
Creates a new BigInt object from a scalar or another BigInt object. The
input is accepted as decimal, hex (with leading '0x') or binary (with leading
\&'0b').
.PP
See \*(L"Input\*(R" for more info on accepted input formats.
.SS "\fIfrom_oct()\fP"
.IX Subsection "from_oct()"
.Vb 1
\&        $x = Math::BigInt\->from_oct("0775");    # input is octal
.Ve
.PP
Interpret the input as an octal string and return the corresponding value. A
\&\*(L"0\*(R" (zero) prefix is optional. A single underscore character may be placed
right after the prefix, if present, or between any two digits. If the input is
invalid, a NaN is returned.
.SS "\fIfrom_hex()\fP"
.IX Subsection "from_hex()"
.Vb 1
\&        $x = Math::BigInt\->from_hex("0xcafe");  # input is hexadecimal
.Ve
.PP
Interpret input as a hexadecimal string. A \*(L"0x\*(R" or \*(L"x\*(R" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.
.SS "\fIfrom_bin()\fP"
.IX Subsection "from_bin()"
.Vb 1
\&        $x = Math::BigInt\->from_bin("0b10011"); # input is binary
.Ve
.PP
Interpret the input as a binary string. A \*(L"0b\*(R" or \*(L"b\*(R" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.
.SS "\fIbnan()\fP"
.IX Subsection "bnan()"
.Vb 1
\&        $x = Math::BigInt\->bnan();
.Ve
.PP
Creates a new BigInt object representing NaN (Not A Number).
If used on an object, it will set it to NaN:
.PP
.Vb 1
\&        $x\->bnan();
.Ve
.SS "\fIbzero()\fP"
.IX Subsection "bzero()"
.Vb 1
\&        $x = Math::BigInt\->bzero();
.Ve
.PP
Creates a new BigInt object representing zero.
If used on an object, it will set it to zero:
.PP
.Vb 1
\&        $x\->bzero();
.Ve
.SS "\fIbinf()\fP"
.IX Subsection "binf()"
.Vb 1
\&        $x = Math::BigInt\->binf($sign);
.Ve
.PP
Creates a new BigInt object representing infinity. The optional argument is
either '\-' or '+', indicating whether you want infinity or minus infinity.
If used on an object, it will set it to infinity:
.PP
.Vb 2
\&        $x\->binf();
\&        $x\->binf(\*(Aq\-\*(Aq);
.Ve
.SS "\fIbone()\fP"
.IX Subsection "bone()"
.Vb 1
\&        $x = Math::BigInt\->binf($sign);
.Ve
.PP
Creates a new BigInt object representing one. The optional argument is
either '\-' or '+', indicating whether you want one or minus one.
If used on an object, it will set it to one:
.PP
.Vb 2
\&        $x\->bone();             # +1
\&        $x\->bone(\*(Aq\-\*(Aq);          # \-1
.Ve
.SS "\fIis_one()\fP/\fIis_zero()\fP/\fIis_nan()\fP/\fIis_inf()\fP"
.IX Subsection "is_one()/is_zero()/is_nan()/is_inf()"
.Vb 6
\&        $x\->is_zero();          # true if arg is +0
\&        $x\->is_nan();           # true if arg is NaN
\&        $x\->is_one();           # true if arg is +1
\&        $x\->is_one(\*(Aq\-\*(Aq);        # true if arg is \-1
\&        $x\->is_inf();           # true if +inf
\&        $x\->is_inf(\*(Aq\-\*(Aq);        # true if \-inf (sign is default \*(Aq+\*(Aq)
.Ve
.PP
These methods all test the BigInt for being one specific value and return
true or false depending on the input. These are faster than doing something
like:
.PP
.Vb 1
\&        if ($x == 0)
.Ve
.SS "\fIis_pos()\fP/\fIis_neg()\fP/\fIis_positive()\fP/\fIis_negative()\fP"
.IX Subsection "is_pos()/is_neg()/is_positive()/is_negative()"
.Vb 2
\&        $x\->is_pos();                   # true if > 0
\&        $x\->is_neg();                   # true if < 0
.Ve
.PP
The methods return true if the argument is positive or negative, respectively.
\&\f(CW\*(C`NaN\*(C'\fR is neither positive nor negative, while \f(CW\*(C`+inf\*(C'\fR counts as positive, and
\&\f(CW\*(C`\-inf\*(C'\fR is negative. A \f(CW\*(C`zero\*(C'\fR is neither positive nor negative.
.PP
These methods are only testing the sign, and not the value.
.PP
\&\f(CW\*(C`is_positive()\*(C'\fR and \f(CW\*(C`is_negative()\*(C'\fR are aliases to \f(CW\*(C`is_pos()\*(C'\fR and
\&\f(CW\*(C`is_neg()\*(C'\fR, respectively. \f(CW\*(C`is_positive()\*(C'\fR and \f(CW\*(C`is_negative()\*(C'\fR were
introduced in v1.36, while \f(CW\*(C`is_pos()\*(C'\fR and \f(CW\*(C`is_neg()\*(C'\fR were only introduced
in v1.68.
.SS "\fIis_odd()\fP/\fIis_even()\fP/\fIis_int()\fP"
.IX Subsection "is_odd()/is_even()/is_int()"
.Vb 3
\&        $x\->is_odd();                   # true if odd, false for even
\&        $x\->is_even();                  # true if even, false for odd
\&        $x\->is_int();                   # true if $x is an integer
.Ve
.PP
The return true when the argument satisfies the condition. \f(CW\*(C`NaN\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR,
\&\f(CW\*(C`\-inf\*(C'\fR are not integers and are neither odd nor even.
.PP
In BigInt, all numbers except \f(CW\*(C`NaN\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR and \f(CW\*(C`\-inf\*(C'\fR are integers.
.SS "\fIbcmp()\fP"
.IX Subsection "bcmp()"
.Vb 1
\&        $x\->bcmp($y);
.Ve
.PP
Compares \f(CW$x\fR with \f(CW$y\fR and takes the sign into account.
Returns \-1, 0, 1 or undef.
.SS "\fIbacmp()\fP"
.IX Subsection "bacmp()"
.Vb 1
\&        $x\->bacmp($y);
.Ve
.PP
Compares \f(CW$x\fR with \f(CW$y\fR while ignoring their sign. Returns \-1, 0, 1 or undef.
.SS "\fIsign()\fP"
.IX Subsection "sign()"
.Vb 1
\&        $x\->sign();
.Ve
.PP
Return the sign, of \f(CW$x\fR, meaning either \f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`\-inf\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR or NaN.
.PP
If you want \f(CW$x\fR to have a certain sign, use one of the following methods:
.PP
.Vb 5
\&        $x\->babs();             # \*(Aq+\*(Aq
\&        $x\->babs()\->bneg();     # \*(Aq\-\*(Aq
\&        $x\->bnan();             # \*(AqNaN\*(Aq
\&        $x\->binf();             # \*(Aq+inf\*(Aq
\&        $x\->binf(\*(Aq\-\*(Aq);          # \*(Aq\-inf\*(Aq
.Ve
.SS "\fIdigit()\fP"
.IX Subsection "digit()"
.Vb 1
\&        $x\->digit($n);       # return the nth digit, counting from right
.Ve
.PP
If \f(CW$n\fR is negative, returns the digit counting from left.
.SS "\fIbneg()\fP"
.IX Subsection "bneg()"
.Vb 1
\&        $x\->bneg();
.Ve
.PP
Negate the number, e.g. change the sign between '+' and '\-', or between '+inf'
and '\-inf', respectively. Does nothing for NaN or zero.
.SS "\fIbabs()\fP"
.IX Subsection "babs()"
.Vb 1
\&        $x\->babs();
.Ve
.PP
Set the number to its absolute value, e.g. change the sign from '\-' to '+'
and from '\-inf' to '+inf', respectively. Does nothing for NaN or positive
numbers.
.SS "\fIbsgn()\fP"
.IX Subsection "bsgn()"
.Vb 1
\&        $x\->bsgn();
.Ve
.PP
Signum function. Set the number to \-1, 0, or 1, depending on whether the
number is negative, zero, or positive, respectivly. Does not modify NaNs.
.SS "\fIbnorm()\fP"
.IX Subsection "bnorm()"
.Vb 1
\&        $x\->bnorm();                    # normalize (no\-op)
.Ve
.SS "\fIbnot()\fP"
.IX Subsection "bnot()"
.Vb 1
\&        $x\->bnot();
.Ve
.PP
Two's complement (bitwise not). This is equivalent to
.PP
.Vb 1
\&        $x\->binc()\->bneg();
.Ve
.PP
but faster.
.SS "\fIbinc()\fP"
.IX Subsection "binc()"
.Vb 1
\&        $x\->binc();             # increment x by 1
.Ve
.SS "\fIbdec()\fP"
.IX Subsection "bdec()"
.Vb 1
\&        $x\->bdec();             # decrement x by 1
.Ve
.SS "\fIbadd()\fP"
.IX Subsection "badd()"
.Vb 1
\&        $x\->badd($y);           # addition (add $y to $x)
.Ve
.SS "\fIbsub()\fP"
.IX Subsection "bsub()"
.Vb 1
\&        $x\->bsub($y);           # subtraction (subtract $y from $x)
.Ve
.SS "\fIbmul()\fP"
.IX Subsection "bmul()"
.Vb 1
\&        $x\->bmul($y);           # multiplication (multiply $x by $y)
.Ve
.SS "\fIbmuladd()\fP"
.IX Subsection "bmuladd()"
.Vb 1
\&        $x\->bmuladd($y,$z);
.Ve
.PP
Multiply \f(CW$x\fR by \f(CW$y\fR, and then add \f(CW$z\fR to the result,
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbdiv()\fP"
.IX Subsection "bdiv()"
.Vb 2
\&        $x\->bdiv($y);           # divide, set $x to quotient
\&                                # return (quo,rem) or quo if scalar
.Ve
.SS "\fIbmod()\fP"
.IX Subsection "bmod()"
.Vb 1
\&        $x\->bmod($y);           # modulus (x % y)
.Ve
.SS "\fIbmodinv()\fP"
.IX Subsection "bmodinv()"
.Vb 1
\&        $x\->bmodinv($mod);      # modular multiplicative inverse
.Ve
.PP
Returns the multiplicative inverse of \f(CW$x\fR modulo \f(CW$mod\fR. If
.PP
.Vb 1
\&        $y = $x \-> copy() \-> bmodinv($mod)
.Ve
.PP
then \f(CW$y\fR is the number closest to zero, and with the same sign as \f(CW$mod\fR,
satisfying
.PP
.Vb 1
\&        ($x * $y) % $mod = 1 % $mod
.Ve
.PP
If \f(CW$x\fR and \f(CW$y\fR are non-zero, they must be relative primes, i.e.,
\&\f(CW\*(C`bgcd($y, $mod)==1\*(C'\fR. '\f(CW\*(C`NaN\*(C'\fR' is returned when no modular multiplicative
inverse exists.
.SS "\fIbmodpow()\fP"
.IX Subsection "bmodpow()"
.Vb 2
\&        $num\->bmodpow($exp,$mod);       # modular exponentiation
\&                                        # ($num**$exp % $mod)
.Ve
.PP
Returns the value of \f(CW$num\fR taken to the power \f(CW$exp\fR in the modulus
\&\f(CW$mod\fR using binary exponentiation.  \f(CW\*(C`bmodpow\*(C'\fR is far superior to
writing
.PP
.Vb 1
\&        $num ** $exp % $mod
.Ve
.PP
because it is much faster \- it reduces internal variables into
the modulus whenever possible, so it operates on smaller numbers.
.PP
\&\f(CW\*(C`bmodpow\*(C'\fR also supports negative exponents.
.PP
.Vb 1
\&        bmodpow($num, \-1, $mod)
.Ve
.PP
is exactly equivalent to
.PP
.Vb 1
\&        bmodinv($num, $mod)
.Ve
.SS "\fIbpow()\fP"
.IX Subsection "bpow()"
.Vb 1
\&        $x\->bpow($y);                 # power of arguments (x ** y)
.Ve
.SS "\fIblog()\fP"
.IX Subsection "blog()"
.Vb 1
\&        $x\->blog($base, $accuracy);   # logarithm of x to the base $base
.Ve
.PP
If \f(CW$base\fR is not defined, Euler's number (e) is used:
.PP
.Vb 1
\&        print $x\->blog(undef, 100);   # log(x) to 100 digits
.Ve
.SS "\fIbexp()\fP"
.IX Subsection "bexp()"
.Vb 1
\&        $x\->bexp($accuracy);          # calculate e ** X
.Ve
.PP
Calculates the expression \f(CW\*(C`e ** $x\*(C'\fR where \f(CW\*(C`e\*(C'\fR is Euler's number.
.PP
This method was added in v1.82 of Math::BigInt (April 2007).
.PP
See also \*(L"\fIblog()\fR\*(R".
.SS "\fIbnok()\fP"
.IX Subsection "bnok()"
.Vb 1
\&        $x\->bnok($y);        # x over y (binomial coefficient n over k)
.Ve
.PP
Calculates the binomial coefficient n over k, also called the \*(L"choose\*(R"
function. The result is equivalent to:
.PP
.Vb 3
\&        ( n )      n!
\&        | \- |  = \-\-\-\-\-\-\-
\&        ( k )    k!(n\-k)!
.Ve
.PP
This method was added in v1.84 of Math::BigInt (April 2007).
.SS "\fIbpi()\fP"
.IX Subsection "bpi()"
.Vb 1
\&        print Math::BigInt\->bpi(100), "\en";             # 3
.Ve
.PP
Returns \s-1PI\s0 truncated to an integer, with the argument being ignored. This means
under BigInt this always returns \f(CW3\fR.
.PP
If upgrading is in effect, returns \s-1PI,\s0 rounded to N digits with the
current rounding mode:
.PP
.Vb 4
\&        use Math::BigFloat;
\&        use Math::BigInt upgrade => Math::BigFloat;
\&        print Math::BigInt\->bpi(3), "\en";               # 3.14
\&        print Math::BigInt\->bpi(100), "\en";             # 3.1415....
.Ve
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbcos()\fP"
.IX Subsection "bcos()"
.Vb 2
\&        my $x = Math::BigInt\->new(1);
\&        print $x\->bcos(100), "\en";
.Ve
.PP
Calculate the cosinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbsin()\fP"
.IX Subsection "bsin()"
.Vb 2
\&        my $x = Math::BigInt\->new(1);
\&        print $x\->bsin(100), "\en";
.Ve
.PP
Calculate the sinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan2()\fP"
.IX Subsection "batan2()"
.Vb 3
\&        my $x = Math::BigInt\->new(1);
\&        my $y = Math::BigInt\->new(1);
\&        print $y\->batan2($x), "\en";
.Ve
.PP
Calculate the arcus tangens of \f(CW$y\fR divided by \f(CW$x\fR, modifying \f(CW$y\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan()\fP"
.IX Subsection "batan()"
.Vb 2
\&        my $x = Math::BigFloat\->new(0.5);
\&        print $x\->batan(100), "\en";
.Ve
.PP
Calculate the arcus tangens of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIblsft()\fP"
.IX Subsection "blsft()"
.Vb 2
\&        $x\->blsft($y);          # left shift in base 2
\&        $x\->blsft($y,$n);       # left shift, in base $n (like 10)
.Ve
.SS "\fIbrsft()\fP"
.IX Subsection "brsft()"
.Vb 2
\&        $x\->brsft($y);          # right shift in base 2
\&        $x\->brsft($y,$n);       # right shift, in base $n (like 10)
.Ve
.SS "\fIband()\fP"
.IX Subsection "band()"
.Vb 1
\&        $x\->band($y);                   # bitwise and
.Ve
.SS "\fIbior()\fP"
.IX Subsection "bior()"
.Vb 1
\&        $x\->bior($y);                   # bitwise inclusive or
.Ve
.SS "\fIbxor()\fP"
.IX Subsection "bxor()"
.Vb 1
\&        $x\->bxor($y);                   # bitwise exclusive or
.Ve
.SS "\fIbnot()\fP"
.IX Subsection "bnot()"
.Vb 1
\&        $x\->bnot();                     # bitwise not (two\*(Aqs complement)
.Ve
.SS "\fIbsqrt()\fP"
.IX Subsection "bsqrt()"
.Vb 1
\&        $x\->bsqrt();                    # calculate square\-root
.Ve
.SS "\fIbroot()\fP"
.IX Subsection "broot()"
.Vb 1
\&        $x\->broot($N);
.Ve
.PP
Calculates the N'th root of \f(CW$x\fR.
.SS "\fIbfac()\fP"
.IX Subsection "bfac()"
.Vb 1
\&        $x\->bfac();                     # factorial of $x (1*2*3*4*..$x)
.Ve
.SS "\fIround()\fP"
.IX Subsection "round()"
.Vb 1
\&        $x\->round($A,$P,$round_mode);
.Ve
.PP
Round \f(CW$x\fR to accuracy \f(CW$A\fR or precision \f(CW$P\fR using the round mode
\&\f(CW$round_mode\fR.
.SS "\fIbround()\fP"
.IX Subsection "bround()"
.Vb 1
\&        $x\->bround($N);               # accuracy: preserve $N digits
.Ve
.SS "\fIbfround()\fP"
.IX Subsection "bfround()"
.Vb 1
\&        $x\->bfround($N);
.Ve
.PP
If N is > 0, rounds to the Nth digit from the left. If N < 0, rounds to
the Nth digit after the dot. Since BigInts are integers, the case N < 0
is a no-op for them.
.PP
Examples:
.PP
.Vb 6
\&        Input           N               Result
\&        ===================================================
\&        123456.123456   3               123500
\&        123456.123456   2               123450
\&        123456.123456   \-2              123456.12
\&        123456.123456   \-3              123456.123
.Ve
.SS "\fIbfloor()\fP"
.IX Subsection "bfloor()"
.Vb 1
\&        $x\->bfloor();
.Ve
.PP
Set \f(CW$x\fR to the integer less or equal than \f(CW$x\fR. This is a no-op in BigInt, but
does change \f(CW$x\fR in BigFloat.
.SS "\fIbceil()\fP"
.IX Subsection "bceil()"
.Vb 1
\&        $x\->bceil();
.Ve
.PP
Set \f(CW$x\fR to the integer greater or equal than \f(CW$x\fR. This is a no-op in BigInt, but
does change \f(CW$x\fR in BigFloat.
.SS "\fIbgcd()\fP"
.IX Subsection "bgcd()"
.Vb 1
\&        bgcd(@values);          # greatest common divisor (no OO style)
.Ve
.SS "\fIblcm()\fP"
.IX Subsection "blcm()"
.Vb 1
\&        blcm(@values);          # lowest common multiple (no OO style)
.Ve
.PP
head2 \fIlength()\fR
.PP
.Vb 2
\&        $x\->length();
\&        ($xl,$fl) = $x\->length();
.Ve
.PP
Returns the number of digits in the decimal representation of the number.
In list context, returns the length of the integer and fraction part. For
BigInt's, the length of the fraction part will always be 0.
.SS "\fIexponent()\fP"
.IX Subsection "exponent()"
.Vb 1
\&        $x\->exponent();
.Ve
.PP
Return the exponent of \f(CW$x\fR as BigInt.
.SS "\fImantissa()\fP"
.IX Subsection "mantissa()"
.Vb 1
\&        $x\->mantissa();
.Ve
.PP
Return the signed mantissa of \f(CW$x\fR as BigInt.
.SS "\fIparts()\fP"
.IX Subsection "parts()"
.Vb 1
\&        $x\->parts();    # return (mantissa,exponent) as BigInt
.Ve
.SS "\fIcopy()\fP"
.IX Subsection "copy()"
.Vb 1
\&        $x\->copy();     # make a true copy of $x (unlike $y = $x;)
.Ve
.SS "\fIas_int()\fP/\fIas_number()\fP"
.IX Subsection "as_int()/as_number()"
.Vb 1
\&        $x\->as_int();
.Ve
.PP
Returns \f(CW$x\fR as a BigInt (truncated towards zero). In BigInt this is the same as
\&\f(CW\*(C`copy()\*(C'\fR.
.PP
\&\f(CW\*(C`as_number()\*(C'\fR is an alias to this method. \f(CW\*(C`as_number\*(C'\fR was introduced in
v1.22, while \f(CW\*(C`as_int()\*(C'\fR was only introduced in v1.68.
.SS "\fIbstr()\fP"
.IX Subsection "bstr()"
.Vb 1
\&        $x\->bstr();
.Ve
.PP
Returns a normalized string representation of \f(CW$x\fR.
.SS "\fIbsstr()\fP"
.IX Subsection "bsstr()"
.Vb 1
\&        $x\->bsstr();    # normalized string in scientific notation
.Ve
.SS "\fIas_hex()\fP"
.IX Subsection "as_hex()"
.Vb 1
\&        $x\->as_hex();   # as signed hexadecimal string with prefixed 0x
.Ve
.SS "\fIas_bin()\fP"
.IX Subsection "as_bin()"
.Vb 1
\&        $x\->as_bin();   # as signed binary string with prefixed 0b
.Ve
.SS "\fIas_oct()\fP"
.IX Subsection "as_oct()"
.Vb 1
\&        $x\->as_oct();   # as signed octal string with prefixed 0
.Ve
.SS "\fInumify()\fP"
.IX Subsection "numify()"
.Vb 1
\&        print $x\->numify();
.Ve
.PP
This returns a normal Perl scalar from \f(CW$x\fR. It is used automatically
whenever a scalar is needed, for instance in array index operations.
.PP
This loses precision, to avoid this use \fIas_int()\fR instead.
.SS "\fImodify()\fP"
.IX Subsection "modify()"
.Vb 1
\&        $x\->modify(\*(Aqbpowd\*(Aq);
.Ve
.PP
This method returns 0 if the object can be modified with the given
operation, or 1 if not.
.PP
This is used for instance by Math::BigInt::Constant.
.SS "\fIupgrade()\fP/\fIdowngrade()\fP"
.IX Subsection "upgrade()/downgrade()"
Set/get the class for downgrade/upgrade operations. Thuis is used
for instance by bignum. The defaults are '', thus the following
operation will create a BigInt, not a BigFloat:
.PP
.Vb 2
\&        my $i = Math::BigInt\->new(123);
\&        my $f = Math::BigFloat\->new(\*(Aq123.1\*(Aq);
\&
\&        print $i + $f,"\en";                     # print 246
.Ve
.SS "\fIdiv_scale()\fP"
.IX Subsection "div_scale()"
Set/get the number of digits for the default precision in divide
operations.
.SS "\fIround_mode()\fP"
.IX Subsection "round_mode()"
Set/get the current round mode.
.SH "ACCURACY and PRECISION"
.IX Header "ACCURACY and PRECISION"
Since version v1.33, Math::BigInt and Math::BigFloat have full support for
accuracy and precision based rounding, both automatically after every
operation, as well as manually.
.PP
This section describes the accuracy/precision handling in Math::Big* as it
used to be and as it is now, complete with an explanation of all terms and
abbreviations.
.PP
Not yet implemented things (but with correct description) are marked with '!',
things that need to be answered are marked with '?'.
.PP
In the next paragraph follows a short description of terms used here (because
these may differ from terms used by others people or documentation).
.PP
During the rest of this document, the shortcuts A (for accuracy), P (for
precision), F (fallback) and R (rounding mode) will be used.
.SS "Precision P"
.IX Subsection "Precision P"
A fixed number of digits before (positive) or after (negative)
the decimal point. For example, 123.45 has a precision of \-2. 0 means an
integer like 123 (or 120). A precision of 2 means two digits to the left
of the decimal point are zero, so 123 with P = 1 becomes 120. Note that
numbers with zeros before the decimal point may have different precisions,
because 1200 can have p = 0, 1 or 2 (depending on what the initial value
was). It could also have p < 0, when the digits after the decimal point
are zero.
.PP
The string output (of floating point numbers) will be padded with zeros:
.PP
.Vb 9
\&        Initial value   P       A       Result          String
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        1234.01         \-3              1000            1000
\&        1234            \-2              1200            1200
\&        1234.5          \-1              1230            1230
\&        1234.001        1               1234            1234.0
\&        1234.01         0               1234            1234
\&        1234.01         2               1234.01         1234.01
\&        1234.01         5               1234.01         1234.01000
.Ve
.PP
For BigInts, no padding occurs.
.SS "Accuracy A"
.IX Subsection "Accuracy A"
Number of significant digits. Leading zeros are not counted. A
number may have an accuracy greater than the non-zero digits
when there are zeros in it or trailing zeros. For example, 123.456 has
A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.
.PP
The string output (of floating point numbers) will be padded with zeros:
.PP
.Vb 5
\&        Initial value   P       A       Result          String
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        1234.01                 3       1230            1230
\&        1234.01                 6       1234.01         1234.01
\&        1234.1                  8       1234.1          1234.1000
.Ve
.PP
For BigInts, no padding occurs.
.SS "Fallback F"
.IX Subsection "Fallback F"
When both A and P are undefined, this is used as a fallback accuracy when
dividing numbers.
.SS "Rounding mode R"
.IX Subsection "Rounding mode R"
When rounding a number, different 'styles' or 'kinds'
of rounding are possible. (Note that random rounding, as in
Math::Round, is not implemented.)
.IP "'trunc'" 2
.IX Item "'trunc'"
truncation invariably removes all digits following the
rounding place, replacing them with zeros. Thus, 987.65 rounded
to tens (P=1) becomes 980, and rounded to the fourth sigdig
becomes 987.6 (A=4). 123.456 rounded to the second place after the
decimal point (P=\-2) becomes 123.46.
.Sp
All other implemented styles of rounding attempt to round to the
\&\*(L"nearest digit.\*(R" If the digit D immediately to the right of the
rounding place (skipping the decimal point) is greater than 5, the
number is incremented at the rounding place (possibly causing a
cascade of incrementation): e.g. when rounding to units, 0.9 rounds
to 1, and \-19.9 rounds to \-20. If D < 5, the number is similarly
truncated at the rounding place: e.g. when rounding to units, 0.4
rounds to 0, and \-19.4 rounds to \-19.
.Sp
However the results of other styles of rounding differ if the
digit immediately to the right of the rounding place (skipping the
decimal point) is 5 and if there are no digits, or no digits other
than 0, after that 5. In such cases:
.IP "'even'" 2
.IX Item "'even'"
rounds the digit at the rounding place to 0, 2, 4, 6, or 8
if it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.4, \-0.55 becomes \-0.6, but 0.4501 becomes 0.5.
.IP "'odd'" 2
.IX Item "'odd'"
rounds the digit at the rounding place to 1, 3, 5, 7, or 9 if
it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.5, \-0.55 becomes \-0.5, but 0.5501 becomes 0.6.
.IP "'+inf'" 2
.IX Item "'+inf'"
round to plus infinity, i.e. always round up. E.g., when
rounding to the first sigdig, 0.45 becomes 0.5, \-0.55 becomes \-0.5,
and 0.4501 also becomes 0.5.
.IP "'\-inf'" 2
.IX Item "'-inf'"
round to minus infinity, i.e. always round down. E.g., when
rounding to the first sigdig, 0.45 becomes 0.4, \-0.55 becomes \-0.6,
but 0.4501 becomes 0.5.
.IP "'zero'" 2
.IX Item "'zero'"
round to zero, i.e. positive numbers down, negative ones up.
E.g., when rounding to the first sigdig, 0.45 becomes 0.4, \-0.55
becomes \-0.5, but 0.4501 becomes 0.5.
.IP "'common'" 2
.IX Item "'common'"
round up if the digit immediately to the right of the rounding place
is 5 or greater, otherwise round down. E.g., 0.15 becomes 0.2 and
0.149 becomes 0.1.
.PP
The handling of A & P in \s-1MBI/MBF \s0(the old core code shipped with Perl
versions <= 5.7.2) is like this:
.IP "Precision" 2
.IX Item "Precision"
.Vb 3
\&  * ffround($p) is able to round to $p number of digits after the decimal
\&    point
\&  * otherwise P is unused
.Ve
.IP "Accuracy (significant digits)" 2
.IX Item "Accuracy (significant digits)"
.Vb 10
\&  * fround($a) rounds to $a significant digits
\&  * only fdiv() and fsqrt() take A as (optional) parameter
\&    + other operations simply create the same number (fneg etc), or more (fmul)
\&      of digits
\&    + rounding/truncating is only done when explicitly calling one of fround
\&      or ffround, and never for BigInt (not implemented)
\&  * fsqrt() simply hands its accuracy argument over to fdiv.
\&  * the documentation and the comment in the code indicate two different ways
\&    on how fdiv() determines the maximum number of digits it should calculate,
\&    and the actual code does yet another thing
\&    POD:
\&      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
\&    Comment:
\&      result has at most max(scale, length(dividend), length(divisor)) digits
\&    Actual code:
\&      scale = max(scale, length(dividend)\-1,length(divisor)\-1);
\&      scale += length(divisor) \- length(dividend);
\&    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10+9\-3).
\&    Actually, the \*(Aqdifference\*(Aq added to the scale is calculated from the
\&    number of "significant digits" in dividend and divisor, which is derived
\&    by looking at the length of the mantissa. Which is wrong, since it includes
\&    the + sign (oops) and actually gets 2 for \*(Aq+100\*(Aq and 4 for \*(Aq+101\*(Aq. Oops
\&    again. Thus 124/3 with div_scale=1 will get you \*(Aq41.3\*(Aq based on the strange
\&    assumption that 124 has 3 significant digits, while 120/7 will get you
\&    \*(Aq17\*(Aq, not \*(Aq17.1\*(Aq since 120 is thought to have 2 significant digits.
\&    The rounding after the division then uses the remainder and $y to determine
\&    whether it must round up or down.
\& ?  I have no idea which is the right way. That\*(Aqs why I used a slightly more
\& ?  simple scheme and tweaked the few failing testcases to match it.
.Ve
.PP
This is how it works now:
.IP "Setting/Accessing" 2
.IX Item "Setting/Accessing"
.Vb 10
\&  * You can set the A global via Math::BigInt\->accuracy() or
\&    Math::BigFloat\->accuracy() or whatever class you are using.
\&  * You can also set P globally by using Math::SomeClass\->precision()
\&    likewise.
\&  * Globals are classwide, and not inherited by subclasses.
\&  * to undefine A, use Math::SomeCLass\->accuracy(undef);
\&  * to undefine P, use Math::SomeClass\->precision(undef);
\&  * Setting Math::SomeClass\->accuracy() clears automatically
\&    Math::SomeClass\->precision(), and vice versa.
\&  * To be valid, A must be > 0, P can have any value.
\&  * If P is negative, this means round to the P\*(Aqth place to the right of the
\&    decimal point; positive values mean to the left of the decimal point.
\&    P of 0 means round to integer.
\&  * to find out the current global A, use Math::SomeClass\->accuracy()
\&  * to find out the current global P, use Math::SomeClass\->precision()
\&  * use $x\->accuracy() respective $x\->precision() for the local
\&    setting of $x.
\&  * Please note that $x\->accuracy() respective $x\->precision()
\&    return eventually defined global A or P, when $x\*(Aqs A or P is not
\&    set.
.Ve
.IP "Creating numbers" 2
.IX Item "Creating numbers"
.Vb 12
\&  * When you create a number, you can give the desired A or P via:
\&    $x = Math::BigInt\->new($number,$A,$P);
\&  * Only one of A or P can be defined, otherwise the result is NaN
\&  * If no A or P is give ($x = Math::BigInt\->new($number) form), then the
\&    globals (if set) will be used. Thus changing the global defaults later on
\&    will not change the A or P of previously created numbers (i.e., A and P of
\&    $x will be what was in effect when $x was created)
\&  * If given undef for A and P, NO rounding will occur, and the globals will
\&    NOT be used. This is used by subclasses to create numbers without
\&    suffering rounding in the parent. Thus a subclass is able to have its own
\&    globals enforced upon creation of a number by using
\&    $x = Math::BigInt\->new($number,undef,undef):
\&
\&        use Math::BigInt::SomeSubclass;
\&        use Math::BigInt;
\&
\&        Math::BigInt\->accuracy(2);
\&        Math::BigInt::SomeSubClass\->accuracy(3);
\&        $x = Math::BigInt::SomeSubClass\->new(1234);
\&
\&    $x is now 1230, and not 1200. A subclass might choose to implement
\&    this otherwise, e.g. falling back to the parent\*(Aqs A and P.
.Ve
.IP "Usage" 2
.IX Item "Usage"
.Vb 7
\&  * If A or P are enabled/defined, they are used to round the result of each
\&    operation according to the rules below
\&  * Negative P is ignored in Math::BigInt, since BigInts never have digits
\&    after the decimal point
\&  * Math::BigFloat uses Math::BigInt internally, but setting A or P inside
\&    Math::BigInt as globals does not tamper with the parts of a BigFloat.
\&    A flag is used to mark all Math::BigFloat numbers as \*(Aqnever round\*(Aq.
.Ve
.IP "Precedence" 2
.IX Item "Precedence"
.Vb 10
\&  * It only makes sense that a number has only one of A or P at a time.
\&    If you set either A or P on one object, or globally, the other one will
\&    be automatically cleared.
\&  * If two objects are involved in an operation, and one of them has A in
\&    effect, and the other P, this results in an error (NaN).
\&  * A takes precedence over P (Hint: A comes before P).
\&    If neither of them is defined, nothing is used, i.e. the result will have
\&    as many digits as it can (with an exception for fdiv/fsqrt) and will not
\&    be rounded.
\&  * There is another setting for fdiv() (and thus for fsqrt()). If neither of
\&    A or P is defined, fdiv() will use a fallback (F) of $div_scale digits.
\&    If either the dividend\*(Aqs or the divisor\*(Aqs mantissa has more digits than
\&    the value of F, the higher value will be used instead of F.
\&    This is to limit the digits (A) of the result (just consider what would
\&    happen with unlimited A and P in the case of 1/3 :\-)
\&  * fdiv will calculate (at least) 4 more digits than required (determined by
\&    A, P or F), and, if F is not used, round the result
\&    (this will still fail in the case of a result like 0.12345000000001 with A
\&    or P of 5, but this can not be helped \- or can it?)
\&  * Thus you can have the math done by on Math::Big* class in two modi:
\&    + never round (this is the default):
\&      This is done by setting A and P to undef. No math operation
\&      will round the result, with fdiv() and fsqrt() as exceptions to guard
\&      against overflows. You must explicitly call bround(), bfround() or
\&      round() (the latter with parameters).
\&      Note: Once you have rounded a number, the settings will \*(Aqstick\*(Aq on it
\&      and \*(Aqinfect\*(Aq all other numbers engaged in math operations with it, since
\&      local settings have the highest precedence. So, to get SaferRound[tm],
\&      use a copy() before rounding like this:
\&
\&        $x = Math::BigFloat\->new(12.34);
\&        $y = Math::BigFloat\->new(98.76);
\&        $z = $x * $y;                           # 1218.6984
\&        print $x\->copy()\->fround(3);            # 12.3 (but A is now 3!)
\&        $z = $x * $y;                           # still 1218.6984, without
\&                                                # copy would have been 1210!
\&
\&    + round after each op:
\&      After each single operation (except for testing like is_zero()), the
\&      method round() is called and the result is rounded appropriately. By
\&      setting proper values for A and P, you can have all\-the\-same\-A or
\&      all\-the\-same\-P modes. For example, Math::Currency might set A to undef,
\&      and P to \-2, globally.
\&
\& ?Maybe an extra option that forbids local A & P settings would be in order,
\& ?so that intermediate rounding does not \*(Aqpoison\*(Aq further math?
.Ve
.IP "Overriding globals" 2
.IX Item "Overriding globals"
.Vb 10
\&  * you will be able to give A, P and R as an argument to all the calculation
\&    routines; the second parameter is A, the third one is P, and the fourth is
\&    R (shift right by one for binary operations like badd). P is used only if
\&    the first parameter (A) is undefined. These three parameters override the
\&    globals in the order detailed as follows, i.e. the first defined value
\&    wins:
\&    (local: per object, global: global default, parameter: argument to sub)
\&      + parameter A
\&      + parameter P
\&      + local A (if defined on both of the operands: smaller one is taken)
\&      + local P (if defined on both of the operands: bigger one is taken)
\&      + global A
\&      + global P
\&      + global F
\&  * fsqrt() will hand its arguments to fdiv(), as it used to, only now for two
\&    arguments (A and P) instead of one
.Ve
.IP "Local settings" 2
.IX Item "Local settings"
.Vb 5
\&  * You can set A or P locally by using $x\->accuracy() or
\&    $x\->precision()
\&    and thus force different A and P for different objects/numbers.
\&  * Setting A or P this way immediately rounds $x to the new value.
\&  * $x\->accuracy() clears $x\->precision(), and vice versa.
.Ve
.IP "Rounding" 2
.IX Item "Rounding"
.Vb 10
\&  * the rounding routines will use the respective global or local settings.
\&    fround()/bround() is for accuracy rounding, while ffround()/bfround()
\&    is for precision
\&  * the two rounding functions take as the second parameter one of the
\&    following rounding modes (R):
\&    \*(Aqeven\*(Aq, \*(Aqodd\*(Aq, \*(Aq+inf\*(Aq, \*(Aq\-inf\*(Aq, \*(Aqzero\*(Aq, \*(Aqtrunc\*(Aq, \*(Aqcommon\*(Aq
\&  * you can set/get the global R by using Math::SomeClass\->round_mode()
\&    or by setting $Math::SomeClass::round_mode
\&  * after each operation, $result\->round() is called, and the result may
\&    eventually be rounded (that is, if A or P were set either locally,
\&    globally or as parameter to the operation)
\&  * to manually round a number, call $x\->round($A,$P,$round_mode);
\&    this will round the number by using the appropriate rounding function
\&    and then normalize it.
\&  * rounding modifies the local settings of the number:
\&
\&        $x = Math::BigFloat\->new(123.456);
\&        $x\->accuracy(5);
\&        $x\->bround(4);
\&
\&    Here 4 takes precedence over 5, so 123.5 is the result and $x\->accuracy()
\&    will be 4 from now on.
.Ve
.IP "Default values" 2
.IX Item "Default values"
.Vb 4
\&  * R: \*(Aqeven\*(Aq
\&  * F: 40
\&  * A: undef
\&  * P: undef
.Ve
.IP "Remarks" 2
.IX Item "Remarks"
.Vb 5
\&  * The defaults are set up so that the new code gives the same results as
\&    the old code (except in a few cases on fdiv):
\&    + Both A and P are undefined and thus will not be used for rounding
\&      after each operation.
\&    + round() is thus a no\-op, unless given extra parameters A and P
.Ve
.SH "Infinity and Not a Number"
.IX Header "Infinity and Not a Number"
While BigInt has extensive handling of inf and NaN, certain quirks remain.
.IP "\fIoct()\fR/\fIhex()\fR" 2
.IX Item "oct()/hex()"
These perl routines currently (as of Perl v.5.8.6) cannot handle passed
inf.
.Sp
.Vb 9
\&        te@linux:~> perl \-wle \*(Aqprint 2 ** 3333\*(Aq
\&        inf
\&        te@linux:~> perl \-wle \*(Aqprint 2 ** 3333 == 2 ** 3333\*(Aq
\&        1
\&        te@linux:~> perl \-wle \*(Aqprint oct(2 ** 3333)\*(Aq
\&        0
\&        te@linux:~> perl \-wle \*(Aqprint hex(2 ** 3333)\*(Aq
\&        Illegal hexadecimal digit \*(Aqi\*(Aq ignored at \-e line 1.
\&        0
.Ve
.Sp
The same problems occur if you pass them Math::BigInt\->\fIbinf()\fR objects. Since
overloading these routines is not possible, this cannot be fixed from BigInt.
.IP "==, !=, <, >, <=, >= with NaNs" 2
.IX Item "==, !=, <, >, <=, >= with NaNs"
BigInt's \fIbcmp()\fR routine currently returns undef to signal that a NaN was
involved in a comparison. However, the overload code turns that into
either 1 or '' and thus operations like \f(CW\*(C`NaN != NaN\*(C'\fR might return
wrong values.
.IP "log(\-inf)" 2
.IX Item "log(-inf)"
\&\f(CW\*(C`log(\-inf)\*(C'\fR is highly weird. Since log(\-x)=pi*i+log(x), then
log(\-inf)=pi*i+inf. However, since the imaginary part is finite, the real
infinity \*(L"overshadows\*(R" it, so the number might as well just be infinity.
However, the result is a complex number, and since BigInt/BigFloat can only
have real numbers as results, the result is NaN.
.IP "\fIexp()\fR, \fIcos()\fR, \fIsin()\fR, \fIatan2()\fR" 2
.IX Item "exp(), cos(), sin(), atan2()"
These all might have problems handling infinity right.
.SH "INTERNALS"
.IX Header "INTERNALS"
The actual numbers are stored as unsigned big integers (with separate sign).
.PP
You should neither care about nor depend on the internal representation; it
might change without notice. Use \fB\s-1ONLY\s0\fR method calls like \f(CW\*(C`$x\->sign();\*(C'\fR
instead relying on the internal representation.
.SS "\s-1MATH LIBRARY\s0"
.IX Subsection "MATH LIBRARY"
Math with the numbers is done (by default) by a module called
\&\f(CW\*(C`Math::BigInt::Calc\*(C'\fR. This is equivalent to saying:
.PP
.Vb 1
\&        use Math::BigInt try => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this backend library by using:
.PP
.Vb 1
\&        use Math::BigInt try => \*(AqGMP\*(Aq;
.Ve
.PP
\&\fBNote\fR: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.
.PP
If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:
.PP
.Vb 1
\&        use Math::BigInt only => \*(AqGMP,Pari\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use Math::BigInt try => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
The library that is loaded last will be used. Note that this can be
overwritten at any time by loading a different library, and numbers
constructed with different libraries cannot be used in math operations
together.
.PP
\fIWhat library to use?\fR
.IX Subsection "What library to use?"
.PP
\&\fBNote\fR: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.
.PP
Math::BigInt::GMP and Math::BigInt::Pari are in cases involving big
numbers much faster than Calc, however it is slower when dealing with very
small numbers (less than about 20 digits) and when converting very large
numbers to decimal (for instance for printing, rounding, calculating their
length in decimal etc).
.PP
So please select carefully what library you want to use.
.PP
Different low-level libraries use different formats to store the numbers.
However, you should \fB\s-1NOT\s0\fR depend on the number having a specific format
internally.
.PP
See the respective math library module documentation for further details.
.SS "\s-1SIGN\s0"
.IX Subsection "SIGN"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SS "\fImantissa()\fP, \fIexponent()\fP and \fIparts()\fP"
.IX Subsection "mantissa(), exponent() and parts()"
\&\f(CW\*(C`mantissa()\*(C'\fR and \f(CW\*(C`exponent()\*(C'\fR return the said parts of the BigInt such
that:
.PP
.Vb 4
\&        $m = $x\->mantissa();
\&        $e = $x\->exponent();
\&        $y = $m * ( 10 ** $e );
\&        print "ok\en" if $x == $y;
.Ve
.PP
\&\f(CW\*(C`($m,$e) = $x\->parts()\*(C'\fR is just a shortcut that gives you both of them
in one go. Both the returned mantissa and exponent have a sign.
.PP
Currently, for BigInts \f(CW$e\fR is always 0, except +inf and \-inf, where it is
\&\f(CW\*(C`+inf\*(C'\fR; and for NaN, where it is \f(CW\*(C`NaN\*(C'\fR; and for \f(CW\*(C`$x == 0\*(C'\fR, where it is \f(CW1\fR
(to be compatible with Math::BigFloat's internal representation of a zero as
\&\f(CW0E1\fR).
.PP
\&\f(CW$m\fR is currently just a copy of the original number. The relation between
\&\f(CW$e\fR and \f(CW$m\fR will stay always the same, though their real values might
change.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&  use Math::BigInt;
\&
\&  sub bint { Math::BigInt\->new(shift); }
\&
\&  $x = Math::BigInt\->bstr("1234")       # string "1234"
\&  $x = "$x";                            # same as bstr()
\&  $x = Math::BigInt\->bneg("1234");      # BigInt "\-1234"
\&  $x = Math::BigInt\->babs("\-12345");    # BigInt "12345"
\&  $x = Math::BigInt\->bnorm("\-0.00");    # BigInt "0"
\&  $x = bint(1) + bint(2);               # BigInt "3"
\&  $x = bint(1) + "2";                   # ditto (auto\-BigIntify of "2")
\&  $x = bint(1);                         # BigInt "1"
\&  $x = $x + 5 / 2;                      # BigInt "3"
\&  $x = $x ** 3;                         # BigInt "27"
\&  $x *= 2;                              # BigInt "54"
\&  $x = Math::BigInt\->new(0);            # BigInt "0"
\&  $x\-\-;                                 # BigInt "\-1"
\&  $x = Math::BigInt\->badd(4,5)          # BigInt "9"
\&  print $x\->bsstr();                    # 9e+0
.Ve
.PP
Examples for rounding:
.PP
.Vb 2
\&  use Math::BigFloat;
\&  use Test;
\&
\&  $x = Math::BigFloat\->new(123.4567);
\&  $y = Math::BigFloat\->new(123.456789);
\&  Math::BigFloat\->accuracy(4);          # no more A than 4
\&
\&  ok ($x\->copy()\->fround(),123.4);      # even rounding
\&  print $x\->copy()\->fround(),"\en";      # 123.4
\&  Math::BigFloat\->round_mode(\*(Aqodd\*(Aq);    # round to odd
\&  print $x\->copy()\->fround(),"\en";      # 123.5
\&  Math::BigFloat\->accuracy(5);          # no more A than 5
\&  Math::BigFloat\->round_mode(\*(Aqodd\*(Aq);    # round to odd
\&  print $x\->copy()\->fround(),"\en";      # 123.46
\&  $y = $x\->copy()\->fround(4),"\en";      # A = 4: 123.4
\&  print "$y, ",$y\->accuracy(),"\en";     # 123.4, 4
\&
\&  Math::BigFloat\->accuracy(undef);      # A not important now
\&  Math::BigFloat\->precision(2);         # P important
\&  print $x\->copy()\->bnorm(),"\en";       # 123.46
\&  print $x\->copy()\->fround(),"\en";      # 123.46
.Ve
.PP
Examples for converting:
.PP
.Vb 2
\&  my $x = Math::BigInt\->new(\*(Aq0b1\*(Aq.\*(Aq01\*(Aq x 123);
\&  print "bin: ",$x\->as_bin()," hex:",$x\->as_hex()," dec: ",$x,"\en";
.Ve
.SH "Autocreating constants"
.IX Header "Autocreating constants"
After \f(CW\*(C`use Math::BigInt \*(Aq:constant\*(Aq\*(C'\fR all the \fBinteger\fR decimal, hexadecimal
and binary constants in the given scope are converted to \f(CW\*(C`Math::BigInt\*(C'\fR.
This conversion happens at compile time.
.PP
In particular,
.PP
.Vb 1
\&  perl \-MMath::BigInt=:constant \-e \*(Aqprint 2**100,"\en"\*(Aq
.Ve
.PP
prints the integer value of \f(CW\*(C`2**100\*(C'\fR. Note that without conversion of 
constants the expression 2**100 will be calculated as perl scalar.
.PP
Please note that strings and floating point constants are not affected,
so that
.PP
.Vb 1
\&        use Math::BigInt qw/:constant/;
\&
\&        $x = 1234567890123456789012345678901234567890
\&                + 123456789123456789;
\&        $y = \*(Aq1234567890123456789012345678901234567890\*(Aq
\&                + \*(Aq123456789123456789\*(Aq;
.Ve
.PP
do not work. You need an explicit Math::BigInt\->\fInew()\fR around one of the
operands. You should also quote large constants to protect loss of precision:
.PP
.Vb 1
\&        use Math::BigInt;
\&
\&        $x = Math::BigInt\->new(\*(Aq1234567889123456789123456789123456789\*(Aq);
.Ve
.PP
Without the quotes Perl would convert the large number to a floating point
constant at compile time and then hand the result to BigInt, which results in
an truncated result or a NaN.
.PP
This also applies to integers that look like floating point constants:
.PP
.Vb 1
\&        use Math::BigInt \*(Aq:constant\*(Aq;
\&
\&        print ref(123e2),"\en";
\&        print ref(123.2e2),"\en";
.Ve
.PP
will print nothing but newlines. Use either bignum or Math::BigFloat
to get this to work.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
Using the form \f(CW$x\fR += \f(CW$y\fR; etc over \f(CW$x\fR = \f(CW$x\fR + \f(CW$y\fR is faster, since a copy of \f(CW$x\fR
must be made in the second case. For long numbers, the copy can eat up to 20%
of the work (in the case of addition/subtraction, less for
multiplication/division). If \f(CW$y\fR is very small compared to \f(CW$x\fR, the form
\&\f(CW$x\fR += \f(CW$y\fR is \s-1MUCH\s0 faster than \f(CW$x\fR = \f(CW$x\fR + \f(CW$y\fR since making the copy of \f(CW$x\fR takes
more time then the actual addition.
.PP
With a technique called copy-on-write, the cost of copying with overload could
be minimized or even completely avoided. A test implementation of \s-1COW\s0 did show
performance gains for overloaded math, but introduced a performance loss due
to a constant overhead for all other operations. So Math::BigInt does currently
not \s-1COW.\s0
.PP
The rewritten version of this module (vs. v0.01) is slower on certain
operations, like \f(CW\*(C`new()\*(C'\fR, \f(CW\*(C`bstr()\*(C'\fR and \f(CW\*(C`numify()\*(C'\fR. The reason are that it
does now more work and handles much more cases. The time spent in these
operations is usually gained in the other math operations so that code on
the average should get (much) faster. If they don't, please contact the author.
.PP
Some operations may be slower for small numbers, but are significantly faster
for big numbers. Other operations are now constant (O(1), like \f(CW\*(C`bneg()\*(C'\fR,
\&\f(CW\*(C`babs()\*(C'\fR etc), instead of O(N) and thus nearly always take much less time.
These optimizations were done on purpose.
.PP
If you find the Calc module to slow, try to install any of the replacement
modules and see if they help you.
.SS "Alternative math libraries"
.IX Subsection "Alternative math libraries"
You can use an alternative library to drive Math::BigInt. See the section
\&\*(L"\s-1MATH LIBRARY\*(R"\s0 for more information.
.PP
For more benchmark results see <http://bloodgate.com/perl/benchmarks.html>.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
.SS "Subclassing Math::BigInt"
.IX Subsection "Subclassing Math::BigInt"
The basic design of Math::BigInt allows simple subclasses with very little
work, as long as a few simple rules are followed:
.IP "\(bu" 2
The public \s-1API\s0 must remain consistent, i.e. if a sub-class is overloading
addition, the sub-class must use the same name, in this case \fIbadd()\fR. The
reason for this is that Math::BigInt is optimized to call the object methods
directly.
.IP "\(bu" 2
The private object hash keys like \f(CW\*(C`$x\->{sign}\*(C'\fR may not be changed, but
additional keys can be added, like \f(CW\*(C`$x\->{_custom}\*(C'\fR.
.IP "\(bu" 2
Accessor functions are available for all existing object hash keys and should
be used instead of directly accessing the internal hash keys. The reason for
this is that Math::BigInt itself has a pluggable interface which permits it
to support different storage methods.
.PP
More complex sub-classes may have to replicate more of the logic internal of
Math::BigInt if they need to change more basic behaviors. A subclass that
needs to merely change the output only needs to overload \f(CW\*(C`bstr()\*(C'\fR.
.PP
All other object methods and overloaded functions can be directly inherited
from the parent class.
.PP
At the very minimum, any subclass will need to provide its own \f(CW\*(C`new()\*(C'\fR and can
store additional hash keys in the object. There are also some package globals
that must be defined, e.g.:
.PP
.Vb 5
\&  # Globals
\&  $accuracy = undef;
\&  $precision = \-2;       # round to 2 decimal places
\&  $round_mode = \*(Aqeven\*(Aq;
\&  $div_scale = 40;
.Ve
.PP
Additionally, you might want to provide the following two globals to allow
auto-upgrading and auto-downgrading to work correctly:
.PP
.Vb 2
\&  $upgrade = undef;
\&  $downgrade = undef;
.Ve
.PP
This allows Math::BigInt to correctly retrieve package globals from the 
subclass, like \f(CW$SubClass::precision\fR.  See t/Math/BigInt/Subclass.pm or
t/Math/BigFloat/SubClass.pm completely functional subclass examples.
.PP
Don't forget to
.PP
.Vb 1
\&        use overload;
.Ve
.PP
in your subclass to automatically inherit the overloading from the parent. If
you like, you can change part of the overloading, look at Math::String for an
example.
.SH "UPGRADING"
.IX Header "UPGRADING"
When used like this:
.PP
.Vb 1
\&        use Math::BigInt upgrade => \*(AqFoo::Bar\*(Aq;
.Ve
.PP
certain operations will 'upgrade' their calculation and thus the result to
the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:
.PP
.Vb 1
\&        use Math::BigInt upgrade => \*(AqMath::BigFloat\*(Aq;
.Ve
.PP
As a shortcut, you can use the module \f(CW\*(C`bignum\*(C'\fR:
.PP
.Vb 1
\&        use bignum;
.Ve
.PP
Also good for one-liners:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint 2 ** 255\*(Aq
.Ve
.PP
This makes it possible to mix arguments of different classes (as in 2.5 + 2)
as well es preserve accuracy (as in \fIsqrt\fR\|(3)).
.PP
Beware: This feature is not fully implemented yet.
.SS "Auto-upgrade"
.IX Subsection "Auto-upgrade"
The following methods upgrade themselves unconditionally; that is if upgrade
is in effect, they will always hand up their work:
.IP "\fIbsqrt()\fR" 2
.IX Item "bsqrt()"
.PD 0
.IP "\fIdiv()\fR" 2
.IX Item "div()"
.IP "\fIblog()\fR" 2
.IX Item "blog()"
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.PD
.PP
Beware: This list is not complete.
.PP
All other methods upgrade themselves only when one (or all) of their
arguments are of the class mentioned in \f(CW$upgrade\fR (This might change in later
versions to a more sophisticated scheme):
.SH "EXPORTS"
.IX Header "EXPORTS"
\&\f(CW\*(C`Math::BigInt\*(C'\fR exports nothing by default, but can export the following methods:
.PP
.Vb 2
\&        bgcd
\&        blcm
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
Some things might not work as you expect them. Below is documented what is
known to be troublesome:
.IP "\fIbstr()\fR, \fIbsstr()\fR and 'cmp'" 1
.IX Item "bstr(), bsstr() and 'cmp'"
Both \f(CW\*(C`bstr()\*(C'\fR and \f(CW\*(C`bsstr()\*(C'\fR as well as automated stringify via overload now
drop the leading '+'. The old code would return '+3', the new returns '3'.
This is to be consistent with Perl and to make \f(CW\*(C`cmp\*(C'\fR (especially with
overloading) to work as you expect. It also solves problems with \f(CW\*(C`Test.pm\*(C'\fR,
because its \f(CW\*(C`ok()\*(C'\fR uses 'eq' internally.
.Sp
Mark Biggar said, when asked about to drop the '+' altogether, or make only
\&\f(CW\*(C`cmp\*(C'\fR work:
.Sp
.Vb 4
\&        I agree (with the first alternative), don\*(Aqt add the \*(Aq+\*(Aq on positive
\&        numbers.  It\*(Aqs not as important anymore with the new internal 
\&        form for numbers.  It made doing things like abs and neg easier,
\&        but those have to be done differently now anyway.
.Ve
.Sp
So, the following examples will now work all as expected:
.Sp
.Vb 3
\&        use Test;
\&        BEGIN { plan tests => 1 }
\&        use Math::BigInt;
\&
\&        my $x = new Math::BigInt 3*3;
\&        my $y = new Math::BigInt 3*3;
\&
\&        ok ($x,3*3);
\&        print "$x eq 9" if $x eq $y;
\&        print "$x eq 9" if $x eq \*(Aq9\*(Aq;
\&        print "$x eq 9" if $x eq 3*3;
.Ve
.Sp
Additionally, the following still works:
.Sp
.Vb 3
\&        print "$x == 9" if $x == $y;
\&        print "$x == 9" if $x == 9;
\&        print "$x == 9" if $x == 3*3;
.Ve
.Sp
There is now a \f(CW\*(C`bsstr()\*(C'\fR method to get the string in scientific notation aka
\&\f(CW1e+2\fR instead of \f(CW100\fR. Be advised that overloaded 'eq' always uses \fIbstr()\fR
for comparison, but Perl will represent some numbers as 100 and others
as 1e+308. If in doubt, convert both arguments to Math::BigInt before 
comparing them as strings:
.Sp
.Vb 3
\&        use Test;
\&        BEGIN { plan tests => 3 }
\&        use Math::BigInt;
\&
\&        $x = Math::BigInt\->new(\*(Aq1e56\*(Aq); $y = 1e56;
\&        ok ($x,$y);                     # will fail
\&        ok ($x\->bsstr(),$y);            # okay
\&        $y = Math::BigInt\->new($y);
\&        ok ($x,$y);                     # okay
.Ve
.Sp
Alternatively, simple use \f(CW\*(C`<=>\*(C'\fR for comparisons, this will get it
always right. There is not yet a way to get a number automatically represented
as a string that matches exactly the way Perl represents it.
.Sp
See also the section about \*(L"Infinity and Not a Number\*(R" for problems in
comparing NaNs.
.IP "\fIint()\fR" 1
.IX Item "int()"
\&\f(CW\*(C`int()\*(C'\fR will return (at least for Perl v5.7.1 and up) another BigInt, not a 
Perl scalar:
.Sp
.Vb 4
\&        $x = Math::BigInt\->new(123);
\&        $y = int($x);                           # BigInt 123
\&        $x = Math::BigFloat\->new(123.45);
\&        $y = int($x);                           # BigInt 123
.Ve
.Sp
In all Perl versions you can use \f(CW\*(C`as_number()\*(C'\fR or \f(CW\*(C`as_int\*(C'\fR for the same
effect:
.Sp
.Vb 3
\&        $x = Math::BigFloat\->new(123.45);
\&        $y = $x\->as_number();                   # BigInt 123
\&        $y = $x\->as_int();                      # ditto
.Ve
.Sp
This also works for other subclasses, like Math::String.
.Sp
If you want a real Perl scalar, use \f(CW\*(C`numify()\*(C'\fR:
.Sp
.Vb 1
\&        $y = $x\->numify();                      # 123 as scalar
.Ve
.Sp
This is seldom necessary, though, because this is done automatically, like
when you access an array:
.Sp
.Vb 1
\&        $z = $array[$x];                        # does work automatically
.Ve
.IP "length" 1
.IX Item "length"
The following will probably not do what you expect:
.Sp
.Vb 2
\&        $c = Math::BigInt\->new(123);
\&        print $c\->length(),"\en";                # prints 30
.Ve
.Sp
It prints both the number of digits in the number and in the fraction part
since print calls \f(CW\*(C`length()\*(C'\fR in list context. Use something like:
.Sp
.Vb 1
\&        print scalar $c\->length(),"\en";         # prints 3
.Ve
.IP "bdiv" 1
.IX Item "bdiv"
The following will probably not do what you expect:
.Sp
.Vb 1
\&        print $c\->bdiv(10000),"\en";
.Ve
.Sp
It prints both quotient and remainder since print calls \f(CW\*(C`bdiv()\*(C'\fR in list
context. Also, \f(CW\*(C`bdiv()\*(C'\fR will modify \f(CW$c\fR, so be careful. You probably want
to use
.Sp
.Vb 2
\&        print $c / 10000,"\en";
\&        print scalar $c\->bdiv(10000),"\en";  # or if you want to modify $c
.Ve
.Sp
instead.
.Sp
The quotient is always the greatest integer less than or equal to the
real-valued quotient of the two operands, and the remainder (when it is
non-zero) always has the same sign as the second operand; so, for
example,
.Sp
.Vb 6
\&          1 / 4  => ( 0, 1)
\&          1 / \-4 => (\-1,\-3)
\&         \-3 / 4  => (\-1, 1)
\&         \-3 / \-4 => ( 0,\-3)
\&        \-11 / 2  => (\-5,1)
\&         11 /\-2  => (\-5,\-1)
.Ve
.Sp
As a consequence, the behavior of the operator % agrees with the
behavior of Perl's built-in % operator (as documented in the perlop
manpage), and the equation
.Sp
.Vb 1
\&        $x == ($x / $y) * $y + ($x % $y)
.Ve
.Sp
holds true for any \f(CW$x\fR and \f(CW$y\fR, which justifies calling the two return
values of \fIbdiv()\fR the quotient and remainder. The only exception to this rule
are when \f(CW$y\fR == 0 and \f(CW$x\fR is negative, then the remainder will also be
negative. See below under \*(L"infinity handling\*(R" for the reasoning behind this.
.Sp
Perl's 'use integer;' changes the behaviour of % and / for scalars, but will
not change BigInt's way to do things. This is because under 'use integer' Perl
will do what the underlying C thinks is right and this is different for each
system. If you need BigInt's behaving exactly like Perl's 'use integer', bug
the author to implement it ;)
.IP "infinity handling" 1
.IX Item "infinity handling"
Here are some examples that explain the reasons why certain results occur while
handling infinity:
.Sp
The following table shows the result of the division and the remainder, so that
the equation above holds true. Some \*(L"ordinary\*(R" cases are strewn in to show more
clearly the reasoning:
.Sp
.Vb 10
\&        A /  B  =   C,     R so that C *    B +    R =    A
\&     =========================================================
\&        5 /   8 =   0,     5         0 *    8 +    5 =    5
\&        0 /   8 =   0,     0         0 *    8 +    0 =    0
\&        0 / inf =   0,     0         0 *  inf +    0 =    0
\&        0 /\-inf =   0,     0         0 * \-inf +    0 =    0
\&        5 / inf =   0,     5         0 *  inf +    5 =    5
\&        5 /\-inf =   0,     5         0 * \-inf +    5 =    5
\&        \-5/ inf =   0,    \-5         0 *  inf +   \-5 =   \-5
\&        \-5/\-inf =   0,    \-5         0 * \-inf +   \-5 =   \-5
\&       inf/   5 =  inf,    0       inf *    5 +    0 =  inf
\&      \-inf/   5 = \-inf,    0      \-inf *    5 +    0 = \-inf
\&       inf/  \-5 = \-inf,    0      \-inf *   \-5 +    0 =  inf
\&      \-inf/  \-5 =  inf,    0       inf *   \-5 +    0 = \-inf
\&         5/   5 =    1,    0         1 *    5 +    0 =    5
\&        \-5/  \-5 =    1,    0         1 *   \-5 +    0 =   \-5
\&       inf/ inf =    1,    0         1 *  inf +    0 =  inf
\&      \-inf/\-inf =    1,    0         1 * \-inf +    0 = \-inf
\&       inf/\-inf =   \-1,    0        \-1 * \-inf +    0 =  inf
\&      \-inf/ inf =   \-1,    0         1 * \-inf +    0 = \-inf
\&         8/   0 =  inf,    8       inf *    0 +    8 =    8
\&       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf
\&         0/   0 =  NaN
.Ve
.Sp
These cases below violate the \*(L"remainder has the sign of the second of the two
arguments\*(R", since they wouldn't match up otherwise.
.Sp
.Vb 4
\&        A /  B  =   C,     R so that C *    B +    R =    A
\&     ========================================================
\&      \-inf/   0 = \-inf, \-inf      \-inf *    0 +  inf = \-inf
\&        \-8/   0 = \-inf,   \-8      \-inf *    0 +    8 = \-8
.Ve
.IP "Modifying and =" 1
.IX Item "Modifying and ="
Beware of:
.Sp
.Vb 2
\&        $x = Math::BigFloat\->new(5);
\&        $y = $x;
.Ve
.Sp
It will not do what you think, e.g. making a copy of \f(CW$x\fR. Instead it just makes
a second reference to the \fBsame\fR object and stores it in \f(CW$y\fR. Thus anything
that modifies \f(CW$x\fR (except overloaded operators) will modify \f(CW$y\fR, and vice versa.
Or in other words, \f(CW\*(C`=\*(C'\fR is only safe if you modify your BigInts only via
overloaded math. As soon as you use a method call it breaks:
.Sp
.Vb 2
\&        $x\->bmul(2);
\&        print "$x, $y\en";       # prints \*(Aq10, 10\*(Aq
.Ve
.Sp
If you want a true copy of \f(CW$x\fR, use:
.Sp
.Vb 1
\&        $y = $x\->copy();
.Ve
.Sp
You can also chain the calls like this, this will make first a copy and then
multiply it by 2:
.Sp
.Vb 1
\&        $y = $x\->copy()\->bmul(2);
.Ve
.Sp
See also the documentation for overload.pm regarding \f(CW\*(C`=\*(C'\fR.
.IP "bpow" 1
.IX Item "bpow"
\&\f(CW\*(C`bpow()\*(C'\fR (and the rounding functions) now modifies the first argument and
returns it, unlike the old code which left it alone and only returned the
result. This is to be consistent with \f(CW\*(C`badd()\*(C'\fR etc. The first three will
modify \f(CW$x\fR, the last one won't:
.Sp
.Vb 4
\&        print bpow($x,$i),"\en";         # modify $x
\&        print $x\->bpow($i),"\en";        # ditto
\&        print $x **= $i,"\en";           # the same
\&        print $x ** $i,"\en";            # leave $x alone
.Ve
.Sp
The form \f(CW\*(C`$x **= $y\*(C'\fR is faster than \f(CW\*(C`$x = $x ** $y;\*(C'\fR, though.
.IP "Overloading \-$x" 1
.IX Item "Overloading -$x"
The following:
.Sp
.Vb 1
\&        $x = \-$x;
.Ve
.Sp
is slower than
.Sp
.Vb 1
\&        $x\->bneg();
.Ve
.Sp
since overload calls \f(CW\*(C`sub($x,0,1);\*(C'\fR instead of \f(CW\*(C`neg($x)\*(C'\fR. The first variant
needs to preserve \f(CW$x\fR since it does not know that it later will get overwritten.
This makes a copy of \f(CW$x\fR and takes O(N), but \f(CW$x\fR\->\fIbneg()\fR is O(1).
.IP "Mixing different object types" 1
.IX Item "Mixing different object types"
In Perl you will get a floating point value if you do one of the following:
.Sp
.Vb 3
\&        $float = 5.0 + 2;
\&        $float = 2 + 5.0;
\&        $float = 5 / 2;
.Ve
.Sp
With overloaded math, only the first two variants will result in a BigFloat:
.Sp
.Vb 2
\&        use Math::BigInt;
\&        use Math::BigFloat;
\&
\&        $mbf = Math::BigFloat\->new(5);
\&        $mbi2 = Math::BigInteger\->new(5);
\&        $mbi = Math::BigInteger\->new(2);
\&
\&                                        # what actually gets called:
\&        $float = $mbf + $mbi;           # $mbf\->badd()
\&        $float = $mbf / $mbi;           # $mbf\->bdiv()
\&        $integer = $mbi + $mbf;         # $mbi\->badd()
\&        $integer = $mbi2 / $mbi;        # $mbi2\->bdiv()
\&        $integer = $mbi2 / $mbf;        # $mbi2\->bdiv()
.Ve
.Sp
This is because math with overloaded operators follows the first (dominating)
operand, and the operation of that is called and returns thus the result. So,
\&\fIMath::BigInt::bdiv()\fR will always return a Math::BigInt, regardless whether
the result should be a Math::BigFloat or the second operant is one.
.Sp
To get a Math::BigFloat you either need to call the operation manually,
make sure the operands are already of the proper type or casted to that type
via Math::BigFloat\->\fInew()\fR:
.Sp
.Vb 1
\&        $float = Math::BigFloat\->new($mbi2) / $mbi;     # = 2.5
.Ve
.Sp
Beware of simple \*(L"casting\*(R" the entire expression, this would only convert
the already computed result:
.Sp
.Vb 1
\&        $float = Math::BigFloat\->new($mbi2 / $mbi);     # = 2.0 thus wrong!
.Ve
.Sp
Beware also of the order of more complicated expressions like:
.Sp
.Vb 2
\&        $integer = ($mbi2 + $mbi) / $mbf;               # int / float => int
\&        $integer = $mbi2 / Math::BigFloat\->new($mbi);   # ditto
.Ve
.Sp
If in doubt, break the expression into simpler terms, or cast all operands
to the desired resulting type.
.Sp
Scalar values are a bit different, since:
.Sp
.Vb 2
\&        $float = 2 + $mbf;
\&        $float = $mbf + 2;
.Ve
.Sp
will both result in the proper type due to the way the overloaded math works.
.Sp
This section also applies to other overloaded math packages, like Math::String.
.Sp
One solution to you problem might be autoupgrading|upgrading. See the
pragmas bignum, bigint and bigrat for an easy way to do this.
.IP "\fIbsqrt()\fR" 1
.IX Item "bsqrt()"
\&\f(CW\*(C`bsqrt()\*(C'\fR works only good if the result is a big integer, e.g. the square
root of 144 is 12, but from 12 the square root is 3, regardless of rounding
mode. The reason is that the result is always truncated to an integer.
.Sp
If you want a better approximation of the square root, then use:
.Sp
.Vb 4
\&        $x = Math::BigFloat\->new(12);
\&        Math::BigFloat\->precision(0);
\&        Math::BigFloat\->round_mode(\*(Aqeven\*(Aq);
\&        print $x\->copy\->bsqrt(),"\en";           # 4
\&
\&        Math::BigFloat\->precision(2);
\&        print $x\->bsqrt(),"\en";                 # 3.46
\&        print $x\->bsqrt(3),"\en";                # 3.464
.Ve
.IP "\fIbrsft()\fR" 1
.IX Item "brsft()"
For negative numbers in base see also brsft.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigFloat, Math::BigRat and Math::Big as well as
Math::BigInt::Pari and  Math::BigInt::GMP.
.PP
The pragmas bignum, bigint and bigrat also might be of interest
because they solve the autoupgrading/downgrading issue, at least partly.
.PP
The package at
<http://search.cpan.org/search?mode=module&query=Math%3A%3ABigInt> contains
more documentation including a full version history, testcases, empty
subclass files and benchmarks.
.SH "AUTHORS"
.IX Header "AUTHORS"
Original code by Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 \- 2006
and still at it in 2007.
.PP
Many people contributed in one or more ways to the final beast, see the file
\&\s-1CREDITS\s0 for an (incomplete) list. If you miss your name, please drop me a
mail. Thank you!
                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Math::BigInt5.16.3pm                         0100644 0001750 0001750 00000253362 12566207436 024003  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigInt 3pm"
.TH Math::BigInt 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigInt \- Arbitrary size integer/float math package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::BigInt;
\&
\&  # or make it faster with huge numbers: install (optional)
\&  # Math::BigInt::GMP and always use (it will fall back to
\&  # pure Perl if the GMP library is not installed):
\&  # (See also the L<MATH LIBRARY> section!)
\&
\&  # will warn if Math::BigInt::GMP cannot be found
\&  use Math::BigInt lib => \*(AqGMP\*(Aq;
\&
\&  # to suppress the warning use this:
\&  # use Math::BigInt try => \*(AqGMP\*(Aq;
\&
\&  # dies if GMP cannot be loaded:
\&  # use Math::BigInt only => \*(AqGMP\*(Aq;
\&
\&  my $str = \*(Aq1234567890\*(Aq;
\&  my @values = (64,74,18);
\&  my $n = 1; my $sign = \*(Aq\-\*(Aq;
\&
\&  # Number creation     
\&  my $x = Math::BigInt\->new($str);      # defaults to 0
\&  my $y = $x\->copy();                   # make a true copy
\&  my $nan  = Math::BigInt\->bnan();      # create a NotANumber
\&  my $zero = Math::BigInt\->bzero();     # create a +0
\&  my $inf = Math::BigInt\->binf();       # create a +inf
\&  my $inf = Math::BigInt\->binf(\*(Aq\-\*(Aq);    # create a \-inf
\&  my $one = Math::BigInt\->bone();       # create a +1
\&  my $mone = Math::BigInt\->bone(\*(Aq\-\*(Aq);   # create a \-1
\&
\&  my $pi = Math::BigInt\->bpi();         # returns \*(Aq3\*(Aq
\&                                        # see Math::BigFloat::bpi()
\&
\&  $h = Math::BigInt\->new(\*(Aq0x123\*(Aq);      # from hexadecimal
\&  $b = Math::BigInt\->new(\*(Aq0b101\*(Aq);      # from binary
\&  $o = Math::BigInt\->from_oct(\*(Aq0101\*(Aq);  # from octal
\&
\&  # Testing (don\*(Aqt modify their arguments)
\&  # (return true if the condition is met, otherwise false)
\&
\&  $x\->is_zero();        # if $x is +0
\&  $x\->is_nan();         # if $x is NaN
\&  $x\->is_one();         # if $x is +1
\&  $x\->is_one(\*(Aq\-\*(Aq);      # if $x is \-1
\&  $x\->is_odd();         # if $x is odd
\&  $x\->is_even();        # if $x is even
\&  $x\->is_pos();         # if $x > 0
\&  $x\->is_neg();         # if $x < 0
\&  $x\->is_inf($sign);    # if $x is +inf, or \-inf (sign is default \*(Aq+\*(Aq)
\&  $x\->is_int();         # if $x is an integer (not a float)
\&
\&  # comparing and digit/sign extraction
\&  $x\->bcmp($y);         # compare numbers (undef,<0,=0,>0)
\&  $x\->bacmp($y);        # compare absolutely (undef,<0,=0,>0)
\&  $x\->sign();           # return the sign, either +,\- or NaN
\&  $x\->digit($n);        # return the nth digit, counting from right
\&  $x\->digit(\-$n);       # return the nth digit, counting from left
\&
\&  # The following all modify their first argument. If you want to pre\-
\&  # serve $x, use $z = $x\->copy()\->bXXX($y); See under L<CAVEATS> for
\&  # why this is necessary when mixing $a = $b assignments with non\-over\-
\&  # loaded math.
\&
\&  $x\->bzero();          # set $x to 0
\&  $x\->bnan();           # set $x to NaN
\&  $x\->bone();           # set $x to +1
\&  $x\->bone(\*(Aq\-\*(Aq);        # set $x to \-1
\&  $x\->binf();           # set $x to inf
\&  $x\->binf(\*(Aq\-\*(Aq);        # set $x to \-inf
\&
\&  $x\->bneg();           # negation
\&  $x\->babs();           # absolute value
\&  $x\->bsgn();           # sign function (\-1, 0, 1, or NaN)
\&  $x\->bnorm();          # normalize (no\-op in BigInt)
\&  $x\->bnot();           # two\*(Aqs complement (bit wise not)
\&  $x\->binc();           # increment $x by 1
\&  $x\->bdec();           # decrement $x by 1
\&
\&  $x\->badd($y);         # addition (add $y to $x)
\&  $x\->bsub($y);         # subtraction (subtract $y from $x)
\&  $x\->bmul($y);         # multiplication (multiply $x by $y)
\&  $x\->bdiv($y);         # divide, set $x to quotient
\&                        # return (quo,rem) or quo if scalar
\&
\&  $x\->bmuladd($y,$z);   # $x = $x * $y + $z
\&
\&  $x\->bmod($y);            # modulus (x % y)
\&  $x\->bmodpow($y,$mod);    # modular exponentiation (($x ** $y) % $mod)
\&  $x\->bmodinv($mod);       # modular multiplicative inverse
\&  $x\->bpow($y);            # power of arguments (x ** y)
\&  $x\->blsft($y);           # left shift in base 2
\&  $x\->brsft($y);           # right shift in base 2
\&                           # returns (quo,rem) or quo if in sca\-
\&                           # lar context
\&  $x\->blsft($y,$n);        # left shift by $y places in base $n
\&  $x\->brsft($y,$n);        # right shift by $y places in base $n
\&                           # returns (quo,rem) or quo if in sca\-
\&                           # lar context
\&
\&  $x\->band($y);            # bitwise and
\&  $x\->bior($y);            # bitwise inclusive or
\&  $x\->bxor($y);            # bitwise exclusive or
\&  $x\->bnot();              # bitwise not (two\*(Aqs complement)
\&
\&  $x\->bsqrt();             # calculate square\-root
\&  $x\->broot($y);           # $y\*(Aqth root of $x (e.g. $y == 3 => cubic root)
\&  $x\->bfac();              # factorial of $x (1*2*3*4*..$x)
\&
\&  $x\->bnok($y);            # x over y (binomial coefficient n over k)
\&
\&  $x\->blog();              # logarithm of $x to base e (Euler\*(Aqs number)
\&  $x\->blog($base);         # logarithm of $x to base $base (f.i. 2)
\&  $x\->bexp();              # calculate e ** $x where e is Euler\*(Aqs number
\&
\&  $x\->round($A,$P,$mode);  # round to accuracy or precision using
\&                           # mode $mode
\&  $x\->bround($n);          # accuracy: preserve $n digits
\&  $x\->bfround($n);         # $n > 0: round $nth digits,
\&                           # $n < 0: round to the $nth digit after the
\&                           # dot, no\-op for BigInts
\&
\&  # The following do not modify their arguments in BigInt (are no\-ops),
\&  # but do so in BigFloat:
\&
\&  $x\->bfloor();            # return integer less or equal than $x
\&  $x\->bceil();             # return integer greater or equal than $x
\&
\&  # The following do not modify their arguments:
\&
\&  # greatest common divisor (no OO style)
\&  my $gcd = Math::BigInt::bgcd(@values);
\&  # lowest common multiple (no OO style)
\&  my $lcm = Math::BigInt::blcm(@values);
\&
\&  $x\->length();            # return number of digits in number
\&  ($xl,$f) = $x\->length(); # length of number and length of fraction
\&                           # part, latter is always 0 digits long
\&                           # for BigInts
\&
\&  $x\->exponent();         # return exponent as BigInt
\&  $x\->mantissa();         # return (signed) mantissa as BigInt
\&  $x\->parts();            # return (mantissa,exponent) as BigInt
\&  $x\->copy();             # make a true copy of $x (unlike $y = $x;)
\&  $x\->as_int();           # return as BigInt (in BigInt: same as copy())
\&  $x\->numify();           # return as scalar (might overflow!)
\&
\&  # conversion to string (do not modify their argument)
\&  $x\->bstr();         # normalized string (e.g. \*(Aq3\*(Aq)
\&  $x\->bsstr();        # norm. string in scientific notation (e.g. \*(Aq3E0\*(Aq)
\&  $x\->as_hex();       # as signed hexadecimal string with prefixed 0x
\&  $x\->as_bin();       # as signed binary string with prefixed 0b
\&  $x\->as_oct();       # as signed octal string with prefixed 0
\&
\&
\&  # precision and accuracy (see section about rounding for more)
\&  $x\->precision();       # return P of $x (or global, if P of $x undef)
\&  $x\->precision($n);     # set P of $x to $n
\&  $x\->accuracy();        # return A of $x (or global, if A of $x undef)
\&  $x\->accuracy($n);      # set A $x to $n
\&
\&  # Global methods
\&  Math::BigInt\->precision();   # get/set global P for all BigInt objects
\&  Math::BigInt\->accuracy();    # get/set global A for all BigInt objects
\&  Math::BigInt\->round_mode();  # get/set global round mode, one of
\&                               # \*(Aqeven\*(Aq, \*(Aqodd\*(Aq, \*(Aq+inf\*(Aq, \*(Aq\-inf\*(Aq, \*(Aqzero\*(Aq,
\&                               # \*(Aqtrunc\*(Aq or \*(Aqcommon\*(Aq
\&  Math::BigInt\->config();      # return hash containing configuration
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded if you
declare your big integers as
.PP
.Vb 1
\&  $i = new Math::BigInt \*(Aq123_456_789_123_456_789\*(Aq;
.Ve
.PP
Operations with overloaded operators preserve the arguments which is
exactly what you expect.
.IP "Input" 2
.IX Item "Input"
Input values to these routines may be any string, that looks like a number
and results in an integer, including hexadecimal and binary numbers.
.Sp
Scalars holding numbers may also be passed, but note that non-integer numbers
may already have lost precision due to the conversion to float. Quote
your input if you want BigInt to see all the digits:
.Sp
.Vb 2
\&        $x = Math::BigInt\->new(12345678890123456789);   # bad
\&        $x = Math::BigInt\->new(\*(Aq12345678901234567890\*(Aq); # good
.Ve
.Sp
You can include one underscore between any two digits.
.Sp
This means integer values like 1.01E2 or even 1000E\-2 are also accepted.
Non-integer values result in NaN.
.Sp
Hexadecimal (prefixed with \*(L"0x\*(R") and binary numbers (prefixed with \*(L"0b\*(R")
are accepted, too. Please note that octal numbers are not recognized
by \fInew()\fR, so the following will print \*(L"123\*(R":
.Sp
.Vb 1
\&        perl \-MMath::BigInt \-le \*(Aqprint Math::BigInt\->new("0123")\*(Aq
.Ve
.Sp
To convert an octal number, use \fIfrom_oct()\fR;
.Sp
.Vb 1
\&        perl \-MMath::BigInt \-le \*(Aqprint Math::BigInt\->from_oct("0123")\*(Aq
.Ve
.Sp
Currently, \fIMath::BigInt::new()\fR defaults to 0, while Math::BigInt::new('')
results in 'NaN'. This might change in the future, so use always the following
explicit forms to get a zero or NaN:
.Sp
.Vb 2
\&        $zero = Math::BigInt\->bzero();
\&        $nan = Math::BigInt\->bnan();
.Ve
.Sp
\&\f(CW\*(C`bnorm()\*(C'\fR on a BigInt object is now effectively a no-op, since the numbers 
are always stored in normalized form. If passed a string, creates a BigInt 
object from the input.
.IP "Output" 2
.IX Item "Output"
Output values are BigInt objects (normalized), except for the methods which
return a string (see \*(L"\s-1SYNOPSIS\s0\*(R").
.Sp
Some routines (\f(CW\*(C`is_odd()\*(C'\fR, \f(CW\*(C`is_even()\*(C'\fR, \f(CW\*(C`is_zero()\*(C'\fR, \f(CW\*(C`is_one()\*(C'\fR,
\&\f(CW\*(C`is_nan()\*(C'\fR, etc.) return true or false, while others (\f(CW\*(C`bcmp()\*(C'\fR, \f(CW\*(C`bacmp()\*(C'\fR)
return either undef (if NaN is involved), <0, 0 or >0 and are suited for sort.
.SH "METHODS"
.IX Header "METHODS"
Each of the methods below (except \fIconfig()\fR, \fIaccuracy()\fR and \fIprecision()\fR)
accepts three additional parameters. These arguments \f(CW$A\fR, \f(CW$P\fR and \f(CW$R\fR
are \f(CW\*(C`accuracy\*(C'\fR, \f(CW\*(C`precision\*(C'\fR and \f(CW\*(C`round_mode\*(C'\fR. Please see the section about
\&\*(L"\s-1ACCURACY\s0 and \s-1PRECISION\s0\*(R" for more information.
.SS "\fIconfig()\fP"
.IX Subsection "config()"
.Vb 1
\&        use Data::Dumper;
\&
\&        print Dumper ( Math::BigInt\->config() );
\&        print Math::BigInt\->config()\->{lib},"\en";
.Ve
.PP
Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.
.PP
.Vb 10
\&        key           Description
\&                      Example
\&        ============================================================
\&        lib           Name of the low\-level math library
\&                      Math::BigInt::Calc
\&        lib_version   Version of low\-level math library (see \*(Aqlib\*(Aq)
\&                      0.30
\&        class         The class name of config() you just called
\&                      Math::BigInt
\&        upgrade       To which class math operations might be upgraded
\&                      Math::BigFloat
\&        downgrade     To which class math operations might be downgraded
\&                      undef
\&        precision     Global precision
\&                      undef
\&        accuracy      Global accuracy
\&                      undef
\&        round_mode    Global round mode
\&                      even
\&        version       version number of the class you used
\&                      1.61
\&        div_scale     Fallback accuracy for div
\&                      40
\&        trap_nan      If true, traps creation of NaN via croak()
\&                      1
\&        trap_inf      If true, traps creation of +inf/\-inf via croak()
\&                      1
.Ve
.PP
The following values can be set by passing \f(CW\*(C`config()\*(C'\fR a reference to a hash:
.PP
.Vb 2
\&        trap_inf trap_nan
\&        upgrade downgrade precision accuracy round_mode div_scale
.Ve
.PP
Example:
.PP
.Vb 3
\&        $new_cfg = Math::BigInt\->config(
\&            { trap_inf => 1, precision => 5 }
\&        );
.Ve
.SS "\fIaccuracy()\fP"
.IX Subsection "accuracy()"
.Vb 3
\&    $x\->accuracy(5);         # local for $x
\&    CLASS\->accuracy(5);      # global for all members of CLASS
\&                             # Note: This also applies to new()!
\&
\&    $A = $x\->accuracy();     # read out accuracy that affects $x
\&    $A = CLASS\->accuracy();  # read out global accuracy
.Ve
.PP
Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to \fInew()\fR!
.PP
Warning! The accuracy \fIsticks\fR, e.g. once you created a number under the
influence of \f(CW\*(C`CLASS\->accuracy($A)\*(C'\fR, all results from math operations with
that number will also be rounded.
.PP
In most cases, you should probably round the results explicitly using one of
\&\*(L"\fIround()\fR\*(R", \*(L"\fIbround()\fR\*(R" or \*(L"\fIbfround()\fR\*(R" or by passing the desired accuracy
to the math operation as additional parameter:
.PP
.Vb 4
\&    my $x = Math::BigInt\->new(30000);
\&    my $y = Math::BigInt\->new(7);
\&    print scalar $x\->copy()\->bdiv($y, 2);               # print 4300
\&    print scalar $x\->copy()\->bdiv($y)\->bround(2);       # print 4300
.Ve
.PP
Please see the section about \*(L"\s-1ACCURACY\s0 and \s-1PRECISION\s0\*(R" for further details.
.PP
Value must be greater than zero. Pass an undef value to disable it:
.PP
.Vb 2
\&    $x\->accuracy(undef);
\&    Math::BigInt\->accuracy(undef);
.Ve
.PP
Returns the current accuracy. For \f(CW\*(C`$x\->accuracy()\*(C'\fR it will return either
the local accuracy, or if not defined, the global. This means the return value
represents the accuracy that will be in effect for \f(CW$x:\fR
.PP
.Vb 10
\&    $y = Math::BigInt\->new(1234567);       # unrounded
\&    print Math::BigInt\->accuracy(4),"\en";  # set 4, print 4
\&    $x = Math::BigInt\->new(123456);        # $x will be automatic\-
\&                                           # ally rounded!
\&    print "$x $y\en";                       # \*(Aq123500 1234567\*(Aq
\&    print $x\->accuracy(),"\en";             # will be 4
\&    print $y\->accuracy(),"\en";             # also 4, since global is 4
\&    print Math::BigInt\->accuracy(5),"\en";  # set to 5, print 5
\&    print $x\->accuracy(),"\en";             # still 4
\&    print $y\->accuracy(),"\en";             # 5, since global is 5
.Ve
.PP
Note: Works also for subclasses like Math::BigFloat. Each class has it's own
globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.
.SS "\fIprecision()\fP"
.IX Subsection "precision()"
.Vb 4
\&    $x\->precision(\-2);          # local for $x, round at the second
\&                                # digit right of the dot
\&    $x\->precision(2);           # ditto, round at the second digit left
\&                                # of the dot
\&
\&    CLASS\->precision(5);        # Global for all members of CLASS
\&                                # This also applies to new()!
\&    CLASS\->precision(\-5);       # ditto
\&
\&    $P = CLASS\->precision();    # read out global precision
\&    $P = $x\->precision();       # read out precision that affects $x
.Ve
.PP
Note: You probably want to use \*(L"\fIaccuracy()\fR\*(R" instead. With \*(L"\fIaccuracy()\fR\*(R" you
set the number of digits each result should have, with \*(L"\fIprecision()\fR\*(R" you
set the place where to round!
.PP
\&\f(CW\*(C`precision()\*(C'\fR sets or gets the global or local precision, aka at which digit
before or after the dot to round all results. A set global precision also
applies to all newly created numbers!
.PP
In Math::BigInt, passing a negative number precision has no effect since no
numbers have digits after the dot. In Math::BigFloat, it will round all
results to P digits after the dot.
.PP
Please see the section about \*(L"\s-1ACCURACY\s0 and \s-1PRECISION\s0\*(R" for further details.
.PP
Pass an undef value to disable it:
.PP
.Vb 2
\&    $x\->precision(undef);
\&    Math::BigInt\->precision(undef);
.Ve
.PP
Returns the current precision. For \f(CW\*(C`$x\->precision()\*(C'\fR it will return either
the local precision of \f(CW$x\fR, or if not defined, the global. This means the return
value represents the prevision that will be in effect for \f(CW$x:\fR
.PP
.Vb 4
\&    $y = Math::BigInt\->new(1234567);        # unrounded
\&    print Math::BigInt\->precision(4),"\en";  # set 4, print 4
\&    $x = Math::BigInt\->new(123456);      # will be automatically rounded
\&    print $x;                               # print "120000"!
.Ve
.PP
Note: Works also for subclasses like Math::BigFloat. Each class has its
own globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.
.SS "\fIbrsft()\fP"
.IX Subsection "brsft()"
.Vb 1
\&        $x\->brsft($y,$n);
.Ve
.PP
Shifts \f(CW$x\fR right by \f(CW$y\fR in base \f(CW$n\fR. Default is base 2, used are usually 10 and
2, but others work, too.
.PP
Right shifting usually amounts to dividing \f(CW$x\fR by \f(CW$n\fR ** \f(CW$y\fR and truncating the
result:
.PP
.Vb 4
\&        $x = Math::BigInt\->new(10);
\&        $x\->brsft(1);                   # same as $x >> 1: 5
\&        $x = Math::BigInt\->new(1234);
\&        $x\->brsft(2,10);                # result 12
.Ve
.PP
There is one exception, and that is base 2 with negative \f(CW$x:\fR
.PP
.Vb 2
\&        $x = Math::BigInt\->new(\-5);
\&        print $x\->brsft(1);
.Ve
.PP
This will print \-3, not \-2 (as it would if you divide \-5 by 2 and truncate the
result).
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&        $x = Math::BigInt\->new($str,$A,$P,$R);
.Ve
.PP
Creates a new BigInt object from a scalar or another BigInt object. The
input is accepted as decimal, hex (with leading '0x') or binary (with leading
\&'0b').
.PP
See \*(L"Input\*(R" for more info on accepted input formats.
.SS "\fIfrom_oct()\fP"
.IX Subsection "from_oct()"
.Vb 1
\&        $x = Math::BigInt\->from_oct("0775");    # input is octal
.Ve
.PP
Interpret the input as an octal string and return the corresponding value. A
\&\*(L"0\*(R" (zero) prefix is optional. A single underscore character may be placed
right after the prefix, if present, or between any two digits. If the input is
invalid, a NaN is returned.
.SS "\fIfrom_hex()\fP"
.IX Subsection "from_hex()"
.Vb 1
\&        $x = Math::BigInt\->from_hex("0xcafe");  # input is hexadecimal
.Ve
.PP
Interpret input as a hexadecimal string. A \*(L"0x\*(R" or \*(L"x\*(R" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.
.SS "\fIfrom_bin()\fP"
.IX Subsection "from_bin()"
.Vb 1
\&        $x = Math::BigInt\->from_bin("0b10011"); # input is binary
.Ve
.PP
Interpret the input as a binary string. A \*(L"0b\*(R" or \*(L"b\*(R" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.
.SS "\fIbnan()\fP"
.IX Subsection "bnan()"
.Vb 1
\&        $x = Math::BigInt\->bnan();
.Ve
.PP
Creates a new BigInt object representing NaN (Not A Number).
If used on an object, it will set it to NaN:
.PP
.Vb 1
\&        $x\->bnan();
.Ve
.SS "\fIbzero()\fP"
.IX Subsection "bzero()"
.Vb 1
\&        $x = Math::BigInt\->bzero();
.Ve
.PP
Creates a new BigInt object representing zero.
If used on an object, it will set it to zero:
.PP
.Vb 1
\&        $x\->bzero();
.Ve
.SS "\fIbinf()\fP"
.IX Subsection "binf()"
.Vb 1
\&        $x = Math::BigInt\->binf($sign);
.Ve
.PP
Creates a new BigInt object representing infinity. The optional argument is
either '\-' or '+', indicating whether you want infinity or minus infinity.
If used on an object, it will set it to infinity:
.PP
.Vb 2
\&        $x\->binf();
\&        $x\->binf(\*(Aq\-\*(Aq);
.Ve
.SS "\fIbone()\fP"
.IX Subsection "bone()"
.Vb 1
\&        $x = Math::BigInt\->binf($sign);
.Ve
.PP
Creates a new BigInt object representing one. The optional argument is
either '\-' or '+', indicating whether you want one or minus one.
If used on an object, it will set it to one:
.PP
.Vb 2
\&        $x\->bone();             # +1
\&        $x\->bone(\*(Aq\-\*(Aq);          # \-1
.Ve
.SS "\fIis_one()\fP/\fIis_zero()\fP/\fIis_nan()\fP/\fIis_inf()\fP"
.IX Subsection "is_one()/is_zero()/is_nan()/is_inf()"
.Vb 6
\&        $x\->is_zero();          # true if arg is +0
\&        $x\->is_nan();           # true if arg is NaN
\&        $x\->is_one();           # true if arg is +1
\&        $x\->is_one(\*(Aq\-\*(Aq);        # true if arg is \-1
\&        $x\->is_inf();           # true if +inf
\&        $x\->is_inf(\*(Aq\-\*(Aq);        # true if \-inf (sign is default \*(Aq+\*(Aq)
.Ve
.PP
These methods all test the BigInt for being one specific value and return
true or false depending on the input. These are faster than doing something
like:
.PP
.Vb 1
\&        if ($x == 0)
.Ve
.SS "\fIis_pos()\fP/\fIis_neg()\fP/\fIis_positive()\fP/\fIis_negative()\fP"
.IX Subsection "is_pos()/is_neg()/is_positive()/is_negative()"
.Vb 2
\&        $x\->is_pos();                   # true if > 0
\&        $x\->is_neg();                   # true if < 0
.Ve
.PP
The methods return true if the argument is positive or negative, respectively.
\&\f(CW\*(C`NaN\*(C'\fR is neither positive nor negative, while \f(CW\*(C`+inf\*(C'\fR counts as positive, and
\&\f(CW\*(C`\-inf\*(C'\fR is negative. A \f(CW\*(C`zero\*(C'\fR is neither positive nor negative.
.PP
These methods are only testing the sign, and not the value.
.PP
\&\f(CW\*(C`is_positive()\*(C'\fR and \f(CW\*(C`is_negative()\*(C'\fR are aliases to \f(CW\*(C`is_pos()\*(C'\fR and
\&\f(CW\*(C`is_neg()\*(C'\fR, respectively. \f(CW\*(C`is_positive()\*(C'\fR and \f(CW\*(C`is_negative()\*(C'\fR were
introduced in v1.36, while \f(CW\*(C`is_pos()\*(C'\fR and \f(CW\*(C`is_neg()\*(C'\fR were only introduced
in v1.68.
.SS "\fIis_odd()\fP/\fIis_even()\fP/\fIis_int()\fP"
.IX Subsection "is_odd()/is_even()/is_int()"
.Vb 3
\&        $x\->is_odd();                   # true if odd, false for even
\&        $x\->is_even();                  # true if even, false for odd
\&        $x\->is_int();                   # true if $x is an integer
.Ve
.PP
The return true when the argument satisfies the condition. \f(CW\*(C`NaN\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR,
\&\f(CW\*(C`\-inf\*(C'\fR are not integers and are neither odd nor even.
.PP
In BigInt, all numbers except \f(CW\*(C`NaN\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR and \f(CW\*(C`\-inf\*(C'\fR are integers.
.SS "\fIbcmp()\fP"
.IX Subsection "bcmp()"
.Vb 1
\&        $x\->bcmp($y);
.Ve
.PP
Compares \f(CW$x\fR with \f(CW$y\fR and takes the sign into account.
Returns \-1, 0, 1 or undef.
.SS "\fIbacmp()\fP"
.IX Subsection "bacmp()"
.Vb 1
\&        $x\->bacmp($y);
.Ve
.PP
Compares \f(CW$x\fR with \f(CW$y\fR while ignoring their sign. Returns \-1, 0, 1 or undef.
.SS "\fIsign()\fP"
.IX Subsection "sign()"
.Vb 1
\&        $x\->sign();
.Ve
.PP
Return the sign, of \f(CW$x\fR, meaning either \f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`\-inf\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR or NaN.
.PP
If you want \f(CW$x\fR to have a certain sign, use one of the following methods:
.PP
.Vb 5
\&        $x\->babs();             # \*(Aq+\*(Aq
\&        $x\->babs()\->bneg();     # \*(Aq\-\*(Aq
\&        $x\->bnan();             # \*(AqNaN\*(Aq
\&        $x\->binf();             # \*(Aq+inf\*(Aq
\&        $x\->binf(\*(Aq\-\*(Aq);          # \*(Aq\-inf\*(Aq
.Ve
.SS "\fIdigit()\fP"
.IX Subsection "digit()"
.Vb 1
\&        $x\->digit($n);       # return the nth digit, counting from right
.Ve
.PP
If \f(CW$n\fR is negative, returns the digit counting from left.
.SS "\fIbneg()\fP"
.IX Subsection "bneg()"
.Vb 1
\&        $x\->bneg();
.Ve
.PP
Negate the number, e.g. change the sign between '+' and '\-', or between '+inf'
and '\-inf', respectively. Does nothing for NaN or zero.
.SS "\fIbabs()\fP"
.IX Subsection "babs()"
.Vb 1
\&        $x\->babs();
.Ve
.PP
Set the number to its absolute value, e.g. change the sign from '\-' to '+'
and from '\-inf' to '+inf', respectively. Does nothing for NaN or positive
numbers.
.SS "\fIbsgn()\fP"
.IX Subsection "bsgn()"
.Vb 1
\&        $x\->bsgn();
.Ve
.PP
Signum function. Set the number to \-1, 0, or 1, depending on whether the
number is negative, zero, or positive, respectivly. Does not modify NaNs.
.SS "\fIbnorm()\fP"
.IX Subsection "bnorm()"
.Vb 1
\&        $x\->bnorm();                    # normalize (no\-op)
.Ve
.SS "\fIbnot()\fP"
.IX Subsection "bnot()"
.Vb 1
\&        $x\->bnot();
.Ve
.PP
Two's complement (bitwise not). This is equivalent to
.PP
.Vb 1
\&        $x\->binc()\->bneg();
.Ve
.PP
but faster.
.SS "\fIbinc()\fP"
.IX Subsection "binc()"
.Vb 1
\&        $x\->binc();             # increment x by 1
.Ve
.SS "\fIbdec()\fP"
.IX Subsection "bdec()"
.Vb 1
\&        $x\->bdec();             # decrement x by 1
.Ve
.SS "\fIbadd()\fP"
.IX Subsection "badd()"
.Vb 1
\&        $x\->badd($y);           # addition (add $y to $x)
.Ve
.SS "\fIbsub()\fP"
.IX Subsection "bsub()"
.Vb 1
\&        $x\->bsub($y);           # subtraction (subtract $y from $x)
.Ve
.SS "\fIbmul()\fP"
.IX Subsection "bmul()"
.Vb 1
\&        $x\->bmul($y);           # multiplication (multiply $x by $y)
.Ve
.SS "\fIbmuladd()\fP"
.IX Subsection "bmuladd()"
.Vb 1
\&        $x\->bmuladd($y,$z);
.Ve
.PP
Multiply \f(CW$x\fR by \f(CW$y\fR, and then add \f(CW$z\fR to the result,
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbdiv()\fP"
.IX Subsection "bdiv()"
.Vb 2
\&        $x\->bdiv($y);           # divide, set $x to quotient
\&                                # return (quo,rem) or quo if scalar
.Ve
.SS "\fIbmod()\fP"
.IX Subsection "bmod()"
.Vb 1
\&        $x\->bmod($y);           # modulus (x % y)
.Ve
.SS "\fIbmodinv()\fP"
.IX Subsection "bmodinv()"
.Vb 1
\&        $x\->bmodinv($mod);      # modular multiplicative inverse
.Ve
.PP
Returns the multiplicative inverse of \f(CW$x\fR modulo \f(CW$mod\fR. If
.PP
.Vb 1
\&        $y = $x \-> copy() \-> bmodinv($mod)
.Ve
.PP
then \f(CW$y\fR is the number closest to zero, and with the same sign as \f(CW$mod\fR,
satisfying
.PP
.Vb 1
\&        ($x * $y) % $mod = 1 % $mod
.Ve
.PP
If \f(CW$x\fR and \f(CW$y\fR are non-zero, they must be relative primes, i.e.,
\&\f(CW\*(C`bgcd($y, $mod)==1\*(C'\fR. '\f(CW\*(C`NaN\*(C'\fR' is returned when no modular multiplicative
inverse exists.
.SS "\fIbmodpow()\fP"
.IX Subsection "bmodpow()"
.Vb 2
\&        $num\->bmodpow($exp,$mod);       # modular exponentiation
\&                                        # ($num**$exp % $mod)
.Ve
.PP
Returns the value of \f(CW$num\fR taken to the power \f(CW$exp\fR in the modulus
\&\f(CW$mod\fR using binary exponentiation.  \f(CW\*(C`bmodpow\*(C'\fR is far superior to
writing
.PP
.Vb 1
\&        $num ** $exp % $mod
.Ve
.PP
because it is much faster \- it reduces internal variables into
the modulus whenever possible, so it operates on smaller numbers.
.PP
\&\f(CW\*(C`bmodpow\*(C'\fR also supports negative exponents.
.PP
.Vb 1
\&        bmodpow($num, \-1, $mod)
.Ve
.PP
is exactly equivalent to
.PP
.Vb 1
\&        bmodinv($num, $mod)
.Ve
.SS "\fIbpow()\fP"
.IX Subsection "bpow()"
.Vb 1
\&        $x\->bpow($y);                 # power of arguments (x ** y)
.Ve
.SS "\fIblog()\fP"
.IX Subsection "blog()"
.Vb 1
\&        $x\->blog($base, $accuracy);   # logarithm of x to the base $base
.Ve
.PP
If \f(CW$base\fR is not defined, Euler's number (e) is used:
.PP
.Vb 1
\&        print $x\->blog(undef, 100);   # log(x) to 100 digits
.Ve
.SS "\fIbexp()\fP"
.IX Subsection "bexp()"
.Vb 1
\&        $x\->bexp($accuracy);          # calculate e ** X
.Ve
.PP
Calculates the expression \f(CW\*(C`e ** $x\*(C'\fR where \f(CW\*(C`e\*(C'\fR is Euler's number.
.PP
This method was added in v1.82 of Math::BigInt (April 2007).
.PP
See also \*(L"\fIblog()\fR\*(R".
.SS "\fIbnok()\fP"
.IX Subsection "bnok()"
.Vb 1
\&        $x\->bnok($y);        # x over y (binomial coefficient n over k)
.Ve
.PP
Calculates the binomial coefficient n over k, also called the \*(L"choose\*(R"
function. The result is equivalent to:
.PP
.Vb 3
\&        ( n )      n!
\&        | \- |  = \-\-\-\-\-\-\-
\&        ( k )    k!(n\-k)!
.Ve
.PP
This method was added in v1.84 of Math::BigInt (April 2007).
.SS "\fIbpi()\fP"
.IX Subsection "bpi()"
.Vb 1
\&        print Math::BigInt\->bpi(100), "\en";             # 3
.Ve
.PP
Returns \s-1PI\s0 truncated to an integer, with the argument being ignored. This means
under BigInt this always returns \f(CW3\fR.
.PP
If upgrading is in effect, returns \s-1PI\s0, rounded to N digits with the
current rounding mode:
.PP
.Vb 4
\&        use Math::BigFloat;
\&        use Math::BigInt upgrade => Math::BigFloat;
\&        print Math::BigInt\->bpi(3), "\en";               # 3.14
\&        print Math::BigInt\->bpi(100), "\en";             # 3.1415....
.Ve
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbcos()\fP"
.IX Subsection "bcos()"
.Vb 2
\&        my $x = Math::BigInt\->new(1);
\&        print $x\->bcos(100), "\en";
.Ve
.PP
Calculate the cosinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbsin()\fP"
.IX Subsection "bsin()"
.Vb 2
\&        my $x = Math::BigInt\->new(1);
\&        print $x\->bsin(100), "\en";
.Ve
.PP
Calculate the sinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan2()\fP"
.IX Subsection "batan2()"
.Vb 3
\&        my $x = Math::BigInt\->new(1);
\&        my $y = Math::BigInt\->new(1);
\&        print $y\->batan2($x), "\en";
.Ve
.PP
Calculate the arcus tangens of \f(CW$y\fR divided by \f(CW$x\fR, modifying \f(CW$y\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan()\fP"
.IX Subsection "batan()"
.Vb 2
\&        my $x = Math::BigFloat\->new(0.5);
\&        print $x\->batan(100), "\en";
.Ve
.PP
Calculate the arcus tangens of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIblsft()\fP"
.IX Subsection "blsft()"
.Vb 2
\&        $x\->blsft($y);          # left shift in base 2
\&        $x\->blsft($y,$n);       # left shift, in base $n (like 10)
.Ve
.SS "\fIbrsft()\fP"
.IX Subsection "brsft()"
.Vb 2
\&        $x\->brsft($y);          # right shift in base 2
\&        $x\->brsft($y,$n);       # right shift, in base $n (like 10)
.Ve
.SS "\fIband()\fP"
.IX Subsection "band()"
.Vb 1
\&        $x\->band($y);                   # bitwise and
.Ve
.SS "\fIbior()\fP"
.IX Subsection "bior()"
.Vb 1
\&        $x\->bior($y);                   # bitwise inclusive or
.Ve
.SS "\fIbxor()\fP"
.IX Subsection "bxor()"
.Vb 1
\&        $x\->bxor($y);                   # bitwise exclusive or
.Ve
.SS "\fIbnot()\fP"
.IX Subsection "bnot()"
.Vb 1
\&        $x\->bnot();                     # bitwise not (two\*(Aqs complement)
.Ve
.SS "\fIbsqrt()\fP"
.IX Subsection "bsqrt()"
.Vb 1
\&        $x\->bsqrt();                    # calculate square\-root
.Ve
.SS "\fIbroot()\fP"
.IX Subsection "broot()"
.Vb 1
\&        $x\->broot($N);
.Ve
.PP
Calculates the N'th root of \f(CW$x\fR.
.SS "\fIbfac()\fP"
.IX Subsection "bfac()"
.Vb 1
\&        $x\->bfac();                     # factorial of $x (1*2*3*4*..$x)
.Ve
.SS "\fIround()\fP"
.IX Subsection "round()"
.Vb 1
\&        $x\->round($A,$P,$round_mode);
.Ve
.PP
Round \f(CW$x\fR to accuracy \f(CW$A\fR or precision \f(CW$P\fR using the round mode
\&\f(CW$round_mode\fR.
.SS "\fIbround()\fP"
.IX Subsection "bround()"
.Vb 1
\&        $x\->bround($N);               # accuracy: preserve $N digits
.Ve
.SS "\fIbfround()\fP"
.IX Subsection "bfround()"
.Vb 1
\&        $x\->bfround($N);
.Ve
.PP
If N is > 0, rounds to the Nth digit from the left. If N < 0, rounds to
the Nth digit after the dot. Since BigInts are integers, the case N < 0
is a no-op for them.
.PP
Examples:
.PP
.Vb 6
\&        Input           N               Result
\&        ===================================================
\&        123456.123456   3               123500
\&        123456.123456   2               123450
\&        123456.123456   \-2              123456.12
\&        123456.123456   \-3              123456.123
.Ve
.SS "\fIbfloor()\fP"
.IX Subsection "bfloor()"
.Vb 1
\&        $x\->bfloor();
.Ve
.PP
Set \f(CW$x\fR to the integer less or equal than \f(CW$x\fR. This is a no-op in BigInt, but
does change \f(CW$x\fR in BigFloat.
.SS "\fIbceil()\fP"
.IX Subsection "bceil()"
.Vb 1
\&        $x\->bceil();
.Ve
.PP
Set \f(CW$x\fR to the integer greater or equal than \f(CW$x\fR. This is a no-op in BigInt, but
does change \f(CW$x\fR in BigFloat.
.SS "\fIbgcd()\fP"
.IX Subsection "bgcd()"
.Vb 1
\&        bgcd(@values);          # greatest common divisor (no OO style)
.Ve
.SS "\fIblcm()\fP"
.IX Subsection "blcm()"
.Vb 1
\&        blcm(@values);          # lowest common multiple (no OO style)
.Ve
.PP
head2 \fIlength()\fR
.PP
.Vb 2
\&        $x\->length();
\&        ($xl,$fl) = $x\->length();
.Ve
.PP
Returns the number of digits in the decimal representation of the number.
In list context, returns the length of the integer and fraction part. For
BigInt's, the length of the fraction part will always be 0.
.SS "\fIexponent()\fP"
.IX Subsection "exponent()"
.Vb 1
\&        $x\->exponent();
.Ve
.PP
Return the exponent of \f(CW$x\fR as BigInt.
.SS "\fImantissa()\fP"
.IX Subsection "mantissa()"
.Vb 1
\&        $x\->mantissa();
.Ve
.PP
Return the signed mantissa of \f(CW$x\fR as BigInt.
.SS "\fIparts()\fP"
.IX Subsection "parts()"
.Vb 1
\&        $x\->parts();    # return (mantissa,exponent) as BigInt
.Ve
.SS "\fIcopy()\fP"
.IX Subsection "copy()"
.Vb 1
\&        $x\->copy();     # make a true copy of $x (unlike $y = $x;)
.Ve
.SS "\fIas_int()\fP/\fIas_number()\fP"
.IX Subsection "as_int()/as_number()"
.Vb 1
\&        $x\->as_int();
.Ve
.PP
Returns \f(CW$x\fR as a BigInt (truncated towards zero). In BigInt this is the same as
\&\f(CW\*(C`copy()\*(C'\fR.
.PP
\&\f(CW\*(C`as_number()\*(C'\fR is an alias to this method. \f(CW\*(C`as_number\*(C'\fR was introduced in
v1.22, while \f(CW\*(C`as_int()\*(C'\fR was only introduced in v1.68.
.SS "\fIbstr()\fP"
.IX Subsection "bstr()"
.Vb 1
\&        $x\->bstr();
.Ve
.PP
Returns a normalized string representation of \f(CW$x\fR.
.SS "\fIbsstr()\fP"
.IX Subsection "bsstr()"
.Vb 1
\&        $x\->bsstr();    # normalized string in scientific notation
.Ve
.SS "\fIas_hex()\fP"
.IX Subsection "as_hex()"
.Vb 1
\&        $x\->as_hex();   # as signed hexadecimal string with prefixed 0x
.Ve
.SS "\fIas_bin()\fP"
.IX Subsection "as_bin()"
.Vb 1
\&        $x\->as_bin();   # as signed binary string with prefixed 0b
.Ve
.SS "\fIas_oct()\fP"
.IX Subsection "as_oct()"
.Vb 1
\&        $x\->as_oct();   # as signed octal string with prefixed 0
.Ve
.SS "\fInumify()\fP"
.IX Subsection "numify()"
.Vb 1
\&        print $x\->numify();
.Ve
.PP
This returns a normal Perl scalar from \f(CW$x\fR. It is used automatically
whenever a scalar is needed, for instance in array index operations.
.PP
This loses precision, to avoid this use \fIas_int()\fR instead.
.SS "\fImodify()\fP"
.IX Subsection "modify()"
.Vb 1
\&        $x\->modify(\*(Aqbpowd\*(Aq);
.Ve
.PP
This method returns 0 if the object can be modified with the given
operation, or 1 if not.
.PP
This is used for instance by Math::BigInt::Constant.
.SS "\fIupgrade()\fP/\fIdowngrade()\fP"
.IX Subsection "upgrade()/downgrade()"
Set/get the class for downgrade/upgrade operations. Thuis is used
for instance by bignum. The defaults are '', thus the following
operation will create a BigInt, not a BigFloat:
.PP
.Vb 2
\&        my $i = Math::BigInt\->new(123);
\&        my $f = Math::BigFloat\->new(\*(Aq123.1\*(Aq);
\&
\&        print $i + $f,"\en";                     # print 246
.Ve
.SS "\fIdiv_scale()\fP"
.IX Subsection "div_scale()"
Set/get the number of digits for the default precision in divide
operations.
.SS "\fIround_mode()\fP"
.IX Subsection "round_mode()"
Set/get the current round mode.
.SH "ACCURACY and PRECISION"
.IX Header "ACCURACY and PRECISION"
Since version v1.33, Math::BigInt and Math::BigFloat have full support for
accuracy and precision based rounding, both automatically after every
operation, as well as manually.
.PP
This section describes the accuracy/precision handling in Math::Big* as it
used to be and as it is now, complete with an explanation of all terms and
abbreviations.
.PP
Not yet implemented things (but with correct description) are marked with '!',
things that need to be answered are marked with '?'.
.PP
In the next paragraph follows a short description of terms used here (because
these may differ from terms used by others people or documentation).
.PP
During the rest of this document, the shortcuts A (for accuracy), P (for
precision), F (fallback) and R (rounding mode) will be used.
.SS "Precision P"
.IX Subsection "Precision P"
A fixed number of digits before (positive) or after (negative)
the decimal point. For example, 123.45 has a precision of \-2. 0 means an
integer like 123 (or 120). A precision of 2 means two digits to the left
of the decimal point are zero, so 123 with P = 1 becomes 120. Note that
numbers with zeros before the decimal point may have different precisions,
because 1200 can have p = 0, 1 or 2 (depending on what the initial value
was). It could also have p < 0, when the digits after the decimal point
are zero.
.PP
The string output (of floating point numbers) will be padded with zeros:
.PP
.Vb 9
\&        Initial value   P       A       Result          String
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        1234.01         \-3              1000            1000
\&        1234            \-2              1200            1200
\&        1234.5          \-1              1230            1230
\&        1234.001        1               1234            1234.0
\&        1234.01         0               1234            1234
\&        1234.01         2               1234.01         1234.01
\&        1234.01         5               1234.01         1234.01000
.Ve
.PP
For BigInts, no padding occurs.
.SS "Accuracy A"
.IX Subsection "Accuracy A"
Number of significant digits. Leading zeros are not counted. A
number may have an accuracy greater than the non-zero digits
when there are zeros in it or trailing zeros. For example, 123.456 has
A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.
.PP
The string output (of floating point numbers) will be padded with zeros:
.PP
.Vb 5
\&        Initial value   P       A       Result          String
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        1234.01                 3       1230            1230
\&        1234.01                 6       1234.01         1234.01
\&        1234.1                  8       1234.1          1234.1000
.Ve
.PP
For BigInts, no padding occurs.
.SS "Fallback F"
.IX Subsection "Fallback F"
When both A and P are undefined, this is used as a fallback accuracy when
dividing numbers.
.SS "Rounding mode R"
.IX Subsection "Rounding mode R"
When rounding a number, different 'styles' or 'kinds'
of rounding are possible. (Note that random rounding, as in
Math::Round, is not implemented.)
.IP "'trunc'" 2
.IX Item "'trunc'"
truncation invariably removes all digits following the
rounding place, replacing them with zeros. Thus, 987.65 rounded
to tens (P=1) becomes 980, and rounded to the fourth sigdig
becomes 987.6 (A=4). 123.456 rounded to the second place after the
decimal point (P=\-2) becomes 123.46.
.Sp
All other implemented styles of rounding attempt to round to the
\&\*(L"nearest digit.\*(R" If the digit D immediately to the right of the
rounding place (skipping the decimal point) is greater than 5, the
number is incremented at the rounding place (possibly causing a
cascade of incrementation): e.g. when rounding to units, 0.9 rounds
to 1, and \-19.9 rounds to \-20. If D < 5, the number is similarly
truncated at the rounding place: e.g. when rounding to units, 0.4
rounds to 0, and \-19.4 rounds to \-19.
.Sp
However the results of other styles of rounding differ if the
digit immediately to the right of the rounding place (skipping the
decimal point) is 5 and if there are no digits, or no digits other
than 0, after that 5. In such cases:
.IP "'even'" 2
.IX Item "'even'"
rounds the digit at the rounding place to 0, 2, 4, 6, or 8
if it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.4, \-0.55 becomes \-0.6, but 0.4501 becomes 0.5.
.IP "'odd'" 2
.IX Item "'odd'"
rounds the digit at the rounding place to 1, 3, 5, 7, or 9 if
it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.5, \-0.55 becomes \-0.5, but 0.5501 becomes 0.6.
.IP "'+inf'" 2
.IX Item "'+inf'"
round to plus infinity, i.e. always round up. E.g., when
rounding to the first sigdig, 0.45 becomes 0.5, \-0.55 becomes \-0.5,
and 0.4501 also becomes 0.5.
.IP "'\-inf'" 2
.IX Item "'-inf'"
round to minus infinity, i.e. always round down. E.g., when
rounding to the first sigdig, 0.45 becomes 0.4, \-0.55 becomes \-0.6,
but 0.4501 becomes 0.5.
.IP "'zero'" 2
.IX Item "'zero'"
round to zero, i.e. positive numbers down, negative ones up.
E.g., when rounding to the first sigdig, 0.45 becomes 0.4, \-0.55
becomes \-0.5, but 0.4501 becomes 0.5.
.IP "'common'" 2
.IX Item "'common'"
round up if the digit immediately to the right of the rounding place
is 5 or greater, otherwise round down. E.g., 0.15 becomes 0.2 and
0.149 becomes 0.1.
.PP
The handling of A & P in \s-1MBI/MBF\s0 (the old core code shipped with Perl
versions <= 5.7.2) is like this:
.IP "Precision" 2
.IX Item "Precision"
.Vb 3
\&  * ffround($p) is able to round to $p number of digits after the decimal
\&    point
\&  * otherwise P is unused
.Ve
.IP "Accuracy (significant digits)" 2
.IX Item "Accuracy (significant digits)"
.Vb 10
\&  * fround($a) rounds to $a significant digits
\&  * only fdiv() and fsqrt() take A as (optional) parameter
\&    + other operations simply create the same number (fneg etc), or more (fmul)
\&      of digits
\&    + rounding/truncating is only done when explicitly calling one of fround
\&      or ffround, and never for BigInt (not implemented)
\&  * fsqrt() simply hands its accuracy argument over to fdiv.
\&  * the documentation and the comment in the code indicate two different ways
\&    on how fdiv() determines the maximum number of digits it should calculate,
\&    and the actual code does yet another thing
\&    POD:
\&      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
\&    Comment:
\&      result has at most max(scale, length(dividend), length(divisor)) digits
\&    Actual code:
\&      scale = max(scale, length(dividend)\-1,length(divisor)\-1);
\&      scale += length(divisor) \- length(dividend);
\&    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10+9\-3).
\&    Actually, the \*(Aqdifference\*(Aq added to the scale is calculated from the
\&    number of "significant digits" in dividend and divisor, which is derived
\&    by looking at the length of the mantissa. Which is wrong, since it includes
\&    the + sign (oops) and actually gets 2 for \*(Aq+100\*(Aq and 4 for \*(Aq+101\*(Aq. Oops
\&    again. Thus 124/3 with div_scale=1 will get you \*(Aq41.3\*(Aq based on the strange
\&    assumption that 124 has 3 significant digits, while 120/7 will get you
\&    \*(Aq17\*(Aq, not \*(Aq17.1\*(Aq since 120 is thought to have 2 significant digits.
\&    The rounding after the division then uses the remainder and $y to determine
\&    whether it must round up or down.
\& ?  I have no idea which is the right way. That\*(Aqs why I used a slightly more
\& ?  simple scheme and tweaked the few failing testcases to match it.
.Ve
.PP
This is how it works now:
.IP "Setting/Accessing" 2
.IX Item "Setting/Accessing"
.Vb 10
\&  * You can set the A global via Math::BigInt\->accuracy() or
\&    Math::BigFloat\->accuracy() or whatever class you are using.
\&  * You can also set P globally by using Math::SomeClass\->precision()
\&    likewise.
\&  * Globals are classwide, and not inherited by subclasses.
\&  * to undefine A, use Math::SomeCLass\->accuracy(undef);
\&  * to undefine P, use Math::SomeClass\->precision(undef);
\&  * Setting Math::SomeClass\->accuracy() clears automatically
\&    Math::SomeClass\->precision(), and vice versa.
\&  * To be valid, A must be > 0, P can have any value.
\&  * If P is negative, this means round to the P\*(Aqth place to the right of the
\&    decimal point; positive values mean to the left of the decimal point.
\&    P of 0 means round to integer.
\&  * to find out the current global A, use Math::SomeClass\->accuracy()
\&  * to find out the current global P, use Math::SomeClass\->precision()
\&  * use $x\->accuracy() respective $x\->precision() for the local
\&    setting of $x.
\&  * Please note that $x\->accuracy() respective $x\->precision()
\&    return eventually defined global A or P, when $x\*(Aqs A or P is not
\&    set.
.Ve
.IP "Creating numbers" 2
.IX Item "Creating numbers"
.Vb 12
\&  * When you create a number, you can give the desired A or P via:
\&    $x = Math::BigInt\->new($number,$A,$P);
\&  * Only one of A or P can be defined, otherwise the result is NaN
\&  * If no A or P is give ($x = Math::BigInt\->new($number) form), then the
\&    globals (if set) will be used. Thus changing the global defaults later on
\&    will not change the A or P of previously created numbers (i.e., A and P of
\&    $x will be what was in effect when $x was created)
\&  * If given undef for A and P, NO rounding will occur, and the globals will
\&    NOT be used. This is used by subclasses to create numbers without
\&    suffering rounding in the parent. Thus a subclass is able to have its own
\&    globals enforced upon creation of a number by using
\&    $x = Math::BigInt\->new($number,undef,undef):
\&
\&        use Math::BigInt::SomeSubclass;
\&        use Math::BigInt;
\&
\&        Math::BigInt\->accuracy(2);
\&        Math::BigInt::SomeSubClass\->accuracy(3);
\&        $x = Math::BigInt::SomeSubClass\->new(1234);
\&
\&    $x is now 1230, and not 1200. A subclass might choose to implement
\&    this otherwise, e.g. falling back to the parent\*(Aqs A and P.
.Ve
.IP "Usage" 2
.IX Item "Usage"
.Vb 7
\&  * If A or P are enabled/defined, they are used to round the result of each
\&    operation according to the rules below
\&  * Negative P is ignored in Math::BigInt, since BigInts never have digits
\&    after the decimal point
\&  * Math::BigFloat uses Math::BigInt internally, but setting A or P inside
\&    Math::BigInt as globals does not tamper with the parts of a BigFloat.
\&    A flag is used to mark all Math::BigFloat numbers as \*(Aqnever round\*(Aq.
.Ve
.IP "Precedence" 2
.IX Item "Precedence"
.Vb 10
\&  * It only makes sense that a number has only one of A or P at a time.
\&    If you set either A or P on one object, or globally, the other one will
\&    be automatically cleared.
\&  * If two objects are involved in an operation, and one of them has A in
\&    effect, and the other P, this results in an error (NaN).
\&  * A takes precedence over P (Hint: A comes before P).
\&    If neither of them is defined, nothing is used, i.e. the result will have
\&    as many digits as it can (with an exception for fdiv/fsqrt) and will not
\&    be rounded.
\&  * There is another setting for fdiv() (and thus for fsqrt()). If neither of
\&    A or P is defined, fdiv() will use a fallback (F) of $div_scale digits.
\&    If either the dividend\*(Aqs or the divisor\*(Aqs mantissa has more digits than
\&    the value of F, the higher value will be used instead of F.
\&    This is to limit the digits (A) of the result (just consider what would
\&    happen with unlimited A and P in the case of 1/3 :\-)
\&  * fdiv will calculate (at least) 4 more digits than required (determined by
\&    A, P or F), and, if F is not used, round the result
\&    (this will still fail in the case of a result like 0.12345000000001 with A
\&    or P of 5, but this can not be helped \- or can it?)
\&  * Thus you can have the math done by on Math::Big* class in two modi:
\&    + never round (this is the default):
\&      This is done by setting A and P to undef. No math operation
\&      will round the result, with fdiv() and fsqrt() as exceptions to guard
\&      against overflows. You must explicitly call bround(), bfround() or
\&      round() (the latter with parameters).
\&      Note: Once you have rounded a number, the settings will \*(Aqstick\*(Aq on it
\&      and \*(Aqinfect\*(Aq all other numbers engaged in math operations with it, since
\&      local settings have the highest precedence. So, to get SaferRound[tm],
\&      use a copy() before rounding like this:
\&
\&        $x = Math::BigFloat\->new(12.34);
\&        $y = Math::BigFloat\->new(98.76);
\&        $z = $x * $y;                           # 1218.6984
\&        print $x\->copy()\->fround(3);            # 12.3 (but A is now 3!)
\&        $z = $x * $y;                           # still 1218.6984, without
\&                                                # copy would have been 1210!
\&
\&    + round after each op:
\&      After each single operation (except for testing like is_zero()), the
\&      method round() is called and the result is rounded appropriately. By
\&      setting proper values for A and P, you can have all\-the\-same\-A or
\&      all\-the\-same\-P modes. For example, Math::Currency might set A to undef,
\&      and P to \-2, globally.
\&
\& ?Maybe an extra option that forbids local A & P settings would be in order,
\& ?so that intermediate rounding does not \*(Aqpoison\*(Aq further math?
.Ve
.IP "Overriding globals" 2
.IX Item "Overriding globals"
.Vb 10
\&  * you will be able to give A, P and R as an argument to all the calculation
\&    routines; the second parameter is A, the third one is P, and the fourth is
\&    R (shift right by one for binary operations like badd). P is used only if
\&    the first parameter (A) is undefined. These three parameters override the
\&    globals in the order detailed as follows, i.e. the first defined value
\&    wins:
\&    (local: per object, global: global default, parameter: argument to sub)
\&      + parameter A
\&      + parameter P
\&      + local A (if defined on both of the operands: smaller one is taken)
\&      + local P (if defined on both of the operands: bigger one is taken)
\&      + global A
\&      + global P
\&      + global F
\&  * fsqrt() will hand its arguments to fdiv(), as it used to, only now for two
\&    arguments (A and P) instead of one
.Ve
.IP "Local settings" 2
.IX Item "Local settings"
.Vb 5
\&  * You can set A or P locally by using $x\->accuracy() or
\&    $x\->precision()
\&    and thus force different A and P for different objects/numbers.
\&  * Setting A or P this way immediately rounds $x to the new value.
\&  * $x\->accuracy() clears $x\->precision(), and vice versa.
.Ve
.IP "Rounding" 2
.IX Item "Rounding"
.Vb 10
\&  * the rounding routines will use the respective global or local settings.
\&    fround()/bround() is for accuracy rounding, while ffround()/bfround()
\&    is for precision
\&  * the two rounding functions take as the second parameter one of the
\&    following rounding modes (R):
\&    \*(Aqeven\*(Aq, \*(Aqodd\*(Aq, \*(Aq+inf\*(Aq, \*(Aq\-inf\*(Aq, \*(Aqzero\*(Aq, \*(Aqtrunc\*(Aq, \*(Aqcommon\*(Aq
\&  * you can set/get the global R by using Math::SomeClass\->round_mode()
\&    or by setting $Math::SomeClass::round_mode
\&  * after each operation, $result\->round() is called, and the result may
\&    eventually be rounded (that is, if A or P were set either locally,
\&    globally or as parameter to the operation)
\&  * to manually round a number, call $x\->round($A,$P,$round_mode);
\&    this will round the number by using the appropriate rounding function
\&    and then normalize it.
\&  * rounding modifies the local settings of the number:
\&
\&        $x = Math::BigFloat\->new(123.456);
\&        $x\->accuracy(5);
\&        $x\->bround(4);
\&
\&    Here 4 takes precedence over 5, so 123.5 is the result and $x\->accuracy()
\&    will be 4 from now on.
.Ve
.IP "Default values" 2
.IX Item "Default values"
.Vb 4
\&  * R: \*(Aqeven\*(Aq
\&  * F: 40
\&  * A: undef
\&  * P: undef
.Ve
.IP "Remarks" 2
.IX Item "Remarks"
.Vb 5
\&  * The defaults are set up so that the new code gives the same results as
\&    the old code (except in a few cases on fdiv):
\&    + Both A and P are undefined and thus will not be used for rounding
\&      after each operation.
\&    + round() is thus a no\-op, unless given extra parameters A and P
.Ve
.SH "Infinity and Not a Number"
.IX Header "Infinity and Not a Number"
While BigInt has extensive handling of inf and NaN, certain quirks remain.
.IP "\fIoct()\fR/\fIhex()\fR" 2
.IX Item "oct()/hex()"
These perl routines currently (as of Perl v.5.8.6) cannot handle passed
inf.
.Sp
.Vb 9
\&        te@linux:~> perl \-wle \*(Aqprint 2 ** 3333\*(Aq
\&        inf
\&        te@linux:~> perl \-wle \*(Aqprint 2 ** 3333 == 2 ** 3333\*(Aq
\&        1
\&        te@linux:~> perl \-wle \*(Aqprint oct(2 ** 3333)\*(Aq
\&        0
\&        te@linux:~> perl \-wle \*(Aqprint hex(2 ** 3333)\*(Aq
\&        Illegal hexadecimal digit \*(Aqi\*(Aq ignored at \-e line 1.
\&        0
.Ve
.Sp
The same problems occur if you pass them Math::BigInt\->\fIbinf()\fR objects. Since
overloading these routines is not possible, this cannot be fixed from BigInt.
.IP "==, !=, <, >, <=, >= with NaNs" 2
.IX Item "==, !=, <, >, <=, >= with NaNs"
BigInt's \fIbcmp()\fR routine currently returns undef to signal that a NaN was
involved in a comparison. However, the overload code turns that into
either 1 or '' and thus operations like \f(CW\*(C`NaN != NaN\*(C'\fR might return
wrong values.
.IP "log(\-inf)" 2
.IX Item "log(-inf)"
\&\f(CW\*(C`log(\-inf)\*(C'\fR is highly weird. Since log(\-x)=pi*i+log(x), then
log(\-inf)=pi*i+inf. However, since the imaginary part is finite, the real
infinity \*(L"overshadows\*(R" it, so the number might as well just be infinity.
However, the result is a complex number, and since BigInt/BigFloat can only
have real numbers as results, the result is NaN.
.IP "\fIexp()\fR, \fIcos()\fR, \fIsin()\fR, \fIatan2()\fR" 2
.IX Item "exp(), cos(), sin(), atan2()"
These all might have problems handling infinity right.
.SH "INTERNALS"
.IX Header "INTERNALS"
The actual numbers are stored as unsigned big integers (with separate sign).
.PP
You should neither care about nor depend on the internal representation; it
might change without notice. Use \fB\s-1ONLY\s0\fR method calls like \f(CW\*(C`$x\->sign();\*(C'\fR
instead relying on the internal representation.
.SS "\s-1MATH\s0 \s-1LIBRARY\s0"
.IX Subsection "MATH LIBRARY"
Math with the numbers is done (by default) by a module called
\&\f(CW\*(C`Math::BigInt::Calc\*(C'\fR. This is equivalent to saying:
.PP
.Vb 1
\&        use Math::BigInt try => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this backend library by using:
.PP
.Vb 1
\&        use Math::BigInt try => \*(AqGMP\*(Aq;
.Ve
.PP
\&\fBNote\fR: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.
.PP
If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:
.PP
.Vb 1
\&        use Math::BigInt only => \*(AqGMP,Pari\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use Math::BigInt try => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
The library that is loaded last will be used. Note that this can be
overwritten at any time by loading a different library, and numbers
constructed with different libraries cannot be used in math operations
together.
.PP
\fIWhat library to use?\fR
.IX Subsection "What library to use?"
.PP
\&\fBNote\fR: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.
.PP
Math::BigInt::GMP and Math::BigInt::Pari are in cases involving big
numbers much faster than Calc, however it is slower when dealing with very
small numbers (less than about 20 digits) and when converting very large
numbers to decimal (for instance for printing, rounding, calculating their
length in decimal etc).
.PP
So please select carefully what library you want to use.
.PP
Different low-level libraries use different formats to store the numbers.
However, you should \fB\s-1NOT\s0\fR depend on the number having a specific format
internally.
.PP
See the respective math library module documentation for further details.
.SS "\s-1SIGN\s0"
.IX Subsection "SIGN"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SS "\fImantissa()\fP, \fIexponent()\fP and \fIparts()\fP"
.IX Subsection "mantissa(), exponent() and parts()"
\&\f(CW\*(C`mantissa()\*(C'\fR and \f(CW\*(C`exponent()\*(C'\fR return the said parts of the BigInt such
that:
.PP
.Vb 4
\&        $m = $x\->mantissa();
\&        $e = $x\->exponent();
\&        $y = $m * ( 10 ** $e );
\&        print "ok\en" if $x == $y;
.Ve
.PP
\&\f(CW\*(C`($m,$e) = $x\->parts()\*(C'\fR is just a shortcut that gives you both of them
in one go. Both the returned mantissa and exponent have a sign.
.PP
Currently, for BigInts \f(CW$e\fR is always 0, except +inf and \-inf, where it is
\&\f(CW\*(C`+inf\*(C'\fR; and for NaN, where it is \f(CW\*(C`NaN\*(C'\fR; and for \f(CW\*(C`$x == 0\*(C'\fR, where it is \f(CW1\fR
(to be compatible with Math::BigFloat's internal representation of a zero as
\&\f(CW0E1\fR).
.PP
\&\f(CW$m\fR is currently just a copy of the original number. The relation between
\&\f(CW$e\fR and \f(CW$m\fR will stay always the same, though their real values might
change.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&  use Math::BigInt;
\&
\&  sub bint { Math::BigInt\->new(shift); }
\&
\&  $x = Math::BigInt\->bstr("1234")       # string "1234"
\&  $x = "$x";                            # same as bstr()
\&  $x = Math::BigInt\->bneg("1234");      # BigInt "\-1234"
\&  $x = Math::BigInt\->babs("\-12345");    # BigInt "12345"
\&  $x = Math::BigInt\->bnorm("\-0.00");    # BigInt "0"
\&  $x = bint(1) + bint(2);               # BigInt "3"
\&  $x = bint(1) + "2";                   # ditto (auto\-BigIntify of "2")
\&  $x = bint(1);                         # BigInt "1"
\&  $x = $x + 5 / 2;                      # BigInt "3"
\&  $x = $x ** 3;                         # BigInt "27"
\&  $x *= 2;                              # BigInt "54"
\&  $x = Math::BigInt\->new(0);            # BigInt "0"
\&  $x\-\-;                                 # BigInt "\-1"
\&  $x = Math::BigInt\->badd(4,5)          # BigInt "9"
\&  print $x\->bsstr();                    # 9e+0
.Ve
.PP
Examples for rounding:
.PP
.Vb 2
\&  use Math::BigFloat;
\&  use Test;
\&
\&  $x = Math::BigFloat\->new(123.4567);
\&  $y = Math::BigFloat\->new(123.456789);
\&  Math::BigFloat\->accuracy(4);          # no more A than 4
\&
\&  ok ($x\->copy()\->fround(),123.4);      # even rounding
\&  print $x\->copy()\->fround(),"\en";      # 123.4
\&  Math::BigFloat\->round_mode(\*(Aqodd\*(Aq);    # round to odd
\&  print $x\->copy()\->fround(),"\en";      # 123.5
\&  Math::BigFloat\->accuracy(5);          # no more A than 5
\&  Math::BigFloat\->round_mode(\*(Aqodd\*(Aq);    # round to odd
\&  print $x\->copy()\->fround(),"\en";      # 123.46
\&  $y = $x\->copy()\->fround(4),"\en";      # A = 4: 123.4
\&  print "$y, ",$y\->accuracy(),"\en";     # 123.4, 4
\&
\&  Math::BigFloat\->accuracy(undef);      # A not important now
\&  Math::BigFloat\->precision(2);         # P important
\&  print $x\->copy()\->bnorm(),"\en";       # 123.46
\&  print $x\->copy()\->fround(),"\en";      # 123.46
.Ve
.PP
Examples for converting:
.PP
.Vb 2
\&  my $x = Math::BigInt\->new(\*(Aq0b1\*(Aq.\*(Aq01\*(Aq x 123);
\&  print "bin: ",$x\->as_bin()," hex:",$x\->as_hex()," dec: ",$x,"\en";
.Ve
.SH "Autocreating constants"
.IX Header "Autocreating constants"
After \f(CW\*(C`use Math::BigInt \*(Aq:constant\*(Aq\*(C'\fR all the \fBinteger\fR decimal, hexadecimal
and binary constants in the given scope are converted to \f(CW\*(C`Math::BigInt\*(C'\fR.
This conversion happens at compile time.
.PP
In particular,
.PP
.Vb 1
\&  perl \-MMath::BigInt=:constant \-e \*(Aqprint 2**100,"\en"\*(Aq
.Ve
.PP
prints the integer value of \f(CW\*(C`2**100\*(C'\fR. Note that without conversion of 
constants the expression 2**100 will be calculated as perl scalar.
.PP
Please note that strings and floating point constants are not affected,
so that
.PP
.Vb 1
\&        use Math::BigInt qw/:constant/;
\&
\&        $x = 1234567890123456789012345678901234567890
\&                + 123456789123456789;
\&        $y = \*(Aq1234567890123456789012345678901234567890\*(Aq
\&                + \*(Aq123456789123456789\*(Aq;
.Ve
.PP
do not work. You need an explicit Math::BigInt\->\fInew()\fR around one of the
operands. You should also quote large constants to protect loss of precision:
.PP
.Vb 1
\&        use Math::BigInt;
\&
\&        $x = Math::BigInt\->new(\*(Aq1234567889123456789123456789123456789\*(Aq);
.Ve
.PP
Without the quotes Perl would convert the large number to a floating point
constant at compile time and then hand the result to BigInt, which results in
an truncated result or a NaN.
.PP
This also applies to integers that look like floating point constants:
.PP
.Vb 1
\&        use Math::BigInt \*(Aq:constant\*(Aq;
\&
\&        print ref(123e2),"\en";
\&        print ref(123.2e2),"\en";
.Ve
.PP
will print nothing but newlines. Use either bignum or Math::BigFloat
to get this to work.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
Using the form \f(CW$x\fR += \f(CW$y\fR; etc over \f(CW$x\fR = \f(CW$x\fR + \f(CW$y\fR is faster, since a copy of \f(CW$x\fR
must be made in the second case. For long numbers, the copy can eat up to 20%
of the work (in the case of addition/subtraction, less for
multiplication/division). If \f(CW$y\fR is very small compared to \f(CW$x\fR, the form
\&\f(CW$x\fR += \f(CW$y\fR is \s-1MUCH\s0 faster than \f(CW$x\fR = \f(CW$x\fR + \f(CW$y\fR since making the copy of \f(CW$x\fR takes
more time then the actual addition.
.PP
With a technique called copy-on-write, the cost of copying with overload could
be minimized or even completely avoided. A test implementation of \s-1COW\s0 did show
performance gains for overloaded math, but introduced a performance loss due
to a constant overhead for all other operations. So Math::BigInt does currently
not \s-1COW\s0.
.PP
The rewritten version of this module (vs. v0.01) is slower on certain
operations, like \f(CW\*(C`new()\*(C'\fR, \f(CW\*(C`bstr()\*(C'\fR and \f(CW\*(C`numify()\*(C'\fR. The reason are that it
does now more work and handles much more cases. The time spent in these
operations is usually gained in the other math operations so that code on
the average should get (much) faster. If they don't, please contact the author.
.PP
Some operations may be slower for small numbers, but are significantly faster
for big numbers. Other operations are now constant (O(1), like \f(CW\*(C`bneg()\*(C'\fR,
\&\f(CW\*(C`babs()\*(C'\fR etc), instead of O(N) and thus nearly always take much less time.
These optimizations were done on purpose.
.PP
If you find the Calc module to slow, try to install any of the replacement
modules and see if they help you.
.SS "Alternative math libraries"
.IX Subsection "Alternative math libraries"
You can use an alternative library to drive Math::BigInt. See the section
\&\*(L"\s-1MATH\s0 \s-1LIBRARY\s0\*(R" for more information.
.PP
For more benchmark results see <http://bloodgate.com/perl/benchmarks.html>.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
.SS "Subclassing Math::BigInt"
.IX Subsection "Subclassing Math::BigInt"
The basic design of Math::BigInt allows simple subclasses with very little
work, as long as a few simple rules are followed:
.IP "\(bu" 2
The public \s-1API\s0 must remain consistent, i.e. if a sub-class is overloading
addition, the sub-class must use the same name, in this case \fIbadd()\fR. The
reason for this is that Math::BigInt is optimized to call the object methods
directly.
.IP "\(bu" 2
The private object hash keys like \f(CW\*(C`$x\->{sign}\*(C'\fR may not be changed, but
additional keys can be added, like \f(CW\*(C`$x\->{_custom}\*(C'\fR.
.IP "\(bu" 2
Accessor functions are available for all existing object hash keys and should
be used instead of directly accessing the internal hash keys. The reason for
this is that Math::BigInt itself has a pluggable interface which permits it
to support different storage methods.
.PP
More complex sub-classes may have to replicate more of the logic internal of
Math::BigInt if they need to change more basic behaviors. A subclass that
needs to merely change the output only needs to overload \f(CW\*(C`bstr()\*(C'\fR.
.PP
All other object methods and overloaded functions can be directly inherited
from the parent class.
.PP
At the very minimum, any subclass will need to provide its own \f(CW\*(C`new()\*(C'\fR and can
store additional hash keys in the object. There are also some package globals
that must be defined, e.g.:
.PP
.Vb 5
\&  # Globals
\&  $accuracy = undef;
\&  $precision = \-2;       # round to 2 decimal places
\&  $round_mode = \*(Aqeven\*(Aq;
\&  $div_scale = 40;
.Ve
.PP
Additionally, you might want to provide the following two globals to allow
auto-upgrading and auto-downgrading to work correctly:
.PP
.Vb 2
\&  $upgrade = undef;
\&  $downgrade = undef;
.Ve
.PP
This allows Math::BigInt to correctly retrieve package globals from the 
subclass, like \f(CW$SubClass::precision\fR.  See t/Math/BigInt/Subclass.pm or
t/Math/BigFloat/SubClass.pm completely functional subclass examples.
.PP
Don't forget to
.PP
.Vb 1
\&        use overload;
.Ve
.PP
in your subclass to automatically inherit the overloading from the parent. If
you like, you can change part of the overloading, look at Math::String for an
example.
.SH "UPGRADING"
.IX Header "UPGRADING"
When used like this:
.PP
.Vb 1
\&        use Math::BigInt upgrade => \*(AqFoo::Bar\*(Aq;
.Ve
.PP
certain operations will 'upgrade' their calculation and thus the result to
the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:
.PP
.Vb 1
\&        use Math::BigInt upgrade => \*(AqMath::BigFloat\*(Aq;
.Ve
.PP
As a shortcut, you can use the module \f(CW\*(C`bignum\*(C'\fR:
.PP
.Vb 1
\&        use bignum;
.Ve
.PP
Also good for one-liners:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint 2 ** 255\*(Aq
.Ve
.PP
This makes it possible to mix arguments of different classes (as in 2.5 + 2)
as well es preserve accuracy (as in \fIsqrt\fR\|(3)).
.PP
Beware: This feature is not fully implemented yet.
.SS "Auto-upgrade"
.IX Subsection "Auto-upgrade"
The following methods upgrade themselves unconditionally; that is if upgrade
is in effect, they will always hand up their work:
.IP "\fIbsqrt()\fR" 2
.IX Item "bsqrt()"
.PD 0
.IP "\fIdiv()\fR" 2
.IX Item "div()"
.IP "\fIblog()\fR" 2
.IX Item "blog()"
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.PD
.PP
Beware: This list is not complete.
.PP
All other methods upgrade themselves only when one (or all) of their
arguments are of the class mentioned in \f(CW$upgrade\fR (This might change in later
versions to a more sophisticated scheme):
.SH "EXPORTS"
.IX Header "EXPORTS"
\&\f(CW\*(C`Math::BigInt\*(C'\fR exports nothing by default, but can export the following methods:
.PP
.Vb 2
\&        bgcd
\&        blcm
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
Some things might not work as you expect them. Below is documented what is
known to be troublesome:
.IP "\fIbstr()\fR, \fIbsstr()\fR and 'cmp'" 1
.IX Item "bstr(), bsstr() and 'cmp'"
Both \f(CW\*(C`bstr()\*(C'\fR and \f(CW\*(C`bsstr()\*(C'\fR as well as automated stringify via overload now
drop the leading '+'. The old code would return '+3', the new returns '3'.
This is to be consistent with Perl and to make \f(CW\*(C`cmp\*(C'\fR (especially with
overloading) to work as you expect. It also solves problems with \f(CW\*(C`Test.pm\*(C'\fR,
because its \f(CW\*(C`ok()\*(C'\fR uses 'eq' internally.
.Sp
Mark Biggar said, when asked about to drop the '+' altogether, or make only
\&\f(CW\*(C`cmp\*(C'\fR work:
.Sp
.Vb 4
\&        I agree (with the first alternative), don\*(Aqt add the \*(Aq+\*(Aq on positive
\&        numbers.  It\*(Aqs not as important anymore with the new internal 
\&        form for numbers.  It made doing things like abs and neg easier,
\&        but those have to be done differently now anyway.
.Ve
.Sp
So, the following examples will now work all as expected:
.Sp
.Vb 3
\&        use Test;
\&        BEGIN { plan tests => 1 }
\&        use Math::BigInt;
\&
\&        my $x = new Math::BigInt 3*3;
\&        my $y = new Math::BigInt 3*3;
\&
\&        ok ($x,3*3);
\&        print "$x eq 9" if $x eq $y;
\&        print "$x eq 9" if $x eq \*(Aq9\*(Aq;
\&        print "$x eq 9" if $x eq 3*3;
.Ve
.Sp
Additionally, the following still works:
.Sp
.Vb 3
\&        print "$x == 9" if $x == $y;
\&        print "$x == 9" if $x == 9;
\&        print "$x == 9" if $x == 3*3;
.Ve
.Sp
There is now a \f(CW\*(C`bsstr()\*(C'\fR method to get the string in scientific notation aka
\&\f(CW1e+2\fR instead of \f(CW100\fR. Be advised that overloaded 'eq' always uses \fIbstr()\fR
for comparison, but Perl will represent some numbers as 100 and others
as 1e+308. If in doubt, convert both arguments to Math::BigInt before 
comparing them as strings:
.Sp
.Vb 3
\&        use Test;
\&        BEGIN { plan tests => 3 }
\&        use Math::BigInt;
\&
\&        $x = Math::BigInt\->new(\*(Aq1e56\*(Aq); $y = 1e56;
\&        ok ($x,$y);                     # will fail
\&        ok ($x\->bsstr(),$y);            # okay
\&        $y = Math::BigInt\->new($y);
\&        ok ($x,$y);                     # okay
.Ve
.Sp
Alternatively, simple use \f(CW\*(C`<=>\*(C'\fR for comparisons, this will get it
always right. There is not yet a way to get a number automatically represented
as a string that matches exactly the way Perl represents it.
.Sp
See also the section about \*(L"Infinity and Not a Number\*(R" for problems in
comparing NaNs.
.IP "\fIint()\fR" 1
.IX Item "int()"
\&\f(CW\*(C`int()\*(C'\fR will return (at least for Perl v5.7.1 and up) another BigInt, not a 
Perl scalar:
.Sp
.Vb 4
\&        $x = Math::BigInt\->new(123);
\&        $y = int($x);                           # BigInt 123
\&        $x = Math::BigFloat\->new(123.45);
\&        $y = int($x);                           # BigInt 123
.Ve
.Sp
In all Perl versions you can use \f(CW\*(C`as_number()\*(C'\fR or \f(CW\*(C`as_int\*(C'\fR for the same
effect:
.Sp
.Vb 3
\&        $x = Math::BigFloat\->new(123.45);
\&        $y = $x\->as_number();                   # BigInt 123
\&        $y = $x\->as_int();                      # ditto
.Ve
.Sp
This also works for other subclasses, like Math::String.
.Sp
If you want a real Perl scalar, use \f(CW\*(C`numify()\*(C'\fR:
.Sp
.Vb 1
\&        $y = $x\->numify();                      # 123 as scalar
.Ve
.Sp
This is seldom necessary, though, because this is done automatically, like
when you access an array:
.Sp
.Vb 1
\&        $z = $array[$x];                        # does work automatically
.Ve
.IP "length" 1
.IX Item "length"
The following will probably not do what you expect:
.Sp
.Vb 2
\&        $c = Math::BigInt\->new(123);
\&        print $c\->length(),"\en";                # prints 30
.Ve
.Sp
It prints both the number of digits in the number and in the fraction part
since print calls \f(CW\*(C`length()\*(C'\fR in list context. Use something like:
.Sp
.Vb 1
\&        print scalar $c\->length(),"\en";         # prints 3
.Ve
.IP "bdiv" 1
.IX Item "bdiv"
The following will probably not do what you expect:
.Sp
.Vb 1
\&        print $c\->bdiv(10000),"\en";
.Ve
.Sp
It prints both quotient and remainder since print calls \f(CW\*(C`bdiv()\*(C'\fR in list
context. Also, \f(CW\*(C`bdiv()\*(C'\fR will modify \f(CW$c\fR, so be careful. You probably want
to use
.Sp
.Vb 2
\&        print $c / 10000,"\en";
\&        print scalar $c\->bdiv(10000),"\en";  # or if you want to modify $c
.Ve
.Sp
instead.
.Sp
The quotient is always the greatest integer less than or equal to the
real-valued quotient of the two operands, and the remainder (when it is
non-zero) always has the same sign as the second operand; so, for
example,
.Sp
.Vb 6
\&          1 / 4  => ( 0, 1)
\&          1 / \-4 => (\-1,\-3)
\&         \-3 / 4  => (\-1, 1)
\&         \-3 / \-4 => ( 0,\-3)
\&        \-11 / 2  => (\-5,1)
\&         11 /\-2  => (\-5,\-1)
.Ve
.Sp
As a consequence, the behavior of the operator % agrees with the
behavior of Perl's built-in % operator (as documented in the perlop
manpage), and the equation
.Sp
.Vb 1
\&        $x == ($x / $y) * $y + ($x % $y)
.Ve
.Sp
holds true for any \f(CW$x\fR and \f(CW$y\fR, which justifies calling the two return
values of \fIbdiv()\fR the quotient and remainder. The only exception to this rule
are when \f(CW$y\fR == 0 and \f(CW$x\fR is negative, then the remainder will also be
negative. See below under \*(L"infinity handling\*(R" for the reasoning behind this.
.Sp
Perl's 'use integer;' changes the behaviour of % and / for scalars, but will
not change BigInt's way to do things. This is because under 'use integer' Perl
will do what the underlying C thinks is right and this is different for each
system. If you need BigInt's behaving exactly like Perl's 'use integer', bug
the author to implement it ;)
.IP "infinity handling" 1
.IX Item "infinity handling"
Here are some examples that explain the reasons why certain results occur while
handling infinity:
.Sp
The following table shows the result of the division and the remainder, so that
the equation above holds true. Some \*(L"ordinary\*(R" cases are strewn in to show more
clearly the reasoning:
.Sp
.Vb 10
\&        A /  B  =   C,     R so that C *    B +    R =    A
\&     =========================================================
\&        5 /   8 =   0,     5         0 *    8 +    5 =    5
\&        0 /   8 =   0,     0         0 *    8 +    0 =    0
\&        0 / inf =   0,     0         0 *  inf +    0 =    0
\&        0 /\-inf =   0,     0         0 * \-inf +    0 =    0
\&        5 / inf =   0,     5         0 *  inf +    5 =    5
\&        5 /\-inf =   0,     5         0 * \-inf +    5 =    5
\&        \-5/ inf =   0,    \-5         0 *  inf +   \-5 =   \-5
\&        \-5/\-inf =   0,    \-5         0 * \-inf +   \-5 =   \-5
\&       inf/   5 =  inf,    0       inf *    5 +    0 =  inf
\&      \-inf/   5 = \-inf,    0      \-inf *    5 +    0 = \-inf
\&       inf/  \-5 = \-inf,    0      \-inf *   \-5 +    0 =  inf
\&      \-inf/  \-5 =  inf,    0       inf *   \-5 +    0 = \-inf
\&         5/   5 =    1,    0         1 *    5 +    0 =    5
\&        \-5/  \-5 =    1,    0         1 *   \-5 +    0 =   \-5
\&       inf/ inf =    1,    0         1 *  inf +    0 =  inf
\&      \-inf/\-inf =    1,    0         1 * \-inf +    0 = \-inf
\&       inf/\-inf =   \-1,    0        \-1 * \-inf +    0 =  inf
\&      \-inf/ inf =   \-1,    0         1 * \-inf +    0 = \-inf
\&         8/   0 =  inf,    8       inf *    0 +    8 =    8
\&       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf
\&         0/   0 =  NaN
.Ve
.Sp
These cases below violate the \*(L"remainder has the sign of the second of the two
arguments\*(R", since they wouldn't match up otherwise.
.Sp
.Vb 4
\&        A /  B  =   C,     R so that C *    B +    R =    A
\&     ========================================================
\&      \-inf/   0 = \-inf, \-inf      \-inf *    0 +  inf = \-inf
\&        \-8/   0 = \-inf,   \-8      \-inf *    0 +    8 = \-8
.Ve
.IP "Modifying and =" 1
.IX Item "Modifying and ="
Beware of:
.Sp
.Vb 2
\&        $x = Math::BigFloat\->new(5);
\&        $y = $x;
.Ve
.Sp
It will not do what you think, e.g. making a copy of \f(CW$x\fR. Instead it just makes
a second reference to the \fBsame\fR object and stores it in \f(CW$y\fR. Thus anything
that modifies \f(CW$x\fR (except overloaded operators) will modify \f(CW$y\fR, and vice versa.
Or in other words, \f(CW\*(C`=\*(C'\fR is only safe if you modify your BigInts only via
overloaded math. As soon as you use a method call it breaks:
.Sp
.Vb 2
\&        $x\->bmul(2);
\&        print "$x, $y\en";       # prints \*(Aq10, 10\*(Aq
.Ve
.Sp
If you want a true copy of \f(CW$x\fR, use:
.Sp
.Vb 1
\&        $y = $x\->copy();
.Ve
.Sp
You can also chain the calls like this, this will make first a copy and then
multiply it by 2:
.Sp
.Vb 1
\&        $y = $x\->copy()\->bmul(2);
.Ve
.Sp
See also the documentation for overload.pm regarding \f(CW\*(C`=\*(C'\fR.
.IP "bpow" 1
.IX Item "bpow"
\&\f(CW\*(C`bpow()\*(C'\fR (and the rounding functions) now modifies the first argument and
returns it, unlike the old code which left it alone and only returned the
result. This is to be consistent with \f(CW\*(C`badd()\*(C'\fR etc. The first three will
modify \f(CW$x\fR, the last one won't:
.Sp
.Vb 4
\&        print bpow($x,$i),"\en";         # modify $x
\&        print $x\->bpow($i),"\en";        # ditto
\&        print $x **= $i,"\en";           # the same
\&        print $x ** $i,"\en";            # leave $x alone
.Ve
.Sp
The form \f(CW\*(C`$x **= $y\*(C'\fR is faster than \f(CW\*(C`$x = $x ** $y;\*(C'\fR, though.
.IP "Overloading \-$x" 1
.IX Item "Overloading -$x"
The following:
.Sp
.Vb 1
\&        $x = \-$x;
.Ve
.Sp
is slower than
.Sp
.Vb 1
\&        $x\->bneg();
.Ve
.Sp
since overload calls \f(CW\*(C`sub($x,0,1);\*(C'\fR instead of \f(CW\*(C`neg($x)\*(C'\fR. The first variant
needs to preserve \f(CW$x\fR since it does not know that it later will get overwritten.
This makes a copy of \f(CW$x\fR and takes O(N), but \f(CW$x\fR\->\fIbneg()\fR is O(1).
.IP "Mixing different object types" 1
.IX Item "Mixing different object types"
In Perl you will get a floating point value if you do one of the following:
.Sp
.Vb 3
\&        $float = 5.0 + 2;
\&        $float = 2 + 5.0;
\&        $float = 5 / 2;
.Ve
.Sp
With overloaded math, only the first two variants will result in a BigFloat:
.Sp
.Vb 2
\&        use Math::BigInt;
\&        use Math::BigFloat;
\&        
\&        $mbf = Math::BigFloat\->new(5);
\&        $mbi2 = Math::BigInteger\->new(5);
\&        $mbi = Math::BigInteger\->new(2);
\&
\&                                        # what actually gets called:
\&        $float = $mbf + $mbi;           # $mbf\->badd()
\&        $float = $mbf / $mbi;           # $mbf\->bdiv()
\&        $integer = $mbi + $mbf;         # $mbi\->badd()
\&        $integer = $mbi2 / $mbi;        # $mbi2\->bdiv()
\&        $integer = $mbi2 / $mbf;        # $mbi2\->bdiv()
.Ve
.Sp
This is because math with overloaded operators follows the first (dominating)
operand, and the operation of that is called and returns thus the result. So,
\&\fIMath::BigInt::bdiv()\fR will always return a Math::BigInt, regardless whether
the result should be a Math::BigFloat or the second operant is one.
.Sp
To get a Math::BigFloat you either need to call the operation manually,
make sure the operands are already of the proper type or casted to that type
via Math::BigFloat\->\fInew()\fR:
.Sp
.Vb 1
\&        $float = Math::BigFloat\->new($mbi2) / $mbi;     # = 2.5
.Ve
.Sp
Beware of simple \*(L"casting\*(R" the entire expression, this would only convert
the already computed result:
.Sp
.Vb 1
\&        $float = Math::BigFloat\->new($mbi2 / $mbi);     # = 2.0 thus wrong!
.Ve
.Sp
Beware also of the order of more complicated expressions like:
.Sp
.Vb 2
\&        $integer = ($mbi2 + $mbi) / $mbf;               # int / float => int
\&        $integer = $mbi2 / Math::BigFloat\->new($mbi);   # ditto
.Ve
.Sp
If in doubt, break the expression into simpler terms, or cast all operands
to the desired resulting type.
.Sp
Scalar values are a bit different, since:
.Sp
.Vb 2
\&        $float = 2 + $mbf;
\&        $float = $mbf + 2;
.Ve
.Sp
will both result in the proper type due to the way the overloaded math works.
.Sp
This section also applies to other overloaded math packages, like Math::String.
.Sp
One solution to you problem might be autoupgrading|upgrading. See the
pragmas bignum, bigint and bigrat for an easy way to do this.
.IP "\fIbsqrt()\fR" 1
.IX Item "bsqrt()"
\&\f(CW\*(C`bsqrt()\*(C'\fR works only good if the result is a big integer, e.g. the square
root of 144 is 12, but from 12 the square root is 3, regardless of rounding
mode. The reason is that the result is always truncated to an integer.
.Sp
If you want a better approximation of the square root, then use:
.Sp
.Vb 4
\&        $x = Math::BigFloat\->new(12);
\&        Math::BigFloat\->precision(0);
\&        Math::BigFloat\->round_mode(\*(Aqeven\*(Aq);
\&        print $x\->copy\->bsqrt(),"\en";           # 4
\&
\&        Math::BigFloat\->precision(2);
\&        print $x\->bsqrt(),"\en";                 # 3.46
\&        print $x\->bsqrt(3),"\en";                # 3.464
.Ve
.IP "\fIbrsft()\fR" 1
.IX Item "brsft()"
For negative numbers in base see also brsft.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigFloat, Math::BigRat and Math::Big as well as
Math::BigInt::BitVect, Math::BigInt::Pari and  Math::BigInt::GMP.
.PP
The pragmas bignum, bigint and bigrat also might be of interest
because they solve the autoupgrading/downgrading issue, at least partly.
.PP
The package at
<http://search.cpan.org/search?mode=module&query=Math%3A%3ABigInt> contains
more documentation including a full version history, testcases, empty
subclass files and benchmarks.
.SH "AUTHORS"
.IX Header "AUTHORS"
Original code by Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 \- 2006
and still at it in 2007.
.PP
Many people contributed in one or more ways to the final beast, see the file
\&\s-1CREDITS\s0 for an (incomplete) list. If you miss your name, please drop me a
mail. Thank you!
                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Math::BigInt5.18.3pm                         0100644 0001750 0001750 00000253626 12566207460 024005  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigInt 3pm"
.TH Math::BigInt 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigInt \- Arbitrary size integer/float math package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::BigInt;
\&
\&  # or make it faster with huge numbers: install (optional)
\&  # Math::BigInt::GMP and always use (it will fall back to
\&  # pure Perl if the GMP library is not installed):
\&  # (See also the L<MATH LIBRARY> section!)
\&
\&  # will warn if Math::BigInt::GMP cannot be found
\&  use Math::BigInt lib => \*(AqGMP\*(Aq;
\&
\&  # to suppress the warning use this:
\&  # use Math::BigInt try => \*(AqGMP\*(Aq;
\&
\&  # dies if GMP cannot be loaded:
\&  # use Math::BigInt only => \*(AqGMP\*(Aq;
\&
\&  my $str = \*(Aq1234567890\*(Aq;
\&  my @values = (64,74,18);
\&  my $n = 1; my $sign = \*(Aq\-\*(Aq;
\&
\&  # Number creation     
\&  my $x = Math::BigInt\->new($str);      # defaults to 0
\&  my $y = $x\->copy();                   # make a true copy
\&  my $nan  = Math::BigInt\->bnan();      # create a NotANumber
\&  my $zero = Math::BigInt\->bzero();     # create a +0
\&  my $inf = Math::BigInt\->binf();       # create a +inf
\&  my $inf = Math::BigInt\->binf(\*(Aq\-\*(Aq);    # create a \-inf
\&  my $one = Math::BigInt\->bone();       # create a +1
\&  my $mone = Math::BigInt\->bone(\*(Aq\-\*(Aq);   # create a \-1
\&
\&  my $pi = Math::BigInt\->bpi();         # returns \*(Aq3\*(Aq
\&                                        # see Math::BigFloat::bpi()
\&
\&  $h = Math::BigInt\->new(\*(Aq0x123\*(Aq);      # from hexadecimal
\&  $b = Math::BigInt\->new(\*(Aq0b101\*(Aq);      # from binary
\&  $o = Math::BigInt\->from_oct(\*(Aq0101\*(Aq);  # from octal
\&
\&  # Testing (don\*(Aqt modify their arguments)
\&  # (return true if the condition is met, otherwise false)
\&
\&  $x\->is_zero();        # if $x is +0
\&  $x\->is_nan();         # if $x is NaN
\&  $x\->is_one();         # if $x is +1
\&  $x\->is_one(\*(Aq\-\*(Aq);      # if $x is \-1
\&  $x\->is_odd();         # if $x is odd
\&  $x\->is_even();        # if $x is even
\&  $x\->is_pos();         # if $x > 0
\&  $x\->is_neg();         # if $x < 0
\&  $x\->is_inf($sign);    # if $x is +inf, or \-inf (sign is default \*(Aq+\*(Aq)
\&  $x\->is_int();         # if $x is an integer (not a float)
\&
\&  # comparing and digit/sign extraction
\&  $x\->bcmp($y);         # compare numbers (undef,<0,=0,>0)
\&  $x\->bacmp($y);        # compare absolutely (undef,<0,=0,>0)
\&  $x\->sign();           # return the sign, either +,\- or NaN
\&  $x\->digit($n);        # return the nth digit, counting from right
\&  $x\->digit(\-$n);       # return the nth digit, counting from left
\&
\&  # The following all modify their first argument. If you want to pre\-
\&  # serve $x, use $z = $x\->copy()\->bXXX($y); See under L<CAVEATS> for
\&  # why this is necessary when mixing $a = $b assignments with non\-over\-
\&  # loaded math.
\&
\&  $x\->bzero();          # set $x to 0
\&  $x\->bnan();           # set $x to NaN
\&  $x\->bone();           # set $x to +1
\&  $x\->bone(\*(Aq\-\*(Aq);        # set $x to \-1
\&  $x\->binf();           # set $x to inf
\&  $x\->binf(\*(Aq\-\*(Aq);        # set $x to \-inf
\&
\&  $x\->bneg();           # negation
\&  $x\->babs();           # absolute value
\&  $x\->bsgn();           # sign function (\-1, 0, 1, or NaN)
\&  $x\->bnorm();          # normalize (no\-op in BigInt)
\&  $x\->bnot();           # two\*(Aqs complement (bit wise not)
\&  $x\->binc();           # increment $x by 1
\&  $x\->bdec();           # decrement $x by 1
\&
\&  $x\->badd($y);         # addition (add $y to $x)
\&  $x\->bsub($y);         # subtraction (subtract $y from $x)
\&  $x\->bmul($y);         # multiplication (multiply $x by $y)
\&  $x\->bdiv($y);         # divide, set $x to quotient
\&                        # return (quo,rem) or quo if scalar
\&
\&  $x\->bmuladd($y,$z);   # $x = $x * $y + $z
\&
\&  $x\->bmod($y);            # modulus (x % y)
\&  $x\->bmodpow($y,$mod);    # modular exponentiation (($x ** $y) % $mod)
\&  $x\->bmodinv($mod);       # modular multiplicative inverse
\&  $x\->bpow($y);            # power of arguments (x ** y)
\&  $x\->blsft($y);           # left shift in base 2
\&  $x\->brsft($y);           # right shift in base 2
\&                           # returns (quo,rem) or quo if in sca\-
\&                           # lar context
\&  $x\->blsft($y,$n);        # left shift by $y places in base $n
\&  $x\->brsft($y,$n);        # right shift by $y places in base $n
\&                           # returns (quo,rem) or quo if in sca\-
\&                           # lar context
\&
\&  $x\->band($y);            # bitwise and
\&  $x\->bior($y);            # bitwise inclusive or
\&  $x\->bxor($y);            # bitwise exclusive or
\&  $x\->bnot();              # bitwise not (two\*(Aqs complement)
\&
\&  $x\->bsqrt();             # calculate square\-root
\&  $x\->broot($y);           # $y\*(Aqth root of $x (e.g. $y == 3 => cubic root)
\&  $x\->bfac();              # factorial of $x (1*2*3*4*..$x)
\&
\&  $x\->bnok($y);            # x over y (binomial coefficient n over k)
\&
\&  $x\->blog();              # logarithm of $x to base e (Euler\*(Aqs number)
\&  $x\->blog($base);         # logarithm of $x to base $base (f.i. 2)
\&  $x\->bexp();              # calculate e ** $x where e is Euler\*(Aqs number
\&
\&  $x\->round($A,$P,$mode);  # round to accuracy or precision using
\&                           # mode $mode
\&  $x\->bround($n);          # accuracy: preserve $n digits
\&  $x\->bfround($n);         # $n > 0: round $nth digits,
\&                           # $n < 0: round to the $nth digit after the
\&                           # dot, no\-op for BigInts
\&
\&  # The following do not modify their arguments in BigInt (are no\-ops),
\&  # but do so in BigFloat:
\&
\&  $x\->bfloor();            # return integer less or equal than $x
\&  $x\->bceil();             # return integer greater or equal than $x
\&
\&  # The following do not modify their arguments:
\&
\&  # greatest common divisor (no OO style)
\&  my $gcd = Math::BigInt::bgcd(@values);
\&  # lowest common multiple (no OO style)
\&  my $lcm = Math::BigInt::blcm(@values);
\&
\&  $x\->length();            # return number of digits in number
\&  ($xl,$f) = $x\->length(); # length of number and length of fraction
\&                           # part, latter is always 0 digits long
\&                           # for BigInts
\&
\&  $x\->exponent();         # return exponent as BigInt
\&  $x\->mantissa();         # return (signed) mantissa as BigInt
\&  $x\->parts();            # return (mantissa,exponent) as BigInt
\&  $x\->copy();             # make a true copy of $x (unlike $y = $x;)
\&  $x\->as_int();           # return as BigInt (in BigInt: same as copy())
\&  $x\->numify();           # return as scalar (might overflow!)
\&
\&  # conversion to string (do not modify their argument)
\&  $x\->bstr();         # normalized string (e.g. \*(Aq3\*(Aq)
\&  $x\->bsstr();        # norm. string in scientific notation (e.g. \*(Aq3E0\*(Aq)
\&  $x\->as_hex();       # as signed hexadecimal string with prefixed 0x
\&  $x\->as_bin();       # as signed binary string with prefixed 0b
\&  $x\->as_oct();       # as signed octal string with prefixed 0
\&
\&
\&  # precision and accuracy (see section about rounding for more)
\&  $x\->precision();       # return P of $x (or global, if P of $x undef)
\&  $x\->precision($n);     # set P of $x to $n
\&  $x\->accuracy();        # return A of $x (or global, if A of $x undef)
\&  $x\->accuracy($n);      # set A $x to $n
\&
\&  # Global methods
\&  Math::BigInt\->precision();   # get/set global P for all BigInt objects
\&  Math::BigInt\->accuracy();    # get/set global A for all BigInt objects
\&  Math::BigInt\->round_mode();  # get/set global round mode, one of
\&                               # \*(Aqeven\*(Aq, \*(Aqodd\*(Aq, \*(Aq+inf\*(Aq, \*(Aq\-inf\*(Aq, \*(Aqzero\*(Aq,
\&                               # \*(Aqtrunc\*(Aq or \*(Aqcommon\*(Aq
\&  Math::BigInt\->config();      # return hash containing configuration
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded if you
declare your big integers as
.PP
.Vb 1
\&  $i = new Math::BigInt \*(Aq123_456_789_123_456_789\*(Aq;
.Ve
.PP
Operations with overloaded operators preserve the arguments which is
exactly what you expect.
.IP "Input" 2
.IX Item "Input"
Input values to these routines may be any string, that looks like a number
and results in an integer, including hexadecimal and binary numbers.
.Sp
Scalars holding numbers may also be passed, but note that non-integer numbers
may already have lost precision due to the conversion to float. Quote
your input if you want BigInt to see all the digits:
.Sp
.Vb 2
\&        $x = Math::BigInt\->new(12345678890123456789);   # bad
\&        $x = Math::BigInt\->new(\*(Aq12345678901234567890\*(Aq); # good
.Ve
.Sp
You can include one underscore between any two digits.
.Sp
This means integer values like 1.01E2 or even 1000E\-2 are also accepted.
Non-integer values result in NaN.
.Sp
Hexadecimal (prefixed with \*(L"0x\*(R") and binary numbers (prefixed with \*(L"0b\*(R")
are accepted, too. Please note that octal numbers are not recognized
by \fInew()\fR, so the following will print \*(L"123\*(R":
.Sp
.Vb 1
\&        perl \-MMath::BigInt \-le \*(Aqprint Math::BigInt\->new("0123")\*(Aq
.Ve
.Sp
To convert an octal number, use \fIfrom_oct()\fR;
.Sp
.Vb 1
\&        perl \-MMath::BigInt \-le \*(Aqprint Math::BigInt\->from_oct("0123")\*(Aq
.Ve
.Sp
Currently, \fIMath::BigInt::new()\fR defaults to 0, while Math::BigInt::new('')
results in 'NaN'. This might change in the future, so use always the following
explicit forms to get a zero or NaN:
.Sp
.Vb 2
\&        $zero = Math::BigInt\->bzero();
\&        $nan = Math::BigInt\->bnan();
.Ve
.Sp
\&\f(CW\*(C`bnorm()\*(C'\fR on a BigInt object is now effectively a no-op, since the numbers 
are always stored in normalized form. If passed a string, creates a BigInt 
object from the input.
.IP "Output" 2
.IX Item "Output"
Output values are BigInt objects (normalized), except for the methods which
return a string (see \*(L"\s-1SYNOPSIS\*(R"\s0).
.Sp
Some routines (\f(CW\*(C`is_odd()\*(C'\fR, \f(CW\*(C`is_even()\*(C'\fR, \f(CW\*(C`is_zero()\*(C'\fR, \f(CW\*(C`is_one()\*(C'\fR,
\&\f(CW\*(C`is_nan()\*(C'\fR, etc.) return true or false, while others (\f(CW\*(C`bcmp()\*(C'\fR, \f(CW\*(C`bacmp()\*(C'\fR)
return either undef (if NaN is involved), <0, 0 or >0 and are suited for sort.
.SH "METHODS"
.IX Header "METHODS"
Each of the methods below (except \fIconfig()\fR, \fIaccuracy()\fR and \fIprecision()\fR)
accepts three additional parameters. These arguments \f(CW$A\fR, \f(CW$P\fR and \f(CW$R\fR
are \f(CW\*(C`accuracy\*(C'\fR, \f(CW\*(C`precision\*(C'\fR and \f(CW\*(C`round_mode\*(C'\fR. Please see the section about
\&\*(L"\s-1ACCURACY\s0 and \s-1PRECISION\*(R"\s0 for more information.
.SS "\fIconfig()\fP"
.IX Subsection "config()"
.Vb 1
\&        use Data::Dumper;
\&
\&        print Dumper ( Math::BigInt\->config() );
\&        print Math::BigInt\->config()\->{lib},"\en";
.Ve
.PP
Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.
.PP
.Vb 10
\&        key           Description
\&                      Example
\&        ============================================================
\&        lib           Name of the low\-level math library
\&                      Math::BigInt::Calc
\&        lib_version   Version of low\-level math library (see \*(Aqlib\*(Aq)
\&                      0.30
\&        class         The class name of config() you just called
\&                      Math::BigInt
\&        upgrade       To which class math operations might be upgraded
\&                      Math::BigFloat
\&        downgrade     To which class math operations might be downgraded
\&                      undef
\&        precision     Global precision
\&                      undef
\&        accuracy      Global accuracy
\&                      undef
\&        round_mode    Global round mode
\&                      even
\&        version       version number of the class you used
\&                      1.61
\&        div_scale     Fallback accuracy for div
\&                      40
\&        trap_nan      If true, traps creation of NaN via croak()
\&                      1
\&        trap_inf      If true, traps creation of +inf/\-inf via croak()
\&                      1
.Ve
.PP
The following values can be set by passing \f(CW\*(C`config()\*(C'\fR a reference to a hash:
.PP
.Vb 2
\&        trap_inf trap_nan
\&        upgrade downgrade precision accuracy round_mode div_scale
.Ve
.PP
Example:
.PP
.Vb 3
\&        $new_cfg = Math::BigInt\->config(
\&            { trap_inf => 1, precision => 5 }
\&        );
.Ve
.SS "\fIaccuracy()\fP"
.IX Subsection "accuracy()"
.Vb 3
\&    $x\->accuracy(5);         # local for $x
\&    CLASS\->accuracy(5);      # global for all members of CLASS
\&                             # Note: This also applies to new()!
\&
\&    $A = $x\->accuracy();     # read out accuracy that affects $x
\&    $A = CLASS\->accuracy();  # read out global accuracy
.Ve
.PP
Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to \fInew()\fR!
.PP
Warning! The accuracy \fIsticks\fR, e.g. once you created a number under the
influence of \f(CW\*(C`CLASS\->accuracy($A)\*(C'\fR, all results from math operations with
that number will also be rounded.
.PP
In most cases, you should probably round the results explicitly using one of
\&\*(L"\fIround()\fR\*(R", \*(L"\fIbround()\fR\*(R" or \*(L"\fIbfround()\fR\*(R" or by passing the desired accuracy
to the math operation as additional parameter:
.PP
.Vb 4
\&    my $x = Math::BigInt\->new(30000);
\&    my $y = Math::BigInt\->new(7);
\&    print scalar $x\->copy()\->bdiv($y, 2);               # print 4300
\&    print scalar $x\->copy()\->bdiv($y)\->bround(2);       # print 4300
.Ve
.PP
Please see the section about \*(L"\s-1ACCURACY\s0 and \s-1PRECISION\*(R"\s0 for further details.
.PP
Value must be greater than zero. Pass an undef value to disable it:
.PP
.Vb 2
\&    $x\->accuracy(undef);
\&    Math::BigInt\->accuracy(undef);
.Ve
.PP
Returns the current accuracy. For \f(CW\*(C`$x\->accuracy()\*(C'\fR it will return either
the local accuracy, or if not defined, the global. This means the return value
represents the accuracy that will be in effect for \f(CW$x:\fR
.PP
.Vb 10
\&    $y = Math::BigInt\->new(1234567);       # unrounded
\&    print Math::BigInt\->accuracy(4),"\en";  # set 4, print 4
\&    $x = Math::BigInt\->new(123456);        # $x will be automatic\-
\&                                           # ally rounded!
\&    print "$x $y\en";                       # \*(Aq123500 1234567\*(Aq
\&    print $x\->accuracy(),"\en";             # will be 4
\&    print $y\->accuracy(),"\en";             # also 4, since global is 4
\&    print Math::BigInt\->accuracy(5),"\en";  # set to 5, print 5
\&    print $x\->accuracy(),"\en";             # still 4
\&    print $y\->accuracy(),"\en";             # 5, since global is 5
.Ve
.PP
Note: Works also for subclasses like Math::BigFloat. Each class has it's own
globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.
.SS "\fIprecision()\fP"
.IX Subsection "precision()"
.Vb 4
\&    $x\->precision(\-2);          # local for $x, round at the second
\&                                # digit right of the dot
\&    $x\->precision(2);           # ditto, round at the second digit left
\&                                # of the dot
\&
\&    CLASS\->precision(5);        # Global for all members of CLASS
\&                                # This also applies to new()!
\&    CLASS\->precision(\-5);       # ditto
\&
\&    $P = CLASS\->precision();    # read out global precision
\&    $P = $x\->precision();       # read out precision that affects $x
.Ve
.PP
Note: You probably want to use \*(L"\fIaccuracy()\fR\*(R" instead. With \*(L"\fIaccuracy()\fR\*(R" you
set the number of digits each result should have, with \*(L"\fIprecision()\fR\*(R" you
set the place where to round!
.PP
\&\f(CW\*(C`precision()\*(C'\fR sets or gets the global or local precision, aka at which digit
before or after the dot to round all results. A set global precision also
applies to all newly created numbers!
.PP
In Math::BigInt, passing a negative number precision has no effect since no
numbers have digits after the dot. In Math::BigFloat, it will round all
results to P digits after the dot.
.PP
Please see the section about \*(L"\s-1ACCURACY\s0 and \s-1PRECISION\*(R"\s0 for further details.
.PP
Pass an undef value to disable it:
.PP
.Vb 2
\&    $x\->precision(undef);
\&    Math::BigInt\->precision(undef);
.Ve
.PP
Returns the current precision. For \f(CW\*(C`$x\->precision()\*(C'\fR it will return either
the local precision of \f(CW$x\fR, or if not defined, the global. This means the return
value represents the prevision that will be in effect for \f(CW$x:\fR
.PP
.Vb 4
\&    $y = Math::BigInt\->new(1234567);        # unrounded
\&    print Math::BigInt\->precision(4),"\en";  # set 4, print 4
\&    $x = Math::BigInt\->new(123456);      # will be automatically rounded
\&    print $x;                               # print "120000"!
.Ve
.PP
Note: Works also for subclasses like Math::BigFloat. Each class has its
own globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.
.SS "\fIbrsft()\fP"
.IX Subsection "brsft()"
.Vb 1
\&        $x\->brsft($y,$n);
.Ve
.PP
Shifts \f(CW$x\fR right by \f(CW$y\fR in base \f(CW$n\fR. Default is base 2, used are usually 10 and
2, but others work, too.
.PP
Right shifting usually amounts to dividing \f(CW$x\fR by \f(CW$n\fR ** \f(CW$y\fR and truncating the
result:
.PP
.Vb 4
\&        $x = Math::BigInt\->new(10);
\&        $x\->brsft(1);                   # same as $x >> 1: 5
\&        $x = Math::BigInt\->new(1234);
\&        $x\->brsft(2,10);                # result 12
.Ve
.PP
There is one exception, and that is base 2 with negative \f(CW$x:\fR
.PP
.Vb 2
\&        $x = Math::BigInt\->new(\-5);
\&        print $x\->brsft(1);
.Ve
.PP
This will print \-3, not \-2 (as it would if you divide \-5 by 2 and truncate the
result).
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&        $x = Math::BigInt\->new($str,$A,$P,$R);
.Ve
.PP
Creates a new BigInt object from a scalar or another BigInt object. The
input is accepted as decimal, hex (with leading '0x') or binary (with leading
\&'0b').
.PP
See \*(L"Input\*(R" for more info on accepted input formats.
.SS "\fIfrom_oct()\fP"
.IX Subsection "from_oct()"
.Vb 1
\&        $x = Math::BigInt\->from_oct("0775");    # input is octal
.Ve
.PP
Interpret the input as an octal string and return the corresponding value. A
\&\*(L"0\*(R" (zero) prefix is optional. A single underscore character may be placed
right after the prefix, if present, or between any two digits. If the input is
invalid, a NaN is returned.
.SS "\fIfrom_hex()\fP"
.IX Subsection "from_hex()"
.Vb 1
\&        $x = Math::BigInt\->from_hex("0xcafe");  # input is hexadecimal
.Ve
.PP
Interpret input as a hexadecimal string. A \*(L"0x\*(R" or \*(L"x\*(R" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.
.SS "\fIfrom_bin()\fP"
.IX Subsection "from_bin()"
.Vb 1
\&        $x = Math::BigInt\->from_bin("0b10011"); # input is binary
.Ve
.PP
Interpret the input as a binary string. A \*(L"0b\*(R" or \*(L"b\*(R" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.
.SS "\fIbnan()\fP"
.IX Subsection "bnan()"
.Vb 1
\&        $x = Math::BigInt\->bnan();
.Ve
.PP
Creates a new BigInt object representing NaN (Not A Number).
If used on an object, it will set it to NaN:
.PP
.Vb 1
\&        $x\->bnan();
.Ve
.SS "\fIbzero()\fP"
.IX Subsection "bzero()"
.Vb 1
\&        $x = Math::BigInt\->bzero();
.Ve
.PP
Creates a new BigInt object representing zero.
If used on an object, it will set it to zero:
.PP
.Vb 1
\&        $x\->bzero();
.Ve
.SS "\fIbinf()\fP"
.IX Subsection "binf()"
.Vb 1
\&        $x = Math::BigInt\->binf($sign);
.Ve
.PP
Creates a new BigInt object representing infinity. The optional argument is
either '\-' or '+', indicating whether you want infinity or minus infinity.
If used on an object, it will set it to infinity:
.PP
.Vb 2
\&        $x\->binf();
\&        $x\->binf(\*(Aq\-\*(Aq);
.Ve
.SS "\fIbone()\fP"
.IX Subsection "bone()"
.Vb 1
\&        $x = Math::BigInt\->binf($sign);
.Ve
.PP
Creates a new BigInt object representing one. The optional argument is
either '\-' or '+', indicating whether you want one or minus one.
If used on an object, it will set it to one:
.PP
.Vb 2
\&        $x\->bone();             # +1
\&        $x\->bone(\*(Aq\-\*(Aq);          # \-1
.Ve
.SS "\fIis_one()\fP/\fIis_zero()\fP/\fIis_nan()\fP/\fIis_inf()\fP"
.IX Subsection "is_one()/is_zero()/is_nan()/is_inf()"
.Vb 6
\&        $x\->is_zero();          # true if arg is +0
\&        $x\->is_nan();           # true if arg is NaN
\&        $x\->is_one();           # true if arg is +1
\&        $x\->is_one(\*(Aq\-\*(Aq);        # true if arg is \-1
\&        $x\->is_inf();           # true if +inf
\&        $x\->is_inf(\*(Aq\-\*(Aq);        # true if \-inf (sign is default \*(Aq+\*(Aq)
.Ve
.PP
These methods all test the BigInt for being one specific value and return
true or false depending on the input. These are faster than doing something
like:
.PP
.Vb 1
\&        if ($x == 0)
.Ve
.SS "\fIis_pos()\fP/\fIis_neg()\fP/\fIis_positive()\fP/\fIis_negative()\fP"
.IX Subsection "is_pos()/is_neg()/is_positive()/is_negative()"
.Vb 2
\&        $x\->is_pos();                   # true if > 0
\&        $x\->is_neg();                   # true if < 0
.Ve
.PP
The methods return true if the argument is positive or negative, respectively.
\&\f(CW\*(C`NaN\*(C'\fR is neither positive nor negative, while \f(CW\*(C`+inf\*(C'\fR counts as positive, and
\&\f(CW\*(C`\-inf\*(C'\fR is negative. A \f(CW\*(C`zero\*(C'\fR is neither positive nor negative.
.PP
These methods are only testing the sign, and not the value.
.PP
\&\f(CW\*(C`is_positive()\*(C'\fR and \f(CW\*(C`is_negative()\*(C'\fR are aliases to \f(CW\*(C`is_pos()\*(C'\fR and
\&\f(CW\*(C`is_neg()\*(C'\fR, respectively. \f(CW\*(C`is_positive()\*(C'\fR and \f(CW\*(C`is_negative()\*(C'\fR were
introduced in v1.36, while \f(CW\*(C`is_pos()\*(C'\fR and \f(CW\*(C`is_neg()\*(C'\fR were only introduced
in v1.68.
.SS "\fIis_odd()\fP/\fIis_even()\fP/\fIis_int()\fP"
.IX Subsection "is_odd()/is_even()/is_int()"
.Vb 3
\&        $x\->is_odd();                   # true if odd, false for even
\&        $x\->is_even();                  # true if even, false for odd
\&        $x\->is_int();                   # true if $x is an integer
.Ve
.PP
The return true when the argument satisfies the condition. \f(CW\*(C`NaN\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR,
\&\f(CW\*(C`\-inf\*(C'\fR are not integers and are neither odd nor even.
.PP
In BigInt, all numbers except \f(CW\*(C`NaN\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR and \f(CW\*(C`\-inf\*(C'\fR are integers.
.SS "\fIbcmp()\fP"
.IX Subsection "bcmp()"
.Vb 1
\&        $x\->bcmp($y);
.Ve
.PP
Compares \f(CW$x\fR with \f(CW$y\fR and takes the sign into account.
Returns \-1, 0, 1 or undef.
.SS "\fIbacmp()\fP"
.IX Subsection "bacmp()"
.Vb 1
\&        $x\->bacmp($y);
.Ve
.PP
Compares \f(CW$x\fR with \f(CW$y\fR while ignoring their sign. Returns \-1, 0, 1 or undef.
.SS "\fIsign()\fP"
.IX Subsection "sign()"
.Vb 1
\&        $x\->sign();
.Ve
.PP
Return the sign, of \f(CW$x\fR, meaning either \f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`\-inf\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR or NaN.
.PP
If you want \f(CW$x\fR to have a certain sign, use one of the following methods:
.PP
.Vb 5
\&        $x\->babs();             # \*(Aq+\*(Aq
\&        $x\->babs()\->bneg();     # \*(Aq\-\*(Aq
\&        $x\->bnan();             # \*(AqNaN\*(Aq
\&        $x\->binf();             # \*(Aq+inf\*(Aq
\&        $x\->binf(\*(Aq\-\*(Aq);          # \*(Aq\-inf\*(Aq
.Ve
.SS "\fIdigit()\fP"
.IX Subsection "digit()"
.Vb 1
\&        $x\->digit($n);       # return the nth digit, counting from right
.Ve
.PP
If \f(CW$n\fR is negative, returns the digit counting from left.
.SS "\fIbneg()\fP"
.IX Subsection "bneg()"
.Vb 1
\&        $x\->bneg();
.Ve
.PP
Negate the number, e.g. change the sign between '+' and '\-', or between '+inf'
and '\-inf', respectively. Does nothing for NaN or zero.
.SS "\fIbabs()\fP"
.IX Subsection "babs()"
.Vb 1
\&        $x\->babs();
.Ve
.PP
Set the number to its absolute value, e.g. change the sign from '\-' to '+'
and from '\-inf' to '+inf', respectively. Does nothing for NaN or positive
numbers.
.SS "\fIbsgn()\fP"
.IX Subsection "bsgn()"
.Vb 1
\&        $x\->bsgn();
.Ve
.PP
Signum function. Set the number to \-1, 0, or 1, depending on whether the
number is negative, zero, or positive, respectivly. Does not modify NaNs.
.SS "\fIbnorm()\fP"
.IX Subsection "bnorm()"
.Vb 1
\&        $x\->bnorm();                    # normalize (no\-op)
.Ve
.SS "\fIbnot()\fP"
.IX Subsection "bnot()"
.Vb 1
\&        $x\->bnot();
.Ve
.PP
Two's complement (bitwise not). This is equivalent to
.PP
.Vb 1
\&        $x\->binc()\->bneg();
.Ve
.PP
but faster.
.SS "\fIbinc()\fP"
.IX Subsection "binc()"
.Vb 1
\&        $x\->binc();             # increment x by 1
.Ve
.SS "\fIbdec()\fP"
.IX Subsection "bdec()"
.Vb 1
\&        $x\->bdec();             # decrement x by 1
.Ve
.SS "\fIbadd()\fP"
.IX Subsection "badd()"
.Vb 1
\&        $x\->badd($y);           # addition (add $y to $x)
.Ve
.SS "\fIbsub()\fP"
.IX Subsection "bsub()"
.Vb 1
\&        $x\->bsub($y);           # subtraction (subtract $y from $x)
.Ve
.SS "\fIbmul()\fP"
.IX Subsection "bmul()"
.Vb 1
\&        $x\->bmul($y);           # multiplication (multiply $x by $y)
.Ve
.SS "\fIbmuladd()\fP"
.IX Subsection "bmuladd()"
.Vb 1
\&        $x\->bmuladd($y,$z);
.Ve
.PP
Multiply \f(CW$x\fR by \f(CW$y\fR, and then add \f(CW$z\fR to the result,
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbdiv()\fP"
.IX Subsection "bdiv()"
.Vb 2
\&        $x\->bdiv($y);           # divide, set $x to quotient
\&                                # return (quo,rem) or quo if scalar
.Ve
.SS "\fIbmod()\fP"
.IX Subsection "bmod()"
.Vb 1
\&        $x\->bmod($y);           # modulus (x % y)
.Ve
.SS "\fIbmodinv()\fP"
.IX Subsection "bmodinv()"
.Vb 1
\&        $x\->bmodinv($mod);      # modular multiplicative inverse
.Ve
.PP
Returns the multiplicative inverse of \f(CW$x\fR modulo \f(CW$mod\fR. If
.PP
.Vb 1
\&        $y = $x \-> copy() \-> bmodinv($mod)
.Ve
.PP
then \f(CW$y\fR is the number closest to zero, and with the same sign as \f(CW$mod\fR,
satisfying
.PP
.Vb 1
\&        ($x * $y) % $mod = 1 % $mod
.Ve
.PP
If \f(CW$x\fR and \f(CW$y\fR are non-zero, they must be relative primes, i.e.,
\&\f(CW\*(C`bgcd($y, $mod)==1\*(C'\fR. '\f(CW\*(C`NaN\*(C'\fR' is returned when no modular multiplicative
inverse exists.
.SS "\fIbmodpow()\fP"
.IX Subsection "bmodpow()"
.Vb 2
\&        $num\->bmodpow($exp,$mod);       # modular exponentiation
\&                                        # ($num**$exp % $mod)
.Ve
.PP
Returns the value of \f(CW$num\fR taken to the power \f(CW$exp\fR in the modulus
\&\f(CW$mod\fR using binary exponentiation.  \f(CW\*(C`bmodpow\*(C'\fR is far superior to
writing
.PP
.Vb 1
\&        $num ** $exp % $mod
.Ve
.PP
because it is much faster \- it reduces internal variables into
the modulus whenever possible, so it operates on smaller numbers.
.PP
\&\f(CW\*(C`bmodpow\*(C'\fR also supports negative exponents.
.PP
.Vb 1
\&        bmodpow($num, \-1, $mod)
.Ve
.PP
is exactly equivalent to
.PP
.Vb 1
\&        bmodinv($num, $mod)
.Ve
.SS "\fIbpow()\fP"
.IX Subsection "bpow()"
.Vb 1
\&        $x\->bpow($y);                 # power of arguments (x ** y)
.Ve
.SS "\fIblog()\fP"
.IX Subsection "blog()"
.Vb 1
\&        $x\->blog($base, $accuracy);   # logarithm of x to the base $base
.Ve
.PP
If \f(CW$base\fR is not defined, Euler's number (e) is used:
.PP
.Vb 1
\&        print $x\->blog(undef, 100);   # log(x) to 100 digits
.Ve
.SS "\fIbexp()\fP"
.IX Subsection "bexp()"
.Vb 1
\&        $x\->bexp($accuracy);          # calculate e ** X
.Ve
.PP
Calculates the expression \f(CW\*(C`e ** $x\*(C'\fR where \f(CW\*(C`e\*(C'\fR is Euler's number.
.PP
This method was added in v1.82 of Math::BigInt (April 2007).
.PP
See also \*(L"\fIblog()\fR\*(R".
.SS "\fIbnok()\fP"
.IX Subsection "bnok()"
.Vb 1
\&        $x\->bnok($y);        # x over y (binomial coefficient n over k)
.Ve
.PP
Calculates the binomial coefficient n over k, also called the \*(L"choose\*(R"
function. The result is equivalent to:
.PP
.Vb 3
\&        ( n )      n!
\&        | \- |  = \-\-\-\-\-\-\-
\&        ( k )    k!(n\-k)!
.Ve
.PP
This method was added in v1.84 of Math::BigInt (April 2007).
.SS "\fIbpi()\fP"
.IX Subsection "bpi()"
.Vb 1
\&        print Math::BigInt\->bpi(100), "\en";             # 3
.Ve
.PP
Returns \s-1PI\s0 truncated to an integer, with the argument being ignored. This means
under BigInt this always returns \f(CW3\fR.
.PP
If upgrading is in effect, returns \s-1PI,\s0 rounded to N digits with the
current rounding mode:
.PP
.Vb 4
\&        use Math::BigFloat;
\&        use Math::BigInt upgrade => Math::BigFloat;
\&        print Math::BigInt\->bpi(3), "\en";               # 3.14
\&        print Math::BigInt\->bpi(100), "\en";             # 3.1415....
.Ve
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbcos()\fP"
.IX Subsection "bcos()"
.Vb 2
\&        my $x = Math::BigInt\->new(1);
\&        print $x\->bcos(100), "\en";
.Ve
.PP
Calculate the cosinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbsin()\fP"
.IX Subsection "bsin()"
.Vb 2
\&        my $x = Math::BigInt\->new(1);
\&        print $x\->bsin(100), "\en";
.Ve
.PP
Calculate the sinus of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan2()\fP"
.IX Subsection "batan2()"
.Vb 3
\&        my $x = Math::BigInt\->new(1);
\&        my $y = Math::BigInt\->new(1);
\&        print $y\->batan2($x), "\en";
.Ve
.PP
Calculate the arcus tangens of \f(CW$y\fR divided by \f(CW$x\fR, modifying \f(CW$y\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan()\fP"
.IX Subsection "batan()"
.Vb 2
\&        my $x = Math::BigFloat\->new(0.5);
\&        print $x\->batan(100), "\en";
.Ve
.PP
Calculate the arcus tangens of \f(CW$x\fR, modifying \f(CW$x\fR in place.
.PP
In BigInt, unless upgrading is in effect, the result is truncated to an
integer.
.PP
This method was added in v1.87 of Math::BigInt (June 2007).
.SS "\fIblsft()\fP"
.IX Subsection "blsft()"
.Vb 2
\&        $x\->blsft($y);          # left shift in base 2
\&        $x\->blsft($y,$n);       # left shift, in base $n (like 10)
.Ve
.SS "\fIbrsft()\fP"
.IX Subsection "brsft()"
.Vb 2
\&        $x\->brsft($y);          # right shift in base 2
\&        $x\->brsft($y,$n);       # right shift, in base $n (like 10)
.Ve
.SS "\fIband()\fP"
.IX Subsect