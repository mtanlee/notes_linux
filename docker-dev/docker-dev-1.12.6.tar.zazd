st['ok'] = _dummyButton(self, 'ok')
        self.subwidget_list['apply'] = _dummyButton(self, 'apply')
        self.subwidget_list['cancel'] = _dummyButton(self, 'cancel')
        self.subwidget_list['help'] = _dummyButton(self, 'help')

    def invoke(self, name):
        if name in self.subwidget_list:
            self.tk.call(self._w, 'invoke', name)

class TList(TixWidget, XView, YView):
    """TList - Hierarchy display widget which can be
    used to display data in a tabular format. The list entries of a TList
    widget are similar to the entries in the Tk listbox widget. The main
    differences are (1) the TList widget can display the list entries in a
    two dimensional format and (2) you can use graphical images as well as
    multiple colors and fonts for the list entries.

    Subwidgets - None"""

    def __init__ (self,master=None,cnf={}, **kw):
        TixWidget.__init__(self, master, 'tixTList', ['options'], cnf, kw)

    def active_set(self, index):
        self.tk.call(self._w, 'active', 'set', index)

    def active_clear(self):
        self.tk.call(self._w, 'active', 'clear')

    def anchor_set(self, index):
        self.tk.call(self._w, 'anchor', 'set', index)

    def anchor_clear(self):
        self.tk.call(self._w, 'anchor', 'clear')

    def delete(self, from_, to=None):
        self.tk.call(self._w, 'delete', from_, to)

    def dragsite_set(self, index):
        self.tk.call(self._w, 'dragsite', 'set', index)

    def dragsite_clear(self):
        self.tk.call(self._w, 'dragsite', 'clear')

    def dropsite_set(self, index):
        self.tk.call(self._w, 'dropsite', 'set', index)

    def dropsite_clear(self):
        self.tk.call(self._w, 'dropsite', 'clear')

    def insert(self, index, cnf={}, **kw):
        self.tk.call(self._w, 'insert', index, *self._options(cnf, kw))

    def info_active(self):
        return self.tk.call(self._w, 'info', 'active')

    def info_anchor(self):
        return self.tk.call(self._w, 'info', 'anchor')

    def info_down(self, index):
        return self.tk.call(self._w, 'info', 'down', index)

    def info_left(self, index):
        return self.tk.call(self._w, 'info', 'left', index)

    def info_right(self, index):
        return self.tk.call(self._w, 'info', 'right', index)

    def info_selection(self):
        c = self.tk.call(self._w, 'info', 'selection')
        return self.tk.splitlist(c)

    def info_size(self):
        return self.tk.call(self._w, 'info', 'size')

    def info_up(self, index):
        return self.tk.call(self._w, 'info', 'up', index)

    def nearest(self, x, y):
        return self.tk.call(self._w, 'nearest', x, y)

    def see(self, index):
        self.tk.call(self._w, 'see', index)

    def selection_clear(self, cnf={}, **kw):
        self.tk.call(self._w, 'selection', 'clear', *self._options(cnf, kw))

    def selection_includes(self, index):
        return self.tk.call(self._w, 'selection', 'includes', index)

    def selection_set(self, first, last=None):
        self.tk.call(self._w, 'selection', 'set', first, last)

class Tree(TixWidget):
    """Tree - The tixTree widget can be used to display hierarchical
    data in a tree form. The user can adjust
    the view of the tree by opening or closing parts of the tree."""

    # FIXME: It should inherit -superclass tixScrolledWidget
    def __init__(self, master=None, cnf={}, **kw):
        TixWidget.__init__(self, master, 'tixTree',
                           ['options'], cnf, kw)
        self.subwidget_list['hlist'] = _dummyHList(self, 'hlist')
        self.subwidget_list['vsb'] = _dummyScrollbar(self, 'vsb')
        self.subwidget_list['hsb'] = _dummyScrollbar(self, 'hsb')

    def autosetmode(self):
        '''This command calls the setmode method for all the entries in this
     Tree widget: if an entry has no child entries, its mode is set to
     none. Otherwise, if the entry has any hidden child entries, its mode is
     set to open; otherwise its mode is set to close.'''
        self.tk.call(self._w, 'autosetmode')

    def close(self, entrypath):
        '''Close the entry given by entryPath if its mode is close.'''
        self.tk.call(self._w, 'close', entrypath)

    def getmode(self, entrypath):
        '''Returns the current mode of the entry given by entryPath.'''
        return self.tk.call(self._w, 'getmode', entrypath)

    def open(self, entrypath):
        '''Open the entry given by entryPath if its mode is open.'''
        self.tk.call(self._w, 'open', entrypath)

    def setmode(self, entrypath, mode='none'):
        '''This command is used to indicate whether the entry given by
     entryPath has children entries and whether the children are visible. mode
     must be one of open, close or none. If mode is set to open, a (+)
     indicator is drawn next the entry. If mode is set to close, a (-)
     indicator is drawn next the entry. If mode is set to none, no
     indicators will be drawn for this entry. The default mode is none. The
     open mode indicates the entry has hidden children and this entry can be
     opened by the user. The close mode indicates that all the children of the
     entry are now visible and the entry can be closed by the user.'''
        self.tk.call(self._w, 'setmode', entrypath, mode)


# Could try subclassing Tree for CheckList - would need another arg to init
class CheckList(TixWidget):
    """The CheckList widget
    displays a list of items to be selected by the user. CheckList acts
    similarly to the Tk checkbutton or radiobutton widgets, except it is
    capable of handling many more items than checkbuttons or radiobuttons.
    """
    # FIXME: It should inherit -superclass tixTree
    def __init__(self, master=None, cnf={}, **kw):
        TixWidget.__init__(self, master, 'tixCheckList',
                           ['options', 'radio'], cnf, kw)
        self.subwidget_list['hlist'] = _dummyHList(self, 'hlist')
        self.subwidget_list['vsb'] = _dummyScrollbar(self, 'vsb')
        self.subwidget_list['hsb'] = _dummyScrollbar(self, 'hsb')

    def autosetmode(self):
        '''This command calls the setmode method for all the entries in this
     Tree widget: if an entry has no child entries, its mode is set to
     none. Otherwise, if the entry has any hidden child entries, its mode is
     set to open; otherwise its mode is set to close.'''
        self.tk.call(self._w, 'autosetmode')

    def close(self, entrypath):
        '''Close the entry given by entryPath if its mode is close.'''
        self.tk.call(self._w, 'close', entrypath)

    def getmode(self, entrypath):
        '''Returns the current mode of the entry given by entryPath.'''
        return self.tk.call(self._w, 'getmode', entrypath)

    def open(self, entrypath):
        '''Open the entry given by entryPath if its mode is open.'''
        self.tk.call(self._w, 'open', entrypath)

    def getselection(self, mode='on'):
        '''Returns a list of items whose status matches status. If status is
     not specified, the list of items in the "on" status will be returned.
     Mode can be on, off, default'''
        c = self.tk.split(self.tk.call(self._w, 'getselection', mode))
        return self.tk.splitlist(c)

    def getstatus(self, entrypath):
        '''Returns the current status of entryPath.'''
        return self.tk.call(self._w, 'getstatus', entrypath)

    def setstatus(self, entrypath, mode='on'):
        '''Sets the status of entryPath to be status. A bitmap will be
     displayed next to the entry its status is on, off or default.'''
        self.tk.call(self._w, 'setstatus', entrypath, mode)


###########################################################################
### The subclassing below is used to instantiate the subwidgets in each ###
### mega widget. This allows us to access their methods directly.       ###
###########################################################################

class _dummyButton(Button, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyCheckbutton(Checkbutton, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyEntry(Entry, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyFrame(Frame, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyLabel(Label, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyListbox(Listbox, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyMenu(Menu, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyMenubutton(Menubutton, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyScrollbar(Scrollbar, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyText(Text, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyScrolledListBox(ScrolledListBox, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)
        self.subwidget_list['listbox'] = _dummyListbox(self, 'listbox')
        self.subwidget_list['vsb'] = _dummyScrollbar(self, 'vsb')
        self.subwidget_list['hsb'] = _dummyScrollbar(self, 'hsb')

class _dummyHList(HList, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyScrolledHList(ScrolledHList, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)
        self.subwidget_list['hlist'] = _dummyHList(self, 'hlist')
        self.subwidget_list['vsb'] = _dummyScrollbar(self, 'vsb')
        self.subwidget_list['hsb'] = _dummyScrollbar(self, 'hsb')

class _dummyTList(TList, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyComboBox(ComboBox, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, ['fancy',destroy_physically])
        self.subwidget_list['label'] = _dummyLabel(self, 'label')
        self.subwidget_list['entry'] = _dummyEntry(self, 'entry')
        self.subwidget_list['arrow'] = _dummyButton(self, 'arrow')

        self.subwidget_list['slistbox'] = _dummyScrolledListBox(self,
                                                                'slistbox')
        try:
            self.subwidget_list['tick'] = _dummyButton(self, 'tick')
            #cross Button : present if created with the fancy option
            self.subwidget_list['cross'] = _dummyButton(self, 'cross')
        except TypeError:
            # unavailable when -fancy not specified
            pass

class _dummyDirList(DirList, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)
        self.subwidget_list['hlist'] = _dummyHList(self, 'hlist')
        self.subwidget_list['vsb'] = _dummyScrollbar(self, 'vsb')
        self.subwidget_list['hsb'] = _dummyScrollbar(self, 'hsb')

class _dummyDirSelectBox(DirSelectBox, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)
        self.subwidget_list['dirlist'] = _dummyDirList(self, 'dirlist')
        self.subwidget_list['dircbx'] = _dummyFileComboBox(self, 'dircbx')

class _dummyExFileSelectBox(ExFileSelectBox, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)
        self.subwidget_list['cancel'] = _dummyButton(self, 'cancel')
        self.subwidget_list['ok'] = _dummyButton(self, 'ok')
        self.subwidget_list['hidden'] = _dummyCheckbutton(self, 'hidden')
        self.subwidget_list['types'] = _dummyComboBox(self, 'types')
        self.subwidget_list['dir'] = _dummyComboBox(self, 'dir')
        self.subwidget_list['dirlist'] = _dummyScrolledListBox(self, 'dirlist')
        self.subwidget_list['file'] = _dummyComboBox(self, 'file')
        self.subwidget_list['filelist'] = _dummyScrolledListBox(self, 'filelist')

class _dummyFileSelectBox(FileSelectBox, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)
        self.subwidget_list['dirlist'] = _dummyScrolledListBox(self, 'dirlist')
        self.subwidget_list['filelist'] = _dummyScrolledListBox(self, 'filelist')
        self.subwidget_list['filter'] = _dummyComboBox(self, 'filter')
        self.subwidget_list['selection'] = _dummyComboBox(self, 'selection')

class _dummyFileComboBox(ComboBox, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)
        self.subwidget_list['dircbx'] = _dummyComboBox(self, 'dircbx')

class _dummyStdButtonBox(StdButtonBox, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)
        self.subwidget_list['ok'] = _dummyButton(self, 'ok')
        self.subwidget_list['apply'] = _dummyButton(self, 'apply')
        self.subwidget_list['cancel'] = _dummyButton(self, 'cancel')
        self.subwidget_list['help'] = _dummyButton(self, 'help')

class _dummyNoteBookFrame(NoteBookFrame, TixSubWidget):
    def __init__(self, master, name, destroy_physically=0):
        TixSubWidget.__init__(self, master, name, destroy_physically)

class _dummyPanedWindow(PanedWindow, TixSubWidget):
    def __init__(self, master, name, destroy_physically=1):
        TixSubWidget.__init__(self, master, name, destroy_physically)

########################
### Utility Routines ###
########################

#mike Should tixDestroy be exposed as a wrapper? - but not for widgets.

def OptionName(widget):
    '''Returns the qualified path name for the widget. Normally used to set
    default options for subwidgets. See tixwidgets.py'''
    return widget.tk.call('tixOptionName', widget._w)

# Called with a dictionary argument of the form
# {'*.c':'C source files', '*.txt':'Text Files', '*':'All files'}
# returns a string which can be used to configure the fsbox file types
# in an ExFileSelectBox. i.e.,
# '{{*} {* - All files}} {{*.c} {*.c - C source files}} {{*.txt} {*.txt - Text Files}}'
def FileTypeList(dict):
    s = ''
    for type in dict.keys():
        s = s + '{{' + type + '} {' + type + ' - ' + dict[type] + '}} '
    return s

# Still to be done:
# tixIconView
class CObjView(TixWidget):
    """This file implements the Canvas Object View widget. This is a base
    class of IconView. It implements automatic placement/adjustment of the
    scrollbars according to the canvas objects inside the canvas subwidget.
    The scrollbars are adjusted so that the canvas is just large enough
    to see all the objects.
    """
    # FIXME: It should inherit -superclass tixScrolledWidget
    pass


class Grid(TixWidget, XView, YView):
    '''The Tix Grid command creates a new window  and makes it into a
    tixGrid widget. Additional options, may be specified on the command
    line or in the option database to configure aspects such as its cursor
    and relief.

    A Grid widget displays its contents in a two dimensional grid of cells.
    Each cell may contain one Tix display item, which may be in text,
    graphics or other formats. See the DisplayStyle class for more information
    about Tix display items. Individual cells, or groups of cells, can be
    formatted with a wide range of attributes, such as its color, relief and
    border.

    Subwidgets - None'''
    # valid specific resources as of Tk 8.4
    # editdonecmd, editnotifycmd, floatingcols, floatingrows, formatcmd,
    # highlightbackground, highlightcolor, leftmargin, itemtype, selectmode,
    # selectunit, topmargin,
    def __init__(self, master=None, cnf={}, **kw):
        static= []
        self.cnf= cnf
        TixWidget.__init__(self, master, 'tixGrid', static, cnf, kw)

    # valid options as of Tk 8.4
    # anchor, bdtype, cget, configure, delete, dragsite, dropsite, entrycget,
    # edit, entryconfigure, format, geometryinfo, info, index, move, nearest,
    # selection, set, size, unset, xview, yview
    def anchor_clear(self):
        """Removes the selection anchor."""
        self.tk.call(self, 'anchor', 'clear')

    def anchor_get(self):
        "Get the (x,y) coordinate of the current anchor cell"
        return self._getints(self.tk.call(self, 'anchor', 'get'))

    def anchor_set(self, x, y):
        """Set the selection anchor to the cell at (x, y)."""
        self.tk.call(self, 'anchor', 'set', x, y)

    def delete_row(self, from_, to=None):
        """Delete rows between from_ and to inclusive.
        If to is not provided,  delete only row at from_"""
        if to is None:
            self.tk.call(self, 'delete', 'row', from_)
        else:
            self.tk.call(self, 'delete', 'row', from_, to)

    def delete_column(self, from_, to=None):
        """Delete columns between from_ and to inclusive.
        If to is not provided,  delete only column at from_"""
        if to is None:
            self.tk.call(self, 'delete', 'column', from_)
        else:
            self.tk.call(self, 'delete', 'column', from_, to)

    def edit_apply(self):
        """If any cell is being edited, de-highlight the cell  and  applies
        the changes."""
        self.tk.call(self, 'edit', 'apply')

    def edit_set(self, x, y):
        """Highlights  the  cell  at  (x, y) for editing, if the -editnotify
        command returns True for this cell."""
        self.tk.call(self, 'edit', 'set', x, y)

    def entrycget(self, x, y, option):
        "Get the option value for cell at (x,y)"
        if option and option[0] != '-':
            option = '-' + option
        return self.tk.call(self, 'entrycget', x, y, option)

    def entryconfigure(self, x, y, cnf=None, **kw):
        return self._configure(('entryconfigure', x, y), cnf, kw)

    # def format
    # def index

    def info_exists(self, x, y):
        "Return True if display item exists at (x,y)"
        return self._getboolean(self.tk.call(self, 'info', 'exists', x, y))

    def info_bbox(self, x, y):
        # This seems to always return '', at least for 'text' displayitems
        return self.tk.call(self, 'info', 'bbox', x, y)

    def move_column(self, from_, to, offset):
        """Moves the range of columns from position FROM through TO by
        the distance indicated by OFFSET. For example, move_column(2, 4, 1)
        moves the columns 2,3,4 to columns 3,4,5."""
        self.tk.call(self, 'move', 'column', from_, to, offset)

    def move_row(self, from_, to, offset):
        """Moves the range of rows from position FROM through TO by
        the distance indicated by OFFSET.
        For example, move_row(2, 4, 1) moves the rows 2,3,4 to rows 3,4,5."""
        self.tk.call(self, 'move', 'row', from_, to, offset)

    def nearest(self, x, y):
        "Return coordinate of cell nearest pixel coordinate (x,y)"
        return self._getints(self.tk.call(self, 'nearest', x, y))

    # def selection adjust
    # def selection clear
    # def selection includes
    # def selection set
    # def selection toggle

    def set(self, x, y, itemtype=None, **kw):
        args= self._options(self.cnf, kw)
        if itemtype is not None:
            args= ('-itemtype', itemtype) + args
        self.tk.call(self, 'set', x, y, *args)

    def size_column(self, index, **kw):
        """Queries or sets the size of the column given by
        INDEX.  INDEX may be any non-negative
        integer that gives the position of a given column.
        INDEX can also be the string "default"; in this case, this command
        queries or sets the default size of all columns.
        When no option-value pair is given, this command returns a tuple
        containing the current size setting of the given column.  When
        option-value pairs are given, the corresponding options of the
        size setting of the given column are changed. Options may be one
        of the follwing:
              pad0 pixels
                     Specifies the paddings to the left of a column.
              pad1 pixels
                     Specifies the paddings to the right of a column.
              size val
                     Specifies the width of a column.  Val may be:
                     "auto" -- the width of the column is set to the
                     width of the widest cell in the column;
                     a valid Tk screen distance unit;
                     or a real number following by the word chars
                     (e.g. 3.4chars) that sets the width of the column to the
                     given number of characters."""
        return self.tk.split(self.tk.call(self._w, 'size', 'column', index,
                             *self._options({}, kw)))

    def size_row(self, index, **kw):
        """Queries or sets the size of the row given by
        INDEX. INDEX may be any non-negative
        integer that gives the position of a given row .
        INDEX can also be the string "default"; in this case, this command
        queries or sets the default size of all rows.
        When no option-value pair is given, this command returns a list con-
        taining the current size setting of the given row . When option-value
        pairs are given, the corresponding options of the size setting of the
        given row are changed. Options may be one of the follwing:
              pad0 pixels
                     Specifies the paddings to the top of a row.
              pad1 pixels
                     Specifies the paddings to the bottom of a row.
              size val
                     Specifies the height of a row.  Val may be:
                     "auto" -- the height of the row is set to the
                     height of the highest cell in the row;
                     a valid Tk screen distance unit;
                     or a real number following by the word chars
                     (e.g. 3.4chars) that sets the height of the row to the
                     given number of characters."""
        return self.tk.split(self.tk.call(
                    self, 'size', 'row', index, *self._options({}, kw)))

    def unset(self, x, y):
        """Clears the cell at (x, y) by removing its display item."""
        self.tk.call(self._w, 'unset', x, y)


class ScrolledGrid(Grid):
    '''Scrolled Grid widgets'''

    # FIXME: It should inherit -superclass tixScrolledWidget
    def __init__(self, master=None, cnf={}, **kw):
        static= []
        self.cnf= cnf
        TixWidget.__init__(self, master, 'tixScrolledGrid', static, cnf, kw)
                                                                                                                                                                                                                                                                                                  usr/lib/python3.4/tkinter/ttk.py                                                                    0100644 0000000 0000000 00000154642 12415221636 015244  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Ttk wrapper.

This module provides classes to allow using Tk themed widget set.

Ttk is based on a revised and enhanced version of
TIP #48 (http://tip.tcl.tk/48) specified style engine.

Its basic idea is to separate, to the extent possible, the code
implementing a widget's behavior from the code implementing its
appearance. Widget class bindings are primarily responsible for
maintaining the widget state and invoking callbacks, all aspects
of the widgets appearance lies at Themes.
"""

__version__ = "0.3.1"

__author__ = "Guilherme Polo <ggpolo@gmail.com>"

__all__ = ["Button", "Checkbutton", "Combobox", "Entry", "Frame", "Label",
           "Labelframe", "LabelFrame", "Menubutton", "Notebook", "Panedwindow",
           "PanedWindow", "Progressbar", "Radiobutton", "Scale", "Scrollbar",
           "Separator", "Sizegrip", "Style", "Treeview",
           # Extensions
           "LabeledScale", "OptionMenu",
           # functions
           "tclobjs_to_py", "setup_master"]

import tkinter
from tkinter import _flatten, _join, _stringify, _splitdict

# Verify if Tk is new enough to not need the Tile package
_REQUIRE_TILE = True if tkinter.TkVersion < 8.5 else False

def _load_tile(master):
    if _REQUIRE_TILE:
        import os
        tilelib = os.environ.get('TILE_LIBRARY')
        if tilelib:
            # append custom tile path to the list of directories that
            # Tcl uses when attempting to resolve packages with the package
            # command
            master.tk.eval(
                    'global auto_path; '
                    'lappend auto_path {%s}' % tilelib)

        master.tk.eval('package require tile') # TclError may be raised here
        master._tile_loaded = True

def _format_optvalue(value, script=False):
    """Internal function."""
    if script:
        # if caller passes a Tcl script to tk.call, all the values need to
        # be grouped into words (arguments to a command in Tcl dialect)
        value = _stringify(value)
    elif isinstance(value, (list, tuple)):
        value = _join(value)
    return value

def _format_optdict(optdict, script=False, ignore=None):
    """Formats optdict to a tuple to pass it to tk.call.

    E.g. (script=False):
      {'foreground': 'blue', 'padding': [1, 2, 3, 4]} returns:
      ('-foreground', 'blue', '-padding', '1 2 3 4')"""

    opts = []
    for opt, value in optdict.items():
        if not ignore or opt not in ignore:
            opts.append("-%s" % opt)
            if value is not None:
                opts.append(_format_optvalue(value, script))

    return _flatten(opts)

def _mapdict_values(items):
    # each value in mapdict is expected to be a sequence, where each item
    # is another sequence containing a state (or several) and a value
    # E.g. (script=False):
    #   [('active', 'selected', 'grey'), ('focus', [1, 2, 3, 4])]
    #   returns:
    #   ['active selected', 'grey', 'focus', [1, 2, 3, 4]]
    opt_val = []
    for *state, val in items:
        # hacks for bakward compatibility
        state[0] # raise IndexError if empty
        if len(state) == 1:
            # if it is empty (something that evaluates to False), then
            # format it to Tcl code to denote the "normal" state
            state = state[0] or ''
        else:
            # group multiple states
            state = ' '.join(state) # raise TypeError if not str
        opt_val.append(state)
        if val is not None:
            opt_val.append(val)
    return opt_val

def _format_mapdict(mapdict, script=False):
    """Formats mapdict to pass it to tk.call.

    E.g. (script=False):
      {'expand': [('active', 'selected', 'grey'), ('focus', [1, 2, 3, 4])]}

      returns:

      ('-expand', '{active selected} grey focus {1, 2, 3, 4}')"""

    opts = []
    for opt, value in mapdict.items():
        opts.extend(("-%s" % opt,
                     _format_optvalue(_mapdict_values(value), script)))

    return _flatten(opts)

def _format_elemcreate(etype, script=False, *args, **kw):
    """Formats args and kw according to the given element factory etype."""
    spec = None
    opts = ()
    if etype in ("image", "vsapi"):
        if etype == "image": # define an element based on an image
            # first arg should be the default image name
            iname = args[0]
            # next args, if any, are statespec/value pairs which is almost
            # a mapdict, but we just need the value
            imagespec = _join(_mapdict_values(args[1:]))
            spec = "%s %s" % (iname, imagespec)

        else:
            # define an element whose visual appearance is drawn using the
            # Microsoft Visual Styles API which is responsible for the
            # themed styles on Windows XP and Vista.
            # Availability: Tk 8.6, Windows XP and Vista.
            class_name, part_id = args[:2]
            statemap = _join(_mapdict_values(args[2:]))
            spec = "%s %s %s" % (class_name, part_id, statemap)

        opts = _format_optdict(kw, script)

    elif etype == "from": # clone an element
        # it expects a themename and optionally an element to clone from,
        # otherwise it will clone {} (empty element)
        spec = args[0] # theme name
        if len(args) > 1: # elementfrom specified
            opts = (_format_optvalue(args[1], script),)

    if script:
        spec = '{%s}' % spec
        opts = ' '.join(opts)

    return spec, opts

def _format_layoutlist(layout, indent=0, indent_size=2):
    """Formats a layout list so we can pass the result to ttk::style
    layout and ttk::style settings. Note that the layout doesn't has to
    be a list necessarily.

    E.g.:
      [("Menubutton.background", None),
       ("Menubutton.button", {"children":
           [("Menubutton.focus", {"children":
               [("Menubutton.padding", {"children":
                [("Menubutton.label", {"side": "left", "expand": 1})]
               })]
           })]
       }),
       ("Menubutton.indicator", {"side": "right"})
      ]

      returns:

      Menubutton.background
      Menubutton.button -children {
        Menubutton.focus -children {
          Menubutton.padding -children {
            Menubutton.label -side left -expand 1
          }
        }
      }
      Menubutton.indicator -side right"""
    script = []

    for layout_elem in layout:
        elem, opts = layout_elem
        opts = opts or {}
        fopts = ' '.join(_format_optdict(opts, True, ("children",)))
        head = "%s%s%s" % (' ' * indent, elem, (" %s" % fopts) if fopts else '')

        if "children" in opts:
            script.append(head + " -children {")
            indent += indent_size
            newscript, indent = _format_layoutlist(opts['children'], indent,
                indent_size)
            script.append(newscript)
            indent -= indent_size
            script.append('%s}' % (' ' * indent))
        else:
            script.append(head)

    return '\n'.join(script), indent

def _script_from_settings(settings):
    """Returns an appropriate script, based on settings, according to
    theme_settings definition to be used by theme_settings and
    theme_create."""
    script = []
    # a script will be generated according to settings passed, which
    # will then be evaluated by Tcl
    for name, opts in settings.items():
        # will format specific keys according to Tcl code
        if opts.get('configure'): # format 'configure'
            s = ' '.join(_format_optdict(opts['configure'], True))
            script.append("ttk::style configure %s %s;" % (name, s))

        if opts.get('map'): # format 'map'
            s = ' '.join(_format_mapdict(opts['map'], True))
            script.append("ttk::style map %s %s;" % (name, s))

        if 'layout' in opts: # format 'layout' which may be empty
            if not opts['layout']:
                s = 'null' # could be any other word, but this one makes sense
            else:
                s, _ = _format_layoutlist(opts['layout'])
            script.append("ttk::style layout %s {\n%s\n}" % (name, s))

        if opts.get('element create'): # format 'element create'
            eopts = opts['element create']
            etype = eopts[0]

            # find where args end, and where kwargs start
            argc = 1 # etype was the first one
            while argc < len(eopts) and not hasattr(eopts[argc], 'items'):
                argc += 1

            elemargs = eopts[1:argc]
            elemkw = eopts[argc] if argc < len(eopts) and eopts[argc] else {}
            spec, opts = _format_elemcreate(etype, True, *elemargs, **elemkw)

            script.append("ttk::style element create %s %s %s %s" % (
                name, etype, spec, opts))

    return '\n'.join(script)

def _list_from_statespec(stuple):
    """Construct a list from the given statespec tuple according to the
    accepted statespec accepted by _format_mapdict."""
    nval = []
    for val in stuple:
        typename = getattr(val, 'typename', None)
        if typename is None:
            nval.append(val)
        else: # this is a Tcl object
            val = str(val)
            if typename == 'StateSpec':
                val = val.split()
            nval.append(val)

    it = iter(nval)
    return [_flatten(spec) for spec in zip(it, it)]

def _list_from_layouttuple(tk, ltuple):
    """Construct a list from the tuple returned by ttk::layout, this is
    somewhat the reverse of _format_layoutlist."""
    ltuple = tk.splitlist(ltuple)
    res = []

    indx = 0
    while indx < len(ltuple):
        name = ltuple[indx]
        opts = {}
        res.append((name, opts))
        indx += 1

        while indx < len(ltuple): # grab name's options
            opt, val = ltuple[indx:indx + 2]
            if not opt.startswith('-'): # found next name
                break

            opt = opt[1:] # remove the '-' from the option
            indx += 2

            if opt == 'children':
                val = _list_from_layouttuple(tk, val)

            opts[opt] = val

    return res

def _val_or_dict(tk, options, *args):
    """Format options then call Tk command with args and options and return
    the appropriate result.

    If no option is specified, a dict is returned. If a option is
    specified with the None value, the value for that option is returned.
    Otherwise, the function just sets the passed options and the caller
    shouldn't be expecting a return value anyway."""
    options = _format_optdict(options)
    res = tk.call(*(args + options))

    if len(options) % 2: # option specified without a value, return its value
        return res

    return _splitdict(tk, res, conv=_tclobj_to_py)

def _convert_stringval(value):
    """Converts a value to, hopefully, a more appropriate Python object."""
    value = str(value)
    try:
        value = int(value)
    except (ValueError, TypeError):
        pass

    return value

def _to_number(x):
    if isinstance(x, str):
        if '.' in x:
            x = float(x)
        else:
            x = int(x)
    return x

def _tclobj_to_py(val):
    """Return value converted from Tcl object to Python object."""
    if val and hasattr(val, '__len__') and not isinstance(val, str):
        if getattr(val[0], 'typename', None) == 'StateSpec':
            val = _list_from_statespec(val)
        else:
            val = list(map(_convert_stringval, val))

    elif hasattr(val, 'typename'): # some other (single) Tcl object
        val = _convert_stringval(val)

    return val

def tclobjs_to_py(adict):
    """Returns adict with its values converted from Tcl objects to Python
    objects."""
    for opt, val in adict.items():
        adict[opt] = _tclobj_to_py(val)

    return adict

def setup_master(master=None):
    """If master is not None, itself is returned. If master is None,
    the default master is returned if there is one, otherwise a new
    master is created and returned.

    If it is not allowed to use the default root and master is None,
    RuntimeError is raised."""
    if master is None:
        if tkinter._support_default_root:
            master = tkinter._default_root or tkinter.Tk()
        else:
            raise RuntimeError(
                    "No master specified and tkinter is "
                    "configured to not support default root")
    return master


class Style(object):
    """Manipulate style database."""

    _name = "ttk::style"

    def __init__(self, master=None):
        master = setup_master(master)

        if not getattr(master, '_tile_loaded', False):
            # Load tile now, if needed
            _load_tile(master)

        self.master = master
        self.tk = self.master.tk


    def configure(self, style, query_opt=None, **kw):
        """Query or sets the default value of the specified option(s) in
        style.

        Each key in kw is an option and each value is either a string or
        a sequence identifying the value for that option."""
        if query_opt is not None:
            kw[query_opt] = None
        return _val_or_dict(self.tk, kw, self._name, "configure", style)


    def map(self, style, query_opt=None, **kw):
        """Query or sets dynamic values of the specified option(s) in
        style.

        Each key in kw is an option and each value should be a list or a
        tuple (usually) containing statespecs grouped in tuples, or list,
        or something else of your preference. A statespec is compound of
        one or more states and then a value."""
        if query_opt is not None:
            return _list_from_statespec(self.tk.splitlist(
                self.tk.call(self._name, "map", style, '-%s' % query_opt)))

        return _splitdict(
            self.tk,
            self.tk.call(self._name, "map", style, *_format_mapdict(kw)),
            conv=_tclobj_to_py)


    def lookup(self, style, option, state=None, default=None):
        """Returns the value specified for option in style.

        If state is specified it is expected to be a sequence of one
        or more states. If the default argument is set, it is used as
        a fallback value in case no specification for option is found."""
        state = ' '.join(state) if state else ''

        return self.tk.call(self._name, "lookup", style, '-%s' % option,
            state, default)


    def layout(self, style, layoutspec=None):
        """Define the widget layout for given style. If layoutspec is
        omitted, return the layout specification for given style.

        layoutspec is expected to be a list or an object different than
        None that evaluates to False if you want to "turn off" that style.
        If it is a list (or tuple, or something else), each item should be
        a tuple where the first item is the layout name and the second item
        should have the format described below:

        LAYOUTS

            A layout can contain the value None, if takes no options, or
            a dict of options specifying how to arrange the element.
            The layout mechanism uses a simplified version of the pack
            geometry manager: given an initial cavity, each element is
            allocated a parcel. Valid options/values are:

                side: whichside
                    Specifies which side of the cavity to place the
                    element; one of top, right, bottom or left. If
                    omitted, the element occupies the entire cavity.

                sticky: nswe
                    Specifies where the element is placed inside its
                    allocated parcel.

                children: [sublayout... ]
                    Specifies a list of elements to place inside the
                    element. Each element is a tuple (or other sequence)
                    where the first item is the layout name, and the other
                    is a LAYOUT."""
        lspec = None
        if layoutspec:
            lspec = _format_layoutlist(layoutspec)[0]
        elif layoutspec is not None: # will disable the layout ({}, '', etc)
            lspec = "null" # could be any other word, but this may make sense
                           # when calling layout(style) later

        return _list_from_layouttuple(self.tk,
            self.tk.call(self._name, "layout", style, lspec))


    def element_create(self, elementname, etype, *args, **kw):
        """Create a new element in the current theme of given etype."""
        spec, opts = _format_elemcreate(etype, False, *args, **kw)
        self.tk.call(self._name, "element", "create", elementname, etype,
            spec, *opts)


    def element_names(self):
        """Returns the list of elements defined in the current theme."""
        return self.tk.splitlist(self.tk.call(self._name, "element", "names"))


    def element_options(self, elementname):
        """Return the list of elementname's options."""
        return self.tk.splitlist(self.tk.call(self._name, "element", "options", elementname))


    def theme_create(self, themename, parent=None, settings=None):
        """Creates a new theme.

        It is an error if themename already exists. If parent is
        specified, the new theme will inherit styles, elements and
        layouts from the specified parent theme. If settings are present,
        they are expected to have the same syntax used for theme_settings."""
        script = _script_from_settings(settings) if settings else ''

        if parent:
            self.tk.call(self._name, "theme", "create", themename,
                "-parent", parent, "-settings", script)
        else:
            self.tk.call(self._name, "theme", "create", themename,
                "-settings", script)


    def theme_settings(self, themename, settings):
        """Temporarily sets the current theme to themename, apply specified
        settings and then restore the previous theme.

        Each key in settings is a style and each value may contain the
        keys 'configure', 'map', 'layout' and 'element create' and they
        are expected to have the same format as specified by the methods
        configure, map, layout and element_create respectively."""
        script = _script_from_settings(settings)
        self.tk.call(self._name, "theme", "settings", themename, script)


    def theme_names(self):
        """Returns a list of all known themes."""
        return self.tk.splitlist(self.tk.call(self._name, "theme", "names"))


    def theme_use(self, themename=None):
        """If themename is None, returns the theme in use, otherwise, set
        the current theme to themename, refreshes all widgets and emits
        a <<ThemeChanged>> event."""
        if themename is None:
            # Starting on Tk 8.6, checking this global is no longer needed
            # since it allows doing self.tk.call(self._name, "theme", "use")
            return self.tk.eval("return $ttk::currentTheme")

        # using "ttk::setTheme" instead of "ttk::style theme use" causes
        # the variable currentTheme to be updated, also, ttk::setTheme calls
        # "ttk::style theme use" in order to change theme.
        self.tk.call("ttk::setTheme", themename)


class Widget(tkinter.Widget):
    """Base class for Tk themed widgets."""

    def __init__(self, master, widgetname, kw=None):
        """Constructs a Ttk Widget with the parent master.

        STANDARD OPTIONS

            class, cursor, takefocus, style

        SCROLLABLE WIDGET OPTIONS

            xscrollcommand, yscrollcommand

        LABEL WIDGET OPTIONS

            text, textvariable, underline, image, compound, width

        WIDGET STATES

            active, disabled, focus, pressed, selected, background,
            readonly, alternate, invalid
        """
        master = setup_master(master)
        if not getattr(master, '_tile_loaded', False):
            # Load tile now, if needed
            _load_tile(master)
        tkinter.Widget.__init__(self, master, widgetname, kw=kw)


    def identify(self, x, y):
        """Returns the name of the element at position x, y, or the empty
        string if the point does not lie within any element.

        x and y are pixel coordinates relative to the widget."""
        return self.tk.call(self._w, "identify", x, y)


    def instate(self, statespec, callback=None, *args, **kw):
        """Test the widget's state.

        If callback is not specified, returns True if the widget state
        matches statespec and False otherwise. If callback is specified,
        then it will be invoked with *args, **kw if the widget state
        matches statespec. statespec is expected to be a sequence."""
        ret = self.tk.getboolean(
                self.tk.call(self._w, "instate", ' '.join(statespec)))
        if ret and callback:
            return callback(*args, **kw)

        return bool(ret)


    def state(self, statespec=None):
        """Modify or inquire widget state.

        Widget state is returned if statespec is None, otherwise it is
        set according to the statespec flags and then a new state spec
        is returned indicating which flags were changed. statespec is
        expected to be a sequence."""
        if statespec is not None:
            statespec = ' '.join(statespec)

        return self.tk.splitlist(str(self.tk.call(self._w, "state", statespec)))


class Button(Widget):
    """Ttk Button widget, displays a textual label and/or image, and
    evaluates a command when pressed."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Button widget with the parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            command, default, width
        """
        Widget.__init__(self, master, "ttk::button", kw)


    def invoke(self):
        """Invokes the command associated with the button."""
        return self.tk.call(self._w, "invoke")


class Checkbutton(Widget):
    """Ttk Checkbutton widget which is either in on- or off-state."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Checkbutton widget with the parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            command, offvalue, onvalue, variable
        """
        Widget.__init__(self, master, "ttk::checkbutton", kw)


    def invoke(self):
        """Toggles between the selected and deselected states and
        invokes the associated command. If the widget is currently
        selected, sets the option variable to the offvalue option
        and deselects the widget; otherwise, sets the option variable
        to the option onvalue.

        Returns the result of the associated command."""
        return self.tk.call(self._w, "invoke")


class Entry(Widget, tkinter.Entry):
    """Ttk Entry widget displays a one-line text string and allows that
    string to be edited by the user."""

    def __init__(self, master=None, widget=None, **kw):
        """Constructs a Ttk Entry widget with the parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus, xscrollcommand

        WIDGET-SPECIFIC OPTIONS

            exportselection, invalidcommand, justify, show, state,
            textvariable, validate, validatecommand, width

        VALIDATION MODES

            none, key, focus, focusin, focusout, all
        """
        Widget.__init__(self, master, widget or "ttk::entry", kw)


    def bbox(self, index):
        """Return a tuple of (x, y, width, height) which describes the
        bounding box of the character given by index."""
        return self._getints(self.tk.call(self._w, "bbox", index))


    def identify(self, x, y):
        """Returns the name of the element at position x, y, or the
        empty string if the coordinates are outside the window."""
        return self.tk.call(self._w, "identify", x, y)


    def validate(self):
        """Force revalidation, independent of the conditions specified
        by the validate option. Returns False if validation fails, True
        if it succeeds. Sets or clears the invalid state accordingly."""
        return bool(self.tk.getboolean(self.tk.call(self._w, "validate")))


class Combobox(Entry):
    """Ttk Combobox widget combines a text field with a pop-down list of
    values."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Combobox widget with the parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            exportselection, justify, height, postcommand, state,
            textvariable, values, width
        """
        Entry.__init__(self, master, "ttk::combobox", **kw)


    def current(self, newindex=None):
        """If newindex is supplied, sets the combobox value to the
        element at position newindex in the list of values. Otherwise,
        returns the index of the current value in the list of values
        or -1 if the current value does not appear in the list."""
        if newindex is None:
            return self.tk.getint(self.tk.call(self._w, "current"))
        return self.tk.call(self._w, "current", newindex)


    def set(self, value):
        """Sets the value of the combobox to value."""
        self.tk.call(self._w, "set", value)


class Frame(Widget):
    """Ttk Frame widget is a container, used to group other widgets
    together."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Frame with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            borderwidth, relief, padding, width, height
        """
        Widget.__init__(self, master, "ttk::frame", kw)


class Label(Widget):
    """Ttk Label widget displays a textual label and/or image."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Label with parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, style, takefocus, text,
            textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            anchor, background, font, foreground, justify, padding,
            relief, text, wraplength
        """
        Widget.__init__(self, master, "ttk::label", kw)


class Labelframe(Widget):
    """Ttk Labelframe widget is a container used to group other widgets
    together. It has an optional label, which may be a plain text string
    or another widget."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Labelframe with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS
            labelanchor, text, underline, padding, labelwidget, width,
            height
        """
        Widget.__init__(self, master, "ttk::labelframe", kw)

LabelFrame = Labelframe # tkinter name compatibility


class Menubutton(Widget):
    """Ttk Menubutton widget displays a textual label and/or image, and
    displays a menu when pressed."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Menubutton with parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            direction, menu
        """
        Widget.__init__(self, master, "ttk::menubutton", kw)


class Notebook(Widget):
    """Ttk Notebook widget manages a collection of windows and displays
    a single one at a time. Each child window is associated with a tab,
    which the user may select to change the currently-displayed window."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Notebook with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            height, padding, width

        TAB OPTIONS

            state, sticky, padding, text, image, compound, underline

        TAB IDENTIFIERS (tab_id)

            The tab_id argument found in several methods may take any of
            the following forms:

                * An integer between zero and the number of tabs
                * The name of a child window
                * A positional specification of the form "@x,y", which
                  defines the tab
                * The string "current", which identifies the
                  currently-selected tab
                * The string "end", which returns the number of tabs (only
                  valid for method index)
        """
        Widget.__init__(self, master, "ttk::notebook", kw)


    def add(self, child, **kw):
        """Adds a new tab to the notebook.

        If window is currently managed by the notebook but hidden, it is
        restored to its previous position."""
        self.tk.call(self._w, "add", child, *(_format_optdict(kw)))


    def forget(self, tab_id):
        """Removes the tab specified by tab_id, unmaps and unmanages the
        associated window."""
        self.tk.call(self._w, "forget", tab_id)


    def hide(self, tab_id):
        """Hides the tab specified by tab_id.

        The tab will not be displayed, but the associated window remains
        managed by the notebook and its configuration remembered. Hidden
        tabs may be restored with the add command."""
        self.tk.call(self._w, "hide", tab_id)


    def identify(self, x, y):
        """Returns the name of the tab element at position x, y, or the
        empty string if none."""
        return self.tk.call(self._w, "identify", x, y)


    def index(self, tab_id):
        """Returns the numeric index of the tab specified by tab_id, or
        the total number of tabs if tab_id is the string "end"."""
        return self.tk.getint(self.tk.call(self._w, "index", tab_id))


    def insert(self, pos, child, **kw):
        """Inserts a pane at the specified position.

        pos is either the string end, an integer index, or the name of
        a managed child. If child is already managed by the notebook,
        moves it to the specified position."""
        self.tk.call(self._w, "insert", pos, child, *(_format_optdict(kw)))


    def select(self, tab_id=None):
        """Selects the specified tab.

        The associated child window will be displayed, and the
        previously-selected window (if different) is unmapped. If tab_id
        is omitted, returns the widget name of the currently selected
        pane."""
        return self.tk.call(self._w, "select", tab_id)


    def tab(self, tab_id, option=None, **kw):
        """Query or modify the options of the specific tab_id.

        If kw is not given, returns a dict of the tab option values. If option
        is specified, returns the value of that option. Otherwise, sets the
        options to the corresponding values."""
        if option is not None:
            kw[option] = None
        return _val_or_dict(self.tk, kw, self._w, "tab", tab_id)


    def tabs(self):
        """Returns a list of windows managed by the notebook."""
        return self.tk.splitlist(self.tk.call(self._w, "tabs") or ())


    def enable_traversal(self):
        """Enable keyboard traversal for a toplevel window containing
        this notebook.

        This will extend the bindings for the toplevel window containing
        this notebook as follows:

            Control-Tab: selects the tab following the currently selected
                         one

            Shift-Control-Tab: selects the tab preceding the currently
                               selected one

            Alt-K: where K is the mnemonic (underlined) character of any
                   tab, will select that tab.

        Multiple notebooks in a single toplevel may be enabled for
        traversal, including nested notebooks. However, notebook traversal
        only works properly if all panes are direct children of the
        notebook."""
        # The only, and good, difference I see is about mnemonics, which works
        # after calling this method. Control-Tab and Shift-Control-Tab always
        # works (here at least).
        self.tk.call("ttk::notebook::enableTraversal", self._w)


class Panedwindow(Widget, tkinter.PanedWindow):
    """Ttk Panedwindow widget displays a number of subwindows, stacked
    either vertically or horizontally."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Panedwindow with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            orient, width, height

        PANE OPTIONS

            weight
        """
        Widget.__init__(self, master, "ttk::panedwindow", kw)


    forget = tkinter.PanedWindow.forget # overrides Pack.forget


    def insert(self, pos, child, **kw):
        """Inserts a pane at the specified positions.

        pos is either the string end, and integer index, or the name
        of a child. If child is already managed by the paned window,
        moves it to the specified position."""
        self.tk.call(self._w, "insert", pos, child, *(_format_optdict(kw)))


    def pane(self, pane, option=None, **kw):
        """Query or modify the options of the specified pane.

        pane is either an integer index or the name of a managed subwindow.
        If kw is not given, returns a dict of the pane option values. If
        option is specified then the value for that option is returned.
        Otherwise, sets the options to the corresponding values."""
        if option is not None:
            kw[option] = None
        return _val_or_dict(self.tk, kw, self._w, "pane", pane)


    def sashpos(self, index, newpos=None):
        """If newpos is specified, sets the position of sash number index.

        May adjust the positions of adjacent sashes to ensure that
        positions are monotonically increasing. Sash positions are further
        constrained to be between 0 and the total size of the widget.

        Returns the new position of sash number index."""
        return self.tk.getint(self.tk.call(self._w, "sashpos", index, newpos))

PanedWindow = Panedwindow # tkinter name compatibility


class Progressbar(Widget):
    """Ttk Progressbar widget shows the status of a long-running
    operation. They can operate in two modes: determinate mode shows the
    amount completed relative to the total amount of work to be done, and
    indeterminate mode provides an animated display to let the user know
    that something is happening."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Progressbar with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            orient, length, mode, maximum, value, variable, phase
        """
        Widget.__init__(self, master, "ttk::progressbar", kw)


    def start(self, interval=None):
        """Begin autoincrement mode: schedules a recurring timer event
        that calls method step every interval milliseconds.

        interval defaults to 50 milliseconds (20 steps/second) if ommited."""
        self.tk.call(self._w, "start", interval)


    def step(self, amount=None):
        """Increments the value option by amount.

        amount defaults to 1.0 if omitted."""
        self.tk.call(self._w, "step", amount)


    def stop(self):
        """Stop autoincrement mode: cancels any recurring timer event
        initiated by start."""
        self.tk.call(self._w, "stop")


class Radiobutton(Widget):
    """Ttk Radiobutton widgets are used in groups to show or change a
    set of mutually-exclusive options."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Radiobutton with parent master.

        STANDARD OPTIONS

            class, compound, cursor, image, state, style, takefocus,
            text, textvariable, underline, width

        WIDGET-SPECIFIC OPTIONS

            command, value, variable
        """
        Widget.__init__(self, master, "ttk::radiobutton", kw)


    def invoke(self):
        """Sets the option variable to the option value, selects the
        widget, and invokes the associated command.

        Returns the result of the command, or an empty string if
        no command is specified."""
        return self.tk.call(self._w, "invoke")


class Scale(Widget, tkinter.Scale):
    """Ttk Scale widget is typically used to control the numeric value of
    a linked variable that varies uniformly over some range."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Scale with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            command, from, length, orient, to, value, variable
        """
        Widget.__init__(self, master, "ttk::scale", kw)


    def configure(self, cnf=None, **kw):
        """Modify or query scale options.

        Setting a value for any of the "from", "from_" or "to" options
        generates a <<RangeChanged>> event."""
        if cnf:
            kw.update(cnf)
        Widget.configure(self, **kw)
        if any(['from' in kw, 'from_' in kw, 'to' in kw]):
            self.event_generate('<<RangeChanged>>')


    def get(self, x=None, y=None):
        """Get the current value of the value option, or the value
        corresponding to the coordinates x, y if they are specified.

        x and y are pixel coordinates relative to the scale widget
        origin."""
        return self.tk.call(self._w, 'get', x, y)


class Scrollbar(Widget, tkinter.Scrollbar):
    """Ttk Scrollbar controls the viewport of a scrollable widget."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Scrollbar with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            command, orient
        """
        Widget.__init__(self, master, "ttk::scrollbar", kw)


class Separator(Widget):
    """Ttk Separator widget displays a horizontal or vertical separator
    bar."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Separator with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus

        WIDGET-SPECIFIC OPTIONS

            orient
        """
        Widget.__init__(self, master, "ttk::separator", kw)


class Sizegrip(Widget):
    """Ttk Sizegrip allows the user to resize the containing toplevel
    window by pressing and dragging the grip."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Sizegrip with parent master.

        STANDARD OPTIONS

            class, cursor, state, style, takefocus
        """
        Widget.__init__(self, master, "ttk::sizegrip", kw)


class Treeview(Widget, tkinter.XView, tkinter.YView):
    """Ttk Treeview widget displays a hierarchical collection of items.

    Each item has a textual label, an optional image, and an optional list
    of data values. The data values are displayed in successive columns
    after the tree label."""

    def __init__(self, master=None, **kw):
        """Construct a Ttk Treeview with parent master.

        STANDARD OPTIONS

            class, cursor, style, takefocus, xscrollcommand,
            yscrollcommand

        WIDGET-SPECIFIC OPTIONS

            columns, displaycolumns, height, padding, selectmode, show

        ITEM OPTIONS

            text, image, values, open, tags

        TAG OPTIONS

            foreground, background, font, image
        """
        Widget.__init__(self, master, "ttk::treeview", kw)


    def bbox(self, item, column=None):
        """Returns the bounding box (relative to the treeview widget's
        window) of the specified item in the form x y width height.

        If column is specified, returns the bounding box of that cell.
        If the item is not visible (i.e., if it is a descendant of a
        closed item or is scrolled offscreen), returns an empty string."""
        return self._getints(self.tk.call(self._w, "bbox", item, column)) or ''


    def get_children(self, item=None):
        """Returns a tuple of children belonging to item.

        If item is not specified, returns root children."""
        return self.tk.splitlist(
                self.tk.call(self._w, "children", item or '') or ())


    def set_children(self, item, *newchildren):
        """Replaces item's child with newchildren.

        Children present in item that are not present in newchildren
        are detached from tree. No items in newchildren may be an
        ancestor of item."""
        self.tk.call(self._w, "children", item, newchildren)


    def column(self, column, option=None, **kw):
        """Query or modify the options for the specified column.

        If kw is not given, returns a dict of the column option values. If
        option is specified then the value for that option is returned.
        Otherwise, sets the options to the corresponding values."""
        if option is not None:
            kw[option] = None
        return _val_or_dict(self.tk, kw, self._w, "column", column)


    def delete(self, *items):
        """Delete all specified items and all their descendants. The root
        item may not be deleted."""
        self.tk.call(self._w, "delete", items)


    def detach(self, *items):
        """Unlinks all of the specified items from the tree.

        The items and all of their descendants are still present, and may
        be reinserted at another point in the tree, but will not be
        displayed. The root item may not be detached."""
        self.tk.call(self._w, "detach", items)


    def exists(self, item):
        """Returns True if the specified item is present in the tree,
        False otherwise."""
        return bool(self.tk.getboolean(self.tk.call(self._w, "exists", item)))


    def focus(self, item=None):
        """If item is specified, sets the focus item to item. Otherwise,
        returns the current focus item, or '' if there is none."""
        return self.tk.call(self._w, "focus", item)


    def heading(self, column, option=None, **kw):
        """Query or modify the heading options for the specified column.

        If kw is not given, returns a dict of the heading option values. If
        option is specified then the value for that option is returned.
        Otherwise, sets the options to the corresponding values.

        Valid options/values are:
            text: text
                The text to display in the column heading
            image: image_name
                Specifies an image to display to the right of the column
                heading
            anchor: anchor
                Specifies how the heading text should be aligned. One of
                the standard Tk anchor values
            command: callback
                A callback to be invoked when the heading label is
                pressed.

        To configure the tree column heading, call this with column = "#0" """
        cmd = kw.get('command')
        if cmd and not isinstance(cmd, str):
            # callback not registered yet, do it now
            kw['command'] = self.master.register(cmd, self._substitute)

        if option is not None:
            kw[option] = None

        return _val_or_dict(self.tk, kw, self._w, 'heading', column)


    def identify(self, component, x, y):
        """Returns a description of the specified component under the
        point given by x and y, or the empty string if no such component
        is present at that position."""
        return self.tk.call(self._w, "identify", component, x, y)


    def identify_row(self, y):
        """Returns the item ID of the item at position y."""
        return self.identify("row", 0, y)


    def identify_column(self, x):
        """Returns the data column identifier of the cell at position x.

        The tree column has ID #0."""
        return self.identify("column", x, 0)


    def identify_region(self, x, y):
        """Returns one of:

        heading: Tree heading area.
        separator: Space between two columns headings;
        tree: The tree area.
        cell: A data cell.

        * Availability: Tk 8.6"""
        return self.identify("region", x, y)


    def identify_element(self, x, y):
        """Returns the element at position x, y.

        * Availability: Tk 8.6"""
        return self.identify("element", x, y)


    def index(self, item):
        """Returns the integer index of item within its parent's list
        of children."""
        return self.tk.getint(self.tk.call(self._w, "index", item))


    def insert(self, parent, index, iid=None, **kw):
        """Creates a new item and return the item identifier of the newly
        created item.

        parent is the item ID of the parent item, or the empty string
        to create a new top-level item. index is an integer, or the value
        end, specifying where in the list of parent's children to insert
        the new item. If index is less than or equal to zero, the new node
        is inserted at the beginning, if index is greater than or equal to
        the current number of children, it is inserted at the end. If iid
        is specified, it is used as the item identifier, iid must not
        already exist in the tree. Otherwise, a new unique identifier
        is generated."""
        opts = _format_optdict(kw)
        if iid:
            res = self.tk.call(self._w, "insert", parent, index,
                "-id", iid, *opts)
        else:
            res = self.tk.call(self._w, "insert", parent, index, *opts)

        return res


    def item(self, item, option=None, **kw):
        """Query or modify the options for the specified item.

        If no options are given, a dict with options/values for the item
        is returned. If option is specified then the value for that option
        is returned. Otherwise, sets the options to the corresponding
        values as given by kw."""
        if option is not None:
            kw[option] = None
        return _val_or_dict(self.tk, kw, self._w, "item", item)


    def move(self, item, parent, index):
        """Moves item to position index in parent's list of children.

        It is illegal to move an item under one of its descendants. If
        index is less than or equal to zero, item is moved to the
        beginning, if greater than or equal to the number of children,
        it is moved to the end. If item was detached it is reattached."""
        self.tk.call(self._w, "move", item, parent, index)

    reattach = move # A sensible method name for reattaching detached items


    def next(self, item):
        """Returns the identifier of item's next sibling, or '' if item
        is the last child of its parent."""
        return self.tk.call(self._w, "next", item)


    def parent(self, item):
        """Returns the ID of the parent of item, or '' if item is at the
        top level of the hierarchy."""
        return self.tk.call(self._w, "parent", item)


    def prev(self, item):
        """Returns the identifier of item's previous sibling, or '' if
        item is the first child of its parent."""
        return self.tk.call(self._w, "prev", item)


    def see(self, item):
        """Ensure that item is visible.

        Sets all of item's ancestors open option to True, and scrolls
        the widget if necessary so that item is within the visible
        portion of the tree."""
        self.tk.call(self._w, "see", item)


    def selection(self, selop=None, items=None):
        """If selop is not specified, returns selected items."""
        return self.tk.call(self._w, "selection", selop, items)


    def selection_set(self, items):
        """items becomes the new selection."""
        self.selection("set", items)


    def selection_add(self, items):
        """Add items to the selection."""
        self.selection("add", items)


    def selection_remove(self, items):
        """Remove items from the selection."""
        self.selection("remove", items)


    def selection_toggle(self, items):
        """Toggle the selection state of each item in items."""
        self.selection("toggle", items)


    def set(self, item, column=None, value=None):
        """Query or set the value of given item.

        With one argument, return a dictionary of column/value pairs
        for the specified item. With two arguments, return the current
        value of the specified column. With three arguments, set the
        value of given column in given item to the specified value."""
        res = self.tk.call(self._w, "set", item, column, value)
        if column is None and value is None:
            return _splitdict(self.tk, res,
                              cut_minus=False, conv=_tclobj_to_py)
        else:
            return res


    def tag_bind(self, tagname, sequence=None, callback=None):
        """Bind a callback for the given event sequence to the tag tagname.
        When an event is delivered to an item, the callbacks for each
        of the item's tags option are called."""
        self._bind((self._w, "tag", "bind", tagname), sequence, callback, add=0)


    def tag_configure(self, tagname, option=None, **kw):
        """Query or modify the options for the specified tagname.

        If kw is not given, returns a dict of the option settings for tagname.
        If option is specified, returns the value for that option for the
        specified tagname. Otherwise, sets the options to the corresponding
        values for the given tagname."""
        if option is not None:
            kw[option] = None
        return _val_or_dict(self.tk, kw, self._w, "tag", "configure",
            tagname)


    def tag_has(self, tagname, item=None):
        """If item is specified, returns 1 or 0 depending on whether the
        specified item has the given tagname. Otherwise, returns a list of
        all items which have the specified tag.

        * Availability: Tk 8.6"""
        return self.tk.getboolean(
                self.tk.call(self._w, "tag", "has", tagname, item))


# Extensions

class LabeledScale(Frame):
    """A Ttk Scale widget with a Ttk Label widget indicating its
    current value.

    The Ttk Scale can be accessed through instance.scale, and Ttk Label
    can be accessed through instance.label"""

    def __init__(self, master=None, variable=None, from_=0, to=10, **kw):
        """Construct an horizontal LabeledScale with parent master, a
        variable to be associated with the Ttk Scale widget and its range.
        If variable is not specified, a tkinter.IntVar is created.

        WIDGET-SPECIFIC OPTIONS

            compound: 'top' or 'bottom'
                Specifies how to display the label relative to the scale.
                Defaults to 'top'.
        """
        self._label_top = kw.pop('compound', 'top') == 'top'

        Frame.__init__(self, master, **kw)
        self._variable = variable or tkinter.IntVar(master)
        self._variable.set(from_)
        self._last_valid = from_

        self.label = Label(self)
        self.scale = Scale(self, variable=self._variable, from_=from_, to=to)
        self.scale.bind('<<RangeChanged>>', self._adjust)

        # position scale and label according to the compound option
        scale_side = 'bottom' if self._label_top else 'top'
        label_side = 'top' if scale_side == 'bottom' else 'bottom'
        self.scale.pack(side=scale_side, fill='x')
        tmp = Label(self).pack(side=label_side) # place holder
        self.label.place(anchor='n' if label_side == 'top' else 's')

        # update the label as scale or variable changes
        self.__tracecb = self._variable.trace_variable('w', self._adjust)
        self.bind('<Configure>', self._adjust)
        self.bind('<Map>', self._adjust)


    def destroy(self):
        """Destroy this widget and possibly its associated variable."""
        try:
            self._variable.trace_vdelete('w', self.__tracecb)
        except AttributeError:
            # widget has been destroyed already
            pass
        else:
            del self._variable
            Frame.destroy(self)


    def _adjust(self, *args):
        """Adjust the label position according to the scale."""
        def adjust_label():
            self.update_idletasks() # "force" scale redraw

            x, y = self.scale.coords()
            if self._label_top:
                y = self.scale.winfo_y() - self.label.winfo_reqheight()
            else:
                y = self.scale.winfo_reqheight() + self.label.winfo_reqheight()

            self.label.place_configure(x=x, y=y)

        from_ = _to_number(self.scale['from'])
        to = _to_number(self.scale['to'])
        if to < from_:
            from_, to = to, from_
        newval = self._variable.get()
        if not from_ <= newval <= to:
            # value outside range, set value back to the last valid one
            self.value = self._last_valid
            return

        self._last_valid = newval
        self.label['text'] = newval
        self.after_idle(adjust_label)


    def _get_value(self):
        """Return current scale value."""
        return self._variable.get()


    def _set_value(self, val):
        """Set new scale value."""
        self._variable.set(val)


    value = property(_get_value, _set_value)


class OptionMenu(Menubutton):
    """Themed OptionMenu, based after tkinter's OptionMenu, which allows
    the user to select a value from a menu."""

    def __init__(self, master, variable, default=None, *values, **kwargs):
        """Construct a themed OptionMenu widget with master as the parent,
        the resource textvariable set to variable, the initially selected
        value specified by the default parameter, the menu values given by
        *values and additional keywords.

        WIDGET-SPECIFIC OPTIONS

            style: stylename
                Menubutton style.
            direction: 'above', 'below', 'left', 'right', or 'flush'
                Menubutton direction.
            command: callback
                A callback that will be invoked after selecting an item.
        """
        kw = {'textvariable': variable, 'style': kwargs.pop('style', None),
              'direction': kwargs.pop('direction', None)}
        Menubutton.__init__(self, master, **kw)
        self['menu'] = tkinter.Menu(self, tearoff=False)

        self._variable = variable
        self._callback = kwargs.pop('command', None)
        if kwargs:
            raise tkinter.TclError('unknown option -%s' % (
                next(iter(kwargs.keys()))))

        self.set_menu(default, *values)


    def __getitem__(self, item):
        if item == 'menu':
            return self.nametowidget(Menubutton.__getitem__(self, item))

        return Menubutton.__getitem__(self, item)


    def set_menu(self, default=None, *values):
        """Build a new menu of radiobuttons with *values and optionally
        a default value."""
        menu = self['menu']
        menu.delete(0, 'end')
        for val in values:
            menu.add_radiobutton(label=val,
                command=tkinter._setit(self._variable, val, self._callback))

        if default:
            self._variable.set(default)


    def destroy(self):
        """Destroy this widget and its associated variable."""
        del self._variable
        Menubutton.destroy(self)
                                                                                              usr/lib/python3.4/token.py                                                                          0100644 0000000 0000000 00000005732 12415221636 014075  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Token constants (from "token.h")."""

__all__ = ['tok_name', 'ISTERMINAL', 'ISNONTERMINAL', 'ISEOF']

#  This file is automatically generated; please don't muck it up!
#
#  To update the symbols in this file, 'cd' to the top directory of
#  the python source tree after building the interpreter and run:
#
#    ./python Lib/token.py

#--start constants--
ENDMARKER = 0
NAME = 1
NUMBER = 2
STRING = 3
NEWLINE = 4
INDENT = 5
DEDENT = 6
LPAR = 7
RPAR = 8
LSQB = 9
RSQB = 10
COLON = 11
COMMA = 12
SEMI = 13
PLUS = 14
MINUS = 15
STAR = 16
SLASH = 17
VBAR = 18
AMPER = 19
LESS = 20
GREATER = 21
EQUAL = 22
DOT = 23
PERCENT = 24
LBRACE = 25
RBRACE = 26
EQEQUAL = 27
NOTEQUAL = 28
LESSEQUAL = 29
GREATEREQUAL = 30
TILDE = 31
CIRCUMFLEX = 32
LEFTSHIFT = 33
RIGHTSHIFT = 34
DOUBLESTAR = 35
PLUSEQUAL = 36
MINEQUAL = 37
STAREQUAL = 38
SLASHEQUAL = 39
PERCENTEQUAL = 40
AMPEREQUAL = 41
VBAREQUAL = 42
CIRCUMFLEXEQUAL = 43
LEFTSHIFTEQUAL = 44
RIGHTSHIFTEQUAL = 45
DOUBLESTAREQUAL = 46
DOUBLESLASH = 47
DOUBLESLASHEQUAL = 48
AT = 49
RARROW = 50
ELLIPSIS = 51
OP = 52
ERRORTOKEN = 53
N_TOKENS = 54
NT_OFFSET = 256
#--end constants--

tok_name = {value: name
            for name, value in globals().items()
            if isinstance(value, int) and not name.startswith('_')}
__all__.extend(tok_name.values())

def ISTERMINAL(x):
    return x < NT_OFFSET

def ISNONTERMINAL(x):
    return x >= NT_OFFSET

def ISEOF(x):
    return x == ENDMARKER


def _main():
    import re
    import sys
    args = sys.argv[1:]
    inFileName = args and args[0] or "Include/token.h"
    outFileName = "Lib/token.py"
    if len(args) > 1:
        outFileName = args[1]
    try:
        fp = open(inFileName)
    except OSError as err:
        sys.stdout.write("I/O error: %s\n" % str(err))
        sys.exit(1)
    lines = fp.read().split("\n")
    fp.close()
    prog = re.compile(
        "#define[ \t][ \t]*([A-Z0-9][A-Z0-9_]*)[ \t][ \t]*([0-9][0-9]*)",
        re.IGNORECASE)
    tokens = {}
    for line in lines:
        match = prog.match(line)
        if match:
            name, val = match.group(1, 2)
            val = int(val)
            tokens[val] = name          # reverse so we can sort them...
    keys = sorted(tokens.keys())
    # load the output skeleton from the target:
    try:
        fp = open(outFileName)
    except OSError as err:
        sys.stderr.write("I/O error: %s\n" % str(err))
        sys.exit(2)
    format = fp.read().split("\n")
    fp.close()
    try:
        start = format.index("#--start constants--") + 1
        end = format.index("#--end constants--")
    except ValueError:
        sys.stderr.write("target does not contain format markers")
        sys.exit(3)
    lines = []
    for val in keys:
        lines.append("%s = %d" % (tokens[val], val))
    format[start:end] = lines
    try:
        fp = open(outFileName, 'w')
    except OSError as err:
        sys.stderr.write("I/O error: %s\n" % str(err))
        sys.exit(4)
    fp.write("\n".join(format))
    fp.close()


if __name__ == "__main__":
    _main()
                                      usr/lib/python3.4/tokenize.py                                                                       0100644 0000000 0000000 00000060454 12415221636 014607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Tokenization help for Python programs.

tokenize(readline) is a generator that breaks a stream of bytes into
Python tokens.  It decodes the bytes according to PEP-0263 for
determining source file encoding.

It accepts a readline-like method which is called repeatedly to get the
next line of input (or b"" for EOF).  It generates 5-tuples with these
members:

    the token type (see token.py)
    the token (a string)
    the starting (row, column) indices of the token (a 2-tuple of ints)
    the ending (row, column) indices of the token (a 2-tuple of ints)
    the original line (string)

It is designed to match the working of the Python tokenizer exactly, except
that it produces COMMENT tokens for comments and gives type OP for all
operators.  Additionally, all token lists start with an ENCODING token
which tells you which encoding was used to decode the bytes stream.
"""

__author__ = 'Ka-Ping Yee <ping@lfw.org>'
__credits__ = ('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '
               'Skip Montanaro, Raymond Hettinger, Trent Nelson, '
               'Michael Foord')
import builtins
from codecs import lookup, BOM_UTF8
import collections
from io import TextIOWrapper
from itertools import chain
import re
import sys
from token import *

cookie_re = re.compile(r'^[ \t\f]*#.*coding[:=][ \t]*([-\w.]+)', re.ASCII)
blank_re = re.compile(br'^[ \t\f]*(?:[#\r\n]|$)', re.ASCII)

import token
__all__ = token.__all__ + ["COMMENT", "tokenize", "detect_encoding",
                           "NL", "untokenize", "ENCODING", "TokenInfo"]
del token

COMMENT = N_TOKENS
tok_name[COMMENT] = 'COMMENT'
NL = N_TOKENS + 1
tok_name[NL] = 'NL'
ENCODING = N_TOKENS + 2
tok_name[ENCODING] = 'ENCODING'
N_TOKENS += 3
EXACT_TOKEN_TYPES = {
    '(':   LPAR,
    ')':   RPAR,
    '[':   LSQB,
    ']':   RSQB,
    ':':   COLON,
    ',':   COMMA,
    ';':   SEMI,
    '+':   PLUS,
    '-':   MINUS,
    '*':   STAR,
    '/':   SLASH,
    '|':   VBAR,
    '&':   AMPER,
    '<':   LESS,
    '>':   GREATER,
    '=':   EQUAL,
    '.':   DOT,
    '%':   PERCENT,
    '{':   LBRACE,
    '}':   RBRACE,
    '==':  EQEQUAL,
    '!=':  NOTEQUAL,
    '<=':  LESSEQUAL,
    '>=':  GREATEREQUAL,
    '~':   TILDE,
    '^':   CIRCUMFLEX,
    '<<':  LEFTSHIFT,
    '>>':  RIGHTSHIFT,
    '**':  DOUBLESTAR,
    '+=':  PLUSEQUAL,
    '-=':  MINEQUAL,
    '*=':  STAREQUAL,
    '/=':  SLASHEQUAL,
    '%=':  PERCENTEQUAL,
    '&=':  AMPEREQUAL,
    '|=':  VBAREQUAL,
    '^=': CIRCUMFLEXEQUAL,
    '<<=': LEFTSHIFTEQUAL,
    '>>=': RIGHTSHIFTEQUAL,
    '**=': DOUBLESTAREQUAL,
    '//':  DOUBLESLASH,
    '//=': DOUBLESLASHEQUAL,
    '@':   AT
}

class TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):
    def __repr__(self):
        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])
        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %
                self._replace(type=annotated_type))

    @property
    def exact_type(self):
        if self.type == OP and self.string in EXACT_TOKEN_TYPES:
            return EXACT_TOKEN_TYPES[self.string]
        else:
            return self.type

def group(*choices): return '(' + '|'.join(choices) + ')'
def any(*choices): return group(*choices) + '*'
def maybe(*choices): return group(*choices) + '?'

# Note: we use unicode matching for names ("\w") but ascii matching for
# number literals.
Whitespace = r'[ \f\t]*'
Comment = r'#[^\r\n]*'
Ignore = Whitespace + any(r'\\\r?\n' + Whitespace) + maybe(Comment)
Name = r'\w+'

Hexnumber = r'0[xX][0-9a-fA-F]+'
Binnumber = r'0[bB][01]+'
Octnumber = r'0[oO][0-7]+'
Decnumber = r'(?:0+|[1-9][0-9]*)'
Intnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)
Exponent = r'[eE][-+]?[0-9]+'
Pointfloat = group(r'[0-9]+\.[0-9]*', r'\.[0-9]+') + maybe(Exponent)
Expfloat = r'[0-9]+' + Exponent
Floatnumber = group(Pointfloat, Expfloat)
Imagnumber = group(r'[0-9]+[jJ]', Floatnumber + r'[jJ]')
Number = group(Imagnumber, Floatnumber, Intnumber)

StringPrefix = r'(?:[bB][rR]?|[rR][bB]?|[uU])?'

# Tail end of ' string.
Single = r"[^'\\]*(?:\\.[^'\\]*)*'"
# Tail end of " string.
Double = r'[^"\\]*(?:\\.[^"\\]*)*"'
# Tail end of ''' string.
Single3 = r"[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''"
# Tail end of """ string.
Double3 = r'[^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*"""'
Triple = group(StringPrefix + "'''", StringPrefix + '"""')
# Single-line ' or " string.
String = group(StringPrefix + r"'[^\n'\\]*(?:\\.[^\n'\\]*)*'",
               StringPrefix + r'"[^\n"\\]*(?:\\.[^\n"\\]*)*"')

# Because of leftmost-then-longest match semantics, be sure to put the
# longest operators first (e.g., if = came before ==, == would get
# recognized as two instances of =).
Operator = group(r"\*\*=?", r">>=?", r"<<=?", r"!=",
                 r"//=?", r"->",
                 r"[+\-*/%&|^=<>]=?",
                 r"~")

Bracket = '[][(){}]'
Special = group(r'\r?\n', r'\.\.\.', r'[:;.,@]')
Funny = group(Operator, Bracket, Special)

PlainToken = group(Number, Funny, String, Name)
Token = Ignore + PlainToken

# First (or only) line of ' or " string.
ContStr = group(StringPrefix + r"'[^\n'\\]*(?:\\.[^\n'\\]*)*" +
                group("'", r'\\\r?\n'),
                StringPrefix + r'"[^\n"\\]*(?:\\.[^\n"\\]*)*' +
                group('"', r'\\\r?\n'))
PseudoExtras = group(r'\\\r?\n|\Z', Comment, Triple)
PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)

def _compile(expr):
    return re.compile(expr, re.UNICODE)

endpats = {"'": Single, '"': Double,
           "'''": Single3, '"""': Double3,
           "r'''": Single3, 'r"""': Double3,
           "b'''": Single3, 'b"""': Double3,
           "R'''": Single3, 'R"""': Double3,
           "B'''": Single3, 'B"""': Double3,
           "br'''": Single3, 'br"""': Double3,
           "bR'''": Single3, 'bR"""': Double3,
           "Br'''": Single3, 'Br"""': Double3,
           "BR'''": Single3, 'BR"""': Double3,
           "rb'''": Single3, 'rb"""': Double3,
           "Rb'''": Single3, 'Rb"""': Double3,
           "rB'''": Single3, 'rB"""': Double3,
           "RB'''": Single3, 'RB"""': Double3,
           "u'''": Single3, 'u"""': Double3,
           "R'''": Single3, 'R"""': Double3,
           "U'''": Single3, 'U"""': Double3,
           'r': None, 'R': None, 'b': None, 'B': None,
           'u': None, 'U': None}

triple_quoted = {}
for t in ("'''", '"""',
          "r'''", 'r"""', "R'''", 'R"""',
          "b'''", 'b"""', "B'''", 'B"""',
          "br'''", 'br"""', "Br'''", 'Br"""',
          "bR'''", 'bR"""', "BR'''", 'BR"""',
          "rb'''", 'rb"""', "rB'''", 'rB"""',
          "Rb'''", 'Rb"""', "RB'''", 'RB"""',
          "u'''", 'u"""', "U'''", 'U"""',
          ):
    triple_quoted[t] = t
single_quoted = {}
for t in ("'", '"',
          "r'", 'r"', "R'", 'R"',
          "b'", 'b"', "B'", 'B"',
          "br'", 'br"', "Br'", 'Br"',
          "bR'", 'bR"', "BR'", 'BR"' ,
          "rb'", 'rb"', "rB'", 'rB"',
          "Rb'", 'Rb"', "RB'", 'RB"' ,
          "u'", 'u"', "U'", 'U"',
          ):
    single_quoted[t] = t

tabsize = 8

class TokenError(Exception): pass

class StopTokenizing(Exception): pass


class Untokenizer:

    def __init__(self):
        self.tokens = []
        self.prev_row = 1
        self.prev_col = 0
        self.encoding = None

    def add_whitespace(self, start):
        row, col = start
        if row < self.prev_row or row == self.prev_row and col < self.prev_col:
            raise ValueError("start ({},{}) precedes previous end ({},{})"
                             .format(row, col, self.prev_row, self.prev_col))
        row_offset = row - self.prev_row
        if row_offset:
            self.tokens.append("\\\n" * row_offset)
            self.prev_col = 0
        col_offset = col - self.prev_col
        if col_offset:
            self.tokens.append(" " * col_offset)

    def untokenize(self, iterable):
        it = iter(iterable)
        for t in it:
            if len(t) == 2:
                self.compat(t, it)
                break
            tok_type, token, start, end, line = t
            if tok_type == ENCODING:
                self.encoding = token
                continue
            if tok_type == ENDMARKER:
                break
            self.add_whitespace(start)
            self.tokens.append(token)
            self.prev_row, self.prev_col = end
            if tok_type in (NEWLINE, NL):
                self.prev_row += 1
                self.prev_col = 0
        return "".join(self.tokens)

    def compat(self, token, iterable):
        indents = []
        toks_append = self.tokens.append
        startline = token[0] in (NEWLINE, NL)
        prevstring = False

        for tok in chain([token], iterable):
            toknum, tokval = tok[:2]
            if toknum == ENCODING:
                self.encoding = tokval
                continue

            if toknum in (NAME, NUMBER):
                tokval += ' '

            # Insert a space between two consecutive strings
            if toknum == STRING:
                if prevstring:
                    tokval = ' ' + tokval
                prevstring = True
            else:
                prevstring = False

            if toknum == INDENT:
                indents.append(tokval)
                continue
            elif toknum == DEDENT:
                indents.pop()
                continue
            elif toknum in (NEWLINE, NL):
                startline = True
            elif startline and indents:
                toks_append(indents[-1])
                startline = False
            toks_append(tokval)


def untokenize(iterable):
    """Transform tokens back into Python source code.
    It returns a bytes object, encoded using the ENCODING
    token, which is the first token sequence output by tokenize.

    Each element returned by the iterable must be a token sequence
    with at least two elements, a token number and token value.  If
    only two tokens are passed, the resulting output is poor.

    Round-trip invariant for full input:
        Untokenized source will match input source exactly

    Round-trip invariant for limited intput:
        # Output bytes will tokenize the back to the input
        t1 = [tok[:2] for tok in tokenize(f.readline)]
        newcode = untokenize(t1)
        readline = BytesIO(newcode).readline
        t2 = [tok[:2] for tok in tokenize(readline)]
        assert t1 == t2
    """
    ut = Untokenizer()
    out = ut.untokenize(iterable)
    if ut.encoding is not None:
        out = out.encode(ut.encoding)
    return out


def _get_normal_name(orig_enc):
    """Imitates get_normal_name in tokenizer.c."""
    # Only care about the first 12 characters.
    enc = orig_enc[:12].lower().replace("_", "-")
    if enc == "utf-8" or enc.startswith("utf-8-"):
        return "utf-8"
    if enc in ("latin-1", "iso-8859-1", "iso-latin-1") or \
       enc.startswith(("latin-1-", "iso-8859-1-", "iso-latin-1-")):
        return "iso-8859-1"
    return orig_enc

def detect_encoding(readline):
    """
    The detect_encoding() function is used to detect the encoding that should
    be used to decode a Python source file.  It requires one argument, readline,
    in the same way as the tokenize() generator.

    It will call readline a maximum of twice, and return the encoding used
    (as a string) and a list of any lines (left as bytes) it has read in.

    It detects the encoding from the presence of a utf-8 bom or an encoding
    cookie as specified in pep-0263.  If both a bom and a cookie are present,
    but disagree, a SyntaxError will be raised.  If the encoding cookie is an
    invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
    'utf-8-sig' is returned.

    If no encoding is specified, then the default of 'utf-8' will be returned.
    """
    try:
        filename = readline.__self__.name
    except AttributeError:
        filename = None
    bom_found = False
    encoding = None
    default = 'utf-8'
    def read_or_stop():
        try:
            return readline()
        except StopIteration:
            return b''

    def find_cookie(line):
        try:
            # Decode as UTF-8. Either the line is an encoding declaration,
            # in which case it should be pure ASCII, or it must be UTF-8
            # per default encoding.
            line_string = line.decode('utf-8')
        except UnicodeDecodeError:
            msg = "invalid or missing encoding declaration"
            if filename is not None:
                msg = '{} for {!r}'.format(msg, filename)
            raise SyntaxError(msg)

        match = cookie_re.match(line_string)
        if not match:
            return None
        encoding = _get_normal_name(match.group(1))
        try:
            codec = lookup(encoding)
        except LookupError:
            # This behaviour mimics the Python interpreter
            if filename is None:
                msg = "unknown encoding: " + encoding
            else:
                msg = "unknown encoding for {!r}: {}".format(filename,
                        encoding)
            raise SyntaxError(msg)

        if bom_found:
            if encoding != 'utf-8':
                # This behaviour mimics the Python interpreter
                if filename is None:
                    msg = 'encoding problem: utf-8'
                else:
                    msg = 'encoding problem for {!r}: utf-8'.format(filename)
                raise SyntaxError(msg)
            encoding += '-sig'
        return encoding

    first = read_or_stop()
    if first.startswith(BOM_UTF8):
        bom_found = True
        first = first[3:]
        default = 'utf-8-sig'
    if not first:
        return default, []

    encoding = find_cookie(first)
    if encoding:
        return encoding, [first]
    if not blank_re.match(first):
        return default, [first]

    second = read_or_stop()
    if not second:
        return default, [first]

    encoding = find_cookie(second)
    if encoding:
        return encoding, [first, second]

    return default, [first, second]


def open(filename):
    """Open a file in read only mode using the encoding detected by
    detect_encoding().
    """
    buffer = builtins.open(filename, 'rb')
    encoding, lines = detect_encoding(buffer.readline)
    buffer.seek(0)
    text = TextIOWrapper(buffer, encoding, line_buffering=True)
    text.mode = 'r'
    return text


def tokenize(readline):
    """
    The tokenize() generator requires one argment, readline, which
    must be a callable object which provides the same interface as the
    readline() method of built-in file objects.  Each call to the function
    should return one line of input as bytes.  Alternately, readline
    can be a callable function terminating with StopIteration:
        readline = open(myfile, 'rb').__next__  # Example of alternate readline

    The generator produces 5-tuples with these members: the token type; the
    token string; a 2-tuple (srow, scol) of ints specifying the row and
    column where the token begins in the source; a 2-tuple (erow, ecol) of
    ints specifying the row and column where the token ends in the source;
    and the line on which the token was found.  The line passed is the
    logical line; continuation lines are included.

    The first token sequence will always be an ENCODING token
    which tells you which encoding was used to decode the bytes stream.
    """
    # This import is here to avoid problems when the itertools module is not
    # built yet and tokenize is imported.
    from itertools import chain, repeat
    encoding, consumed = detect_encoding(readline)
    rl_gen = iter(readline, b"")
    empty = repeat(b"")
    return _tokenize(chain(consumed, rl_gen, empty).__next__, encoding)


def _tokenize(readline, encoding):
    lnum = parenlev = continued = 0
    numchars = '0123456789'
    contstr, needcont = '', 0
    contline = None
    indents = [0]

    if encoding is not None:
        if encoding == "utf-8-sig":
            # BOM will already have been stripped.
            encoding = "utf-8"
        yield TokenInfo(ENCODING, encoding, (0, 0), (0, 0), '')
    while True:             # loop over lines in stream
        try:
            line = readline()
        except StopIteration:
            line = b''

        if encoding is not None:
            line = line.decode(encoding)
        lnum += 1
        pos, max = 0, len(line)

        if contstr:                            # continued string
            if not line:
                raise TokenError("EOF in multi-line string", strstart)
            endmatch = endprog.match(line)
            if endmatch:
                pos = end = endmatch.end(0)
                yield TokenInfo(STRING, contstr + line[:end],
                       strstart, (lnum, end), contline + line)
                contstr, needcont = '', 0
                contline = None
            elif needcont and line[-2:] != '\\\n' and line[-3:] != '\\\r\n':
                yield TokenInfo(ERRORTOKEN, contstr + line,
                           strstart, (lnum, len(line)), contline)
                contstr = ''
                contline = None
                continue
            else:
                contstr = contstr + line
                contline = contline + line
                continue

        elif parenlev == 0 and not continued:  # new statement
            if not line: break
            column = 0
            while pos < max:                   # measure leading whitespace
                if line[pos] == ' ':
                    column += 1
                elif line[pos] == '\t':
                    column = (column//tabsize + 1)*tabsize
                elif line[pos] == '\f':
                    column = 0
                else:
                    break
                pos += 1
            if pos == max:
                break

            if line[pos] in '#\r\n':           # skip comments or blank lines
                if line[pos] == '#':
                    comment_token = line[pos:].rstrip('\r\n')
                    nl_pos = pos + len(comment_token)
                    yield TokenInfo(COMMENT, comment_token,
                           (lnum, pos), (lnum, pos + len(comment_token)), line)
                    yield TokenInfo(NL, line[nl_pos:],
                           (lnum, nl_pos), (lnum, len(line)), line)
                else:
                    yield TokenInfo((NL, COMMENT)[line[pos] == '#'], line[pos:],
                           (lnum, pos), (lnum, len(line)), line)
                continue

            if column > indents[-1]:           # count indents or dedents
                indents.append(column)
                yield TokenInfo(INDENT, line[:pos], (lnum, 0), (lnum, pos), line)
            while column < indents[-1]:
                if column not in indents:
                    raise IndentationError(
                        "unindent does not match any outer indentation level",
                        ("<tokenize>", lnum, pos, line))
                indents = indents[:-1]
                yield TokenInfo(DEDENT, '', (lnum, pos), (lnum, pos), line)

        else:                                  # continued statement
            if not line:
                raise TokenError("EOF in multi-line statement", (lnum, 0))
            continued = 0

        while pos < max:
            pseudomatch = _compile(PseudoToken).match(line, pos)
            if pseudomatch:                                # scan for tokens
                start, end = pseudomatch.span(1)
                spos, epos, pos = (lnum, start), (lnum, end), end
                if start == end:
                    continue
                token, initial = line[start:end], line[start]

                if (initial in numchars or                  # ordinary number
                    (initial == '.' and token != '.' and token != '...')):
                    yield TokenInfo(NUMBER, token, spos, epos, line)
                elif initial in '\r\n':
                    yield TokenInfo(NL if parenlev > 0 else NEWLINE,
                           token, spos, epos, line)
                elif initial == '#':
                    assert not token.endswith("\n")
                    yield TokenInfo(COMMENT, token, spos, epos, line)
                elif token in triple_quoted:
                    endprog = _compile(endpats[token])
                    endmatch = endprog.match(line, pos)
                    if endmatch:                           # all on one line
                        pos = endmatch.end(0)
                        token = line[start:pos]
                        yield TokenInfo(STRING, token, spos, (lnum, pos), line)
                    else:
                        strstart = (lnum, start)           # multiple lines
                        contstr = line[start:]
                        contline = line
                        break
                elif initial in single_quoted or \
                    token[:2] in single_quoted or \
                    token[:3] in single_quoted:
                    if token[-1] == '\n':                  # continued string
                        strstart = (lnum, start)
                        endprog = _compile(endpats[initial] or
                                           endpats[token[1]] or
                                           endpats[token[2]])
                        contstr, needcont = line[start:], 1
                        contline = line
                        break
                    else:                                  # ordinary string
                        yield TokenInfo(STRING, token, spos, epos, line)
                elif initial.isidentifier():               # ordinary name
                    yield TokenInfo(NAME, token, spos, epos, line)
                elif initial == '\\':                      # continued stmt
                    continued = 1
                else:
                    if initial in '([{':
                        parenlev += 1
                    elif initial in ')]}':
                        parenlev -= 1
                    yield TokenInfo(OP, token, spos, epos, line)
            else:
                yield TokenInfo(ERRORTOKEN, line[pos],
                           (lnum, pos), (lnum, pos+1), line)
                pos += 1

    for indent in indents[1:]:                 # pop remaining indent levels
        yield TokenInfo(DEDENT, '', (lnum, 0), (lnum, 0), '')
    yield TokenInfo(ENDMARKER, '', (lnum, 0), (lnum, 0), '')


# An undocumented, backwards compatible, API for all the places in the standard
# library that expect to be able to use tokenize with strings
def generate_tokens(readline):
    return _tokenize(readline, None)

def main():
    import argparse

    # Helper error handling routines
    def perror(message):
        print(message, file=sys.stderr)

    def error(message, filename=None, location=None):
        if location:
            args = (filename,) + location + (message,)
            perror("%s:%d:%d: error: %s" % args)
        elif filename:
            perror("%s: error: %s" % (filename, message))
        else:
            perror("error: %s" % message)
        sys.exit(1)

    # Parse the arguments and options
    parser = argparse.ArgumentParser(prog='python -m tokenize')
    parser.add_argument(dest='filename', nargs='?',
                        metavar='filename.py',
                        help='the file to tokenize; defaults to stdin')
    parser.add_argument('-e', '--exact', dest='exact', action='store_true',
                        help='display token names using the exact type')
    args = parser.parse_args()

    try:
        # Tokenize the input
        if args.filename:
            filename = args.filename
            with builtins.open(filename, 'rb') as f:
                tokens = list(tokenize(f.readline))
        else:
            filename = "<stdin>"
            tokens = _tokenize(sys.stdin.readline, None)

        # Output the tokenization
        for token in tokens:
            token_type = token.type
            if args.exact:
                token_type = token.exact_type
            token_range = "%d,%d-%d,%d:" % (token.start + token.end)
            print("%-20s%-15s%-15r" %
                  (token_range, tok_name[token_type], token.string))
    except IndentationError as err:
        line, column = err.args[1][1:3]
        error(err.args[0], filename, (line, column))
    except TokenError as err:
        line, column = err.args[1]
        error(err.args[0], filename, (line, column))
    except SyntaxError as err:
        error(err, filename)
    except OSError as err:
        error(err)
    except KeyboardInterrupt:
        print("interrupted\n")
    except Exception as err:
        perror("unexpected error: %s" % err)
        raise

if __name__ == "__main__":
    main()
                                                                                                                                                                                                                    usr/lib/python3.4/trace.py                                                                          0100755 0000000 0000000 00000075362 12415221651 014061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python3.4

# portions copyright 2001, Autonomous Zones Industries, Inc., all rights...
# err...  reserved and offered to the public under the terms of the
# Python 2.2 license.
# Author: Zooko O'Whielacronx
# http://zooko.com/
# mailto:zooko@zooko.com
#
# Copyright 2000, Mojam Media, Inc., all rights reserved.
# Author: Skip Montanaro
#
# Copyright 1999, Bioreason, Inc., all rights reserved.
# Author: Andrew Dalke
#
# Copyright 1995-1997, Automatrix, Inc., all rights reserved.
# Author: Skip Montanaro
#
# Copyright 1991-1995, Stichting Mathematisch Centrum, all rights reserved.
#
#
# Permission to use, copy, modify, and distribute this Python software and
# its associated documentation for any purpose without fee is hereby
# granted, provided that the above copyright notice appears in all copies,
# and that both that copyright notice and this permission notice appear in
# supporting documentation, and that the name of neither Automatrix,
# Bioreason or Mojam Media be used in advertising or publicity pertaining to
# distribution of the software without specific, written prior permission.
#
"""program/module to trace Python program or function execution

Sample use, command line:
  trace.py -c -f counts --ignore-dir '$prefix' spam.py eggs
  trace.py -t --ignore-dir '$prefix' spam.py eggs
  trace.py --trackcalls spam.py eggs

Sample use, programmatically
  import sys

  # create a Trace object, telling it what to ignore, and whether to
  # do tracing or line-counting or both.
  tracer = trace.Trace(ignoredirs=[sys.base_prefix, sys.base_exec_prefix,],
                       trace=0, count=1)
  # run the new command using the given tracer
  tracer.run('main()')
  # make a report, placing output in /tmp
  r = tracer.results()
  r.write_results(show_missing=True, coverdir="/tmp")
"""
__all__ = ['Trace', 'CoverageResults']
import linecache
import os
import re
import sys
import token
import tokenize
import inspect
import gc
import dis
import pickle
from warnings import warn as _warn
try:
    from time import monotonic as _time
except ImportError:
    from time import time as _time

try:
    import threading
except ImportError:
    _settrace = sys.settrace

    def _unsettrace():
        sys.settrace(None)
else:
    def _settrace(func):
        threading.settrace(func)
        sys.settrace(func)

    def _unsettrace():
        sys.settrace(None)
        threading.settrace(None)

def _usage(outfile):
    outfile.write("""Usage: %s [OPTIONS] <file> [ARGS]

Meta-options:
--help                Display this help then exit.
--version             Output version information then exit.

Otherwise, exactly one of the following three options must be given:
-t, --trace           Print each line to sys.stdout before it is executed.
-c, --count           Count the number of times each line is executed
                      and write the counts to <module>.cover for each
                      module executed, in the module's directory.
                      See also `--coverdir', `--file', `--no-report' below.
-l, --listfuncs       Keep track of which functions are executed at least
                      once and write the results to sys.stdout after the
                      program exits.
-T, --trackcalls      Keep track of caller/called pairs and write the
                      results to sys.stdout after the program exits.
-r, --report          Generate a report from a counts file; do not execute
                      any code.  `--file' must specify the results file to
                      read, which must have been created in a previous run
                      with `--count --file=FILE'.

Modifiers:
-f, --file=<file>     File to accumulate counts over several runs.
-R, --no-report       Do not generate the coverage report files.
                      Useful if you want to accumulate over several runs.
-C, --coverdir=<dir>  Directory where the report files.  The coverage
                      report for <package>.<module> is written to file
                      <dir>/<package>/<module>.cover.
-m, --missing         Annotate executable lines that were not executed
                      with '>>>>>> '.
-s, --summary         Write a brief summary on stdout for each file.
                      (Can only be used with --count or --report.)
-g, --timing          Prefix each line with the time since the program started.
                      Only used while tracing.

Filters, may be repeated multiple times:
--ignore-module=<mod> Ignore the given module(s) and its submodules
                      (if it is a package).  Accepts comma separated
                      list of module names
--ignore-dir=<dir>    Ignore files in the given directory (multiple
                      directories can be joined by os.pathsep).
""" % sys.argv[0])

PRAGMA_NOCOVER = "#pragma NO COVER"

# Simple rx to find lines with no code.
rx_blank = re.compile(r'^\s*(#.*)?$')

class _Ignore:
    def __init__(self, modules=None, dirs=None):
        self._mods = set() if not modules else set(modules)
        self._dirs = [] if not dirs else [os.path.normpath(d)
                                          for d in dirs]
        self._ignore = { '<string>': 1 }

    def names(self, filename, modulename):
        if modulename in self._ignore:
            return self._ignore[modulename]

        # haven't seen this one before, so see if the module name is
        # on the ignore list.
        if modulename in self._mods:  # Identical names, so ignore
            self._ignore[modulename] = 1
            return 1

        # check if the module is a proper submodule of something on
        # the ignore list
        for mod in self._mods:
            # Need to take some care since ignoring
            # "cmp" mustn't mean ignoring "cmpcache" but ignoring
            # "Spam" must also mean ignoring "Spam.Eggs".
            if modulename.startswith(mod + '.'):
                self._ignore[modulename] = 1
                return 1

        # Now check that filename isn't in one of the directories
        if filename is None:
            # must be a built-in, so we must ignore
            self._ignore[modulename] = 1
            return 1

        # Ignore a file when it contains one of the ignorable paths
        for d in self._dirs:
            # The '+ os.sep' is to ensure that d is a parent directory,
            # as compared to cases like:
            #  d = "/usr/local"
            #  filename = "/usr/local.py"
            # or
            #  d = "/usr/local.py"
            #  filename = "/usr/local.py"
            if filename.startswith(d + os.sep):
                self._ignore[modulename] = 1
                return 1

        # Tried the different ways, so we don't ignore this module
        self._ignore[modulename] = 0
        return 0

def _modname(path):
    """Return a plausible module name for the patch."""

    base = os.path.basename(path)
    filename, ext = os.path.splitext(base)
    return filename

def _fullmodname(path):
    """Return a plausible module name for the path."""

    # If the file 'path' is part of a package, then the filename isn't
    # enough to uniquely identify it.  Try to do the right thing by
    # looking in sys.path for the longest matching prefix.  We'll
    # assume that the rest is the package name.

    comparepath = os.path.normcase(path)
    longest = ""
    for dir in sys.path:
        dir = os.path.normcase(dir)
        if comparepath.startswith(dir) and comparepath[len(dir)] == os.sep:
            if len(dir) > len(longest):
                longest = dir

    if longest:
        base = path[len(longest) + 1:]
    else:
        base = path
    # the drive letter is never part of the module name
    drive, base = os.path.splitdrive(base)
    base = base.replace(os.sep, ".")
    if os.altsep:
        base = base.replace(os.altsep, ".")
    filename, ext = os.path.splitext(base)
    return filename.lstrip(".")

class CoverageResults:
    def __init__(self, counts=None, calledfuncs=None, infile=None,
                 callers=None, outfile=None):
        self.counts = counts
        if self.counts is None:
            self.counts = {}
        self.counter = self.counts.copy() # map (filename, lineno) to count
        self.calledfuncs = calledfuncs
        if self.calledfuncs is None:
            self.calledfuncs = {}
        self.calledfuncs = self.calledfuncs.copy()
        self.callers = callers
        if self.callers is None:
            self.callers = {}
        self.callers = self.callers.copy()
        self.infile = infile
        self.outfile = outfile
        if self.infile:
            # Try to merge existing counts file.
            try:
                counts, calledfuncs, callers = \
                        pickle.load(open(self.infile, 'rb'))
                self.update(self.__class__(counts, calledfuncs, callers))
            except (OSError, EOFError, ValueError) as err:
                print(("Skipping counts file %r: %s"
                                      % (self.infile, err)), file=sys.stderr)

    def is_ignored_filename(self, filename):
        """Return True if the filename does not refer to a file
        we want to have reported.
        """
        return filename.startswith('<') and filename.endswith('>')

    def update(self, other):
        """Merge in the data from another CoverageResults"""
        counts = self.counts
        calledfuncs = self.calledfuncs
        callers = self.callers
        other_counts = other.counts
        other_calledfuncs = other.calledfuncs
        other_callers = other.callers

        for key in other_counts:
            counts[key] = counts.get(key, 0) + other_counts[key]

        for key in other_calledfuncs:
            calledfuncs[key] = 1

        for key in other_callers:
            callers[key] = 1

    def write_results(self, show_missing=True, summary=False, coverdir=None):
        """
        @param coverdir
        """
        if self.calledfuncs:
            print()
            print("functions called:")
            calls = self.calledfuncs
            for filename, modulename, funcname in sorted(calls):
                print(("filename: %s, modulename: %s, funcname: %s"
                       % (filename, modulename, funcname)))

        if self.callers:
            print()
            print("calling relationships:")
            lastfile = lastcfile = ""
            for ((pfile, pmod, pfunc), (cfile, cmod, cfunc)) \
                    in sorted(self.callers):
                if pfile != lastfile:
                    print()
                    print("***", pfile, "***")
                    lastfile = pfile
                    lastcfile = ""
                if cfile != pfile and lastcfile != cfile:
                    print("  -->", cfile)
                    lastcfile = cfile
                print("    %s.%s -> %s.%s" % (pmod, pfunc, cmod, cfunc))

        # turn the counts data ("(filename, lineno) = count") into something
        # accessible on a per-file basis
        per_file = {}
        for filename, lineno in self.counts:
            lines_hit = per_file[filename] = per_file.get(filename, {})
            lines_hit[lineno] = self.counts[(filename, lineno)]

        # accumulate summary info, if needed
        sums = {}

        for filename, count in per_file.items():
            if self.is_ignored_filename(filename):
                continue

            if filename.endswith((".pyc", ".pyo")):
                filename = filename[:-1]

            if coverdir is None:
                dir = os.path.dirname(os.path.abspath(filename))
                modulename = _modname(filename)
            else:
                dir = coverdir
                if not os.path.exists(dir):
                    os.makedirs(dir)
                modulename = _fullmodname(filename)

            # If desired, get a list of the line numbers which represent
            # executable content (returned as a dict for better lookup speed)
            if show_missing:
                lnotab = _find_executable_linenos(filename)
            else:
                lnotab = {}

            source = linecache.getlines(filename)
            coverpath = os.path.join(dir, modulename + ".cover")
            with open(filename, 'rb') as fp:
                encoding, _ = tokenize.detect_encoding(fp.readline)
            n_hits, n_lines = self.write_results_file(coverpath, source,
                                                      lnotab, count, encoding)
            if summary and n_lines:
                percent = int(100 * n_hits / n_lines)
                sums[modulename] = n_lines, percent, modulename, filename

        if summary and sums:
            print("lines   cov%   module   (path)")
            for m in sorted(sums):
                n_lines, percent, modulename, filename = sums[m]
                print("%5d   %3d%%   %s   (%s)" % sums[m])

        if self.outfile:
            # try and store counts and module info into self.outfile
            try:
                pickle.dump((self.counts, self.calledfuncs, self.callers),
                            open(self.outfile, 'wb'), 1)
            except OSError as err:
                print("Can't save counts files because %s" % err, file=sys.stderr)

    def write_results_file(self, path, lines, lnotab, lines_hit, encoding=None):
        """Return a coverage results file in path."""

        try:
            outfile = open(path, "w", encoding=encoding)
        except OSError as err:
            print(("trace: Could not open %r for writing: %s"
                                  "- skipping" % (path, err)), file=sys.stderr)
            return 0, 0

        n_lines = 0
        n_hits = 0
        for lineno, line in enumerate(lines, 1):
            # do the blank/comment match to try to mark more lines
            # (help the reader find stuff that hasn't been covered)
            if lineno in lines_hit:
                outfile.write("%5d: " % lines_hit[lineno])
                n_hits += 1
                n_lines += 1
            elif rx_blank.match(line):
                outfile.write("       ")
            else:
                # lines preceded by no marks weren't hit
                # Highlight them if so indicated, unless the line contains
                # #pragma: NO COVER
                if lineno in lnotab and not PRAGMA_NOCOVER in line:
                    outfile.write(">>>>>> ")
                    n_lines += 1
                else:
                    outfile.write("       ")
            outfile.write(line.expandtabs(8))
        outfile.close()

        return n_hits, n_lines

def _find_lines_from_code(code, strs):
    """Return dict where keys are lines in the line number table."""
    linenos = {}

    for _, lineno in dis.findlinestarts(code):
        if lineno not in strs:
            linenos[lineno] = 1

    return linenos

def _find_lines(code, strs):
    """Return lineno dict for all code objects reachable from code."""
    # get all of the lineno information from the code of this scope level
    linenos = _find_lines_from_code(code, strs)

    # and check the constants for references to other code objects
    for c in code.co_consts:
        if inspect.iscode(c):
            # find another code object, so recurse into it
            linenos.update(_find_lines(c, strs))
    return linenos

def _find_strings(filename, encoding=None):
    """Return a dict of possible docstring positions.

    The dict maps line numbers to strings.  There is an entry for
    line that contains only a string or a part of a triple-quoted
    string.
    """
    d = {}
    # If the first token is a string, then it's the module docstring.
    # Add this special case so that the test in the loop passes.
    prev_ttype = token.INDENT
    with open(filename, encoding=encoding) as f:
        tok = tokenize.generate_tokens(f.readline)
        for ttype, tstr, start, end, line in tok:
            if ttype == token.STRING:
                if prev_ttype == token.INDENT:
                    sline, scol = start
                    eline, ecol = end
                    for i in range(sline, eline + 1):
                        d[i] = 1
            prev_ttype = ttype
    return d

def _find_executable_linenos(filename):
    """Return dict where keys are line numbers in the line number table."""
    try:
        with tokenize.open(filename) as f:
            prog = f.read()
            encoding = f.encoding
    except OSError as err:
        print(("Not printing coverage data for %r: %s"
                              % (filename, err)), file=sys.stderr)
        return {}
    code = compile(prog, filename, "exec")
    strs = _find_strings(filename, encoding)
    return _find_lines(code, strs)

class Trace:
    def __init__(self, count=1, trace=1, countfuncs=0, countcallers=0,
                 ignoremods=(), ignoredirs=(), infile=None, outfile=None,
                 timing=False):
        """
        @param count true iff it should count number of times each
                     line is executed
        @param trace true iff it should print out each line that is
                     being counted
        @param countfuncs true iff it should just output a list of
                     (filename, modulename, funcname,) for functions
                     that were called at least once;  This overrides
                     `count' and `trace'
        @param ignoremods a list of the names of modules to ignore
        @param ignoredirs a list of the names of directories to ignore
                     all of the (recursive) contents of
        @param infile file from which to read stored counts to be
                     added into the results
        @param outfile file in which to write the results
        @param timing true iff timing information be displayed
        """
        self.infile = infile
        self.outfile = outfile
        self.ignore = _Ignore(ignoremods, ignoredirs)
        self.counts = {}   # keys are (filename, linenumber)
        self.pathtobasename = {} # for memoizing os.path.basename
        self.donothing = 0
        self.trace = trace
        self._calledfuncs = {}
        self._callers = {}
        self._caller_cache = {}
        self.start_time = None
        if timing:
            self.start_time = _time()
        if countcallers:
            self.globaltrace = self.globaltrace_trackcallers
        elif countfuncs:
            self.globaltrace = self.globaltrace_countfuncs
        elif trace and count:
            self.globaltrace = self.globaltrace_lt
            self.localtrace = self.localtrace_trace_and_count
        elif trace:
            self.globaltrace = self.globaltrace_lt
            self.localtrace = self.localtrace_trace
        elif count:
            self.globaltrace = self.globaltrace_lt
            self.localtrace = self.localtrace_count
        else:
            # Ahem -- do nothing?  Okay.
            self.donothing = 1

    def run(self, cmd):
        import __main__
        dict = __main__.__dict__
        self.runctx(cmd, dict, dict)

    def runctx(self, cmd, globals=None, locals=None):
        if globals is None: globals = {}
        if locals is None: locals = {}
        if not self.donothing:
            _settrace(self.globaltrace)
        try:
            exec(cmd, globals, locals)
        finally:
            if not self.donothing:
                _unsettrace()

    def runfunc(self, func, *args, **kw):
        result = None
        if not self.donothing:
            sys.settrace(self.globaltrace)
        try:
            result = func(*args, **kw)
        finally:
            if not self.donothing:
                sys.settrace(None)
        return result

    def file_module_function_of(self, frame):
        code = frame.f_code
        filename = code.co_filename
        if filename:
            modulename = _modname(filename)
        else:
            modulename = None

        funcname = code.co_name
        clsname = None
        if code in self._caller_cache:
            if self._caller_cache[code] is not None:
                clsname = self._caller_cache[code]
        else:
            self._caller_cache[code] = None
            ## use of gc.get_referrers() was suggested by Michael Hudson
            # all functions which refer to this code object
            funcs = [f for f in gc.get_referrers(code)
                         if inspect.isfunction(f)]
            # require len(func) == 1 to avoid ambiguity caused by calls to
            # new.function(): "In the face of ambiguity, refuse the
            # temptation to guess."
            if len(funcs) == 1:
                dicts = [d for d in gc.get_referrers(funcs[0])
                             if isinstance(d, dict)]
                if len(dicts) == 1:
                    classes = [c for c in gc.get_referrers(dicts[0])
                                   if hasattr(c, "__bases__")]
                    if len(classes) == 1:
                        # ditto for new.classobj()
                        clsname = classes[0].__name__
                        # cache the result - assumption is that new.* is
                        # not called later to disturb this relationship
                        # _caller_cache could be flushed if functions in
                        # the new module get called.
                        self._caller_cache[code] = clsname
        if clsname is not None:
            funcname = "%s.%s" % (clsname, funcname)

        return filename, modulename, funcname

    def globaltrace_trackcallers(self, frame, why, arg):
        """Handler for call events.

        Adds information about who called who to the self._callers dict.
        """
        if why == 'call':
            # XXX Should do a better job of identifying methods
            this_func = self.file_module_function_of(frame)
            parent_func = self.file_module_function_of(frame.f_back)
            self._callers[(parent_func, this_func)] = 1

    def globaltrace_countfuncs(self, frame, why, arg):
        """Handler for call events.

        Adds (filename, modulename, funcname) to the self._calledfuncs dict.
        """
        if why == 'call':
            this_func = self.file_module_function_of(frame)
            self._calledfuncs[this_func] = 1

    def globaltrace_lt(self, frame, why, arg):
        """Handler for call events.

        If the code block being entered is to be ignored, returns `None',
        else returns self.localtrace.
        """
        if why == 'call':
            code = frame.f_code
            filename = frame.f_globals.get('__file__', None)
            if filename:
                # XXX _modname() doesn't work right for packages, so
                # the ignore support won't work right for packages
                modulename = _modname(filename)
                if modulename is not None:
                    ignore_it = self.ignore.names(filename, modulename)
                    if not ignore_it:
                        if self.trace:
                            print((" --- modulename: %s, funcname: %s"
                                   % (modulename, code.co_name)))
                        return self.localtrace
            else:
                return None

    def localtrace_trace_and_count(self, frame, why, arg):
        if why == "line":
            # record the file name and line number of every trace
            filename = frame.f_code.co_filename
            lineno = frame.f_lineno
            key = filename, lineno
            self.counts[key] = self.counts.get(key, 0) + 1

            if self.start_time:
                print('%.2f' % (_time() - self.start_time), end=' ')
            bname = os.path.basename(filename)
            print("%s(%d): %s" % (bname, lineno,
                                  linecache.getline(filename, lineno)), end='')
        return self.localtrace

    def localtrace_trace(self, frame, why, arg):
        if why == "line":
            # record the file name and line number of every trace
            filename = frame.f_code.co_filename
            lineno = frame.f_lineno

            if self.start_time:
                print('%.2f' % (_time() - self.start_time), end=' ')
            bname = os.path.basename(filename)
            print("%s(%d): %s" % (bname, lineno,
                                  linecache.getline(filename, lineno)), end='')
        return self.localtrace

    def localtrace_count(self, frame, why, arg):
        if why == "line":
            filename = frame.f_code.co_filename
            lineno = frame.f_lineno
            key = filename, lineno
            self.counts[key] = self.counts.get(key, 0) + 1
        return self.localtrace

    def results(self):
        return CoverageResults(self.counts, infile=self.infile,
                               outfile=self.outfile,
                               calledfuncs=self._calledfuncs,
                               callers=self._callers)

def _err_exit(msg):
    sys.stderr.write("%s: %s\n" % (sys.argv[0], msg))
    sys.exit(1)

def main(argv=None):
    import getopt

    if argv is None:
        argv = sys.argv
    try:
        opts, prog_argv = getopt.getopt(argv[1:], "tcrRf:d:msC:lTg",
                                        ["help", "version", "trace", "count",
                                         "report", "no-report", "summary",
                                         "file=", "missing",
                                         "ignore-module=", "ignore-dir=",
                                         "coverdir=", "listfuncs",
                                         "trackcalls", "timing"])

    except getopt.error as msg:
        sys.stderr.write("%s: %s\n" % (sys.argv[0], msg))
        sys.stderr.write("Try `%s --help' for more information\n"
                         % sys.argv[0])
        sys.exit(1)

    trace = 0
    count = 0
    report = 0
    no_report = 0
    counts_file = None
    missing = 0
    ignore_modules = []
    ignore_dirs = []
    coverdir = None
    summary = 0
    listfuncs = False
    countcallers = False
    timing = False

    for opt, val in opts:
        if opt == "--help":
            _usage(sys.stdout)
            sys.exit(0)

        if opt == "--version":
            sys.stdout.write("trace 2.0\n")
            sys.exit(0)

        if opt == "-T" or opt == "--trackcalls":
            countcallers = True
            continue

        if opt == "-l" or opt == "--listfuncs":
            listfuncs = True
            continue

        if opt == "-g" or opt == "--timing":
            timing = True
            continue

        if opt == "-t" or opt == "--trace":
            trace = 1
            continue

        if opt == "-c" or opt == "--count":
            count = 1
            continue

        if opt == "-r" or opt == "--report":
            report = 1
            continue

        if opt == "-R" or opt == "--no-report":
            no_report = 1
            continue

        if opt == "-f" or opt == "--file":
            counts_file = val
            continue

        if opt == "-m" or opt == "--missing":
            missing = 1
            continue

        if opt == "-C" or opt == "--coverdir":
            coverdir = val
            continue

        if opt == "-s" or opt == "--summary":
            summary = 1
            continue

        if opt == "--ignore-module":
            for mod in val.split(","):
                ignore_modules.append(mod.strip())
            continue

        if opt == "--ignore-dir":
            for s in val.split(os.pathsep):
                s = os.path.expandvars(s)
                # should I also call expanduser? (after all, could use $HOME)

                s = s.replace("$prefix",
                              os.path.join(sys.base_prefix, "lib",
                                           "python" + sys.version[:3]))
                s = s.replace("$exec_prefix",
                              os.path.join(sys.base_exec_prefix, "lib",
                                           "python" + sys.version[:3]))
                s = os.path.normpath(s)
                ignore_dirs.append(s)
            continue

        assert 0, "Should never get here"

    if listfuncs and (count or trace):
        _err_exit("cannot specify both --listfuncs and (--trace or --count)")

    if not (count or trace or report or listfuncs or countcallers):
        _err_exit("must specify one of --trace, --count, --report, "
                  "--listfuncs, or --trackcalls")

    if report and no_report:
        _err_exit("cannot specify both --report and --no-report")

    if report and not counts_file:
        _err_exit("--report requires a --file")

    if no_report and len(prog_argv) == 0:
        _err_exit("missing name of file to run")

    # everything is ready
    if report:
        results = CoverageResults(infile=counts_file, outfile=counts_file)
        results.write_results(missing, summary=summary, coverdir=coverdir)
    else:
        sys.argv = prog_argv
        progname = prog_argv[0]
        sys.path[0] = os.path.split(progname)[0]

        t = Trace(count, trace, countfuncs=listfuncs,
                  countcallers=countcallers, ignoremods=ignore_modules,
                  ignoredirs=ignore_dirs, infile=counts_file,
                  outfile=counts_file, timing=timing)
        try:
            with open(progname) as fp:
                code = compile(fp.read(), progname, 'exec')
            # try to emulate __main__ namespace as much as possible
            globs = {
                '__file__': progname,
                '__name__': '__main__',
                '__package__': None,
                '__cached__': None,
            }
            t.runctx(code, globs, globs)
        except OSError as err:
            _err_exit("Cannot run file %r because: %s" % (sys.argv[0], err))
        except SystemExit:
            pass

        results = t.results()

        if not no_report:
            results.write_results(missing, summary=summary, coverdir=coverdir)

#  Deprecated API
def usage(outfile):
    _warn("The trace.usage() function is deprecated",
         DeprecationWarning, 2)
    _usage(outfile)

class Ignore(_Ignore):
    def __init__(self, modules=None, dirs=None):
        _warn("The class trace.Ignore is deprecated",
             DeprecationWarning, 2)
        _Ignore.__init__(self, modules, dirs)

def modname(path):
    _warn("The trace.modname() function is deprecated",
         DeprecationWarning, 2)
    return _modname(path)

def fullmodname(path):
    _warn("The trace.fullmodname() function is deprecated",
         DeprecationWarning, 2)
    return _fullmodname(path)

def find_lines_from_code(code, strs):
    _warn("The trace.find_lines_from_code() function is deprecated",
         DeprecationWarning, 2)
    return _find_lines_from_code(code, strs)

def find_lines(code, strs):
    _warn("The trace.find_lines() function is deprecated",
         DeprecationWarning, 2)
    return _find_lines(code, strs)

def find_strings(filename, encoding=None):
    _warn("The trace.find_strings() function is deprecated",
         DeprecationWarning, 2)
    return _find_strings(filename, encoding=None)

def find_executable_linenos(filename):
    _warn("The trace.find_executable_linenos() function is deprecated",
         DeprecationWarning, 2)
    return _find_executable_linenos(filename)

if __name__=='__main__':
    main()
                                                                                                                                                                                                                                                                              usr/lib/python3.4/traceback.py                                                                      0100644 0000000 0000000 00000025637 12415221636 014702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Extract, format and print information about Python stack traces."""

import linecache
import sys
import operator

__all__ = ['extract_stack', 'extract_tb', 'format_exception',
           'format_exception_only', 'format_list', 'format_stack',
           'format_tb', 'print_exc', 'format_exc', 'print_exception',
           'print_last', 'print_stack', 'print_tb',
           'clear_frames']

#
# Formatting and printing lists of traceback lines.
#

def _format_list_iter(extracted_list):
    for filename, lineno, name, line in extracted_list:
        item = '  File "{}", line {}, in {}\n'.format(filename, lineno, name)
        if line:
            item = item + '    {}\n'.format(line.strip())
        yield item

def print_list(extracted_list, file=None):
    """Print the list of tuples as returned by extract_tb() or
    extract_stack() as a formatted stack trace to the given file."""
    if file is None:
        file = sys.stderr
    for item in _format_list_iter(extracted_list):
        print(item, file=file, end="")

def format_list(extracted_list):
    """Format a list of traceback entry tuples for printing.

    Given a list of tuples as returned by extract_tb() or
    extract_stack(), return a list of strings ready for printing.
    Each string in the resulting list corresponds to the item with the
    same index in the argument list.  Each string ends in a newline;
    the strings may contain internal newlines as well, for those items
    whose source text line is not None.
    """
    return list(_format_list_iter(extracted_list))

#
# Printing and Extracting Tracebacks.
#

# extractor takes curr and needs to return a tuple of:
# - Frame object
# - Line number
# - Next item (same type as curr)
# In practice, curr is either a traceback or a frame.
def _extract_tb_or_stack_iter(curr, limit, extractor):
    if limit is None:
        limit = getattr(sys, 'tracebacklimit', None)

    n = 0
    while curr is not None and (limit is None or n < limit):
        f, lineno, next_item = extractor(curr)
        co = f.f_code
        filename = co.co_filename
        name = co.co_name

        linecache.checkcache(filename)
        line = linecache.getline(filename, lineno, f.f_globals)

        if line:
            line = line.strip()
        else:
            line = None

        yield (filename, lineno, name, line)
        curr = next_item
        n += 1

def _extract_tb_iter(tb, limit):
    return _extract_tb_or_stack_iter(
                tb, limit,
                operator.attrgetter("tb_frame", "tb_lineno", "tb_next"))

def print_tb(tb, limit=None, file=None):
    """Print up to 'limit' stack trace entries from the traceback 'tb'.

    If 'limit' is omitted or None, all entries are printed.  If 'file'
    is omitted or None, the output goes to sys.stderr; otherwise
    'file' should be an open file or file-like object with a write()
    method.
    """
    print_list(extract_tb(tb, limit=limit), file=file)

def format_tb(tb, limit=None):
    """A shorthand for 'format_list(extract_tb(tb, limit))'."""
    return format_list(extract_tb(tb, limit=limit))

def extract_tb(tb, limit=None):
    """Return list of up to limit pre-processed entries from traceback.

    This is useful for alternate formatting of stack traces.  If
    'limit' is omitted or None, all entries are extracted.  A
    pre-processed stack trace entry is a quadruple (filename, line
    number, function name, text) representing the information that is
    usually printed for a stack trace.  The text is a string with
    leading and trailing whitespace stripped; if the source is not
    available it is None.
    """
    return list(_extract_tb_iter(tb, limit=limit))

#
# Exception formatting and output.
#

_cause_message = (
    "\nThe above exception was the direct cause "
    "of the following exception:\n")

_context_message = (
    "\nDuring handling of the above exception, "
    "another exception occurred:\n")

def _iter_chain(exc, custom_tb=None, seen=None):
    if seen is None:
        seen = set()
    seen.add(exc)
    its = []
    context = exc.__context__
    cause = exc.__cause__
    if cause is not None and cause not in seen:
        its.append(_iter_chain(cause, False, seen))
        its.append([(_cause_message, None)])
    elif (context is not None and
          not exc.__suppress_context__ and
          context not in seen):
        its.append(_iter_chain(context, None, seen))
        its.append([(_context_message, None)])
    its.append([(exc, custom_tb or exc.__traceback__)])
    # itertools.chain is in an extension module and may be unavailable
    for it in its:
        yield from it

def _format_exception_iter(etype, value, tb, limit, chain):
    if chain:
        values = _iter_chain(value, tb)
    else:
        values = [(value, tb)]

    for value, tb in values:
        if isinstance(value, str):
            # This is a cause/context message line
            yield value + '\n'
            continue
        if tb:
            yield 'Traceback (most recent call last):\n'
            yield from _format_list_iter(_extract_tb_iter(tb, limit=limit))
        yield from _format_exception_only_iter(type(value), value)

def print_exception(etype, value, tb, limit=None, file=None, chain=True):
    """Print exception up to 'limit' stack trace entries from 'tb' to 'file'.

    This differs from print_tb() in the following ways: (1) if
    traceback is not None, it prints a header "Traceback (most recent
    call last):"; (2) it prints the exception type and value after the
    stack trace; (3) if type is SyntaxError and value has the
    appropriate format, it prints the line where the syntax error
    occurred with a caret on the next line indicating the approximate
    position of the error.
    """
    if file is None:
        file = sys.stderr
    for line in _format_exception_iter(etype, value, tb, limit, chain):
        print(line, file=file, end="")

def format_exception(etype, value, tb, limit=None, chain=True):
    """Format a stack trace and the exception information.

    The arguments have the same meaning as the corresponding arguments
    to print_exception().  The return value is a list of strings, each
    ending in a newline and some containing internal newlines.  When
    these lines are concatenated and printed, exactly the same text is
    printed as does print_exception().
    """
    return list(_format_exception_iter(etype, value, tb, limit, chain))

def format_exception_only(etype, value):
    """Format the exception part of a traceback.

    The arguments are the exception type and value such as given by
    sys.last_type and sys.last_value. The return value is a list of
    strings, each ending in a newline.

    Normally, the list contains a single string; however, for
    SyntaxError exceptions, it contains several lines that (when
    printed) display detailed information about where the syntax
    error occurred.

    The message indicating which exception occurred is always the last
    string in the list.

    """
    return list(_format_exception_only_iter(etype, value))

def _format_exception_only_iter(etype, value):
    # Gracefully handle (the way Python 2.4 and earlier did) the case of
    # being called with (None, None).
    if etype is None:
        yield _format_final_exc_line(etype, value)
        return

    stype = etype.__name__
    smod = etype.__module__
    if smod not in ("__main__", "builtins"):
        stype = smod + '.' + stype

    if not issubclass(etype, SyntaxError):
        yield _format_final_exc_line(stype, value)
        return

    # It was a syntax error; show exactly where the problem was found.
    filename = value.filename or "<string>"
    lineno = str(value.lineno) or '?'
    yield '  File "{}", line {}\n'.format(filename, lineno)

    badline = value.text
    offset = value.offset
    if badline is not None:
        yield '    {}\n'.format(badline.strip())
        if offset is not None:
            caretspace = badline.rstrip('\n')
            offset = min(len(caretspace), offset) - 1
            caretspace = caretspace[:offset].lstrip()
            # non-space whitespace (likes tabs) must be kept for alignment
            caretspace = ((c.isspace() and c or ' ') for c in caretspace)
            yield '    {}^\n'.format(''.join(caretspace))
    msg = value.msg or "<no detail available>"
    yield "{}: {}\n".format(stype, msg)

def _format_final_exc_line(etype, value):
    valuestr = _some_str(value)
    if value is None or not valuestr:
        line = "%s\n" % etype
    else:
        line = "%s: %s\n" % (etype, valuestr)
    return line

def _some_str(value):
    try:
        return str(value)
    except:
        return '<unprintable %s object>' % type(value).__name__

def print_exc(limit=None, file=None, chain=True):
    """Shorthand for 'print_exception(*sys.exc_info(), limit, file)'."""
    print_exception(*sys.exc_info(), limit=limit, file=file, chain=chain)

def format_exc(limit=None, chain=True):
    """Like print_exc() but return a string."""
    return "".join(format_exception(*sys.exc_info(), limit=limit, chain=chain))

def print_last(limit=None, file=None, chain=True):
    """This is a shorthand for 'print_exception(sys.last_type,
    sys.last_value, sys.last_traceback, limit, file)'."""
    if not hasattr(sys, "last_type"):
        raise ValueError("no last exception")
    print_exception(sys.last_type, sys.last_value, sys.last_traceback,
                    limit, file, chain)

#
# Printing and Extracting Stacks.
#

def _extract_stack_iter(f, limit=None):
    return _extract_tb_or_stack_iter(
                f, limit, lambda f: (f, f.f_lineno, f.f_back))

def _get_stack(f):
    if f is None:
        f = sys._getframe().f_back.f_back
    return f

def print_stack(f=None, limit=None, file=None):
    """Print a stack trace from its invocation point.

    The optional 'f' argument can be used to specify an alternate
    stack frame at which to start. The optional 'limit' and 'file'
    arguments have the same meaning as for print_exception().
    """
    print_list(extract_stack(_get_stack(f), limit=limit), file=file)

def format_stack(f=None, limit=None):
    """Shorthand for 'format_list(extract_stack(f, limit))'."""
    return format_list(extract_stack(_get_stack(f), limit=limit))

def extract_stack(f=None, limit=None):
    """Extract the raw traceback from the current stack frame.

    The return value has the same format as for extract_tb().  The
    optional 'f' and 'limit' arguments have the same meaning as for
    print_stack().  Each item in the list is a quadruple (filename,
    line number, function name, text), and the entries are in order
    from oldest to newest stack frame.
    """
    stack = list(_extract_stack_iter(_get_stack(f), limit=limit))
    stack.reverse()
    return stack

def clear_frames(tb):
    "Clear all references to local variables in the frames of a traceback."
    while tb is not None:
        try:
            tb.tb_frame.clear()
        except RuntimeError:
            # Ignore the exception raised if the frame is still executing.
            pass
        tb = tb.tb_next
                                                                                                 usr/lib/python3.4/tracemalloc.py                                                                    0100644 0000000 0000000 00000036443 12415221636 015246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        from collections import Sequence, Iterable
from functools import total_ordering
import fnmatch
import linecache
import os.path
import pickle

# Import types and functions implemented in C
from _tracemalloc import *
from _tracemalloc import _get_object_traceback, _get_traces


def _format_size(size, sign):
    for unit in ('B', 'KiB', 'MiB', 'GiB', 'TiB'):
        if abs(size) < 100 and unit != 'B':
            # 3 digits (xx.x UNIT)
            if sign:
                return "%+.1f %s" % (size, unit)
            else:
                return "%.1f %s" % (size, unit)
        if abs(size) < 10 * 1024 or unit == 'TiB':
            # 4 or 5 digits (xxxx UNIT)
            if sign:
                return "%+.0f %s" % (size, unit)
            else:
                return "%.0f %s" % (size, unit)
        size /= 1024


class Statistic:
    """
    Statistic difference on memory allocations between two Snapshot instance.
    """

    __slots__ = ('traceback', 'size', 'count')

    def __init__(self, traceback, size, count):
        self.traceback = traceback
        self.size = size
        self.count = count

    def __hash__(self):
        return hash((self.traceback, self.size, self.count))

    def __eq__(self, other):
        return (self.traceback == other.traceback
                and self.size == other.size
                and self.count == other.count)

    def __str__(self):
        text = ("%s: size=%s, count=%i"
                 % (self.traceback,
                    _format_size(self.size, False),
                    self.count))
        if self.count:
            average = self.size / self.count
            text += ", average=%s" % _format_size(average, False)
        return text

    def __repr__(self):
        return ('<Statistic traceback=%r size=%i count=%i>'
                % (self.traceback, self.size, self.count))

    def _sort_key(self):
        return (self.size, self.count, self.traceback)


class StatisticDiff:
    """
    Statistic difference on memory allocations between an old and a new
    Snapshot instance.
    """
    __slots__ = ('traceback', 'size', 'size_diff', 'count', 'count_diff')

    def __init__(self, traceback, size, size_diff, count, count_diff):
        self.traceback = traceback
        self.size = size
        self.size_diff = size_diff
        self.count = count
        self.count_diff = count_diff

    def __hash__(self):
        return hash((self.traceback, self.size, self.size_diff,
                     self.count, self.count_diff))

    def __eq__(self, other):
        return (self.traceback == other.traceback
                and self.size == other.size
                and self.size_diff == other.size_diff
                and self.count == other.count
                and self.count_diff == other.count_diff)

    def __str__(self):
        text = ("%s: size=%s (%s), count=%i (%+i)"
                % (self.traceback,
                   _format_size(self.size, False),
                   _format_size(self.size_diff, True),
                   self.count,
                   self.count_diff))
        if self.count:
            average = self.size / self.count
            text += ", average=%s" % _format_size(average, False)
        return text

    def __repr__(self):
        return ('<StatisticDiff traceback=%r size=%i (%+i) count=%i (%+i)>'
                % (self.traceback, self.size, self.size_diff,
                   self.count, self.count_diff))

    def _sort_key(self):
        return (abs(self.size_diff), self.size,
                abs(self.count_diff), self.count,
                self.traceback)


def _compare_grouped_stats(old_group, new_group):
    statistics = []
    for traceback, stat in new_group.items():
        previous = old_group.pop(traceback, None)
        if previous is not None:
            stat = StatisticDiff(traceback,
                                 stat.size, stat.size - previous.size,
                                 stat.count, stat.count - previous.count)
        else:
            stat = StatisticDiff(traceback,
                                 stat.size, stat.size,
                                 stat.count, stat.count)
        statistics.append(stat)

    for traceback, stat in old_group.items():
        stat = StatisticDiff(traceback, 0, -stat.size, 0, -stat.count)
        statistics.append(stat)
    return statistics


@total_ordering
class Frame:
    """
    Frame of a traceback.
    """
    __slots__ = ("_frame",)

    def __init__(self, frame):
        # frame is a tuple: (filename: str, lineno: int)
        self._frame = frame

    @property
    def filename(self):
        return self._frame[0]

    @property
    def lineno(self):
        return self._frame[1]

    def __eq__(self, other):
        return (self._frame == other._frame)

    def __lt__(self, other):
        return (self._frame < other._frame)

    def __hash__(self):
        return hash(self._frame)

    def __str__(self):
        return "%s:%s" % (self.filename, self.lineno)

    def __repr__(self):
        return "<Frame filename=%r lineno=%r>" % (self.filename, self.lineno)


@total_ordering
class Traceback(Sequence):
    """
    Sequence of Frame instances sorted from the most recent frame
    to the oldest frame.
    """
    __slots__ = ("_frames",)

    def __init__(self, frames):
        Sequence.__init__(self)
        # frames is a tuple of frame tuples: see Frame constructor for the
        # format of a frame tuple
        self._frames = frames

    def __len__(self):
        return len(self._frames)

    def __getitem__(self, index):
        if isinstance(index, slice):
            return tuple(Frame(trace) for trace in self._frames[index])
        else:
            return Frame(self._frames[index])

    def __contains__(self, frame):
        return frame._frame in self._frames

    def __hash__(self):
        return hash(self._frames)

    def __eq__(self, other):
        return (self._frames == other._frames)

    def __lt__(self, other):
        return (self._frames < other._frames)

    def __str__(self):
        return str(self[0])

    def __repr__(self):
        return "<Traceback %r>" % (tuple(self),)

    def format(self, limit=None):
        lines = []
        if limit is not None and limit < 0:
            return lines
        for frame in self[:limit]:
            lines.append('  File "%s", line %s'
                         % (frame.filename, frame.lineno))
            line = linecache.getline(frame.filename, frame.lineno).strip()
            if line:
                lines.append('    %s' % line)
        return lines


def get_object_traceback(obj):
    """
    Get the traceback where the Python object *obj* was allocated.
    Return a Traceback instance.

    Return None if the tracemalloc module is not tracing memory allocations or
    did not trace the allocation of the object.
    """
    frames = _get_object_traceback(obj)
    if frames is not None:
        return Traceback(frames)
    else:
        return None


class Trace:
    """
    Trace of a memory block.
    """
    __slots__ = ("_trace",)

    def __init__(self, trace):
        # trace is a tuple: (size, traceback), see Traceback constructor
        # for the format of the traceback tuple
        self._trace = trace

    @property
    def size(self):
        return self._trace[0]

    @property
    def traceback(self):
        return Traceback(self._trace[1])

    def __eq__(self, other):
        return (self._trace == other._trace)

    def __hash__(self):
        return hash(self._trace)

    def __str__(self):
        return "%s: %s" % (self.traceback, _format_size(self.size, False))

    def __repr__(self):
        return ("<Trace size=%s, traceback=%r>"
                % (_format_size(self.size, False), self.traceback))


class _Traces(Sequence):
    def __init__(self, traces):
        Sequence.__init__(self)
        # traces is a tuple of trace tuples: see Trace constructor
        self._traces = traces

    def __len__(self):
        return len(self._traces)

    def __getitem__(self, index):
        if isinstance(index, slice):
            return tuple(Trace(trace) for trace in self._traces[index])
        else:
            return Trace(self._traces[index])

    def __contains__(self, trace):
        return trace._trace in self._traces

    def __eq__(self, other):
        return (self._traces == other._traces)

    def __repr__(self):
        return "<Traces len=%s>" % len(self)


def _normalize_filename(filename):
    filename = os.path.normcase(filename)
    if filename.endswith(('.pyc', '.pyo')):
        filename = filename[:-1]
    return filename


class Filter:
    def __init__(self, inclusive, filename_pattern,
                 lineno=None, all_frames=False):
        self.inclusive = inclusive
        self._filename_pattern = _normalize_filename(filename_pattern)
        self.lineno = lineno
        self.all_frames = all_frames

    @property
    def filename_pattern(self):
        return self._filename_pattern

    def __match_frame(self, filename, lineno):
        filename = _normalize_filename(filename)
        if not fnmatch.fnmatch(filename, self._filename_pattern):
            return False
        if self.lineno is None:
            return True
        else:
            return (lineno == self.lineno)

    def _match_frame(self, filename, lineno):
        return self.__match_frame(filename, lineno) ^ (not self.inclusive)

    def _match_traceback(self, traceback):
        if self.all_frames:
            if any(self.__match_frame(filename, lineno)
                   for filename, lineno in traceback):
                return self.inclusive
            else:
                return (not self.inclusive)
        else:
            filename, lineno = traceback[0]
            return self._match_frame(filename, lineno)


class Snapshot:
    """
    Snapshot of traces of memory blocks allocated by Python.
    """

    def __init__(self, traces, traceback_limit):
        # traces is a tuple of trace tuples: see _Traces constructor for
        # the exact format
        self.traces = _Traces(traces)
        self.traceback_limit = traceback_limit

    def dump(self, filename):
        """
        Write the snapshot into a file.
        """
        with open(filename, "wb") as fp:
            pickle.dump(self, fp, pickle.HIGHEST_PROTOCOL)

    @staticmethod
    def load(filename):
        """
        Load a snapshot from a file.
        """
        with open(filename, "rb") as fp:
            return pickle.load(fp)

    def _filter_trace(self, include_filters, exclude_filters, trace):
        traceback = trace[1]
        if include_filters:
            if not any(trace_filter._match_traceback(traceback)
                       for trace_filter in include_filters):
                return False
        if exclude_filters:
            if any(not trace_filter._match_traceback(traceback)
                   for trace_filter in exclude_filters):
                return False
        return True

    def filter_traces(self, filters):
        """
        Create a new Snapshot instance with a filtered traces sequence, filters
        is a list of Filter instances.  If filters is an empty list, return a
        new Snapshot instance with a copy of the traces.
        """
        if not isinstance(filters, Iterable):
            raise TypeError("filters must be a list of filters, not %s"
                            % type(filters).__name__)
        if filters:
            include_filters = []
            exclude_filters = []
            for trace_filter in filters:
                if trace_filter.inclusive:
                    include_filters.append(trace_filter)
                else:
                    exclude_filters.append(trace_filter)
            new_traces = [trace for trace in self.traces._traces
                          if self._filter_trace(include_filters,
                                                exclude_filters,
                                                trace)]
        else:
            new_traces = self.traces._traces.copy()
        return Snapshot(new_traces, self.traceback_limit)

    def _group_by(self, key_type, cumulative):
        if key_type not in ('traceback', 'filename', 'lineno'):
            raise ValueError("unknown key_type: %r" % (key_type,))
        if cumulative and key_type not in ('lineno', 'filename'):
            raise ValueError("cumulative mode cannot by used "
                             "with key type %r" % key_type)

        stats = {}
        tracebacks = {}
        if not cumulative:
            for trace in self.traces._traces:
                size, trace_traceback = trace
                try:
                    traceback = tracebacks[trace_traceback]
                except KeyError:
                    if key_type == 'traceback':
                        frames = trace_traceback
                    elif key_type == 'lineno':
                        frames = trace_traceback[:1]
                    else: # key_type == 'filename':
                        frames = ((trace_traceback[0][0], 0),)
                    traceback = Traceback(frames)
                    tracebacks[trace_traceback] = traceback
                try:
                    stat = stats[traceback]
                    stat.size += size
                    stat.count += 1
                except KeyError:
                    stats[traceback] = Statistic(traceback, size, 1)
        else:
            # cumulative statistics
            for trace in self.traces._traces:
                size, trace_traceback = trace
                for frame in trace_traceback:
                    try:
                        traceback = tracebacks[frame]
                    except KeyError:
                        if key_type == 'lineno':
                            frames = (frame,)
                        else: # key_type == 'filename':
                            frames = ((frame[0], 0),)
                        traceback = Traceback(frames)
                        tracebacks[frame] = traceback
                    try:
                        stat = stats[traceback]
                        stat.size += size
                        stat.count += 1
                    except KeyError:
                        stats[traceback] = Statistic(traceback, size, 1)
        return stats

    def statistics(self, key_type, cumulative=False):
        """
        Group statistics by key_type. Return a sorted list of Statistic
        instances.
        """
        grouped = self._group_by(key_type, cumulative)
        statistics = list(grouped.values())
        statistics.sort(reverse=True, key=Statistic._sort_key)
        return statistics

    def compare_to(self, old_snapshot, key_type, cumulative=False):
        """
        Compute the differences with an old snapshot old_snapshot. Get
        statistics as a sorted list of StatisticDiff instances, grouped by
        group_by.
        """
        new_group = self._group_by(key_type, cumulative)
        old_group = old_snapshot._group_by(key_type, cumulative)
        statistics = _compare_grouped_stats(old_group, new_group)
        statistics.sort(reverse=True, key=StatisticDiff._sort_key)
        return statistics


def take_snapshot():
    """
    Take a snapshot of traces of memory blocks allocated by Python.
    """
    if not is_tracing():
        raise RuntimeError("the tracemalloc module must be tracing memory "
                           "allocations to take a snapshot")
    traces = _get_traces()
    traceback_limit = get_traceback_limit()
    return Snapshot(traces, traceback_limit)
                                                                                                                                                                                                                             usr/lib/python3.4/tty.py                                                                            0100644 0000000 0000000 00000001557 12415221636 013576  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Terminal utilities."""

# Author: Steen Lumholt.

from termios import *

__all__ = ["setraw", "setcbreak"]

# Indexes for termios list.
IFLAG = 0
OFLAG = 1
CFLAG = 2
LFLAG = 3
ISPEED = 4
OSPEED = 5
CC = 6

def setraw(fd, when=TCSAFLUSH):
    """Put terminal into a raw mode."""
    mode = tcgetattr(fd)
    mode[IFLAG] = mode[IFLAG] & ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON)
    mode[OFLAG] = mode[OFLAG] & ~(OPOST)
    mode[CFLAG] = mode[CFLAG] & ~(CSIZE | PARENB)
    mode[CFLAG] = mode[CFLAG] | CS8
    mode[LFLAG] = mode[LFLAG] & ~(ECHO | ICANON | IEXTEN | ISIG)
    mode[CC][VMIN] = 1
    mode[CC][VTIME] = 0
    tcsetattr(fd, when, mode)

def setcbreak(fd, when=TCSAFLUSH):
    """Put terminal into a cbreak mode."""
    mode = tcgetattr(fd)
    mode[LFLAG] = mode[LFLAG] & ~(ECHO | ICANON)
    mode[CC][VMIN] = 1
    mode[CC][VTIME] = 0
    tcsetattr(fd, when, mode)
                                                                                                                                                 usr/lib/python3.4/turtle.py                                                                         0100644 0000000 0000000 00000430273 12415221636 014276  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# turtle.py: a Tkinter based turtle graphics module for Python
# Version 1.1b - 4. 5. 2009
#
# Copyright (C) 2006 - 2010  Gregor Lingl
# email: glingl@aon.at
#
# This software is provided 'as-is', without any express or implied
# warranty.  In no event will the authors be held liable for any damages
# arising from the use of this software.
#
# Permission is granted to anyone to use this software for any purpose,
# including commercial applications, and to alter it and redistribute it
# freely, subject to the following restrictions:
#
# 1. The origin of this software must not be misrepresented; you must not
#    claim that you wrote the original software. If you use this software
#    in a product, an acknowledgment in the product documentation would be
#    appreciated but is not required.
# 2. Altered source versions must be plainly marked as such, and must not be
#    misrepresented as being the original software.
# 3. This notice may not be removed or altered from any source distribution.


"""
Turtle graphics is a popular way for introducing programming to
kids. It was part of the original Logo programming language developed
by Wally Feurzig and Seymour Papert in 1966.

Imagine a robotic turtle starting at (0, 0) in the x-y plane. After an ``import turtle``, give it
the command turtle.forward(15), and it moves (on-screen!) 15 pixels in
the direction it is facing, drawing a line as it moves. Give it the
command turtle.right(25), and it rotates in-place 25 degrees clockwise.

By combining together these and similar commands, intricate shapes and
pictures can easily be drawn.

----- turtle.py

This module is an extended reimplementation of turtle.py from the
Python standard distribution up to Python 2.5. (See: http://www.python.org)

It tries to keep the merits of turtle.py and to be (nearly) 100%
compatible with it. This means in the first place to enable the
learning programmer to use all the commands, classes and methods
interactively when using the module from within IDLE run with
the -n switch.

Roughly it has the following features added:

- Better animation of the turtle movements, especially of turning the
  turtle. So the turtles can more easily be used as a visual feedback
  instrument by the (beginning) programmer.

- Different turtle shapes, gif-images as turtle shapes, user defined
  and user controllable turtle shapes, among them compound
  (multicolored) shapes. Turtle shapes can be stretched and tilted, which
  makes turtles very versatile geometrical objects.

- Fine control over turtle movement and screen updates via delay(),
  and enhanced tracer() and speed() methods.

- Aliases for the most commonly used commands, like fd for forward etc.,
  following the early Logo traditions. This reduces the boring work of
  typing long sequences of commands, which often occur in a natural way
  when kids try to program fancy pictures on their first encounter with
  turtle graphics.

- Turtles now have an undo()-method with configurable undo-buffer.

- Some simple commands/methods for creating event driven programs
  (mouse-, key-, timer-events). Especially useful for programming games.

- A scrollable Canvas class. The default scrollable Canvas can be
  extended interactively as needed while playing around with the turtle(s).

- A TurtleScreen class with methods controlling background color or
  background image, window and canvas size and other properties of the
  TurtleScreen.

- There is a method, setworldcoordinates(), to install a user defined
  coordinate-system for the TurtleScreen.

- The implementation uses a 2-vector class named Vec2D, derived from tuple.
  This class is public, so it can be imported by the application programmer,
  which makes certain types of computations very natural and compact.

- Appearance of the TurtleScreen and the Turtles at startup/import can be
  configured by means of a turtle.cfg configuration file.
  The default configuration mimics the appearance of the old turtle module.

- If configured appropriately the module reads in docstrings from a docstring
  dictionary in some different language, supplied separately  and replaces
  the English ones by those read in. There is a utility function
  write_docstringdict() to write a dictionary with the original (English)
  docstrings to disc, so it can serve as a template for translations.

Behind the scenes there are some features included with possible
extensions in mind. These will be commented and documented elsewhere.

"""

_ver = "turtle 1.1b- - for Python 3.1   -  4. 5. 2009"

# print(_ver)

import tkinter as TK
import types
import math
import time
import inspect
import sys

from os.path import isfile, split, join
from copy import deepcopy
from tkinter import simpledialog

_tg_classes = ['ScrolledCanvas', 'TurtleScreen', 'Screen',
               'RawTurtle', 'Turtle', 'RawPen', 'Pen', 'Shape', 'Vec2D']
_tg_screen_functions = ['addshape', 'bgcolor', 'bgpic', 'bye',
        'clearscreen', 'colormode', 'delay', 'exitonclick', 'getcanvas',
        'getshapes', 'listen', 'mainloop', 'mode', 'numinput',
        'onkey', 'onkeypress', 'onkeyrelease', 'onscreenclick', 'ontimer',
        'register_shape', 'resetscreen', 'screensize', 'setup',
        'setworldcoordinates', 'textinput', 'title', 'tracer', 'turtles', 'update',
        'window_height', 'window_width']
_tg_turtle_functions = ['back', 'backward', 'begin_fill', 'begin_poly', 'bk',
        'circle', 'clear', 'clearstamp', 'clearstamps', 'clone', 'color',
        'degrees', 'distance', 'dot', 'down', 'end_fill', 'end_poly', 'fd',
        'fillcolor', 'filling', 'forward', 'get_poly', 'getpen', 'getscreen', 'get_shapepoly',
        'getturtle', 'goto', 'heading', 'hideturtle', 'home', 'ht', 'isdown',
        'isvisible', 'left', 'lt', 'onclick', 'ondrag', 'onrelease', 'pd',
        'pen', 'pencolor', 'pendown', 'pensize', 'penup', 'pos', 'position',
        'pu', 'radians', 'right', 'reset', 'resizemode', 'rt',
        'seth', 'setheading', 'setpos', 'setposition', 'settiltangle',
        'setundobuffer', 'setx', 'sety', 'shape', 'shapesize', 'shapetransform', 'shearfactor', 'showturtle',
        'speed', 'st', 'stamp', 'tilt', 'tiltangle', 'towards',
        'turtlesize', 'undo', 'undobufferentries', 'up', 'width',
        'write', 'xcor', 'ycor']
_tg_utilities = ['write_docstringdict', 'done']

__all__ = (_tg_classes + _tg_screen_functions + _tg_turtle_functions +
           _tg_utilities + ['Terminator']) # + _math_functions)

_alias_list = ['addshape', 'backward', 'bk', 'fd', 'ht', 'lt', 'pd', 'pos',
               'pu', 'rt', 'seth', 'setpos', 'setposition', 'st',
               'turtlesize', 'up', 'width']

_CFG = {"width" : 0.5,               # Screen
        "height" : 0.75,
        "canvwidth" : 400,
        "canvheight": 300,
        "leftright": None,
        "topbottom": None,
        "mode": "standard",          # TurtleScreen
        "colormode": 1.0,
        "delay": 10,
        "undobuffersize": 1000,      # RawTurtle
        "shape": "classic",
        "pencolor" : "black",
        "fillcolor" : "black",
        "resizemode" : "noresize",
        "visible" : True,
        "language": "english",        # docstrings
        "exampleturtle": "turtle",
        "examplescreen": "screen",
        "title": "Python Turtle Graphics",
        "using_IDLE": False
       }

def config_dict(filename):
    """Convert content of config-file into dictionary."""
    with open(filename, "r") as f:
        cfglines = f.readlines()
    cfgdict = {}
    for line in cfglines:
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        try:
            key, value = line.split("=")
        except:
            print("Bad line in config-file %s:\n%s" % (filename,line))
            continue
        key = key.strip()
        value = value.strip()
        if value in ["True", "False", "None", "''", '""']:
            value = eval(value)
        else:
            try:
                if "." in value:
                    value = float(value)
                else:
                    value = int(value)
            except:
                pass # value need not be converted
        cfgdict[key] = value
    return cfgdict

def readconfig(cfgdict):
    """Read config-files, change configuration-dict accordingly.

    If there is a turtle.cfg file in the current working directory,
    read it from there. If this contains an importconfig-value,
    say 'myway', construct filename turtle_mayway.cfg else use
    turtle.cfg and read it from the import-directory, where
    turtle.py is located.
    Update configuration dictionary first according to config-file,
    in the import directory, then according to config-file in the
    current working directory.
    If no config-file is found, the default configuration is used.
    """
    default_cfg = "turtle.cfg"
    cfgdict1 = {}
    cfgdict2 = {}
    if isfile(default_cfg):
        cfgdict1 = config_dict(default_cfg)
    if "importconfig" in cfgdict1:
        default_cfg = "turtle_%s.cfg" % cfgdict1["importconfig"]
    try:
        head, tail = split(__file__)
        cfg_file2 = join(head, default_cfg)
    except:
        cfg_file2 = ""
    if isfile(cfg_file2):
        cfgdict2 = config_dict(cfg_file2)
    _CFG.update(cfgdict2)
    _CFG.update(cfgdict1)

try:
    readconfig(_CFG)
except:
    print ("No configfile read, reason unknown")


class Vec2D(tuple):
    """A 2 dimensional vector class, used as a helper class
    for implementing turtle graphics.
    May be useful for turtle graphics programs also.
    Derived from tuple, so a vector is a tuple!

    Provides (for a, b vectors, k number):
       a+b vector addition
       a-b vector subtraction
       a*b inner product
       k*a and a*k multiplication with scalar
       |a| absolute value of a
       a.rotate(angle) rotation
    """
    def __new__(cls, x, y):
        return tuple.__new__(cls, (x, y))
    def __add__(self, other):
        return Vec2D(self[0]+other[0], self[1]+other[1])
    def __mul__(self, other):
        if isinstance(other, Vec2D):
            return self[0]*other[0]+self[1]*other[1]
        return Vec2D(self[0]*other, self[1]*other)
    def __rmul__(self, other):
        if isinstance(other, int) or isinstance(other, float):
            return Vec2D(self[0]*other, self[1]*other)
    def __sub__(self, other):
        return Vec2D(self[0]-other[0], self[1]-other[1])
    def __neg__(self):
        return Vec2D(-self[0], -self[1])
    def __abs__(self):
        return (self[0]**2 + self[1]**2)**0.5
    def rotate(self, angle):
        """rotate self counterclockwise by angle
        """
        perp = Vec2D(-self[1], self[0])
        angle = angle * math.pi / 180.0
        c, s = math.cos(angle), math.sin(angle)
        return Vec2D(self[0]*c+perp[0]*s, self[1]*c+perp[1]*s)
    def __getnewargs__(self):
        return (self[0], self[1])
    def __repr__(self):
        return "(%.2f,%.2f)" % self


##############################################################################
### From here up to line    : Tkinter - Interface for turtle.py            ###
### May be replaced by an interface to some different graphics toolkit     ###
##############################################################################

## helper functions for Scrolled Canvas, to forward Canvas-methods
## to ScrolledCanvas class

def __methodDict(cls, _dict):
    """helper function for Scrolled Canvas"""
    baseList = list(cls.__bases__)
    baseList.reverse()
    for _super in baseList:
        __methodDict(_super, _dict)
    for key, value in cls.__dict__.items():
        if type(value) == types.FunctionType:
            _dict[key] = value

def __methods(cls):
    """helper function for Scrolled Canvas"""
    _dict = {}
    __methodDict(cls, _dict)
    return _dict.keys()

__stringBody = (
    'def %(method)s(self, *args, **kw): return ' +
    'self.%(attribute)s.%(method)s(*args, **kw)')

def __forwardmethods(fromClass, toClass, toPart, exclude = ()):
    ### MANY CHANGES ###
    _dict_1 = {}
    __methodDict(toClass, _dict_1)
    _dict = {}
    mfc = __methods(fromClass)
    for ex in _dict_1.keys():
        if ex[:1] == '_' or ex[-1:] == '_' or ex in exclude or ex in mfc:
            pass
        else:
            _dict[ex] = _dict_1[ex]

    for method, func in _dict.items():
        d = {'method': method, 'func': func}
        if isinstance(toPart, str):
            execString = \
                __stringBody % {'method' : method, 'attribute' : toPart}
        exec(execString, d)
        setattr(fromClass, method, d[method])   ### NEWU!


class ScrolledCanvas(TK.Frame):
    """Modeled after the scrolled canvas class from Grayons's Tkinter book.

    Used as the default canvas, which pops up automatically when
    using turtle graphics functions or the Turtle class.
    """
    def __init__(self, master, width=500, height=350,
                                          canvwidth=600, canvheight=500):
        TK.Frame.__init__(self, master, width=width, height=height)
        self._rootwindow = self.winfo_toplevel()
        self.width, self.height = width, height
        self.canvwidth, self.canvheight = canvwidth, canvheight
        self.bg = "white"
        self._canvas = TK.Canvas(master, width=width, height=height,
                                 bg=self.bg, relief=TK.SUNKEN, borderwidth=2)
        self.hscroll = TK.Scrollbar(master, command=self._canvas.xview,
                                    orient=TK.HORIZONTAL)
        self.vscroll = TK.Scrollbar(master, command=self._canvas.yview)
        self._canvas.configure(xscrollcommand=self.hscroll.set,
                               yscrollcommand=self.vscroll.set)
        self.rowconfigure(0, weight=1, minsize=0)
        self.columnconfigure(0, weight=1, minsize=0)
        self._canvas.grid(padx=1, in_ = self, pady=1, row=0,
                column=0, rowspan=1, columnspan=1, sticky='news')
        self.vscroll.grid(padx=1, in_ = self, pady=1, row=0,
                column=1, rowspan=1, columnspan=1, sticky='news')
        self.hscroll.grid(padx=1, in_ = self, pady=1, row=1,
                column=0, rowspan=1, columnspan=1, sticky='news')
        self.reset()
        self._rootwindow.bind('<Configure>', self.onResize)

    def reset(self, canvwidth=None, canvheight=None, bg = None):
        """Adjust canvas and scrollbars according to given canvas size."""
        if canvwidth:
            self.canvwidth = canvwidth
        if canvheight:
            self.canvheight = canvheight
        if bg:
            self.bg = bg
        self._canvas.config(bg=bg,
                        scrollregion=(-self.canvwidth//2, -self.canvheight//2,
                                       self.canvwidth//2, self.canvheight//2))
        self._canvas.xview_moveto(0.5*(self.canvwidth - self.width + 30) /
                                                               self.canvwidth)
        self._canvas.yview_moveto(0.5*(self.canvheight- self.height + 30) /
                                                              self.canvheight)
        self.adjustScrolls()


    def adjustScrolls(self):
        """ Adjust scrollbars according to window- and canvas-size.
        """
        cwidth = self._canvas.winfo_width()
        cheight = self._canvas.winfo_height()
        self._canvas.xview_moveto(0.5*(self.canvwidth-cwidth)/self.canvwidth)
        self._canvas.yview_moveto(0.5*(self.canvheight-cheight)/self.canvheight)
        if cwidth < self.canvwidth or cheight < self.canvheight:
            self.hscroll.grid(padx=1, in_ = self, pady=1, row=1,
                              column=0, rowspan=1, columnspan=1, sticky='news')
            self.vscroll.grid(padx=1, in_ = self, pady=1, row=0,
                              column=1, rowspan=1, columnspan=1, sticky='news')
        else:
            self.hscroll.grid_forget()
            self.vscroll.grid_forget()

    def onResize(self, event):
        """self-explanatory"""
        self.adjustScrolls()

    def bbox(self, *args):
        """ 'forward' method, which canvas itself has inherited...
        """
        return self._canvas.bbox(*args)

    def cget(self, *args, **kwargs):
        """ 'forward' method, which canvas itself has inherited...
        """
        return self._canvas.cget(*args, **kwargs)

    def config(self, *args, **kwargs):
        """ 'forward' method, which canvas itself has inherited...
        """
        self._canvas.config(*args, **kwargs)

    def bind(self, *args, **kwargs):
        """ 'forward' method, which canvas itself has inherited...
        """
        self._canvas.bind(*args, **kwargs)

    def unbind(self, *args, **kwargs):
        """ 'forward' method, which canvas itself has inherited...
        """
        self._canvas.unbind(*args, **kwargs)

    def focus_force(self):
        """ 'forward' method, which canvas itself has inherited...
        """
        self._canvas.focus_force()

__forwardmethods(ScrolledCanvas, TK.Canvas, '_canvas')


class _Root(TK.Tk):
    """Root class for Screen based on Tkinter."""
    def __init__(self):
        TK.Tk.__init__(self)

    def setupcanvas(self, width, height, cwidth, cheight):
        self._canvas = ScrolledCanvas(self, width, height, cwidth, cheight)
        self._canvas.pack(expand=1, fill="both")

    def _getcanvas(self):
        return self._canvas

    def set_geometry(self, width, height, startx, starty):
        self.geometry("%dx%d%+d%+d"%(width, height, startx, starty))

    def ondestroy(self, destroy):
        self.wm_protocol("WM_DELETE_WINDOW", destroy)

    def win_width(self):
        return self.winfo_screenwidth()

    def win_height(self):
        return self.winfo_screenheight()

Canvas = TK.Canvas


class TurtleScreenBase(object):
    """Provide the basic graphics functionality.
       Interface between Tkinter and turtle.py.

       To port turtle.py to some different graphics toolkit
       a corresponding TurtleScreenBase class has to be implemented.
    """

    @staticmethod
    def _blankimage():
        """return a blank image object
        """
        img = TK.PhotoImage(width=1, height=1)
        img.blank()
        return img

    @staticmethod
    def _image(filename):
        """return an image object containing the
        imagedata from a gif-file named filename.
        """
        return TK.PhotoImage(file=filename)

    def __init__(self, cv):
        self.cv = cv
        if isinstance(cv, ScrolledCanvas):
            w = self.cv.canvwidth
            h = self.cv.canvheight
        else:  # expected: ordinary TK.Canvas
            w = int(self.cv.cget("width"))
            h = int(self.cv.cget("height"))
            self.cv.config(scrollregion = (-w//2, -h//2, w//2, h//2 ))
        self.canvwidth = w
        self.canvheight = h
        self.xscale = self.yscale = 1.0

    def _createpoly(self):
        """Create an invisible polygon item on canvas self.cv)
        """
        return self.cv.create_polygon((0, 0, 0, 0, 0, 0), fill="", outline="")

    def _drawpoly(self, polyitem, coordlist, fill=None,
                  outline=None, width=None, top=False):
        """Configure polygonitem polyitem according to provided
        arguments:
        coordlist is sequence of coordinates
        fill is filling color
        outline is outline color
        top is a boolean value, which specifies if polyitem
        will be put on top of the canvas' displaylist so it
        will not be covered by other items.
        """
        cl = []
        for x, y in coordlist:
            cl.append(x * self.xscale)
            cl.append(-y * self.yscale)
        self.cv.coords(polyitem, *cl)
        if fill is not None:
            self.cv.itemconfigure(polyitem, fill=fill)
        if outline is not None:
            self.cv.itemconfigure(polyitem, outline=outline)
        if width is not None:
            self.cv.itemconfigure(polyitem, width=width)
        if top:
            self.cv.tag_raise(polyitem)

    def _createline(self):
        """Create an invisible line item on canvas self.cv)
        """
        return self.cv.create_line(0, 0, 0, 0, fill="", width=2,
                                   capstyle = TK.ROUND)

    def _drawline(self, lineitem, coordlist=None,
                  fill=None, width=None, top=False):
        """Configure lineitem according to provided arguments:
        coordlist is sequence of coordinates
        fill is drawing color
        width is width of drawn line.
        top is a boolean value, which specifies if polyitem
        will be put on top of the canvas' displaylist so it
        will not be covered by other items.
        """
        if coordlist is not None:
            cl = []
            for x, y in coordlist:
                cl.append(x * self.xscale)
                cl.append(-y * self.yscale)
            self.cv.coords(lineitem, *cl)
        if fill is not None:
            self.cv.itemconfigure(lineitem, fill=fill)
        if width is not None:
            self.cv.itemconfigure(lineitem, width=width)
        if top:
            self.cv.tag_raise(lineitem)

    def _delete(self, item):
        """Delete graphics item from canvas.
        If item is"all" delete all graphics items.
        """
        self.cv.delete(item)

    def _update(self):
        """Redraw graphics items on canvas
        """
        self.cv.update()

    def _delay(self, delay):
        """Delay subsequent canvas actions for delay ms."""
        self.cv.after(delay)

    def _iscolorstring(self, color):
        """Check if the string color is a legal Tkinter color string.
        """
        try:
            rgb = self.cv.winfo_rgb(color)
            ok = True
        except TK.TclError:
            ok = False
        return ok

    def _bgcolor(self, color=None):
        """Set canvas' backgroundcolor if color is not None,
        else return backgroundcolor."""
        if color is not None:
            self.cv.config(bg = color)
            self._update()
        else:
            return self.cv.cget("bg")

    def _write(self, pos, txt, align, font, pencolor):
        """Write txt at pos in canvas with specified font
        and color.
        Return text item and x-coord of right bottom corner
        of text's bounding box."""
        x, y = pos
        x = x * self.xscale
        y = y * self.yscale
        anchor = {"left":"sw", "center":"s", "right":"se" }
        item = self.cv.create_text(x-1, -y, text = txt, anchor = anchor[align],
                                        fill = pencolor, font = font)
        x0, y0, x1, y1 = self.cv.bbox(item)
        self.cv.update()
        return item, x1-1

##    def _dot(self, pos, size, color):
##        """may be implemented for some other graphics toolkit"""

    def _onclick(self, item, fun, num=1, add=None):
        """Bind fun to mouse-click event on turtle.
        fun must be a function with two arguments, the coordinates
        of the clicked point on the canvas.
        num, the number of the mouse-button defaults to 1
        """
        if fun is None:
            self.cv.tag_unbind(item, "<Button-%s>" % num)
        else:
            def eventfun(event):
                x, y = (self.cv.canvasx(event.x)/self.xscale,
                        -self.cv.canvasy(event.y)/self.yscale)
                fun(x, y)
            self.cv.tag_bind(item, "<Button-%s>" % num, eventfun, add)

    def _onrelease(self, item, fun, num=1, add=None):
        """Bind fun to mouse-button-release event on turtle.
        fun must be a function with two arguments, the coordinates
        of the point on the canvas where mouse button is released.
        num, the number of the mouse-button defaults to 1

        If a turtle is clicked, first _onclick-event will be performed,
        then _onscreensclick-event.
        """
        if fun is None:
            self.cv.tag_unbind(item, "<Button%s-ButtonRelease>" % num)
        else:
            def eventfun(event):
                x, y = (self.cv.canvasx(event.x)/self.xscale,
                        -self.cv.canvasy(event.y)/self.yscale)
                fun(x, y)
            self.cv.tag_bind(item, "<Button%s-ButtonRelease>" % num,
                             eventfun, add)

    def _ondrag(self, item, fun, num=1, add=None):
        """Bind fun to mouse-move-event (with pressed mouse button) on turtle.
        fun must be a function with two arguments, the coordinates of the
        actual mouse position on the canvas.
        num, the number of the mouse-button defaults to 1

        Every sequence of mouse-move-events on a turtle is preceded by a
        mouse-click event on that turtle.
        """
        if fun is None:
            self.cv.tag_unbind(item, "<Button%s-Motion>" % num)
        else:
            def eventfun(event):
                try:
                    x, y = (self.cv.canvasx(event.x)/self.xscale,
                           -self.cv.canvasy(event.y)/self.yscale)
                    fun(x, y)
                except:
                    pass
            self.cv.tag_bind(item, "<Button%s-Motion>" % num, eventfun, add)

    def _onscreenclick(self, fun, num=1, add=None):
        """Bind fun to mouse-click event on canvas.
        fun must be a function with two arguments, the coordinates
        of the clicked point on the canvas.
        num, the number of the mouse-button defaults to 1

        If a turtle is clicked, first _onclick-event will be performed,
        then _onscreensclick-event.
        """
        if fun is None:
            self.cv.unbind("<Button-%s>" % num)
        else:
            def eventfun(event):
                x, y = (self.cv.canvasx(event.x)/self.xscale,
                        -self.cv.canvasy(event.y)/self.yscale)
                fun(x, y)
            self.cv.bind("<Button-%s>" % num, eventfun, add)

    def _onkeyrelease(self, fun, key):
        """Bind fun to key-release event of key.
        Canvas must have focus. See method listen
        """
        if fun is None:
            self.cv.unbind("<KeyRelease-%s>" % key, None)
        else:
            def eventfun(event):
                fun()
            self.cv.bind("<KeyRelease-%s>" % key, eventfun)

    def _onkeypress(self, fun, key=None):
        """If key is given, bind fun to key-press event of key.
        Otherwise bind fun to any key-press.
        Canvas must have focus. See method listen.
        """
        if fun is None:
            if key is None:
                self.cv.unbind("<KeyPress>", None)
            else:
                self.cv.unbind("<KeyPress-%s>" % key, None)
        else:
            def eventfun(event):
                fun()
            if key is None:
                self.cv.bind("<KeyPress>", eventfun)
            else:
                self.cv.bind("<KeyPress-%s>" % key, eventfun)

    def _listen(self):
        """Set focus on canvas (in order to collect key-events)
        """
        self.cv.focus_force()

    def _ontimer(self, fun, t):
        """Install a timer, which calls fun after t milliseconds.
        """
        if t == 0:
            self.cv.after_idle(fun)
        else:
            self.cv.after(t, fun)

    def _createimage(self, image):
        """Create and return image item on canvas.
        """
        return self.cv.create_image(0, 0, image=image)

    def _drawimage(self, item, pos, image):
        """Configure image item as to draw image object
        at position (x,y) on canvas)
        """
        x, y = pos
        self.cv.coords(item, (x * self.xscale, -y * self.yscale))
        self.cv.itemconfig(item, image=image)

    def _setbgpic(self, item, image):
        """Configure image item as to draw image object
        at center of canvas. Set item to the first item
        in the displaylist, so it will be drawn below
        any other item ."""
        self.cv.itemconfig(item, image=image)
        self.cv.tag_lower(item)

    def _type(self, item):
        """Return 'line' or 'polygon' or 'image' depending on
        type of item.
        """
        return self.cv.type(item)

    def _pointlist(self, item):
        """returns list of coordinate-pairs of points of item
        Example (for insiders):
        >>> from turtle import *
        >>> getscreen()._pointlist(getturtle().turtle._item)
        [(0.0, 9.9999999999999982), (0.0, -9.9999999999999982),
        (9.9999999999999982, 0.0)]
        >>> """
        cl = self.cv.coords(item)
        pl = [(cl[i], -cl[i+1]) for i in range(0, len(cl), 2)]
        return  pl

    def _setscrollregion(self, srx1, sry1, srx2, sry2):
        self.cv.config(scrollregion=(srx1, sry1, srx2, sry2))

    def _rescale(self, xscalefactor, yscalefactor):
        items = self.cv.find_all()
        for item in items:
            coordinates = list(self.cv.coords(item))
            newcoordlist = []
            while coordinates:
                x, y = coordinates[:2]
                newcoordlist.append(x * xscalefactor)
                newcoordlist.append(y * yscalefactor)
                coordinates = coordinates[2:]
            self.cv.coords(item, *newcoordlist)

    def _resize(self, canvwidth=None, canvheight=None, bg=None):
        """Resize the canvas the turtles are drawing on. Does
        not alter the drawing window.
        """
        # needs amendment
        if not isinstance(self.cv, ScrolledCanvas):
            return self.canvwidth, self.canvheight
        if canvwidth is canvheight is bg is None:
            return self.cv.canvwidth, self.cv.canvheight
        if canvwidth is not None:
            self.canvwidth = canvwidth
        if canvheight is not None:
            self.canvheight = canvheight
        self.cv.reset(canvwidth, canvheight, bg)

    def _window_size(self):
        """ Return the width and height of the turtle window.
        """
        width = self.cv.winfo_width()
        if width <= 1:  # the window isn't managed by a geometry manager
            width = self.cv['width']
        height = self.cv.winfo_height()
        if height <= 1: # the window isn't managed by a geometry manager
            height = self.cv['height']
        return width, height

    def mainloop(self):
        """Starts event loop - calling Tkinter's mainloop function.

        No argument.

        Must be last statement in a turtle graphics program.
        Must NOT be used if a script is run from within IDLE in -n mode
        (No subprocess) - for interactive use of turtle graphics.

        Example (for a TurtleScreen instance named screen):
        >>> screen.mainloop()

        """
        TK.mainloop()

    def textinput(self, title, prompt):
        """Pop up a dialog window for input of a string.

        Arguments: title is the title of the dialog window,
        prompt is a text mostly describing what information to input.

        Return the string input
        If the dialog is canceled, return None.

        Example (for a TurtleScreen instance named screen):
        >>> screen.textinput("NIM", "Name of first player:")

        """
        return simpledialog.askstring(title, prompt)

    def numinput(self, title, prompt, default=None, minval=None, maxval=None):
        """Pop up a dialog window for input of a number.

        Arguments: title is the title of the dialog window,
        prompt is a text mostly describing what numerical information to input.
        default: default value
        minval: minimum value for imput
        maxval: maximum value for input

        The number input must be in the range minval .. maxval if these are
        given. If not, a hint is issued and the dialog remains open for
        correction. Return the number input.
        If the dialog is canceled,  return None.

        Example (for a TurtleScreen instance named screen):
        >>> screen.numinput("Poker", "Your stakes:", 1000, minval=10, maxval=10000)

        """
        return simpledialog.askfloat(title, prompt, initialvalue=default,
                                     minvalue=minval, maxvalue=maxval)


##############################################################################
###                  End of Tkinter - interface                            ###
##############################################################################


class Terminator (Exception):
    """Will be raised in TurtleScreen.update, if _RUNNING becomes False.

    This stops execution of a turtle graphics script.
    Main purpose: use in the Demo-Viewer turtle.Demo.py.
    """
    pass


class TurtleGraphicsError(Exception):
    """Some TurtleGraphics Error
    """


class Shape(object):
    """Data structure modeling shapes.

    attribute _type is one of "polygon", "image", "compound"
    attribute _data is - depending on _type a poygon-tuple,
    an image or a list constructed using the addcomponent method.
    """
    def __init__(self, type_, data=None):
        self._type = type_
        if type_ == "polygon":
            if isinstance(data, list):
                data = tuple(data)
        elif type_ == "image":
            if isinstance(data, str):
                if data.lower().endswith(".gif") and isfile(data):
                    data = TurtleScreen._image(data)
                # else data assumed to be Photoimage
        elif type_ == "compound":
            data = []
        else:
            raise TurtleGraphicsError("There is no shape type %s" % type_)
        self._data = data

    def addcomponent(self, poly, fill, outline=None):
        """Add component to a shape of type compound.

        Arguments: poly is a polygon, i. e. a tuple of number pairs.
        fill is the fillcolor of the component,
        outline is the outline color of the component.

        call (for a Shapeobject namend s):
        --   s.addcomponent(((0,0), (10,10), (-10,10)), "red", "blue")

        Example:
        >>> poly = ((0,0),(10,-5),(0,10),(-10,-5))
        >>> s = Shape("compound")
        >>> s.addcomponent(poly, "red", "blue")
        >>> # .. add more components and then use register_shape()
        """
        if self._type != "compound":
            raise TurtleGraphicsError("Cannot add component to %s Shape"
                                                                % self._type)
        if outline is None:
            outline = fill
        self._data.append([poly, fill, outline])


class Tbuffer(object):
    """Ring buffer used as undobuffer for RawTurtle objects."""
    def __init__(self, bufsize=10):
        self.bufsize = bufsize
        self.buffer = [[None]] * bufsize
        self.ptr = -1
        self.cumulate = False
    def reset(self, bufsize=None):
        if bufsize is None:
            for i in range(self.bufsize):
                self.buffer[i] = [None]
        else:
            self.bufsize = bufsize
            self.buffer = [[None]] * bufsize
        self.ptr = -1
    def push(self, item):
        if self.bufsize > 0:
            if not self.cumulate:
                self.ptr = (self.ptr + 1) % self.bufsize
                self.buffer[self.ptr] = item
            else:
                self.buffer[self.ptr].append(item)
    def pop(self):
        if self.bufsize > 0:
            item = self.buffer[self.ptr]
            if item is None:
                return None
            else:
                self.buffer[self.ptr] = [None]
                self.ptr = (self.ptr - 1) % self.bufsize
                return (item)
    def nr_of_items(self):
        return self.bufsize - self.buffer.count([None])
    def __repr__(self):
        return str(self.buffer) + " " + str(self.ptr)



class TurtleScreen(TurtleScreenBase):
    """Provides screen oriented methods like setbg etc.

    Only relies upon the methods of TurtleScreenBase and NOT
    upon components of the underlying graphics toolkit -
    which is Tkinter in this case.
    """
    _RUNNING = True

    def __init__(self, cv, mode=_CFG["mode"],
                 colormode=_CFG["colormode"], delay=_CFG["delay"]):
        self._shapes = {
                   "arrow" : Shape("polygon", ((-10,0), (10,0), (0,10))),
                  "turtle" : Shape("polygon", ((0,16), (-2,14), (-1,10), (-4,7),
                              (-7,9), (-9,8), (-6,5), (-7,1), (-5,-3), (-8,-6),
                              (-6,-8), (-4,-5), (0,-7), (4,-5), (6,-8), (8,-6),
                              (5,-3), (7,1), (6,5), (9,8), (7,9), (4,7), (1,10),
                              (2,14))),
                  "circle" : Shape("polygon", ((10,0), (9.51,3.09), (8.09,5.88),
                              (5.88,8.09), (3.09,9.51), (0,10), (-3.09,9.51),
                              (-5.88,8.09), (-8.09,5.88), (-9.51,3.09), (-10,0),
                              (-9.51,-3.09), (-8.09,-5.88), (-5.88,-8.09),
                              (-3.09,-9.51), (-0.00,-10.00), (3.09,-9.51),
                              (5.88,-8.09), (8.09,-5.88), (9.51,-3.09))),
                  "square" : Shape("polygon", ((10,-10), (10,10), (-10,10),
                              (-10,-10))),
                "triangle" : Shape("polygon", ((10,-5.77), (0,11.55),
                              (-10,-5.77))),
                  "classic": Shape("polygon", ((0,0),(-5,-9),(0,-7),(5,-9))),
                   "blank" : Shape("image", self._blankimage())
                  }

        self._bgpics = {"nopic" : ""}

        TurtleScreenBase.__init__(self, cv)
        self._mode = mode
        self._delayvalue = delay
        self._colormode = _CFG["colormode"]
        self._keys = []
        self.clear()
        if sys.platform == 'darwin':
            # Force Turtle window to the front on OS X. This is needed because
            # the Turtle window will show behind the Terminal window when you
            # start the demo from the command line.
            rootwindow = cv.winfo_toplevel()
            rootwindow.call('wm', 'attributes', '.', '-topmost', '1')
            rootwindow.call('wm', 'attributes', '.', '-topmost', '0')

    def clear(self):
        """Delete all drawings and all turtles from the TurtleScreen.

        No argument.

        Reset empty TurtleScreen to its initial state: white background,
        no backgroundimage, no eventbindings and tracing on.

        Example (for a TurtleScreen instance named screen):
        >>> screen.clear()

        Note: this method is not available as function.
        """
        self._delayvalue = _CFG["delay"]
        self._colormode = _CFG["colormode"]
        self._delete("all")
        self._bgpic = self._createimage("")
        self._bgpicname = "nopic"
        self._tracing = 1
        self._updatecounter = 0
        self._turtles = []
        self.bgcolor("white")
        for btn in 1, 2, 3:
            self.onclick(None, btn)
        self.onkeypress(None)
        for key in self._keys[:]:
            self.onkey(None, key)
            self.onkeypress(None, key)
        Turtle._pen = None

    def mode(self, mode=None):
        """Set turtle-mode ('standard', 'logo' or 'world') and perform reset.

        Optional argument:
        mode -- on of the strings 'standard', 'logo' or 'world'

        Mode 'standard' is compatible with turtle.py.
        Mode 'logo' is compatible with most Logo-Turtle-Graphics.
        Mode 'world' uses userdefined 'worldcoordinates'. *Attention*: in
        this mode angles appear distorted if x/y unit-ratio doesn't equal 1.
        If mode is not given, return the current mode.

             Mode      Initial turtle heading     positive angles
         ------------|-------------------------|-------------------
          'standard'    to the right (east)       counterclockwise
            'logo'        upward    (north)         clockwise

        Examples:
        >>> mode('logo')   # resets turtle heading to north
        >>> mode()
        'logo'
        """
        if mode is None:
            return self._mode
        mode = mode.lower()
        if mode not in ["standard", "logo", "world"]:
            raise TurtleGraphicsError("No turtle-graphics-mode %s" % mode)
        self._mode = mode
        if mode in ["standard", "logo"]:
            self._setscrollregion(-self.canvwidth//2, -self.canvheight//2,
                                       self.canvwidth//2, self.canvheight//2)
            self.xscale = self.yscale = 1.0
        self.reset()

    def setworldcoordinates(self, llx, lly, urx, ury):
        """Set up a user defined coordinate-system.

        Arguments:
        llx -- a number, x-coordinate of lower left corner of canvas
        lly -- a number, y-coordinate of lower left corner of canvas
        urx -- a number, x-coordinate of upper right corner of canvas
        ury -- a number, y-coordinate of upper right corner of canvas

        Set up user coodinat-system and switch to mode 'world' if necessary.
        This performs a screen.reset. If mode 'world' is already active,
        all drawings are redrawn according to the new coordinates.

        But ATTENTION: in user-defined coordinatesystems angles may appear
        distorted. (see Screen.mode())

        Example (for a TurtleScreen instance named screen):
        >>> screen.setworldcoordinates(-10,-0.5,50,1.5)
        >>> for _ in range(36):
        ...     left(10)
        ...     forward(0.5)
        """
        if self.mode() != "world":
            self.mode("world")
        xspan = float(urx - llx)
        yspan = float(ury - lly)
        wx, wy = self._window_size()
        self.screensize(wx-20, wy-20)
        oldxscale, oldyscale = self.xscale, self.yscale
        self.xscale = self.canvwidth / xspan
        self.yscale = self.canvheight / yspan
        srx1 = llx * self.xscale
        sry1 = -ury * self.yscale
        srx2 = self.canvwidth + srx1
        sry2 = self.canvheight + sry1
        self._setscrollregion(srx1, sry1, srx2, sry2)
        self._rescale(self.xscale/oldxscale, self.yscale/oldyscale)
        self.update()

    def register_shape(self, name, shape=None):
        """Adds a turtle shape to TurtleScreen's shapelist.

        Arguments:
        (1) name is the name of a gif-file and shape is None.
            Installs the corresponding image shape.
            !! Image-shapes DO NOT rotate when turning the turtle,
            !! so they do not display the heading of the turtle!
        (2) name is an arbitrary string and shape is a tuple
            of pairs of coordinates. Installs the corresponding
            polygon shape
        (3) name is an arbitrary string and shape is a
            (compound) Shape object. Installs the corresponding
            compound shape.
        To use a shape, you have to issue the command shape(shapename).

        call: register_shape("turtle.gif")
        --or: register_shape("tri", ((0,0), (10,10), (-10,10)))

        Example (for a TurtleScreen instance named screen):
        >>> screen.register_shape("triangle", ((5,-3),(0,5),(-5,-3)))

        """
        if shape is None:
            # image
            if name.lower().endswith(".gif"):
                shape = Shape("image", self._image(name))
            else:
                raise TurtleGraphicsError("Bad arguments for register_shape.\n"
                                          + "Use  help(register_shape)" )
        elif isinstance(shape, tuple):
            shape = Shape("polygon", shape)
        ## else shape assumed to be Shape-instance
        self._shapes[name] = shape

    def _colorstr(self, color):
        """Return color string corresponding to args.

        Argument may be a string or a tuple of three
        numbers corresponding to actual colormode,
        i.e. in the range 0<=n<=colormode.

        If the argument doesn't represent a color,
        an error is raised.
        """
        if len(color) == 1:
            color = color[0]
        if isinstance(color, str):
            if self._iscolorstring(color) or color == "":
                return color
            else:
                raise TurtleGraphicsError("bad color string: %s" % str(color))
        try:
            r, g, b = color
        except:
            raise TurtleGraphicsError("bad color arguments: %s" % str(color))
        if self._colormode == 1.0:
            r, g, b = [round(255.0*x) for x in (r, g, b)]
        if not ((0 <= r <= 255) and (0 <= g <= 255) and (0 <= b <= 255)):
            raise TurtleGraphicsError("bad color sequence: %s" % str(color))
        return "#%02x%02x%02x" % (r, g, b)

    def _color(self, cstr):
        if not cstr.startswith("#"):
            return cstr
        if len(cstr) == 7:
            cl = [int(cstr[i:i+2], 16) for i in (1, 3, 5)]
        elif len(cstr) == 4:
            cl = [16*int(cstr[h], 16) for h in cstr[1:]]
        else:
            raise TurtleGraphicsError("bad colorstring: %s" % cstr)
        return tuple([c * self._colormode/255 for c in cl])

    def colormode(self, cmode=None):
        """Return the colormode or set it to 1.0 or 255.

        Optional argument:
        cmode -- one of the values 1.0 or 255

        r, g, b values of colortriples have to be in range 0..cmode.

        Example (for a TurtleScreen instance named screen):
        >>> screen.colormode()
        1.0
        >>> screen.colormode(255)
        >>> pencolor(240,160,80)
        """
        if cmode is None:
            return self._colormode
        if cmode == 1.0:
            self._colormode = float(cmode)
        elif cmode == 255:
            self._colormode = int(cmode)

    def reset(self):
        """Reset all Turtles on the Screen to their initial state.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.reset()
        """
        for turtle in self._turtles:
            turtle._setmode(self._mode)
            turtle.reset()

    def turtles(self):
        """Return the list of turtles on the screen.

        Example (for a TurtleScreen instance named screen):
        >>> screen.turtles()
        [<turtle.Turtle object at 0x00E11FB0>]
        """
        return self._turtles

    def bgcolor(self, *args):
        """Set or return backgroundcolor of the TurtleScreen.

        Arguments (if given): a color string or three numbers
        in the range 0..colormode or a 3-tuple of such numbers.

        Example (for a TurtleScreen instance named screen):
        >>> screen.bgcolor("orange")
        >>> screen.bgcolor()
        'orange'
        >>> screen.bgcolor(0.5,0,0.5)
        >>> screen.bgcolor()
        '#800080'
        """
        if args:
            color = self._colorstr(args)
        else:
            color = None
        color = self._bgcolor(color)
        if color is not None:
            color = self._color(color)
        return color

    def tracer(self, n=None, delay=None):
        """Turns turtle animation on/off and set delay for update drawings.

        Optional arguments:
        n -- nonnegative  integer
        delay -- nonnegative  integer

        If n is given, only each n-th regular screen update is really performed.
        (Can be used to accelerate the drawing of complex graphics.)
        Second arguments sets delay value (see RawTurtle.delay())

        Example (for a TurtleScreen instance named screen):
        >>> screen.tracer(8, 25)
        >>> dist = 2
        >>> for i in range(200):
        ...     fd(dist)
        ...     rt(90)
        ...     dist += 2
        """
        if n is None:
            return self._tracing
        self._tracing = int(n)
        self._updatecounter = 0
        if delay is not None:
            self._delayvalue = int(delay)
        if self._tracing:
            self.update()

    def delay(self, delay=None):
        """ Return or set the drawing delay in milliseconds.

        Optional argument:
        delay -- positive integer

        Example (for a TurtleScreen instance named screen):
        >>> screen.delay(15)
        >>> screen.delay()
        15
        """
        if delay is None:
            return self._delayvalue
        self._delayvalue = int(delay)

    def _incrementudc(self):
        """Increment update counter."""
        if not TurtleScreen._RUNNING:
            TurtleScreen._RUNNNING = True
            raise Terminator
        if self._tracing > 0:
            self._updatecounter += 1
            self._updatecounter %= self._tracing

    def update(self):
        """Perform a TurtleScreen update.
        """
        tracing = self._tracing
        self._tracing = True
        for t in self.turtles():
            t._update_data()
            t._drawturtle()
        self._tracing = tracing
        self._update()

    def window_width(self):
        """ Return the width of the turtle window.

        Example (for a TurtleScreen instance named screen):
        >>> screen.window_width()
        640
        """
        return self._window_size()[0]

    def window_height(self):
        """ Return the height of the turtle window.

        Example (for a TurtleScreen instance named screen):
        >>> screen.window_height()
        480
        """
        return self._window_size()[1]

    def getcanvas(self):
        """Return the Canvas of this TurtleScreen.

        No argument.

        Example (for a Screen instance named screen):
        >>> cv = screen.getcanvas()
        >>> cv
        <turtle.ScrolledCanvas instance at 0x010742D8>
        """
        return self.cv

    def getshapes(self):
        """Return a list of names of all currently available turtle shapes.

        No argument.

        Example (for a TurtleScreen instance named screen):
        >>> screen.getshapes()
        ['arrow', 'blank', 'circle', ... , 'turtle']
        """
        return sorted(self._shapes.keys())

    def onclick(self, fun, btn=1, add=None):
        """Bind fun to mouse-click event on canvas.

        Arguments:
        fun -- a function with two arguments, the coordinates of the
               clicked point on the canvas.
        num -- the number of the mouse-button, defaults to 1

        Example (for a TurtleScreen instance named screen)

        >>> screen.onclick(goto)
        >>> # Subsequently clicking into the TurtleScreen will
        >>> # make the turtle move to the clicked point.
        >>> screen.onclick(None)
        """
        self._onscreenclick(fun, btn, add)

    def onkey(self, fun, key):
        """Bind fun to key-release event of key.

        Arguments:
        fun -- a function with no arguments
        key -- a string: key (e.g. "a") or key-symbol (e.g. "space")

        In order to be able to register key-events, TurtleScreen
        must have focus. (See method listen.)

        Example (for a TurtleScreen instance named screen):

        >>> def f():
        ...     fd(50)
        ...     lt(60)
        ...
        >>> screen.onkey(f, "Up")
        >>> screen.listen()

        Subsequently the turtle can be moved by repeatedly pressing
        the up-arrow key, consequently drawing a hexagon

        """
        if fun is None:
            if key in self._keys:
                self._keys.remove(key)
        elif key not in self._keys:
            self._keys.append(key)
        self._onkeyrelease(fun, key)

    def onkeypress(self, fun, key=None):
        """Bind fun to key-press event of key if key is given,
        or to any key-press-event if no key is given.

        Arguments:
        fun -- a function with no arguments
        key -- a string: key (e.g. "a") or key-symbol (e.g. "space")

        In order to be able to register key-events, TurtleScreen
        must have focus. (See method listen.)

        Example (for a TurtleScreen instance named screen
        and a Turtle instance named turtle):

        >>> def f():
        ...     fd(50)
        ...     lt(60)
        ...
        >>> screen.onkeypress(f, "Up")
        >>> screen.listen()

        Subsequently the turtle can be moved by repeatedly pressing
        the up-arrow key, or by keeping pressed the up-arrow key.
        consequently drawing a hexagon.
        """
        if fun is None:
            if key in self._keys:
                self._keys.remove(key)
        elif key is not None and key not in self._keys:
            self._keys.append(key)
        self._onkeypress(fun, key)

    def listen(self, xdummy=None, ydummy=None):
        """Set focus on TurtleScreen (in order to collect key-events)

        No arguments.
        Dummy arguments are provided in order
        to be able to pass listen to the onclick method.

        Example (for a TurtleScreen instance named screen):
        >>> screen.listen()
        """
        self._listen()

    def ontimer(self, fun, t=0):
        """Install a timer, which calls fun after t milliseconds.

        Arguments:
        fun -- a function with no arguments.
        t -- a number >= 0

        Example (for a TurtleScreen instance named screen):

        >>> running = True
        >>> def f():
        ...     if running:
        ...             fd(50)
        ...             lt(60)
        ...             screen.ontimer(f, 250)
        ...
        >>> f()   # makes the turtle marching around
        >>> running = False
        """
        self._ontimer(fun, t)

    def bgpic(self, picname=None):
        """Set background image or return name of current backgroundimage.

        Optional argument:
        picname -- a string, name of a gif-file or "nopic".

        If picname is a filename, set the corresponding image as background.
        If picname is "nopic", delete backgroundimage, if present.
        If picname is None, return the filename of the current backgroundimage.

        Example (for a TurtleScreen instance named screen):
        >>> screen.bgpic()
        'nopic'
        >>> screen.bgpic("landscape.gif")
        >>> screen.bgpic()
        'landscape.gif'
        """
        if picname is None:
            return self._bgpicname
        if picname not in self._bgpics:
            self._bgpics[picname] = self._image(picname)
        self._setbgpic(self._bgpic, self._bgpics[picname])
        self._bgpicname = picname

    def screensize(self, canvwidth=None, canvheight=None, bg=None):
        """Resize the canvas the turtles are drawing on.

        Optional arguments:
        canvwidth -- positive integer, new width of canvas in pixels
        canvheight --  positive integer, new height of canvas in pixels
        bg -- colorstring or color-tuple, new backgroundcolor
        If no arguments are given, return current (canvaswidth, canvasheight)

        Do not alter the drawing window. To observe hidden parts of
        the canvas use the scrollbars. (Can make visible those parts
        of a drawing, which were outside the canvas before!)

        Example (for a Turtle instance named turtle):
        >>> turtle.screensize(2000,1500)
        >>> # e.g. to search for an erroneously escaped turtle ;-)
        """
        return self._resize(canvwidth, canvheight, bg)

    onscreenclick = onclick
    resetscreen = reset
    clearscreen = clear
    addshape = register_shape
    onkeyrelease = onkey

class TNavigator(object):
    """Navigation part of the RawTurtle.
    Implements methods for turtle movement.
    """
    START_ORIENTATION = {
        "standard": Vec2D(1.0, 0.0),
        "world"   : Vec2D(1.0, 0.0),
        "logo"    : Vec2D(0.0, 1.0)  }
    DEFAULT_MODE = "standard"
    DEFAULT_ANGLEOFFSET = 0
    DEFAULT_ANGLEORIENT = 1

    def __init__(self, mode=DEFAULT_MODE):
        self._angleOffset = self.DEFAULT_ANGLEOFFSET
        self._angleOrient = self.DEFAULT_ANGLEORIENT
        self._mode = mode
        self.undobuffer = None
        self.degrees()
        self._mode = None
        self._setmode(mode)
        TNavigator.reset(self)

    def reset(self):
        """reset turtle to its initial values

        Will be overwritten by parent class
        """
        self._position = Vec2D(0.0, 0.0)
        self._orient =  TNavigator.START_ORIENTATION[self._mode]

    def _setmode(self, mode=None):
        """Set turtle-mode to 'standard', 'world' or 'logo'.
        """
        if mode is None:
            return self._mode
        if mode not in ["standard", "logo", "world"]:
            return
        self._mode = mode
        if mode in ["standard", "world"]:
            self._angleOffset = 0
            self._angleOrient = 1
        else: # mode == "logo":
            self._angleOffset = self._fullcircle/4.
            self._angleOrient = -1

    def _setDegreesPerAU(self, fullcircle):
        """Helper function for degrees() and radians()"""
        self._fullcircle = fullcircle
        self._degreesPerAU = 360/fullcircle
        if self._mode == "standard":
            self._angleOffset = 0
        else:
            self._angleOffset = fullcircle/4.

    def degrees(self, fullcircle=360.0):
        """ Set angle measurement units to degrees.

        Optional argument:
        fullcircle -  a number

        Set angle measurement units, i. e. set number
        of 'degrees' for a full circle. Dafault value is
        360 degrees.

        Example (for a Turtle instance named turtle):
        >>> turtle.left(90)
        >>> turtle.heading()
        90

        Change angle measurement unit to grad (also known as gon,
        grade, or gradian and equals 1/100-th of the right angle.)
        >>> turtle.degrees(400.0)
        >>> turtle.heading()
        100

        """
        self._setDegreesPerAU(fullcircle)

    def radians(self):
        """ Set the angle measurement units to radians.

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> turtle.heading()
        90
        >>> turtle.radians()
        >>> turtle.heading()
        1.5707963267948966
        """
        self._setDegreesPerAU(2*math.pi)

    def _go(self, distance):
        """move turtle forward by specified distance"""
        ende = self._position + self._orient * distance
        self._goto(ende)

    def _rotate(self, angle):
        """Turn turtle counterclockwise by specified angle if angle > 0."""
        angle *= self._degreesPerAU
        self._orient = self._orient.rotate(angle)

    def _goto(self, end):
        """move turtle to position end."""
        self._position = end

    def forward(self, distance):
        """Move the turtle forward by the specified distance.

        Aliases: forward | fd

        Argument:
        distance -- a number (integer or float)

        Move the turtle forward by the specified distance, in the direction
        the turtle is headed.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 0.00)
        >>> turtle.forward(25)
        >>> turtle.position()
        (25.00,0.00)
        >>> turtle.forward(-75)
        >>> turtle.position()
        (-50.00,0.00)
        """
        self._go(distance)

    def back(self, distance):
        """Move the turtle backward by distance.

        Aliases: back | backward | bk

        Argument:
        distance -- a number

        Move the turtle backward by distance ,opposite to the direction the
        turtle is headed. Do not change the turtle's heading.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 0.00)
        >>> turtle.backward(30)
        >>> turtle.position()
        (-30.00, 0.00)
        """
        self._go(-distance)

    def right(self, angle):
        """Turn turtle right by angle units.

        Aliases: right | rt

        Argument:
        angle -- a number (integer or float)

        Turn turtle right by angle units. (Units are by default degrees,
        but can be set via the degrees() and radians() functions.)
        Angle orientation depends on mode. (See this.)

        Example (for a Turtle instance named turtle):
        >>> turtle.heading()
        22.0
        >>> turtle.right(45)
        >>> turtle.heading()
        337.0
        """
        self._rotate(-angle)

    def left(self, angle):
        """Turn turtle left by angle units.

        Aliases: left | lt

        Argument:
        angle -- a number (integer or float)

        Turn turtle left by angle units. (Units are by default degrees,
        but can be set via the degrees() and radians() functions.)
        Angle orientation depends on mode. (See this.)

        Example (for a Turtle instance named turtle):
        >>> turtle.heading()
        22.0
        >>> turtle.left(45)
        >>> turtle.heading()
        67.0
        """
        self._rotate(angle)

    def pos(self):
        """Return the turtle's current location (x,y), as a Vec2D-vector.

        Aliases: pos | position

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> turtle.pos()
        (0.00, 240.00)
        """
        return self._position

    def xcor(self):
        """ Return the turtle's x coordinate.

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> reset()
        >>> turtle.left(60)
        >>> turtle.forward(100)
        >>> print turtle.xcor()
        50.0
        """
        return self._position[0]

    def ycor(self):
        """ Return the turtle's y coordinate
        ---
        No arguments.

        Example (for a Turtle instance named turtle):
        >>> reset()
        >>> turtle.left(60)
        >>> turtle.forward(100)
        >>> print turtle.ycor()
        86.6025403784
        """
        return self._position[1]


    def goto(self, x, y=None):
        """Move turtle to an absolute position.

        Aliases: setpos | setposition | goto:

        Arguments:
        x -- a number      or     a pair/vector of numbers
        y -- a number             None

        call: goto(x, y)         # two coordinates
        --or: goto((x, y))       # a pair (tuple) of coordinates
        --or: goto(vec)          # e.g. as returned by pos()

        Move turtle to an absolute position. If the pen is down,
        a line will be drawn. The turtle's orientation does not change.

        Example (for a Turtle instance named turtle):
        >>> tp = turtle.pos()
        >>> tp
        (0.00, 0.00)
        >>> turtle.setpos(60,30)
        >>> turtle.pos()
        (60.00,30.00)
        >>> turtle.setpos((20,80))
        >>> turtle.pos()
        (20.00,80.00)
        >>> turtle.setpos(tp)
        >>> turtle.pos()
        (0.00,0.00)
        """
        if y is None:
            self._goto(Vec2D(*x))
        else:
            self._goto(Vec2D(x, y))

    def home(self):
        """Move turtle to the origin - coordinates (0,0).

        No arguments.

        Move turtle to the origin - coordinates (0,0) and set its
        heading to its start-orientation (which depends on mode).

        Example (for a Turtle instance named turtle):
        >>> turtle.home()
        """
        self.goto(0, 0)
        self.setheading(0)

    def setx(self, x):
        """Set the turtle's first coordinate to x

        Argument:
        x -- a number (integer or float)

        Set the turtle's first coordinate to x, leave second coordinate
        unchanged.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 240.00)
        >>> turtle.setx(10)
        >>> turtle.position()
        (10.00, 240.00)
        """
        self._goto(Vec2D(x, self._position[1]))

    def sety(self, y):
        """Set the turtle's second coordinate to y

        Argument:
        y -- a number (integer or float)

        Set the turtle's first coordinate to x, second coordinate remains
        unchanged.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00, 40.00)
        >>> turtle.sety(-10)
        >>> turtle.position()
        (0.00, -10.00)
        """
        self._goto(Vec2D(self._position[0], y))

    def distance(self, x, y=None):
        """Return the distance from the turtle to (x,y) in turtle step units.

        Arguments:
        x -- a number   or  a pair/vector of numbers   or   a turtle instance
        y -- a number       None                            None

        call: distance(x, y)         # two coordinates
        --or: distance((x, y))       # a pair (tuple) of coordinates
        --or: distance(vec)          # e.g. as returned by pos()
        --or: distance(mypen)        # where mypen is another turtle

        Example (for a Turtle instance named turtle):
        >>> turtle.pos()
        (0.00, 0.00)
        >>> turtle.distance(30,40)
        50.0
        >>> pen = Turtle()
        >>> pen.forward(77)
        >>> turtle.distance(pen)
        77.0
        """
        if y is not None:
            pos = Vec2D(x, y)
        if isinstance(x, Vec2D):
            pos = x
        elif isinstance(x, tuple):
            pos = Vec2D(*x)
        elif isinstance(x, TNavigator):
            pos = x._position
        return abs(pos - self._position)

    def towards(self, x, y=None):
        """Return the angle of the line from the turtle's position to (x, y).

        Arguments:
        x -- a number   or  a pair/vector of numbers   or   a turtle instance
        y -- a number       None                            None

        call: distance(x, y)         # two coordinates
        --or: distance((x, y))       # a pair (tuple) of coordinates
        --or: distance(vec)          # e.g. as returned by pos()
        --or: distance(mypen)        # where mypen is another turtle

        Return the angle, between the line from turtle-position to position
        specified by x, y and the turtle's start orientation. (Depends on
        modes - "standard" or "logo")

        Example (for a Turtle instance named turtle):
        >>> turtle.pos()
        (10.00, 10.00)
        >>> turtle.towards(0,0)
        225.0
        """
        if y is not None:
            pos = Vec2D(x, y)
        if isinstance(x, Vec2D):
            pos = x
        elif isinstance(x, tuple):
            pos = Vec2D(*x)
        elif isinstance(x, TNavigator):
            pos = x._position
        x, y = pos - self._position
        result = round(math.atan2(y, x)*180.0/math.pi, 10) % 360.0
        result /= self._degreesPerAU
        return (self._angleOffset + self._angleOrient*result) % self._fullcircle

    def heading(self):
        """ Return the turtle's current heading.

        No arguments.

        Example (for a Turtle instance named turtle):
        >>> turtle.left(67)
        >>> turtle.heading()
        67.0
        """
        x, y = self._orient
        result = round(math.atan2(y, x)*180.0/math.pi, 10) % 360.0
        result /= self._degreesPerAU
        return (self._angleOffset + self._angleOrient*result) % self._fullcircle

    def setheading(self, to_angle):
        """Set the orientation of the turtle to to_angle.

        Aliases:  setheading | seth

        Argument:
        to_angle -- a number (integer or float)

        Set the orientation of the turtle to to_angle.
        Here are some common directions in degrees:

         standard - mode:          logo-mode:
        -------------------|--------------------
           0 - east                0 - north
          90 - north              90 - east
         180 - west              180 - south
         270 - south             270 - west

        Example (for a Turtle instance named turtle):
        >>> turtle.setheading(90)
        >>> turtle.heading()
        90
        """
        angle = (to_angle - self.heading())*self._angleOrient
        full = self._fullcircle
        angle = (angle+full/2.)%full - full/2.
        self._rotate(angle)

    def circle(self, radius, extent = None, steps = None):
        """ Draw a circle with given radius.

        Arguments:
        radius -- a number
        extent (optional) -- a number
        steps (optional) -- an integer

        Draw a circle with given radius. The center is radius units left
        of the turtle; extent - an angle - determines which part of the
        circle is drawn. If extent is not given, draw the entire circle.
        If extent is not a full circle, one endpoint of the arc is the
        current pen position. Draw the arc in counterclockwise direction
        if radius is positive, otherwise in clockwise direction. Finally
        the direction of the turtle is changed by the amount of extent.

        As the circle is approximated by an inscribed regular polygon,
        steps determines the number of steps to use. If not given,
        it will be calculated automatically. Maybe used to draw regular
        polygons.

        call: circle(radius)                  # full circle
        --or: circle(radius, extent)          # arc
        --or: circle(radius, extent, steps)
        --or: circle(radius, steps=6)         # 6-sided polygon

        Example (for a Turtle instance named turtle):
        >>> turtle.circle(50)
        >>> turtle.circle(120, 180)  # semicircle
        """
        if self.undobuffer:
            self.undobuffer.push(["seq"])
            self.undobuffer.cumulate = True
        speed = self.speed()
        if extent is None:
            extent = self._fullcircle
        if steps is None:
            frac = abs(extent)/self._fullcircle
            steps = 1+int(min(11+abs(radius)/6.0, 59.0)*frac)
        w = 1.0 * extent / steps
        w2 = 0.5 * w
        l = 2.0 * radius * math.sin(w2*math.pi/180.0*self._degreesPerAU)
        if radius < 0:
            l, w, w2 = -l, -w, -w2
        tr = self._tracer()
        dl = self._delay()
        if speed == 0:
            self._tracer(0, 0)
        else:
            self.speed(0)
        self._rotate(w2)
        for i in range(steps):
            self.speed(speed)
            self._go(l)
            self.speed(0)
            self._rotate(w)
        self._rotate(-w2)
        if speed == 0:
            self._tracer(tr, dl)
        self.speed(speed)
        if self.undobuffer:
            self.undobuffer.cumulate = False

## three dummy methods to be implemented by child class:

    def speed(self, s=0):
        """dummy method - to be overwritten by child class"""
    def _tracer(self, a=None, b=None):
        """dummy method - to be overwritten by child class"""
    def _delay(self, n=None):
        """dummy method - to be overwritten by child class"""

    fd = forward
    bk = back
    backward = back
    rt = right
    lt = left
    position = pos
    setpos = goto
    setposition = goto
    seth = setheading


class TPen(object):
    """Drawing part of the RawTurtle.
    Implements drawing properties.
    """
    def __init__(self, resizemode=_CFG["resizemode"]):
        self._resizemode = resizemode # or "user" or "noresize"
        self.undobuffer = None
        TPen._reset(self)

    def _reset(self, pencolor=_CFG["pencolor"],
                     fillcolor=_CFG["fillcolor"]):
        self._pensize = 1
        self._shown = True
        self._pencolor = pencolor
        self._fillcolor = fillcolor
        self._drawing = True
        self._speed = 3
        self._stretchfactor = (1., 1.)
        self._shearfactor = 0.
        self._tilt = 0.
        self._shapetrafo = (1., 0., 0., 1.)
        self._outlinewidth = 1

    def resizemode(self, rmode=None):
        """Set resizemode to one of the values: "auto", "user", "noresize".

        (Optional) Argument:
        rmode -- one of the strings "auto", "user", "noresize"

        Different resizemodes have the following effects:
          - "auto" adapts the appearance of the turtle
                   corresponding to the value of pensize.
          - "user" adapts the appearance of the turtle according to the
                   values of stretchfactor and outlinewidth (outline),
                   which are set by shapesize()
          - "noresize" no adaption of the turtle's appearance takes place.
        If no argument is given, return current resizemode.
        resizemode("user") is called by a call of shapesize with arguments.


        Examples (for a Turtle instance named turtle):
        >>> turtle.resizemode("noresize")
        >>> turtle.resizemode()
        'noresize'
        """
        if rmode is None:
            return self._resizemode
        rmode = rmode.lower()
        if rmode in ["auto", "user", "noresize"]:
            self.pen(resizemode=rmode)

    def pensize(self, width=None):
        """Set or return the line thickness.

        Aliases:  pensize | width

        Argument:
        width -- positive number

        Set the line thickness to width or return it. If resizemode is set
        to "auto" and turtleshape is a polygon, that polygon is drawn with
        the same line thickness. If no argument is given, current pensize
        is returned.

        Example (for a Turtle instance named turtle):
        >>> turtle.pensize()
        1
        >>> turtle.pensize(10)   # from here on lines of width 10 are drawn
        """
        if width is None:
            return self._pensize
        self.pen(pensize=width)


    def penup(self):
        """Pull the pen up -- no drawing when moving.

        Aliases: penup | pu | up

        No argument

        Example (for a Turtle instance named turtle):
        >>> turtle.penup()
        """
        if not self._drawing:
            return
        self.pen(pendown=False)

    def pendown(self):
        """Pull the pen down -- drawing when moving.

        Aliases: pendown | pd | down

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.pendown()
        """
        if self._drawing:
            return
        self.pen(pendown=True)

    def isdown(self):
        """Return True if pen is down, False if it's up.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.penup()
        >>> turtle.isdown()
        False
        >>> turtle.pendown()
        >>> turtle.isdown()
        True
        """
        return self._drawing

    def speed(self, speed=None):
        """ Return or set the turtle's speed.

        Optional argument:
        speed -- an integer in the range 0..10 or a speedstring (see below)

        Set the turtle's speed to an integer value in the range 0 .. 10.
        If no argument is given: return current speed.

        If input is a number greater than 10 or smaller than 0.5,
        speed is set to 0.
        Speedstrings  are mapped to speedvalues in the following way:
            'fastest' :  0
            'fast'    :  10
            'normal'  :  6
            'slow'    :  3
            'slowest' :  1
        speeds from 1 to 10 enforce increasingly faster animation of
        line drawing and turtle turning.

        Attention:
        speed = 0 : *no* animation takes place. forward/back makes turtle jump
        and likewise left/right make the turtle turn instantly.

        Example (for a Turtle instance named turtle):
        >>> turtle.speed(3)
        """
        speeds = {'fastest':0, 'fast':10, 'normal':6, 'slow':3, 'slowest':1 }
        if speed is None:
            return self._speed
        if speed in speeds:
            speed = speeds[speed]
        elif 0.5 < speed < 10.5:
            speed = int(round(speed))
        else:
            speed = 0
        self.pen(speed=speed)

    def color(self, *args):
        """Return or set the pencolor and fillcolor.

        Arguments:
        Several input formats are allowed.
        They use 0, 1, 2, or 3 arguments as follows:

        color()
            Return the current pencolor and the current fillcolor
            as a pair of color specification strings as are returned
            by pencolor and fillcolor.
        color(colorstring), color((r,g,b)), color(r,g,b)
            inputs as in pencolor, set both, fillcolor and pencolor,
            to the given value.
        color(colorstring1, colorstring2),
        color((r1,g1,b1), (r2,g2,b2))
            equivalent to pencolor(colorstring1) and fillcolor(colorstring2)
            and analogously, if the other input format is used.

        If turtleshape is a polygon, outline and interior of that polygon
        is drawn with the newly set colors.
        For mor info see: pencolor, fillcolor

        Example (for a Turtle instance named turtle):
        >>> turtle.color('red', 'green')
        >>> turtle.color()
        ('red', 'green')
        >>> colormode(255)
        >>> color((40, 80, 120), (160, 200, 240))
        >>> color()
        ('#285078', '#a0c8f0')
        """
        if args:
            l = len(args)
            if l == 1:
                pcolor = fcolor = args[0]
            elif l == 2:
                pcolor, fcolor = args
            elif l == 3:
                pcolor = fcolor = args
            pcolor = self._colorstr(pcolor)
            fcolor = self._colorstr(fcolor)
            self.pen(pencolor=pcolor, fillcolor=fcolor)
        else:
            return self._color(self._pencolor), self._color(self._fillcolor)

    def pencolor(self, *args):
        """ Return or set the pencolor.

        Arguments:
        Four input formats are allowed:
          - pencolor()
            Return the current pencolor as color specification string,
            possibly in hex-number format (see example).
            May be used as input to another color/pencolor/fillcolor call.
          - pencolor(colorstring)
            s is a Tk color specification string, such as "red" or "yellow"
          - pencolor((r, g, b))
            *a tuple* of r, g, and b, which represent, an RGB color,
            and each of r, g, and b are in the range 0..colormode,
            where colormode is either 1.0 or 255
          - pencolor(r, g, b)
            r, g, and b represent an RGB color, and each of r, g, and b
            are in the range 0..colormode

        If turtleshape is a polygon, the outline of that polygon is drawn
        with the newly set pencolor.

        Example (for a Turtle instance named turtle):
        >>> turtle.pencolor('brown')
        >>> tup = (0.2, 0.8, 0.55)
        >>> turtle.pencolor(tup)
        >>> turtle.pencolor()
        '#33cc8c'
        """
        if args:
            color = self._colorstr(args)
            if color == self._pencolor:
                return
            self.pen(pencolor=color)
        else:
            return self._color(self._pencolor)

    def fillcolor(self, *args):
        """ Return or set the fillcolor.

        Arguments:
        Four input formats are allowed:
          - fillcolor()
            Return the current fillcolor as color specification string,
            possibly in hex-number format (see example).
            May be used as input to another color/pencolor/fillcolor call.
          - fillcolor(colorstring)
            s is a Tk color specification string, such as "red" or "yellow"
          - fillcolor((r, g, b))
            *a tuple* of r, g, and b, which represent, an RGB color,
            and each of r, g, and b are in the range 0..colormode,
            where colormode is either 1.0 or 255
          - fillcolor(r, g, b)
            r, g, and b represent an RGB color, and each of r, g, and b
            are in the range 0..colormode

        If turtleshape is a polygon, the interior of that polygon is drawn
        with the newly set fillcolor.

        Example (for a Turtle instance named turtle):
        >>> turtle.fillcolor('violet')
        >>> col = turtle.pencolor()
        >>> turtle.fillcolor(col)
        >>> turtle.fillcolor(0, .5, 0)
        """
        if args:
            color = self._colorstr(args)
            if color == self._fillcolor:
                return
            self.pen(fillcolor=color)
        else:
            return self._color(self._fillcolor)

    def showturtle(self):
        """Makes the turtle visible.

        Aliases: showturtle | st

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.hideturtle()
        >>> turtle.showturtle()
        """
        self.pen(shown=True)

    def hideturtle(self):
        """Makes the turtle invisible.

        Aliases: hideturtle | ht

        No argument.

        It's a good idea to do this while you're in the
        middle of a complicated drawing, because hiding
        the turtle speeds up the drawing observably.

        Example (for a Turtle instance named turtle):
        >>> turtle.hideturtle()
        """
        self.pen(shown=False)

    def isvisible(self):
        """Return True if the Turtle is shown, False if it's hidden.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.hideturtle()
        >>> print turtle.isvisible():
        False
        """
        return self._shown

    def pen(self, pen=None, **pendict):
        """Return or set the pen's attributes.

        Arguments:
            pen -- a dictionary with some or all of the below listed keys.
            **pendict -- one or more keyword-arguments with the below
                         listed keys as keywords.

        Return or set the pen's attributes in a 'pen-dictionary'
        with the following key/value pairs:
           "shown"      :   True/False
           "pendown"    :   True/False
           "pencolor"   :   color-string or color-tuple
           "fillcolor"  :   color-string or color-tuple
           "pensize"    :   positive number
           "speed"      :   number in range 0..10
           "resizemode" :   "auto" or "user" or "noresize"
           "stretchfactor": (positive number, positive number)
           "shearfactor":   number
           "outline"    :   positive number
           "tilt"       :   number

        This dictionary can be used as argument for a subsequent
        pen()-call to restore the former pen-state. Moreover one
        or more of these attributes can be provided as keyword-arguments.
        This can be used to set several pen attributes in one statement.


        Examples (for a Turtle instance named turtle):
        >>> turtle.pen(fillcolor="black", pencolor="red", pensize=10)
        >>> turtle.pen()
        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',
        'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}
        >>> penstate=turtle.pen()
        >>> turtle.color("yellow","")
        >>> turtle.penup()
        >>> turtle.pen()
        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',
        'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}
        >>> p.pen(penstate, fillcolor="green")
        >>> p.pen()
        {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',
        'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}
        """
        _pd =  {"shown"         : self._shown,
                "pendown"       : self._drawing,
                "pencolor"      : self._pencolor,
                "fillcolor"     : self._fillcolor,
                "pensize"       : self._pensize,
                "speed"         : self._speed,
                "resizemode"    : self._resizemode,
                "stretchfactor" : self._stretchfactor,
                "shearfactor"   : self._shearfactor,
                "outline"       : self._outlinewidth,
                "tilt"          : self._tilt
               }

        if not (pen or pendict):
            return _pd

        if isinstance(pen, dict):
            p = pen
        else:
            p = {}
        p.update(pendict)

        _p_buf = {}
        for key in p:
            _p_buf[key] = _pd[key]

        if self.undobuffer:
            self.undobuffer.push(("pen", _p_buf))

        newLine = False
        if "pendown" in p:
            if self._drawing != p["pendown"]:
                newLine = True
        if "pencolor" in p:
            if isinstance(p["pencolor"], tuple):
                p["pencolor"] = self._colorstr((p["pencolor"],))
            if self._pencolor != p["pencolor"]:
                newLine = True
        if "pensize" in p:
            if self._pensize != p["pensize"]:
                newLine = True
        if newLine:
            self._newLine()
        if "pendown" in p:
            self._drawing = p["pendown"]
        if "pencolor" in p:
            self._pencolor = p["pencolor"]
        if "pensize" in p:
            self._pensize = p["pensize"]
        if "fillcolor" in p:
            if isinstance(p["fillcolor"], tuple):
                p["fillcolor"] = self._colorstr((p["fillcolor"],))
            self._fillcolor = p["fillcolor"]
        if "speed" in p:
            self._speed = p["speed"]
        if "resizemode" in p:
            self._resizemode = p["resizemode"]
        if "stretchfactor" in p:
            sf = p["stretchfactor"]
            if isinstance(sf, (int, float)):
                sf = (sf, sf)
            self._stretchfactor = sf
        if "shearfactor" in p:
            self._shearfactor = p["shearfactor"]
        if "outline" in p:
            self._outlinewidth = p["outline"]
        if "shown" in p:
            self._shown = p["shown"]
        if "tilt" in p:
            self._tilt = p["tilt"]
        if "stretchfactor" in p or "tilt" in p or "shearfactor" in p:
            scx, scy = self._stretchfactor
            shf = self._shearfactor
            sa, ca = math.sin(self._tilt), math.cos(self._tilt)
            self._shapetrafo = ( scx*ca, scy*(shf*ca + sa),
                                -scx*sa, scy*(ca - shf*sa))
        self._update()

## three dummy methods to be implemented by child class:

    def _newLine(self, usePos = True):
        """dummy method - to be overwritten by child class"""
    def _update(self, count=True, forced=False):
        """dummy method - to be overwritten by child class"""
    def _color(self, args):
        """dummy method - to be overwritten by child class"""
    def _colorstr(self, args):
        """dummy method - to be overwritten by child class"""

    width = pensize
    up = penup
    pu = penup
    pd = pendown
    down = pendown
    st = showturtle
    ht = hideturtle


class _TurtleImage(object):
    """Helper class: Datatype to store Turtle attributes
    """

    def __init__(self, screen, shapeIndex):
        self.screen = screen
        self._type = None
        self._setshape(shapeIndex)

    def _setshape(self, shapeIndex):
        screen = self.screen
        self.shapeIndex = shapeIndex
        if self._type == "polygon" == screen._shapes[shapeIndex]._type:
            return
        if self._type == "image" == screen._shapes[shapeIndex]._type:
            return
        if self._type in ["image", "polygon"]:
            screen._delete(self._item)
        elif self._type == "compound":
            for item in self._item:
                screen._delete(item)
        self._type = screen._shapes[shapeIndex]._type
        if self._type == "polygon":
            self._item = screen._createpoly()
        elif self._type == "image":
            self._item = screen._createimage(screen._shapes["blank"]._data)
        elif self._type == "compound":
            self._item = [screen._createpoly() for item in
                                          screen._shapes[shapeIndex]._data]


class RawTurtle(TPen, TNavigator):
    """Animation part of the RawTurtle.
    Puts RawTurtle upon a TurtleScreen and provides tools for
    its animation.
    """
    screens = []

    def __init__(self, canvas=None,
                 shape=_CFG["shape"],
                 undobuffersize=_CFG["undobuffersize"],
                 visible=_CFG["visible"]):
        if isinstance(canvas, _Screen):
            self.screen = canvas
        elif isinstance(canvas, TurtleScreen):
            if canvas not in RawTurtle.screens:
                RawTurtle.screens.append(canvas)
            self.screen = canvas
        elif isinstance(canvas, (ScrolledCanvas, Canvas)):
            for screen in RawTurtle.screens:
                if screen.cv == canvas:
                    self.screen = screen
                    break
            else:
                self.screen = TurtleScreen(canvas)
                RawTurtle.screens.append(self.screen)
        else:
            raise TurtleGraphicsError("bad canvas argument %s" % canvas)

        screen = self.screen
        TNavigator.__init__(self, screen.mode())
        TPen.__init__(self)
        screen._turtles.append(self)
        self.drawingLineItem = screen._createline()
        self.turtle = _TurtleImage(screen, shape)
        self._poly = None
        self._creatingPoly = False
        self._fillitem = self._fillpath = None
        self._shown = visible
        self._hidden_from_screen = False
        self.currentLineItem = screen._createline()
        self.currentLine = [self._position]
        self.items = [self.currentLineItem]
        self.stampItems = []
        self._undobuffersize = undobuffersize
        self.undobuffer = Tbuffer(undobuffersize)
        self._update()

    def reset(self):
        """Delete the turtle's drawings and restore its default values.

        No argument.

        Delete the turtle's drawings from the screen, re-center the turtle
        and set variables to the default values.

        Example (for a Turtle instance named turtle):
        >>> turtle.position()
        (0.00,-22.00)
        >>> turtle.heading()
        100.0
        >>> turtle.reset()
        >>> turtle.position()
        (0.00,0.00)
        >>> turtle.heading()
        0.0
        """
        TNavigator.reset(self)
        TPen._reset(self)
        self._clear()
        self._drawturtle()
        self._update()

    def setundobuffer(self, size):
        """Set or disable undobuffer.

        Argument:
        size -- an integer or None

        If size is an integer an empty undobuffer of given size is installed.
        Size gives the maximum number of turtle-actions that can be undone
        by the undo() function.
        If size is None, no undobuffer is present.

        Example (for a Turtle instance named turtle):
        >>> turtle.setundobuffer(42)
        """
        if size is None or size <= 0:
            self.undobuffer = None
        else:
            self.undobuffer = Tbuffer(size)

    def undobufferentries(self):
        """Return count of entries in the undobuffer.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> while undobufferentries():
        ...     undo()
        """
        if self.undobuffer is None:
            return 0
        return self.undobuffer.nr_of_items()

    def _clear(self):
        """Delete all of pen's drawings"""
        self._fillitem = self._fillpath = None
        for item in self.items:
            self.screen._delete(item)
        self.currentLineItem = self.screen._createline()
        self.currentLine = []
        if self._drawing:
            self.currentLine.append(self._position)
        self.items = [self.currentLineItem]
        self.clearstamps()
        self.setundobuffer(self._undobuffersize)


    def clear(self):
        """Delete the turtle's drawings from the screen. Do not move turtle.

        No arguments.

        Delete the turtle's drawings from the screen. Do not move turtle.
        State and position of the turtle as well as drawings of other
        turtles are not affected.

        Examples (for a Turtle instance named turtle):
        >>> turtle.clear()
        """
        self._clear()
        self._update()

    def _update_data(self):
        self.screen._incrementudc()
        if self.screen._updatecounter != 0:
            return
        if len(self.currentLine)>1:
            self.screen._drawline(self.currentLineItem, self.currentLine,
                                  self._pencolor, self._pensize)

    def _update(self):
        """Perform a Turtle-data update.
        """
        screen = self.screen
        if screen._tracing == 0:
            return
        elif screen._tracing == 1:
            self._update_data()
            self._drawturtle()
            screen._update()                  # TurtleScreenBase
            screen._delay(screen._delayvalue) # TurtleScreenBase
        else:
            self._update_data()
            if screen._updatecounter == 0:
                for t in screen.turtles():
                    t._drawturtle()
                screen._update()

    def _tracer(self, flag=None, delay=None):
        """Turns turtle animation on/off and set delay for update drawings.

        Optional arguments:
        n -- nonnegative  integer
        delay -- nonnegative  integer

        If n is given, only each n-th regular screen update is really performed.
        (Can be used to accelerate the drawing of complex graphics.)
        Second arguments sets delay value (see RawTurtle.delay())

        Example (for a Turtle instance named turtle):
        >>> turtle.tracer(8, 25)
        >>> dist = 2
        >>> for i in range(200):
        ...     turtle.fd(dist)
        ...     turtle.rt(90)
        ...     dist += 2
        """
        return self.screen.tracer(flag, delay)

    def _color(self, args):
        return self.screen._color(args)

    def _colorstr(self, args):
        return self.screen._colorstr(args)

    def _cc(self, args):
        """Convert colortriples to hexstrings.
        """
        if isinstance(args, str):
            return args
        try:
            r, g, b = args
        except:
            raise TurtleGraphicsError("bad color arguments: %s" % str(args))
        if self.screen._colormode == 1.0:
            r, g, b = [round(255.0*x) for x in (r, g, b)]
        if not ((0 <= r <= 255) and (0 <= g <= 255) and (0 <= b <= 255)):
            raise TurtleGraphicsError("bad color sequence: %s" % str(args))
        return "#%02x%02x%02x" % (r, g, b)

    def clone(self):
        """Create and return a clone of the turtle.

        No argument.

        Create and return a clone of the turtle with same position, heading
        and turtle properties.

        Example (for a Turtle instance named mick):
        mick = Turtle()
        joe = mick.clone()
        """
        screen = self.screen
        self._newLine(self._drawing)

        turtle = self.turtle
        self.screen = None
        self.turtle = None  # too make self deepcopy-able

        q = deepcopy(self)

        self.screen = screen
        self.turtle = turtle

        q.screen = screen
        q.turtle = _TurtleImage(screen, self.turtle.shapeIndex)

        screen._turtles.append(q)
        ttype = screen._shapes[self.turtle.shapeIndex]._type
        if ttype == "polygon":
            q.turtle._item = screen._createpoly()
        elif ttype == "image":
            q.turtle._item = screen._createimage(screen._shapes["blank"]._data)
        elif ttype == "compound":
            q.turtle._item = [screen._createpoly() for item in
                              screen._shapes[self.turtle.shapeIndex]._data]
        q.currentLineItem = screen._createline()
        q._update()
        return q

    def shape(self, name=None):
        """Set turtle shape to shape with given name / return current shapename.

        Optional argument:
        name -- a string, which is a valid shapename

        Set turtle shape to shape with given name or, if name is not given,
        return name of current shape.
        Shape with name must exist in the TurtleScreen's shape dictionary.
        Initially there are the following polygon shapes:
        'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.
        To learn about how to deal with shapes see Screen-method register_shape.

        Example (for a Turtle instance named turtle):
        >>> turtle.shape()
        'arrow'
        >>> turtle.shape("turtle")
        >>> turtle.shape()
        'turtle'
        """
        if name is None:
            return self.turtle.shapeIndex
        if not name in self.screen.getshapes():
            raise TurtleGraphicsError("There is no shape named %s" % name)
        self.turtle._setshape(name)
        self._update()

    def shapesize(self, stretch_wid=None, stretch_len=None, outline=None):
        """Set/return turtle's stretchfactors/outline. Set resizemode to "user".

        Optional arguments:
           stretch_wid : positive number
           stretch_len : positive number
           outline  : positive number

        Return or set the pen's attributes x/y-stretchfactors and/or outline.
        Set resizemode to "user".
        If and only if resizemode is set to "user", the turtle will be displayed
        stretched according to its stretchfactors:
        stretch_wid is stretchfactor perpendicular to orientation
        stretch_len is stretchfactor in direction of turtles orientation.
        outline determines the width of the shapes's outline.

        Examples (for a Turtle instance named turtle):
        >>> turtle.resizemode("user")
        >>> turtle.shapesize(5, 5, 12)
        >>> turtle.shapesize(outline=8)
        """
        if stretch_wid is stretch_len is outline is None:
            stretch_wid, stretch_len = self._stretchfactor
            return stretch_wid, stretch_len, self._outlinewidth
        if stretch_wid == 0 or stretch_len == 0:
            raise TurtleGraphicsError("stretch_wid/stretch_len must not be zero")
        if stretch_wid is not None:
            if stretch_len is None:
                stretchfactor = stretch_wid, stretch_wid
            else:
                stretchfactor = stretch_wid, stretch_len
        elif stretch_len is not None:
            stretchfactor = self._stretchfactor[0], stretch_len
        else:
            stretchfactor = self._stretchfactor
        if outline is None:
            outline = self._outlinewidth
        self.pen(resizemode="user",
                 stretchfactor=stretchfactor, outline=outline)

    def shearfactor(self, shear=None):
        """Set or return the current shearfactor.

        Optional argument: shear -- number, tangent of the shear angle

        Shear the turtleshape according to the given shearfactor shear,
        which is the tangent of the shear angle. DO NOT change the
        turtle's heading (direction of movement).
        If shear is not given: return the current shearfactor, i. e. the
        tangent of the shear angle, by which lines parallel to the
        heading of the turtle are sheared.

        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("circle")
        >>> turtle.shapesize(5,2)
        >>> turtle.shearfactor(0.5)
        >>> turtle.shearfactor()
        >>> 0.5
        """
        if shear is None:
            return self._shearfactor
        self.pen(resizemode="user", shearfactor=shear)

    def settiltangle(self, angle):
        """Rotate the turtleshape to point in the specified direction

        Argument: angle -- number

        Rotate the turtleshape to point in the direction specified by angle,
        regardless of its current tilt-angle. DO NOT change the turtle's
        heading (direction of movement).


        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("circle")
        >>> turtle.shapesize(5,2)
        >>> turtle.settiltangle(45)
        >>> stamp()
        >>> turtle.fd(50)
        >>> turtle.settiltangle(-45)
        >>> stamp()
        >>> turtle.fd(50)
        """
        tilt = -angle * self._degreesPerAU * self._angleOrient
        tilt = (tilt * math.pi / 180.0) % (2*math.pi)
        self.pen(resizemode="user", tilt=tilt)

    def tiltangle(self, angle=None):
        """Set or return the current tilt-angle.

        Optional argument: angle -- number

        Rotate the turtleshape to point in the direction specified by angle,
        regardless of its current tilt-angle. DO NOT change the turtle's
        heading (direction of movement).
        If angle is not given: return the current tilt-angle, i. e. the angle
        between the orientation of the turtleshape and the heading of the
        turtle (its direction of movement).

        Deprecated since Python 3.1

        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("circle")
        >>> turtle.shapesize(5,2)
        >>> turtle.tilt(45)
        >>> turtle.tiltangle()
        """
        if angle is None:
            tilt = -self._tilt * (180.0/math.pi) * self._angleOrient
            return (tilt / self._degreesPerAU) % self._fullcircle
        else:
            self.settiltangle(angle)

    def tilt(self, angle):
        """Rotate the turtleshape by angle.

        Argument:
        angle - a number

        Rotate the turtleshape by angle from its current tilt-angle,
        but do NOT change the turtle's heading (direction of movement).

        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("circle")
        >>> turtle.shapesize(5,2)
        >>> turtle.tilt(30)
        >>> turtle.fd(50)
        >>> turtle.tilt(30)
        >>> turtle.fd(50)
        """
        self.settiltangle(angle + self.tiltangle())

    def shapetransform(self, t11=None, t12=None, t21=None, t22=None):
        """Set or return the current transformation matrix of the turtle shape.

        Optional arguments: t11, t12, t21, t22 -- numbers.

        If none of the matrix elements are given, return the transformation
        matrix.
        Otherwise set the given elements and transform the turtleshape
        according to the matrix consisting of first row t11, t12 and
        second row t21, 22.
        Modify stretchfactor, shearfactor and tiltangle according to the
        given matrix.

        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("square")
        >>> turtle.shapesize(4,2)
        >>> turtle.shearfactor(-0.5)
        >>> turtle.shapetransform()
        (4.0, -1.0, -0.0, 2.0)
        """
        if t11 is t12 is t21 is t22 is None:
            return self._shapetrafo
        m11, m12, m21, m22 = self._shapetrafo
        if t11 is not None: m11 = t11
        if t12 is not None: m12 = t12
        if t21 is not None: m21 = t21
        if t22 is not None: m22 = t22
        if t11 * t22 - t12 * t21 == 0:
            raise TurtleGraphicsError("Bad shape transform matrix: must not be singular")
        self._shapetrafo = (m11, m12, m21, m22)
        alfa = math.atan2(-m21, m11) % (2 * math.pi)
        sa, ca = math.sin(alfa), math.cos(alfa)
        a11, a12, a21, a22 = (ca*m11 - sa*m21, ca*m12 - sa*m22,
                              sa*m11 + ca*m21, sa*m12 + ca*m22)
        self._stretchfactor = a11, a22
        self._shearfactor = a12/a22
        self._tilt = alfa
        self.pen(resizemode="user")


    def _polytrafo(self, poly):
        """Computes transformed polygon shapes from a shape
        according to current position and heading.
        """
        screen = self.screen
        p0, p1 = self._position
        e0, e1 = self._orient
        e = Vec2D(e0, e1 * screen.yscale / screen.xscale)
        e0, e1 = (1.0 / abs(e)) * e
        return [(p0+(e1*x+e0*y)/screen.xscale, p1+(-e0*x+e1*y)/screen.yscale)
                                                           for (x, y) in poly]

    def get_shapepoly(self):
        """Return the current shape polygon as tuple of coordinate pairs.

        No argument.

        Examples (for a Turtle instance named turtle):
        >>> turtle.shape("square")
        >>> turtle.shapetransform(4, -1, 0, 2)
        >>> turtle.get_shapepoly()
        ((50, -20), (30, 20), (-50, 20), (-30, -20))

        """
        shape = self.screen._shapes[self.turtle.shapeIndex]
        if shape._type == "polygon":
            return self._getshapepoly(shape._data, shape._type == "compound")
        # else return None

    def _getshapepoly(self, polygon, compound=False):
        """Calculate transformed shape polygon according to resizemode
        and shapetransform.
        """
        if self._resizemode == "user" or compound:
            t11, t12, t21, t22 = self._shapetrafo
        elif self._resizemode == "auto":
            l = max(1, self._pensize/5.0)
            t11, t12, t21, t22 = l, 0, 0, l
        elif self._resizemode == "noresize":
            return polygon
        return tuple([(t11*x + t12*y, t21*x + t22*y) for (x, y) in polygon])

    def _drawturtle(self):
        """Manages the correct rendering of the turtle with respect to
        its shape, resizemode, stretch and tilt etc."""
        screen = self.screen
        shape = screen._shapes[self.turtle.shapeIndex]
        ttype = shape._type
        titem = self.turtle._item
        if self._shown and screen._updatecounter == 0 and screen._tracing > 0:
            self._hidden_from_screen = False
            tshape = shape._data
            if ttype == "polygon":
                if self._resizemode == "noresize": w = 1
                elif self._resizemode == "auto": w = self._pensize
                else: w =self._outlinewidth
                shape = self._polytrafo(self._getshapepoly(tshape))
                fc, oc = self._fillcolor, self._pencolor
                screen._drawpoly(titem, shape, fill=fc, outline=oc,
                                                      width=w, top=True)
            elif ttype == "image":
                screen._drawimage(titem, self._position, tshape)
            elif ttype == "compound":
                for item, (poly, fc, oc) in zip(titem, tshape):
                    poly = self._polytrafo(self._getshapepoly(poly, True))
                    screen._drawpoly(item, poly, fill=self._cc(fc),
                                     outline=self._cc(oc), width=self._outlinewidth, top=True)
        else:
            if self._hidden_from_screen:
                return
            if ttype == "polygon":
                screen._drawpoly(titem, ((0, 0), (0, 0), (0, 0)), "", "")
            elif ttype == "image":
                screen._drawimage(titem, self._position,
                                          screen._shapes["blank"]._data)
            elif ttype == "compound":
                for item in titem:
                    screen._drawpoly(item, ((0, 0), (0, 0), (0, 0)), "", "")
            self._hidden_from_screen = True

##############################  stamp stuff  ###############################

    def stamp(self):
        """Stamp a copy of the turtleshape onto the canvas and return its id.

        No argument.

        Stamp a copy of the turtle shape onto the canvas at the current
        turtle position. Return a stamp_id for that stamp, which can be
        used to delete it by calling clearstamp(stamp_id).

        Example (for a Turtle instance named turtle):
        >>> turtle.color("blue")
        >>> turtle.stamp()
        13
        >>> turtle.fd(50)
        """
        screen = self.screen
        shape = screen._shapes[self.turtle.shapeIndex]
        ttype = shape._type
        tshape = shape._data
        if ttype == "polygon":
            stitem = screen._createpoly()
            if self._resizemode == "noresize": w = 1
            elif self._resizemode == "auto": w = self._pensize
            else: w =self._outlinewidth
            shape = self._polytrafo(self._getshapepoly(tshape))
            fc, oc = self._fillcolor, self._pencolor
            screen._drawpoly(stitem, shape, fill=fc, outline=oc,
                                                  width=w, top=True)
        elif ttype == "image":
            stitem = screen._createimage("")
            screen._drawimage(stitem, self._position, tshape)
        elif ttype == "compound":
            stitem = []
            for element in tshape:
                item = screen._createpoly()
                stitem.append(item)
            stitem = tuple(stitem)
            for item, (poly, fc, oc) in zip(stitem, tshape):
                poly = self._polytrafo(self._getshapepoly(poly, True))
                screen._drawpoly(item, poly, fill=self._cc(fc),
                                 outline=self._cc(oc), width=self._outlinewidth, top=True)
        self.stampItems.append(stitem)
        self.undobuffer.push(("stamp", stitem))
        return stitem

    def _clearstamp(self, stampid):
        """does the work for clearstamp() and clearstamps()
        """
        if stampid in self.stampItems:
            if isinstance(stampid, tuple):
                for subitem in stampid:
                    self.screen._delete(subitem)
            else:
                self.screen._delete(stampid)
            self.stampItems.remove(stampid)
        # Delete stampitem from undobuffer if necessary
        # if clearstamp is called directly.
        item = ("stamp", stampid)
        buf = self.undobuffer
        if item not in buf.buffer:
            return
        index = buf.buffer.index(item)
        buf.buffer.remove(item)
        if index <= buf.ptr:
            buf.ptr = (buf.ptr - 1) % buf.bufsize
        buf.buffer.insert((buf.ptr+1)%buf.bufsize, [None])

    def clearstamp(self, stampid):
        """Delete stamp with given stampid

        Argument:
        stampid - an integer, must be return value of previous stamp() call.

        Example (for a Turtle instance named turtle):
        >>> turtle.color("blue")
        >>> astamp = turtle.stamp()
        >>> turtle.fd(50)
        >>> turtle.clearstamp(astamp)
        """
        self._clearstamp(stampid)
        self._update()

    def clearstamps(self, n=None):
        """Delete all or first/last n of turtle's stamps.

        Optional argument:
        n -- an integer

        If n is None, delete all of pen's stamps,
        else if n > 0 delete first n stamps
        else if n < 0 delete last n stamps.

        Example (for a Turtle instance named turtle):
        >>> for i in range(8):
        ...     turtle.stamp(); turtle.fd(30)
        ...
        >>> turtle.clearstamps(2)
        >>> turtle.clearstamps(-2)
        >>> turtle.clearstamps()
        """
        if n is None:
            toDelete = self.stampItems[:]
        elif n >= 0:
            toDelete = self.stampItems[:n]
        else:
            toDelete = self.stampItems[n:]
        for item in toDelete:
            self._clearstamp(item)
        self._update()

    def _goto(self, end):
        """Move the pen to the point end, thereby drawing a line
        if pen is down. All other methods for turtle movement depend
        on this one.
        """
        ## Version with undo-stuff
        go_modes = ( self._drawing,
                     self._pencolor,
                     self._pensize,
                     isinstance(self._fillpath, list))
        screen = self.screen
        undo_entry = ("go", self._position, end, go_modes,
                      (self.currentLineItem,
                      self.currentLine[:],
                      screen._pointlist(self.currentLineItem),
                      self.items[:])
                      )
        if self.undobuffer:
            self.undobuffer.push(undo_entry)
        start = self._position
        if self._speed and screen._tracing == 1:
            diff = (end-start)
            diffsq = (diff[0]*screen.xscale)**2 + (diff[1]*screen.yscale)**2
            nhops = 1+int((diffsq**0.5)/(3*(1.1**self._speed)*self._speed))
            delta = diff * (1.0/nhops)
            for n in range(1, nhops):
                if n == 1:
                    top = True
                else:
                    top = False
                self._position = start + delta * n
                if self._drawing:
                    screen._drawline(self.drawingLineItem,
                                     (start, self._position),
                                     self._pencolor, self._pensize, top)
                self._update()
            if self._drawing:
                screen._drawline(self.drawingLineItem, ((0, 0), (0, 0)),
                                               fill="", width=self._pensize)
        # Turtle now at end,
        if self._drawing: # now update currentLine
            self.currentLine.append(end)
        if isinstance(self._fillpath, list):
            self._fillpath.append(end)
        ######    vererbung!!!!!!!!!!!!!!!!!!!!!!
        self._position = end
        if self._creatingPoly:
            self._poly.append(end)
        if len(self.currentLine) > 42: # 42! answer to the ultimate question
                                       # of life, the universe and everything
            self._newLine()
        self._update() #count=True)

    def _undogoto(self, entry):
        """Reverse a _goto. Used for undo()
        """
        old, new, go_modes, coodata = entry
        drawing, pc, ps, filling = go_modes
        cLI, cL, pl, items = coodata
        screen = self.screen
        if abs(self._position - new) > 0.5:
            print ("undogoto: HALLO-DA-STIMMT-WAS-NICHT!")
        # restore former situation
        self.currentLineItem = cLI
        self.currentLine = cL

        if pl == [(0, 0), (0, 0)]:
            usepc = ""
        else:
            usepc = pc
        screen._drawline(cLI, pl, fill=usepc, width=ps)

        todelete = [i for i in self.items if (i not in items) and
                                       (screen._type(i) == "line")]
        for i in todelete:
            screen._delete(i)
            self.items.remove(i)

        start = old
        if self._speed and screen._tracing == 1:
            diff = old - new
            diffsq = (diff[0]*screen.xscale)**2 + (diff[1]*screen.yscale)**2
            nhops = 1+int((diffsq**0.5)/(3*(1.1**self._speed)*self._speed))
            delta = diff * (1.0/nhops)
            for n in range(1, nhops):
                if n == 1:
                    top = True
                else:
                    top = False
                self._position = new + delta * n
                if drawing:
                    screen._drawline(self.drawingLineItem,
                                     (start, self._position),
                                     pc, ps, top)
                self._update()
            if drawing:
                screen._drawline(self.drawingLineItem, ((0, 0), (0, 0)),
                                               fill="", width=ps)
        # Turtle now at position old,
        self._position = old
        ##  if undo is done during creating a polygon, the last vertex
        ##  will be deleted. if the polygon is entirely deleted,
        ##  creatingPoly will be set to False.
        ##  Polygons created before the last one will not be affected by undo()
        if self._creatingPoly:
            if len(self._poly) > 0:
                self._poly.pop()
            if self._poly == []:
                self._creatingPoly = False
                self._poly = None
        if filling:
            if self._fillpath == []:
                self._fillpath = None
                print("Unwahrscheinlich in _undogoto!")
            elif self._fillpath is not None:
                self._fillpath.pop()
        self._update() #count=True)

    def _rotate(self, angle):
        """Turns pen clockwise by angle.
        """
        if self.undobuffer:
            self.undobuffer.push(("rot", angle, self._degreesPerAU))
        angle *= self._degreesPerAU
        neworient = self._orient.rotate(angle)
        tracing = self.screen._tracing
        if tracing == 1 and self._speed > 0:
            anglevel = 3.0 * self._speed
            steps = 1 + int(abs(angle)/anglevel)
            delta = 1.0*angle/steps
            for _ in range(steps):
                self._orient = self._orient.rotate(delta)
                self._update()
        self._orient = neworient
        self._update()

    def _newLine(self, usePos=True):
        """Closes current line item and starts a new one.
           Remark: if current line became too long, animation
           performance (via _drawline) slowed down considerably.
        """
        if len(self.currentLine) > 1:
            self.screen._drawline(self.currentLineItem, self.currentLine,
                                      self._pencolor, self._pensize)
            self.currentLineItem = self.screen._createline()
            self.items.append(self.currentLineItem)
        else:
            self.screen._drawline(self.currentLineItem, top=True)
        self.currentLine = []
        if usePos:
            self.currentLine = [self._position]

    def filling(self):
        """Return fillstate (True if filling, False else).

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.begin_fill()
        >>> if turtle.filling():
        ...     turtle.pensize(5)
        ... else:
        ...     turtle.pensize(3)
        """
        return isinstance(self._fillpath, list)

    def begin_fill(self):
        """Called just before drawing a shape to be filled.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.color("black", "red")
        >>> turtle.begin_fill()
        >>> turtle.circle(60)
        >>> turtle.end_fill()
        """
        if not self.filling():
            self._fillitem = self.screen._createpoly()
            self.items.append(self._fillitem)
        self._fillpath = [self._position]
        self._newLine()
        if self.undobuffer:
            self.undobuffer.push(("beginfill", self._fillitem))
        self._update()


    def end_fill(self):
        """Fill the shape drawn after the call begin_fill().

        No argument.

        Example (for a Turtle instance named turtle):
        >>> turtle.color("black", "red")
        >>> turtle.begin_fill()
        >>> turtle.circle(60)
        >>> turtle.end_fill()
        """
        if self.filling():
            if len(self._fillpath) > 2:
                self.screen._drawpoly(self._fillitem, self._fillpath,
                                      fill=self._fillcolor)
                if self.undobuffer:
                    self.undobuffer.push(("dofill", self._fillitem))
            self._fillitem = self._fillpath = None
            self._update()

    def dot(self, size=None, *color):
        """Draw a dot with diameter size, using color.

        Optional arguments:
        size -- an integer >= 1 (if given)
        color -- a colorstring or a numeric color tuple

        Draw a circular dot with diameter size, using color.
        If size is not given, the maximum of pensize+4 and 2*pensize is used.

        Example (for a Turtle instance named turtle):
        >>> turtle.dot()
        >>> turtle.fd(50); turtle.dot(20, "blue"); turtle.fd(50)
        """
        if not color:
            if isinstance(size, (str, tuple)):
                color = self._colorstr(size)
                size = self._pensize + max(self._pensize, 4)
            else:
                color = self._pencolor
                if not size:
                    size = self._pensize + max(self._pensize, 4)
        else:
            if size is None:
                size = self._pensize + max(self._pensize, 4)
            color = self._colorstr(color)
        if hasattr(self.screen, "_dot"):
            item = self.screen._dot(self._position, size, color)
            self.items.append(item)
            if self.undobuffer:
                self.undobuffer.push(("dot", item))
        else:
            pen = self.pen()
            if self.undobuffer:
                self.undobuffer.push(["seq"])
                self.undobuffer.cumulate = True
            try:
                if self.resizemode() == 'auto':
                    self.ht()
                self.pendown()
                self.pensize(size)
                self.pencolor(color)
                self.forward(0)
            finally:
                self.pen(pen)
            if self.undobuffer:
                self.undobuffer.cumulate = False

    def _write(self, txt, align, font):
        """Performs the writing for write()
        """
        item, end = self.screen._write(self._position, txt, align, font,
                                                          self._pencolor)
        self.items.append(item)
        if self.undobuffer:
            self.undobuffer.push(("wri", item))
        return end

    def write(self, arg, move=False, align="left", font=("Arial", 8, "normal")):
        """Write text at the current turtle position.

        Arguments:
        arg -- info, which is to be written to the TurtleScreen
        move (optional) -- True/False
        align (optional) -- one of the strings "left", "center" or right"
        font (optional) -- a triple (fontname, fontsize, fonttype)

        Write text - the string representation of arg - at the current
        turtle position according to align ("left", "center" or right")
        and with the given font.
        If move is True, the pen is moved to the bottom-right corner
        of the text. By default, move is False.

        Example (for a Turtle instance named turtle):
        >>> turtle.write('Home = ', True, align="center")
        >>> turtle.write((0,0), True)
        """
        if self.undobuffer:
            self.undobuffer.push(["seq"])
            self.undobuffer.cumulate = True
        end = self._write(str(arg), align.lower(), font)
        if move:
            x, y = self.pos()
            self.setpos(end, y)
        if self.undobuffer:
            self.undobuffer.cumulate = False

    def begin_poly(self):
        """Start recording the vertices of a polygon.

        No argument.

        Start recording the vertices of a polygon. Current turtle position
        is first point of polygon.

        Example (for a Turtle instance named turtle):
        >>> turtle.begin_poly()
        """
        self._poly = [self._position]
        self._creatingPoly = True

    def end_poly(self):
        """Stop recording the vertices of a polygon.

        No argument.

        Stop recording the vertices of a polygon. Current turtle position is
        last point of polygon. This will be connected with the first point.

        Example (for a Turtle instance named turtle):
        >>> turtle.end_poly()
        """
        self._creatingPoly = False

    def get_poly(self):
        """Return the lastly recorded polygon.

        No argument.

        Example (for a Turtle instance named turtle):
        >>> p = turtle.get_poly()
        >>> turtle.register_shape("myFavouriteShape", p)
        """
        ## check if there is any poly?
        if self._poly is not None:
            return tuple(self._poly)

    def getscreen(self):
        """Return the TurtleScreen object, the turtle is drawing  on.

        No argument.

        Return the TurtleScreen object, the turtle is drawing  on.
        So TurtleScreen-methods can be called for that object.

        Example (for a Turtle instance named turtle):
        >>> ts = turtle.getscreen()
        >>> ts
        <turtle.TurtleScreen object at 0x0106B770>
        >>> ts.bgcolor("pink")
        """
        return self.screen

    def getturtle(self):
        """Return the Turtleobject itself.

        No argument.

        Only reasonable use: as a function to return the 'anonymous turtle':

        Example:
        >>> pet = getturtle()
        >>> pet.fd(50)
        >>> pet
        <turtle.Turtle object at 0x0187D810>
        >>> turtles()
        [<turtle.Turtle object at 0x0187D810>]
        """
        return self

    getpen = getturtle


    ################################################################
    ### screen oriented methods recurring to methods of TurtleScreen
    ################################################################

    def _delay(self, delay=None):
        """Set delay value which determines speed of turtle animation.
        """
        return self.screen.delay(delay)

    def onclick(self, fun, btn=1, add=None):
        """Bind fun to mouse-click event on this turtle on canvas.

        Arguments:
        fun --  a function with two arguments, to which will be assigned
                the coordinates of the clicked point on the canvas.
        num --  number of the mouse-button defaults to 1 (left mouse button).
        add --  True or False. If True, new binding will be added, otherwise
                it will replace a former binding.

        Example for the anonymous turtle, i. e. the procedural way:

        >>> def turn(x, y):
        ...     left(360)
        ...
        >>> onclick(turn)  # Now clicking into the turtle will turn it.
        >>> onclick(None)  # event-binding will be removed
        """
        self.screen._onclick(self.turtle._item, fun, btn, add)
        self._update()

    def onrelease(self, fun, btn=1, add=None):
        """Bind fun to mouse-button-release event on this turtle on canvas.

        Arguments:
        fun -- a function with two arguments, to which will be assigned
                the coordinates of the clicked point on the canvas.
        num --  number of the mouse-button defaults to 1 (left mouse button).

        Example (for a MyTurtle instance named joe):
        >>> class MyTurtle(Turtle):
        ...     def glow(self,x,y):
        ...             self.fillcolor("red")
        ...     def unglow(self,x,y):
        ...             self.fillcolor("")
        ...
        >>> joe = MyTurtle()
        >>> joe.onclick(joe.glow)
        >>> joe.onrelease(joe.unglow)

        Clicking on joe turns fillcolor red, unclicking turns it to
        transparent.
        """
        self.screen._onrelease(self.turtle._item, fun, btn, add)
        self._update()

    def ondrag(self, fun, btn=1, add=None):
        """Bind fun to mouse-move event on this turtle on canvas.

        Arguments:
        fun -- a function with two arguments, to which will be assigned
               the coordinates of the clicked point on the canvas.
        num -- number of the mouse-button defaults to 1 (left mouse button).

        Every sequence of mouse-move-events on a turtle is preceded by a
        mouse-click event on that turtle.

        Example (for a Turtle instance named turtle):
        >>> turtle.ondrag(turtle.goto)

        Subsequently clicking and dragging a Turtle will move it
        across the screen thereby producing handdrawings (if pen is
        down).
        """
        self.screen._ondrag(self.turtle._item, fun, btn, add)


    def _undo(self, action, data):
        """Does the main part of the work for undo()
        """
        if self.undobuffer is None:
            return
        if action == "rot":
            angle, degPAU = data
            self._rotate(-angle*degPAU/self._degreesPerAU)
            dummy = self.undobuffer.pop()
        elif action == "stamp":
            stitem = data[0]
            self.clearstamp(stitem)
        elif action == "go":
            self._undogoto(data)
        elif action in ["wri", "dot"]:
            item = data[0]
            self.screen._delete(item)
            self.items.remove(item)
        elif action == "dofill":
            item = data[0]
            self.screen._drawpoly(item, ((0, 0),(0, 0),(0, 0)),
                                  fill="", outline="")
        elif action == "beginfill":
            item = data[0]
            self._fillitem = self._fillpath = None
            if item in self.items:
                self.screen._delete(item)
                self.items.remove(item)
        elif action == "pen":
            TPen.pen(self, data[0])
            self.undobuffer.pop()

    def undo(self):
        """undo (repeatedly) the last turtle action.

        No argument.

        undo (repeatedly) the last turtle action.
        Number of available undo actions is determined by the size of
        the undobuffer.

        Example (for a Turtle instance named turtle):
        >>> for i in range(4):
        ...     turtle.fd(50); turtle.lt(80)
        ...
        >>> for i in range(8):
        ...     turtle.undo()
        ...
        """
        if self.undobuffer is None:
            return
        item = self.undobuffer.pop()
        action = item[0]
        data = item[1:]
        if action == "seq":
            while data:
                item = data.pop()
                self._undo(item[0], item[1:])
        else:
            self._undo(action, data)

    turtlesize = shapesize

RawPen = RawTurtle

###  Screen - Singleton  ########################

def Screen():
    """Return the singleton screen object.
    If none exists at the moment, create a new one and return it,
    else return the existing one."""
    if Turtle._screen is None:
        Turtle._screen = _Screen()
    return Turtle._screen

class _Screen(TurtleScreen):

    _root = None
    _canvas = None
    _title = _CFG["title"]

    def __init__(self):
        # XXX there is no need for this code to be conditional,
        # as there will be only a single _Screen instance, anyway
        # XXX actually, the turtle demo is injecting root window,
        # so perhaps the conditional creation of a root should be
        # preserved (perhaps by passing it as an optional parameter)
        if _Screen._root is None:
            _Screen._root = self._root = _Root()
            self._root.title(_Screen._title)
            self._root.ondestroy(self._destroy)
        if _Screen._canvas is None:
            width = _CFG["width"]
            height = _CFG["height"]
            canvwidth = _CFG["canvwidth"]
            canvheight = _CFG["canvheight"]
            leftright = _CFG["leftright"]
            topbottom = _CFG["topbottom"]
            self._root.setupcanvas(width, height, canvwidth, canvheight)
            _Screen._canvas = self._root._getcanvas()
            TurtleScreen.__init__(self, _Screen._canvas)
            self.setup(width, height, leftright, topbottom)

    def setup(self, width=_CFG["width"], height=_CFG["height"],
              startx=_CFG["leftright"], starty=_CFG["topbottom"]):
        """ Set the size and position of the main window.

        Arguments:
        width: as integer a size in pixels, as float a fraction of the screen.
          Default is 50% of screen.
        height: as integer the height in pixels, as float a fraction of the
          screen. Default is 75% of screen.
        startx: if positive, starting position in pixels from the left
          edge of the screen, if negative from the right edge
          Default, startx=None is to center window horizontally.
        starty: if positive, starting position in pixels from the top
          edge of the screen, if negative from the bottom edge
          Default, starty=None is to center window vertically.

        Examples (for a Screen instance named screen):
        >>> screen.setup (width=200, height=200, startx=0, starty=0)

        sets window to 200x200 pixels, in upper left of screen

        >>> screen.setup(width=.75, height=0.5, startx=None, starty=None)

        sets window to 75% of screen by 50% of screen and centers
        """
        if not hasattr(self._root, "set_geometry"):
            return
        sw = self._root.win_width()
        sh = self._root.win_height()
        if isinstance(width, float) and 0 <= width <= 1:
            width = sw*width
        if startx is None:
            startx = (sw - width) / 2
        if isinstance(height, float) and 0 <= height <= 1:
            height = sh*height
        if starty is None:
            starty = (sh - height) / 2
        self._root.set_geometry(width, height, startx, starty)
        self.update()

    def title(self, titlestring):
        """Set title of turtle-window

        Argument:
        titlestring -- a string, to appear in the titlebar of the
                       turtle graphics window.

        This is a method of Screen-class. Not available for TurtleScreen-
        objects.

        Example (for a Screen instance named screen):
        >>> screen.title("Welcome to the turtle-zoo!")
        """
        if _Screen._root is not None:
            _Screen._root.title(titlestring)
        _Screen._title = titlestring

    def _destroy(self):
        root = self._root
        if root is _Screen._root:
            Turtle._pen = None
            Turtle._screen = None
            _Screen._root = None
            _Screen._canvas = None
        TurtleScreen._RUNNING = True
        root.destroy()

    def bye(self):
        """Shut the turtlegraphics window.

        Example (for a TurtleScreen instance named screen):
        >>> screen.bye()
        """
        self._destroy()

    def exitonclick(self):
        """Go into mainloop until the mouse is clicked.

        No arguments.

        Bind bye() method to mouseclick on TurtleScreen.
        If "using_IDLE" - value in configuration dictionary is False
        (default value), enter mainloop.
        If IDLE with -n switch (no subprocess) is used, this value should be
        set to True in turtle.cfg. In this case IDLE's mainloop
        is active also for the client script.

        This is a method of the Screen-class and not available for
        TurtleScreen instances.

        Example (for a Screen instance named screen):
        >>> screen.exitonclick()

        """
        def exitGracefully(x, y):
            """Screen.bye() with two dummy-parameters"""
            self.bye()
        self.onclick(exitGracefully)
        if _CFG["using_IDLE"]:
            return
        try:
            mainloop()
        except AttributeError:
            exit(0)


class Turtle(RawTurtle):
    """RawTurtle auto-creating (scrolled) canvas.

    When a Turtle object is created or a function derived from some
    Turtle method is called a TurtleScreen object is automatically created.
    """
    _pen = None
    _screen = None

    def __init__(self,
                 shape=_CFG["shape"],
                 undobuffersize=_CFG["undobuffersize"],
                 visible=_CFG["visible"]):
        if Turtle._screen is None:
            Turtle._screen = Screen()
        RawTurtle.__init__(self, Turtle._screen,
                           shape=shape,
                           undobuffersize=undobuffersize,
                           visible=visible)

Pen = Turtle

def _getpen():
    """Create the 'anonymous' turtle if not already present."""
    if Turtle._pen is None:
        Turtle._pen = Turtle()
    return Turtle._pen

def _getscreen():
    """Create a TurtleScreen if not already present."""
    if Turtle._screen is None:
        Turtle._screen = Screen()
    return Turtle._screen

def write_docstringdict(filename="turtle_docstringdict"):
    """Create and write docstring-dictionary to file.

    Optional argument:
    filename -- a string, used as filename
                default value is turtle_docstringdict

    Has to be called explicitly, (not used by the turtle-graphics classes)
    The docstring dictionary will be written to the Python script <filname>.py
    It is intended to serve as a template for translation of the docstrings
    into different languages.
    """
    docsdict = {}

    for methodname in _tg_screen_functions:
        key = "_Screen."+methodname
        docsdict[key] = eval(key).__doc__
    for methodname in _tg_turtle_functions:
        key = "Turtle."+methodname
        docsdict[key] = eval(key).__doc__

    with open("%s.py" % filename,"w") as f:
        keys = sorted([x for x in docsdict.keys()
                            if x.split('.')[1] not in _alias_list])
        f.write('docsdict = {\n\n')
        for key in keys[:-1]:
            f.write('%s :\n' % repr(key))
            f.write('        """%s\n""",\n\n' % docsdict[key])
        key = keys[-1]
        f.write('%s :\n' % repr(key))
        f.write('        """%s\n"""\n\n' % docsdict[key])
        f.write("}\n")
        f.close()

def read_docstrings(lang):
    """Read in docstrings from lang-specific docstring dictionary.

    Transfer docstrings, translated to lang, from a dictionary-file
    to the methods of classes Screen and Turtle and - in revised form -
    to the corresponding functions.
    """
    modname = "turtle_docstringdict_%(language)s" % {'language':lang.lower()}
    module = __import__(modname)
    docsdict = module.docsdict
    for key in docsdict:
        try:
#            eval(key).im_func.__doc__ = docsdict[key]
            eval(key).__doc__ = docsdict[key]
        except:
            print("Bad docstring-entry: %s" % key)

_LANGUAGE = _CFG["language"]

try:
    if _LANGUAGE != "english":
        read_docstrings(_LANGUAGE)
except ImportError:
    print("Cannot find docsdict for", _LANGUAGE)
except:
    print ("Unknown Error when trying to import %s-docstring-dictionary" %
                                                                  _LANGUAGE)


def getmethparlist(ob):
    """Get strings describing the arguments for the given object

    Returns a pair of strings representing function parameter lists
    including parenthesis.  The first string is suitable for use in
    function definition and the second is suitable for use in function
    call.  The "self" parameter is not included.
    """
    defText = callText = ""
    # bit of a hack for methods - turn it into a function
    # but we drop the "self" param.
    # Try and build one for Python defined functions
    args, varargs, varkw = inspect.getargs(ob.__code__)
    items2 = args[1:]
    realArgs = args[1:]
    defaults = ob.__defaults__ or []
    defaults = ["=%r" % (value,) for value in defaults]
    defaults = [""] * (len(realArgs)-len(defaults)) + defaults
    items1 = [arg + dflt for arg, dflt in zip(realArgs, defaults)]
    if varargs is not None:
        items1.append("*" + varargs)
        items2.append("*" + varargs)
    if varkw is not None:
        items1.append("**" + varkw)
        items2.append("**" + varkw)
    defText = ", ".join(items1)
    defText = "(%s)" % defText
    callText = ", ".join(items2)
    callText = "(%s)" % callText
    return defText, callText

def _turtle_docrevise(docstr):
    """To reduce docstrings from RawTurtle class for functions
    """
    import re
    if docstr is None:
        return None
    turtlename = _CFG["exampleturtle"]
    newdocstr = docstr.replace("%s." % turtlename,"")
    parexp = re.compile(r' \(.+ %s\):' % turtlename)
    newdocstr = parexp.sub(":", newdocstr)
    return newdocstr

def _screen_docrevise(docstr):
    """To reduce docstrings from TurtleScreen class for functions
    """
    import re
    if docstr is None:
        return None
    screenname = _CFG["examplescreen"]
    newdocstr = docstr.replace("%s." % screenname,"")
    parexp = re.compile(r' \(.+ %s\):' % screenname)
    newdocstr = parexp.sub(":", newdocstr)
    return newdocstr

## The following mechanism makes all methods of RawTurtle and Turtle available
## as functions. So we can enhance, change, add, delete methods to these
## classes and do not need to change anything here.


for methodname in _tg_screen_functions:
    pl1, pl2 = getmethparlist(eval('_Screen.' + methodname))
    if pl1 == "":
        print(">>>>>>", pl1, pl2)
        continue
    defstr = ("def %(key)s%(pl1)s: return _getscreen().%(key)s%(pl2)s" %
                                   {'key':methodname, 'pl1':pl1, 'pl2':pl2})
    exec(defstr)
    eval(methodname).__doc__ = _screen_docrevise(eval('_Screen.'+methodname).__doc__)

for methodname in _tg_turtle_functions:
    pl1, pl2 = getmethparlist(eval('Turtle.' + methodname))
    if pl1 == "":
        print(">>>>>>", pl1, pl2)
        continue
    defstr = ("def %(key)s%(pl1)s: return _getpen().%(key)s%(pl2)s" %
                                   {'key':methodname, 'pl1':pl1, 'pl2':pl2})
    exec(defstr)
    eval(methodname).__doc__ = _turtle_docrevise(eval('Turtle.'+methodname).__doc__)


done = mainloop

if __name__ == "__main__":
    def switchpen():
        if isdown():
            pu()
        else:
            pd()

    def demo1():
        """Demo of old turtle.py - module"""
        reset()
        tracer(True)
        up()
        backward(100)
        down()
        # draw 3 squares; the last filled
        width(3)
        for i in range(3):
            if i == 2:
                begin_fill()
            for _ in range(4):
                forward(20)
                left(90)
            if i == 2:
                color("maroon")
                end_fill()
            up()
            forward(30)
            down()
        width(1)
        color("black")
        # move out of the way
        tracer(False)
        up()
        right(90)
        forward(100)
        right(90)
        forward(100)
        right(180)
        down()
        # some text
        write("startstart", 1)
        write("start", 1)
        color("red")
        # staircase
        for i in range(5):
            forward(20)
            left(90)
            forward(20)
            right(90)
        # filled staircase
        tracer(True)
        begin_fill()
        for i in range(5):
            forward(20)
            left(90)
            forward(20)
            right(90)
        end_fill()
        # more text

    def demo2():
        """Demo of some new features."""
        speed(1)
        st()
        pensize(3)
        setheading(towards(0, 0))
        radius = distance(0, 0)/2.0
        rt(90)
        for _ in range(18):
            switchpen()
            circle(radius, 10)
        write("wait a moment...")
        while undobufferentries():
            undo()
        reset()
        lt(90)
        colormode(255)
        laenge = 10
        pencolor("green")
        pensize(3)
        lt(180)
        for i in range(-2, 16):
            if i > 0:
                begin_fill()
                fillcolor(255-15*i, 0, 15*i)
            for _ in range(3):
                fd(laenge)
                lt(120)
            end_fill()
            laenge += 10
            lt(15)
            speed((speed()+1)%12)
        #end_fill()

        lt(120)
        pu()
        fd(70)
        rt(30)
        pd()
        color("red","yellow")
        speed(0)
        begin_fill()
        for _ in range(4):
            circle(50, 90)
            rt(90)
            fd(30)
            rt(90)
        end_fill()
        lt(90)
        pu()
        fd(30)
        pd()
        shape("turtle")

        tri = getturtle()
        tri.resizemode("auto")
        turtle = Turtle()
        turtle.resizemode("auto")
        turtle.shape("turtle")
        turtle.reset()
        turtle.left(90)
        turtle.speed(0)
        turtle.up()
        turtle.goto(280, 40)
        turtle.lt(30)
        turtle.down()
        turtle.speed(6)
        turtle.color("blue","orange")
        turtle.pensize(2)
        tri.speed(6)
        setheading(towards(turtle))
        count = 1
        while tri.distance(turtle) > 4:
            turtle.fd(3.5)
            turtle.lt(0.6)
            tri.setheading(tri.towards(turtle))
            tri.fd(4)
            if count % 20 == 0:
                turtle.stamp()
                tri.stamp()
                switchpen()
            count += 1
        tri.write("CAUGHT! ", font=("Arial", 16, "bold"), align="right")
        tri.pencolor("black")
        tri.pencolor("red")

        def baba(xdummy, ydummy):
            clearscreen()
            bye()

        time.sleep(2)

        while undobufferentries():
            tri.undo()
            turtle.undo()
        tri.fd(50)
        tri.write("  Click me!", font = ("Courier", 12, "bold") )
        tri.onclick(baba, 1)

    demo1()
    demo2()
    exitonclick()
                                                                                                                                                                                                                                                                                                                                     usr/lib/python3.4/types.py                                                                          0100644 0000000 0000000 00000012360 12415221636 014114  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """
Define names for built-in types that aren't directly accessible as a builtin.
"""
import sys

# Iterators in Python aren't a matter of type but of protocol.  A large
# and changing number of builtin types implement *some* flavor of
# iterator.  Don't check the type!  Use hasattr to check for both
# "__iter__" and "__next__" attributes instead.

def _f(): pass
FunctionType = type(_f)
LambdaType = type(lambda: None)         # Same as FunctionType
CodeType = type(_f.__code__)
MappingProxyType = type(type.__dict__)
SimpleNamespace = type(sys.implementation)

def _g():
    yield 1
GeneratorType = type(_g())

class _C:
    def _m(self): pass
MethodType = type(_C()._m)

BuiltinFunctionType = type(len)
BuiltinMethodType = type([].append)     # Same as BuiltinFunctionType

ModuleType = type(sys)

try:
    raise TypeError
except TypeError:
    tb = sys.exc_info()[2]
    TracebackType = type(tb)
    FrameType = type(tb.tb_frame)
    tb = None; del tb

# For Jython, the following two types are identical
GetSetDescriptorType = type(FunctionType.__code__)
MemberDescriptorType = type(FunctionType.__globals__)

del sys, _f, _g, _C,                              # Not for export


# Provide a PEP 3115 compliant mechanism for class creation
def new_class(name, bases=(), kwds=None, exec_body=None):
    """Create a class object dynamically using the appropriate metaclass."""
    meta, ns, kwds = prepare_class(name, bases, kwds)
    if exec_body is not None:
        exec_body(ns)
    return meta(name, bases, ns, **kwds)

def prepare_class(name, bases=(), kwds=None):
    """Call the __prepare__ method of the appropriate metaclass.

    Returns (metaclass, namespace, kwds) as a 3-tuple

    *metaclass* is the appropriate metaclass
    *namespace* is the prepared class namespace
    *kwds* is an updated copy of the passed in kwds argument with any
    'metaclass' entry removed. If no kwds argument is passed in, this will
    be an empty dict.
    """
    if kwds is None:
        kwds = {}
    else:
        kwds = dict(kwds) # Don't alter the provided mapping
    if 'metaclass' in kwds:
        meta = kwds.pop('metaclass')
    else:
        if bases:
            meta = type(bases[0])
        else:
            meta = type
    if isinstance(meta, type):
        # when meta is a type, we first determine the most-derived metaclass
        # instead of invoking the initial candidate directly
        meta = _calculate_meta(meta, bases)
    if hasattr(meta, '__prepare__'):
        ns = meta.__prepare__(name, bases, **kwds)
    else:
        ns = {}
    return meta, ns, kwds

def _calculate_meta(meta, bases):
    """Calculate the most derived metaclass."""
    winner = meta
    for base in bases:
        base_meta = type(base)
        if issubclass(winner, base_meta):
            continue
        if issubclass(base_meta, winner):
            winner = base_meta
            continue
        # else:
        raise TypeError("metaclass conflict: "
                        "the metaclass of a derived class "
                        "must be a (non-strict) subclass "
                        "of the metaclasses of all its bases")
    return winner

class DynamicClassAttribute:
    """Route attribute access on a class to __getattr__.

    This is a descriptor, used to define attributes that act differently when
    accessed through an instance and through a class.  Instance access remains
    normal, but access to an attribute through a class will be routed to the
    class's __getattr__ method; this is done by raising AttributeError.

    This allows one to have properties active on an instance, and have virtual
    attributes on the class with the same name (see Enum for an example).

    """
    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        # next two lines make DynamicClassAttribute act the same as property
        self.__doc__ = doc or fget.__doc__
        self.overwrite_doc = doc is None
        # support for abstract methods
        self.__isabstractmethod__ = bool(getattr(fget, '__isabstractmethod__', False))

    def __get__(self, instance, ownerclass=None):
        if instance is None:
            if self.__isabstractmethod__:
                return self
            raise AttributeError()
        elif self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(instance)

    def __set__(self, instance, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(instance, value)

    def __delete__(self, instance):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(instance)

    def getter(self, fget):
        fdoc = fget.__doc__ if self.overwrite_doc else None
        result = type(self)(fget, self.fset, self.fdel, fdoc or self.__doc__)
        result.overwrite_doc = self.overwrite_doc
        return result

    def setter(self, fset):
        result = type(self)(self.fget, fset, self.fdel, self.__doc__)
        result.overwrite_doc = self.overwrite_doc
        return result

    def deleter(self, fdel):
        result = type(self)(self.fget, self.fset, fdel, self.__doc__)
        result.overwrite_doc = self.overwrite_doc
        return result
                                                                                                                                                                                                                                                                                usr/lib/python3.4/unittest/                                                                         0040755 0000000 0000000 00000000000 13077704336 014266  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/unittest/__init__.py                                                              0100644 0000000 0000000 00000005236 12415221640 016365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """
Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's
Smalltalk testing framework.

This module contains the core framework classes that form the basis of
specific test cases and suites (TestCase, TestSuite etc.), and also a
text-based utility class for running the tests and reporting the results
 (TextTestRunner).

Simple usage:

    import unittest

    class IntegerArithmeticTestCase(unittest.TestCase):
        def testAdd(self):  ## test method names begin 'test*'
            self.assertEqual((1 + 2), 3)
            self.assertEqual(0 + 1, 1)
        def testMultiply(self):
            self.assertEqual((0 * 10), 0)
            self.assertEqual((5 * 8), 40)

    if __name__ == '__main__':
        unittest.main()

Further information is available in the bundled documentation, and from

  http://docs.python.org/library/unittest.html

Copyright (c) 1999-2003 Steve Purcell
Copyright (c) 2003-2010 Python Software Foundation
This module is free software, and you may redistribute it and/or modify
it under the same terms as Python itself, so long as this copyright message
and disclaimer are retained in their original form.

IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,
AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
"""

__all__ = ['TestResult', 'TestCase', 'TestSuite',
           'TextTestRunner', 'TestLoader', 'FunctionTestCase', 'main',
           'defaultTestLoader', 'SkipTest', 'skip', 'skipIf', 'skipUnless',
           'expectedFailure', 'TextTestResult', 'installHandler',
           'registerResult', 'removeResult', 'removeHandler']

# Expose obsolete functions for backwards compatibility
__all__.extend(['getTestCaseNames', 'makeSuite', 'findTestCases'])

__unittest = True

from .result import TestResult
from .case import (TestCase, FunctionTestCase, SkipTest, skip, skipIf,
                   skipUnless, expectedFailure)
from .suite import BaseTestSuite, TestSuite
from .loader import (TestLoader, defaultTestLoader, makeSuite, getTestCaseNames,
                     findTestCases)
from .main import TestProgram, main
from .runner import TextTestRunner, TextTestResult
from .signals import installHandler, registerResult, removeResult, removeHandler

# deprecated
_TextTestResult = TextTestResult
                                                                                                                                                                                                                                                                                                                                                                  usr/lib/python3.4/unittest/__main__.py                                                              0100644 0000000 0000000 00000000745 12415221640 016346  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Main entry point"""

import sys
if sys.argv[0].endswith("__main__.py"):
    import os.path
    # We change sys.argv[0] to make help message more useful
    # use executable without path, unquoted
    # (it's just a hint anyway)
    # (if you have spaces in your executable you get what you deserve!)
    executable = os.path.basename(sys.executable)
    sys.argv[0] = executable + " -m unittest"
    del os

__unittest = True

from .main import main, TestProgram

main(module=None)
                           usr/lib/python3.4/unittest/__pycache__/                                                             0040755 0000000 0000000 00000000000 13077704336 016476  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/unittest/__pycache__/__init__.cpython-34.pyc                                      0100644 0000000 0000000 00000005410 13077704336 022656  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T
                 @   s8  d  Z  d d d d d d d d d	 d
 d d d d d d d d g Z e j d d d g  d Z d d l m Z d d l m Z m Z m	 Z	 m
 Z
 m Z m Z m Z d d l m Z m Z d d l m Z m Z m Z m Z m Z d d l m Z m Z d d l m Z m Z d d l m Z m Z m Z m  Z  e Z! d S) a  
Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's
Smalltalk testing framework.

This module contains the core framework classes that form the basis of
specific test cases and suites (TestCase, TestSuite etc.), and also a
text-based utility class for running the tests and reporting the results
 (TextTestRunner).

Simple usage:

    import unittest

    class IntegerArithmeticTestCase(unittest.TestCase):
        def testAdd(self):  ## test method names begin 'test*'
            self.assertEqual((1 + 2), 3)
            self.assertEqual(0 + 1, 1)
        def testMultiply(self):
            self.assertEqual((0 * 10), 0)
            self.assertEqual((5 * 8), 40)

    if __name__ == '__main__':
        unittest.main()

Further information is available in the bundled documentation, and from

  http://docs.python.org/library/unittest.html

Copyright (c) 1999-2003 Steve Purcell
Copyright (c) 2003-2010 Python Software Foundation
This module is free software, and you may redistribute it and/or modify
it under the same terms as Python itself, so long as this copyright message
and disclaimer are retained in their original form.

IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,
AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

TestResultTestCase	TestSuiteTextTestRunner
TestLoaderFunctionTestCasemaindefaultTestLoaderSkipTestskipskipIf
skipUnlessexpectedFailureTextTestResultinstallHandlerregisterResultremoveResultremoveHandlergetTestCaseNames	makeSuitefindTestCasesT   )r   )r   r   r	   r
   r   r   r   )BaseTestSuiter   )r   r   r   r   r   )TestProgramr   )r   r   )r   r   r   r   N)"__doc____all__extendZ
__unittestresultr   Zcaser   r   r	   r
   r   r   r   Zsuiter   r   loaderr   r   r   r   r   r   r   Zrunnerr   r   Zsignalsr   r   r   r   Z_TextTestResult r   r   '/usr/lib/python3.4/unittest/__init__.py<module>-   s   		4("                                                                                                                                                                                                                                                        usr/lib/python3.4/unittest/__pycache__/__main__.cpython-34.pyc                                      0100644 0000000 0000000 00000000704 13077704336 022640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s   d  Z  d d l Z e j d j d  r` d d l Z e j j e j  Z e d e j d <[ n  d Z	 d d l
 m
 Z
 m Z e
 d d  d S)	zMain entry point    Nz__main__.pyz -m unittestT   )mainTestProgrammodule)__doc__sysargvendswithos.pathospathbasename
executableZ
__unittestr   r    r   r   '/usr/lib/python3.4/unittest/__main__.py<module>   s                                                               usr/lib/python3.4/unittest/__pycache__/case.cpython-34.pyc                                          0100644 0000000 0000000 00000141514 13077704336 022040  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s8  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l m Z d d l m Z m Z m Z m Z m Z d Z d Z Gd d	   d	 e  Z Gd
 d   d e  Z Gd d   d e  Z Gd d   d e  Z d d   Z d d   Z d d   Z d d   Z d d   Z Gd d   d  Z  Gd d   d e   Z! Gd d   d e!  Z" Gd  d!   d! e!  Z# e j$ d" d# d$ g  Z% Gd% d&   d& e j&  Z' Gd' d(   d( e   Z( Gd) d*   d* e  Z) Gd+ d,   d, e)  Z* Gd- d.   d. e)  Z+ d S)/zTest case implementation    N   )result)strclass	safe_repr_count_diff_all_purpose_count_diff_hashable_common_shorten_reprTz@
Diff is %s characters long. Set self.maxDiff to None to see it.c               @   s   e  Z d  Z d Z d S)SkipTestz
    Raise this exception in a test to skip it.

    Usually you can use TestCase.skipTest() or one of the skipping decorators
    instead of raising this directly.
    N)__name__
__module____qualname____doc__ r   r   #/usr/lib/python3.4/unittest/case.pyr	      s   r	   c               @   s   e  Z d  Z d Z d S)_ShouldStopz
    The test should stop.
    N)r
   r   r   r   r   r   r   r   r       s   r   c               @   s   e  Z d  Z d Z d S)_UnexpectedSuccessz7
    The test was supposed to fail, but it didn't!
    N)r
   r   r   r   r   r   r   r   r   %   s   r   c               @   s7   e  Z d  Z d d d  Z e j d d d   Z d S)_OutcomeNc             C   sL   d |  _  | |  _ t | d  |  _ d |  _ g  |  _ d  |  _ g  |  _ d  S)NF
addSubTestT)expecting_failurer   hasattrresult_supports_subtestssuccessskippedexpectedFailureerrors)selfr   r   r   r   __init__,   s    					z_Outcome.__init__Fc             c   s#  |  j  } d |  _  z y	 d  VWn t k
 r5   Yn t k
 r~ } z* d |  _  |  j j | t |  f  WYd  d  } ~ Xn t k
 r Yny t j   } |  j	 r | |  _
 n d |  _  |  j j | | f  d  } Yn, X|  j r|  j  r|  j j | d  f  n  Wd  |  j  o| |  _  Xd  S)NTF)r   KeyboardInterruptr	   r   appendstrr   sysexc_infor   r   r   r   )r   	test_caseisTestZold_successer!   r   r   r   testPartExecutor5   s*    				.		z_Outcome.testPartExecutor)r
   r   r   r   
contextlibcontextmanagerr%   r   r   r   r   r   +   s   	r   c             C   s   |  S)Nr   )objr   r   r   _idS   s    r)   c                s     f d d   } | S)z&
    Unconditionally skip a test.
    c                sO   t  |  t  s9 t j |     f d d    } | }  n  d |  _   |  _ |  S)Nc                 s   t      d  S)N)r	   )argskwargs)reasonr   r   skip_wrapper\   s    z-skip.<locals>.decorator.<locals>.skip_wrapperT)
isinstancetype	functoolswraps__unittest_skip____unittest_skip_why__)	test_itemr-   )r,   r   r   	decoratorZ   s    !			zskip.<locals>.decoratorr   )r,   r5   r   )r,   r   skipV   s    
r6   c             C   s   |  r t  |  St S)z/
    Skip a test if the condition is true.
    )r6   r)   )	conditionr,   r   r   r   skipIff   s    
r8   c             C   s   |  s t  |  St S)z3
    Skip a test unless the condition is true.
    )r6   r)   )r7   r,   r   r   r   
skipUnlessn   s    
r9   c             C   s   d |  _  |  S)NT)__unittest_expecting_failure__)r4   r   r   r   r   v   s    	r   c               @   s(   e  Z d  Z d d   Z d d   Z d S)_BaseTestCaseContextc             C   s   | |  _  d  S)N)r"   )r   r"   r   r   r   r   }   s    z_BaseTestCaseContext.__init__c             C   s.   |  j  j |  j |  } |  j  j |   d  S)N)r"   _formatMessagemsgfailureException)r   standardMsgr=   r   r   r   _raiseFailure   s    z"_BaseTestCaseContext._raiseFailureN)r
   r   r   r   r@   r   r   r   r   r;   {   s   r;   c               @   s.   e  Z d  Z d d d d  Z d d   Z d S)_AssertRaisesBaseContextNc             C   s   t  j |  |  | |  _ | |  _ | d  k	 re y | j |  _ Wqn t k
 ra t |  |  _ Yqn Xn	 d  |  _ | d  k	 r t j	 |  } n  | |  _
 d  |  _ d  S)N)r;   r   expectedr"   r
   obj_nameAttributeErrorr   recompileexpected_regexr=   )r   rB   r"   callable_objrG   r   r   r   r      s    				z!_AssertRaisesBaseContext.__init__c          
   C   sC   | d k r% | j  d d  |  _ |  S|   | | |   Wd QXd S)z
        If callable_obj is None, assertRaises/Warns is being used as a
        context manager, so check for a 'msg' kwarg and return self.
        If callable_obj is not None, call it passing args and kwargs.
        Nr=   )popr=   )r   namerH   r*   r+   r   r   r   handle   s
    z_AssertRaisesBaseContext.handle)r
   r   r   r   rK   r   r   r   r   rA      s   rA   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)_AssertRaisesContextzCA context manager used to implement TestCase.assertRaises* methods.c             C   s   |  S)Nr   )r   r   r   r   	__enter__   s    z_AssertRaisesContext.__enter__c             C   s  | d  k r y |  j  j } Wn! t k
 r? t |  j   } Yn X|  j rh |  j d j | |  j   q |  j d j |   n t j |  t	 | |  j   s d S| j
 d   |  _ |  j d  k r d S|  j } | j t |   s|  j d j | j t |    n  d S)Nz{} not raised by {}z{} not raisedFTz"{}" does not match "{}")rB   r
   rD   r   rC   r@   format	tracebackclear_frames
issubclasswith_tracebackZ	exceptionrG   searchpattern)r   exc_type	exc_valuetbexc_namerG   r   r   r   __exit__   s(    		z_AssertRaisesContext.__exit__N)r
   r   r   r   rM   rY   r   r   r   r   rL      s   rL   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)_AssertWarnsContextzBA context manager used to implement TestCase.assertWarns* methods.c             C   sv   x5 t  j j   D]$ } t | d d   r i  | _ q q Wt j d d  |  _ |  j j   |  _ t j	 d |  j
  |  S)N__warningregistry__recordTalways)r    modulesvaluesgetattrr[   warningscatch_warningswarnings_managerrM   simplefilterrB   )r   vr   r   r   rM      s    z_AssertWarnsContext.__enter__c             C   sp  |  j  j | | |  | d  k	 r& d  Sy |  j j } Wn! t k
 rY t |  j  } Yn Xd  } x |  j D] } | j } t | |  j  s qj n  | d  k r | } n  |  j	 d  k	 r |  j	 j
 t |   r qj n  | |  _ | j |  _ | j |  _ d  SW| d  k	 r.|  j d j |  j	 j t |    n  |  j rV|  j d j | |  j   n |  j d j |   d  S)Nz"{}" does not match "{}"z{} not triggered by {}z{} not triggered)rc   rY   rB   r
   rD   r   ra   messager.   rG   rS   Zwarningfilenamelinenor@   rN   rT   rC   )r   rU   rV   rW   rX   Zfirst_matchingmwr   r   r   rY      s8    				z_AssertWarnsContext.__exit__N)r
   r   r   r   rM   rY   r   r   r   r   rZ      s   rZ   _LoggingWatcherrecordsoutputc               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	_CapturingHandlerzM
    A logging handler capturing all (raw and formatted) logging output.
    c             C   s&   t  j j |   t g  g   |  _ d  S)N)loggingHandlerr   rk   watcher)r   r   r   r   r     s    z_CapturingHandler.__init__c             C   s   d  S)Nr   )r   r   r   r   flush  s    z_CapturingHandler.flushc             C   s9   |  j  j j |  |  j |  } |  j  j j |  d  S)N)rq   rl   r   rN   rm   )r   r\   r=   r   r   r   emit	  s    z_CapturingHandler.emitN)r
   r   r   r   r   rr   rs   r   r   r   r   rn      s   rn   c               @   s@   e  Z d  Z d Z d Z d d   Z d d   Z d d   Z d	 S)
_AssertLogsContextz:A context manager used to implement TestCase.assertLogs().z"%(levelname)s:%(name)s:%(message)sc             C   sS   t  j |  |  | |  _ | r: t j j | |  |  _ n t j |  _ d  |  _ d  S)N)	r;   r   logger_namero   Z_nameToLevelgetlevelINFOr=   )r   r"   ru   rw   r   r   r   r     s    	z_AssertLogsContext.__init__c             C   s   t  |  j t j  r( |  j } |  _ n t j |  j  } |  _ t j |  j  } t   } | j	 |  | j
 |  _
 | j d  d   |  _ | j |  _ | j |  _ | g | _ | j |  j  d | _ | j
 S)NF)r.   ru   ro   ZLoggerloggerZ	getLoggerZ	FormatterLOGGING_FORMATrn   ZsetFormatterrq   handlersold_handlersrw   	old_level	propagateold_propagatesetLevel)r   ry   Z	formatterZhandlerr   r   r   rM     s    		z_AssertLogsContext.__enter__c             C   s   |  j  |  j _ |  j |  j _ |  j j |  j  | d  k	 rA d St |  j j	  d k r |  j
 d j t j |  j  |  j j   n  d  S)NFr   z-no logs of level {} or higher triggered on {})r|   ry   r{   r   r~   r   r}   lenrq   rl   r@   rN   ro   ZgetLevelNamerw   rJ   )r   rU   rV   rW   r   r   r   rY   /  s    z_AssertLogsContext.__exit__N)r
   r   r   r   rz   r   rM   rY   r   r   r   r   rt     s
   	rt   c               @   sM  e  Z d  Z d Z e Z d Z d Z d Z d Z	 d d	 d
  Z
 d d   Z d d   Z d d   Z d d   Z e d d    Z e d d    Z d d   Z d d   Z d d   Z d d   Z d d    Z d! d"   Z d# d$   Z d% d&   Z d' d(   Z e j d) d* d+   Z d, d-   Z d. d/   Z d0 d1   Z  d) d2 d3  Z! d4 d5   Z" d6 d7   Z# d8 d9   Z$ d: d;   Z% d) d< d=  Z& d) d> d?  Z' d) d@ dA  Z( dB dC   Z) d) dD dE  Z* d) dF dG  Z+ d) d) dH dI  Z, dJ dK   Z- d) dL dM  Z. d) dN dO  Z/ d) dP dQ  Z0 d) d) d) dR dS  Z1 d) d) d) dT dU  Z2 d) d) dV dW  Z3 dX dY   Z4 d) dZ d[  Z5 d) d\ d]  Z6 d) d^ d_  Z7 d) d` da  Z8 d) db dc  Z9 d) dd de  Z: d) df dg  Z; d) dh di  Z< d) dj dk  Z= d) dl dm  Z> d) dn do  Z? d) dp dq  Z@ d) dr ds  ZA d) dt du  ZB d) dv dw  ZC d) dx dy  ZD d) dz d{  ZE d) d| d}  ZF d) d~ d  ZG d) d d  ZH d) d d  ZI d) d d  ZJ d) d d  ZK d d   ZL eL e/  ZM ZN eL e0  ZO ZP eL e1  ZQ ZR eL e2  ZS ZT eL e(  ZU ZV eL e*  ZW eL e'  ZX eL eH  ZY eL eJ  ZZ d) S)TestCaseaW  A class whose instances are single test cases.

    By default, the test code itself should be placed in a method named
    'runTest'.

    If the fixture may be used for many test cases, create as
    many test methods as are needed. When instantiating such a TestCase
    subclass, specify in the constructor arguments the name of the test method
    that the instance is to execute.

    Test authors should subclass TestCase for their own tests. Construction
    and deconstruction of the test's environment ('fixture') can be
    implemented by overriding the 'setUp' and 'tearDown' methods respectively.

    If it is necessary to override the __init__ method, the base class
    __init__ method must always be called. It is important that subclasses
    should not change the signature of their __init__ method, since instances
    of the classes are instantiated automatically by parts of the framework
    in order to be run.

    When subclassing TestCase, you can set these attributes:
    * failureException: determines which exception will be raised when
        the instance's assertion methods fail; test methods raising this
        exception will be deemed to have 'failed' rather than 'errored'.
    * longMessage: determines whether long messages (including repr of
        objects used in assert methods) will be printed on failure in *addition*
        to any explicit message passed.
    * maxDiff: sets the maximum length of a diff in failure messages
        by assert methods using difflib. It is looked up as an instance
        attribute so can be configured by individual tests if required.
    TP            FrunTestc             C   s   | |  _  d |  _ d |  _ y t |  |  } Wn: t k
 rj | d k rf t d |  j | f   n  Yn X| j |  _ g  |  _ d |  _	 i  |  _
 |  j t d  |  j t d  |  j t d  |  j t d  |  j t d  |  j t d	  d S)
zCreate an instance of the class that will use the named test
           method when executed. Raises a ValueError if the instance does
           not have a method with the specified name.
        NzNo testr   zno such test method in %s: %sassertDictEqualassertListEqualassertTupleEqualassertSetEqualassertMultiLineEqual)_testMethodName_outcome_testMethodDocr`   rD   
ValueError	__class__r   	_cleanups_subtest_type_equality_funcsaddTypeEqualityFuncdictlisttupleset	frozensetr   )r   Z
methodName
testMethodr   r   r   r   k  s&    						zTestCase.__init__c             C   s   | |  j  | <d S)a[  Add a type specific assertEqual style function to compare a type.

        This method is for use by TestCase subclasses that need to register
        their own type equality functions to provide nicer error messages.

        Args:
            typeobj: The data type to call this function on when both values
                    are of the same type in assertEqual().
            function: The callable taking two arguments and an optional
                    msg= argument that raises self.failureException with a
                    useful error message when the two arguments are not equal.
        N)r   )r   Ztypeobjfunctionr   r   r   r     s    zTestCase.addTypeEqualityFuncc             O   s   |  j  j | | | f  d S)a  Add a function, with arguments, to be called when the test is
        completed. Functions added are called on a LIFO basis and are
        called after tearDown on test failure or success.

        Cleanup items are called even if setUp fails (unlike tearDown).N)r   r   )r   r   r*   r+   r   r   r   
addCleanup  s    zTestCase.addCleanupc             C   s   d S)zAHook method for setting up the test fixture before exercising it.Nr   )r   r   r   r   setUp  s    zTestCase.setUpc             C   s   d S)zAHook method for deconstructing the test fixture after testing it.Nr   )r   r   r   r   tearDown  s    zTestCase.tearDownc             C   s   d S)zKHook method for setting up class fixture before running tests in the class.Nr   )clsr   r   r   
setUpClass  s    zTestCase.setUpClassc             C   s   d S)zVHook method for deconstructing the class fixture after running all tests in the class.Nr   )r   r   r   r   tearDownClass  s    zTestCase.tearDownClassc             C   s   d S)Nr   r   )r   r   r   r   countTestCases  s    zTestCase.countTestCasesc             C   s
   t  j   S)N)r   Z
TestResult)r   r   r   r   defaultTestResult  s    zTestCase.defaultTestResultc             C   s,   |  j  } | r( | j d  d j   p+ d S)zReturns a one-line description of the test, or None if no
        description has been provided.

        The default implementation of this method returns the first line of
        the specified test method's docstring.
        
r   N)r   splitstrip)r   docr   r   r   shortDescription  s    	zTestCase.shortDescriptionc             C   s   d t  |  j  |  j f S)Nz%s.%s)r   r   r   )r   r   r   r   id  s    zTestCase.idc             C   s,   t  |   t  |  k	 r t S|  j | j k S)N)r/   NotImplementedr   )r   otherr   r   r   __eq__  s    zTestCase.__eq__c             C   s   t  t |   |  j f  S)N)hashr/   r   )r   r   r   r   __hash__  s    zTestCase.__hash__c             C   s   d |  j  t |  j  f S)Nz%s (%s))r   r   r   )r   r   r   r   __str__  s    zTestCase.__str__c             C   s   d t  |  j  |  j f S)Nz<%s testMethod=%s>)r   r   r   )r   r   r   r   __repr__  s    zTestCase.__repr__c             C   sR   t  | d d   } | d  k	 r. | | |  n  t j d t d  | j |  d  S)NaddSkipz4TestResult has no addSkip method, skips not reportedr   )r`   ra   warnRuntimeWarning
addSuccess)r   r   r"   r,   r   r   r   r   _addSkip  s    	
zTestCase._addSkipNc             k   s   |  j  j s d Vd S|  j } | d k r< t j |  } n | j j |  } t |  | |  |  _ zy |  j  j |  j d d 
 d VWd QX|  j  j	 s |  j  j
 } | d k	 r | j r t  q n |  j  j r t  n  Wd | |  _ Xd S)aP  Return a context manager that will return the enclosed block
        of code in a subtest identified by the optional message and
        keyword parameters.  A failure in the subtest marks the test
        case as failed but resumes execution at the end of the enclosed
        block, allowing further test code to be executed.
        Nr#   T)r   r   r   collectionsChainMapparams	new_child_SubTestr%   r   r   Zfailfastr   r   )r   r=   r   parentZ
params_mapr   r   r   r   subTest  s$    	zTestCase.subTestc             C   s   x | D]| \ } } t  | t  r; | j | j | |  q | d  k	 r t | d |  j  rp | j | |  q | j | |  q q Wd  S)Nr   )r.   r   r   r"   rQ   r>   
addFailureZaddError)r   r   r   testr!   r   r   r   _feedErrorsToResult  s    zTestCase._feedErrorsToResultc             C   sP   y | j  } Wn/ t k
 r> t j d t  | j |   Yn X| |  |  d  S)Nz@TestResult has no addExpectedFailure method, reporting as passes)addExpectedFailurerD   ra   r   r   r   )r   r   r!   r   r   r   r   _addExpectedFailure  s    	zTestCase._addExpectedFailurec             C   sx   y | j  } WnZ t k
 ri t j d t  y t d   Wn( t k
 rd | j |  t j    Yn XYn X| |   d  S)NzCTestResult has no addUnexpectedSuccess method, reporting as failure)	addUnexpectedSuccessrD   ra   r   r   r   r   r    r!   )r   r   r   r   r   r   _addUnexpectedSuccess  s    	 zTestCase._addUnexpectedSuccessc          %   C   s  | } | d  k rI |  j    } t | d d   } | d  k	 rI |   qI n  | j |   t |  |  j  } t |  j d d  s t | d d  r z> t |  j d d  p t | d d  } |  j | |  |  Wd  | j |   Xd  St | d d  } t |  } z*| |  _ | j	 |    |  j
   Wd  QX| j r| | _ | j	 |  d d  |   Wd  QXd | _ | j	 |    |  j   Wd  QXn  |  j   x* | j D] \ } }	 |  j | | |	  qW|  j | | j  | j r%| r| j r|  j | | j  q"|  j |  q%| j |   n  | SWd  | j |   | d  k rqt | d	 d   }
 |
 d  k	 rq|
   qqn  | j j   d  | _ d  |  _ Xd  S)
NstartTestRunr2   Fr3    r:   r#   TstopTestRun)r   r`   Z	startTestr   r   r   ZstopTestr   r   r%   r   r   r   r   
doCleanupsr   r   r   r   r   r   r   clear)r   r   Zorig_resultr   r   Zskip_whyr   outcomer   r,   r   r   r   r   run!  sb    				
			zTestCase.runc          
   C   sd   |  j  p t   } xH |  j r\ |  j j   \ } } } | j |    | | |   Wd QXq W| j S)zNExecute all cleanup functions. Normally called for you after
        tearDown.N)r   r   r   rI   r%   r   )r   r   r   r*   r+   r   r   r   r   c  s    zTestCase.doCleanupsc             O   s   |  j  | |   S)N)r   )r   r*   kwdsr   r   r   __call__p  s    zTestCase.__call__c             C   sc   |  j    t |  |  j    |  j   x5 |  j r^ |  j j d  \ } } } | | |   q* Wd S)z6Run the test without collecting errors in a TestResultr   N)r   r`   r   r   r   rI   )r   r   r*   r+   r   r   r   debugs  s    

zTestCase.debugc             C   s   t  |   d S)zSkip this test.N)r	   )r   r,   r   r   r   skipTest|  s    zTestCase.skipTestc             C   s   |  j  |   d S)z)Fail immediately, with the given message.N)r>   )r   r=   r   r   r   fail  s    zTestCase.failc             C   s8   | r4 |  j  | d t |   } |  j |   n  d S)z#Check that the expression is false.z%s is not falseN)r<   r   r>   )r   exprr=   r   r   r   assertFalse  s    zTestCase.assertFalsec             C   s8   | s4 |  j  | d t |   } |  j |   n  d S)z"Check that the expression is true.z%s is not trueN)r<   r   r>   )r   r   r=   r   r   r   
assertTrue  s    zTestCase.assertTruec             C   sh   |  j  s | p | S| d k r# | Sy d | | f SWn, t k
 rc d t |  t |  f SYn Xd S)a  Honour the longMessage attribute when generating failure messages.
        If longMessage is False this means:
        * Use only an explicit message if it is provided
        * Otherwise use the standard message for the assert

        If longMessage is True:
        * Use the standard message
        * If an explicit message is provided, plus ' : ' and the explicit message
        Nz%s : %s)longMessageUnicodeDecodeErrorr   )r   r=   r?   r   r   r   r<     s    
	
zTestCase._formatMessagec             O   s(   t  | |  |  } | j d | | |  S)a,  Fail unless an exception of class excClass is raised
           by callableObj when invoked with arguments args and keyword
           arguments kwargs. If a different type of exception is
           raised, it will not be caught, and the test case will be
           deemed to have suffered an error, exactly as for an
           unexpected exception.

           If called with callableObj omitted or None, will return a
           context object used like this::

                with self.assertRaises(SomeException):
                    do_something()

           An optional keyword argument 'msg' can be provided when assertRaises
           is used as a context object.

           The context manager keeps a reference to the exception as
           the 'exception' attribute. This allows you to inspect the
           exception after the assertion::

               with self.assertRaises(SomeException) as cm:
                   do_something()
               the_exception = cm.exception
               self.assertEqual(the_exception.error_code, 3)
        assertRaises)rL   rK   )r   ZexcClassZcallableObjr*   r+   contextr   r   r   r     s    zTestCase.assertRaisesc             O   s(   t  | |  |  } | j d | | |  S)a  Fail unless a warning of class warnClass is triggered
           by callable_obj when invoked with arguments args and keyword
           arguments kwargs.  If a different type of warning is
           triggered, it will not be handled: depending on the other
           warning filtering rules in effect, it might be silenced, printed
           out, or raised as an exception.

           If called with callable_obj omitted or None, will return a
           context object used like this::

                with self.assertWarns(SomeWarning):
                    do_something()

           An optional keyword argument 'msg' can be provided when assertWarns
           is used as a context object.

           The context manager keeps a reference to the first matching
           warning as the 'warning' attribute; similarly, the 'filename'
           and 'lineno' attributes give you information about the line
           of Python code from which the warning was triggered.
           This allows you to inspect the warning after the assertion::

               with self.assertWarns(SomeWarning) as cm:
                   do_something()
               the_warning = cm.warning
               self.assertEqual(the_warning.some_attribute, 147)
        assertWarns)rZ   rK   )r   expected_warningrH   r*   r+   r   r   r   r   r     s    zTestCase.assertWarnsc             C   s   t  |  | |  S)a  Fail unless a log message of level *level* or higher is emitted
        on *logger_name* or its children.  If omitted, *level* defaults to
        INFO and *logger* defaults to the root logger.

        This method must be used as a context manager, and will yield
        a recording object with two attributes: `output` and `records`.
        At the end of the context manager, the `output` attribute will
        be a list of the matching formatted log messages and the
        `records` attribute will be a list of the corresponding LogRecord
        objects.

        Example::

            with self.assertLogs('foo', level='INFO') as cm:
                logging.getLogger('foo').info('first message')
                logging.getLogger('foo.bar').error('second message')
            self.assertEqual(cm.output, ['INFO:foo:first message',
                                         'ERROR:foo.bar:second message'])
        )rt   )r   ry   rw   r   r   r   
assertLogs  s    zTestCase.assertLogsc             C   sk   t  |  t  |  k rd |  j j t  |   } | d k	 rd t | t  r] t |  |  } n  | Sn  |  j S)a  Get a detailed comparison function for the types of the two args.

        Returns: A callable accepting (first, second, msg=None) that will
        raise a failure exception if first != second with a useful human
        readable error message for those types.
        N)r/   r   rv   r.   r   r`   _baseAssertEqual)r   firstsecondZasserterr   r   r   _getAssertEqualityFunc  s    zTestCase._getAssertEqualityFuncc             C   sG   | | k sC d t  | |  } |  j | |  } |  j |   n  d S)z:The default assertEqual implementation, not type specific.z%s != %sN)r   r<   r>   )r   r   r   r=   r?   r   r   r   r     s    zTestCase._baseAssertEqualc             C   s)   |  j  | |  } | | | d | d S)z[Fail if the two objects are unequal as determined by the '=='
           operator.
        r=   N)r   )r   r   r   r=   Zassertion_funcr   r   r   assertEqual  s    zTestCase.assertEqualc             C   sJ   | | k sF |  j  | d t |  t |  f  } |  j |   n  d S)zYFail if the two objects are equal as determined by the '!='
           operator.
        z%s == %sN)r<   r   r>   )r   r   r   r=   r   r   r   assertNotEqual  s    zTestCase.assertNotEqualc             C   s  | | k r d S| d k	 r7 | d k	 r7 t  d   n  | d k	 r t | |  | k r] d Sd t |  t |  t |  f } nW | d k r d } n  t t | |  |  d k r d Sd t |  t |  | f } |  j | |  } |  j |   d S)a  Fail if the two objects are unequal as determined by their
           difference rounded to the given number of decimal places
           (default 7) and comparing to zero, or by comparing that the
           between the two objects is more than the given delta.

           Note that decimal places (from zero) are usually not the same
           as significant digits (measured from the most signficant digit).

           If the two objects compare equal then they will automatically
           compare almost equal.
        Nz specify delta or places not bothz%s != %s within %s delta   r   z%s != %s within %r places)	TypeErrorabsr   roundr<   r>   )r   r   r   placesr=   deltar?   r   r   r   assertAlmostEqual(  s&    			
zTestCase.assertAlmostEqualc             C   s  | d k	 r' | d k	 r' t  d   n  | d k	 r | | k rZ t | |  | k rZ d Sd t |  t |  t |  f } nd | d k r d } n  | | k r t t | |  |  d k r d Sd t |  t |  | f } |  j | |  } |  j |   d S)a  Fail if the two objects are equal as determined by their
           difference rounded to the given number of decimal places
           (default 7) and comparing to zero, or by comparing that the
           between the two objects is less than the given delta.

           Note that decimal places (from zero) are usually not the same
           as significant digits (measured from the most signficant digit).

           Objects that are equal automatically fail.
        Nz specify delta or places not bothz%s == %s within %s deltar   r   z%s == %s within %r places)r   r   r   r   r<   r>   )r   r   r   r   r=   r   r?   r   r   r   assertNotAlmostEqualO  s"    #		,	
zTestCase.assertNotAlmostEqualc          &   C   s  | d k	 rz | j  } t | |  sF |  j d | t |  f   n  t | |  s |  j d | t |  f   q n d } d } y t |  } Wn" t t f k
 r d | } Yn X| d k r y t |  } Wq t t f k
 r d | } Yq Xn  | d k r%| | k rd Sd | j   f t | |  } x t	 t
 | |   D] }	 y | |	 }
 Wn0 t t t f k
 r| d |	 | f 7} PYn Xy | |	 } Wn0 t t t f k
 r| d	 |	 | f 7} PYn X|
 | k rQ| d
 |	 |
 | f 7} PqQqQW| | k r8| d k r8t |  t |  k r8d S| | k r| d | | | f 7} y | d | | | f 7} Wq"t t t f k
 r| d | | f 7} Yq"Xq%| | k  r%| d | | | f 7} y | d | | | f 7} Wq"t t t f k
 r| d | | f 7} Yq"Xq%n  | } d d j t j t j |  j   t j |  j     } |  j | |  } |  j | |  } |  j |  d S)aA  An equality assertion for ordered sequences (like lists and tuples).

        For the purposes of this function, a valid ordered sequence type is one
        which can be indexed, has a length, and has an equality operator.

        Args:
            seq1: The first sequence to compare.
            seq2: The second sequence to compare.
            seq_type: The expected datatype of the sequences, or None if no
                    datatype should be enforced.
            msg: Optional message to use on failure instead of a list of
                    differences.
        NzFirst sequence is not a %s: %szSecond sequence is not a %s: %sZsequencez(First %s has no length.    Non-sequence?z)Second %s has no length.    Non-sequence?z%ss differ: %s != %s
z(
Unable to index element %d of first %s
z)
Unable to index element %d of second %s
z#
First differing element %d:
%s
%s
z+
First %s contains %d additional elements.
zFirst extra element %d:
%s
z'Unable to index element %d of first %s
z,
Second %s contains %d additional elements.
z(Unable to index element %d of second %s
r   )r
   r.   r>   r   r   r   NotImplementedError
capitalizer   rangemin
IndexErrorr/   joindifflibndiffpprintpformat
splitlines_truncateMessager<   r   )r   Zseq1Zseq2r=   seq_typeZseq_type_nameZ	differingZlen1Zlen2iZitem1Zitem2r?   diffMsgr   r   r   assertSequenceEqualp  s    				zTestCase.assertSequenceEqualc             C   sA   |  j  } | d  k s' t |  | k r/ | | S| t t |  S)N)maxDiffr   DIFF_OMITTED)r   rf   diffZmax_diffr   r   r   r     s    	zTestCase._truncateMessagec             C   s   |  j  | | | d t d S)a  A list-specific equality assertion.

        Args:
            list1: The first list to compare.
            list2: The second list to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.

        r   N)r   r   )r   Zlist1Zlist2r=   r   r   r   r     s    
zTestCase.assertListEqualc             C   s   |  j  | | | d t d S)a  A tuple-specific equality assertion.

        Args:
            tuple1: The first tuple to compare.
            tuple2: The second tuple to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.
        r   N)r   r   )r   Ztuple1Ztuple2r=   r   r   r   r     s    	zTestCase.assertTupleEqualc       
       C   s  y | j  |  } Wnk t k
 rK } z |  j d |  WYd d } ~ Xn6 t k
 r } z |  j d |  WYd d } ~ Xn Xy | j  |  } Wnk t k
 r } z |  j d |  WYd d } ~ Xn6 t k
 r} z |  j d |  WYd d } ~ Xn X| p| sd Sg  } | rR| j d  x$ | D] } | j t |   q2Wn  | r| j d  x$ | D] } | j t |   qlWn  d j |  }	 |  j |  j | |	   d S)a  A set-specific equality assertion.

        Args:
            set1: The first set to compare.
            set2: The second set to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.

        assertSetEqual uses ducktyping to support different types of sets, and
        is optimized for sets specifically (parameters must support a
        difference method).
        z/invalid type when attempting set difference: %sNz2first argument does not support set difference: %sz3second argument does not support set difference: %sz*Items in the first set but not the second:z*Items in the second set but not the first:r   )
differencer   r   rD   r   reprr   r<   )
r   Zset1Zset2r=   Zdifference1r$   Zdifference2linesitemr?   r   r   r   r     s2    #$#$zTestCase.assertSetEqualc             C   sH   | | k rD d t  |  t  |  f } |  j |  j | |   n  d S)zDJust like self.assertTrue(a in b), but with a nicer default message.z%s not found in %sN)r   r   r<   )r   member	containerr=   r?   r   r   r   assertIn  s    zTestCase.assertInc             C   sH   | | k rD d t  |  t  |  f } |  j |  j | |   n  d S)zHJust like self.assertTrue(a not in b), but with a nicer default message.z%s unexpectedly found in %sN)r   r   r<   )r   r  r  r=   r?   r   r   r   assertNotIn"  s    zTestCase.assertNotInc             C   sH   | | k	 rD d t  |  t  |  f } |  j |  j | |   n  d S)zDJust like self.assertTrue(a is b), but with a nicer default message.z%s is not %sN)r   r   r<   )r   expr1expr2r=   r?   r   r   r   assertIs)  s    zTestCase.assertIsc             C   s?   | | k r; d t  |  f } |  j |  j | |   n  d S)zHJust like self.assertTrue(a is not b), but with a nicer default message.zunexpectedly identical: %sN)r   r   r<   )r   r  r  r=   r?   r   r   r   assertIsNot0  s    zTestCase.assertIsNotc             C   s   |  j  | t d  |  j  | t d  | | k r d t | |  } d d j t j t j |  j   t j |  j     } |  j	 | |  } |  j
 |  j | |   n  d  S)Nz"First argument is not a dictionaryz#Second argument is not a dictionaryz%s != %sr   )assertIsInstancer   r   r   r   r   r   r   r   r   r   r<   )r   Zd1Zd2r=   r?   r   r   r   r   r   6  s    zTestCase.assertDictEqualc       	      C   s'  t  j d t  g  } g  } xy | j   D]k \ } } | | k rQ | j |  q) | | | k r) | j d t |  t |  t | |  f  q) q) W| p | s d Sd } | r d d j d d   | D  } n  | r
| r | d	 7} n  | d
 d j |  7} n  |  j |  j | |   d S)z2Checks whether dictionary is a superset of subset.z&assertDictContainsSubset is deprecatedz%s, expected: %s, actual: %sNr   zMissing: %s,c             s   s   |  ] } t  |  Vq d  S)N)r   ).0ri   r   r   r   	<genexpr>U  s    z4TestCase.assertDictContainsSubset.<locals>.<genexpr>z; zMismatched values: %s)	ra   r   DeprecationWarningitemsr   r   r   r   r<   )	r   ZsubsetZ
dictionaryr=   ZmissingZ
mismatchedkeyvaluer?   r   r   r   assertDictContainsSubsetB  s,    		z!TestCase.assertDictContainsSubsetc       
      C   s   t  |  t  |  } } y" t j |  } t j |  } Wn! t k
 r^ t | |  } Yn  X| | k ro d St | |  } | r d } d d   | D } d j |  }	 |  j | |	  } |  j | |  } |  j	 |  n  d S)a  An unordered sequence comparison asserting that the same elements,
        regardless of order.  If the same element occurs more than once,
        it verifies that the elements occur the same number of times.

            self.assertEqual(Counter(list(first)),
                             Counter(list(second)))

         Example:
            - [0, 1, 1] and [1, 0, 1] compare equal.
            - [0, 0, 1] and [0, 1] compare unequal.

        NzElement counts were not equal:
c             S   s   g  |  ] } d  |  q S)z First has %d, Second has %d:  %rr   )r  r   r   r   r   
<listcomp>z  s   	 z-TestCase.assertCountEqual.<locals>.<listcomp>r   )
r   r   Counterr   r   r   r   r   r<   r   )
r   r   r   r=   Z	first_seqZ
second_seqZdifferencesr?   r   r   r   r   r   assertCountEqual_  s     zTestCase.assertCountEqualc             C   s>  |  j  | t d  |  j  | t d  | | k r:t |  |  j k s\ t |  |  j k rr |  j | | |  n  | j d d  } | j d d  } t |  d k r | j d  | k r | d g } | d g } n  d t | |  } d d	 j t	 j
 | |   } |  j | |  } |  j |  j | |   n  d
 S)z-Assert that two multi-line strings are equal.zFirst argument is not a stringzSecond argument is not a stringkeependsTr   z
r   z%s != %sr   N)r	  r   r   _diffThresholdr   r   r   r   r   r   r   r   r   r<   )r   r   r   r=   Z
firstlinesZsecondlinesr?   r   r   r   r   r     s    'zTestCase.assertMultiLineEqualc             C   sH   | | k  sD d t  |  t  |  f } |  j |  j | |   n  d S)zCJust like self.assertTrue(a < b), but with a nicer default message.z%s not less than %sN)r   r   r<   )r   abr=   r?   r   r   r   
assertLess  s    zTestCase.assertLessc             C   sH   | | k sD d t  |  t  |  f } |  j |  j | |   n  d S)zDJust like self.assertTrue(a <= b), but with a nicer default message.z%s not less than or equal to %sN)r   r   r<   )r   r  r  r=   r?   r   r   r   assertLessEqual  s    zTestCase.assertLessEqualc             C   sH   | | k sD d t  |  t  |  f } |  j |  j | |   n  d S)zCJust like self.assertTrue(a > b), but with a nicer default message.z%s not greater than %sN)r   r   r<   )r   r  r  r=   r?   r   r   r   assertGreater  s    zTestCase.assertGreaterc             C   sH   | | k sD d t  |  t  |  f } |  j |  j | |   n  d S)zDJust like self.assertTrue(a >= b), but with a nicer default message.z"%s not greater than or equal to %sN)r   r   r<   )r   r  r  r=   r?   r   r   r   assertGreaterEqual  s    zTestCase.assertGreaterEqualc             C   s?   | d k	 r; d t  |  f } |  j |  j | |   n  d S)zCSame as self.assertTrue(obj is None), with a nicer default message.Nz%s is not None)r   r   r<   )r   r(   r=   r?   r   r   r   assertIsNone  s    zTestCase.assertIsNonec             C   s2   | d k r. d } |  j  |  j | |   n  d S)z(Included for symmetry with assertIsNone.Nzunexpectedly None)r   r<   )r   r(   r=   r?   r   r   r   assertIsNotNone  s    zTestCase.assertIsNotNonec             C   sE   t  | |  sA d t |  | f } |  j |  j | |   n  d S)zTSame as self.assertTrue(isinstance(obj, cls)), with a nicer
        default message.z%s is not an instance of %rN)r.   r   r   r<   )r   r(   r   r=   r?   r   r   r   r	    s    zTestCase.assertIsInstancec             C   sE   t  | |  rA d t |  | f } |  j |  j | |   n  d S)z,Included for symmetry with assertIsInstance.z%s is an instance of %rN)r.   r   r   r<   )r   r(   r   r=   r?   r   r   r   assertNotIsInstance  s    zTestCase.assertNotIsInstancec             O   s+   t  | |  | |  } | j d | | |  S)a  Asserts that the message in a raised exception matches a regex.

        Args:
            expected_exception: Exception class expected to be raised.
            expected_regex: Regex (re pattern object or string) expected
                    to be found in error message.
            callable_obj: Function to be called.
            msg: Optional message used in case of failure. Can only be used
                    when assertRaisesRegex is used as a context manager.
            args: Extra args.
            kwargs: Extra kwargs.
        assertRaisesRegex)rL   rK   )r   Zexpected_exceptionrG   rH   r*   r+   r   r   r   r   r     s    	zTestCase.assertRaisesRegexc             O   s+   t  | |  | |  } | j d | | |  S)a  Asserts that the message in a triggered warning matches a regexp.
        Basic functioning is similar to assertWarns() with the addition
        that only warnings whose messages also match the regular expression
        are considered successful matches.

        Args:
            expected_warning: Warning class expected to be triggered.
            expected_regex: Regex (re pattern object or string) expected
                    to be found in error message.
            callable_obj: Function to be called.
            msg: Optional message used in case of failure. Can only be used
                    when assertWarnsRegex is used as a context manager.
            args: Extra args.
            kwargs: Extra kwargs.
        assertWarnsRegex)rZ   rK   )r   r   rG   rH   r*   r+   r   r   r   r   r!    s    	zTestCase.assertWarnsRegexc             C   s   t  | t t f  r9 | s' t d   t j |  } n  | j |  s| | pQ d } d | | j | f } |  j |   n  d S)z=Fail the test unless the text matches the regular expression.z!expected_regex must not be empty.zRegex didn't matchz%s: %r not found in %rN)	r.   r   bytesAssertionErrorrE   rF   rS   rT   r>   )r   textrG   r=   r   r   r   assertRegex  s    zTestCase.assertRegexc             C   s   t  | t t f  r' t j |  } n  | j |  } | r | pE d } d | | | j   | j    | j | f } |  j	 |   n  d S)z9Fail the test if the text matches the regular expression.zRegex matchedz%s: %r matches %r in %rN)
r.   r   r"  rE   rF   rS   startendrT   r>   )r   r$  Zunexpected_regexr=   matchr   r   r   assertNotRegex  s    
zTestCase.assertNotRegexc                s     f d d   } | S)Nc                 s,   t  j d j   j  t d    |  |   S)NzPlease use {0} instead.r   )ra   r   rN   r
   r  )r*   r+   )original_funcr   r   deprecated_func  s    
z,TestCase._deprecate.<locals>.deprecated_funcr   )r*  r+  r   )r*  r   
_deprecate  s    zTestCase._deprecatei  i   )[r
   r   r   r   r#  r>   r   r   r  Z_classSetupFailedr   r   r   r   r   classmethodr   r   r   r   r   r   r   r   r   r   r   r&   r'   r   r   r   r   r   r   r   r   r   r   r   r   r<   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r  r  r  r  r   r  r  r   r  r  r  r  r  r  r	  r  r   r!  r%  r)  r,  ZfailUnlessEqualZassertEqualsZfailIfEqualZassertNotEqualsZfailUnlessAlmostEqualZassertAlmostEqualsZfailIfAlmostEqualZassertNotAlmostEqualsZ
failUnlessZassert_ZfailUnlessRaisesZfailIfZassertRaisesRegexpZassertRegexpMatchesr   r   r   r   r   <  s    	

B		& c+!
	r   c                   s   e  Z d  Z d Z d d d   f d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z   S)FunctionTestCaseaI  A test case that wraps a test function.

    This is useful for slipping pre-existing test functions into the
    unittest framework. Optionally, set-up and tidy-up functions can be
    supplied. As with TestCase, the tidy-up ('tearDown') function will
    always be called if the set-up ('setUp') function ran successfully.
    Nc                s;   t  t |   j   | |  _ | |  _ | |  _ | |  _ d  S)N)superr.  r   
_setUpFunc_tearDownFunc	_testFunc_description)r   ZtestFuncr   r   Zdescription)r   r   r   r   #  s
    			zFunctionTestCase.__init__c             C   s    |  j  d  k	 r |  j    n  d  S)N)r0  )r   r   r   r   r   *  s    zFunctionTestCase.setUpc             C   s    |  j  d  k	 r |  j    n  d  S)N)r1  )r   r   r   r   r   .  s    zFunctionTestCase.tearDownc             C   s   |  j    d  S)N)r2  )r   r   r   r   r   2  s    zFunctionTestCase.runTestc             C   s
   |  j  j S)N)r2  r
   )r   r   r   r   r   5  s    zFunctionTestCase.idc             C   s\   t  | |  j  s t S|  j | j k o[ |  j | j k o[ |  j | j k o[ |  j | j k S)N)r.   r   r   r0  r1  r2  r3  )r   r   r   r   r   r   8  s    zFunctionTestCase.__eq__c             C   s   |  | k S)Nr   )r   r   r   r   r   __ne__A  s    zFunctionTestCase.__ne__c             C   s+   t  t |   |  j |  j |  j |  j f  S)N)r   r/   r0  r1  r2  r3  )r   r   r   r   r   D  s    zFunctionTestCase.__hash__c             C   s   d t  |  j  |  j j f S)Nz%s (%s))r   r   r2  r
   )r   r   r   r   r   H  s    zFunctionTestCase.__str__c             C   s   d t  |  j  |  j f S)Nz<%s tec=%s>)r   r   r2  )r   r   r   r   r   L  s    zFunctionTestCase.__repr__c             C   sE   |  j  d  k	 r |  j  S|  j j } | rA | j d  d j   pD d  S)Nr   r   )r3  r2  r   r   r   )r   r   r   r   r   r   P  s    z!FunctionTestCase.shortDescription)r
   r   r   r   r   r   r   r   r   r   r4  r   r   r   r   r   r   )r   r   r.    s   	r.  c                   s^   e  Z d  Z   f d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z   S)r   c                s8   t    j   | |  _ | |  _ | |  _ | j |  _ d  S)N)r/  r   _messager"   r   r>   )r   r"   rf   r   )r   r   r   r   Y  s
    			z_SubTest.__init__c             C   s   t  d   d  S)Nzsubtests cannot be run directly)r   )r   r   r   r   r   `  s    z_SubTest.runTestc             C   s   g  } |  j  r+ | j d j |  j    n  |  j rx d j d d   t |  j j    D  } | j d j |   n  d j |  p d S)Nz[{}]z, c             s   s'   |  ] \ } } d  j  | |  Vq d S)z{}={!r}N)rN   )r  kre   r   r   r   r  i  s   z+_SubTest._subDescription.<locals>.<genexpr>z({}) z(<subtest>))r5  r   rN   r   r   sortedr  )r   partsZparams_descr   r   r   _subDescriptionc  s    			z_SubTest._subDescriptionc             C   s   d j  |  j j   |  j    S)Nz{} {})rN   r"   r   r:  )r   r   r   r   r   n  s    z_SubTest.idc             C   s   |  j  j   S)zlReturns a one-line description of the subtest, or None if no
        description has been provided.
        )r"   r   )r   r   r   r   r   q  s    z_SubTest.shortDescriptionc             C   s   d j  |  j |  j    S)Nz{} {})rN   r"   r:  )r   r   r   r   r   w  s    z_SubTest.__str__)	r
   r   r   r   r   r:  r   r   r   r   r   )r   r   r   W  s   r   ),r   r    r0   r   ro   r   rE   ra   r   r&   rO   r   r   utilr   r   r   r   r   Z
__unittestr   	Exceptionr	   r   r   objectr   r)   r6   r8   r9   r   r;   rA   rL   rZ   
namedtuplerk   rp   rn   rt   r   r.  r   r   r   r   r   <module>   sJ   ((
 "2	,   =                                                                                                                                                                                    usr/lib/python3.4/unittest/__pycache__/loader.cpython-34.pyc                                        0100644 0000000 0000000 00000027752 13077704336 022402  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T?                 @   sK  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l m	 Z	 m
 Z
 m Z d Z e j d e j  Z d d	   Z d
 d   Z d d   Z d d   Z d d   Z Gd d   d e  Z e   Z d d d  Z e j d d  Z d e j e
 j d d  Z d e j e
 j d d  Z d S)zLoading unittests.    N)fnmatch   )casesuiteutilTz[_a-z]\w*\.py$c             C   s/   d |  t  j   f } t d |  t |  |  S)Nz#Failed to import test module: %s
%sZModuleImportFailure)	traceback
format_exc_make_failed_testImportError)name
suiteClassmessage r   %/usr/lib/python3.4/unittest/loader.py_make_failed_import_test   s    r   c             C   s   t  d |  | |  S)NZLoadTestsFailure)r	   )r   	exceptionr   r   r   r   _make_failed_load_tests   s    r   c                sJ     f d d   } i | | 6} t  |  t j f |  } | | |  f  S)Nc                s
      d  S)Nr   )self)r   r   r   testFailure   s    z&_make_failed_test.<locals>.testFailure)typer   TestCase)Z	classname
methodnamer   r   r   attrs	TestClassr   )r   r   r	      s    r	   c             C   sY   t  j t |   d d    } i | |  6} t d t  j f |  } | | |   f  S)Nc             S   s   d  S)Nr   )r   r   r   r   testSkipped&   s    z'_make_skipped_test.<locals>.testSkippedZModuleSkipped)r   skipstrr   r   )r   r   r   r   r   r   r   r   r   _make_skipped_test%   s    !r   c             C   s7   |  j    j d  r# |  d  d  St j j |   d S)Nz	$py.class	   r   i)lowerendswithospathsplitext)r"   r   r   r   _jython_aware_splitext-   s    r$   c               @   s   e  Z d  Z d Z d Z e e j  Z e	 j
 Z d Z d d   Z d d d  Z d d	 d
  Z d d d  Z d d   Z d d d d  Z d d   Z d d   Z d d   Z d d   Z d d d  Z d S)
TestLoaderz
    This class is responsible for loading tests according to various criteria
    and returning them wrapped in a TestSuite
    testNc             C   sn   t  | t j  r! t d   n  |  j |  } | rR t | d  rR d g } n  |  j t | |   } | S)z<Return a suite of all tests cases contained in testCaseClasszYTest cases should not be derived from TestSuite. Maybe you meant to derive from TestCase?ZrunTest)
issubclassr   	TestSuite	TypeErrorgetTestCaseNameshasattrr   map)r   testCaseClassZtestCaseNamesZloaded_suiter   r   r   loadTestsFromTestCase=   s    z TestLoader.loadTestsFromTestCaseTc             C   s   g  } x] t  |  D]O } t | |  } t | t  r t | t j  r | j |  j |   q q Wt | d d  } |  j	 |  } | r | d k	 r y | |  | d  SWq t
 k
 r } z t | j | |  j	  SWYd d } ~ Xq Xn  | S)z?Return a suite of all tests cases contained in the given module
load_testsN)dirgetattr
isinstancer   r'   r   r   appendr.   r   	Exceptionr   __name__)r   moduleuse_load_teststestsr   objr/   er   r   r   loadTestsFromModuleI   s    ! zTestLoader.loadTestsFromModulec       
      C   s  | j  d  } | d k r | d d  } xL | ry y t d j |   } PWq. t k
 ru | d =| sq   n  Yq. Xq. W| d d  } n  | } x$ | D] } | t | |  } } q Wt | t j  r |  j |  St | t	  rt
 | t j  r|  j |  St | t j  r~t | t	  r~t
 | t j  r~| d } | |  } t t | |  t j  s|  j | g  Sn t | t j  r| St |  r|   }	 t |	 t j  r|	 St |	 t j  r|  j |	 g  St d | |	 f   n t d |   d S)aT  Return a suite of all tests cases given a string specifier.

        The name may resolve either to a module, a test case class, a
        test method within a test case class, or a callable object which
        returns a TestCase or TestSuite instance.

        The method optionally resolves the names relative to a given module.
        .Nr   z"calling %s returned %s, not a testz$don't know how to make test from: %sr=   )split
__import__joinr
   r1   r2   types
ModuleTyper;   r   r'   r   r   r.   FunctionTyper   r   r(   callabler)   )
r   r   r6   partsZ
parts_copyr9   partparentZinstr&   r   r   r   loadTestsFromName[   sJ    		!
	zTestLoader.loadTestsFromNamec                s)      f d d   | D }  j  |  S)zReturn a suite of all tests cases found using the given sequence
        of string specifiers. See 'loadTestsFromName()'.
        c                s"   g  |  ] }  j  |     q Sr   )rH   ).0r   )r6   r   r   r   
<listcomp>   s   	 z1TestLoader.loadTestsFromNames.<locals>.<listcomp>)r   )r   namesr6   Zsuitesr   )r6   r   r   loadTestsFromNames   s    zTestLoader.loadTestsFromNamesc             C   s\   | |  j  d d  } t t | t |    } |  j rX | j d t j |  j   n  | S)zLReturn a sorted sequence of method names found within testCaseClass
        c             S   s"   |  j  |  o! t t | |    S)N)
startswithrD   r1   )Zattrnamer-   prefixr   r   r   isTestMethod   s    z1TestLoader.getTestCaseNames.<locals>.isTestMethodkey)testMethodPrefixlistfilterr0   sortTestMethodsUsingsort	functools
cmp_to_key)r   r-   rO   ZtestFnNamesr   r   r   r*      s    	zTestLoader.getTestCaseNamesztest*.pyc             C   s  d } | d k r- |  j  d k	 r- |  j  } n | d k rH d } | } n  t j j |  } | t j k r t j j d |  n  | |  _  d } d } g  } t j j t j j |   r t j j |  } | | k rt j j t j j | d   } qny t	 |  Wn t
 k
 r&d } YnXt j | } | j d  d }	 y% t j j t j j | j   } Wn!t k
 ry | j }
 Wn t k
 rd }
 Yn X|
 rO|
 j d k rO|
 j d k	 rd } x{ | j D]m } | r| j |  rqn  | j | j j d t j j   d |  _  | j |  j | | d d  qWqn< | j t j k rst d  d  n t d	 j |   d  Yn X| r| s|  j |	  |  _  t j j |  qt j j |  n  | rt
 d
 |   n  | st |  j | |   } n  |  j  |  S)a  Find and return all test modules from the specified start
        directory, recursing into subdirectories to find them and return all
        tests found within them. Only test files that match the pattern will
        be loaded. (Using shell style pattern matching.)

        All test modules must be importable from the top level of the project.
        If the start directory is not the top level directory then the top
        level directory must be specified separately.

        If a test package name (directory with '__init__.py') matches the
        pattern then the package will be checked for a 'load_tests' function. If
        this exists then it will be called with loader, tests, pattern.

        If load_tests exists then discovery does  *not* recurse into the package,
        load_tests is responsible for loading all tests in the package.

        The pattern is deliberately not stored as a loader attribute so that
        packages can continue discovery themselves. top_level_dir is stored so
        load_tests does not need to pass this argument in to loader.discover().

        Paths are sorted before being imported to ensure reproducible execution
        order even on filesystems with non-alphabetical ordering like ext3/4.
        FNTr   z__init__.pyr<   	namespacez2Can not use builtin modules as dotted module namesz$don't know how to discover from {!r}z%Start directory is not importable: %r)!_top_level_dirr!   r"   abspathsysinsertisdirisfiler@   r?   r
   modulesr>   dirname__file__AttributeError__spec__loadersubmodule_search_locations__path__rM   r5   replacesepextend_find_testsbuiltin_module_namesr)   format _get_directory_containing_moduleremoverR   r   )r   	start_dirpatternZtop_level_dirZset_implicit_topZis_not_importableis_namespacer8   Z
the_moduleZtop_partspecr"   r   r   r   discover   sr    		(	+		zTestLoader.discoverc             C   ss   t  j | } t j j | j  } t j j |  j   j d  r_ t j j	 t j j	 |   St j j	 |  Sd  S)Nz__init__.py)
r[   r_   r!   r"   rZ   ra   basenamer   rM   r`   )r   Zmodule_namer6   	full_pathr   r   r   rm     s
    !z+TestLoader._get_directory_containing_modulec             C   s   t  t j j |   } t j j | |  j  } t j j |  sO t d   | j d  sk t d   | j	 t j j
 d  } | S)NzPath must be within the projectz..r<   )r$   r!   r"   normpathrelpathrY   isabsAssertionErrorrM   rg   rh   )r   r"   Z_relpathr   r   r   r   _get_name_from_path  s    zTestLoader._get_name_from_pathc             C   s   t  |  t j | S)N)r?   r[   r_   )r   r   r   r   r   _get_module_from_name!  s    
z TestLoader._get_module_from_namec             C   s   t  | |  S)N)r   )r   r"   ru   rp   r   r   r   _match_path%  s    zTestLoader._match_pathFc             c   s  t  t j |   } x| D]} t j j | |  } t j j |  rt j |  s^ q n  |  j | | |  sy q n  |  j	 |  } y |  j
 |  } WnT t j k
 r }	 z t | |	 |  j  VWYd d }	 ~	 Xq t | |  j  VYq Xt j j t | d |   }
 t t j j |
   } t t j j |   } | j   | j   k rt j j |  } t t j j |   } t j j |  } d } t | | | | f   n  |  j |  Vq t j j |  r | rt j j t j j | d   rq n  d } d } t | |  rk|  j	 |  } |  j
 |  } t | d d  } |  j | d d } n  | d k r| d k	 r| Vn  |  j | | d | Dd Hq y | |  | |  VWq t k
 r}	 z t | j |	 |  j  VWYd d }	 ~	 Xq Xq q Wd S)	z/Used by discovery. Yields test suites it loads.Nra   zW%r module incorrectly imported from %r. Expected %r. Is this module globally installed?z__init__.pyr/   r7   FrX   )sortedr!   listdirr"   r@   r^   VALID_MODULE_NAMEmatchr|   rz   r{   r   ZSkipTestr   r   r   rZ   r1   r$   realpathr   r`   rt   r
   r;   r]   r   rj   r4   r   r5   )r   ro   rp   rX   Zpathsr"   ru   r   r6   r:   Zmod_filer   Zfullpath_noextZ
module_dirZmod_nameZexpected_dirmsgr/   r8   packager   r   r   rj   )  s\    &"zTestLoader._find_tests)r5   
__module____qualname____doc__rQ   staticmethodr   three_way_cmprT   r   r(   r   rY   r.   r;   rH   rL   r*   rs   rm   rz   r{   r|   rj   r   r   r   r   r%   3   s    	3j
r%   c             C   s1   t    } | | _ |  | _ | r- | | _ n  | S)N)r%   rT   rQ   r   )rN   	sortUsingr   rd   r   r   r   _makeLoaderh  s    			r   c             C   s   t  | |  j |   S)N)r   r*   )r-   rN   r   r   r   r   r*   p  s    r*   r&   c             C   s   t  | | |  j |   S)N)r   r.   )r-   rN   r   r   r   r   r   	makeSuites  s    r   c             C   s   t  | | |  j |   S)N)r   r;   )r6   rN   r   r   r   r   r   findTestCasesx  s    r   )r   r!   rer[   r   rA   rV   r    r   r   r   Z
__unittestcompile
IGNORECASEr   r   r   r	   r   r$   objectr%   ZdefaultTestLoaderr   r   r*   r(   r   r   r   r   r   r   <module>   s0    3			                      usr/lib/python3.4/unittest/__pycache__/main.cpython-34.pyc                                          0100644 0000000 0000000 00000016457 13077704336 022060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T&                 @   s   d  Z  d d l Z d d l Z d d l Z d d l m Z m Z d d l m Z d Z	 d Z
 d Z d	 d
   Z d d   Z Gd d   d e  Z e Z d S)zUnittest main program    N   )loaderrunner)installHandlerTzExamples:
  %(prog)s test_module               - run tests from test_module
  %(prog)s module.TestClass          - run tests from module.TestClass
  %(prog)s module.Class.test_method  - run specified test method
aF  Examples:
  %(prog)s                           - run default set of tests
  %(prog)s MyTestSuite               - run suite 'MyTestSuite'
  %(prog)s MyTestCase.testSomething  - run MyTestCase.testSomething
  %(prog)s MyTestCase                - run all 'test*' test methods
                                       in MyTestCase
c             C   s   t  j j |   r |  j   j d  r t  j j |   r t  j j |  t  j    } t  j j |  sx | j t  j	  r| |  S| }  n  |  d  d  j
 d d  j
 d d  S|  S)Nz.py   \./)ospathisfilelowerendswithisabsrelpathgetcwd
startswithpardirreplace)nameZrel_path r   #/usr/lib/python3.4/unittest/main.py_convert_name   s    '$	&r   c             C   s   d d   |  D S)Nc             S   s   g  |  ] } t  |   q Sr   )r   ).0r   r   r   r   
<listcomp>-   s   	 z"_convert_names.<locals>.<listcomp>r   )namesr   r   r   _convert_names,   s    r   c               @   s   e  Z d  Z d Z d Z d Z d Z Z Z Z	 Z
 d Z d d d d e j d d d d d d d d  Z d d d	  Z d
 d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d d  Z d d   Z d S)TestProgramzA command-line program that runs a set of tests; this is primarily
       for making test modules conveniently executable.
    Nr   __main__Tc             C   s"  t  | t  rZ t |  |  _ xB | j d  d d   D] } t |  j |  |  _ q8 Wn	 | |  _ | d  k r{ t j } n  | |  _ | |  _	 |	 |  _
 | |  _ |
 |  _ | d  k r t j r d |  _ n	 | |  _ | |  _ | |  _ | |  _ t j j | d  |  _ |  j |  |  j   d  S)Nr   r   defaultr   )
isinstancestr
__import__modulesplitgetattrsysargvexitfailfast
catchbreak	verbositybufferwarnoptionswarningsdefaultTest
testRunner
testLoaderr   r   basenameprogName	parseArgsrunTests)selfr$   r0   r(   r1   r2   r)   r,   r*   r+   r-   r/   partr   r   r   __init__:   s*     										zTestProgram.__init__c             C   sJ   | r t  |  n  |  j d  k r/ |  j   n  |  j   t j d  d  S)N   )print_discovery_parser_initArgParsers_print_helpr'   r)   )r7   msgr   r   r   	usageExit_   s    
zTestProgram.usageExitc             O   sy   |  j  d  k rJ t |  j j    t t i |  j d 6 |  j j   n+ t |  j j    t t i |  j d 6 d  S)Nprog)	r$   r;   _main_parserZformat_helpMAIN_EXAMPLESr4   r<   
print_helpMODULE_EXAMPLES)r7   argskwargsr   r   r   r>   g   s    zTestProgram._print_helpc             C   sH  |  j    |  j d  k r t |  d k r\ | d j   d k r\ |  j | d d    d  S|  j j | d d   |   |  j s |  j g   d  Sn |  j j | d d   |   |  j r t |  j  |  _	 t
 d k r:d  |  _ q:nQ |  j d  k rd  |  _	 n6 t |  j t  r(|  j f |  _	 n t |  j  |  _	 |  j   d  S)Nr   discoverr:   r   )r=   r$   lenr   _do_discoveryrB   
parse_argstestsr   	testNames__name__r0   r!   r"   listcreateTests)r7   r(   r   r   r   r5   p   s(    
(		zTestProgram.parseArgsc             C   sL   |  j  d  k r* |  j j |  j  |  _ n |  j j |  j  |  j  |  _ d  S)N)rM   r2   ZloadTestsFromModuler$   testZloadTestsFromNames)r7   r   r   r   rP      s    zTestProgram.createTestsc             C   s4   |  j    } |  j |  |  _ |  j |  |  _ d  S)N)_getParentArgParser_getMainArgParserrB   _getDiscoveryArgParserr<   )r7   Zparent_parserr   r   r   r=      s    zTestProgram._initArgParsersc             C   s  t  j d d  } | j d d d d d d d	 d
 d d | j d d d d d d d	 d d d |  j d  k r | j d d d d d d d d d |  _ n  |  j d  k r | j d d d d d d d d d |  _ n  |  j d  k r| j d d d d d d d d d |  _ n  | S)NZadd_helpFz-vz	--verbosedestr,   actionZstore_constZconstr:   helpzVerbose outputz-qz--quietr   zQuiet outputz-fz
--failfastr*   
store_truezStop on first fail or errorz-cz--catchr+   z'Catch ctrl-C and display results so farz-bz--bufferr-   z%Buffer stdout and stderr during tests)argparseArgumentParseradd_argumentr*   r+   r-   )r7   parserr   r   r   rR      s.    zTestProgram._getParentArgParserc             C   sJ   t  j d | g  } |  j | _ |  j | _ | j d d d d d | S)NparentsrL   nargs*rW   z?a list of any number of test modules, classes and test methods.)rY   rZ   r4   rA   r>   rD   r[   )r7   parentr\   r   r   r   rS      s    zTestProgram._getMainArgParserc          	   C   s   t  j d | g  } d |  j | _ d | _ | j d d d d d d	 | j d
 d d d d d | j d d d d d d x3 d D]+ } | j | d d d t  j d t  j q W| S)Nr]   z%s discoverzcFor test discovery all test modules must be importable from the top level directory of the project.z-sz--start-directoryrU   startrW   z*Directory to start discovery ('.' default)z-pz	--patternpatternz+Pattern to match tests ('test*.py' default)z-tz--top-level-directorytopz<Top level directory of project (defaults to start directory)r^   ?r    )zstartzpatternztop)rY   rZ   r4   rA   Zepilogr[   ZSUPPRESS)r7   r`   r\   argr   r   r   rT      s    		z"TestProgram._getDiscoveryArgParserc             C   s   d |  _  d |  _ d  |  _ | d  k	 rY |  j d  k rC |  j   n  |  j j | |   n  | d  k rn |  j n |   } | j |  j  |  j |  j  |  _ d  S)Nr   ztest*.py)	ra   rb   rc   r<   r=   rK   r2   rH   rQ   )r7   r(   ZLoaderr   r   r   r   rJ      s    			zTestProgram._do_discoveryc             C   s   |  j  r t   n  |  j d  k r1 t j |  _ n  t |  j t  r y4 |  j d |  j d |  j d |  j	 d |  j
  } Wq t k
 r |  j   } Yq Xn	 |  j } | j |  j  |  _ |  j r t j |  j j    n  d  S)Nr,   r*   r-   r/   )r+   r   r1   r   ZTextTestRunnerr!   typer,   r*   r-   r/   	TypeErrorZrunrQ   resultr)   r'   ZwasSuccessful)r7   r1   r   r   r   r6      s     	
				zTestProgram.runTests)rN   
__module____qualname____doc__r$   r,   r*   r+   r-   r4   r/   r<   r   ZdefaultTestLoaderr9   r@   r>   r5   rP   r=   rR   rS   rT   rJ   r6   r   r   r   r   r   0   s&   		"	r   )rk   r'   rY   r    r   r   Zsignalsr   Z
__unittestrC   rE   r   r   objectr   mainr   r   r   r   <module>   s   	                                                                                                                                                                                                                 usr/lib/python3.4/unittest/__pycache__/mock.cpython-34.pyc                                          0100644 0000000 0000000 00000175674 13077704336 022074  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T)                @   s  d  d d d d d d d d d	 d
 d d f Z  d Z d d l Z d d l Z d d l Z d d l m Z m Z e f Z	 d e j
 k r d d l Z e e j j f Z	 n  d Z e Z d d   Z d d   Z Gd d   d e  Z e e j  e f Z d d   Z d d d  Z d d   Z d  d!   Z d" d#   Z d$ d%   Z d d& d'  Z d( d)   Z  d* d+   Z! Gd, d-   d- e  Z" Gd. d/   d/ e  Z# e#   Z$ e$ j% Z% e$ j& Z' e$ j( Z) d0 d1   Z* e+ d2 d3 d4 d5 d6 d7 d8 d9 g  Z, d: d;   Z- Gd< d=   d= e.  Z/ d> d?   Z0 Gd@ dA   dA e  Z1 GdB dC   dC e  Z2 GdD d	   d	 e2  Z3 dE dF   Z4 GdG dH   dH e2  Z5 GdI d    d  e5 e3  Z6 dJ dK   Z7 dL dM   Z8 dN dO   Z9 GdP dQ   dQ e  Z: dR dS   Z; e% d d d d d dT dU  Z< d d d d d dV dW  Z= e% d d d d d dX d  Z> GdY dZ   dZ e  Z? d[ d\   Z@ d] d^   ZA e< e> _ e? e> _B e= e> _C eA e> _D d_ e> _E d` ZF da ZG db jH dc dd   eG jI   D  ZJ db jH de dd   eG jI   D  ZK e+ df dd   dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw g D  ZL dx dy   ZM e+ dz dd   db jH eF eG eJ eK g  jI   D  ZN eN eL BZO e+ d{ d| d} d~ d d d g  ZP i d d   d 6d d   d 6d d   d 6ZQ i eR d 6eR d 6eR d 6eR d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6ZS d d   ZT d d   ZU d d   ZV i eT d 6eU d 6eV d 6ZW d d   ZX Gd d   d e  ZY Gd d
   d
 eY e3  ZZ Gd d   d eY e6  Z[ Gd d   d e  Z\ Gd d   d e  Z] e]   Z^ d d   Z_ Gd d   d e`  Za ea d d  Zb d d d d d d  Zc d d   Zd d d   Ze Gd d   d e  Zf e ec  e e^ jg  f Zh e e^ jg ji  f Zj d ak d d   Zl d d d d  Zm Gd d   d e6  Zn d S)Mock	MagicMockpatchsentinelDEFAULTANYcallcreate_autospec
FILTER_DIRNonCallableMockNonCallableMagicMock	mock_openPropertyMockz1.0    N)wrapspartialjavaTc             C   s   t  t |   t  S)N)
issubclasstyper
   )obj r   #/usr/lib/python3.4/unittest/mock.py_is_instance_mock.   s    r   c             C   s+   t  |  t  p* t  |  t  o* t |  t  S)N)
isinstanceBaseExceptionsr   r   )r   r   r   r   _is_exception4   s    r   c               @   s   e  Z d  Z d g Z d S)_slottedaN)__name__
__module____qualname__	__slots__r   r   r   r   r   ;   s   r   c             C   s   t  |  t  rE | rE y |  j }  Wn t k
 r; d SYn Xd } n8 t  |  t  s} y |  j }  Wq} t k
 ry d SYq} Xn  | r t |  d  } n |  } y |  t j |  f SWn t	 k
 r d SYn Xd S)z
    Given an arbitrary, possibly callable object, try to create a suitable
    signature object.
    Return a (reduced func, signature) tuple, or None.
    NT)
r   r   __init__AttributeErrorFunctionTypes__call__r   inspectZ	signature
ValueError)funcZas_instanceZeat_selfZsig_funcr   r   r   _get_signature_objectE   s$    		r(   Fc                s`   t  |  | |      d  k r" d  S  \ }      f d d   } t |  |  | t |  _ d  S)Nc                s     j  | |   d  S)N)bind)
_mock_selfargskwargs)sigr   r   checksigj   s    z"_check_signature.<locals>.checksig)r(   _copy_func_detailsr   _mock_check_sig)r'   mock	skipfirstinstancer.   r   )r-   r   _check_signaturee   s    r4   c          #   C   s   |  j  | _  |  j | _ y |  j | _ Wn t k
 r< Yn Xy |  j | _ Wn t k
 ra Yn Xy |  j | _ Wn t k
 r Yn Xy |  j | _ Wn t k
 r Yn Xd  S)N)r   __doc____text_signature__r"   r   __defaults____kwdefaults__)r'   funcopyr   r   r   r/   p   s$    r/   c             C   s3   t  |  t  r d St |  d d   d  k	 r/ d Sd S)NTr$   F)r   r   getattr)r   r   r   r   	_callable   s
    r;   c             C   s   t  |   t t f k S)N)r   listtuple)r   r   r   r   _is_list   s    r>   c             C   s`   t  |  t  s% t |  d d  d k	 Sx4 |  f |  j D]" } | j j d  d k	 r6 d Sq6 Wd S)ztGiven an object, return True if the object is callable.
    For classes, return True if instances would be callable.r$   NTF)r   r   r:   __mro____dict__get)r   baser   r   r   _instance_callable   s    rC   c                s   t  |  s d  St | t  } t | | |  } | d  k rA d  S| \ }     f d d   } t | |  | j } | j   s d } n  i | d 6|  d 6} d | }	 t |	 |  | | }
 t |
 |   |
 S)Nc                 s     j  |  |   d  S)N)r)   )r+   r,   )r-   r   r   r.      s    z _set_signature.<locals>.checksigr9   Z
_checksig_r1   zYdef %s(*args, **kwargs):
    _checksig_(*args, **kwargs)
    return mock(*args, **kwargs))	r;   r   r   r(   r/   r   isidentifierexec_setup_func)r1   originalr3   r2   resultr'   r.   namecontextsrcr9   r   )r-   r   _set_signature   s$    		

rL   c                s     _  t   s d  S f d d   }  f d d   }  f d d   }  f d d   }    f d	 d
   } d   _ d   _ d    _ t     _ t     _ t     _  j	   _	  j
   _
  j   _ |   _ |   _ |   _ |   _ |   _    _ d  S)Nc                 s     j  |  |   S)N)assert_called_with)r+   r,   )r1   r   r   rM      s    z'_setup_func.<locals>.assert_called_withc                 s     j  |  |   S)N)assert_called_once_with)r+   r,   )r1   r   r   rN      s    z,_setup_func.<locals>.assert_called_once_withc                 s     j  |  |   S)N)assert_has_calls)r+   r,   )r1   r   r   rO      s    z%_setup_func.<locals>.assert_has_callsc                 s     j  |  |   S)N)assert_any_call)r+   r,   )r1   r   r   rP      s    z$_setup_func.<locals>.assert_any_callc                 sT   t      _ t      _  j     j }  t |   rP |   k	 rP |  j   n  d  S)N)	_CallListmethod_calls
mock_calls
reset_mockreturn_valuer   )ret)r9   r1   r   r   rT      s    
	z_setup_func.<locals>.reset_mockFr   )r1   r   called
call_count	call_argsrQ   call_args_listrR   rS   rU   side_effect_mock_childrenrM   rN   rO   rP   rT   _mock_delegate)r9   r1   rM   rN   rO   rP   rT   r   )r9   r1   r   rF      s.    									rF   c             C   s   d |  d d  |  k S)Nz__%s__   r   )rI   r   r   r   	_is_magic   s    r`   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)_SentinelObjectz!A unique, named, sentinel object.c             C   s   | |  _  d  S)N)rI   )selfrI   r   r   r   r!      s    z_SentinelObject.__init__c             C   s   d |  j  S)Nzsentinel.%s)rI   )rb   r   r   r   __repr__   s    z_SentinelObject.__repr__N)r   r   r   r5   r!   rc   r   r   r   r   ra      s   ra   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)	_SentinelzAAccess attributes to return a named object, usable as a sentinel.c             C   s   i  |  _  d  S)N)
_sentinels)rb   r   r   r   r!      s    z_Sentinel.__init__c             C   s.   | d k r t   n  |  j j | t |   S)N	__bases__)r"   re   
setdefaultra   )rb   rI   r   r   r   __getattr__   s    	z_Sentinel.__getattr__N)r   r   r   r5   r!   rh   r   r   r   r   rd      s   rd   c             C   s2   t  |   t t t t f k r. t  |   |   S|  S)N)r   dictr<   r=   set)valuer   r   r   _copy  s    rl   rU   _mock_return_valuer[   _mock_side_effect_mock_parent_mock_new_parent
_mock_name_mock_new_namec             C   sH   t  j |   d |  } |  | d d  } |  | d d  } t | |  S)NZ_mock_c             S   s/   |  j  } | d  k r" t |  |  St | |  S)N)r]   r:   )rb   rI   	_the_namer-   r   r   r   _get  s    	z"_delegating_property.<locals>._getc             S   s9   |  j  } | d  k r% | |  j | <n t | | |  d  S)N)r]   r@   setattr)rb   rk   rI   rs   r-   r   r   r   _set#  s    	z"_delegating_property.<locals>._set)_allowed_namesaddproperty)rI   rs   rt   rv   r   r   r   _delegating_property  s
    
rz   c               @   s(   e  Z d  Z d d   Z d d   Z d S)rQ   c             C   s   t  | t  s t j |  |  St |  } t |   } | | k rG d SxC t d | | d  D]* } |  | | |  } | | k r_ d Sq_ Wd S)NFr      T)r   r<   __contains__lenrange)rb   rk   Z	len_valueZlen_selfiZsub_listr   r   r   r|   0  s    z_CallList.__contains__c             C   s   t  j t |    S)N)pprintZpformatr<   )rb   r   r   r   rc   >  s    z_CallList.__repr__N)r   r   r   r|   rc   r   r   r   r   rQ   .  s   rQ   c             C   s   t  |  s d S| j s@ | j s@ | j d  k	 s@ | j d  k	 rD d S|  } x) | d  k	 ru | | k ri d S| j } qM W| r |  | _ | | _ n  | r |  | _ | | _ n  d S)NFT)r   rq   rr   ro   rp   )parentrk   rI   new_name_parentr   r   r   _check_and_set_parentB  s$    		r   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)	_MockIterc             C   s   t  |  |  _ d  S)N)iterr   )rb   r   r   r   r   r!   \  s    z_MockIter.__init__c             C   s   |  S)Nr   )rb   r   r   r   __iter__^  s    z_MockIter.__iter__c             C   s   t  |  j  S)N)nextr   )rb   r   r   r   __next__`  s    z_MockIter.__next__N)r   r   r   r!   r   r   r   r   r   r   r   [  s   r   c               @   s(   e  Z d  Z e Z d Z d d   Z d S)BaseNc             O   s   d  S)Nr   )rb   r+   r,   r   r   r   r!   f  s    zBase.__init__)r   r   r   r   rm   rn   r!   r   r   r   r   r   c  s   r   c               @   s  e  Z d  Z d Z d d   Z d d d d d d d d d d d d 
 Z d	 d
   Z d d d  Z d d d d  Z d d   Z	 d d   Z
 d Z e e	 e
 e  Z e d d    Z e d  Z e d  Z e d  Z e d  Z e d  Z d d   Z d d   Z e e e  Z d d    Z d! d"   Z d# d$   Z d% d&   Z d' d(   Z d) d*   Z d+ d,   Z d- d.   Z d/ d0   Z  d1 d2   Z! d3 d4   Z" d5 d6   Z# d d7 d8  Z$ d9 d:   Z% d; d<   Z& d S)=r
   z A non-callable version of `Mock`c             O   s5   t  |  j |  f i |  j d 6 } t j |  } | S)Nr5   )r   r   r5   object__new__)clsr+   kwnewr3   r   r   r   r   n  s    "zNonCallableMock.__new__N Fc             K   s4  | d  k r | } n  |  j  } | | d <| | d <| | d <| | d <| d  k	 ra | } d } n  |
 d  k r| | d  k	 }
 n  |  j | | |	 |
  i  | d <| | d <d  | d <d	 | d
 <d  | d <d | d <t   | d <t   | d <t   | d <| r|  j |   n  t t |   j | | | | | |  d  S)Nro   rq   rr   rp   Tr\   _mock_wrapsr]   FZ_mock_calledZ_mock_call_argsr   Z_mock_call_countZ_mock_call_args_listZ_mock_mock_callsrR   )r@   _mock_add_specrQ   configure_mock_safe_superr
   r!   )rb   specr   rI   spec_setr   _spec_state	_new_name_new_parent_spec_as_instance	_eat_selfr,   r@   r   r   r   r!   w  s6    		



	





zNonCallableMock.__init__c             C   s8   d | _  d | _ d | _ d | _ t |  | |  d S)z
        Attach a mock as an attribute of this one, replacing its name and
        parent. Calls to the attached mock will be recorded in the
        `method_calls` and `mock_calls` attributes of this one.Nr   )ro   rp   rq   rr   ru   )rb   r1   	attributer   r   r   attach_mock  s
    				zNonCallableMock.attach_mockc             C   s   |  j  | |  d S)zAdd a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set.N)r   )rb   r   r   r   r   r   mock_add_spec  s    zNonCallableMock.mock_add_specc       	      C   s   d  } d  } | d  k	 rz t  |  rz t | t  r= | } n t |  } t | | |  } | oh | d } t |  } n  |  j } | | d <| | d <| | d <| | d <d  S)Nr{   _spec_class	_spec_set_spec_signature_mock_methods)r>   r   r   
_get_classr(   dirr@   )	rb   r   r   r   r   r   r   Zresr@   r   r   r   r     s    		


zNonCallableMock._mock_add_specc             C   s[   |  j  } |  j d  k	 r' |  j j } n  | t k rW |  j d |  d d  } | |  _ n  | S)Nr   r   z())rm   r]   rU   r   _get_child_mock)rb   rV   r   r   r   Z__get_return_value  s    		z"NonCallableMock.__get_return_valuec             C   s>   |  j  d  k	 r | |  j  _ n | |  _ t |  | d  d  d  S)Nz())r]   rU   rm   r   )rb   rk   r   r   r   Z__set_return_value  s    	z"NonCallableMock.__set_return_valuez1The value to be returned when the mock is called.c             C   s    |  j  d  k r t |   S|  j  S)N)r   r   )rb   r   r   r   	__class__  s    
zNonCallableMock.__class__rW   rX   rY   rZ   rS   c             C   sj   |  j  } | d  k r |  j S| j } | d  k	 rf t |  rf t | t  rf t |  } | | _ n  | S)N)r]   rn   r[   callabler   r   )rb   	delegatedZsfr   r   r   Z__get_side_effect  s    		)z!NonCallableMock.__get_side_effectc             C   s:   t  |  } |  j } | d  k r- | |  _ n	 | | _ d  S)N)	_try_iterr]   rn   r[   )rb   rk   r   r   r   r   Z__set_side_effect  s
    	z!NonCallableMock.__set_side_effectc             C   s   d |  _  d |  _ d |  _ t   |  _ t   |  _ t   |  _ x6 |  j j   D]% } t	 | t
  rj qO n  | j   qO W|  j } t |  r | |  k	 r | j   n  d S)z-Restore the mock object to its initial state.FNr   )rW   rY   rX   rQ   rS   rZ   rR   r\   valuesr   
_SpecStaterT   rm   r   )rb   ZchildrV   r   r   r   rT   
  s    				zNonCallableMock.reset_mockc             K   s   x} t  | j   d d d   D]] \ } } | j d  } | j   } |  } x | D] } t | |  } qS Wt | | |  q Wd S)aZ  Set attributes on the mock through keyword arguments.

        Attributes plus return values and side effects can be set on child
        mocks using standard dot notation and unpacking a dictionary in the
        method call:

        >>> attrs = {'method.return_value': 3, 'other.side_effect': KeyError}
        >>> mock.configure_mock(**attrs)keyc             S   s   |  d j  d  S)Nr   .)count)entryr   r   r   <lambda>*  s    z0NonCallableMock.configure_mock.<locals>.<lambda>r   N)sorteditemssplitpopr:   ru   )rb   r,   argvalr+   finalr   r   r   r   r   r     s    	zNonCallableMock.configure_mockc             C   s]  | d k r t  |   n[ |  j d  k	 r[ | |  j k sE | t k rv t  d |   qv n t |  rv t  |   n  |  j j |  } | t k r t  |   n | d  k rd  } |  j d  k	 r t |  j |  } n  |  j	 d |  d | d | d | d |   } | |  j | <nF t
 | t  rYt | j | j | j | j | j  } | |  j | <n  | S)Nr   zMock object has no attribute %rr   rI   r   r   r   )r"   r   _all_magicsr`   r\   rA   _deletedr   r:   r   r   r   r   r   r   r3   r   rI   )rb   rI   rH   r   r   r   r   rh   3  s0    		zNonCallableMock.__getattr__c       
      C   s  |  j  g } |  j } |  } d } | d g k r9 d } n  t   } xz | d  k	 r | } | j | j  |  d } | j  d k r d } n  | j } t |  | k r Pn  | j t |   qE Wt t |   } | j p d } t	 |  d k r| d d k r| d 7} qn  | | d <d j
 |  } d } | d k rJd	 | } n  d }	 |  j d  k	 rd
 }	 |  j rwd }	 n  |	 |  j j }	 n  d t |   j | |	 t |   f S)Nr   ()r   r1   r{   ().r   mock.z name=%rz spec=%rz spec_set=%rz<%s%s%s id='%s'>)r   r   )zmockr   )rr   rp   rj   appendidrx   r<   reversedrq   r}   joinr   r   r   r   )
rb   Z
_name_listr   lastdotseenZ_firstrI   Zname_stringZspec_stringr   r   r   rc   V  sL    					
		zNonCallableMock.__repr__c             C   s   t  s t j |   S|  j p g  } t t |    } t |  j  } d d   | D } d d   | D } t t	 | | | t |  j
    S)z8Filter the output of `dir(mock)` to only useful members.c             S   s%   g  |  ] } | j  d   s |  q S)_)
startswith).0er   r   r   
<listcomp>  s   	 z+NonCallableMock.__dir__.<locals>.<listcomp>c             S   s2   g  |  ]( } | j  d   s( t |  r |  q S)r   )r   r`   )r   r   r   r   r   r     s   	 )r	   r   __dir__r   r   r   r<   r@   r   rj   r\   )rb   ZextrasZ	from_typeZ	from_dictr   r   r   r     s    zNonCallableMock.__dir__c                s  | t  k r t j  | |  S j rh  j d  k	 rh |  j k rh |  j k rh t d |   n"| t k r d | } t |   n | t k rL j d  k	 r |  j k r t d |   n  t	 |  st
 t   | t | |   |      f d d   } qt  | d  |  t
 t   | |  |  j | <n> | d k re|  _ d  St  | | |  r|  j | <n  t j  | |  S)Nz!Mock object has no attribute '%s'z.Attempting to set unsupported magic method %r.c                 s      |  |  S)Nr   )r+   r   )rG   rb   r   r   r     s    z-NonCallableMock.__setattr__.<locals>.<lambda>r   )rw   r   __setattr__r   r   r@   r"   _unsupported_magicsr   r   ru   r   _get_methodr   r\   r   )rb   rI   rk   msgr   )rG   rb   r   r     s2    
	zNonCallableMock.__setattr__c             C   s   | t  k rJ | t |   j k rJ t t |   |  | |  j k rJ d  Sn  | |  j k rl t j |  |  n  |  j j | t  } | t	 k r t
 |   n  | t k	 r |  j | =n  t	 |  j | <d  S)N)r   r   r@   delattrr   __delattr__r\   rA   _missingr   r"   )rb   rI   r   r   r   r   r     s    !zNonCallableMock.__delattr__c             C   s   |  j  p d } t | | |  S)Nr1   )rq   _format_call_signature)rb   r+   r,   rI   r   r   r   _format_mock_call_signature  s    z+NonCallableMock._format_mock_call_signaturec             C   sc   d } |  j  | |  } |  j } t |  d k rF | d d   } n  |  j  |   } | | | f S)Nz!Expected call: %s
Actual call: %s   r{   )r   rY   r}   )rb   r+   r,   messageexpected_stringrY   Zactual_stringr   r   r   _format_mock_failure_message  s    	z,NonCallableMock._format_mock_failure_messagec             C   s   |  j  } | d k	 r t |  d k r< d } | \ } } n | \ } } } y | | j | |   f SWq t k
 r } z | j d  SWYd d } ~ Xq Xn | Sd S)a  
        Given a call (or simply a (args, kwargs) tuple), return a
        comparison key suitable for matching with other calls.
        This is a best effort method which relies on the spec's signature,
        if available, or falls back on the arguments themselves.
        Nr^   r   )r   r}   r)   	TypeErrorwith_traceback)rb   _callr-   rI   r+   r,   r   r   r   r   _call_matcher  s    	#zNonCallableMock._call_matcherc                s   |    j  d k r=  j     } t d | f   n      f d d   }  j    f  }  j  j   } | | k r t | t  r | n d } t |    |  n  d S)zassert that the mock was called with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock.NzExpected call: %s
Not calledc                 s    j      }  |  S)N)r   )r   )r+   r,   rb   r   r   _error_message  s    z:NonCallableMock.assert_called_with.<locals>._error_message)rY   r   AssertionErrorr   r   	Exception)r*   r+   r,   expectedr   actualcauser   )r+   r,   rb   r   rM     s    z"NonCallableMock.assert_called_withc             O   sP   |  } | j  d k s@ d | j p$ d | j  f } t |   n  | j | |   S)zVassert that the mock was called exactly once and with the specified
        arguments.r{   z1Expected '%s' to be called once. Called %s times.r1   )rX   rq   r   rM   )r*   r+   r,   rb   r   r   r   r   rN     s    z'NonCallableMock.assert_called_once_withc                s
    f d d   | D } t  | t  r. | n d } t   f d d     j D  } | s | | k r t d |   j f  |  n  d St |  } g  } xA | D]9 } y | j |  Wq t k
 r | j |  Yq Xq W| rt d t	 |  f  |  n  d S)a  assert the mock has been called with the specified calls.
        The `mock_calls` list is checked for the calls.

        If `any_order` is False (the default) then the calls must be
        sequential. There can be extra calls before or after the
        specified calls.

        If `any_order` is True then the calls can be in any order, but
        they must all appear in `mock_calls`.c                s   g  |  ] }   j  |   q Sr   )r   )r   c)rb   r   r   r     s   	 z4NonCallableMock.assert_has_calls.<locals>.<listcomp>Nc             3   s   |  ] }   j  |  Vq d  S)N)r   )r   r   )rb   r   r   	<genexpr>  s    z3NonCallableMock.assert_has_calls.<locals>.<genexpr>z(Calls not found.
Expected: %r
Actual: %rz%r not all found in call list)
r   r   rQ   rS   r   r<   remover&   r   r=   )rb   ZcallsZ	any_orderr   r   Z	all_callsZ	not_foundZkallr   )rb   r   rO     s*    
"	z NonCallableMock.assert_has_callsc                s     j  | | f  }   f d d     j D } | | k r t | t  rR | n d }   j | |  } t d |  |  n  d S)zassert the mock has been called with the specified arguments.

        The assert passes if the mock has *ever* been called, unlike
        `assert_called_with` and `assert_called_once_with` that only pass if
        the call is the most recent one.c                s   g  |  ] }   j  |   q Sr   )r   )r   r   )rb   r   r   r   ;  s   	 z3NonCallableMock.assert_any_call.<locals>.<listcomp>Nz%s call not found)r   rZ   r   r   r   r   )rb   r+   r,   r   r   r   r   r   )rb   r   rP   4  s    
zNonCallableMock.assert_any_callc             K   se   t  |   } t | t  sN t | t  r3 t } q[ t | t  r[ t } q[ n | j d } | |   S)aP  Create the child mocks for attributes and return value.
        By default child mocks will be the same type as the parent.
        Subclasses of Mock may want to override this to customize the way
        child mocks are made.

        For non-callable mocks the callable variant will be used (rather than
        any custom subclass).r{   )r   r   CallableMixinr   r   r
   r   r?   )rb   r   _typeklassr   r   r   r   D  s    	zNonCallableMock._get_child_mock)'r   r   r   r5   r   r!   r   r   r   Z"_NonCallableMock__get_return_valueZ"_NonCallableMock__set_return_valueZ"_NonCallableMock__return_value_docry   rU   r   rz   rW   rX   rY   rZ   rS   Z!_NonCallableMock__get_side_effectZ!_NonCallableMock__set_side_effectr[   rT   r   rh   rc   r   r   r   r   r   r   rM   rN   rO   rP   r   r   r   r   r   r
   k  sL   
(			
#2"
#c             C   s[   |  d  k r |  St  |   r  |  St |   r0 |  Sy t |   SWn t k
 rV |  SYn Xd  S)N)r   r;   r   r   )r   r   r   r   r   X  s    r   c               @   s^   e  Z d  Z d d e d d d d d d d d d 
 Z d d   Z d d   Z d	 d
   Z d S)r   Nr   c          
   K   sH   | |  j  d <t t |   j | | | | | | |	 |
 |  | |  _ d  S)Nrm   )r@   r   r   r!   r[   )rb   r   r[   rU   r   rI   r   r   r   r   r   r,   r   r   r   r!   j  s
    zCallableMixin.__init__c             O   s   d  S)Nr   )rb   r+   r,   r   r   r   r0   w  s    zCallableMixin._mock_check_sigc             O   s    |  j  | |   |  j | |   S)N)r0   
_mock_call)r*   r+   r,   r   r   r   r$   |  s    zCallableMixin.__call__c             O   s  |  } d | _  | j d 7_ | j } | j } t | | f d d } | | _ | j j |  | j j t d | | f   t	   } | d k } | j
 d  k	 }	 | j }
 x#| d  k	 rt | | | f  } | j r!d } | r d } n  d } | j d k rd } n  | j | | } n  |	 r| |
 k r<| } n t |
 | | f  } | j j |  | j
 d  k	 }	 |	 r| j d |
 }
 qn  | j j |  | j } t |  } | | k rPn  | j |  q Wt } | j } | d  k	 r^t |  r|  n  t |  sLt |  } t |  r0|  n  | t k rH| j } n  | S| | |   } n  | j d  k	 r| j t k r| j | |   S| t k r| j } n  | S)NTr{   twor   z()r   F)rW   rX   rr   rp   _CallrY   rZ   r   rS   rj   ro   rq   rR   r   rx   r   r[   r   r;   r   rU   r   rm   )r*   r+   r,   rb   r   r   r   r   Zskip_next_dotZdo_method_callsrI   Zthis_mock_callr   Zthis_method_callZ_new_parent_idret_valZeffectrH   r   r   r   r     sp    														zCallableMixin._mock_call)r   r   r   r   r!   r0   r$   r   r   r   r   r   r   h  s   	r   c               @   s   e  Z d  Z d Z d S)r   a	  
    Create a new `Mock` object. `Mock` takes several optional arguments
    that specify the behaviour of the Mock object:

    * `spec`: This can be either a list of strings or an existing object (a
      class or instance) that acts as the specification for the mock object. If
      you pass in an object then a list of strings is formed by calling dir on
      the object (excluding unsupported magic attributes and methods). Accessing
      any attribute not in this list will raise an `AttributeError`.

      If `spec` is an object (rather than a list of strings) then
      `mock.__class__` returns the class of the spec object. This allows mocks
      to pass `isinstance` tests.

    * `spec_set`: A stricter variant of `spec`. If used, attempting to *set*
      or get an attribute on the mock that isn't on the object passed as
      `spec_set` will raise an `AttributeError`.

    * `side_effect`: A function to be called whenever the Mock is called. See
      the `side_effect` attribute. Useful for raising exceptions or
      dynamically changing return values. The function is called with the same
      arguments as the mock, and unless it returns `DEFAULT`, the return
      value of this function is used as the return value.

      If `side_effect` is an iterable then each call to the mock will return
      the next value from the iterable. If any of the members of the iterable
      are exceptions they will be raised instead of returned.

    * `return_value`: The value returned when the mock is called. By default
      this is a new Mock (created on first access). See the
      `return_value` attribute.

    * `wraps`: Item for the mock object to wrap. If `wraps` is not None then
      calling the Mock will pass the call through to the wrapped object
      (returning the real result). Attribute access on the mock will return a
      Mock object that wraps the corresponding attribute of the wrapped object
      (so attempting to access an attribute that doesn't exist will raise an
      `AttributeError`).

      If the mock has an explicit `return_value` set then calls are not passed
      to the wrapped object and the `return_value` is returned instead.

    * `name`: If the mock has a name then it will be used in the repr of the
      mock. This can be useful for debugging. The name is propagated to child
      mocks.

    Mocks can also be called with arbitrary keyword arguments. These will be
    used to set attributes on the mock after it is created.
    N)r   r   r   r5   r   r   r   r   r     s   1c             C   sA   y t  |  |  SWn) t k
 r< t |  t  |  |  SYn Xd  S)N)r:   r"   
__import__)thingcompimport_pathr   r   r   _dot_lookup  s
    
r   c             C   s_   |  j  d  } | j d  } t |  } x. | D]& } | d | 7} t | | |  } q1 W| S)Nr   r   z.%s)r   r   r   r   )targetZ
componentsr   r   r   r   r   r   	_importer
  s    r   c             C   s   t  |  d  S)Nis_local)hasattr)patcherr   r   r   _is_started  s    r   c               @   s   e  Z d  Z d Z g  Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d S)_patchNc
       
      C   s   | d  k	 rE | t  k	 r' t d   n  | d  k	 rE t d   qE n  | |  _ | |  _ | |  _ | |  _ | |  _ | |  _ d |  _ | |  _	 | |  _
 |	 |  _ g  |  _ d  S)Nz,Cannot use 'new' and 'new_callable' togetherz1Cannot use 'autospec' and 'new_callable' togetherF)r   r&   getterr   r   new_callabler   createZ	has_localr   autospecr,   additional_patchers)
rb   r   r   r   r   r   r   r   r   r,   r   r   r   r!     s$    										z_patch.__init__c          
   C   sh   t  |  j |  j |  j |  j |  j |  j |  j |  j |  j	 	 } |  j
 | _
 d d   |  j D | _ | S)Nc             S   s   g  |  ] } | j     q Sr   )copy)r   pr   r   r   r   B  s   	 z_patch.copy.<locals>.<listcomp>)r   r   r   r   r   r   r   r   r   r,   attribute_namer   )rb   r   r   r   r   r   :  s    z_patch.copyc             C   s)   t  | t  r |  j |  S|  j |  S)N)r   r   decorate_classdecorate_callable)rb   r'   r   r   r   r$   G  s    z_patch.__call__c             C   sy   xr t  |  D]d } | j t j  s+ q n  t | |  } t | d  sO q n  |  j   } t | | | |   q W| S)Nr$   )r   r   r   TEST_PREFIXr:   r   r   ru   )rb   r   attr
attr_valuer   r   r   r   r   M  s    z_patch.decorate_classc                sT   t    d  r#   j j |     St       f d d     |  g  _  S)N	patchingsc                 s  g  } g  } t    } z y xh  j D]] } | j   } | j |  | j d  k	 rc | j |  q% | j t k r% | j |  q% q% W|  t  |  7}    |  |   SWn? | | k r t |  r | j |  n  t	 j
   }   Yn XWd  x! t |  D] } | j |   q WXd  S)N)r=   r  	__enter__r   r   updater   r   r   sysexc_infor   __exit__)r+   Zkeywargs
extra_argsZentered_patchersr  patchingr   )r'   patchedr   r   r  `  s*    	z)_patch.decorate_callable.<locals>.patched)r   r  r   r   )rb   r'   r   )r'   r  r   r   [  s    !z_patch.decorate_callablec             C   s   |  j    } |  j } t } d } y | j | } Wn* t t f k
 r^ t | | t  } Yn Xd } |  j r | t k r t d | | f   n  | | f S)NFTz!%s does not have the attribute %r)r   r   r   r@   r"   KeyErrorr:   r   )rb   r   rI   rG   localr   r   r   get_original  s    	z_patch.get_originalc             C   s  |  j  |  j |  j } } } |  j |  j } } |  j } |  j   |  _ | d k r] d } n  | d k rr d } n  | d k r d } n  | d k	 r | d k	 r t d   n  | d k	 s | d k	 r | d k r t d   n  |  j	   \ } } | t
 k r\| d k r\d }	 | d k rA| } | d k r| } d } qn? | d k	 rk| d k r| } d } qn | d k r| } n  | d k	 s| d k	 r| t
 k rt d   n  t | t  rd }	 qn  t }
 i  } | d k	 r| }
 nm | d k	 s| d k	 r\| } | d k	 r"| } n  t |  r=d | k } n t |  } | r\t }
 q\n  | d k	 ru| | d <n  | d k	 r| | d	 <n  t |
 t  rt |
 t  r|  j r|  j | d
 <n  | j |  |
 |   } |	 rt |  r| } | d k	 r| } n  t |  r.t |  r.t }
 n  | j d
  |
 d | d d |  | _ qn | d k	 r| t
 k	 rt d   n  | t
 k rt d   n  t |  } | d k r| } n  t | d	 | d |  j | } n | rt d   n  | } | |  _ | |  _ t |  j |  j |  |  j d k	 ri  } |  j  t
 k rW| | |  j <n  x< |  j D]1 } | j    } | j  t
 k ra| j |  qaqaW| S| S)zPerform the patch.FNzCan't specify spec and autospecTz6Can't provide explicit spec_set *and* spec or autospecz!Can't use 'spec' with create=Truer$   r   r   rI   r   r   z()zBautospec creates the mock for you. Can't specify autospec and new.z%Can't use 'autospec' with create=True_namez.Can't pass kwargs to a mock we aren't creating)TN)!r   r   r   r   r,   r   r   r   r   r  r   r   r   r   r>   r   r   r   r
   r   r  r   rC   r   rU   boolr   temp_originalr   ru   r   r   r  )rb   r   r   r   r   r,   r   rG   r  ZinheritKlass_kwargsZ	this_specZnot_callableZnew_attrr
  r  r   r   r   r   r    s    												z_patch.__enter__c             G   s   t  |   s t d   n  |  j rO |  j t k	 rO t |  j |  j |  j  nO t |  j |  j  |  j	 r t
 |  j |  j  r t |  j |  j |  j  n  |  ` |  ` |  ` x3 t |  j  D]" } t  |  r | j |   q q Wd S)zUndo the patch.z stop called on unstarted patcherN)r   RuntimeErrorr   r  r   ru   r   r   r   r   r   r   r   r	  )rb   r  r   r   r   r   r	    s     z_patch.__exit__c             C   s    |  j    } |  j j |   | S)z-Activate a patch, returning any created mock.)r  _active_patchesr   )rb   rH   r   r   r   start+  s    z_patch.startc             C   s3   y |  j  j |   Wn t k
 r( Yn X|  j   S)zStop an active patch.)r  r   r&   r	  )rb   r   r   r   stop2  s
    z_patch.stop)r   r   r   r   r  r!   r   r$   r   r   r  r  r	  r  r  r   r   r   r   r     s   (~r   c                sf   y   j  d d  \   } Wn+ t t f k
 rI t d   f   Yn X  f d d   } | | f S)Nr   r{   z.Need a valid target to patch. You supplied: %rc                  s
   t     S)N)r   r   )r   r   r   r   D  s    z_get_target.<locals>.<lambda>)rsplitr   r&   )r   r   r   r   )r   r   _get_target>  s    r  c       
   
      s4     f d d   }	 t  |	 | | | | | | | | 	 S)a  
    patch the named member (`attribute`) on an object (`target`) with a mock
    object.

    `patch.object` can be used as a decorator, class decorator or a context
    manager. Arguments `new`, `spec`, `create`, `spec_set`,
    `autospec` and `new_callable` have the same meaning as for `patch`. Like
    `patch`, `patch.object` takes arbitrary keyword arguments for configuring
    the mock object it creates.

    When used as a class decorator `patch.object` honours `patch.TEST_PREFIX`
    for choosing which methods to wrap.
    c                  s     S)Nr   r   )r   r   r   r   Z  s    z_patch_object.<locals>.<lambda>)r   )
r   r   r   r   r   r   r   r   r,   r   r   )r   r   _patch_objectH  s    r  c                s   t     t k r'   f d d   } n   f d d   } | sN t d   n  t | j    } | d \ }	 }
 t | |	 |
 | | | | | i  	 } |	 | _ x[ | d d  D]I \ }	 }
 t | |	 |
 | | | | | i  	 } |	 | _ | j j |  q W| S)a  Perform multiple patches in a single call. It takes the object to be
    patched (either as an object or a string to fetch the object by importing)
    and keyword arguments for the patches::

        with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):
            ...

    Use `DEFAULT` as the value if you want `patch.multiple` to create
    mocks for you. In this case the created mocks are passed into a decorated
    function by keyword, and a dictionary is returned when `patch.multiple` is
    used as a context manager.

    `patch.multiple` can be used as a decorator, class decorator or a context
    manager. The arguments `spec`, `spec_set`, `create`,
    `autospec` and `new_callable` have the same meaning as for `patch`. These
    arguments will be applied to *all* patches done by `patch.multiple`.

    When used as a class decorator `patch.multiple` honours `patch.TEST_PREFIX`
    for choosing which methods to wrap.
    c                  s
   t     S)N)r   r   )r   r   r   r   x  s    z!_patch_multiple.<locals>.<lambda>c                  s     S)Nr   r   )r   r   r   r   z  s    z=Must supply at least one keyword argument with patch.multipler   r{   N)	r   strr&   r<   r   r   r   r   r   )r   r   r   r   r   r   r,   r   r   r   r   r   Zthis_patcherr   )r   r   _patch_multiplea  s&    		r  c       
   
   K   s4   t  |   \ } }	 t | |	 | | | | | | | 	 S)a  
    `patch` acts as a function decorator, class decorator or a context
    manager. Inside the body of the function or with statement, the `target`
    is patched with a `new` object. When the function/with statement exits
    the patch is undone.

    If `new` is omitted, then the target is replaced with a
    `MagicMock`. If `patch` is used as a decorator and `new` is
    omitted, the created mock is passed in as an extra argument to the
    decorated function. If `patch` is used as a context manager the created
    mock is returned by the context manager.

    `target` should be a string in the form `'package.module.ClassName'`. The
    `target` is imported and the specified object replaced with the `new`
    object, so the `target` must be importable from the environment you are
    calling `patch` from. The target is imported when the decorated function
    is executed, not at decoration time.

    The `spec` and `spec_set` keyword arguments are passed to the `MagicMock`
    if patch is creating one for you.

    In addition you can pass `spec=True` or `spec_set=True`, which causes
    patch to pass in the object being mocked as the spec/spec_set object.

    `new_callable` allows you to specify a different class, or callable object,
    that will be called to create the `new` object. By default `MagicMock` is
    used.

    A more powerful form of `spec` is `autospec`. If you set `autospec=True`
    then the mock with be created with a spec from the object being replaced.
    All attributes of the mock will also have the spec of the corresponding
    attribute of the object being replaced. Methods and functions being
    mocked will have their arguments checked and will raise a `TypeError` if
    they are called with the wrong signature. For mocks replacing a class,
    their return value (the 'instance') will have the same spec as the class.

    Instead of `autospec=True` you can pass `autospec=some_object` to use an
    arbitrary object as the spec instead of the one being replaced.

    By default `patch` will fail to replace attributes that don't exist. If
    you pass in `create=True`, and the attribute doesn't exist, patch will
    create the attribute for you when the patched function is called, and
    delete it again afterwards. This is useful for writing tests against
    attributes that your production code creates at runtime. It is off by
    default because it can be dangerous. With it switched on you can write
    passing tests against APIs that don't actually exist!

    Patch can be used as a `TestCase` class decorator. It works by
    decorating each test method in the class. This reduces the boilerplate
    code when your test methods share a common patchings set. `patch` finds
    tests by looking for method names that start with `patch.TEST_PREFIX`.
    By default this is `test`, which matches the way `unittest` finds tests.
    You can specify an alternative prefix by setting `patch.TEST_PREFIX`.

    Patch can be used as a context manager, with the with statement. Here the
    patching applies to the indented block after the with statement. If you
    use "as" then the patched object will be bound to the name after the
    "as"; very useful if `patch` is creating a mock object for you.

    `patch` takes arbitrary keyword arguments. These will be passed to
    the `Mock` (or `new_callable`) on construction.

    `patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are
    available for alternate use-cases.
    )r  r   )
r   r   r   r   r   r   r   r,   r   r   r   r   r   r     s    Ec               @   s|   e  Z d  Z d Z f  d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 e Z e
 Z d S)_patch_dicta#  
    Patch a dictionary, or dictionary like object, and restore the dictionary
    to its original state after the test.

    `in_dict` can be a dictionary or a mapping like container. If it is a
    mapping then it must at least support getting, setting and deleting items
    plus iterating over keys.

    `in_dict` can also be a string specifying the name of the dictionary, which
    will then be fetched by importing it.

    `values` can be a dictionary of values to set in the dictionary. `values`
    can also be an iterable of `(key, value)` pairs.

    If `clear` is True then the dictionary will be cleared before the new
    values are set.

    `patch.dict` can also be called with arbitrary keyword arguments to set
    values in the dictionary::

        with patch.dict('sys.modules', mymodule=Mock(), other_module=Mock()):
            ...

    `patch.dict` can be used as a context manager, decorator or class
    decorator. When used as a class decorator `patch.dict` honours
    `patch.TEST_PREFIX` for choosing which methods to wrap.
    Fc             K   s\   t  | t  r t |  } n  | |  _ t |  |  _ |  j j |  | |  _ d  |  _ d  S)N)	r   r  r   in_dictri   r   r  clear	_original)rb   r  r   r   r,   r   r   r   r!     s    		z_patch_dict.__init__c                sA   t    t  r  j    St       f d d    } | S)Nc           
      s-    j    z   |  |   SWd   j   Xd  S)N)r  _unpatch_dict)r+   r   )frb   r   r   _inner	  s    
z$_patch_dict.__call__.<locals>._inner)r   r   r   r   )rb   r#  r$  r   )r#  rb   r   r$     s    !z_patch_dict.__call__c             C   s   x~ t  |  D]p } t | |  } | j t j  r t | d  r t |  j |  j |  j	  } | |  } t
 | | |  q q W| S)Nr$   )r   r:   r   r   r  r   r  r  r   r   ru   )rb   r   r  r  Z	decoratorZ	decoratedr   r   r   r     s    z_patch_dict.decorate_classc             C   s   |  j    d S)zPatch the dict.N)r  )rb   r   r   r   r    s    z_patch_dict.__enter__c             C   s   |  j  } |  j } |  j } y | j   } Wn7 t k
 rd i  } x | D] } | | | | <qH WYn X| |  _ | r t |  n  y | j |  Wn1 t k
 r x | D] } | | | | <q WYn Xd  S)N)r   r  r   r   r"   r!  _clear_dictr  )rb   r   r  r   rG   r   r   r   r   r  $  s"    				z_patch_dict._patch_dictc             C   se   |  j  } |  j } t |  y | j |  Wn1 t k
 r` x | D] } | | | | <qD WYn Xd  S)N)r  r!  r%  r  r"   )rb   r  rG   r   r   r   r   r"  >  s    		
z_patch_dict._unpatch_dictc             G   s   |  j    d S)zUnpatch the dict.F)r"  )rb   r+   r   r   r   r	  K  s    
z_patch_dict.__exit__N)r   r   r   r5   r!   r$   r   r  r  r"  r	  r  r  r   r   r   r   r    s   r  c             C   sK   y |  j    Wn6 t k
 rF t |   } x | D] } |  | =q1 WYn Xd  S)N)r   r"   r<   )r  keysr   r   r   r   r%  T  s    r%  c              C   s(   x! t  t j  D] }  |  j   q Wd S)z7Stop all active patches. LIFO to unroll nested patches.N)r   r   r  r  )r   r   r   r   _patch_stopall]  s    r'  Ztestzlt le gt ge eq ne getitem setitem delitem len contains iter hash str sizeof enter exit divmod neg pos abs invert complex int float index trunc floor ceil bool next zAadd sub mul div floordiv mod lshift rshift and xor or pow truediv c             c   s   |  ] } d  | Vq d S)zi%sNr   )r   nr   r   r   r   x  s    r   c             c   s   |  ] } d  | Vq d S)zr%sNr   )r   r)  r   r   r   r   y  s    c             c   s   |  ] } d  | Vq d S)z__%s__Nr   )r   methodr   r   r   r     s    rA   rj   Zdeleter   ZmissingreduceZ	reduce_exZgetinitargsZ
getnewargsgetstatesetstateZ	getformatZ	setformatreprr   Z
subclassesformatc                s     f d d   } |  | _  | S)z:Turns a callable object (like a mock) into a real functionc                s     |  | |  S)Nr   )rb   r+   r   )r'   r   r   r*    s    z_get_method.<locals>.method)r   )rI   r'   r*  r   )r'   r   r     s    	r   c             c   s   |  ] } d  | Vq d S)z__%s__Nr   )r   r*  r   r   r   r     s    rh   r   r!   r   Z__prepare____instancecheck____subclasscheck____del__c             C   s   t  j |   S)N)r   __hash__)rb   r   r   r   r     s    r   r2  c             C   s   t  j |   S)N)r   __str__)rb   r   r   r   r     s    r3  c             C   s   t  j |   S)N)r   
__sizeof__)rb   r   r   r   r     s    r4  __lt____gt____le____ge__r{   __int__r|   __len__r	  y              ?__complex__g      ?	__float____bool__	__index__c                s     f d d   } | S)Nc                s&     j  j } | t k	 r | S  |  k S)N)__eq__rm   r   )otherr   )rb   r   r   r?    s    z_get_eq.<locals>.__eq__r   )rb   r?  r   )rb   r   _get_eq  s    rA  c                s     f d d   } | S)Nc                s      j  j t k	 r t S  |  k	 S)N)__ne__rm   r   )r@  )rb   r   r   rB    s    z_get_ne.<locals>.__ne__r   )rb   rB  r   )rb   r   _get_ne  s    rC  c                s     f d d   } | S)Nc                 s,     j  j }  |  t k r" t g   St |   S)N)r   rm   r   r   )r   )rb   r   r   r     s    
z_get_iter.<locals>.__iter__r   )rb   r   r   )rb   r   	_get_iter  s    rD  r?  rB  r   c             C   s   t  j | t  } | t k	 r+ | | _ d  St j |  } | d  k	 r y | |   } Wn t k
 rv t |  } Yn X| | _ d  St j |  } | d  k	 r | |   | _ n  d  S)N)_return_valuesrA   r   rU   _calculate_return_valuer"   _side_effect_methodsr[   )r1   r*  rI   ZfixedZreturn_calulatorrU   Zside_effectorr   r   r   _set_return_value  s    		rH  c               @   s(   e  Z d  Z d d   Z d d   Z d S)
MagicMixinc             O   s'   t  t |   j | |   |  j   d  S)N)r   rI  r!   _mock_set_magics)rb   r+   r   r   r   r   r!     s    zMagicMixin.__init__c             C   s   t  } |  j d  k	 rs t  j |  j  } t   } t  | } x6 | D]+ } | t |   j k rA t |  |  qA qA Wn  | t t |   j  } t |   } x' | D] } t | | t | |    q Wd  S)N)	_magicsr   intersectionrj   r   r@   r   ru   
MagicProxy)rb   Zthese_magicsZremove_magicsr   r   r   r   r   rJ    s    	
zMagicMixin._mock_set_magicsN)r   r   r   r!   rJ  r   r   r   r   rI    s   rI  c               @   s%   e  Z d  Z d Z d d d  Z d S)r   z-A version of `MagicMock` that isn't callable.Fc             C   s   |  j  | |  |  j   d S)zAdd a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set.N)r   rJ  )rb   r   r   r   r   r   r   	  s    z"NonCallableMagicMock.mock_add_specN)r   r   r   r5   r   r   r   r   r   r     s   c               @   s%   e  Z d  Z d Z d d d  Z d S)r   a  
    MagicMock is a subclass of Mock with default implementations
    of most of the magic methods. You can use MagicMock without having to
    configure the magic methods yourself.

    If you use the `spec` or `spec_set` arguments then *only* magic
    methods that exist in the spec will be created.

    Attributes and the return value of a `MagicMock` will also be `MagicMocks`.
    Fc             C   s   |  j  | |  |  j   d S)zAdd a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set.N)r   rJ  )rb   r   r   r   r   r   r     s    zMagicMock.mock_add_specN)r   r   r   r5   r   r   r   r   r   r     s   
c               @   sC   e  Z d  Z d d   Z d d   Z d d   Z d d d	  Z d S)
rM  c             C   s   | |  _  | |  _ d  S)N)rI   r   )rb   rI   r   r   r   r   r!   +  s    	zMagicProxy.__init__c             O   s   |  j    } | | |   S)N)create_mock)rb   r+   r,   mr   r   r   r$   /  s    zMagicProxy.__call__c             C   sT   |  j  } |  j } | j d | d | d |  } t | | |  t | | |  | S)NrI   r   r   )rI   r   r   ru   rH  )rb   r   r   rO  r   r   r   rN  3  s    			zMagicProxy.create_mockNc             C   s
   |  j    S)N)rN  )rb   r   r   r   r   r   __get__<  s    zMagicProxy.__get__)r   r   r   r!   r$   rN  rP  r   r   r   r   rM  *  s   	rM  c               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	_ANYz2A helper object that compares equal to everything.c             C   s   d S)NTr   )rb   r@  r   r   r   r?  D  s    z_ANY.__eq__c             C   s   d S)NFr   )rb   r@  r   r   r   rB  G  s    z_ANY.__ne__c             C   s   d S)Nz<ANY>r   )rb   r   r   r   rc   J  s    z_ANY.__repr__N)r   r   r   r5   r?  rB  rc   r   r   r   r   rQ  A  s   rQ  c             C   s   d |  } d } d j  d d   | D  } d j  d d   | j   D  } | r] | } n  | r | rv | d 7} n  | | 7} n  | | S)Nz%s(%%s)r   z, c             S   s   g  |  ] } t  |   q Sr   )r.  )r   r   r   r   r   r   T  s   	 z*_format_call_signature.<locals>.<listcomp>c             S   s&   g  |  ] \ } } d  | | f  q S)z%s=%rr   )r   r   rk   r   r   r   r   V  s   	 )r   r   )rI   r+   r,   r   Zformatted_argsZargs_stringZkwargs_stringr   r   r   r   Q  s    
	r   c               @   s   e  Z d  Z d Z f  d d d d d d  Z f  d d d d d d  Z d	 d
   Z d d   Z d d   Z d d   Z	 d d   Z
 d d   Z d S)r   a  
    A tuple for holding the results of a call to a mock, either in the form
    `(args, kwargs)` or `(name, args, kwargs)`.

    If args or kwargs are empty then a call tuple will compare equal to
    a tuple without those values. This makes comparisons less verbose::

        _Call(('name', (), {})) == ('name',)
        _Call(('name', (1,), {})) == ('name', (1,))
        _Call(((), {'a': 'b'})) == ({'a': 'b'},)

    The `_Call` object provides a useful shortcut for comparing with call::

        _Call(((1, 2), {'a': 3})) == call(1, 2, a=3)
        _Call(('foo', (1, 2), {'a': 3})) == call.foo(1, 2, a=3)

    If the _Call has no name then it will match any name.
    NFTc             C   s  d } f  } i  } t  |  } | d k r< | \ } } } n | d k r | \ }	 }
 t |	 t  r |	 } t |
 t  r |
 } q |
 } q |	 |
 } } nN | d k r | \ } t | t  r | } q t | t  r | } q | } n  | rt j |  | | f  St j |  | | | f  S)Nr   r   r^   r{   )r}   r   r  r=   r   )r   rk   rI   r   r   	from_kallr+   r,   _lenfirstsecondr   r   r   r   v  s0    						z_Call.__new__c             C   s   | |  _  | |  _ | |  _ d  S)N)rI   r   rR  )rb   rk   rI   r   r   rR  r   r   r   r!     s    		z_Call.__init__c             C   s  | t  k r d Sy t |  } Wn t k
 r8 d SYn Xd } t |   d k r` |  \ } } n |  \ } } } d } | d k r f  i  } } n | d k r | \ } } } n | d k r| \ }	 t |	 t  r |	 } i  } qst |	 t  r|	 } f  i  } } qsf  } |	 } n] | \ }
 } t |
 t  rf|
 } t | t  rV| i  } } qsf  | } } n |
 | } } | r| | k rd S| | f | | f k S)NTFr   r^   r   r   r{   )r   r}   r   r   r=   r  )rb   r@  Z	len_otherZ	self_nameZ	self_argsZself_kwargsZ
other_nameZ
other_argsZother_kwargsrk   rT  rU  r   r   r   r?    sF    				z_Call.__eq__c             C   s   |  j  |  S)N)r?  )rb   r@  r   r   r   rB    s    z_Call.__ne__c             O   sW   |  j  d  k r( t d | | f d d S|  j  d } t |  j  | | f d | d |  S)Nr   rI   z()r   )rI   r   )rb   r+   r,   rI   r   r   r   r$     s    z_Call.__call__c             C   sN   |  j  d  k r" t d | d d  Sd |  j  | f } t d | d |  d d  S)NrI   rR  Fz%s.%sr   )rI   r   )rb   r  rI   r   r   r   rh     s    z_Call.__getattr__c             C   s   |  j  s8 |  j p d } | j d  r4 d | } n  | St |   d k r_ d } |  \ } } nD |  \ } } } | s} d } n& | j d  s d | } n
 d | } t | | |  S)Nr   z()zcall%sr^   zcall.%s)rR  rI   r   r}   r   )rb   rI   r+   r,   r   r   r   rc     s    		
z_Call.__repr__c             C   sQ   g  } |  } x2 | d k	 r@ | j  r4 | j |  n  | j } q Wt t |   S)zFor a call object that represents multiple calls, `call_list`
        returns a list of all the intermediate calls as well as the
        final call.N)rR  r   r   rQ   r   )rb   Zvalsr   r   r   r   	call_list  s    	z_Call.call_list)r   r   r   r5   r   r!   r?  rB  r$   rh   rc   rV  r   r   r   r   r   c  s    2r   rR  c             K   s  t  |   r t |   }  n  t |  t  } i |  d 6} | rM i |  d 6} n |  d k rb i  } n  | r{ | r{ d | d <n  | j |  t } t |   t k r i  } n7 t |   s t } n" | r | r t |   r t } n  | j	 d |  } | }	 | d k rd }	 n  | d | d	 | d
 |	 d | |  }
 t |  t
  rRt |
 |   }
 n t |  |
 | |  | d k	 r| r|
 | j | <n  | r| rd | k rt |  | d d d d d |
 |
 _ n  xNt |   D]@} t |  rqn  y t |  |  } Wn t k
 rwYn Xi | d 6} | r;i | d 6} n  t | t
  srt | | |
 | |  } | |
 j | <n |
 } t |  t
  r|
 j } n  t |  | |  } | | d <t d | d | d
 | d	 | |  } | |
 j | <t | | d | t | t
  rt |
 | |  qqW|
 S)aI  Create a mock object using another object as a spec. Attributes on the
    mock will use the corresponding attribute on the `spec` object as their
    spec.

    Functions or methods being mocked will have their arguments checked
    to check that they are called with the correct signature.

    If `spec_set` is True then attempting to set attributes that don't exist
    on the spec object will raise an `AttributeError`.

    If a class is used as a spec then the return value of the mock (the
    instance of the class) will have the same spec. You can use a class as the
    spec for an instance object by passing `instance=True`. The returned mock
    will only be callable if instances of the mock are callable.

    `create_autospec` also takes arbitrary keyword arguments that are passed to
    the constructor of the created mock.r   r   NTr   rI   r   r   r   r   rU   r3   r  z()r   r   r2   )r>   r   r   r  r   DescriptorTypesr;   r   rC   r   r#   rL   r4   r\   r   rU   r   r`   r:   r"   r   r1   
_must_skipru   )r   r   r3   r   r  r,   is_typer  r  r   r1   r   rG   r   r   r2   r   r   r   r   	  st    					
	c             C   s   t  |  t  s7 | t |  d i   k r+ d S|  j }  n  xt |  j D]i } | j j | t  } | t k rn qA n  t  | t t	 f  r d St  t | d d  t
  r | Sd SqA W| S)z[
    Return whether we should skip the first argument on spec's `entry`
    attribute.
    r@   FrP  N)r   r   r:   r   r?   r@   rA   r   staticmethodclassmethodMethodWrapperTypes)r   r   rY  r   rH   r   r   r   rX    s    rX  c             C   s.   y |  j  SWn t k
 r) t |   SYn Xd  S)N)r   r"   r   )r   r   r   r   r     s    r   c               @   s+   e  Z d  Z d d d d d d d  Z d S)r   FNc             C   s:   | |  _  | |  _ | |  _ | |  _ | |  _ | |  _ d  S)N)r   idsr   r   r3   rI   )rb   r   r   r   rI   r]  r3   r   r   r   r!     s    					z_SpecState.__init__)r   r   r   r!   r   r   r   r   r     s   r   c             c   sq   d d   |  j  d  D } | d d k r? | d  d  } n | d d  d  | d	 <x | D] } | Vq^ Wd  S)
Nc             S   s   g  |  ] } d  j  |   q S)z{}
)r/  )r   lr   r   r   r     s   	 z&_iterate_read_data.<locals>.<listcomp>
r{   r`  r`  r`  r`  )r   )	read_dataZdata_as_listliner   r   r   _iterate_read_data  s    rc  r   c                s<     f d d   }    f d d   }    f d d   } t  d k r d d l } t t t | j   j t t | j     a  n  |  d k r t d	 d
 d t	  }  n  t d t      j
 _ t |    d  j _ d  j _ d  j _ d  j _ |  j _ |    j _ |  j _  |  _ |  S)a  
    A helper function to create a mock to replace the use of `open`. It works
    for `open` called directly or used as a context manager.

    The `mock` argument is the mock object to configure. If `None` (the
    default) then a `MagicMock` will be created for you, with the API limited
    to methods or attributes available on standard file handles.

    `read_data` is a string for the `read` methoddline`, and `readlines` of the
    file handle to return.  This is an empty string by default.
    c                 s&    j  j d  k	 r  j  j St    S)N)	readlinesrU   r<   )r+   r,   )_datahandler   r   _readlines_side_effect  s    
z)mock_open.<locals>._readlines_side_effectc                 s)    j  j d  k	 r  j  j Sd j    S)Nr   )readrU   r   )r+   r,   )re  rf  r   r   _read_side_effect  s    
z$mock_open.<locals>._read_side_effectc              3   s@    j  j d  k	 r& x  j  j Vq n  x   D] }  |  Vq- Wd  S)N)readlinerU   )rb  )re  rf  r   r   _readline_side_effect  s
    z(mock_open.<locals>._readline_side_effectNr   rI   openr   )	file_spec_ior<   rj   r   TextIOWrapperunionBytesIOr   rl  r  rU   rc  writerh  rj  rd  r[   )r1   ra  rg  ri  rk  rn  r   )re  rf  r   r     s(    	6	c               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	r   aW  
    A mock intended to be used as a property, or other descriptor, on a class.
    `PropertyMock` provides `__get__` and `__set__` methods so you can specify
    a return value when it is fetched.

    Fetching a `PropertyMock` instance from an object calls the mock, with
    no args. Setting it calls the mock with the value being set.
    c             K   s
   t  |   S)N)r   )rb   r,   r   r   r   r   	  s    zPropertyMock._get_child_mockc             C   s   |    S)Nr   )rb   r   Zobj_typer   r   r   rP  	  s    zPropertyMock.__get__c             C   s   |  |  d  S)Nr   )rb   r   r   r   r   r   __set__	  s    zPropertyMock.__set__N)r   r   r   r5   r   rP  rs  r   r   r   r   r   	  s   )o__all____version__r%   r   r  	functoolsr   r   BaseExceptionr   platformr   ZlangZ	Throwabler	   superr   r   r   r   r   r   r   ry   rW  r(   r4   r/   r;   r>   rC   rL   rF   r`   ra   rd   r   r   ZMISSINGr   ZDELETEDr   rl   rj   rw   rz   r<   rQ   r   r   r   r
   r   r   r   r   r   r   r   r  r  r  r   r  r%  r'  ri   ZmultipleZstopallr  Zmagic_methodsZnumericsr   r   ZinplacerightZ_non_defaultsr   rK  r   r   rF  NotImplementedrE  rA  rC  rD  rG  rH  rI  r   r   rM  rQ  r   r   r=   r   r   r   rX  r   r   r?  r#   rP  r\  rm  rc  r   r   r   r   r   r   <module>   s  			 +							 e5 %		1	Jv						""	(
	


		w	8                                                                    usr/lib/python3.4/unittest/__pycache__/result.cpython-34.pyc                                        0100644 0000000 0000000 00000016765 13077704336 022454  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s   d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d Z d d   Z	 d	 Z
 d
 Z Gd d   d e  Z d S)zTest result object    N   )util)wrapsTc                s"   t       f d d    } | S)Nc                s/   t  |  d d  r |  j   n    |  | |  S)NfailfastF)getattrstop)selfargskw)method %/usr/lib/python3.4/unittest/result.pyinner   s    zfailfast.<locals>.inner)r   )r   r   r   )r   r   r      s    r   z
Stdout:
%sz
Stderr:
%sc               @   sE  e  Z d  Z d Z d Z d Z d Z d d d d d  Z d d   Z d d	   Z	 d
 d   Z
 d d   Z d d   Z d d   Z d d   Z e d d    Z e d d    Z e d d    Z d d   Z d d   Z d d   Z e d  d!    Z d" d#   Z d$ d%   Z d& d'   Z d( d)   Z d* d+   Z d, d-   Z d S).
TestResulta  Holder for test result information.

    Test results are automatically managed by the TestCase and TestSuite
    classes, and do not need to be explicitly manipulated by writers of tests.

    Each instance holds the total number of tests run, and collections of
    failures and errors that occurred among those test runs. The collections
    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the
    formatted traceback of the error that occurred.
    NFc             C   s   d |  _  g  |  _ g  |  _ d |  _ g  |  _ g  |  _ g  |  _ d |  _ d |  _ d  |  _	 d  |  _
 t j |  _ t j |  _ d |  _ d  S)NFr   )r   failureserrorstestsRunskippedexpectedFailuresunexpectedSuccesses
shouldStopbuffer_stdout_buffer_stderr_buffersysstdout_original_stdoutstderr_original_stderr_mirrorOutput)r   streamZdescriptions	verbosityr   r   r   __init__&   s    											zTestResult.__init__c             C   s   d S)z#Called by TestRunner after test runNr   )r   r   r   r   printErrors6   s    zTestResult.printErrorsc             C   s&   |  j  d 7_  d |  _ |  j   d S)z-Called when the given test is about to be runr   FN)r   r   _setupStdout)r   testr   r   r   	startTest9   s    	zTestResult.startTestc             C   sX   |  j  rT |  j d  k r9 t j   |  _ t j   |  _ n  |  j t _ |  j t _ n  d  S)N)r   r   ioStringIOr   r   r   r   )r   r   r   r   r$   ?   s    	zTestResult._setupStdoutc             C   s   d S)zpCalled once before any tests are executed.

        See startTest for a method called before each test.
        Nr   )r   r   r   r   startTestRunG   s    zTestResult.startTestRunc             C   s   |  j    d |  _ d S)z'Called when the given test has been runFN)_restoreStdoutr   )r   r%   r   r   r   stopTestM   s    
zTestResult.stopTestc             C   s   |  j  r |  j r t j j   } t j j   } | ri | j d  sR | d 7} n  |  j j t	 |  n  | r | j d  s | d 7} n  |  j
 j t |  q n  |  j t _ |  j
 t _ |  j j d  |  j j   |  j j d  |  j j   n  d  S)N
r   )r   r   r   r   getvaluer   endswithr   writeSTDOUT_LINEr   STDERR_LINEr   seektruncater   )r   outputerrorr   r   r   r*   R   s$    		zTestResult._restoreStdoutc             C   s   d S)zmCalled once after all tests are executed.

        See stopTest for a method called after each test.
        Nr   )r   r   r   r   stopTestRung   s    zTestResult.stopTestRunc             C   s/   |  j  j | |  j | |  f  d |  _ d S)zmCalled when an error has occurred. 'err' is a tuple of values as
        returned by sys.exc_info().
        TN)r   append_exc_info_to_stringr   )r   r%   errr   r   r   addErrorm   s    "zTestResult.addErrorc             C   s/   |  j  j | |  j | |  f  d |  _ d S)zdCalled when an error has occurred. 'err' is a tuple of values as
        returned by sys.exc_info().TN)r   r7   r8   r   )r   r%   r9   r   r   r   
addFailureu   s    "zTestResult.addFailurec             C   sf   | d k	 rb t  | d | j  r. |  j } n	 |  j } | j | |  j | |  f  d |  _ n  d S)zCalled at the end of a subtest.
        'err' is None if the subtest ended successfully, otherwise it's a
        tuple of values as returned by sys.exc_info().
        Nr   T)
issubclassfailureExceptionr   r   r7   r8   r   )r   r%   Zsubtestr9   r   r   r   r   
addSubTest|   s    	zTestResult.addSubTestc             C   s   d S)z-Called when a test has completed successfullyNr   )r   r%   r   r   r   
addSuccess   s    zTestResult.addSuccessc             C   s   |  j  j | | f  d S)zCalled when a test is skipped.N)r   r7   )r   r%   reasonr   r   r   addSkip   s    zTestResult.addSkipc             C   s&   |  j  j | |  j | |  f  d S)z.Called when an expected failure/error occured.N)r   r7   r8   )r   r%   r9   r   r   r   addExpectedFailure   s    	zTestResult.addExpectedFailurec             C   s   |  j  j |  d S)z5Called when a test was expected to fail, but succeed.N)r   r7   )r   r%   r   r   r   addUnexpectedSuccess   s    zTestResult.addUnexpectedSuccessc             C   sQ   t  |  j  t  |  j  k o) d k n oP t |  d  pP t  |  j  d k S)z/Tells whether or not this result was a success.r   r   )lenr   r   hasattrr   )r   r   r   r   wasSuccessful   s    .zTestResult.wasSuccessfulc             C   s   d |  _  d S)z+Indicates that the tests should be aborted.TN)r   )r   r   r   r   r      s    zTestResult.stopc       
      C   s%  | \ } } } x" | r3 |  j  |  r3 | j } q W| | j k rm |  j |  } t j | | | |  } n t j | | |  } |  j rt j j	   } t j
 j	   }	 | r | j d  s | d 7} n  | j t |  n  |	 r|	 j d  s|	 d 7}	 n  | j t |	  qn  d j |  S)z>Converts a sys.exc_info()-style tuple of values into a string.r,    )_is_relevant_tb_leveltb_nextr=   _count_relevant_tb_levels	tracebackformat_exceptionr   r   r   r-   r   r.   r7   r0   r1   join)
r   r9   r%   exctypevaluetblengthZmsgLinesr4   r5   r   r   r   r8      s&    	zTestResult._exc_info_to_stringc             C   s   d | j  j k S)N
__unittest)tb_frame	f_globals)r   rP   r   r   r   rH      s    z TestResult._is_relevant_tb_levelc             C   s:   d } x- | r5 |  j  |  r5 | d 7} | j } q	 W| S)Nr   r   )rH   rI   )r   rP   rQ   r   r   r   rJ      s
    
z$TestResult._count_relevant_tb_levelsc             C   s5   d t  j |  j  |  j t |  j  t |  j  f S)Nz!<%s run=%i errors=%i failures=%i>)r   Zstrclass	__class__r   rD   r   r   )r   r   r   r   __repr__   s    !zTestResult.__repr__)__name__
__module____qualname____doc__Z_previousTestClassZ_testRunEnteredZ_moduleSetUpFailedr"   r#   r&   r$   r)   r+   r*   r6   r   r:   r;   r>   r?   rA   rB   rC   rF   r   r8   rH   rJ   rV   r   r   r   r   r      s2   
	r   )rZ   r'   r   rK   rG   r   	functoolsr   rR   r   r0   r1   objectr   r   r   r   r   <module>   s              usr/lib/python3.4/unittest/__pycache__/runner.cpython-34.pyc                                        0100644 0000000 0000000 00000016312 13077704336 022433  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T<                 @   s   d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d Z Gd d   d e	  Z
 Gd	 d
   d
 e j  Z Gd d   d e	  Z d S)zRunning tests    N   )result)registerResultTc               @   s=   e  Z d  Z d Z d d   Z d d   Z d d d  Z d S)	_WritelnDecoratorz@Used to decorate file-like objects with a handy 'writeln' methodc             C   s   | |  _  d  S)N)stream)selfr    r   %/usr/lib/python3.4/unittest/runner.py__init__   s    z_WritelnDecorator.__init__c             C   s+   | d k r t  |   n  t |  j |  S)Nr   __getstate__)zstreamz__getstate__)AttributeErrorgetattrr   )r   attrr   r   r	   __getattr__   s    z_WritelnDecorator.__getattr__Nc             C   s'   | r |  j  |  n  |  j  d  d  S)N
)write)r   argr   r   r	   writeln   s    z_WritelnDecorator.writeln)__name__
__module____qualname____doc__r
   r   r   r   r   r   r	   r      s   r   c                   s   e  Z d  Z d Z d d Z d d Z   f d d   Z d d   Z   f d	 d
   Z   f d d   Z	   f d d   Z
   f d d   Z   f d d   Z   f d d   Z   f d d   Z d d   Z d d   Z   S)TextTestResultzhA test result class that can print formatted text results to a stream.

    Used by TextTestRunner.
    =F   -c                sP   t  t |   j | | |  | |  _ | d k |  _ | d k |  _ | |  _ d  S)Nr   )superr   r
   r   showAlldotsdescriptions)r   r   r   	verbosity)	__class__r   r	   r
   %   s
    	zTextTestResult.__init__c             C   sB   | j    } |  j r4 | r4 d j t |  | f  St |  Sd  S)Nr   )ZshortDescriptionr   joinstr)r   testZdoc_first_liner   r   r	   getDescription,   s    zTextTestResult.getDescriptionc                s\   t  t |   j |  |  j rX |  j j |  j |   |  j j d  |  j j   n  d  S)Nz ... )r   r   	startTestr   r   r   r%   flush)r   r$   )r!   r   r	   r&   3   s
    	zTextTestResult.startTestc                s_   t  t |   j |  |  j r2 |  j j d  n) |  j r[ |  j j d  |  j j   n  d  S)Nok.)	r   r   
addSuccessr   r   r   r   r   r'   )r   r$   )r!   r   r	   r*   :   s    		zTextTestResult.addSuccessc                sb   t  t |   j | |  |  j r5 |  j j d  n) |  j r^ |  j j d  |  j j   n  d  S)NERRORE)	r   r   addErrorr   r   r   r   r   r'   )r   r$   err)r!   r   r	   r-   B   s    		zTextTestResult.addErrorc                sb   t  t |   j | |  |  j r5 |  j j d  n) |  j r^ |  j j d  |  j j   n  d  S)NFAILF)	r   r   
addFailurer   r   r   r   r   r'   )r   r$   r.   )r!   r   r	   r1   J   s    		zTextTestResult.addFailurec                sk   t  t |   j | |  |  j r> |  j j d j |   n) |  j rg |  j j d  |  j j	   n  d  S)Nzskipped {0!r}s)
r   r   addSkipr   r   r   formatr   r   r'   )r   r$   reason)r!   r   r	   r3   R   s    		zTextTestResult.addSkipc                sb   t  t |   j | |  |  j r5 |  j j d  n) |  j r^ |  j j d  |  j j   n  d  S)Nzexpected failurex)	r   r   addExpectedFailurer   r   r   r   r   r'   )r   r$   r.   )r!   r   r	   r7   Z   s    		z!TextTestResult.addExpectedFailurec                s_   t  t |   j |  |  j r2 |  j j d  n) |  j r[ |  j j d  |  j j   n  d  S)Nzunexpected successu)	r   r   addUnexpectedSuccessr   r   r   r   r   r'   )r   r$   )r!   r   r	   r9   b   s    		z#TextTestResult.addUnexpectedSuccessc             C   sL   |  j  s |  j r" |  j j   n  |  j d |  j  |  j d |  j  d  S)Nr+   r/   )r   r   r   r   printErrorListerrorsfailures)r   r   r   r	   printErrorsj   s    zTextTestResult.printErrorsc             C   sx   xq | D]i \ } } |  j  j |  j  |  j  j d | |  j |  f  |  j  j |  j  |  j  j d |  q Wd  S)Nz%s: %sz%s)r   r   
separator1r%   
separator2)r   Zflavourr;   r$   r.   r   r   r	   r:   p   s
    #zTextTestResult.printErrorList)r   r   r   r   r>   r?   r
   r%   r&   r*   r-   r1   r3   r7   r9   r=   r:   r   r   )r!   r	   r      s   

r   c            	   @   sU   e  Z d  Z d Z e Z d d d d d d d d d  Z d d	   Z d
 d   Z d S)TextTestRunnerzA test runner class that displays results in textual form.

    It prints out the names of tests as they are run, errors as they
    occur, and a summary of the results at the end of the test run.
    NTr   Fc             C   sp   | d  k r t  j } n  t |  |  _ | |  _ | |  _ | |  _ | |  _ | |  _ | d  k	 rl | |  _	 n  d  S)N)
sysstderrr   r   r   r    failfastbufferwarningsresultclass)r   r   r   r    rC   rD   rF   rE   r   r   r	   r
      s    					zTextTestRunner.__init__c             C   s   |  j  |  j |  j |  j  S)N)rF   r   r   r    )r   r   r   r	   _makeResult   s    zTextTestRunner._makeResultc             C   s  |  j    } t |  |  j | _ |  j | _ t j    |  j r t j |  j  |  j d k r t j d d t d d q n  t	 j	   } t
 | d d  } | d k	 r |   n  z | |  Wd t
 | d	 d  } | d k	 r |   n  Xt	 j	   } Wd QX| | } | j   t | d
  r;|  j j | j  n  | j } |  j j d | | d k red phd | f  |  j j   d }	 }
 } y% t t | j | j | j f  } Wn t k
 rYn X| \ }	 }
 } g  } | j   sO|  j j d  t | j  t | j  } } | r2| j d |  n  | r_| j d |  q_n |  j j d  | ry| j d |  n  |	 r| j d |	  n  |
 r| j d |
  n  | r|  j j d d j |  f  n |  j j d  | S)z&Run the given test case or test suite.defaultalwaysmodulecategorymessagezPlease use assert\w+ instead.startTestRunNstopTestRunr?   zRan %d test%s in %.3fsr   r2    r   ZFAILEDzfailures=%dz	errors=%dZOKz
skipped=%dzexpected failures=%dzunexpected successes=%dz (%s)z, r   )zdefaultzalways)rG   r   rC   rD   rE   catch_warningssimplefilterfilterwarningsDeprecationWarningtimer   r=   hasattrr   r   r?   ZtestsRunmaplenZexpectedFailuresunexpectedSuccessesskippedr   ZwasSuccessfulr   r<   r;   appendr"   )r   r$   r   Z	startTimerM   rN   ZstopTimeZ	timeTakenrunZexpectedFailsrX   rY   ZresultsZinfosZfailedZerroredr   r   r	   r[      sp    
	


	##zTextTestRunner.run)	r   r   r   r   r   rF   r
   rG   r[   r   r   r   r	   r@   x   s   	r@   )r   rA   rT   rE   rO   r   Zsignalsr   Z
__unittestobjectr   Z
TestResultr   r@   r   r   r   r	   <module>   s   [                                                                                                                                                                                                                                                                                                                      usr/lib/python3.4/unittest/__pycache__/signals.cpython-34.pyc                                       0100644 0000000 0000000 00000004511 13077704336 022560  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5Tc	                 @   s   d  d l  Z  d  d l Z d  d l m Z d Z Gd d   d e  Z e j   Z d d   Z	 d d	   Z
 d a d
 d   Z d d d  Z d S)    N)wrapsTc               @   s(   e  Z d  Z d d   Z d d   Z d S)_InterruptHandlerc             C   sv   d |  _  | |  _ t | t  ri | t j k r< t j } qi | t j k rZ d d   } qi t d   n  | |  _	 d  S)NFc             S   s   d  S)N )Zunused_signumZunused_framer   r   &/usr/lib/python3.4/unittest/signals.pydefault_handler   s    z3_InterruptHandler.__init__.<locals>.default_handlerzYexpected SIGINT signal handler to be signal.SIG_IGN, signal.SIG_DFL, or a callable object)
calledoriginal_handler
isinstanceintsignalSIG_DFLdefault_int_handlerSIG_IGN	TypeErrorr   )selfr   r   r   r   __init__
   s    		z_InterruptHandler.__init__c             C   s{   t  j t  j  } | |  k	 r1 |  j | |  n  |  j rM |  j | |  n  d |  _ x t j   D] } | j   qc Wd  S)NT)r   	getsignalSIGINTr   r   _resultskeysstop)r   ZsignumZframeZinstalled_handlerresultr   r   r   __call__   s    		z_InterruptHandler.__call__N)__name__
__module____qualname__r   r   r   r   r   r   r   	   s   r   c             C   s   d t  |  <d  S)N   )r   )r   r   r   r   registerResult*   s    r   c             C   s   t  t j |  d    S)N)boolr   pop)r   r   r   r   removeResult-   s    r    c              C   sD   t  d  k r@ t j t j  }  t |   a  t j t j t   n  d  S)N)_interrupt_handlerr   r   r   r   )r   r   r   r   installHandler1   s    r"   c                sW     d  k	 r. t       f d d    } | St d  k	 rS t j t j t j  n  d  S)Nc                 sE   t  j t  j  } t   z   |  |   SWd  t  j  t  j |  Xd  S)N)r   r   r   removeHandler)argskwargsinitial)methodr   r   inner;   s
    zremoveHandler.<locals>.inner)r   r!   r   r   r   )r'   r(   r   )r'   r   r#   9   s
    r#   )r   weakref	functoolsr   Z
__unittestobjectr   WeakKeyDictionaryr   r   r    r!   r"   r#   r   r   r   r   <module>   s                                                                                                                                                                                           usr/lib/python3.4/unittest/__pycache__/suite.cpython-34.pyc                                         0100644 0000000 0000000 00000023560 13077704336 022256  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T-)                 @   s   d  Z  d d l Z d d l m Z d d l m Z d Z d d   Z Gd	 d
   d
 e  Z Gd d    d  e  Z	 Gd d   d e  Z
 d d   Z Gd d   d e  Z d S)	TestSuite    N   )case)utilTc             C   s#   t  |  | d d    } |   d  S)Nc               S   s   d  S)N r   r   r   $/usr/lib/python3.4/unittest/suite.py<lambda>   s    z!_call_if_exists.<locals>.<lambda>)getattr)parentattrfuncr   r   r   _call_if_exists   s    r   c               @   s   e  Z d  Z d Z d Z f  d d  Z d d   Z d d   Z d	 d
   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S)BaseTestSuitezNA simple test suite that doesn't provide class or module shared fixtures.
    Tc             C   s#   g  |  _  d |  _ |  j |  d  S)Nr   )_tests_removed_testsaddTests)selftestsr   r   r   __init__   s    		zBaseTestSuite.__init__c             C   s    d t  j |  j  t |   f S)Nz<%s tests=%s>)r   strclass	__class__list)r   r   r   r   __repr__   s    zBaseTestSuite.__repr__c             C   s,   t  | |  j  s t St |   t |  k S)N)
isinstancer   NotImplementedr   )r   otherr   r   r   __eq__   s    zBaseTestSuite.__eq__c             C   s   |  | k S)Nr   )r   r   r   r   r   __ne__"   s    zBaseTestSuite.__ne__c             C   s   t  |  j  S)N)iterr   )r   r   r   r   __iter__%   s    zBaseTestSuite.__iter__c             C   s7   |  j  } x' |  D] } | r | | j   7} q q W| S)N)r   countTestCases)r   Zcasestestr   r   r   r    (   s
    	zBaseTestSuite.countTestCasesc             C   st   t  |  s* t d j t |     n  t | t  r` t | t j t	 f  r` t d   n  |  j
 j |  d  S)Nz{} is not callablezNTestCases and TestSuites must be instantiated before passing them to addTest())callable	TypeErrorformatreprr   type
issubclassr   ZTestCaser   r   append)r   r!   r   r   r   addTest/   s    zBaseTestSuite.addTestc             C   s@   t  | t  r t d   n  x | D] } |  j |  q% Wd  S)Nz0tests must be an iterable of tests, not a string)r   strr#   r)   )r   r   r!   r   r   r   r   9   s    zBaseTestSuite.addTestsc             C   sQ   xJ t  |   D]< \ } } | j r& Pn  | |  |  j r |  j |  q q W| S)N)	enumerate
shouldStop_cleanup_removeTestAtIndex)r   resultindexr!   r   r   r   run?   s    	
	zBaseTestSuite.runc             C   s^   y |  j  | } Wn t k
 r% Yn5 Xt | d  rM |  j | j   7_ n  d |  j  | <d S)z2Stop holding a reference to the TestCase at index.r    N)r   r#   hasattrr   r    )r   r0   r!   r   r   r   r.   H   s    z BaseTestSuite._removeTestAtIndexc             O   s   |  j  | |   S)N)r1   )r   argskwdsr   r   r   __call__V   s    zBaseTestSuite.__call__c             C   s   x |  D] } | j    q Wd S)z7Run the tests without collecting errors in a TestResultN)debug)r   r!   r   r   r   r6   Y   s    zBaseTestSuite.debugN)__name__
__module____qualname____doc__r-   r   r   r   r   r   r    r)   r   r1   r.   r5   r6   r   r   r   r   r      s   
	r   c               @   sy   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d S)r   a  A test suite is a composite test consisting of a number of TestCases.

    For use, create an instance of TestSuite, then add test case instances.
    When all tests have been added, the suite can be passed to a test
    runner, such as TextTestRunner. It will run the individual test cases
    in the order in which they were added, aggregating the results. When
    subclassing, do not forget to call the base class constructor.
    Fc             C   s9  d } t  | d d  d k r. d | _ } n  x t |   D] \ } } | j rT Pn  t |  r |  j | |  |  j | |  |  j | |  | j | _	 t  | j d d  s; t  | d d  r q; q n  | s | |  n
 | j
   |  j r; |  j |  q; q; W| r5|  j d  |  |  j |  d | _ n  | S)NF_testRunEnteredT_classSetupFailed_moduleSetUpFailed)r	   r;   r+   r,   _isnotsuite_tearDownPreviousClass_handleModuleFixture_handleClassSetUpr   _previousTestClassr6   r-   r.   _handleModuleTearDown)r   r/   r6   ZtopLevelr0   r!   r   r   r   r1   i   s0    		
	zTestSuite.runc             C   s   t    } |  j | d  d S)z7Run the tests without collecting errors in a TestResultTN)_DebugResultr1   )r   r6   r   r   r   r6      s    	zTestSuite.debugc       	       C   s4  t  | d d   } | j } | | k r+ d  S| j r8 d  St  | d d  rN d  Sy d | _ Wn t k
 ro Yn Xt  | d d   } | d  k	 r0t | d  z y |   Wno t k
 r} zO t | t  r   n  d | _ t	 j
 |  } d | } |  j | | |  WYd  d  } ~ Xn XWd  t | d  Xn  d  S)	NrB   __unittest_skip__F
setUpClass_setupStdoutTzsetUpClass (%s)_restoreStdout)r	   r   r=   r<   r#   r   	Exceptionr   rD   r   r   _addClassOrModuleLevelException)	r   r!   r/   previousClasscurrentClassrF   e	className	errorNamer   r   r   rA      s2    			
*zTestSuite._handleClassSetUpc             C   s4   d  } t  | d d   } | d  k	 r0 | j } n  | S)NrB   )r	   r8   )r   r/   previousModulerK   r   r   r   _get_previous_module   s
    zTestSuite._get_previous_modulec       	       C   s   |  j  |  } | j j } | | k r+ d  S|  j |  d | _ y t j | } Wn t k
 rj d  SYn Xt | d d   } | d  k	 rt	 | d  zr y |   Wn` t
 k
 r} z@ t | t  r   n  d | _ d | } |  j | | |  WYd  d  } ~ Xn XWd  t	 | d  Xn  d  S)NFsetUpModulerG   TzsetUpModule (%s)rH   )rQ   r   r8   rC   r=   sysmodulesKeyErrorr	   r   rI   r   rD   rJ   )	r   r!   r/   rP   ZcurrentModulemodulerR   rM   rO   r   r   r   r@      s,    			
*zTestSuite._handleModuleFixturec             C   sl   t  |  } t | d d   } | d  k	 rR t | t j  rR | | t |   n | j | t j    d  S)NaddSkip)	_ErrorHolderr	   r   r   ZSkipTestr*   ZaddErrorrS   exc_info)r   r/   Z	exceptionrO   errorrW   r   r   r   rJ      s
    z)TestSuite._addClassOrModuleLevelExceptionc              C   s  |  j  |  } | d  k r d  S| j r, d  Sy t j | } Wn t k
 rU d  SYn Xt | d d   } | d  k	 r t | d  zi y |   WnW t k
 r } z7 t | t	  r   n  d | } |  j
 | | |  WYd  d  } ~ Xn XWd  t | d  Xn  d  S)NtearDownModulerG   ztearDownModule (%s)rH   )rQ   r=   rS   rT   rU   r	   r   rI   r   rD   rJ   )r   r/   rP   rV   r[   rM   rO   r   r   r   rC      s(    		
*zTestSuite._handleModuleTearDownc       	      C   s(  t  | d d   } | j } | | k r+ d  St  | d d  rA d  St  | d d  rW d  St  | d d  rm d  St  | d d   } | d  k	 r$t | d  zx y |   Wnf t k
 r} zF t | t  r   n  t j |  } d | } |  j | | |  WYd  d  } ~ Xn XWd  t | d	  Xn  d  S)
NrB   r<   Fr=   rE   tearDownClassrG   ztearDownClass (%s)rH   )	r	   r   r   rI   r   rD   r   r   rJ   )	r   r!   r/   rK   rL   r\   rM   rN   rO   r   r   r   r?      s,    	
*z TestSuite._tearDownPreviousClassN)r7   r8   r9   r:   r1   r6   rA   rQ   r@   rJ   rC   r?   r   r   r   r   r   _   s   ! c               @   s|   e  Z d  Z d Z d Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z	 d d   Z
 d d   Z d d   Z d S)rX   z
    Placeholder for a TestCase inside a result. As far as a TestResult
    is concerned, this looks exactly like a unit test. Used to insert
    arbitrary errors into a test suite run.
    Nc             C   s   | |  _  d  S)N)description)r   r]   r   r   r   r     s    z_ErrorHolder.__init__c             C   s   |  j  S)N)r]   )r   r   r   r   id   s    z_ErrorHolder.idc             C   s   d  S)Nr   )r   r   r   r   shortDescription#  s    z_ErrorHolder.shortDescriptionc             C   s   d |  j  f S)Nz<ErrorHolder description=%r>)r]   )r   r   r   r   r   &  s    z_ErrorHolder.__repr__c             C   s
   |  j    S)N)r^   )r   r   r   r   __str__)  s    z_ErrorHolder.__str__c             C   s   d  S)Nr   )r   r/   r   r   r   r1   ,  s    z_ErrorHolder.runc             C   s   |  j  |  S)N)r1   )r   r/   r   r   r   r5   1  s    z_ErrorHolder.__call__c             C   s   d S)Nr   r   )r   r   r   r   r    4  s    z_ErrorHolder.countTestCases)r7   r8   r9   r:   ZfailureExceptionr   r^   r_   r   r`   r1   r5   r    r   r   r   r   rX     s   rX   c             C   s+   y t  |   Wn t k
 r& d SYn Xd S)z?A crude way to tell apart testcases and suites with duck-typingTF)r   r#   )r!   r   r   r   r>   7  s
    	r>   c               @   s(   e  Z d  Z d Z d Z d Z d Z d S)rD   zCUsed by the TestSuite to hold previous class when running in debug.NF)r7   r8   r9   r:   rB   r=   r,   r   r   r   r   rD   @  s   rD   )r:   rS    r   r   Z
__unittestr   objectr   r   rX   r>   rD   r   r   r   r   <module>   s   O&	                                                                                                                                                usr/lib/python3.4/unittest/__pycache__/util.cpython-34.pyc                                          0100644 0000000 0000000 00000012162 13077704336 022076  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T5                 @   s
  d  Z  d d l m Z m Z d d l m Z d Z d Z d Z d Z	 d Z
 d Z e e	 e e e e
 Z e d k s| t  d d	   Z d
 d   Z d d d  Z d d   Z d d   Z d d   Z d d   Z e d d  Z d d   Z d d   Z d d   Z d S) zVarious utility functions.    )
namedtupleOrderedDict)commonprefixTP         c             C   sX   t  |   | | } | t k rT d |  d  |  | |  t  |   | d   f }  n  |  S)Nz%s[%d chars]%s)len_PLACEHOLDER_LEN)s	prefixlenZ	suffixlenskip r   #/usr/lib/python3.4/unittest/util.py_shorten   s    4r   c                 s   t  t t |    }  t t t |    } | t k r: |  St |     t     t |  t t } | t	 k r t t t	 |  t k  s t
  t   t |    t     f d d   |  D  St   t t	    t     f d d   |  D  S)Nc             3   s#   |  ] }   |  d   Vq d  S)Nr   ).0r
   )prefixr   r   r   	<genexpr>'   s    z'_common_shorten_repr.<locals>.<genexpr>c             3   s/   |  ]% }   t  |  d   t t  Vq d  S)N)r   _MIN_DIFF_LEN_MIN_END_LEN)r   r
   )r   r   r   r   r   *   s   )tuplemap	safe_reprmaxr   _MAX_LENGTHr   _MIN_BEGIN_LENr	   _MIN_COMMON_LENAssertionErrorr   )argsmaxlenZ
common_lenr   )r   r   r   _common_shorten_repr   s      r   Fc             C   sc   y t  |   } Wn! t k
 r3 t j |   } Yn X| sM t |  t k  rQ | S| d  t  d S)Nz [truncated]...)repr	Exceptionobject__repr__r   r   )objZshortresultr   r   r   r   -   s    r   c             C   s   d |  j  |  j f S)Nz%s.%s)
__module____name__)clsr   r   r   strclass6   s    r)   c             C   sn  d } } g  } g  } xKy|  | } | | } | | k  rw | j  |  | d 7} x |  | | k rs | d 7} qV Wn | | k r | j  |  | d 7} x | | | k r | d 7} q Wn^ | d 7} z% x |  | | k r | d 7} q WWd | d 7} x | | | k r| d 7} q WXWq t k
 r`| j |  | d   | j | | d   PYq Xq | | f S)ar  Finds elements in only one or the other of two, sorted input lists.

    Returns a two-element tuple of lists.    The first list contains those
    elements in the "expected" list but not in the "actual" list, and the
    second contains those elements in the "actual" list but not in the
    "expected" list.    Duplicate elements in either input list are ignored.
    r      N)append
IndexErrorextend)expectedactualijmissingZ
unexpectedear   r   r   sorted_list_difference9   s:    






	r5   c             C   s\   g  } xI |  rQ |  j    } y | j |  Wq	 t k
 rM | j |  Yq	 Xq	 W| | f S)zSame behavior as sorted_list_difference but
    for lists of unorderable items (like dicts).

    As it does a linear search per item (remove) it
    has O(n*n) performance.)popremove
ValueErrorr+   )r.   r/   r2   itemr   r   r   unorderable_list_differenceb   s    	r:   c             C   s   |  | k |  | k  S)z.Return -1 if x < y, 0 if x == y and 1 if x > yr   )xyr   r   r   three_way_cmps   s    r=   ZMismatchzactual expected valuec             C   s  t  |   t  |  } } t |  t |  } } t   } g  } x t |  D] \ } }	 |	 | k rl qN n  d }
 } x> t | |  D]- } | | |	 k r |
 d 7}
 | | | <q q Wx= t |  D]/ \ } } | |	 k r | d 7} | | | <q q W|
 | k rN t |
 | |	  } | j |  qN qN Wx t |  D] \ } }	 |	 | k rTq6n  d } x> t | |  D]- } | | |	 k rj| d 7} | | | <qjqjWt d | |	  } | j |  q6W| S)zHReturns list of (cnt_act, cnt_exp, elem) triples where the counts differr   r*   )listr   r"   	enumeraterange	_Mismatchr+   )r/   r.   r
   tmnZNULLr%   r0   elemcnt_scnt_tr1   Z
other_elemdiffr   r   r   _count_diff_all_purposey   s<    	



rI   c             C   s8   t    } x( |  D]  } | j | d  d | | <q W| S)z@Return dict of element counts, in the order they were first seenr   r*   )r   get)iterablecrE   r   r   r   _ordered_count   s    	rM   c       	      C   s   t  |   t  |  } } g  } xZ | j   D]L \ } } | j | d  } | | k r, t | | |  } | j |  q, q, WxH | j   D]: \ } } | | k r t d | |  } | j |  q q W| S)zHReturns list of (cnt_act, cnt_exp, elem) triples where the counts differr   )rM   itemsrJ   rA   r+   )	r/   r.   r
   rB   r%   rE   rF   rG   rH   r   r   r   _count_diff_hashable   s    rO   N)__doc__collectionsr   r   os.pathr   Z
__unittestr   r	   r   r   r   r   r   r   r   r   r)   r5   r:   r=   rA   rI   rM   rO   r   r   r   r   <module>   s,   	)#                                                                                                                                                                                                                                                                                                                                                                                                              usr/lib/python3.4/unittest/case.py                                                                  0100644 0000000 0000000 00000154337 12415221640 015550  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Test case implementation"""

import sys
import functools
import difflib
import logging
import pprint
import re
import warnings
import collections
import contextlib
import traceback

from . import result
from .util import (strclass, safe_repr, _count_diff_all_purpose,
                   _count_diff_hashable, _common_shorten_repr)

__unittest = True


DIFF_OMITTED = ('\nDiff is %s characters long. '
                 'Set self.maxDiff to None to see it.')

class SkipTest(Exception):
    """
    Raise this exception in a test to skip it.

    Usually you can use TestCase.skipTest() or one of the skipping decorators
    instead of raising this directly.
    """

class _ShouldStop(Exception):
    """
    The test should stop.
    """

class _UnexpectedSuccess(Exception):
    """
    The test was supposed to fail, but it didn't!
    """


class _Outcome(object):
    def __init__(self, result=None):
        self.expecting_failure = False
        self.result = result
        self.result_supports_subtests = hasattr(result, "addSubTest")
        self.success = True
        self.skipped = []
        self.expectedFailure = None
        self.errors = []

    @contextlib.contextmanager
    def testPartExecutor(self, test_case, isTest=False):
        old_success = self.success
        self.success = True
        try:
            yield
        except KeyboardInterrupt:
            raise
        except SkipTest as e:
            self.success = False
            self.skipped.append((test_case, str(e)))
        except _ShouldStop:
            pass
        except:
            exc_info = sys.exc_info()
            if self.expecting_failure:
                self.expectedFailure = exc_info
            else:
                self.success = False
                self.errors.append((test_case, exc_info))
            # explicitly break a reference cycle:
            # exc_info -> frame -> exc_info
            exc_info = None
        else:
            if self.result_supports_subtests and self.success:
                self.errors.append((test_case, None))
        finally:
            self.success = self.success and old_success


def _id(obj):
    return obj

def skip(reason):
    """
    Unconditionally skip a test.
    """
    def decorator(test_item):
        if not isinstance(test_item, type):
            @functools.wraps(test_item)
            def skip_wrapper(*args, **kwargs):
                raise SkipTest(reason)
            test_item = skip_wrapper

        test_item.__unittest_skip__ = True
        test_item.__unittest_skip_why__ = reason
        return test_item
    return decorator

def skipIf(condition, reason):
    """
    Skip a test if the condition is true.
    """
    if condition:
        return skip(reason)
    return _id

def skipUnless(condition, reason):
    """
    Skip a test unless the condition is true.
    """
    if not condition:
        return skip(reason)
    return _id

def expectedFailure(test_item):
    test_item.__unittest_expecting_failure__ = True
    return test_item


class _BaseTestCaseContext:

    def __init__(self, test_case):
        self.test_case = test_case

    def _raiseFailure(self, standardMsg):
        msg = self.test_case._formatMessage(self.msg, standardMsg)
        raise self.test_case.failureException(msg)


class _AssertRaisesBaseContext(_BaseTestCaseContext):

    def __init__(self, expected, test_case, callable_obj=None,
                 expected_regex=None):
        _BaseTestCaseContext.__init__(self, test_case)
        self.expected = expected
        self.test_case = test_case
        if callable_obj is not None:
            try:
                self.obj_name = callable_obj.__name__
            except AttributeError:
                self.obj_name = str(callable_obj)
        else:
            self.obj_name = None
        if expected_regex is not None:
            expected_regex = re.compile(expected_regex)
        self.expected_regex = expected_regex
        self.msg = None

    def handle(self, name, callable_obj, args, kwargs):
        """
        If callable_obj is None, assertRaises/Warns is being used as a
        context manager, so check for a 'msg' kwarg and return self.
        If callable_obj is not None, call it passing args and kwargs.
        """
        if callable_obj is None:
            self.msg = kwargs.pop('msg', None)
            return self
        with self:
            callable_obj(*args, **kwargs)


class _AssertRaisesContext(_AssertRaisesBaseContext):
    """A context manager used to implement TestCase.assertRaises* methods."""

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, tb):
        if exc_type is None:
            try:
                exc_name = self.expected.__name__
            except AttributeError:
                exc_name = str(self.expected)
            if self.obj_name:
                self._raiseFailure("{} not raised by {}".format(exc_name,
                                                                self.obj_name))
            else:
                self._raiseFailure("{} not raised".format(exc_name))
        else:
            traceback.clear_frames(tb)
        if not issubclass(exc_type, self.expected):
            # let unexpected exceptions pass through
            return False
        # store exception, without traceback, for later retrieval
        self.exception = exc_value.with_traceback(None)
        if self.expected_regex is None:
            return True

        expected_regex = self.expected_regex
        if not expected_regex.search(str(exc_value)):
            self._raiseFailure('"{}" does not match "{}"'.format(
                     expected_regex.pattern, str(exc_value)))
        return True


class _AssertWarnsContext(_AssertRaisesBaseContext):
    """A context manager used to implement TestCase.assertWarns* methods."""

    def __enter__(self):
        # The __warningregistry__'s need to be in a pristine state for tests
        # to work properly.
        for v in sys.modules.values():
            if getattr(v, '__warningregistry__', None):
                v.__warningregistry__ = {}
        self.warnings_manager = warnings.catch_warnings(record=True)
        self.warnings = self.warnings_manager.__enter__()
        warnings.simplefilter("always", self.expected)
        return self

    def __exit__(self, exc_type, exc_value, tb):
        self.warnings_manager.__exit__(exc_type, exc_value, tb)
        if exc_type is not None:
            # let unexpected exceptions pass through
            return
        try:
            exc_name = self.expected.__name__
        except AttributeError:
            exc_name = str(self.expected)
        first_matching = None
        for m in self.warnings:
            w = m.message
            if not isinstance(w, self.expected):
                continue
            if first_matching is None:
                first_matching = w
            if (self.expected_regex is not None and
                not self.expected_regex.search(str(w))):
                continue
            # store warning for later retrieval
            self.warning = w
            self.filename = m.filename
            self.lineno = m.lineno
            return
        # Now we simply try to choose a helpful failure message
        if first_matching is not None:
            self._raiseFailure('"{}" does not match "{}"'.format(
                     self.expected_regex.pattern, str(first_matching)))
        if self.obj_name:
            self._raiseFailure("{} not triggered by {}".format(exc_name,
                                                               self.obj_name))
        else:
            self._raiseFailure("{} not triggered".format(exc_name))



_LoggingWatcher = collections.namedtuple("_LoggingWatcher",
                                         ["records", "output"])


class _CapturingHandler(logging.Handler):
    """
    A logging handler capturing all (raw and formatted) logging output.
    """

    def __init__(self):
        logging.Handler.__init__(self)
        self.watcher = _LoggingWatcher([], [])

    def flush(self):
        pass

    def emit(self, record):
        self.watcher.records.append(record)
        msg = self.format(record)
        self.watcher.output.append(msg)



class _AssertLogsContext(_BaseTestCaseContext):
    """A context manager used to implement TestCase.assertLogs()."""

    LOGGING_FORMAT = "%(levelname)s:%(name)s:%(message)s"

    def __init__(self, test_case, logger_name, level):
        _BaseTestCaseContext.__init__(self, test_case)
        self.logger_name = logger_name
        if level:
            self.level = logging._nameToLevel.get(level, level)
        else:
            self.level = logging.INFO
        self.msg = None

    def __enter__(self):
        if isinstance(self.logger_name, logging.Logger):
            logger = self.logger = self.logger_name
        else:
            logger = self.logger = logging.getLogger(self.logger_name)
        formatter = logging.Formatter(self.LOGGING_FORMAT)
        handler = _CapturingHandler()
        handler.setFormatter(formatter)
        self.watcher = handler.watcher
        self.old_handlers = logger.handlers[:]
        self.old_level = logger.level
        self.old_propagate = logger.propagate
        logger.handlers = [handler]
        logger.setLevel(self.level)
        logger.propagate = False
        return handler.watcher

    def __exit__(self, exc_type, exc_value, tb):
        self.logger.handlers = self.old_handlers
        self.logger.propagate = self.old_propagate
        self.logger.setLevel(self.old_level)
        if exc_type is not None:
            # let unexpected exceptions pass through
            return False
        if len(self.watcher.records) == 0:
            self._raiseFailure(
                "no logs of level {} or higher triggered on {}"
                .format(logging.getLevelName(self.level), self.logger.name))


class TestCase(object):
    """A class whose instances are single test cases.

    By default, the test code itself should be placed in a method named
    'runTest'.

    If the fixture may be used for many test cases, create as
    many test methods as are needed. When instantiating such a TestCase
    subclass, specify in the constructor arguments the name of the test method
    that the instance is to execute.

    Test authors should subclass TestCase for their own tests. Construction
    and deconstruction of the test's environment ('fixture') can be
    implemented by overriding the 'setUp' and 'tearDown' methods respectively.

    If it is necessary to override the __init__ method, the base class
    __init__ method must always be called. It is important that subclasses
    should not change the signature of their __init__ method, since instances
    of the classes are instantiated automatically by parts of the framework
    in order to be run.

    When subclassing TestCase, you can set these attributes:
    * failureException: determines which exception will be raised when
        the instance's assertion methods fail; test methods raising this
        exception will be deemed to have 'failed' rather than 'errored'.
    * longMessage: determines whether long messages (including repr of
        objects used in assert methods) will be printed on failure in *addition*
        to any explicit message passed.
    * maxDiff: sets the maximum length of a diff in failure messages
        by assert methods using difflib. It is looked up as an instance
        attribute so can be configured by individual tests if required.
    """

    failureException = AssertionError

    longMessage = True

    maxDiff = 80*8

    # If a string is longer than _diffThreshold, use normal comparison instead
    # of difflib.  See #11763.
    _diffThreshold = 2**16

    # Attribute used by TestSuite for classSetUp

    _classSetupFailed = False

    def __init__(self, methodName='runTest'):
        """Create an instance of the class that will use the named test
           method when executed. Raises a ValueError if the instance does
           not have a method with the specified name.
        """
        self._testMethodName = methodName
        self._outcome = None
        self._testMethodDoc = 'No test'
        try:
            testMethod = getattr(self, methodName)
        except AttributeError:
            if methodName != 'runTest':
                # we allow instantiation with no explicit method name
                # but not an *incorrect* or missing method name
                raise ValueError("no such test method in %s: %s" %
                      (self.__class__, methodName))
        else:
            self._testMethodDoc = testMethod.__doc__
        self._cleanups = []
        self._subtest = None

        # Map types to custom assertEqual functions that will compare
        # instances of said type in more detail to generate a more useful
        # error message.
        self._type_equality_funcs = {}
        self.addTypeEqualityFunc(dict, 'assertDictEqual')
        self.addTypeEqualityFunc(list, 'assertListEqual')
        self.addTypeEqualityFunc(tuple, 'assertTupleEqual')
        self.addTypeEqualityFunc(set, 'assertSetEqual')
        self.addTypeEqualityFunc(frozenset, 'assertSetEqual')
        self.addTypeEqualityFunc(str, 'assertMultiLineEqual')

    def addTypeEqualityFunc(self, typeobj, function):
        """Add a type specific assertEqual style function to compare a type.

        This method is for use by TestCase subclasses that need to register
        their own type equality functions to provide nicer error messages.

        Args:
            typeobj: The data type to call this function on when both values
                    are of the same type in assertEqual().
            function: The callable taking two arguments and an optional
                    msg= argument that raises self.failureException with a
                    useful error message when the two arguments are not equal.
        """
        self._type_equality_funcs[typeobj] = function

    def addCleanup(self, function, *args, **kwargs):
        """Add a function, with arguments, to be called when the test is
        completed. Functions added are called on a LIFO basis and are
        called after tearDown on test failure or success.

        Cleanup items are called even if setUp fails (unlike tearDown)."""
        self._cleanups.append((function, args, kwargs))

    def setUp(self):
        "Hook method for setting up the test fixture before exercising it."
        pass

    def tearDown(self):
        "Hook method for deconstructing the test fixture after testing it."
        pass

    @classmethod
    def setUpClass(cls):
        "Hook method for setting up class fixture before running tests in the class."

    @classmethod
    def tearDownClass(cls):
        "Hook method for deconstructing the class fixture after running all tests in the class."

    def countTestCases(self):
        return 1

    def defaultTestResult(self):
        return result.TestResult()

    def shortDescription(self):
        """Returns a one-line description of the test, or None if no
        description has been provided.

        The default implementation of this method returns the first line of
        the specified test method's docstring.
        """
        doc = self._testMethodDoc
        return doc and doc.split("\n")[0].strip() or None


    def id(self):
        return "%s.%s" % (strclass(self.__class__), self._testMethodName)

    def __eq__(self, other):
        if type(self) is not type(other):
            return NotImplemented

        return self._testMethodName == other._testMethodName

    def __hash__(self):
        return hash((type(self), self._testMethodName))

    def __str__(self):
        return "%s (%s)" % (self._testMethodName, strclass(self.__class__))

    def __repr__(self):
        return "<%s testMethod=%s>" % \
               (strclass(self.__class__), self._testMethodName)

    def _addSkip(self, result, test_case, reason):
        addSkip = getattr(result, 'addSkip', None)
        if addSkip is not None:
            addSkip(test_case, reason)
        else:
            warnings.warn("TestResult has no addSkip method, skips not reported",
                          RuntimeWarning, 2)
            result.addSuccess(test_case)

    @contextlib.contextmanager
    def subTest(self, msg=None, **params):
        """Return a context manager that will return the enclosed block
        of code in a subtest identified by the optional message and
        keyword parameters.  A failure in the subtest marks the test
        case as failed but resumes execution at the end of the enclosed
        block, allowing further test code to be executed.
        """
        if not self._outcome.result_supports_subtests:
            yield
            return
        parent = self._subtest
        if parent is None:
            params_map = collections.ChainMap(params)
        else:
            params_map = parent.params.new_child(params)
        self._subtest = _SubTest(self, msg, params_map)
        try:
            with self._outcome.testPartExecutor(self._subtest, isTest=True):
                yield
            if not self._outcome.success:
                result = self._outcome.result
                if result is not None and result.failfast:
                    raise _ShouldStop
            elif self._outcome.expectedFailure:
                # If the test is expecting a failure, we really want to
                # stop now and register the expected failure.
                raise _ShouldStop
        finally:
            self._subtest = parent

    def _feedErrorsToResult(self, result, errors):
        for test, exc_info in errors:
            if isinstance(test, _SubTest):
                result.addSubTest(test.test_case, test, exc_info)
            elif exc_info is not None:
                if issubclass(exc_info[0], self.failureException):
                    result.addFailure(test, exc_info)
                else:
                    result.addError(test, exc_info)

    def _addExpectedFailure(self, result, exc_info):
        try:
            addExpectedFailure = result.addExpectedFailure
        except AttributeError:
            warnings.warn("TestResult has no addExpectedFailure method, reporting as passes",
                          RuntimeWarning)
            result.addSuccess(self)
        else:
            addExpectedFailure(self, exc_info)

    def _addUnexpectedSuccess(self, result):
        try:
            addUnexpectedSuccess = result.addUnexpectedSuccess
        except AttributeError:
            warnings.warn("TestResult has no addUnexpectedSuccess method, reporting as failure",
                          RuntimeWarning)
            # We need to pass an actual exception and traceback to addFailure,
            # otherwise the legacy result can choke.
            try:
                raise _UnexpectedSuccess from None
            except _UnexpectedSuccess:
                result.addFailure(self, sys.exc_info())
        else:
            addUnexpectedSuccess(self)

    def run(self, result=None):
        orig_result = result
        if result is None:
            result = self.defaultTestResult()
            startTestRun = getattr(result, 'startTestRun', None)
            if startTestRun is not None:
                startTestRun()

        result.startTest(self)

        testMethod = getattr(self, self._testMethodName)
        if (getattr(self.__class__, "__unittest_skip__", False) or
            getattr(testMethod, "__unittest_skip__", False)):
            # If the class or method was skipped.
            try:
                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')
                            or getattr(testMethod, '__unittest_skip_why__', ''))
                self._addSkip(result, self, skip_why)
            finally:
                result.stopTest(self)
            return
        expecting_failure = getattr(testMethod,
                                    "__unittest_expecting_failure__", False)
        outcome = _Outcome(result)
        try:
            self._outcome = outcome

            with outcome.testPartExecutor(self):
                self.setUp()
            if outcome.success:
                outcome.expecting_failure = expecting_failure
                with outcome.testPartExecutor(self, isTest=True):
                    testMethod()
                outcome.expecting_failure = False
                with outcome.testPartExecutor(self):
                    self.tearDown()

            self.doCleanups()
            for test, reason in outcome.skipped:
                self._addSkip(result, test, reason)
            self._feedErrorsToResult(result, outcome.errors)
            if outcome.success:
                if expecting_failure:
                    if outcome.expectedFailure:
                        self._addExpectedFailure(result, outcome.expectedFailure)
                    else:
                        self._addUnexpectedSuccess(result)
                else:
                    result.addSuccess(self)
            return result
        finally:
            result.stopTest(self)
            if orig_result is None:
                stopTestRun = getattr(result, 'stopTestRun', None)
                if stopTestRun is not None:
                    stopTestRun()

            # explicitly break reference cycles:
            # outcome.errors -> frame -> outcome -> outcome.errors
            # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure
            outcome.errors.clear()
            outcome.expectedFailure = None

            # clear the outcome, no more needed
            self._outcome = None

    def doCleanups(self):
        """Execute all cleanup functions. Normally called for you after
        tearDown."""
        outcome = self._outcome or _Outcome()
        while self._cleanups:
            function, args, kwargs = self._cleanups.pop()
            with outcome.testPartExecutor(self):
                function(*args, **kwargs)

        # return this for backwards compatibility
        # even though we no longer us it internally
        return outcome.success

    def __call__(self, *args, **kwds):
        return self.run(*args, **kwds)

    def debug(self):
        """Run the test without collecting errors in a TestResult"""
        self.setUp()
        getattr(self, self._testMethodName)()
        self.tearDown()
        while self._cleanups:
            function, args, kwargs = self._cleanups.pop(-1)
            function(*args, **kwargs)

    def skipTest(self, reason):
        """Skip this test."""
        raise SkipTest(reason)

    def fail(self, msg=None):
        """Fail immediately, with the given message."""
        raise self.failureException(msg)

    def assertFalse(self, expr, msg=None):
        """Check that the expression is false."""
        if expr:
            msg = self._formatMessage(msg, "%s is not false" % safe_repr(expr))
            raise self.failureException(msg)

    def assertTrue(self, expr, msg=None):
        """Check that the expression is true."""
        if not expr:
            msg = self._formatMessage(msg, "%s is not true" % safe_repr(expr))
            raise self.failureException(msg)

    def _formatMessage(self, msg, standardMsg):
        """Honour the longMessage attribute when generating failure messages.
        If longMessage is False this means:
        * Use only an explicit message if it is provided
        * Otherwise use the standard message for the assert

        If longMessage is True:
        * Use the standard message
        * If an explicit message is provided, plus ' : ' and the explicit message
        """
        if not self.longMessage:
            return msg or standardMsg
        if msg is None:
            return standardMsg
        try:
            # don't switch to '{}' formatting in Python 2.X
            # it changes the way unicode input is handled
            return '%s : %s' % (standardMsg, msg)
        except UnicodeDecodeError:
            return  '%s : %s' % (safe_repr(standardMsg), safe_repr(msg))

    def assertRaises(self, excClass, callableObj=None, *args, **kwargs):
        """Fail unless an exception of class excClass is raised
           by callableObj when invoked with arguments args and keyword
           arguments kwargs. If a different type of exception is
           raised, it will not be caught, and the test case will be
           deemed to have suffered an error, exactly as for an
           unexpected exception.

           If called with callableObj omitted or None, will return a
           context object used like this::

                with self.assertRaises(SomeException):
                    do_something()

           An optional keyword argument 'msg' can be provided when assertRaises
           is used as a context object.

           The context manager keeps a reference to the exception as
           the 'exception' attribute. This allows you to inspect the
           exception after the assertion::

               with self.assertRaises(SomeException) as cm:
                   do_something()
               the_exception = cm.exception
               self.assertEqual(the_exception.error_code, 3)
        """
        context = _AssertRaisesContext(excClass, self, callableObj)
        return context.handle('assertRaises', callableObj, args, kwargs)

    def assertWarns(self, expected_warning, callable_obj=None, *args, **kwargs):
        """Fail unless a warning of class warnClass is triggered
           by callable_obj when invoked with arguments args and keyword
           arguments kwargs.  If a different type of warning is
           triggered, it will not be handled: depending on the other
           warning filtering rules in effect, it might be silenced, printed
           out, or raised as an exception.

           If called with callable_obj omitted or None, will return a
           context object used like this::

                with self.assertWarns(SomeWarning):
                    do_something()

           An optional keyword argument 'msg' can be provided when assertWarns
           is used as a context object.

           The context manager keeps a reference to the first matching
           warning as the 'warning' attribute; similarly, the 'filename'
           and 'lineno' attributes give you information about the line
           of Python code from which the warning was triggered.
           This allows you to inspect the warning after the assertion::

               with self.assertWarns(SomeWarning) as cm:
                   do_something()
               the_warning = cm.warning
               self.assertEqual(the_warning.some_attribute, 147)
        """
        context = _AssertWarnsContext(expected_warning, self, callable_obj)
        return context.handle('assertWarns', callable_obj, args, kwargs)

    def assertLogs(self, logger=None, level=None):
        """Fail unless a log message of level *level* or higher is emitted
        on *logger_name* or its children.  If omitted, *level* defaults to
        INFO and *logger* defaults to the root logger.

        This method must be used as a context manager, and will yield
        a recording object with two attributes: `output` and `records`.
        At the end of the context manager, the `output` attribute will
        be a list of the matching formatted log messages and the
        `records` attribute will be a list of the corresponding LogRecord
        objects.

        Example::

            with self.assertLogs('foo', level='INFO') as cm:
                logging.getLogger('foo').info('first message')
                logging.getLogger('foo.bar').error('second message')
            self.assertEqual(cm.output, ['INFO:foo:first message',
                                         'ERROR:foo.bar:second message'])
        """
        return _AssertLogsContext(self, logger, level)

    def _getAssertEqualityFunc(self, first, second):
        """Get a detailed comparison function for the types of the two args.

        Returns: A callable accepting (first, second, msg=None) that will
        raise a failure exception if first != second with a useful human
        readable error message for those types.
        """
        #
        # NOTE(gregory.p.smith): I considered isinstance(first, type(second))
        # and vice versa.  I opted for the conservative approach in case
        # subclasses are not intended to be compared in detail to their super
        # class instances using a type equality func.  This means testing
        # subtypes won't automagically use the detailed comparison.  Callers
        # should use their type specific assertSpamEqual method to compare
        # subclasses if the detailed comparison is desired and appropriate.
        # See the discussion in http://bugs.python.org/issue2578.
        #
        if type(first) is type(second):
            asserter = self._type_equality_funcs.get(type(first))
            if asserter is not None:
                if isinstance(asserter, str):
                    asserter = getattr(self, asserter)
                return asserter

        return self._baseAssertEqual

    def _baseAssertEqual(self, first, second, msg=None):
        """The default assertEqual implementation, not type specific."""
        if not first == second:
            standardMsg = '%s != %s' % _common_shorten_repr(first, second)
            msg = self._formatMessage(msg, standardMsg)
            raise self.failureException(msg)

    def assertEqual(self, first, second, msg=None):
        """Fail if the two objects are unequal as determined by the '=='
           operator.
        """
        assertion_func = self._getAssertEqualityFunc(first, second)
        assertion_func(first, second, msg=msg)

    def assertNotEqual(self, first, second, msg=None):
        """Fail if the two objects are equal as determined by the '!='
           operator.
        """
        if not first != second:
            msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first),
                                                          safe_repr(second)))
            raise self.failureException(msg)

    def assertAlmostEqual(self, first, second, places=None, msg=None,
                          delta=None):
        """Fail if the two objects are unequal as determined by their
           difference rounded to the given number of decimal places
           (default 7) and comparing to zero, or by comparing that the
           between the two objects is more than the given delta.

           Note that decimal places (from zero) are usually not the same
           as significant digits (measured from the most signficant digit).

           If the two objects compare equal then they will automatically
           compare almost equal.
        """
        if first == second:
            # shortcut
            return
        if delta is not None and places is not None:
            raise TypeError("specify delta or places not both")

        if delta is not None:
            if abs(first - second) <= delta:
                return

            standardMsg = '%s != %s within %s delta' % (safe_repr(first),
                                                        safe_repr(second),
                                                        safe_repr(delta))
        else:
            if places is None:
                places = 7

            if round(abs(second-first), places) == 0:
                return

            standardMsg = '%s != %s within %r places' % (safe_repr(first),
                                                          safe_repr(second),
                                                          places)
        msg = self._formatMessage(msg, standardMsg)
        raise self.failureException(msg)

    def assertNotAlmostEqual(self, first, second, places=None, msg=None,
                             delta=None):
        """Fail if the two objects are equal as determined by their
           difference rounded to the given number of decimal places
           (default 7) and comparing to zero, or by comparing that the
           between the two objects is less than the given delta.

           Note that decimal places (from zero) are usually not the same
           as significant digits (measured from the most signficant digit).

           Objects that are equal automatically fail.
        """
        if delta is not None and places is not None:
            raise TypeError("specify delta or places not both")
        if delta is not None:
            if not (first == second) and abs(first - second) > delta:
                return
            standardMsg = '%s == %s within %s delta' % (safe_repr(first),
                                                        safe_repr(second),
                                                        safe_repr(delta))
        else:
            if places is None:
                places = 7
            if not (first == second) and round(abs(second-first), places) != 0:
                return
            standardMsg = '%s == %s within %r places' % (safe_repr(first),
                                                         safe_repr(second),
                                                         places)

        msg = self._formatMessage(msg, standardMsg)
        raise self.failureException(msg)


    def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):
        """An equality assertion for ordered sequences (like lists and tuples).

        For the purposes of this function, a valid ordered sequence type is one
        which can be indexed, has a length, and has an equality operator.

        Args:
            seq1: The first sequence to compare.
            seq2: The second sequence to compare.
            seq_type: The expected datatype of the sequences, or None if no
                    datatype should be enforced.
            msg: Optional message to use on failure instead of a list of
                    differences.
        """
        if seq_type is not None:
            seq_type_name = seq_type.__name__
            if not isinstance(seq1, seq_type):
                raise self.failureException('First sequence is not a %s: %s'
                                        % (seq_type_name, safe_repr(seq1)))
            if not isinstance(seq2, seq_type):
                raise self.failureException('Second sequence is not a %s: %s'
                                        % (seq_type_name, safe_repr(seq2)))
        else:
            seq_type_name = "sequence"

        differing = None
        try:
            len1 = len(seq1)
        except (TypeError, NotImplementedError):
            differing = 'First %s has no length.    Non-sequence?' % (
                    seq_type_name)

        if differing is None:
            try:
                len2 = len(seq2)
            except (TypeError, NotImplementedError):
                differing = 'Second %s has no length.    Non-sequence?' % (
                        seq_type_name)

        if differing is None:
            if seq1 == seq2:
                return

            differing = '%ss differ: %s != %s\n' % (
                    (seq_type_name.capitalize(),) +
                    _common_shorten_repr(seq1, seq2))

            for i in range(min(len1, len2)):
                try:
                    item1 = seq1[i]
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('\nUnable to index element %d of first %s\n' %
                                 (i, seq_type_name))
                    break

                try:
                    item2 = seq2[i]
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('\nUnable to index element %d of second %s\n' %
                                 (i, seq_type_name))
                    break

                if item1 != item2:
                    differing += ('\nFirst differing element %d:\n%s\n%s\n' %
                                 (i, item1, item2))
                    break
            else:
                if (len1 == len2 and seq_type is None and
                    type(seq1) != type(seq2)):
                    # The sequences are the same, but have differing types.
                    return

            if len1 > len2:
                differing += ('\nFirst %s contains %d additional '
                             'elements.\n' % (seq_type_name, len1 - len2))
                try:
                    differing += ('First extra element %d:\n%s\n' %
                                  (len2, seq1[len2]))
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('Unable to index element %d '
                                  'of first %s\n' % (len2, seq_type_name))
            elif len1 < len2:
                differing += ('\nSecond %s contains %d additional '
                             'elements.\n' % (seq_type_name, len2 - len1))
                try:
                    differing += ('First extra element %d:\n%s\n' %
                                  (len1, seq2[len1]))
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('Unable to index element %d '
                                  'of second %s\n' % (len1, seq_type_name))
        standardMsg = differing
        diffMsg = '\n' + '\n'.join(
            difflib.ndiff(pprint.pformat(seq1).splitlines(),
                          pprint.pformat(seq2).splitlines()))

        standardMsg = self._truncateMessage(standardMsg, diffMsg)
        msg = self._formatMessage(msg, standardMsg)
        self.fail(msg)

    def _truncateMessage(self, message, diff):
        max_diff = self.maxDiff
        if max_diff is None or len(diff) <= max_diff:
            return message + diff
        return message + (DIFF_OMITTED % len(diff))

    def assertListEqual(self, list1, list2, msg=None):
        """A list-specific equality assertion.

        Args:
            list1: The first list to compare.
            list2: The second list to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.

        """
        self.assertSequenceEqual(list1, list2, msg, seq_type=list)

    def assertTupleEqual(self, tuple1, tuple2, msg=None):
        """A tuple-specific equality assertion.

        Args:
            tuple1: The first tuple to compare.
            tuple2: The second tuple to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.
        """
        self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)

    def assertSetEqual(self, set1, set2, msg=None):
        """A set-specific equality assertion.

        Args:
            set1: The first set to compare.
            set2: The second set to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.

        assertSetEqual uses ducktyping to support different types of sets, and
        is optimized for sets specifically (parameters must support a
        difference method).
        """
        try:
            difference1 = set1.difference(set2)
        except TypeError as e:
            self.fail('invalid type when attempting set difference: %s' % e)
        except AttributeError as e:
            self.fail('first argument does not support set difference: %s' % e)

        try:
            difference2 = set2.difference(set1)
        except TypeError as e:
            self.fail('invalid type when attempting set difference: %s' % e)
        except AttributeError as e:
            self.fail('second argument does not support set difference: %s' % e)

        if not (difference1 or difference2):
            return

        lines = []
        if difference1:
            lines.append('Items in the first set but not the second:')
            for item in difference1:
                lines.append(repr(item))
        if difference2:
            lines.append('Items in the second set but not the first:')
            for item in difference2:
                lines.append(repr(item))

        standardMsg = '\n'.join(lines)
        self.fail(self._formatMessage(msg, standardMsg))

    def assertIn(self, member, container, msg=None):
        """Just like self.assertTrue(a in b), but with a nicer default message."""
        if member not in container:
            standardMsg = '%s not found in %s' % (safe_repr(member),
                                                  safe_repr(container))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertNotIn(self, member, container, msg=None):
        """Just like self.assertTrue(a not in b), but with a nicer default message."""
        if member in container:
            standardMsg = '%s unexpectedly found in %s' % (safe_repr(member),
                                                        safe_repr(container))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIs(self, expr1, expr2, msg=None):
        """Just like self.assertTrue(a is b), but with a nicer default message."""
        if expr1 is not expr2:
            standardMsg = '%s is not %s' % (safe_repr(expr1),
                                             safe_repr(expr2))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsNot(self, expr1, expr2, msg=None):
        """Just like self.assertTrue(a is not b), but with a nicer default message."""
        if expr1 is expr2:
            standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertDictEqual(self, d1, d2, msg=None):
        self.assertIsInstance(d1, dict, 'First argument is not a dictionary')
        self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')

        if d1 != d2:
            standardMsg = '%s != %s' % _common_shorten_repr(d1, d2)
            diff = ('\n' + '\n'.join(difflib.ndiff(
                           pprint.pformat(d1).splitlines(),
                           pprint.pformat(d2).splitlines())))
            standardMsg = self._truncateMessage(standardMsg, diff)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertDictContainsSubset(self, subset, dictionary, msg=None):
        """Checks whether dictionary is a superset of subset."""
        warnings.warn('assertDictContainsSubset is deprecated',
                      DeprecationWarning)
        missing = []
        mismatched = []
        for key, value in subset.items():
            if key not in dictionary:
                missing.append(key)
            elif value != dictionary[key]:
                mismatched.append('%s, expected: %s, actual: %s' %
                                  (safe_repr(key), safe_repr(value),
                                   safe_repr(dictionary[key])))

        if not (missing or mismatched):
            return

        standardMsg = ''
        if missing:
            standardMsg = 'Missing: %s' % ','.join(safe_repr(m) for m in
                                                    missing)
        if mismatched:
            if standardMsg:
                standardMsg += '; '
            standardMsg += 'Mismatched values: %s' % ','.join(mismatched)

        self.fail(self._formatMessage(msg, standardMsg))


    def assertCountEqual(self, first, second, msg=None):
        """An unordered sequence comparison asserting that the same elements,
        regardless of order.  If the same element occurs more than once,
        it verifies that the elements occur the same number of times.

            self.assertEqual(Counter(list(first)),
                             Counter(list(second)))

         Example:
            - [0, 1, 1] and [1, 0, 1] compare equal.
            - [0, 0, 1] and [0, 1] compare unequal.

        """
        first_seq, second_seq = list(first), list(second)
        try:
            first = collections.Counter(first_seq)
            second = collections.Counter(second_seq)
        except TypeError:
            # Handle case with unhashable elements
            differences = _count_diff_all_purpose(first_seq, second_seq)
        else:
            if first == second:
                return
            differences = _count_diff_hashable(first_seq, second_seq)

        if differences:
            standardMsg = 'Element counts were not equal:\n'
            lines = ['First has %d, Second has %d:  %r' % diff for diff in differences]
            diffMsg = '\n'.join(lines)
            standardMsg = self._truncateMessage(standardMsg, diffMsg)
            msg = self._formatMessage(msg, standardMsg)
            self.fail(msg)

    def assertMultiLineEqual(self, first, second, msg=None):
        """Assert that two multi-line strings are equal."""
        self.assertIsInstance(first, str, 'First argument is not a string')
        self.assertIsInstance(second, str, 'Second argument is not a string')

        if first != second:
            # don't use difflib if the strings are too long
            if (len(first) > self._diffThreshold or
                len(second) > self._diffThreshold):
                self._baseAssertEqual(first, second, msg)
            firstlines = first.splitlines(keepends=True)
            secondlines = second.splitlines(keepends=True)
            if len(firstlines) == 1 and first.strip('\r\n') == first:
                firstlines = [first + '\n']
                secondlines = [second + '\n']
            standardMsg = '%s != %s' % _common_shorten_repr(first, second)
            diff = '\n' + ''.join(difflib.ndiff(firstlines, secondlines))
            standardMsg = self._truncateMessage(standardMsg, diff)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertLess(self, a, b, msg=None):
        """Just like self.assertTrue(a < b), but with a nicer default message."""
        if not a < b:
            standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertLessEqual(self, a, b, msg=None):
        """Just like self.assertTrue(a <= b), but with a nicer default message."""
        if not a <= b:
            standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertGreater(self, a, b, msg=None):
        """Just like self.assertTrue(a > b), but with a nicer default message."""
        if not a > b:
            standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertGreaterEqual(self, a, b, msg=None):
        """Just like self.assertTrue(a >= b), but with a nicer default message."""
        if not a >= b:
            standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsNone(self, obj, msg=None):
        """Same as self.assertTrue(obj is None), with a nicer default message."""
        if obj is not None:
            standardMsg = '%s is not None' % (safe_repr(obj),)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsNotNone(self, obj, msg=None):
        """Included for symmetry with assertIsNone."""
        if obj is None:
            standardMsg = 'unexpectedly None'
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsInstance(self, obj, cls, msg=None):
        """Same as self.assertTrue(isinstance(obj, cls)), with a nicer
        default message."""
        if not isinstance(obj, cls):
            standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertNotIsInstance(self, obj, cls, msg=None):
        """Included for symmetry with assertIsInstance."""
        if isinstance(obj, cls):
            standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertRaisesRegex(self, expected_exception, expected_regex,
                          callable_obj=None, *args, **kwargs):
        """Asserts that the message in a raised exception matches a regex.

        Args:
            expected_exception: Exception class expected to be raised.
            expected_regex: Regex (re pattern object or string) expected
                    to be found in error message.
            callable_obj: Function to be called.
            msg: Optional message used in case of failure. Can only be used
                    when assertRaisesRegex is used as a context manager.
            args: Extra args.
            kwargs: Extra kwargs.
        """
        context = _AssertRaisesContext(expected_exception, self, callable_obj,
                                       expected_regex)

        return context.handle('assertRaisesRegex', callable_obj, args, kwargs)

    def assertWarnsRegex(self, expected_warning, expected_regex,
                         callable_obj=None, *args, **kwargs):
        """Asserts that the message in a triggered warning matches a regexp.
        Basic functioning is similar to assertWarns() with the addition
        that only warnings whose messages also match the regular expression
        are considered successful matches.

        Args:
            expected_warning: Warning class expected to be triggered.
            expected_regex: Regex (re pattern object or string) expected
                    to be found in error message.
            callable_obj: Function to be called.
            msg: Optional message used in case of failure. Can only be used
                    when assertWarnsRegex is used as a context manager.
            args: Extra args.
            kwargs: Extra kwargs.
        """
        context = _AssertWarnsContext(expected_warning, self, callable_obj,
                                      expected_regex)
        return context.handle('assertWarnsRegex', callable_obj, args, kwargs)

    def assertRegex(self, text, expected_regex, msg=None):
        """Fail the test unless the text matches the regular expression."""
        if isinstance(expected_regex, (str, bytes)):
            assert expected_regex, "expected_regex must not be empty."
            expected_regex = re.compile(expected_regex)
        if not expected_regex.search(text):
            msg = msg or "Regex didn't match"
            msg = '%s: %r not found in %r' % (msg, expected_regex.pattern, text)
            raise self.failureException(msg)

    def assertNotRegex(self, text, unexpected_regex, msg=None):
        """Fail the test if the text matches the regular expression."""
        if isinstance(unexpected_regex, (str, bytes)):
            unexpected_regex = re.compile(unexpected_regex)
        match = unexpected_regex.search(text)
        if match:
            msg = msg or "Regex matched"
            msg = '%s: %r matches %r in %r' % (msg,
                                               text[match.start():match.end()],
                                               unexpected_regex.pattern,
                                               text)
            raise self.failureException(msg)


    def _deprecate(original_func):
        def deprecated_func(*args, **kwargs):
            warnings.warn(
                'Please use {0} instead.'.format(original_func.__name__),
                DeprecationWarning, 2)
            return original_func(*args, **kwargs)
        return deprecated_func

    # see #9424
    failUnlessEqual = assertEquals = _deprecate(assertEqual)
    failIfEqual = assertNotEquals = _deprecate(assertNotEqual)
    failUnlessAlmostEqual = assertAlmostEquals = _deprecate(assertAlmostEqual)
    failIfAlmostEqual = assertNotAlmostEquals = _deprecate(assertNotAlmostEqual)
    failUnless = assert_ = _deprecate(assertTrue)
    failUnlessRaises = _deprecate(assertRaises)
    failIf = _deprecate(assertFalse)
    assertRaisesRegexp = _deprecate(assertRaisesRegex)
    assertRegexpMatches = _deprecate(assertRegex)



class FunctionTestCase(TestCase):
    """A test case that wraps a test function.

    This is useful for slipping pre-existing test functions into the
    unittest framework. Optionally, set-up and tidy-up functions can be
    supplied. As with TestCase, the tidy-up ('tearDown') function will
    always be called if the set-up ('setUp') function ran successfully.
    """

    def __init__(self, testFunc, setUp=None, tearDown=None, description=None):
        super(FunctionTestCase, self).__init__()
        self._setUpFunc = setUp
        self._tearDownFunc = tearDown
        self._testFunc = testFunc
        self._description = description

    def setUp(self):
        if self._setUpFunc is not None:
            self._setUpFunc()

    def tearDown(self):
        if self._tearDownFunc is not None:
            self._tearDownFunc()

    def runTest(self):
        self._testFunc()

    def id(self):
        return self._testFunc.__name__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented

        return self._setUpFunc == other._setUpFunc and \
               self._tearDownFunc == other._tearDownFunc and \
               self._testFunc == other._testFunc and \
               self._description == other._description

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash((type(self), self._setUpFunc, self._tearDownFunc,
                     self._testFunc, self._description))

    def __str__(self):
        return "%s (%s)" % (strclass(self.__class__),
                            self._testFunc.__name__)

    def __repr__(self):
        return "<%s tec=%s>" % (strclass(self.__class__),
                                     self._testFunc)

    def shortDescription(self):
        if self._description is not None:
            return self._description
        doc = self._testFunc.__doc__
        return doc and doc.split("\n")[0].strip() or None


class _SubTest(TestCase):

    def __init__(self, test_case, message, params):
        super().__init__()
        self._message = message
        self.test_case = test_case
        self.params = params
        self.failureException = test_case.failureException

    def runTest(self):
        raise NotImplementedError("subtests cannot be run directly")

    def _subDescription(self):
        parts = []
        if self._message:
            parts.append("[{}]".format(self._message))
        if self.params:
            params_desc = ', '.join(
                "{}={!r}".format(k, v)
                for (k, v) in sorted(self.params.items()))
            parts.append("({})".format(params_desc))
        return " ".join(parts) or '(<subtest>)'

    def id(self):
        return "{} {}".format(self.test_case.id(), self._subDescription())

    def shortDescription(self):
        """Returns a one-line description of the subtest, or None if no
        description has been provided.
        """
        return self.test_case.shortDescription()

    def __str__(self):
        return "{} {}".format(self.test_case, self._subDescription())
                                                                                                                                                                                                                                                                                                 usr/lib/python3.4/unittest/loader.py                                                                0100644 0000000 0000000 00000037772 12415221640 016106  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Loading unittests."""

import os
import re
import sys
import traceback
import types
import functools

from fnmatch import fnmatch

from . import case, suite, util

__unittest = True

# what about .pyc or .pyo (etc)
# we would need to avoid loading the same tests multiple times
# from '.py', '.pyc' *and* '.pyo'
VALID_MODULE_NAME = re.compile(r'[_a-z]\w*\.py$', re.IGNORECASE)


def _make_failed_import_test(name, suiteClass):
    message = 'Failed to import test module: %s\n%s' % (name, traceback.format_exc())
    return _make_failed_test('ModuleImportFailure', name, ImportError(message),
                             suiteClass)

def _make_failed_load_tests(name, exception, suiteClass):
    return _make_failed_test('LoadTestsFailure', name, exception, suiteClass)

def _make_failed_test(classname, methodname, exception, suiteClass):
    def testFailure(self):
        raise exception
    attrs = {methodname: testFailure}
    TestClass = type(classname, (case.TestCase,), attrs)
    return suiteClass((TestClass(methodname),))

def _make_skipped_test(methodname, exception, suiteClass):
    @case.skip(str(exception))
    def testSkipped(self):
        pass
    attrs = {methodname: testSkipped}
    TestClass = type("ModuleSkipped", (case.TestCase,), attrs)
    return suiteClass((TestClass(methodname),))

def _jython_aware_splitext(path):
    if path.lower().endswith('$py.class'):
        return path[:-9]
    return os.path.splitext(path)[0]


class TestLoader(object):
    """
    This class is responsible for loading tests according to various criteria
    and returning them wrapped in a TestSuite
    """
    testMethodPrefix = 'test'
    sortTestMethodsUsing = staticmethod(util.three_way_cmp)
    suiteClass = suite.TestSuite
    _top_level_dir = None

    def loadTestsFromTestCase(self, testCaseClass):
        """Return a suite of all tests cases contained in testCaseClass"""
        if issubclass(testCaseClass, suite.TestSuite):
            raise TypeError("Test cases should not be derived from "
                            "TestSuite. Maybe you meant to derive from "
                            "TestCase?")
        testCaseNames = self.getTestCaseNames(testCaseClass)
        if not testCaseNames and hasattr(testCaseClass, 'runTest'):
            testCaseNames = ['runTest']
        loaded_suite = self.suiteClass(map(testCaseClass, testCaseNames))
        return loaded_suite

    def loadTestsFromModule(self, module, use_load_tests=True):
        """Return a suite of all tests cases contained in the given module"""
        tests = []
        for name in dir(module):
            obj = getattr(module, name)
            if isinstance(obj, type) and issubclass(obj, case.TestCase):
                tests.append(self.loadTestsFromTestCase(obj))

        load_tests = getattr(module, 'load_tests', None)
        tests = self.suiteClass(tests)
        if use_load_tests and load_tests is not None:
            try:
                return load_tests(self, tests, None)
            except Exception as e:
                return _make_failed_load_tests(module.__name__, e,
                                               self.suiteClass)
        return tests

    def loadTestsFromName(self, name, module=None):
        """Return a suite of all tests cases given a string specifier.

        The name may resolve either to a module, a test case class, a
        test method within a test case class, or a callable object which
        returns a TestCase or TestSuite instance.

        The method optionally resolves the names relative to a given module.
        """
        parts = name.split('.')
        if module is None:
            parts_copy = parts[:]
            while parts_copy:
                try:
                    module = __import__('.'.join(parts_copy))
                    break
                except ImportError:
                    del parts_copy[-1]
                    if not parts_copy:
                        raise
            parts = parts[1:]
        obj = module
        for part in parts:
            parent, obj = obj, getattr(obj, part)

        if isinstance(obj, types.ModuleType):
            return self.loadTestsFromModule(obj)
        elif isinstance(obj, type) and issubclass(obj, case.TestCase):
            return self.loadTestsFromTestCase(obj)
        elif (isinstance(obj, types.FunctionType) and
              isinstance(parent, type) and
              issubclass(parent, case.TestCase)):
            name = parts[-1]
            inst = parent(name)
            # static methods follow a different path
            if not isinstance(getattr(inst, name), types.FunctionType):
                return self.suiteClass([inst])
        elif isinstance(obj, suite.TestSuite):
            return obj
        if callable(obj):
            test = obj()
            if isinstance(test, suite.TestSuite):
                return test
            elif isinstance(test, case.TestCase):
                return self.suiteClass([test])
            else:
                raise TypeError("calling %s returned %s, not a test" %
                                (obj, test))
        else:
            raise TypeError("don't know how to make test from: %s" % obj)

    def loadTestsFromNames(self, names, module=None):
        """Return a suite of all tests cases found using the given sequence
        of string specifiers. See 'loadTestsFromName()'.
        """
        suites = [self.loadTestsFromName(name, module) for name in names]
        return self.suiteClass(suites)

    def getTestCaseNames(self, testCaseClass):
        """Return a sorted sequence of method names found within testCaseClass
        """
        def isTestMethod(attrname, testCaseClass=testCaseClass,
                         prefix=self.testMethodPrefix):
            return attrname.startswith(prefix) and \
                callable(getattr(testCaseClass, attrname))
        testFnNames = list(filter(isTestMethod, dir(testCaseClass)))
        if self.sortTestMethodsUsing:
            testFnNames.sort(key=functools.cmp_to_key(self.sortTestMethodsUsing))
        return testFnNames

    def discover(self, start_dir, pattern='test*.py', top_level_dir=None):
        """Find and return all test modules from the specified start
        directory, recursing into subdirectories to find them and return all
        tests found within them. Only test files that match the pattern will
        be loaded. (Using shell style pattern matching.)

        All test modules must be importable from the top level of the project.
        If the start directory is not the top level directory then the top
        level directory must be specified separately.

        If a test package name (directory with '__init__.py') matches the
        pattern then the package will be checked for a 'load_tests' function. If
        this exists then it will be called with loader, tests, pattern.

        If load_tests exists then discovery does  *not* recurse into the package,
        load_tests is responsible for loading all tests in the package.

        The pattern is deliberately not stored as a loader attribute so that
        packages can continue discovery themselves. top_level_dir is stored so
        load_tests does not need to pass this argument in to loader.discover().

        Paths are sorted before being imported to ensure reproducible execution
        order even on filesystems with non-alphabetical ordering like ext3/4.
        """
        set_implicit_top = False
        if top_level_dir is None and self._top_level_dir is not None:
            # make top_level_dir optional if called from load_tests in a package
            top_level_dir = self._top_level_dir
        elif top_level_dir is None:
            set_implicit_top = True
            top_level_dir = start_dir

        top_level_dir = os.path.abspath(top_level_dir)

        if not top_level_dir in sys.path:
            # all test modules must be importable from the top level directory
            # should we *unconditionally* put the start directory in first
            # in sys.path to minimise likelihood of conflicts between installed
            # modules and development versions?
            sys.path.insert(0, top_level_dir)
        self._top_level_dir = top_level_dir

        is_not_importable = False
        is_namespace = False
        tests = []
        if os.path.isdir(os.path.abspath(start_dir)):
            start_dir = os.path.abspath(start_dir)
            if start_dir != top_level_dir:
                is_not_importable = not os.path.isfile(os.path.join(start_dir, '__init__.py'))
        else:
            # support for discovery from dotted module names
            try:
                __import__(start_dir)
            except ImportError:
                is_not_importable = True
            else:
                the_module = sys.modules[start_dir]
                top_part = start_dir.split('.')[0]
                try:
                    start_dir = os.path.abspath(
                       os.path.dirname((the_module.__file__)))
                except AttributeError:
                    # look for namespace packages
                    try:
                        spec = the_module.__spec__
                    except AttributeError:
                        spec = None

                    if spec and spec.loader is None:
                        if spec.submodule_search_locations is not None:
                            is_namespace = True

                            for path in the_module.__path__:
                                if (not set_implicit_top and
                                    not path.startswith(top_level_dir)):
                                    continue
                                self._top_level_dir = \
                                    (path.split(the_module.__name__
                                         .replace(".", os.path.sep))[0])
                                tests.extend(self._find_tests(path,
                                                              pattern,
                                                              namespace=True))
                    elif the_module.__name__ in sys.builtin_module_names:
                        # builtin module
                        raise TypeError('Can not use builtin modules '
                                        'as dotted module names') from None
                    else:
                        raise TypeError(
                            'don\'t know how to discover from {!r}'
                            .format(the_module)) from None

                if set_implicit_top:
                    if not is_namespace:
                        self._top_level_dir = \
                           self._get_directory_containing_module(top_part)
                        sys.path.remove(top_level_dir)
                    else:
                        sys.path.remove(top_level_dir)

        if is_not_importable:
            raise ImportError('Start directory is not importable: %r' % start_dir)

        if not is_namespace:
            tests = list(self._find_tests(start_dir, pattern))
        return self.suiteClass(tests)

    def _get_directory_containing_module(self, module_name):
        module = sys.modules[module_name]
        full_path = os.path.abspath(module.__file__)

        if os.path.basename(full_path).lower().startswith('__init__.py'):
            return os.path.dirname(os.path.dirname(full_path))
        else:
            # here we have been given a module rather than a package - so
            # all we can do is search the *same* directory the module is in
            # should an exception be raised instead
            return os.path.dirname(full_path)

    def _get_name_from_path(self, path):
        path = _jython_aware_splitext(os.path.normpath(path))

        _relpath = os.path.relpath(path, self._top_level_dir)
        assert not os.path.isabs(_relpath), "Path must be within the project"
        assert not _relpath.startswith('..'), "Path must be within the project"

        name = _relpath.replace(os.path.sep, '.')
        return name

    def _get_module_from_name(self, name):
        __import__(name)
        return sys.modules[name]

    def _match_path(self, path, full_path, pattern):
        # override this method to use alternative matching strategy
        return fnmatch(path, pattern)

    def _find_tests(self, start_dir, pattern, namespace=False):
        """Used by discovery. Yields test suites it loads."""
        paths = sorted(os.listdir(start_dir))

        for path in paths:
            full_path = os.path.join(start_dir, path)
            if os.path.isfile(full_path):
                if not VALID_MODULE_NAME.match(path):
                    # valid Python identifiers only
                    continue
                if not self._match_path(path, full_path, pattern):
                    continue
                # if the test file matches, load it
                name = self._get_name_from_path(full_path)
                try:
                    module = self._get_module_from_name(name)
                except case.SkipTest as e:
                    yield _make_skipped_test(name, e, self.suiteClass)
                except:
                    yield _make_failed_import_test(name, self.suiteClass)
                else:
                    mod_file = os.path.abspath(getattr(module, '__file__', full_path))
                    realpath = _jython_aware_splitext(os.path.realpath(mod_file))
                    fullpath_noext = _jython_aware_splitext(os.path.realpath(full_path))
                    if realpath.lower() != fullpath_noext.lower():
                        module_dir = os.path.dirname(realpath)
                        mod_name = _jython_aware_splitext(os.path.basename(full_path))
                        expected_dir = os.path.dirname(full_path)
                        msg = ("%r module incorrectly imported from %r. Expected %r. "
                               "Is this module globally installed?")
                        raise ImportError(msg % (mod_name, module_dir, expected_dir))
                    yield self.loadTestsFromModule(module)
            elif os.path.isdir(full_path):
                if (not namespace and
                    not os.path.isfile(os.path.join(full_path, '__init__.py'))):
                    continue

                load_tests = None
                tests = None
                if fnmatch(path, pattern):
                    # only check load_tests if the package directory itself matches the filter
                    name = self._get_name_from_path(full_path)
                    package = self._get_module_from_name(name)
                    load_tests = getattr(package, 'load_tests', None)
                    tests = self.loadTestsFromModule(package, use_load_tests=False)

                if load_tests is None:
                    if tests is not None:
                        # tests loaded from package file
                        yield tests
                    # recurse into the package
                    yield from self._find_tests(full_path, pattern,
                                                namespace=namespace)
                else:
                    try:
                        yield load_tests(self, tests, pattern)
                    except Exception as e:
                        yield _make_failed_load_tests(package.__name__, e,
                                                      self.suiteClass)

defaultTestLoader = TestLoader()


def _makeLoader(prefix, sortUsing, suiteClass=None):
    loader = TestLoader()
    loader.sortTestMethodsUsing = sortUsing
    loader.testMethodPrefix = prefix
    if suiteClass:
        loader.suiteClass = suiteClass
    return loader

def getTestCaseNames(testCaseClass, prefix, sortUsing=util.three_way_cmp):
    return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)

def makeSuite(testCaseClass, prefix='test', sortUsing=util.three_way_cmp,
              suiteClass=suite.TestSuite):
    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(
        testCaseClass)

def findTestCases(module, prefix='test', sortUsing=util.three_way_cmp,
                  suiteClass=suite.TestSuite):
    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(\
        module)
      usr/lib/python3.4/unittest/main.py                                                                  0100644 0000000 0000000 00000023037 12415221640 015551  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Unittest main program"""

import sys
import argparse
import os

from . import loader, runner
from .signals import installHandler

__unittest = True

MAIN_EXAMPLES = """\
Examples:
  %(prog)s test_module               - run tests from test_module
  %(prog)s module.TestClass          - run tests from module.TestClass
  %(prog)s module.Class.test_method  - run specified test method
"""

MODULE_EXAMPLES = """\
Examples:
  %(prog)s                           - run default set of tests
  %(prog)s MyTestSuite               - run suite 'MyTestSuite'
  %(prog)s MyTestCase.testSomething  - run MyTestCase.testSomething
  %(prog)s MyTestCase                - run all 'test*' test methods
                                       in MyTestCase
"""

def _convert_name(name):
    # on Linux / Mac OS X 'foo.PY' is not importable, but on
    # Windows it is. Simpler to do a case insensitive match
    # a better check would be to check that the name is a
    # valid Python module name.
    if os.path.isfile(name) and name.lower().endswith('.py'):
        if os.path.isabs(name):
            rel_path = os.path.relpath(name, os.getcwd())
            if os.path.isabs(rel_path) or rel_path.startswith(os.pardir):
                return name
            name = rel_path
        # on Windows both '\' and '/' are used as path
        # separators. Better to replace both than rely on os.path.sep
        return name[:-3].replace('\\', '.').replace('/', '.')
    return name

def _convert_names(names):
    return [_convert_name(name) for name in names]


class TestProgram(object):
    """A command-line program that runs a set of tests; this is primarily
       for making test modules conveniently executable.
    """
    # defaults for testing
    module=None
    verbosity = 1
    failfast = catchbreak = buffer = progName = warnings = None
    _discovery_parser = None

    def __init__(self, module='__main__', defaultTest=None, argv=None,
                    testRunner=None, testLoader=loader.defaultTestLoader,
                    exit=True, verbosity=1, failfast=None, catchbreak=None,
                    buffer=None, warnings=None):
        if isinstance(module, str):
            self.module = __import__(module)
            for part in module.split('.')[1:]:
                self.module = getattr(self.module, part)
        else:
            self.module = module
        if argv is None:
            argv = sys.argv

        self.exit = exit
        self.failfast = failfast
        self.catchbreak = catchbreak
        self.verbosity = verbosity
        self.buffer = buffer
        if warnings is None and not sys.warnoptions:
            # even if DreprecationWarnings are ignored by default
            # print them anyway unless other warnings settings are
            # specified by the warnings arg or the -W python flag
            self.warnings = 'default'
        else:
            # here self.warnings is set either to the value passed
            # to the warnings args or to None.
            # If the user didn't pass a value self.warnings will
            # be None. This means that the behavior is unchanged
            # and depends on the values passed to -W.
            self.warnings = warnings
        self.defaultTest = defaultTest
        self.testRunner = testRunner
        self.testLoader = testLoader
        self.progName = os.path.basename(argv[0])
        self.parseArgs(argv)
        self.runTests()

    def usageExit(self, msg=None):
        if msg:
            print(msg)
        if self._discovery_parser is None:
            self._initArgParsers()
        self._print_help()
        sys.exit(2)

    def _print_help(self, *args, **kwargs):
        if self.module is None:
            print(self._main_parser.format_help())
            print(MAIN_EXAMPLES % {'prog': self.progName})
            self._discovery_parser.print_help()
        else:
            print(self._main_parser.format_help())
            print(MODULE_EXAMPLES % {'prog': self.progName})

    def parseArgs(self, argv):
        self._initArgParsers()
        if self.module is None:
            if len(argv) > 1 and argv[1].lower() == 'discover':
                self._do_discovery(argv[2:])
                return
            self._main_parser.parse_args(argv[1:], self)
            if not self.tests:
                # this allows "python -m unittest -v" to still work for
                # test discovery.
                self._do_discovery([])
                return
        else:
            self._main_parser.parse_args(argv[1:], self)

        if self.tests:
            self.testNames = _convert_names(self.tests)
            if __name__ == '__main__':
                # to support python -m unittest ...
                self.module = None
        elif self.defaultTest is None:
            # createTests will load tests from self.module
            self.testNames = None
        elif isinstance(self.defaultTest, str):
            self.testNames = (self.defaultTest,)
        else:
            self.testNames = list(self.defaultTest)
        self.createTests()

    def createTests(self):
        if self.testNames is None:
            self.test = self.testLoader.loadTestsFromModule(self.module)
        else:
            self.test = self.testLoader.loadTestsFromNames(self.testNames,
                                                           self.module)

    def _initArgParsers(self):
        parent_parser = self._getParentArgParser()
        self._main_parser = self._getMainArgParser(parent_parser)
        self._discovery_parser = self._getDiscoveryArgParser(parent_parser)

    def _getParentArgParser(self):
        parser = argparse.ArgumentParser(add_help=False)

        parser.add_argument('-v', '--verbose', dest='verbosity',
                            action='store_const', const=2,
                            help='Verbose output')
        parser.add_argument('-q', '--quiet', dest='verbosity',
                            action='store_const', const=0,
                            help='Quiet output')

        if self.failfast is None:
            parser.add_argument('-f', '--failfast', dest='failfast',
                                action='store_true',
                                help='Stop on first fail or error')
            self.failfast = False
        if self.catchbreak is None:
            parser.add_argument('-c', '--catch', dest='catchbreak',
                                action='store_true',
                                help='Catch ctrl-C and display results so far')
            self.catchbreak = False
        if self.buffer is None:
            parser.add_argument('-b', '--buffer', dest='buffer',
                                action='store_true',
                                help='Buffer stdout and stderr during tests')
            self.buffer = False

        return parser

    def _getMainArgParser(self, parent):
        parser = argparse.ArgumentParser(parents=[parent])
        parser.prog = self.progName
        parser.print_help = self._print_help

        parser.add_argument('tests', nargs='*',
                            help='a list of any number of test modules, '
                            'classes and test methods.')

        return parser

    def _getDiscoveryArgParser(self, parent):
        parser = argparse.ArgumentParser(parents=[parent])
        parser.prog = '%s discover' % self.progName
        parser.epilog = ('For test discovery all test modules must be '
                         'importable from the top level directory of the '
                         'project.')

        parser.add_argument('-s', '--start-directory', dest='start',
                            help="Directory to start discovery ('.' default)")
        parser.add_argument('-p', '--pattern', dest='pattern',
                            help="Pattern to match tests ('test*.py' default)")
        parser.add_argument('-t', '--top-level-directory', dest='top',
                            help='Top level directory of project (defaults to '
                                 'start directory)')
        for arg in ('start', 'pattern', 'top'):
            parser.add_argument(arg, nargs='?',
                                default=argparse.SUPPRESS,
                                help=argparse.SUPPRESS)

        return parser

    def _do_discovery(self, argv, Loader=None):
        self.start = '.'
        self.pattern = 'test*.py'
        self.top = None
        if argv is not None:
            # handle command line args for test discovery
            if self._discovery_parser is None:
                # for testing
                self._initArgParsers()
            self._discovery_parser.parse_args(argv, self)

        loader = self.testLoader if Loader is None else Loader()
        self.test = loader.discover(self.start, self.pattern, self.top)

    def runTests(self):
        if self.catchbreak:
            installHandler()
        if self.testRunner is None:
            self.testRunner = runner.TextTestRunner
        if isinstance(self.testRunner, type):
            try:
                testRunner = self.testRunner(verbosity=self.verbosity,
                                             failfast=self.failfast,
                                             buffer=self.buffer,
                                             warnings=self.warnings)
            except TypeError:
                # didn't accept the verbosity, buffer or failfast arguments
                testRunner = self.testRunner()
        else:
            # it is assumed to be a TestRunner instance
            testRunner = self.testRunner
        self.result = testRunner.run(self.test)
        if self.exit:
            sys.exit(not self.result.wasSuccessful())

main = TestProgram
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python3.4/unittest/mock.py                                                                  0100644 0000000 0000000 00000224405 12415221640 015560  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # mock.py
# Test tools for mocking and patching.
# Maintained by Michael Foord
# Backport for other versions of Python available from
# http://pypi.python.org/pypi/mock

__all__ = (
    'Mock',
    'MagicMock',
    'patch',
    'sentinel',
    'DEFAULT',
    'ANY',
    'call',
    'create_autospec',
    'FILTER_DIR',
    'NonCallableMock',
    'NonCallableMagicMock',
    'mock_open',
    'PropertyMock',
)


__version__ = '1.0'


import inspect
import pprint
import sys
from functools import wraps, partial


BaseExceptions = (BaseException,)
if 'java' in sys.platform:
    # jython
    import java
    BaseExceptions = (BaseException, java.lang.Throwable)


FILTER_DIR = True

# Workaround for issue #12370
# Without this, the __class__ properties wouldn't be set correctly
_safe_super = super

def _is_instance_mock(obj):
    # can't use isinstance on Mock objects because they override __class__
    # The base class for all mocks is NonCallableMock
    return issubclass(type(obj), NonCallableMock)


def _is_exception(obj):
    return (
        isinstance(obj, BaseExceptions) or
        isinstance(obj, type) and issubclass(obj, BaseExceptions)
    )


class _slotted(object):
    __slots__ = ['a']


DescriptorTypes = (
    type(_slotted.a),
    property,
)


def _get_signature_object(func, as_instance, eat_self):
    """
    Given an arbitrary, possibly callable object, try to create a suitable
    signature object.
    Return a (reduced func, signature) tuple, or None.
    """
    if isinstance(func, type) and not as_instance:
        # If it's a type and should be modelled as a type, use __init__.
        try:
            func = func.__init__
        except AttributeError:
            return None
        # Skip the `self` argument in __init__
        eat_self = True
    elif not isinstance(func, FunctionTypes):
        # If we really want to model an instance of the passed type,
        # __call__ should be looked up, not __init__.
        try:
            func = func.__call__
        except AttributeError:
            return None
    if eat_self:
        sig_func = partial(func, None)
    else:
        sig_func = func
    try:
        return func, inspect.signature(sig_func)
    except ValueError:
        # Certain callable types are not supported by inspect.signature()
        return None


def _check_signature(func, mock, skipfirst, instance=False):
    sig = _get_signature_object(func, instance, skipfirst)
    if sig is None:
        return
    func, sig = sig
    def checksig(_mock_self, *args, **kwargs):
        sig.bind(*args, **kwargs)
    _copy_func_details(func, checksig)
    type(mock)._mock_check_sig = checksig


def _copy_func_details(func, funcopy):
    funcopy.__name__ = func.__name__
    funcopy.__doc__ = func.__doc__
    try:
        funcopy.__text_signature__ = func.__text_signature__
    except AttributeError:
        pass
    # we explicitly don't copy func.__dict__ into this copy as it would
    # expose original attributes that should be mocked
    try:
        funcopy.__module__ = func.__module__
    except AttributeError:
        pass
    try:
        funcopy.__defaults__ = func.__defaults__
    except AttributeError:
        pass
    try:
        funcopy.__kwdefaults__ = func.__kwdefaults__
    except AttributeError:
        pass


def _callable(obj):
    if isinstance(obj, type):
        return True
    if getattr(obj, '__call__', None) is not None:
        return True
    return False


def _is_list(obj):
    # checks for list or tuples
    # XXXX badly named!
    return type(obj) in (list, tuple)


def _instance_callable(obj):
    """Given an object, return True if the object is callable.
    For classes, return True if instances would be callable."""
    if not isinstance(obj, type):
        # already an instance
        return getattr(obj, '__call__', None) is not None

    # *could* be broken by a class overriding __mro__ or __dict__ via
    # a metaclass
    for base in (obj,) + obj.__mro__:
        if base.__dict__.get('__call__') is not None:
            return True
    return False


def _set_signature(mock, original, instance=False):
    # creates a function with signature (*args, **kwargs) that delegates to a
    # mock. It still does signature checking by calling a lambda with the same
    # signature as the original.
    if not _callable(original):
        return

    skipfirst = isinstance(original, type)
    result = _get_signature_object(original, instance, skipfirst)
    if result is None:
        return
    func, sig = result
    def checksig(*args, **kwargs):
        sig.bind(*args, **kwargs)
    _copy_func_details(func, checksig)

    name = original.__name__
    if not name.isidentifier():
        name = 'funcopy'
    context = {'_checksig_': checksig, 'mock': mock}
    src = """def %s(*args, **kwargs):
    _checksig_(*args, **kwargs)
    return mock(*args, **kwargs)""" % name
    exec (src, context)
    funcopy = context[name]
    _setup_func(funcopy, mock)
    return funcopy


def _setup_func(funcopy, mock):
    funcopy.mock = mock

    # can't use isinstance with mocks
    if not _is_instance_mock(mock):
        return

    def assert_called_with(*args, **kwargs):
        return mock.assert_called_with(*args, **kwargs)
    def assert_called_once_with(*args, **kwargs):
        return mock.assert_called_once_with(*args, **kwargs)
    def assert_has_calls(*args, **kwargs):
        return mock.assert_has_calls(*args, **kwargs)
    def assert_any_call(*args, **kwargs):
        return mock.assert_any_call(*args, **kwargs)
    def reset_mock():
        funcopy.method_calls = _CallList()
        funcopy.mock_calls = _CallList()
        mock.reset_mock()
        ret = funcopy.return_value
        if _is_instance_mock(ret) and not ret is mock:
            ret.reset_mock()

    funcopy.called = False
    funcopy.call_count = 0
    funcopy.call_args = None
    funcopy.call_args_list = _CallList()
    funcopy.method_calls = _CallList()
    funcopy.mock_calls = _CallList()

    funcopy.return_value = mock.return_value
    funcopy.side_effect = mock.side_effect
    funcopy._mock_children = mock._mock_children

    funcopy.assert_called_with = assert_called_with
    funcopy.assert_called_once_with = assert_called_once_with
    funcopy.assert_has_calls = assert_has_calls
    funcopy.assert_any_call = assert_any_call
    funcopy.reset_mock = reset_mock

    mock._mock_delegate = funcopy


def _is_magic(name):
    return '__%s__' % name[2:-2] == name


class _SentinelObject(object):
    "A unique, named, sentinel object."
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return 'sentinel.%s' % self.name


class _Sentinel(object):
    """Access attributes to return a named object, usable as a sentinel."""
    def __init__(self):
        self._sentinels = {}

    def __getattr__(self, name):
        if name == '__bases__':
            # Without this help(unittest.mock) raises an exception
            raise AttributeError
        return self._sentinels.setdefault(name, _SentinelObject(name))


sentinel = _Sentinel()

DEFAULT = sentinel.DEFAULT
_missing = sentinel.MISSING
_deleted = sentinel.DELETED


def _copy(value):
    if type(value) in (dict, list, tuple, set):
        return type(value)(value)
    return value


_allowed_names = set(
    [
        'return_value', '_mock_return_value', 'side_effect',
        '_mock_side_effect', '_mock_parent', '_mock_new_parent',
        '_mock_name', '_mock_new_name'
    ]
)


def _delegating_property(name):
    _allowed_names.add(name)
    _the_name = '_mock_' + name
    def _get(self, name=name, _the_name=_the_name):
        sig = self._mock_delegate
        if sig is None:
            return getattr(self, _the_name)
        return getattr(sig, name)
    def _set(self, value, name=name, _the_name=_the_name):
        sig = self._mock_delegate
        if sig is None:
            self.__dict__[_the_name] = value
        else:
            setattr(sig, name, value)

    return property(_get, _set)



class _CallList(list):

    def __contains__(self, value):
        if not isinstance(value, list):
            return list.__contains__(self, value)
        len_value = len(value)
        len_self = len(self)
        if len_value > len_self:
            return False

        for i in range(0, len_self - len_value + 1):
            sub_list = self[i:i+len_value]
            if sub_list == value:
                return True
        return False

    def __repr__(self):
        return pprint.pformat(list(self))


def _check_and_set_parent(parent, value, name, new_name):
    if not _is_instance_mock(value):
        return False
    if ((value._mock_name or value._mock_new_name) or
        (value._mock_parent is not None) or
        (value._mock_new_parent is not None)):
        return False

    _parent = parent
    while _parent is not None:
        # setting a mock (value) as a child or return value of itself
        # should not modify the mock
        if _parent is value:
            return False
        _parent = _parent._mock_new_parent

    if new_name:
        value._mock_new_parent = parent
        value._mock_new_name = new_name
    if name:
        value._mock_parent = parent
        value._mock_name = name
    return True

# Internal class to identify if we wrapped an iterator object or not.
class _MockIter(object):
    def __init__(self, obj):
        self.obj = iter(obj)
    def __iter__(self):
        return self
    def __next__(self):
        return next(self.obj)

class Base(object):
    _mock_return_value = DEFAULT
    _mock_side_effect = None
    def __init__(self, *args, **kwargs):
        pass



class NonCallableMock(Base):
    """A non-callable version of `Mock`"""

    def __new__(cls, *args, **kw):
        # every instance has its own class
        # so we can create magic methods on the
        # class without stomping on other mocks
        new = type(cls.__name__, (cls,), {'__doc__': cls.__doc__})
        instance = object.__new__(new)
        return instance


    def __init__(
            self, spec=None, wraps=None, name=None, spec_set=None,
            parent=None, _spec_state=None, _new_name='', _new_parent=None,
            _spec_as_instance=False, _eat_self=None, **kwargs
        ):
        if _new_parent is None:
            _new_parent = parent

        __dict__ = self.__dict__
        __dict__['_mock_parent'] = parent
        __dict__['_mock_name'] = name
        __dict__['_mock_new_name'] = _new_name
        __dict__['_mock_new_parent'] = _new_parent

        if spec_set is not None:
            spec = spec_set
            spec_set = True
        if _eat_self is None:
            _eat_self = parent is not None

        self._mock_add_spec(spec, spec_set, _spec_as_instance, _eat_self)

        __dict__['_mock_children'] = {}
        __dict__['_mock_wraps'] = wraps
        __dict__['_mock_delegate'] = None

        __dict__['_mock_called'] = False
        __dict__['_mock_call_args'] = None
        __dict__['_mock_call_count'] = 0
        __dict__['_mock_call_args_list'] = _CallList()
        __dict__['_mock_mock_calls'] = _CallList()

        __dict__['method_calls'] = _CallList()

        if kwargs:
            self.configure_mock(**kwargs)

        _safe_super(NonCallableMock, self).__init__(
            spec, wraps, name, spec_set, parent,
            _spec_state
        )


    def attach_mock(self, mock, attribute):
        """
        Attach a mock as an attribute of this one, replacing its name and
        parent. Calls to the attached mock will be recorded in the
        `method_calls` and `mock_calls` attributes of this one."""
        mock._mock_parent = None
        mock._mock_new_parent = None
        mock._mock_name = ''
        mock._mock_new_name = None

        setattr(self, attribute, mock)


    def mock_add_spec(self, spec, spec_set=False):
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set."""
        self._mock_add_spec(spec, spec_set)


    def _mock_add_spec(self, spec, spec_set, _spec_as_instance=False,
                       _eat_self=False):
        _spec_class = None
        _spec_signature = None

        if spec is not None and not _is_list(spec):
            if isinstance(spec, type):
                _spec_class = spec
            else:
                _spec_class = _get_class(spec)
            res = _get_signature_object(spec,
                                        _spec_as_instance, _eat_self)
            _spec_signature = res and res[1]

            spec = dir(spec)

        __dict__ = self.__dict__
        __dict__['_spec_class'] = _spec_class
        __dict__['_spec_set'] = spec_set
        __dict__['_spec_signature'] = _spec_signature
        __dict__['_mock_methods'] = spec


    def __get_return_value(self):
        ret = self._mock_return_value
        if self._mock_delegate is not None:
            ret = self._mock_delegate.return_value

        if ret is DEFAULT:
            ret = self._get_child_mock(
                _new_parent=self, _new_name='()'
            )
            self.return_value = ret
        return ret


    def __set_return_value(self, value):
        if self._mock_delegate is not None:
            self._mock_delegate.return_value = value
        else:
            self._mock_return_value = value
            _check_and_set_parent(self, value, None, '()')

    __return_value_doc = "The value to be returned when the mock is called."
    return_value = property(__get_return_value, __set_return_value,
                            __return_value_doc)


    @property
    def __class__(self):
        if self._spec_class is None:
            return type(self)
        return self._spec_class

    called = _delegating_property('called')
    call_count = _delegating_property('call_count')
    call_args = _delegating_property('call_args')
    call_args_list = _delegating_property('call_args_list')
    mock_calls = _delegating_property('mock_calls')


    def __get_side_effect(self):
        delegated = self._mock_delegate
        if delegated is None:
            return self._mock_side_effect
        sf = delegated.side_effect
        if sf is not None and not callable(sf) and not isinstance(sf, _MockIter):
            sf = _MockIter(sf)
            delegated.side_effect = sf
        return sf

    def __set_side_effect(self, value):
        value = _try_iter(value)
        delegated = self._mock_delegate
        if delegated is None:
            self._mock_side_effect = value
        else:
            delegated.side_effect = value

    side_effect = property(__get_side_effect, __set_side_effect)


    def reset_mock(self):
        "Restore the mock object to its initial state."
        self.called = False
        self.call_args = None
        self.call_count = 0
        self.mock_calls = _CallList()
        self.call_args_list = _CallList()
        self.method_calls = _CallList()

        for child in self._mock_children.values():
            if isinstance(child, _SpecState):
                continue
            child.reset_mock()

        ret = self._mock_return_value
        if _is_instance_mock(ret) and ret is not self:
            ret.reset_mock()


    def configure_mock(self, **kwargs):
        """Set attributes on the mock through keyword arguments.

        Attributes plus return values and side effects can be set on child
        mocks using standard dot notation and unpacking a dictionary in the
        method call:

        >>> attrs = {'method.return_value': 3, 'other.side_effect': KeyError}
        >>> mock.configure_mock(**attrs)"""
        for arg, val in sorted(kwargs.items(),
                               # we sort on the number of dots so that
                               # attributes are set before we set attributes on
                               # attributes
                               key=lambda entry: entry[0].count('.')):
            args = arg.split('.')
            final = args.pop()
            obj = self
            for entry in args:
                obj = getattr(obj, entry)
            setattr(obj, final, val)


    def __getattr__(self, name):
        if name == '_mock_methods':
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
            raise AttributeError(name)

        result = self._mock_children.get(name)
        if result is _deleted:
            raise AttributeError(name)
        elif result is None:
            wraps = None
            if self._mock_wraps is not None:
                # XXXX should we get the attribute without triggering code
                # execution?
                wraps = getattr(self._mock_wraps, name)

            result = self._get_child_mock(
                parent=self, name=name, wraps=wraps, _new_name=name,
                _new_parent=self
            )
            self._mock_children[name]  = result

        elif isinstance(result, _SpecState):
            result = create_autospec(
                result.spec, result.spec_set, result.instance,
                result.parent, result.name
            )
            self._mock_children[name]  = result

        return result


    def __repr__(self):
        _name_list = [self._mock_new_name]
        _parent = self._mock_new_parent
        last = self

        dot = '.'
        if _name_list == ['()']:
            dot = ''
        seen = set()
        while _parent is not None:
            last = _parent

            _name_list.append(_parent._mock_new_name + dot)
            dot = '.'
            if _parent._mock_new_name == '()':
                dot = ''

            _parent = _parent._mock_new_parent

            # use ids here so as not to call __hash__ on the mocks
            if id(_parent) in seen:
                break
            seen.add(id(_parent))

        _name_list = list(reversed(_name_list))
        _first = last._mock_name or 'mock'
        if len(_name_list) > 1:
            if _name_list[1] not in ('()', '().'):
                _first += '.'
        _name_list[0] = _first
        name = ''.join(_name_list)

        name_string = ''
        if name not in ('mock', 'mock.'):
            name_string = ' name=%r' % name

        spec_string = ''
        if self._spec_class is not None:
            spec_string = ' spec=%r'
            if self._spec_set:
                spec_string = ' spec_set=%r'
            spec_string = spec_string % self._spec_class.__name__
        return "<%s%s%s id='%s'>" % (
            type(self).__name__,
            name_string,
            spec_string,
            id(self)
        )


    def __dir__(self):
        """Filter the output of `dir(mock)` to only useful members."""
        if not FILTER_DIR:
            return object.__dir__(self)

        extras = self._mock_methods or []
        from_type = dir(type(self))
        from_dict = list(self.__dict__)

        from_type = [e for e in from_type if not e.startswith('_')]
        from_dict = [e for e in from_dict if not e.startswith('_') or
                     _is_magic(e)]
        return sorted(set(extras + from_type + from_dict +
                          list(self._mock_children)))


    def __setattr__(self, name, value):
        if name in _allowed_names:
            # property setters go through here
            return object.__setattr__(self, name, value)
        elif (self._spec_set and self._mock_methods is not None and
            name not in self._mock_methods and
            name not in self.__dict__):
            raise AttributeError("Mock object has no attribute '%s'" % name)
        elif name in _unsupported_magics:
            msg = 'Attempting to set unsupported magic method %r.' % name
            raise AttributeError(msg)
        elif name in _all_magics:
            if self._mock_methods is not None and name not in self._mock_methods:
                raise AttributeError("Mock object has no attribute '%s'" % name)

            if not _is_instance_mock(value):
                setattr(type(self), name, _get_method(name, value))
                original = value
                value = lambda *args, **kw: original(self, *args, **kw)
            else:
                # only set _new_name and not name so that mock_calls is tracked
                # but not method calls
                _check_and_set_parent(self, value, None, name)
                setattr(type(self), name, value)
                self._mock_children[name] = value
        elif name == '__class__':
            self._spec_class = value
            return
        else:
            if _check_and_set_parent(self, value, name, name):
                self._mock_children[name] = value
        return object.__setattr__(self, name, value)


    def __delattr__(self, name):
        if name in _all_magics and name in type(self).__dict__:
            delattr(type(self), name)
            if name not in self.__dict__:
                # for magic methods that are still MagicProxy objects and
                # not set on the instance itself
                return

        if name in self.__dict__:
            object.__delattr__(self, name)

        obj = self._mock_children.get(name, _missing)
        if obj is _deleted:
            raise AttributeError(name)
        if obj is not _missing:
            del self._mock_children[name]
        self._mock_children[name] = _deleted


    def _format_mock_call_signature(self, args, kwargs):
        name = self._mock_name or 'mock'
        return _format_call_signature(name, args, kwargs)


    def _format_mock_failure_message(self, args, kwargs):
        message = 'Expected call: %s\nActual call: %s'
        expected_string = self._format_mock_call_signature(args, kwargs)
        call_args = self.call_args
        if len(call_args) == 3:
            call_args = call_args[1:]
        actual_string = self._format_mock_call_signature(*call_args)
        return message % (expected_string, actual_string)


    def _call_matcher(self, _call):
        """
        Given a call (or simply a (args, kwargs) tuple), return a
        comparison key suitable for matching with other calls.
        This is a best effort method which relies on the spec's signature,
        if available, or falls back on the arguments themselves.
        """
        sig = self._spec_signature
        if sig is not None:
            if len(_call) == 2:
                name = ''
                args, kwargs = _call
            else:
                name, args, kwargs = _call
            try:
                return name, sig.bind(*args, **kwargs)
            except TypeError as e:
                return e.with_traceback(None)
        else:
            return _call


    def assert_called_with(_mock_self, *args, **kwargs):
        """assert that the mock was called with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        self = _mock_self
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            raise AssertionError('Expected call: %s\nNot called' % (expected,))

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher((args, kwargs))
        actual = self._call_matcher(self.call_args)
        if expected != actual:
            cause = expected if isinstance(expected, Exception) else None
            raise AssertionError(_error_message()) from cause


    def assert_called_once_with(_mock_self, *args, **kwargs):
        """assert that the mock was called exactly once and with the specified
        arguments."""
        self = _mock_self
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times." %
                   (self._mock_name or 'mock', self.call_count))
            raise AssertionError(msg)
        return self.assert_called_with(*args, **kwargs)


    def assert_has_calls(self, calls, any_order=False):
        """assert the mock has been called with the specified calls.
        The `mock_calls` list is checked for the calls.

        If `any_order` is False (the default) then the calls must be
        sequential. There can be extra calls before or after the
        specified calls.

        If `any_order` is True then the calls can be in any order, but
        they must all appear in `mock_calls`."""
        expected = [self._call_matcher(c) for c in calls]
        cause = expected if isinstance(expected, Exception) else None
        all_calls = _CallList(self._call_matcher(c) for c in self.mock_calls)
        if not any_order:
            if expected not in all_calls:
                raise AssertionError(
                    'Calls not found.\nExpected: %r\n'
                    'Actual: %r' % (calls, self.mock_calls)
                ) from cause
            return

        all_calls = list(all_calls)

        not_found = []
        for kall in expected:
            try:
                all_calls.remove(kall)
            except ValueError:
                not_found.append(kall)
        if not_found:
            raise AssertionError(
                '%r not all found in call list' % (tuple(not_found),)
            ) from cause


    def assert_any_call(self, *args, **kwargs):
        """assert the mock has been called with the specified arguments.

        The assert passes if the mock has *ever* been called, unlike
        `assert_called_with` and `assert_called_once_with` that only pass if
        the call is the most recent one."""
        expected = self._call_matcher((args, kwargs))
        actual = [self._call_matcher(c) for c in self.call_args_list]
        if expected not in actual:
            cause = expected if isinstance(expected, Exception) else None
            expected_string = self._format_mock_call_signature(args, kwargs)
            raise AssertionError(
                '%s call not found' % expected_string
            ) from cause


    def _get_child_mock(self, **kw):
        """Create the child mocks for attributes and return value.
        By default child mocks will be the same type as the parent.
        Subclasses of Mock may want to override this to customize the way
        child mocks are made.

        For non-callable mocks the callable variant will be used (rather than
        any custom subclass)."""
        _type = type(self)
        if not issubclass(_type, CallableMixin):
            if issubclass(_type, NonCallableMagicMock):
                klass = MagicMock
            elif issubclass(_type, NonCallableMock) :
                klass = Mock
        else:
            klass = _type.__mro__[1]
        return klass(**kw)



def _try_iter(obj):
    if obj is None:
        return obj
    if _is_exception(obj):
        return obj
    if _callable(obj):
        return obj
    try:
        return iter(obj)
    except TypeError:
        # XXXX backwards compatibility
        # but this will blow up on first call - so maybe we should fail early?
        return obj



class CallableMixin(Base):

    def __init__(self, spec=None, side_effect=None, return_value=DEFAULT,
                 wraps=None, name=None, spec_set=None, parent=None,
                 _spec_state=None, _new_name='', _new_parent=None, **kwargs):
        self.__dict__['_mock_return_value'] = return_value

        _safe_super(CallableMixin, self).__init__(
            spec, wraps, name, spec_set, parent,
            _spec_state, _new_name, _new_parent, **kwargs
        )

        self.side_effect = side_effect


    def _mock_check_sig(self, *args, **kwargs):
        # stub method that can be replaced with one with a specific signature
        pass


    def __call__(_mock_self, *args, **kwargs):
        # can't use self in-case a function / method we are mocking uses self
        # in the signature
        _mock_self._mock_check_sig(*args, **kwargs)
        return _mock_self._mock_call(*args, **kwargs)


    def _mock_call(_mock_self, *args, **kwargs):
        self = _mock_self
        self.called = True
        self.call_count += 1
        _new_name = self._mock_new_name
        _new_parent = self._mock_new_parent

        _call = _Call((args, kwargs), two=True)
        self.call_args = _call
        self.call_args_list.append(_call)
        self.mock_calls.append(_Call(('', args, kwargs)))

        seen = set()
        skip_next_dot = _new_name == '()'
        do_method_calls = self._mock_parent is not None
        name = self._mock_name
        while _new_parent is not None:
            this_mock_call = _Call((_new_name, args, kwargs))
            if _new_parent._mock_new_name:
                dot = '.'
                if skip_next_dot:
                    dot = ''

                skip_next_dot = False
                if _new_parent._mock_new_name == '()':
                    skip_next_dot = True

                _new_name = _new_parent._mock_new_name + dot + _new_name

            if do_method_calls:
                if _new_name == name:
                    this_method_call = this_mock_call
                else:
                    this_method_call = _Call((name, args, kwargs))
                _new_parent.method_calls.append(this_method_call)

                do_method_calls = _new_parent._mock_parent is not None
                if do_method_calls:
                    name = _new_parent._mock_name + '.' + name

            _new_parent.mock_calls.append(this_mock_call)
            _new_parent = _new_parent._mock_new_parent

            # use ids here so as not to call __hash__ on the mocks
            _new_parent_id = id(_new_parent)
            if _new_parent_id in seen:
                break
            seen.add(_new_parent_id)

        ret_val = DEFAULT
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect

            if not _callable(effect):
                result = next(effect)
                if _is_exception(result):
                    raise result
                if result is DEFAULT:
                    result = self.return_value
                return result

            ret_val = effect(*args, **kwargs)

        if (self._mock_wraps is not None and
             self._mock_return_value is DEFAULT):
            return self._mock_wraps(*args, **kwargs)
        if ret_val is DEFAULT:
            ret_val = self.return_value
        return ret_val



class Mock(CallableMixin, NonCallableMock):
    """
    Create a new `Mock` object. `Mock` takes several optional arguments
    that specify the behaviour of the Mock object:

    * `spec`: This can be either a list of strings or an existing object (a
      class or instance) that acts as the specification for the mock object. If
      you pass in an object then a list of strings is formed by calling dir on
      the object (excluding unsupported magic attributes and methods). Accessing
      any attribute not in this list will raise an `AttributeError`.

      If `spec` is an object (rather than a list of strings) then
      `mock.__class__` returns the class of the spec object. This allows mocks
      to pass `isinstance` tests.

    * `spec_set`: A stricter variant of `spec`. If used, attempting to *set*
      or get an attribute on the mock that isn't on the object passed as
      `spec_set` will raise an `AttributeError`.

    * `side_effect`: A function to be called whenever the Mock is called. See
      the `side_effect` attribute. Useful for raising exceptions or
      dynamically changing return values. The function is called with the same
      arguments as the mock, and unless it returns `DEFAULT`, the return
      value of this function is used as the return value.

      If `side_effect` is an iterable then each call to the mock will return
      the next value from the iterable. If any of the members of the iterable
      are exceptions they will be raised instead of returned.

    * `return_value`: The value returned when the mock is called. By default
      this is a new Mock (created on first access). See the
      `return_value` attribute.

    * `wraps`: Item for the mock object to wrap. If `wraps` is not None then
      calling the Mock will pass the call through to the wrapped object
      (returning the real result). Attribute access on the mock will return a
      Mock object that wraps the corresponding attribute of the wrapped object
      (so attempting to access an attribute that doesn't exist will raise an
      `AttributeError`).

      If the mock has an explicit `return_value` set then calls are not passed
      to the wrapped object and the `return_value` is returned instead.

    * `name`: If the mock has a name then it will be used in the repr of the
      mock. This can be useful for debugging. The name is propagated to child
      mocks.

    Mocks can also be called with arbitrary keyword arguments. These will be
    used to set attributes on the mock after it is created.
    """



def _dot_lookup(thing, comp, import_path):
    try:
        return getattr(thing, comp)
    except AttributeError:
        __import__(import_path)
        return getattr(thing, comp)


def _importer(target):
    components = target.split('.')
    import_path = components.pop(0)
    thing = __import__(import_path)

    for comp in components:
        import_path += ".%s" % comp
        thing = _dot_lookup(thing, comp, import_path)
    return thing


def _is_started(patcher):
    # XXXX horrible
    return hasattr(patcher, 'is_local')


class _patch(object):

    attribute_name = None
    _active_patches = []

    def __init__(
            self, getter, attribute, new, spec, create,
            spec_set, autospec, new_callable, kwargs
        ):
        if new_callable is not None:
            if new is not DEFAULT:
                raise ValueError(
                    "Cannot use 'new' and 'new_callable' together"
                )
            if autospec is not None:
                raise ValueError(
                    "Cannot use 'autospec' and 'new_callable' together"
                )

        self.getter = getter
        self.attribute = attribute
        self.new = new
        self.new_callable = new_callable
        self.spec = spec
        self.create = create
        self.has_local = False
        self.spec_set = spec_set
        self.autospec = autospec
        self.kwargs = kwargs
        self.additional_patchers = []


    def copy(self):
        patcher = _patch(
            self.getter, self.attribute, self.new, self.spec,
            self.create, self.spec_set,
            self.autospec, self.new_callable, self.kwargs
        )
        patcher.attribute_name = self.attribute_name
        patcher.additional_patchers = [
            p.copy() for p in self.additional_patchers
        ]
        return patcher


    def __call__(self, func):
        if isinstance(func, type):
            return self.decorate_class(func)
        return self.decorate_callable(func)


    def decorate_class(self, klass):
        for attr in dir(klass):
            if not attr.startswith(patch.TEST_PREFIX):
                continue

            attr_value = getattr(klass, attr)
            if not hasattr(attr_value, "__call__"):
                continue

            patcher = self.copy()
            setattr(klass, attr, patcher(attr_value))
        return klass


    def decorate_callable(self, func):
        if hasattr(func, 'patchings'):
            func.patchings.append(self)
            return func

        @wraps(func)
        def patched(*args, **keywargs):
            extra_args = []
            entered_patchers = []

            exc_info = tuple()
            try:
                for patching in patched.patchings:
                    arg = patching.__enter__()
                    entered_patchers.append(patching)
                    if patching.attribute_name is not None:
                        keywargs.update(arg)
                    elif patching.new is DEFAULT:
                        extra_args.append(arg)

                args += tuple(extra_args)
                return func(*args, **keywargs)
            except:
                if (patching not in entered_patchers and
                    _is_started(patching)):
                    # the patcher may have been started, but an exception
                    # raised whilst entering one of its additional_patchers
                    entered_patchers.append(patching)
                # Pass the exception to __exit__
                exc_info = sys.exc_info()
                # re-raise the exception
                raise
            finally:
                for patching in reversed(entered_patchers):
                    patching.__exit__(*exc_info)

        patched.patchings = [self]
        return patched


    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if not self.create and original is DEFAULT:
            raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
        return original, local


    def __enter__(self):
        """Perform the patch."""
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()

        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None

        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")

        original, local = self.get_original()

        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original

            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True

            Klass = MagicMock
            _kwargs = {}
            if new_callable is not None:
                Klass = new_callable
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if not_callable:
                    Klass = NonCallableMagicMock

            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set

            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute

            _kwargs.update(kwargs)
            new = Klass(**_kwargs)

            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock

                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original

            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")

        new_attr = new

        self.temp_original = original
        self.is_local = local
        setattr(self.target, self.attribute, new_attr)
        if self.attribute_name is not None:
            extra_args = {}
            if self.new is DEFAULT:
                extra_args[self.attribute_name] =  new
            for patching in self.additional_patchers:
                arg = patching.__enter__()
                if patching.new is DEFAULT:
                    extra_args.update(arg)
            return extra_args

        return new


    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not _is_started(self):
            raise RuntimeError('stop called on unstarted patcher')

        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
            delattr(self.target, self.attribute)
            if not self.create and not hasattr(self.target, self.attribute):
                # needed for proxy objects like django settings
                setattr(self.target, self.attribute, self.temp_original)

        del self.temp_original
        del self.is_local
        del self.target
        for patcher in reversed(self.additional_patchers):
            if _is_started(patcher):
                patcher.__exit__(*exc_info)


    def start(self):
        """Activate a patch, returning any created mock."""
        result = self.__enter__()
        self._active_patches.append(self)
        return result


    def stop(self):
        """Stop an active patch."""
        try:
            self._active_patches.remove(self)
        except ValueError:
            # If the patch hasn't been started this will fail
            pass

        return self.__exit__()



def _get_target(target):
    try:
        target, attribute = target.rsplit('.', 1)
    except (TypeError, ValueError):
        raise TypeError("Need a valid target to patch. You supplied: %r" %
                        (target,))
    getter = lambda: _importer(target)
    return getter, attribute


def _patch_object(
        target, attribute, new=DEFAULT, spec=None,
        create=False, spec_set=None, autospec=None,
        new_callable=None, **kwargs
    ):
    """
    patch the named member (`attribute`) on an object (`target`) with a mock
    object.

    `patch.object` can be used as a decorator, class decorator or a context
    manager. Arguments `new`, `spec`, `create`, `spec_set`,
    `autospec` and `new_callable` have the same meaning as for `patch`. Like
    `patch`, `patch.object` takes arbitrary keyword arguments for configuring
    the mock object it creates.

    When used as a class decorator `patch.object` honours `patch.TEST_PREFIX`
    for choosing which methods to wrap.
    """
    getter = lambda: target
    return _patch(
        getter, attribute, new, spec, create,
        spec_set, autospec, new_callable, kwargs
    )


def _patch_multiple(target, spec=None, create=False, spec_set=None,
                    autospec=None, new_callable=None, **kwargs):
    """Perform multiple patches in a single call. It takes the object to be
    patched (either as an object or a string to fetch the object by importing)
    and keyword arguments for the patches::

        with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):
            ...

    Use `DEFAULT` as the value if you want `patch.multiple` to create
    mocks for you. In this case the created mocks are passed into a decorated
    function by keyword, and a dictionary is returned when `patch.multiple` is
    used as a context manager.

    `patch.multiple` can be used as a decorator, class decorator or a context
    manager. The arguments `spec`, `spec_set`, `create`,
    `autospec` and `new_callable` have the same meaning as for `patch`. These
    arguments will be applied to *all* patches done by `patch.multiple`.

    When used as a class decorator `patch.multiple` honours `patch.TEST_PREFIX`
    for choosing which methods to wrap.
    """
    if type(target) is str:
        getter = lambda: _importer(target)
    else:
        getter = lambda: target

    if not kwargs:
        raise ValueError(
            'Must supply at least one keyword argument with patch.multiple'
        )
    # need to wrap in a list for python 3, where items is a view
    items = list(kwargs.items())
    attribute, new = items[0]
    patcher = _patch(
        getter, attribute, new, spec, create, spec_set,
        autospec, new_callable, {}
    )
    patcher.attribute_name = attribute
    for attribute, new in items[1:]:
        this_patcher = _patch(
            getter, attribute, new, spec, create, spec_set,
            autospec, new_callable, {}
        )
        this_patcher.attribute_name = attribute
        patcher.additional_patchers.append(this_patcher)
    return patcher


def patch(
        target, new=DEFAULT, spec=None, create=False,
        spec_set=None, autospec=None, new_callable=None, **kwargs
    ):
    """
    `patch` acts as a function decorator, class decorator or a context
    manager. Inside the body of the function or with statement, the `target`
    is patched with a `new` object. When the function/with statement exits
    the patch is undone.

    If `new` is omitted, then the target is replaced with a
    `MagicMock`. If `patch` is used as a decorator and `new` is
    omitted, the created mock is passed in as an extra argument to the
    decorated function. If `patch` is used as a context manager the created
    mock is returned by the context manager.

    `target` should be a string in the form `'package.module.ClassName'`. The
    `target` is imported and the specified object replaced with the `new`
    object, so the `target` must be importable from the environment you are
    calling `patch` from. The target is imported when the decorated function
    is executed, not at decoration time.

    The `spec` and `spec_set` keyword arguments are passed to the `MagicMock`
    if patch is creating one for you.

    In addition you can pass `spec=True` or `spec_set=True`, which causes
    patch to pass in the object being mocked as the spec/spec_set object.

    `new_callable` allows you to specify a different class, or callable object,
    that will be called to create the `new` object. By default `MagicMock` is
    used.

    A more powerful form of `spec` is `autospec`. If you set `autospec=True`
    then the mock with be created with a spec from the object being replaced.
    All attributes of the mock will also have the spec of the corresponding
    attribute of the object being replaced. Methods and functions being
    mocked will have their arguments checked and will raise a `TypeError` if
    they are called with the wrong signature. For mocks replacing a class,
    their return value (the 'instance') will have the same spec as the class.

    Instead of `autospec=True` you can pass `autospec=some_object` to use an
    arbitrary object as the spec instead of the one being replaced.

    By default `patch` will fail to replace attributes that don't exist. If
    you pass in `create=True`, and the attribute doesn't exist, patch will
    create the attribute for you when the patched function is called, and
    delete it again afterwards. This is useful for writing tests against
    attributes that your production code creates at runtime. It is off by
    default because it can be dangerous. With it switched on you can write
    passing tests against APIs that don't actually exist!

    Patch can be used as a `TestCase` class decorator. It works by
    decorating each test method in the class. This reduces the boilerplate
    code when your test methods share a common patchings set. `patch` finds
    tests by looking for method names that start with `patch.TEST_PREFIX`.
    By default this is `test`, which matches the way `unittest` finds tests.
    You can specify an alternative prefix by setting `patch.TEST_PREFIX`.

    Patch can be used as a context manager, with the with statement. Here the
    patching applies to the indented block after the with statement. If you
    use "as" then the patched object will be bound to the name after the
    "as"; very useful if `patch` is creating a mock object for you.

    `patch` takes arbitrary keyword arguments. These will be passed to
    the `Mock` (or `new_callable`) on construction.

    `patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are
    available for alternate use-cases.
    """
    getter, attribute = _get_target(target)
    return _patch(
        getter, attribute, new, spec, create,
        spec_set, autospec, new_callable, kwargs
    )


class _patch_dict(object):
    """
    Patch a dictionary, or dictionary like object, and restore the dictionary
    to its original state after the test.

    `in_dict` can be a dictionary or a mapping like container. If it is a
    mapping then it must at least support getting, setting and deleting items
    plus iterating over keys.

    `in_dict` can also be a string specifying the name of the dictionary, which
    will then be fetched by importing it.

    `values` can be a dictionary of values to set in the dictionary. `values`
    can also be an iterable of `(key, value)` pairs.

    If `clear` is True then the dictionary will be cleared before the new
    values are set.

    `patch.dict` can also be called with arbitrary keyword arguments to set
    values in the dictionary::

        with patch.dict('sys.modules', mymodule=Mock(), other_module=Mock()):
            ...

    `patch.dict` can be used as a context manager, decorator or class
    decorator. When used as a class decorator `patch.dict` honours
    `patch.TEST_PREFIX` for choosing which methods to wrap.
    """

    def __init__(self, in_dict, values=(), clear=False, **kwargs):
        if isinstance(in_dict, str):
            in_dict = _importer(in_dict)
        self.in_dict = in_dict
        # support any argument supported by dict(...) constructor
        self.values = dict(values)
        self.values.update(kwargs)
        self.clear = clear
        self._original = None


    def __call__(self, f):
        if isinstance(f, type):
            return self.decorate_class(f)
        @wraps(f)
        def _inner(*args, **kw):
            self._patch_dict()
            try:
                return f(*args, **kw)
            finally:
                self._unpatch_dict()

        return _inner


    def decorate_class(self, klass):
        for attr in dir(klass):
            attr_value = getattr(klass, attr)
            if (attr.startswith(patch.TEST_PREFIX) and
                 hasattr(attr_value, "__call__")):
                decorator = _patch_dict(self.in_dict, self.values, self.clear)
                decorated = decorator(attr_value)
                setattr(klass, attr, decorated)
        return klass


    def __enter__(self):
        """Patch the dict."""
        self._patch_dict()


    def _patch_dict(self):
        values = self.values
        in_dict = self.in_dict
        clear = self.clear

        try:
            original = in_dict.copy()
        except AttributeError:
            # dict like object with no copy method
            # must support iteration over keys
            original = {}
            for key in in_dict:
                original[key] = in_dict[key]
        self._original = original

        if clear:
            _clear_dict(in_dict)

        try:
            in_dict.update(values)
        except AttributeError:
            # dict like object with no update method
            for key in values:
                in_dict[key] = values[key]


    def _unpatch_dict(self):
        in_dict = self.in_dict
        original = self._original

        _clear_dict(in_dict)

        try:
            in_dict.update(original)
        except AttributeError:
            for key in original:
                in_dict[key] = original[key]


    def __exit__(self, *args):
        """Unpatch the dict."""
        self._unpatch_dict()
        return False

    start = __enter__
    stop = __exit__


def _clear_dict(in_dict):
    try:
        in_dict.clear()
    except AttributeError:
        keys = list(in_dict)
        for key in keys:
            del in_dict[key]


def _patch_stopall():
    """Stop all active patches. LIFO to unroll nested patches."""
    for patch in reversed(_patch._active_patches):
        patch.stop()


patch.object = _patch_object
patch.dict = _patch_dict
patch.multiple = _patch_multiple
patch.stopall = _patch_stopall
patch.TEST_PREFIX = 'test'

magic_methods = (
    "lt le gt ge eq ne "
    "getitem setitem delitem "
    "len contains iter "
    "hash str sizeof "
    "enter exit "
    "divmod neg pos abs invert "
    "complex int float index "
    "trunc floor ceil "
    "bool next "
)

numerics = (
    "add sub mul div floordiv mod lshift rshift and xor or pow truediv"
)
inplace = ' '.join('i%s' % n for n in numerics.split())
right = ' '.join('r%s' % n for n in numerics.split())

# not including __prepare__, __instancecheck__, __subclasscheck__
# (as they are metaclass methods)
# __del__ is not supported at all as it causes problems if it exists

_non_defaults = set('__%s__' % method for method in [
    'get', 'set', 'delete', 'reversed', 'missing', 'reduce', 'reduce_ex',
    'getinitargs', 'getnewargs', 'getstate', 'setstate', 'getformat',
    'setformat', 'repr', 'dir', 'subclasses', 'format',
])


def _get_method(name, func):
    "Turns a callable object (like a mock) into a real function"
    def method(self, *args, **kw):
        return func(self, *args, **kw)
    method.__name__ = name
    return method


_magics = set(
    '__%s__' % method for method in
    ' '.join([magic_methods, numerics, inplace, right]).split()
)

_all_magics = _magics | _non_defaults

_unsupported_magics = set([
    '__getattr__', '__setattr__',
    '__init__', '__new__', '__prepare__'
    '__instancecheck__', '__subclasscheck__',
    '__del__'
])

_calculate_return_value = {
    '__hash__': lambda self: object.__hash__(self),
    '__str__': lambda self: object.__str__(self),
    '__sizeof__': lambda self: object.__sizeof__(self),
}

_return_values = {
    '__lt__': NotImplemented,
    '__gt__': NotImplemented,
    '__le__': NotImplemented,
    '__ge__': NotImplemented,
    '__int__': 1,
    '__contains__': False,
    '__len__': 0,
    '__exit__': False,
    '__complex__': 1j,
    '__float__': 1.0,
    '__bool__': True,
    '__index__': 1,
}


def _get_eq(self):
    def __eq__(other):
        ret_val = self.__eq__._mock_return_value
        if ret_val is not DEFAULT:
            return ret_val
        return self is other
    return __eq__

def _get_ne(self):
    def __ne__(other):
        if self.__ne__._mock_return_value is not DEFAULT:
            return DEFAULT
        return self is not other
    return __ne__

def _get_iter(self):
    def __iter__():
        ret_val = self.__iter__._mock_return_value
        if ret_val is DEFAULT:
            return iter([])
        # if ret_val was already an iterator, then calling iter on it should
        # return the iterator unchanged
        return iter(ret_val)
    return __iter__

_side_effect_methods = {
    '__eq__': _get_eq,
    '__ne__': _get_ne,
    '__iter__': _get_iter,
}



def _set_return_value(mock, method, name):
    fixed = _return_values.get(name, DEFAULT)
    if fixed is not DEFAULT:
        method.return_value = fixed
        return

    return_calulator = _calculate_return_value.get(name)
    if return_calulator is not None:
        try:
            return_value = return_calulator(mock)
        except AttributeError:
            # XXXX why do we return AttributeError here?
            #      set it as a side_effect instead?
            return_value = AttributeError(name)
        method.return_value = return_value
        return

    side_effector = _side_effect_methods.get(name)
    if side_effector is not None:
        method.side_effect = side_effector(mock)



class MagicMixin(object):
    def __init__(self, *args, **kw):
        _safe_super(MagicMixin, self).__init__(*args, **kw)
        self._mock_set_magics()


    def _mock_set_magics(self):
        these_magics = _magics

        if self._mock_methods is not None:
            these_magics = _magics.intersection(self._mock_methods)

            remove_magics = set()
            remove_magics = _magics - these_magics

            for entry in remove_magics:
                if entry in type(self).__dict__:
                    # remove unneeded magic methods
                    delattr(self, entry)

        # don't overwrite existing attributes if called a second time
        these_magics = these_magics - set(type(self).__dict__)

        _type = type(self)
        for entry in these_magics:
            setattr(_type, entry, MagicProxy(entry, self))



class NonCallableMagicMock(MagicMixin, NonCallableMock):
    """A version of `MagicMock` that isn't callable."""
    def mock_add_spec(self, spec, spec_set=False):
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set."""
        self._mock_add_spec(spec, spec_set)
        self._mock_set_magics()



class MagicMock(MagicMixin, Mock):
    """
    MagicMock is a subclass of Mock with default implementations
    of most of the magic methods. You can use MagicMock without having to
    configure the magic methods yourself.

    If you use the `spec` or `spec_set` arguments then *only* magic
    methods that exist in the spec will be created.

    Attributes and the return value of a `MagicMock` will also be `MagicMocks`.
    """
    def mock_add_spec(self, spec, spec_set=False):
        """Add a spec to a mock. `spec` can either be an object or a
        list of strings. Only attributes on the `spec` can be fetched as
        attributes from the mock.

        If `spec_set` is True then only attributes on the spec can be set."""
        self._mock_add_spec(spec, spec_set)
        self._mock_set_magics()



class MagicProxy(object):
    def __init__(self, name, parent):
        self.name = name
        self.parent = parent

    def __call__(self, *args, **kwargs):
        m = self.create_mock()
        return m(*args, **kwargs)

    def create_mock(self):
        entry = self.name
        parent = self.parent
        m = parent._get_child_mock(name=entry, _new_name=entry,
                                   _new_parent=parent)
        setattr(parent, entry, m)
        _set_return_value(parent, m, entry)
        return m

    def __get__(self, obj, _type=None):
        return self.create_mock()



class _ANY(object):
    "A helper object that compares equal to everything."

    def __eq__(self, other):
        return True

    def __ne__(self, other):
        return False

    def __repr__(self):
        return '<ANY>'

ANY = _ANY()



def _format_call_signature(name, args, kwargs):
    message = '%s(%%s)' % name
    formatted_args = ''
    args_string = ', '.join([repr(arg) for arg in args])
    kwargs_string = ', '.join([
        '%s=%r' % (key, value) for key, value in kwargs.items()
    ])
    if args_string:
        formatted_args = args_string
    if kwargs_string:
        if formatted_args:
            formatted_args += ', '
        formatted_args += kwargs_string

    return message % formatted_args



class _Call(tuple):
    """
    A tuple for holding the results of a call to a mock, either in the form
    `(args, kwargs)` or `(name, args, kwargs)`.

    If args or kwargs are empty then a call tuple will compare equal to
    a tuple without those values. This makes comparisons less verbose::

        _Call(('name', (), {})) == ('name',)
        _Call(('name', (1,), {})) == ('name', (1,))
        _Call(((), {'a': 'b'})) == ({'a': 'b'},)

    The `_Call` object provides a useful shortcut for comparing with call::

        _Call(((1, 2), {'a': 3})) == call(1, 2, a=3)
        _Call(('foo', (1, 2), {'a': 3})) == call.foo(1, 2, a=3)

    If the _Call has no name then it will match any name.
    """
    def __new__(cls, value=(), name=None, parent=None, two=False,
                from_kall=True):
        name = ''
        args = ()
        kwargs = {}
        _len = len(value)
        if _len == 3:
            name, args, kwargs = value
        elif _len == 2:
            first, second = value
            if isinstance(first, str):
                name = first
                if isinstance(second, tuple):
                    args = second
                else:
                    kwargs = second
            else:
                args, kwargs = first, second
        elif _len == 1:
            value, = value
            if isinstance(value, str):
                name = value
            elif isinstance(value, tuple):
                args = value
            else:
                kwargs = value

        if two:
            return tuple.__new__(cls, (args, kwargs))

        return tuple.__new__(cls, (name, args, kwargs))


    def __init__(self, value=(), name=None, parent=None, two=False,
                 from_kall=True):
        self.name = name
        self.parent = parent
        self.from_kall = from_kall


    def __eq__(self, other):
        if other is ANY:
            return True
        try:
            len_other = len(other)
        except TypeError:
            return False

        self_name = ''
        if len(self) == 2:
            self_args, self_kwargs = self
        else:
            self_name, self_args, self_kwargs = self

        other_name = ''
        if len_other == 0:
            other_args, other_kwargs = (), {}
        elif len_other == 3:
            other_name, other_args, other_kwargs = other
        elif len_other == 1:
            value, = other
            if isinstance(value, tuple):
                other_args = value
                other_kwargs = {}
            elif isinstance(value, str):
                other_name = value
                other_args, other_kwargs = (), {}
            else:
                other_args = ()
                other_kwargs = value
        else:
            # len 2
            # could be (name, args) or (name, kwargs) or (args, kwargs)
            first, second = other
            if isinstance(first, str):
                other_name = first
                if isinstance(second, tuple):
                    other_args, other_kwargs = second, {}
                else:
                    other_args, other_kwargs = (), second
            else:
                other_args, other_kwargs = first, second

        if self_name and other_name != self_name:
            return False

        # this order is important for ANY to work!
        return (other_args, other_kwargs) == (self_args, self_kwargs)


    def __ne__(self, other):
        return not self.__eq__(other)


    def __call__(self, *args, **kwargs):
        if self.name is None:
            return _Call(('', args, kwargs), name='()')

        name = self.name + '()'
        return _Call((self.name, args, kwargs), name=name, parent=self)


    def __getattr__(self, attr):
        if self.name is None:
            return _Call(name=attr, from_kall=False)
        name = '%s.%s' % (self.name, attr)
        return _Call(name=name, parent=self, from_kall=False)


    def __repr__(self):
        if not self.from_kall:
            name = self.name or 'call'
            if name.startswith('()'):
                name = 'call%s' % name
            return name

        if len(self) == 2:
            name = 'call'
            args, kwargs = self
        else:
            name, args, kwargs = self
            if not name:
                name = 'call'
            elif not name.startswith('()'):
                name = 'call.%s' % name
            else:
                name = 'call%s' % name
        return _format_call_signature(name, args, kwargs)


    def call_list(self):
        """For a call object that represents multiple calls, `call_list`
        returns a list of all the intermediate calls as well as the
        final call."""
        vals = []
        thing = self
        while thing is not None:
            if thing.from_kall:
                vals.append(thing)
            thing = thing.parent
        return _CallList(reversed(vals))


call = _Call(from_kall=False)



def create_autospec(spec, spec_set=False, instance=False, _parent=None,
                    _name=None, **kwargs):
    """Create a mock object using another object as a spec. Attributes on the
    mock will use the corresponding attribute on the `spec` object as their
    spec.

    Functions or methods being mocked will have their arguments checked
    to check that they are called with the correct signature.

    If `spec_set` is True then attempting to set attributes that don't exist
    on the spec object will raise an `AttributeError`.

    If a class is used as a spec then the return value of the mock (the
    instance of the class) will have the same spec. You can use a class as the
    spec for an instance object by passing `instance=True`. The returned mock
    will only be callable if instances of the mock are callable.

    `create_autospec` also takes arbitrary keyword arguments that are passed to
    the constructor of the created mock."""
    if _is_list(spec):
        # can't pass a list instance to the mock constructor as it will be
        # interpreted as a list of strings
        spec = type(spec)

    is_type = isinstance(spec, type)

    _kwargs = {'spec': spec}
    if spec_set:
        _kwargs = {'spec_set': spec}
    elif spec is None:
        # None we mock with a normal mock without a spec
        _kwargs = {}
    if _kwargs and instance:
        _kwargs['_spec_as_instance'] = True

    _kwargs.update(kwargs)

    Klass = MagicMock
    if type(spec) in DescriptorTypes:
        # descriptors don't have a spec
        # because we don't know what type they return
        _kwargs = {}
    elif not _callable(spec):
        Klass = NonCallableMagicMock
    elif is_type and instance and not _instance_callable(spec):
        Klass = NonCallableMagicMock

    _name = _kwargs.pop('name', _name)

    _new_name = _name
    if _parent is None:
        # for a top level object no _new_name should be set
        _new_name = ''

    mock = Klass(parent=_parent, _new_parent=_parent, _new_name=_new_name,
                 name=_name, **_kwargs)

    if isinstance(spec, FunctionTypes):
        # should only happen at the top level because we don't
        # recurse for functions
        mock = _set_signature(mock, spec)
    else:
        _check_signature(spec, mock, is_type, instance)

    if _parent is not None and not instance:
        _parent._mock_children[_name] = mock

    if is_type and not instance and 'return_value' not in kwargs:
        mock.return_value = create_autospec(spec, spec_set, instance=True,
                                            _name='()', _parent=mock)

    for entry in dir(spec):
        if _is_magic(entry):
            # MagicMock already does the useful magic methods for us
            continue

        # XXXX do we need a better way of getting attributes without
        # triggering code execution (?) Probably not - we need the actual
        # object to mock it so we would rather trigger a property than mock
        # the property descriptor. Likewise we want to mock out dynamically
        # provided attributes.
        # XXXX what about attributes that raise exceptions other than
        # AttributeError on being fetched?
        # we could be resilient against it, or catch and propagate the
        # exception when the attribute is fetched from the mock
        try:
            original = getattr(spec, entry)
        except AttributeError:
            continue

        kwargs = {'spec': original}
        if spec_set:
            kwargs = {'spec_set': original}

        if not isinstance(original, FunctionTypes):
            new = _SpecState(original, spec_set, mock, entry, instance)
            mock._mock_children[entry] = new
        else:
            parent = mock
            if isinstance(spec, FunctionTypes):
                parent = mock.mock

            skipfirst = _must_skip(spec, entry, is_type)
            kwargs['_eat_self'] = skipfirst
            new = MagicMock(parent=parent, name=entry, _new_name=entry,
                            _new_parent=parent,
                            **kwargs)
            mock._mock_children[entry] = new
            _check_signature(original, new, skipfirst=skipfirst)

        # so functions created with _set_signature become instance attributes,
        # *plus* their underlying mock exists in _mock_children of the parent
        # mock. Adding to _mock_children may be unnecessary where we are also
        # setting as an instance attribute?
        if isinstance(new, FunctionTypes):
            setattr(mock, entry, new)

    return mock


def _must_skip(spec, entry, is_type):
    """
    Return whether we should skip the first argument on spec's `entry`
    attribute.
    """
    if not isinstance(spec, type):
        if entry in getattr(spec, '__dict__', {}):
            # instance attribute - shouldn't skip
            return False
        spec = spec.__class__

    for klass in spec.__mro__:
        result = klass.__dict__.get(entry, DEFAULT)
        if result is DEFAULT:
            continue
        if isinstance(result, (staticmethod, classmethod)):
            return False
        elif isinstance(getattr(result, '__get__', None), MethodWrapperTypes):
            # Normal method => skip if looked up on type
            # (if looked up on instance, self is already skipped)
            return is_type
        else:
            return False

    # shouldn't get here unless function is a dynamically provided attribute
    # XXXX untested behaviour
    return is_type


def _get_class(obj):
    try:
        return obj.__class__
    except AttributeError:
        # it is possible for objects to have no __class__
        return type(obj)


class _SpecState(object):

    def __init__(self, spec, spec_set=False, parent=None,
                 name=None, ids=None, instance=False):
        self.spec = spec
        self.ids = ids
        self.spec_set = spec_set
        self.parent = parent
        self.instance = instance
        self.name = name


FunctionTypes = (
    # python function
    type(create_autospec),
    # instance method
    type(ANY.__eq__),
)

MethodWrapperTypes = (
    type(ANY.__eq__.__get__),
)


file_spec = None

def _iterate_read_data(read_data):
    # Helper for mock_open:
    # Retrieve lines from read_data via a generator so that separate calls to
    # readline, read, and readlines are properly interleaved
    data_as_list = ['{}\n'.format(l) for l in read_data.split('\n')]

    if data_as_list[-1] == '\n':
        # If the last line ended in a newline, the list comprehension will have an
        # extra entry that's just a newline.  Remove this.
        data_as_list = data_as_list[:-1]
    else:
        # If there wasn't an extra newline by itself, then the file being
        # emulated doesn't have a newline to end the last line  remove the
        # newline that our naive format() added
        data_as_list[-1] = data_as_list[-1][:-1]

    for line in data_as_list:
        yield line

def mock_open(mock=None, read_data=''):
    """
    A helper function to create a mock to replace the use of `open`. It works
    for `open` called directly or used as a context manager.

    The `mock` argument is the mock object to configure. If `None` (the
    default) then a `MagicMock` will be created for you, with the API limited
    to methods or attributes available on standard file handles.

    `read_data` is a string for the `read` methoddline`, and `readlines` of the
    file handle to return.  This is an empty string by default.
    """
    def _readlines_side_effect(*args, **kwargs):
        if handle.readlines.return_value is not None:
            return handle.readlines.return_value
        return list(_data)

    def _read_side_effect(*args, **kwargs):
        if handle.read.return_value is not None:
            return handle.read.return_value
        return ''.join(_data)

    def _readline_side_effect():
        if handle.readline.return_value is not None:
            while True:
                yield handle.readline.return_value
        for line in _data:
            yield line


    global file_spec
    if file_spec is None:
        import _io
        file_spec = list(set(dir(_io.TextIOWrapper)).union(set(dir(_io.BytesIO))))

    if mock is None:
        mock = MagicMock(name='open', spec=open)

    handle = MagicMock(spec=file_spec)
    handle.__enter__.return_value = handle

    _data = _iterate_read_data(read_data)

    handle.write.return_value = None
    handle.read.return_value = None
    handle.readline.return_value = None
    handle.readlines.return_value = None

    handle.read.side_effect = _read_side_effect
    handle.readline.side_effect = _readline_side_effect()
    handle.readlines.side_effect = _readlines_side_effect

    mock.return_value = handle
    return mock


class PropertyMock(Mock):
    """
    A mock intended to be used as a property, or other descriptor, on a class.
    `PropertyMock` provides `__get__` and `__set__` methods so you can specify
    a return value when it is fetched.

    Fetching a `PropertyMock` instance from an object calls the mock, with
    no args. Setting it calls the mock with the value being set.
    """
    def _get_child_mock(self, **kwargs):
        return MagicMock(**kwargs)

    def __get__(self, obj, obj_type):
        return self()
    def __set__(self, obj, val):
        self(val)
                                                                                                                                                                                                                                                           usr/lib/python3.4/unittest/result.py                                                                0100644 0000000 0000000 00000016214 12415221640 016142  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Test result object"""

import io
import sys
import traceback

from . import util
from functools import wraps

__unittest = True

def failfast(method):
    @wraps(method)
    def inner(self, *args, **kw):
        if getattr(self, 'failfast', False):
            self.stop()
        return method(self, *args, **kw)
    return inner

STDOUT_LINE = '\nStdout:\n%s'
STDERR_LINE = '\nStderr:\n%s'


class TestResult(object):
    """Holder for test result information.

    Test results are automatically managed by the TestCase and TestSuite
    classes, and do not need to be explicitly manipulated by writers of tests.

    Each instance holds the total number of tests run, and collections of
    failures and errors that occurred among those test runs. The collections
    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the
    formatted traceback of the error that occurred.
    """
    _previousTestClass = None
    _testRunEntered = False
    _moduleSetUpFailed = False
    def __init__(self, stream=None, descriptions=None, verbosity=None):
        self.failfast = False
        self.failures = []
        self.errors = []
        self.testsRun = 0
        self.skipped = []
        self.expectedFailures = []
        self.unexpectedSuccesses = []
        self.shouldStop = False
        self.buffer = False
        self._stdout_buffer = None
        self._stderr_buffer = None
        self._original_stdout = sys.stdout
        self._original_stderr = sys.stderr
        self._mirrorOutput = False

    def printErrors(self):
        "Called by TestRunner after test run"

    def startTest(self, test):
        "Called when the given test is about to be run"
        self.testsRun += 1
        self._mirrorOutput = False
        self._setupStdout()

    def _setupStdout(self):
        if self.buffer:
            if self._stderr_buffer is None:
                self._stderr_buffer = io.StringIO()
                self._stdout_buffer = io.StringIO()
            sys.stdout = self._stdout_buffer
            sys.stderr = self._stderr_buffer

    def startTestRun(self):
        """Called once before any tests are executed.

        See startTest for a method called before each test.
        """

    def stopTest(self, test):
        """Called when the given test has been run"""
        self._restoreStdout()
        self._mirrorOutput = False

    def _restoreStdout(self):
        if self.buffer:
            if self._mirrorOutput:
                output = sys.stdout.getvalue()
                error = sys.stderr.getvalue()
                if output:
                    if not output.endswith('\n'):
                        output += '\n'
                    self._original_stdout.write(STDOUT_LINE % output)
                if error:
                    if not error.endswith('\n'):
                        error += '\n'
                    self._original_stderr.write(STDERR_LINE % error)

            sys.stdout = self._original_stdout
            sys.stderr = self._original_stderr
            self._stdout_buffer.seek(0)
            self._stdout_buffer.truncate()
            self._stderr_buffer.seek(0)
            self._stderr_buffer.truncate()

    def stopTestRun(self):
        """Called once after all tests are executed.

        See stopTest for a method called after each test.
        """

    @failfast
    def addError(self, test, err):
        """Called when an error has occurred. 'err' is a tuple of values as
        returned by sys.exc_info().
        """
        self.errors.append((test, self._exc_info_to_string(err, test)))
        self._mirrorOutput = True

    @failfast
    def addFailure(self, test, err):
        """Called when an error has occurred. 'err' is a tuple of values as
        returned by sys.exc_info()."""
        self.failures.append((test, self._exc_info_to_string(err, test)))
        self._mirrorOutput = True

    @failfast
    def addSubTest(self, test, subtest, err):
        """Called at the end of a subtest.
        'err' is None if the subtest ended successfully, otherwise it's a
        tuple of values as returned by sys.exc_info().
        """
        # By default, we don't do anything with successful subtests, but
        # more sophisticated test results might want to record them.
        if err is not None:
            if issubclass(err[0], test.failureException):
                errors = self.failures
            else:
                errors = self.errors
            errors.append((subtest, self._exc_info_to_string(err, test)))
            self._mirrorOutput = True

    def addSuccess(self, test):
        "Called when a test has completed successfully"
        pass

    def addSkip(self, test, reason):
        """Called when a test is skipped."""
        self.skipped.append((test, reason))

    def addExpectedFailure(self, test, err):
        """Called when an expected failure/error occured."""
        self.expectedFailures.append(
            (test, self._exc_info_to_string(err, test)))

    @failfast
    def addUnexpectedSuccess(self, test):
        """Called when a test was expected to fail, but succeed."""
        self.unexpectedSuccesses.append(test)

    def wasSuccessful(self):
        """Tells whether or not this result was a success."""
        # The hasattr check is for test_result's OldResult test.  That
        # way this method works on objects that lack the attribute.
        # (where would such result intances come from? old stored pickles?)
        return ((len(self.failures) == len(self.errors) == 0) and
                (not hasattr(self, 'unexpectedSuccesses') or
                 len(self.unexpectedSuccesses) == 0))

    def stop(self):
        """Indicates that the tests should be aborted."""
        self.shouldStop = True

    def _exc_info_to_string(self, err, test):
        """Converts a sys.exc_info()-style tuple of values into a string."""
        exctype, value, tb = err
        # Skip test runner traceback levels
        while tb and self._is_relevant_tb_level(tb):
            tb = tb.tb_next

        if exctype is test.failureException:
            # Skip assert*() traceback levels
            length = self._count_relevant_tb_levels(tb)
            msgLines = traceback.format_exception(exctype, value, tb, length)
        else:
            msgLines = traceback.format_exception(exctype, value, tb)

        if self.buffer:
            output = sys.stdout.getvalue()
            error = sys.stderr.getvalue()
            if output:
                if not output.endswith('\n'):
                    output += '\n'
                msgLines.append(STDOUT_LINE % output)
            if error:
                if not error.endswith('\n'):
                    error += '\n'
                msgLines.append(STDERR_LINE % error)
        return ''.join(msgLines)


    def _is_relevant_tb_level(self, tb):
        return '__unittest' in tb.tb_frame.f_globals

    def _count_relevant_tb_levels(self, tb):
        length = 0
        while tb and not self._is_relevant_tb_level(tb):
            length += 1
            tb = tb.tb_next
        return length

    def __repr__(self):
        return ("<%s run=%i errors=%i failures=%i>" %
               (util.strclass(self.__class__), self.testsRun, len(self.errors),
                len(self.failures)))
                                                                                                                                                                                                                                                                                                                                                                                    usr/lib/python3.4/unittest/runner.py                                                                0100644 0000000 0000000 00000016474 12415221640 016145  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Running tests"""

import sys
import time
import warnings

from . import result
from .signals import registerResult

__unittest = True


class _WritelnDecorator(object):
    """Used to decorate file-like objects with a handy 'writeln' method"""
    def __init__(self,stream):
        self.stream = stream

    def __getattr__(self, attr):
        if attr in ('stream', '__getstate__'):
            raise AttributeError(attr)
        return getattr(self.stream,attr)

    def writeln(self, arg=None):
        if arg:
            self.write(arg)
        self.write('\n') # text-mode streams translate to \r\n if needed


class TextTestResult(result.TestResult):
    """A test result class that can print formatted text results to a stream.

    Used by TextTestRunner.
    """
    separator1 = '=' * 70
    separator2 = '-' * 70

    def __init__(self, stream, descriptions, verbosity):
        super(TextTestResult, self).__init__(stream, descriptions, verbosity)
        self.stream = stream
        self.showAll = verbosity > 1
        self.dots = verbosity == 1
        self.descriptions = descriptions

    def getDescription(self, test):
        doc_first_line = test.shortDescription()
        if self.descriptions and doc_first_line:
            return '\n'.join((str(test), doc_first_line))
        else:
            return str(test)

    def startTest(self, test):
        super(TextTestResult, self).startTest(test)
        if self.showAll:
            self.stream.write(self.getDescription(test))
            self.stream.write(" ... ")
            self.stream.flush()

    def addSuccess(self, test):
        super(TextTestResult, self).addSuccess(test)
        if self.showAll:
            self.stream.writeln("ok")
        elif self.dots:
            self.stream.write('.')
            self.stream.flush()

    def addError(self, test, err):
        super(TextTestResult, self).addError(test, err)
        if self.showAll:
            self.stream.writeln("ERROR")
        elif self.dots:
            self.stream.write('E')
            self.stream.flush()

    def addFailure(self, test, err):
        super(TextTestResult, self).addFailure(test, err)
        if self.showAll:
            self.stream.writeln("FAIL")
        elif self.dots:
            self.stream.write('F')
            self.stream.flush()

    def addSkip(self, test, reason):
        super(TextTestResult, self).addSkip(test, reason)
        if self.showAll:
            self.stream.writeln("skipped {0!r}".format(reason))
        elif self.dots:
            self.stream.write("s")
            self.stream.flush()

    def addExpectedFailure(self, test, err):
        super(TextTestResult, self).addExpectedFailure(test, err)
        if self.showAll:
            self.stream.writeln("expected failure")
        elif self.dots:
            self.stream.write("x")
            self.stream.flush()

    def addUnexpectedSuccess(self, test):
        super(TextTestResult, self).addUnexpectedSuccess(test)
        if self.showAll:
            self.stream.writeln("unexpected success")
        elif self.dots:
            self.stream.write("u")
            self.stream.flush()

    def printErrors(self):
        if self.dots or self.showAll:
            self.stream.writeln()
        self.printErrorList('ERROR', self.errors)
        self.printErrorList('FAIL', self.failures)

    def printErrorList(self, flavour, errors):
        for test, err in errors:
            self.stream.writeln(self.separator1)
            self.stream.writeln("%s: %s" % (flavour,self.getDescription(test)))
            self.stream.writeln(self.separator2)
            self.stream.writeln("%s" % err)


class TextTestRunner(object):
    """A test runner class that displays results in textual form.

    It prints out the names of tests as they are run, errors as they
    occur, and a summary of the results at the end of the test run.
    """
    resultclass = TextTestResult

    def __init__(self, stream=None, descriptions=True, verbosity=1,
                 failfast=False, buffer=False, resultclass=None, warnings=None):
        if stream is None:
            stream = sys.stderr
        self.stream = _WritelnDecorator(stream)
        self.descriptions = descriptions
        self.verbosity = verbosity
        self.failfast = failfast
        self.buffer = buffer
        self.warnings = warnings
        if resultclass is not None:
            self.resultclass = resultclass

    def _makeResult(self):
        return self.resultclass(self.stream, self.descriptions, self.verbosity)

    def run(self, test):
        "Run the given test case or test suite."
        result = self._makeResult()
        registerResult(result)
        result.failfast = self.failfast
        result.buffer = self.buffer
        with warnings.catch_warnings():
            if self.warnings:
                # if self.warnings is set, use it to filter all the warnings
                warnings.simplefilter(self.warnings)
                # if the filter is 'default' or 'always', special-case the
                # warnings from the deprecated unittest methods to show them
                # no more than once per module, because they can be fairly
                # noisy.  The -Wd and -Wa flags can be used to bypass this
                # only when self.warnings is None.
                if self.warnings in ['default', 'always']:
                    warnings.filterwarnings('module',
                            category=DeprecationWarning,
                            message='Please use assert\w+ instead.')
            startTime = time.time()
            startTestRun = getattr(result, 'startTestRun', None)
            if startTestRun is not None:
                startTestRun()
            try:
                test(result)
            finally:
                stopTestRun = getattr(result, 'stopTestRun', None)
                if stopTestRun is not None:
                    stopTestRun()
            stopTime = time.time()
        timeTaken = stopTime - startTime
        result.printErrors()
        if hasattr(result, 'separator2'):
            self.stream.writeln(result.separator2)
        run = result.testsRun
        self.stream.writeln("Ran %d test%s in %.3fs" %
                            (run, run != 1 and "s" or "", timeTaken))
        self.stream.writeln()

        expectedFails = unexpectedSuccesses = skipped = 0
        try:
            results = map(len, (result.expectedFailures,
                                result.unexpectedSuccesses,
                                result.skipped))
        except AttributeError:
            pass
        else:
            expectedFails, unexpectedSuccesses, skipped = results

        infos = []
        if not result.wasSuccessful():
            self.stream.write("FAILED")
            failed, errored = len(result.failures), len(result.errors)
            if failed:
                infos.append("failures=%d" % failed)
            if errored:
                infos.append("errors=%d" % errored)
        else:
            self.stream.write("OK")
        if skipped:
            infos.append("skipped=%d" % skipped)
        if expectedFails:
            infos.append("expected failures=%d" % expectedFails)
        if unexpectedSuccesses:
            infos.append("unexpected successes=%d" % unexpectedSuccesses)
        if infos:
            self.stream.writeln(" (%s)" % (", ".join(infos),))
        else:
            self.stream.write("\n")
        return result
                                                                                                                                                                                                    usr/lib/python3.4/unittest/signals.py                                                               0100644 0000000 0000000 00000004543 12415221640 016266  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import signal
import weakref

from functools import wraps

__unittest = True


class _InterruptHandler(object):
    def __init__(self, default_handler):
        self.called = False
        self.original_handler = default_handler
        if isinstance(default_handler, int):
            if default_handler == signal.SIG_DFL:
                # Pretend it's signal.default_int_handler instead.
                default_handler = signal.default_int_handler
            elif default_handler == signal.SIG_IGN:
                # Not quite the same thing as SIG_IGN, but the closest we
                # can make it: do nothing.
                def default_handler(unused_signum, unused_frame):
                    pass
            else:
                raise TypeError("expected SIGINT signal handler to be "
                                "signal.SIG_IGN, signal.SIG_DFL, or a "
                                "callable object")
        self.default_handler = default_handler

    def __call__(self, signum, frame):
        installed_handler = signal.getsignal(signal.SIGINT)
        if installed_handler is not self:
            # if we aren't the installed handler, then delegate immediately
            # to the default handler
            self.default_handler(signum, frame)

        if self.called:
            self.default_handler(signum, frame)
        self.called = True
        for result in _results.keys():
            result.stop()

_results = weakref.WeakKeyDictionary()
def registerResult(result):
    _results[result] = 1

def removeResult(result):
    return bool(_results.pop(result, None))

_interrupt_handler = None
def installHandler():
    global _interrupt_handler
    if _interrupt_handler is None:
        default_handler = signal.getsignal(signal.SIGINT)
        _interrupt_handler = _InterruptHandler(default_handler)
        signal.signal(signal.SIGINT, _interrupt_handler)


def removeHandler(method=None):
    if method is not None:
        @wraps(method)
        def inner(*args, **kwargs):
            initial = signal.getsignal(signal.SIGINT)
            removeHandler()
            try:
                return method(*args, **kwargs)
            finally:
                signal.signal(signal.SIGINT, initial)
        return inner

    global _interrupt_handler
    if _interrupt_handler is not None:
        signal.signal(signal.SIGINT, _interrupt_handler.original_handler)
                                                                                                                                                             usr/lib/python3.4/unittest/suite.py                                                                 0100644 0000000 0000000 00000024455 12415221640 015763  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """TestSuite"""

import sys

from . import case
from . import util

__unittest = True


def _call_if_exists(parent, attr):
    func = getattr(parent, attr, lambda: None)
    func()


class BaseTestSuite(object):
    """A simple test suite that doesn't provide class or module shared fixtures.
    """
    _cleanup = True

    def __init__(self, tests=()):
        self._tests = []
        self._removed_tests = 0
        self.addTests(tests)

    def __repr__(self):
        return "<%s tests=%s>" % (util.strclass(self.__class__), list(self))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented
        return list(self) == list(other)

    def __ne__(self, other):
        return not self == other

    def __iter__(self):
        return iter(self._tests)

    def countTestCases(self):
        cases = self._removed_tests
        for test in self:
            if test:
                cases += test.countTestCases()
        return cases

    def addTest(self, test):
        # sanity checks
        if not callable(test):
            raise TypeError("{} is not callable".format(repr(test)))
        if isinstance(test, type) and issubclass(test,
                                                 (case.TestCase, TestSuite)):
            raise TypeError("TestCases and TestSuites must be instantiated "
                            "before passing them to addTest()")
        self._tests.append(test)

    def addTests(self, tests):
        if isinstance(tests, str):
            raise TypeError("tests must be an iterable of tests, not a string")
        for test in tests:
            self.addTest(test)

    def run(self, result):
        for index, test in enumerate(self):
            if result.shouldStop:
                break
            test(result)
            if self._cleanup:
                self._removeTestAtIndex(index)
        return result

    def _removeTestAtIndex(self, index):
        """Stop holding a reference to the TestCase at index."""
        try:
            test = self._tests[index]
        except TypeError:
            # support for suite implementations that have overriden self._tests
            pass
        else:
            # Some unittest tests add non TestCase/TestSuite objects to
            # the suite.
            if hasattr(test, 'countTestCases'):
                self._removed_tests += test.countTestCases()
            self._tests[index] = None

    def __call__(self, *args, **kwds):
        return self.run(*args, **kwds)

    def debug(self):
        """Run the tests without collecting errors in a TestResult"""
        for test in self:
            test.debug()


class TestSuite(BaseTestSuite):
    """A test suite is a composite test consisting of a number of TestCases.

    For use, create an instance of TestSuite, then add test case instances.
    When all tests have been added, the suite can be passed to a test
    runner, such as TextTestRunner. It will run the individual test cases
    in the order in which they were added, aggregating the results. When
    subclassing, do not forget to call the base class constructor.
    """

    def run(self, result, debug=False):
        topLevel = False
        if getattr(result, '_testRunEntered', False) is False:
            result._testRunEntered = topLevel = True

        for index, test in enumerate(self):
            if result.shouldStop:
                break

            if _isnotsuite(test):
                self._tearDownPreviousClass(test, result)
                self._handleModuleFixture(test, result)
                self._handleClassSetUp(test, result)
                result._previousTestClass = test.__class__

                if (getattr(test.__class__, '_classSetupFailed', False) or
                    getattr(result, '_moduleSetUpFailed', False)):
                    continue

            if not debug:
                test(result)
            else:
                test.debug()

            if self._cleanup:
                self._removeTestAtIndex(index)

        if topLevel:
            self._tearDownPreviousClass(None, result)
            self._handleModuleTearDown(result)
            result._testRunEntered = False
        return result

    def debug(self):
        """Run the tests without collecting errors in a TestResult"""
        debug = _DebugResult()
        self.run(debug, True)

    ################################

    def _handleClassSetUp(self, test, result):
        previousClass = getattr(result, '_previousTestClass', None)
        currentClass = test.__class__
        if currentClass == previousClass:
            return
        if result._moduleSetUpFailed:
            return
        if getattr(currentClass, "__unittest_skip__", False):
            return

        try:
            currentClass._classSetupFailed = False
        except TypeError:
            # test may actually be a function
            # so its class will be a builtin-type
            pass

        setUpClass = getattr(currentClass, 'setUpClass', None)
        if setUpClass is not None:
            _call_if_exists(result, '_setupStdout')
            try:
                setUpClass()
            except Exception as e:
                if isinstance(result, _DebugResult):
                    raise
                currentClass._classSetupFailed = True
                className = util.strclass(currentClass)
                errorName = 'setUpClass (%s)' % className
                self._addClassOrModuleLevelException(result, e, errorName)
            finally:
                _call_if_exists(result, '_restoreStdout')

    def _get_previous_module(self, result):
        previousModule = None
        previousClass = getattr(result, '_previousTestClass', None)
        if previousClass is not None:
            previousModule = previousClass.__module__
        return previousModule


    def _handleModuleFixture(self, test, result):
        previousModule = self._get_previous_module(result)
        currentModule = test.__class__.__module__
        if currentModule == previousModule:
            return

        self._handleModuleTearDown(result)


        result._moduleSetUpFailed = False
        try:
            module = sys.modules[currentModule]
        except KeyError:
            return
        setUpModule = getattr(module, 'setUpModule', None)
        if setUpModule is not None:
            _call_if_exists(result, '_setupStdout')
            try:
                setUpModule()
            except Exception as e:
                if isinstance(result, _DebugResult):
                    raise
                result._moduleSetUpFailed = True
                errorName = 'setUpModule (%s)' % currentModule
                self._addClassOrModuleLevelException(result, e, errorName)
            finally:
                _call_if_exists(result, '_restoreStdout')

    def _addClassOrModuleLevelException(self, result, exception, errorName):
        error = _ErrorHolder(errorName)
        addSkip = getattr(result, 'addSkip', None)
        if addSkip is not None and isinstance(exception, case.SkipTest):
            addSkip(error, str(exception))
        else:
            result.addError(error, sys.exc_info())

    def _handleModuleTearDown(self, result):
        previousModule = self._get_previous_module(result)
        if previousModule is None:
            return
        if result._moduleSetUpFailed:
            return

        try:
            module = sys.modules[previousModule]
        except KeyError:
            return

        tearDownModule = getattr(module, 'tearDownModule', None)
        if tearDownModule is not None:
            _call_if_exists(result, '_setupStdout')
            try:
                tearDownModule()
            except Exception as e:
                if isinstance(result, _DebugResult):
                    raise
                errorName = 'tearDownModule (%s)' % previousModule
                self._addClassOrModuleLevelException(result, e, errorName)
            finally:
                _call_if_exists(result, '_restoreStdout')

    def _tearDownPreviousClass(self, test, result):
        previousClass = getattr(result, '_previousTestClass', None)
        currentClass = test.__class__
        if currentClass == previousClass:
            return
        if getattr(previousClass, '_classSetupFailed', False):
            return
        if getattr(result, '_moduleSetUpFailed', False):
            return
        if getattr(previousClass, "__unittest_skip__", False):
            return

        tearDownClass = getattr(previousClass, 'tearDownClass', None)
        if tearDownClass is not None:
            _call_if_exists(result, '_setupStdout')
            try:
                tearDownClass()
            except Exception as e:
                if isinstance(result, _DebugResult):
                    raise
                className = util.strclass(previousClass)
                errorName = 'tearDownClass (%s)' % className
                self._addClassOrModuleLevelException(result, e, errorName)
            finally:
                _call_if_exists(result, '_restoreStdout')


class _ErrorHolder(object):
    """
    Placeholder for a TestCase inside a result. As far as a TestResult
    is concerned, this looks exactly like a unit test. Used to insert
    arbitrary errors into a test suite run.
    """
    # Inspired by the ErrorHolder from Twisted:
    # http://twistedmatrix.com/trac/browser/trunk/twisted/trial/runner.py

    # attribute used by TestResult._exc_info_to_string
    failureException = None

    def __init__(self, description):
        self.description = description

    def id(self):
        return self.description

    def shortDescription(self):
        return None

    def __repr__(self):
        return "<ErrorHolder description=%r>" % (self.description,)

    def __str__(self):
        return self.id()

    def run(self, result):
        # could call result.addError(...) - but this test-like object
        # shouldn't be run anyway
        pass

    def __call__(self, result):
        return self.run(result)

    def countTestCases(self):
        return 0

def _isnotsuite(test):
    "A crude way to tell apart testcases and suites with duck-typing"
    try:
        iter(test)
    except TypeError:
        return True
    return False


class _DebugResult(object):
    "Used by the TestSuite to hold previous class when running in debug."
    _previousTestClass = None
    _moduleSetUpFailed = False
    shouldStop = False
                                                                                                                                                                                                                   usr/lib/python3.4/unittest/util.py                                                                  0100644 0000000 0000000 00000012465 12415221640 015605  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Various utility functions."""

from collections import namedtuple, OrderedDict
from os.path import commonprefix

__unittest = True

_MAX_LENGTH = 80
_PLACEHOLDER_LEN = 12
_MIN_BEGIN_LEN = 5
_MIN_END_LEN = 5
_MIN_COMMON_LEN = 5
_MIN_DIFF_LEN = _MAX_LENGTH - \
               (_MIN_BEGIN_LEN + _PLACEHOLDER_LEN + _MIN_COMMON_LEN +
                _PLACEHOLDER_LEN + _MIN_END_LEN)
assert _MIN_DIFF_LEN >= 0

def _shorten(s, prefixlen, suffixlen):
    skip = len(s) - prefixlen - suffixlen
    if skip > _PLACEHOLDER_LEN:
        s = '%s[%d chars]%s' % (s[:prefixlen], skip, s[len(s) - suffixlen:])
    return s

def _common_shorten_repr(*args):
    args = tuple(map(safe_repr, args))
    maxlen = max(map(len, args))
    if maxlen <= _MAX_LENGTH:
        return args

    prefix = commonprefix(args)
    prefixlen = len(prefix)

    common_len = _MAX_LENGTH - \
                 (maxlen - prefixlen + _MIN_BEGIN_LEN + _PLACEHOLDER_LEN)
    if common_len > _MIN_COMMON_LEN:
        assert _MIN_BEGIN_LEN + _PLACEHOLDER_LEN + _MIN_COMMON_LEN + \
               (maxlen - prefixlen) < _MAX_LENGTH
        prefix = _shorten(prefix, _MIN_BEGIN_LEN, common_len)
        return tuple(prefix + s[prefixlen:] for s in args)

    prefix = _shorten(prefix, _MIN_BEGIN_LEN, _MIN_COMMON_LEN)
    return tuple(prefix + _shorten(s[prefixlen:], _MIN_DIFF_LEN, _MIN_END_LEN)
                 for s in args)

def safe_repr(obj, short=False):
    try:
        result = repr(obj)
    except Exception:
        result = object.__repr__(obj)
    if not short or len(result) < _MAX_LENGTH:
        return result
    return result[:_MAX_LENGTH] + ' [truncated]...'

def strclass(cls):
    return "%s.%s" % (cls.__module__, cls.__name__)

def sorted_list_difference(expected, actual):
    """Finds elements in only one or the other of two, sorted input lists.

    Returns a two-element tuple of lists.    The first list contains those
    elements in the "expected" list but not in the "actual" list, and the
    second contains those elements in the "actual" list but not in the
    "expected" list.    Duplicate elements in either input list are ignored.
    """
    i = j = 0
    missing = []
    unexpected = []
    while True:
        try:
            e = expected[i]
            a = actual[j]
            if e < a:
                missing.append(e)
                i += 1
                while expected[i] == e:
                    i += 1
            elif e > a:
                unexpected.append(a)
                j += 1
                while actual[j] == a:
                    j += 1
            else:
                i += 1
                try:
                    while expected[i] == e:
                        i += 1
                finally:
                    j += 1
                    while actual[j] == a:
                        j += 1
        except IndexError:
            missing.extend(expected[i:])
            unexpected.extend(actual[j:])
            break
    return missing, unexpected


def unorderable_list_difference(expected, actual):
    """Same behavior as sorted_list_difference but
    for lists of unorderable items (like dicts).

    As it does a linear search per item (remove) it
    has O(n*n) performance."""
    missing = []
    while expected:
        item = expected.pop()
        try:
            actual.remove(item)
        except ValueError:
            missing.append(item)

    # anything left in actual is unexpected
    return missing, actual

def three_way_cmp(x, y):
    """Return -1 if x < y, 0 if x == y and 1 if x > y"""
    return (x > y) - (x < y)

_Mismatch = namedtuple('Mismatch', 'actual expected value')

def _count_diff_all_purpose(actual, expected):
    'Returns list of (cnt_act, cnt_exp, elem) triples where the counts differ'
    # elements need not be hashable
    s, t = list(actual), list(expected)
    m, n = len(s), len(t)
    NULL = object()
    result = []
    for i, elem in enumerate(s):
        if elem is NULL:
            continue
        cnt_s = cnt_t = 0
        for j in range(i, m):
            if s[j] == elem:
                cnt_s += 1
                s[j] = NULL
        for j, other_elem in enumerate(t):
            if other_elem == elem:
                cnt_t += 1
                t[j] = NULL
        if cnt_s != cnt_t:
            diff = _Mismatch(cnt_s, cnt_t, elem)
            result.append(diff)

    for i, elem in enumerate(t):
        if elem is NULL:
            continue
        cnt_t = 0
        for j in range(i, n):
            if t[j] == elem:
                cnt_t += 1
                t[j] = NULL
        diff = _Mismatch(0, cnt_t, elem)
        result.append(diff)
    return result

def _ordered_count(iterable):
    'Return dict of element counts, in the order they were first seen'
    c = OrderedDict()
    for elem in iterable:
        c[elem] = c.get(elem, 0) + 1
    return c

def _count_diff_hashable(actual, expected):
    'Returns list of (cnt_act, cnt_exp, elem) triples where the counts differ'
    # elements must be hashable
    s, t = _ordered_count(actual), _ordered_count(expected)
    result = []
    for elem, cnt_s in s.items():
        cnt_t = t.get(elem, 0)
        if cnt_s != cnt_t:
            diff = _Mismatch(cnt_s, cnt_t, elem)
            result.append(diff)
    for elem, cnt_t in t.items():
        if elem not in s:
            diff = _Mismatch(0, cnt_t, elem)
            result.append(diff)
    return result
                                                                                                                                                                                                           usr/lib/python3.4/urllib/                                                                           0040755 0000000 0000000 00000000000 13077704336 013700  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/urllib/__init__.py                                                                0100644 0000000 0000000 00000000000 12415221640 015757  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/urllib/__pycache__/                                                               0040755 0000000 0000000 00000000000 13077704336 016110  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/urllib/__pycache__/__init__.cpython-34.pyc                                        0100644 0000000 0000000 00000000170 13077704336 022266  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                   @   s   d  S)N r   r   r   %/usr/lib/python3.4/urllib/__init__.py<module>   s                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/python3.4/urllib/__pycache__/error.cpython-34.pyc                                           0100644 0000000 0000000 00000005154 13077704336 021667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5Tk
                 @   sp   d  Z  d d l Z d d d g Z Gd d   d e  Z Gd d   d e e j j  Z Gd d   d e  Z	 d S)	a  Exception classes raised by urllib.

The base exception class is URLError, which inherits from OSError.  It
doesn't define any behavior of its own, but is the base class for all
exceptions defined in this package.

HTTPError is an exception class that is also a valid HTTP response
instance.  It behaves this way because HTTP protocol errors are valid
responses, with a status code, headers, and a body.  In some contexts,
an application may want to handle an exception like a regular
response.
    NURLError	HTTPErrorContentTooShortErrorc               @   s+   e  Z d  Z d d d  Z d d   Z d S)r   Nc             C   s1   | f |  _  | |  _ | d  k	 r- | |  _ n  d  S)N)argsreasonfilename)selfr   r    r	   "/usr/lib/python3.4/urllib/error.py__init__   s    	zURLError.__init__c             C   s   d |  j  S)Nz<urlopen error %s>)r   )r   r	   r	   r
   __str__#   s    zURLError.__str__)__name__
__module____qualname__r   r   r	   r	   r	   r
   r      s   c               @   sv   e  Z d  Z d Z e j j j Z d d   Z d d   Z	 e
 d d    Z e
 d d	    Z e j d
 d	    Z d S)r   zBRaised when HTTP error occurs, but also acts like non-error returnc             C   sV   | |  _  | |  _ | |  _ | |  _ | |  _ | d  k	 rR |  j | | | |  n  d  S)N)codemsghdrsfpr   _HTTPError__super_init)r   Zurlr   r   r   r   r	   r	   r
   r   *   s    					zHTTPError.__init__c             C   s   d |  j  |  j f S)NzHTTP Error %s: %s)r   r   )r   r	   r	   r
   r   7   s    zHTTPError.__str__c             C   s   |  j  S)N)r   )r   r	   r	   r
   r   <   s    zHTTPError.reasonc             C   s   |  j  S)N)r   )r   r	   r	   r
   headers@   s    zHTTPError.headersc             C   s   | |  _  d  S)N)r   )r   r   r	   r	   r
   r   D   s    N)r   r   r   __doc__urllibresponse
addinfourlr   r   r   propertyr   r   setterr	   r	   r	   r
   r   &   s   c               @   s   e  Z d  Z d d   Z d S)r   c             C   s   t  j |  |  | |  _ d  S)N)r   r   content)r   messager   r	   r	   r
   r   J   s    zContentTooShortError.__init__N)r   r   r   r   r	   r	   r	   r
   r   I   s   )
r   Zurllib.responser   __all__OSErrorr   r   r   r   r   r	   r	   r	   r
   <module>   s
   #                                                                                                                                                                                                                                                                                                                                                                                                                    usr/lib/python3.4/urllib/__pycache__/parse.cpython-34.pyc                                           0100644 0000000 0000000 00000074051 13077704336 021652  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s  d  Z  d d l Z d d l Z d d l Z d d d d d d d	 d
 d d d d d d d g Z d d d d d d d d d d d d d d d  d! d" g Z d d d d d# d d d d d d d$ d d d d% d d! d" d  d& d' d( g Z d d) d d d d d d d d* d+ d d d  d, g Z d d) d- d. d# d d d$ d* d+ g
 Z d d d d d d d d d d* d+ d g Z	 d d) d d d. d d d d d$ d d d g Z
 d/ Z d0 Z i  Z d1 d2   Z d3 Z d4 Z d5 d6   Z e e d7 d8  Z e e d9 d:  Z d; d<   Z Gd= d>   d> e  Z Gd? d@   d@ e  Z GdA dB   dB e  Z GdC dD   dD e e  Z GdE dF   dF e e  Z d dG l m Z e dH dI  Z e dJ dK  Z e dL dM  Z e Z GdN dH   dH e e  Z  GdO dJ   dJ e e  Z! GdP dL   dL e e  Z" GdQ dR   dR e e  Z# GdS dT   dT e e  Z$ GdU dV   dV e e  Z% dW dX   Z& e&   [& d dY dZ d  Z' d[ d\   Z( d d] d^  Z) d dY d_ d  Z* d` d   Z+ da d   Z, dY db d  Z- dc d   Z. dd Z/ d a0 de d   Z1 e j2 df  Z3 dg dh di d  Z4 dj dj dg dh dk d
  Z5 dj dj dg dh dl d  Z6 dg dh dm d  Z7 e8 dn  Z9 e: e9  Z; i  Z< Gdo dp   dp e j=  Z> dq d d dr d  Z? d d d ds d  Z@ dq dt d  ZA dj d d d du d	  ZB dv dw   ZC dx dy   ZD d aE dz d{   ZF d aG d| d}   ZH d aI d~ d   ZJ d aK d d   ZL d aM d d   ZN d aO d d d  ZP d aQ d d   ZR d aS d d   ZT d d   ZU d aV d d   ZW d S)ac  Parse (absolute and relative) URLs.

urlparse module is based upon the following RFC specifications.

RFC 3986 (STD66): "Uniform Resource Identifiers" by T. Berners-Lee, R. Fielding
and L.  Masinter, January 2005.

RFC 2732 : "Format for Literal IPv6 Addresses in URL's by R.Hinden, B.Carpenter
and L.Masinter, December 1999.

RFC 2396:  "Uniform Resource Identifiers (URI)": Generic Syntax by T.
Berners-Lee, R. Fielding, and L. Masinter, August 1998.

RFC 2368: "The mailto URL scheme", by P.Hoffman , L Masinter, J. Zawinski, July 1998.

RFC 1808: "Relative Uniform Resource Locators", by R. Fielding, UC Irvine, June
1995.

RFC 1738: "Uniform Resource Locators (URL)" by T. Berners-Lee, L. Masinter, M.
McCahill, December 1994

RFC 3986 is considered the current standard and any future changes to
urlparse module should conform with it.  The urlparse module is
currently not entirely compliant with this RFC due to defacto
scenarios for parsing, and for backward compatibility purposes, some
parsing quirks from older RFCs are retained. The testcases in
test_urlparse.py provides a good indicator of parsing behavior.
    Nurlparse
urlunparseurljoin	urldefragurlsplit
urlunsplit	urlencodeparse_qs	parse_qslquote
quote_plusquote_from_bytesunquoteunquote_plusunquote_to_bytesZftphttpZgopherZnntpZimapZwaisfileZhttpsZshttpZmmsZprosperoZrtspZrtspu ZsftpZsvnzsvn+sshZtelnetZsnewsZrsyncZnfsZgitzgit+sshZhdlZsipZsipsZtelZmailtoZnewszAabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.   c               C   s   t  j   t j   d S)z,Clear the parse cache and the quoters cache.N)_parse_cacheclear_safe_quoters r   r   "/usr/lib/python3.4/urllib/parse.pyclear_cacheH   s    
r   asciistrictc             C   s   |  S)Nr   )objr   r   r   _noopW   s    r   c             C   s   |  j  | |  S)N)encode)r   encodingerrorsr   r   r   _encode_resultZ   s    r"   c                s    t     f d d   |  D  S)Nc             3   s-   |  ]# } | r! | j      n d  Vq d S)r   N)decode).0x)r    r!   r   r   	<genexpr>`   s    z_decode_args.<locals>.<genexpr>)tuple)argsr    r!   r   )r    r!   r   _decode_args^   s    r)   c              G   sz   t  |  d t  } xB |  d d   D]0 } | r$ t  | t  | k r$ t d   q$ q$ W| ri |  t f St |   t f S)Nr      z$Cannot mix str and non-str arguments)
isinstancestr	TypeErrorr   r)   r"   )r(   Z	str_inputargr   r   r   _coerce_argsb   s    r/   c               @   s.   e  Z d  Z d Z f  Z d d d d  Z d S)_ResultMixinStrz>Standard approach to encoding parsed results from str to bytesr   r   c                s#   |  j     f d d   |  D   S)Nc             3   s!   |  ] } | j      Vq d  S)N)r   )r$   r%   )r    r!   r   r   r&   x   s    z)_ResultMixinStr.encode.<locals>.<genexpr>)_encoded_counterpart)selfr    r!   r   )r    r!   r   r   w   s    z_ResultMixinStr.encodeN)__name__
__module____qualname____doc__	__slots__r   r   r   r   r   r0   s   s   r0   c               @   s.   e  Z d  Z d Z f  Z d d d d  Z d S)_ResultMixinBytesz>Standard approach to decoding parsed results from bytes to strr   r   c                s#   |  j     f d d   |  D   S)Nc             3   s!   |  ] } | j      Vq d  S)N)r#   )r$   r%   )r    r!   r   r   r&      s    z+_ResultMixinBytes.decode.<locals>.<genexpr>)_decoded_counterpart)r2   r    r!   r   )r    r!   r   r#      s    z_ResultMixinBytes.decodeN)r3   r4   r5   r6   r7   r#   r   r   r   r   r8   {   s   r8   c               @   sd   e  Z d  Z d Z f  Z e d d    Z e d d    Z e d d    Z e d d	    Z	 d
 S)_NetlocResultMixinBasezHShared methods for the parsed result objects containing a netloc elementc             C   s   |  j  d S)Nr   )	_userinfo)r2   r   r   r   username   s    z_NetlocResultMixinBase.usernamec             C   s   |  j  d S)Nr*   )r;   )r2   r   r   r   password   s    z_NetlocResultMixinBase.passwordc             C   s;   |  j  d } | s d  } n | d  k	 r7 | j   } n  | S)Nr   )	_hostinfolower)r2   hostnamer   r   r   r@      s    	z_NetlocResultMixinBase.hostnamec             C   sO   |  j  d } | d  k	 rK t | d  } d | k o? d k n sK d  Sn  | S)Nr*   
   r   i  )r>   int)r2   portr   r   r   rC      s    z_NetlocResultMixinBase.portN)
r3   r4   r5   r6   r7   propertyr<   r=   r@   rC   r   r   r   r   r:      s   	r:   c               @   s:   e  Z d  Z f  Z e d d    Z e d d    Z d S)_NetlocResultMixinStrc             C   se   |  j  } | j d  \ } } } | rQ | j d  \ } } } | s[ d  } q[ n
 d  } } | | f S)N@:)netloc
rpartition	partition)r2   rH   userinfo	have_infohostinfor<   have_passwordr=   r   r   r   r;      s    	
z_NetlocResultMixinStr._userinfoc             C   s   |  j  } | j d  \ } } } | j d  \ } } } | rr | j d  \ } } } | j d  \ } } } n | j d  \ } } } | s d  } n  | | f S)NrF   []rG   )rH   rI   rJ   )r2   rH   _rM   have_open_br	bracketedr@   rC   r   r   r   r>      s    		z_NetlocResultMixinStr._hostinfoN)r3   r4   r5   r7   rD   r;   r>   r   r   r   r   rE      s   rE   c               @   s:   e  Z d  Z f  Z e d d    Z e d d    Z d S)_NetlocResultMixinBytesc             C   se   |  j  } | j d  \ } } } | rQ | j d  \ } } } | s[ d  } q[ n
 d  } } | | f S)N   @   :)rH   rI   rJ   )r2   rH   rK   rL   rM   r<   rN   r=   r   r   r   r;      s    	
z!_NetlocResultMixinBytes._userinfoc             C   s   |  j  } | j d  \ } } } | j d  \ } } } | rr | j d  \ } } } | j d  \ } } } n | j d  \ } } } | s d  } n  | | f S)NrU      [   ]rV   )rH   rI   rJ   )r2   rH   rQ   rM   rR   rS   r@   rC   r   r   r   r>      s    		z!_NetlocResultMixinBytes._hostinfoN)r3   r4   r5   r7   rD   r;   r>   r   r   r   r   rT      s   rT   )
namedtupleDefragResultzurl fragmentSplitResultz!scheme netloc path query fragmentParseResultz(scheme netloc path params query fragmentc               @   s"   e  Z d  Z f  Z d d   Z d S)rZ   c             C   s&   |  j  r |  j d |  j  S|  j Sd  S)N#)fragmenturl)r2   r   r   r   geturl   s    	zDefragResult.geturlN)r3   r4   r5   r7   r`   r   r   r   r   rZ      s   c               @   s"   e  Z d  Z f  Z d d   Z d S)r[   c             C   s
   t  |   S)N)r   )r2   r   r   r   r`      s    zSplitResult.geturlN)r3   r4   r5   r7   r`   r   r   r   r   r[      s   c               @   s"   e  Z d  Z f  Z d d   Z d S)r\   c             C   s
   t  |   S)N)r   )r2   r   r   r   r`      s    zParseResult.geturlN)r3   r4   r5   r7   r`   r   r   r   r   r\      s   c               @   s"   e  Z d  Z f  Z d d   Z d S)DefragResultBytesc             C   s&   |  j  r |  j d |  j  S|  j Sd  S)N   #)r^   r_   )r2   r   r   r   r`      s    	zDefragResultBytes.geturlN)r3   r4   r5   r7   r`   r   r   r   r   ra      s   ra   c               @   s"   e  Z d  Z f  Z d d   Z d S)SplitResultBytesc             C   s
   t  |   S)N)r   )r2   r   r   r   r`     s    zSplitResultBytes.geturlN)r3   r4   r5   r7   r`   r   r   r   r   rc     s   rc   c               @   s"   e  Z d  Z f  Z d d   Z d S)ParseResultBytesc             C   s
   t  |   S)N)r   )r2   r   r   r   r`     s    zParseResultBytes.geturlN)r3   r4   r5   r7   r`   r   r   r   r   rd     s   rd   c              C   sN   t  t f t t f t t f f }  x& |  D] \ } } | | _ | | _ q( Wd  S)N)rZ   ra   r[   rc   r\   rd   r1   r9   )Z_result_pairsZ_decodedZ_encodedr   r   r   _fix_result_transcoding  s    			re   Tc       
      C   s   t  |  |  \ }  } } t |  | |  } | \ } } }  } } | t k rl d |  k rl t |   \ }  } n d } t | | |  | | |  }	 | |	  S)a#  Parse a URL into 6 components:
    <scheme>://<netloc>/<path>;<params>?<query>#<fragment>
    Return a 6-tuple: (scheme, netloc, path, params, query, fragment).
    Note that we don't break the components up in smaller bits
    (e.g. netloc is a single string) and we don't expand % escapes.;r   )r/   r   uses_params_splitparamsr\   )
r_   schemeallow_fragments_coerce_resultZsplitresultrH   queryr^   paramsresultr   r   r   r     s    c             C   sq   d |  k r@ |  j  d |  j d   } | d k  rO |  d f Sn |  j  d  } |  d  |  |  | d d   f S)N/rf   r   r   r*   )findrfind)r_   ir   r   r   rh   .  s    rh   c             C   sk   t  |   } x> d D]6 } |  j | |  } | d k r t | |  } q q W|  | |  |  | d   f S)Nz/?#r   )lenrp   min)r_   startZdelimcZwdelimr   r   r   _splitnetloc7  s    rw   c             C   sH  t  |  |  \ }  } } t |  } |  | | t |   t |  f } t j | d  } | rg | |  St t  t k r t   n  d } } } |  j d  }	 |	 d k r[|  d |	  d k r|  d |	  j	   } |  |	 d d  }  |  d d  d k rYt
 |  d  \ } }  d	 | k r/d
 | k sGd
 | k rYd	 | k rYt d   qYn  | rd |  k r|  j d d  \ }  } n  d |  k r|  j d d  \ }  } n  t | | |  | |  }
 |
 t | <| |
  Sx |  d |	  D] } | t k rPqqW|  |	 d d  } | s8t d d   | D  r[|  d |	  j	   | } }  q[n  |  d d  d k rt
 |  d  \ } }  d	 | k rd
 | k sd
 | k rd	 | k rt d   qn  | rd |  k r|  j d d  \ }  } n  d |  k r|  j d d  \ }  } n  t | | |  | |  }
 |
 t | <| |
  S)a  Parse a URL into 5 components:
    <scheme>://<netloc>/<path>?<query>#<fragment>
    Return a 5-tuple: (scheme, netloc, path, query, fragment).
    Note that we don't break the components up in smaller bits
    (e.g. netloc is a single string) and we don't expand % escapes.Nr   rG   r   r   r*      z//rO   rP   zInvalid IPv6 URLr]   ?c             s   s   |  ] } | d  k Vq d S)
0123456789Nr   )r$   rv   r   r   r   r&   f  s    zurlsplit.<locals>.<genexpr>)r/   booltyper   getrs   MAX_CACHE_SIZEr   rp   r?   rw   
ValueErrorsplitr[   scheme_charsany)r_   ri   rj   rk   keycachedrH   rl   r^   rr   vrv   restr   r   r   r   ?  sX    !



 #
c             C   sY   t  |    \ } } } } } } } | r: d | | f } n  | t | | | | | f   S)zPut a parsed URL back together again.  This may result in a
    slightly different, but equivalent URL, if the URL that was parsed
    originally had redundant delimiters, e.g. a ? with an empty query
    (the draft states that these are equivalent).z%s;%s)r/   r   )
componentsri   rH   r_   rm   rl   r^   rk   r   r   r   r   w  s    !c             C   s   t  |    \ } } } } } } | sL | r | t k r | d d  d k r | ru | d d  d k ru d | } n  d | p d | } n  | r | d | } n  | r | d | } n  | r | d	 | } n  | |  S)
ak  Combine the elements of a tuple as returned by urlsplit() into a
    complete URL as a string. The data argument can be any five-item iterable.
    This may result in a slightly different, but equivalent URL, if the URL that
    was parsed originally had unnecessary delimiters (for example, a ? with an
    empty query; the RFC states that these are equivalent).Nrx   z//r*   ro   r   rG   ry   r]   )r/   uses_netloc)r   ri   rH   r_   rl   r^   rk   r   r   r   r     s    . c             C   s  |  s
 | S| s |  St  |  |  \ }  } } t |  d |  \ } } } } } }	 t | | |  \ }
 } } } } } |
 | k s |
 t k r | |  S|
 t k r | r | t |
 | | | | | f   S| } n  | d d  d k r| t |
 | | | | | f   S| rV| rV| } | } | s4| } n  | t |
 | | | | | f   S| j d  d d  | j d  } | d	 d k rd | d
 <n  x d | k r| j d  qWxt d } t |  d } xX | | k  r+| | d k r| | d d k r| | d | d  =Pn  | d } qWPq| d d g k rOd | d <n8 t |  d k r| d d k rd g | d d  <n  | t |
 | d j |  | | | f   S)zaJoin a base URL and a possibly relative URL to form an absolute
    interpretation of the latter.r   Nr*   ro   ...rx   r   r   )r   r   r   r   )	r/   r   uses_relativer   r   r   removers   join)baser_   rj   rk   ZbschemeZbnetlocZbpathZbparamsZbqueryZ	bfragmentri   rH   pathrm   rl   r^   Zsegmentsrr   nr   r   r   r     sZ    $$
		&"c       	      C   s|   t  |   \ }  } d |  k r] t |   \ } } } } } } t | | | | | d f  } n d } |  } | t | |   S)zRemoves any existing fragment from URL.

    Returns a tuple of the defragmented URL and the fragment.  If
    the URL contained no fragments, the second element is the
    empty string.
    r]   r   )r/   r   r   rZ   )	r_   rk   sr   paqZfragZdefragr   r   r   r     s    !Z0123456789ABCDEFabcdefc             C   s  |  s |  j  d St |  t  r2 |  j d  }  n  |  j  d  } t |  d k rW |  S| d g } | j } t d k r d d   t D a n  xq | d d  D]_ } y0 | t | d d	   | | d	 d   Wq t k
 r | d  | |  Yq Xq Wd j	 |  S)
z,unquote_to_bytes('abc%20def') -> b'abc def'.    zutf-8   %r*   r   Nc             S   sF   i  |  ]< } t  D]/ } t t | | d   g  | | j    q q S)   )_hexdigbytesrB   r   )r$   r   br   r   r   
<dictcomp>  s   	z$unquote_to_bytes.<locals>.<dictcomp>rx   )
r   r+   r,   r   rs   append
_hextobyter   KeyErrorr   )stringbitsresr   itemr   r   r   r     s*    		
z([ -]+)zutf-8replacec             C   s   d |  k r |  j  |  S| d k r, d } n  | d k rA d } n  t j  |   } | d g } | j } xR t d t |  d  D]8 } | t | |  j | |   | | | d  q Wd j |  S)	a  Replace %xx escapes by their single-character equivalent. The optional
    encoding and errors parameters specify how to decode percent-encoded
    sequences into Unicode characters, as accepted by the bytes.decode()
    method.
    By default, percent-encoded sequences are decoded with UTF-8, and invalid
    sequences are replaced by a placeholder character.

    unquote('abc%20def') -> 'abc def'.
    %Nzutf-8r   r   r*   rx   r   )r   _asciirer   rangers   r   r#   r   )r   r    r!   r   r   r   rr   r   r   r   r     s    
			 Fc       	      C   sl   i  } t  |  | | d | d | } xA | D]9 \ } } | | k rW | | j |  q+ | g | | <q+ W| S)aO  Parse a query given as a string argument.

        Arguments:

        qs: percent-encoded query string to be parsed

        keep_blank_values: flag indicating whether blank values in
            percent-encoded queries should be treated as blank strings.
            A true value indicates that blanks should be retained as
            blank strings.  The default false value indicates that
            blank values are to be ignored and treated as if they were
            not included.

        strict_parsing: flag indicating what to do with parsing errors.
            If false (the default), errors are silently ignored.
            If true, errors raise a ValueError exception.

        encoding and errors: specify how to decode percent-encoded sequences
            into Unicode characters, as accepted by the bytes.decode() method.
    r    r!   )r
   r   )	qskeep_blank_valuesstrict_parsingr    r!   Zparsed_resultpairsnamevaluer   r   r   r	     s    c             C   sY  t  |   \ }  } d d   |  j d  D } g  } x| D]} | rU | rU q; n  | j d d  }	 t |	  d k r | r t d | f   n  | r; |	 j d  q q; n  t |	 d  s | r; |	 d	 j d
 d  }
 t |
 d | d | }
 | |
  }
 |	 d j d
 d  } t | d | d | } | |  } | j |
 | f  q; q; W| S)a;  Parse a query given as a string argument.

    Arguments:

    qs: percent-encoded query string to be parsed

    keep_blank_values: flag indicating whether blank values in
        percent-encoded queries should be treated as blank strings.  A
        true value indicates that blanks should be retained as blank
        strings.  The default false value indicates that blank values
        are to be ignored and treated as if they were  not included.

    strict_parsing: flag indicating what to do with parsing errors. If
        false (the default), errors are silently ignored. If true,
        errors raise a ValueError exception.

    encoding and errors: specify how to decode percent-encoded sequences
        into Unicode characters, as accepted by the bytes.decode() method.

    Returns a list, as G-d intended.
    c             S   s,   g  |  ]" } | j  d   D] } |  q q S)rf   )r   )r$   s1s2r   r   r   
<listcomp>N  s   	 zparse_qsl.<locals>.<listcomp>&=r*   rx   zbad query field: %rr   r   + r    r!   )r/   r   rs   r   r   r   r   )r   r   r   r    r!   rk   r   rZ
name_valueZnvr   r   r   r   r   r
   6  s,    c             C   s"   |  j  d d  }  t |  | |  S)zLike unquote(), but also replace plus signs by spaces, as required for
    unquoting HTML form values.

    unquote_plus('%7e/abc+def') -> '~/abc def'
    r   r   )r   r   )r   r    r!   r   r   r   r   f  s    sA   ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-c               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	QuoterzA mapping from bytes (in range(0,256)) to strings.

    String values are percent-encoded byte values, unless the key < 128, and
    in the "safe" set (either the specified safe set, or default set).
    c             C   s   t  j |  |  _ d S)zsafe: bytes object.N)_ALWAYS_SAFEunionsafe)r2   r   r   r   r   __init__~  s    zQuoter.__init__c             C   s   d t  |   S)Nz<Quoter %r>)dict)r2   r   r   r   __repr__  s    zQuoter.__repr__c             C   s8   | |  j  k r t |  n d j |  } | |  | <| S)Nz%{:02X})r   chrformat)r2   r   r   r   r   r   __missing__  s    *
zQuoter.__missing__N)r3   r4   r5   r6   r   r   r   r   r   r   r   r   v  s   r   ro   c             C   s   t  |  t  rX |  s |  S| d k r. d } n  | d k rC d } n  |  j | |  }  n6 | d k	 rs t d   n  | d k	 r t d   n  t |  |  S)a  quote('abc def') -> 'abc%20def'

    Each part of a URL, e.g. the path info, the query, etc., has a
    different set of reserved characters that must be quoted.

    RFC 2396 Uniform Resource Identifiers (URI): Generic Syntax lists
    the following reserved characters.

    reserved    = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
                  "$" | ","

    Each of these characters is reserved in some component of a URL,
    but not necessarily in all of them.

    By default, the quote function is intended for quoting the path
    section of a URL.  Thus, it will not encode '/'.  This character
    is reserved, but in typical usage the quote function is being
    called on a path where the existing slash characters are used as
    reserved characters.

    string and safe may be either str or bytes objects. encoding must
    not be specified if string is a str.

    The optional encoding and errors parameters specify how to deal with
    non-ASCII characters, as accepted by the str.encode method.
    By default, encoding='utf-8' (characters are encoded with UTF-8), and
    errors='strict' (unsupported characters raise a UnicodeEncodeError).
    Nzutf-8r   z,quote() doesn't support 'encoding' for bytesz*quote() doesn't support 'errors' for bytes)r+   r,   r   r-   r   )r   r   r    r!   r   r   r   r     s    		c             C   s   t  |  t  r d |  k s6 t  |  t  rI d |  k rI t |  | | |  St  | t  ra d } n d } t |  | | | |  }  |  j d d  S)zLike quote(), but also replace ' ' with '+', as required for quoting
    HTML form values. Plus signs in the original string are escaped unless
    they are included in safe. It also does not have safe default to '/'.
    r       r   )r+   r,   r   r   r   )r   r   r    r!   Zspacer   r   r   r     s    	c                s   t  |  t t f  s$ t d   n  |  s. d St  | t  rR | j d d  } n t d d   | D  } |  j t |  s |  j   Sy t	 |   Wn) t
 k
 r t |  j t	 | <  Yn Xd j   f d d   |  D  S)zLike quote(), but accepts a bytes object rather than a str, and does
    not perform string-to-bytes encoding.  It always returns an ASCII string.
    quote_from_bytes(b'abc def?') -> 'abc%20def%3f'
    z!quote_from_bytes() expected bytesr   r   ignorec             S   s"   g  |  ] } | d  k  r |  q S)   r   )r$   rv   r   r   r   r     s   	 z$quote_from_bytes.<locals>.<listcomp>c                s   g  |  ] }   |   q Sr   r   )r$   char)quoterr   r   r     s   	 )r+   r   	bytearrayr-   r,   r   rstrip_ALWAYS_SAFE_BYTESr#   r   r   r   __getitem__r   )Zbsr   r   )r   r   r     s    
c             C   s  t  |  d  r |  j   }  nl y- t |   rJ t |  d t  rJ t  n  Wn< t k
 r t j   \ } } } t d  j |   Yn Xg  } | s=x |  D] \ }	 }
 t |	 t	  r t
 |	 |  }	 n t
 t |	  | | |  }	 t |
 t	  rt
 |
 |  }
 n t
 t |
  | | |  }
 | j |	 d |
  q Wn|xy|  D]q\ }	 }
 t |	 t	  rqt
 |	 |  }	 n t
 t |	  | | |  }	 t |
 t	  rt
 |
 |  }
 | j |	 d |
  qDt |
 t  rt
 |
 | | |  }
 | j |	 d |
  qDy t |
  } WnB t k
 rRt
 t |
  | | |  }
 | j |	 d |
  YqDXx_ |
 D]W } t | t	  rt
 | |  } n t
 t |  | | |  } | j |	 d |  qZWqDWd j |  S)a@  Encode a dict or sequence of two-element tuples into a URL query string.

    If any values in the query arg are sequences and doseq is true, each
    sequence element is converted to a separate parameter.

    If the query arg is a sequence of two-element tuples, the order of the
    parameters in the output will match the order of parameters in the
    input.

    The components of a query arg may each be either a string or a bytes type.
    When a component is a string, the safe, encoding and error parameters are
    sent to the quote_plus function for encoding.
    itemsr   z1not a valid non-string sequence or mapping objectr   r   )hasattrr   rs   r+   r'   r-   sysexc_infowith_tracebackr   r   r,   r   r   )rl   Zdoseqr   r    r!   ZtyZvatblkr   r%   Zeltr   r   r   r     sN     c             C   s^   t  |  t  rZ y |  j d  j   }  WqZ t k
 rV t d t |   d   YqZ Xn  |  S)zto_bytes(u"URL") --> 'URL'.ASCIIzURL z contains non-ASCII characters)r+   r,   r   r#   UnicodeErrorrepr)r_   r   r   r   to_bytes<  s    r   c             C   s   t  |   j   }  |  d d  d k rW |  d d  d k rW |  d d  j   }  n  |  d d  d k r |  d d  j   }  n  |  S)	z8unwrap('<URL:type://host/path>') --> 'type://host/path'.Nr*   <>   zURL:r   r   )r,   strip)r_   r   r   r   unwrapI  s    , r   c             C   sp   t  d k r t j d  a  n  t  j |   } | rf | j d  } | j   |  t |  d d  f Sd |  f S)z:splittype('type:opaquestring') --> 'type', 'opaquestring'.Nz
^([^/:]+):r*   )	_typeprogrecompilematchgroupr?   rs   )r_   r   ri   r   r   r   	splittypeR  s    $r   c             C   s   t  d k r t j d  a  n  t  j |   } | r~ | j d  } | j d  } | rt | j d  rt d | } n  | | f Sd |  f S)z;splithost('//host[:port]/path') --> 'host[:port]', '/path'.Nz^//([^/?]*)(.*)$r*   rx   ro   )	_hostprogr   r   r   r   
startswith)r_   r   Z	host_portr   r   r   r   	splithost_  s    
r   c             C   sM   t  d k r t j d  a  n  t  j |   } | rC | j d d  Sd |  f S)zJsplituser('user[:passwd]@host[:port]') --> 'user[:passwd]', 'host[:port]'.Nz^(.*)@(.*)$r*   rx   )	_userprogr   r   r   r   )hostr   r   r   r   	splitusero  s     r   c             C   sS   t  d k r$ t j d t j  a  n  t  j |   } | rI | j d d  S|  d f S)z/splitpasswd('user:passwd') -> 'user', 'passwd'.Nz^([^:]*):(.*)$r*   rx   )_passwdprogr   r   Sr   r   )userr   r   r   r   splitpasswdz  s     r   c             C   sb   t  d k r t j d  a  n  t  j |   } | rX | j   \ }  } | rX |  | f Sn  |  d f S)z*splitport('host:port') --> 'host', 'port'.Nz^(.*):([0-9]*)$)	_portprogr   r   r   groups)r   r   rC   r   r   r   	splitport  s    r   r*   c             C   s   t  d k r t j d  a  n  t  j |   } | r | j d d  \ }  } | r y t |  } Wn t k
 r{ d } Yn X|  | f Sn  |  | f S)zSplit host and port, returning numeric port.
    Return given default port if no ':' found; defaults to -1.
    Return numerical port if a valid number are found after ':'.
    Return None if ':' but not a valid number.Nz^(.*):(.*)$r*   rx   )
_nportprogr   r   r   r   rB   r   )r   Zdefportr   rC   Znportr   r   r   
splitnport  s    r   c             C   sM   t  d k r t j d  a  n  t  j |   } | rC | j d d  S|  d f S)z/splitquery('/path?query') --> '/path', 'query'.Nz^(.*)\?([^?]*)$r*   rx   )
_queryprogr   r   r   r   )r_   r   r   r   r   
splitquery  s     r   c             C   sM   t  d k r t j d  a  n  t  j |   } | rC | j d d  S|  d f S)z)splittag('/path#tag') --> '/path', 'tag'.Nz^(.*)#([^#]*)$r*   rx   )_tagprogr   r   r   r   )r_   r   r   r   r   splittag  s     r   c             C   s'   |  j  d  } | d | d d  f S)zksplitattr('/path;attr1=value1;attr2=value2;...') ->
        '/path', ['attr1=value1', 'attr2=value2', ...].rf   r   r*   N)r   )r_   Zwordsr   r   r   	splitattr  s    r   c             C   sM   t  d k r t j d  a  n  t  j |   } | rC | j d d  S|  d f S)z-splitvalue('attr=value') --> 'attr', 'value'.Nz^([^=]*)=(.*)$r*   rx   )
_valueprogr   r   r   r   )attrr   r   r   r   
splitvalue  s     r   r   )Xr6   r   r   collections__all__r   r   rg   Znon_hierarchicalZ
uses_queryZuses_fragmentr   r~   r   r   Z_implicit_encodingZ_implicit_errorsr   r"   r)   r/   objectr0   r8   r:   rE   rT   rY   Z_DefragResultBaseZ_SplitResultBaseZ_ParseResultBaseZ
ResultBaserZ   r[   r\   ra   rc   rd   re   r   rh   rw   r   r   r   r   r   r   r   r   r   r   r   r	   r
   r   	frozensetr   r   r   r   defaultdictr   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   <module>   s    
	85/	,]


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/urllib/__pycache__/request.cpython-34.pyc                                         0100644 0000000 0000000 00000220144 13077704336 022224  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5Ti             (   @   s  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z m Z m Z d d l m Z m Z m Z m Z m Z m Z m Z m Z m Z m  Z  m! Z! m" Z" m# Z# m$ Z$ m% Z% m& Z& m' Z' m( Z( d d l) m* Z* m+ Z+ y d d l, Z, Wn e- k
 rd Z. Yn Xd Z. d d	 d
 d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' g  Z/ e j0 d d(  Z1 d a2 d e j3 d) d d* d d+ d d, d Z4 d- d   Z5 g  Z6 d d d d. d$  Z7 d/ d%   Z8 e
 j9 d0 e
 j:  Z; d1 d2   Z< Gd3 d   d  Z= Gd4 d	   d	  Z> d5 d    Z? Gd6 d
   d
  Z@ Gd7 d   d e@  ZA Gd8 d   d e@  ZB Gd9 d   d e@  ZC d: d;   ZD Gd< d   d e@  ZE Gd= d   d  ZF Gd> d   d eF  ZG Gd? d   d  ZH Gd@ d   d eH e@  ZI GdA d   d eH e@  ZJ e jK ZL GdB d   d  ZM GdC d   d e@ eM  ZN GdD d   d e@ eM  ZO GdE dF   dF e@  ZP GdG d   d eP  ZQ eR e jS dH  rbGdI dJ   dJ eP  ZT e/ jU dJ  n  GdK d   d e@  ZV GdL d   d e@  ZW dM dN   ZX dO dP   ZY GdQ d   d e@  ZZ dR dS   Z[ GdT d   d e@  Z\ GdU d   d e\  Z] GdV d   d e@  Z^ dW Z_ e j` dX k r8d dY la mb Zb mc Zc n dZ d"   Zb d[ d!   Zc i  Zd Gd\ d&   d&  Ze Gd] d'   d' ee  Zf d ag d^ d_   Zh d ai d` da   Zj d ak db dc   Zl d am dd de   Zn Gdf dg   dg  Zo dh di   Zp dj dk   Zq dl dm   Zr e js dn k rVd do lt mu Zu mv Zv dp dq   Zw dr ds   Zx dt du   Zy dv d#   Zz nN e j` dX k rdw dx   Z{ dy d#   Zz dz d{   Z| d| du   Zy n ep Zz eq Zy d S)}a
  An extensible library for opening URLs using a variety of protocols

The simplest way to use this module is to call the urlopen function,
which accepts a string containing a URL or a Request object (described
below).  It opens the URL and returns the results as file-like
object; the returned object has some extra methods described below.

The OpenerDirector manages a collection of Handler objects that do
all the actual work.  Each Handler implements a particular protocol or
option.  The OpenerDirector is a composite object that invokes the
Handlers needed to open the requested URL.  For example, the
HTTPHandler performs HTTP GET and POST requests and deals with
non-error returns.  The HTTPRedirectHandler automatically deals with
HTTP 301, 302, 303 and 307 redirect errors, and the HTTPDigestAuthHandler
deals with digest authentication.

urlopen(url, data=None) -- Basic usage is the same as original
urllib.  pass the url and optionally data to post to an HTTP URL, and
get a file-like object back.  One difference is that you can also pass
a Request instance instead of URL.  Raises a URLError (subclass of
OSError); for HTTP errors, raises an HTTPError, which can also be
treated as a valid response.

build_opener -- Function that creates a new OpenerDirector instance.
Will install the default handlers.  Accepts one or more Handlers as
arguments, either instances or Handler classes that it will
instantiate.  If one of the argument is a subclass of the default
handler, the argument will be installed instead of the default.

install_opener -- Installs a new opener as the default opener.

objects of interest:

OpenerDirector -- Sets up the User Agent as the Python-urllib client and manages
the Handler classes, while dealing with requests and responses.

Request -- An object that encapsulates the state of a request.  The
state can be as simple as the URL.  It can also include extra HTTP
headers, e.g. a User-Agent.

BaseHandler --

internals:
BaseHandler and parent
_call_chain conventions

Example usage:

import urllib.request

# set up authentication info
authinfo = urllib.request.HTTPBasicAuthHandler()
authinfo.add_password(realm='PDQ Application',
                      uri='https://mahler:8092/site-updates.py',
                      user='klem',
                      passwd='geheim$parole')

proxy_support = urllib.request.ProxyHandler({"http" : "http://ahad-haam:3128"})

# build a new opener that adds authentication and caching FTP handlers
opener = urllib.request.build_opener(proxy_support, authinfo,
                                     urllib.request.CacheFTPHandler)

# install it
urllib.request.install_opener(opener)

f = urllib.request.urlopen('http://www.python.org/')
    N)URLError	HTTPErrorContentTooShortError)urlparseurlspliturljoinunwrapquoteunquote	splittype	splithost	splitport	splitusersplitpasswd	splitattr
splitquery
splitvaluesplittagto_bytesunquote_to_bytes
urlunparse)
addinfourladdclosehookFTRequestOpenerDirectorBaseHandlerHTTPDefaultErrorHandlerHTTPRedirectHandlerHTTPCookieProcessorProxyHandlerHTTPPasswordMgrHTTPPasswordMgrWithDefaultRealmAbstractBasicAuthHandlerHTTPBasicAuthHandlerProxyBasicAuthHandlerAbstractDigestAuthHandlerHTTPDigestAuthHandlerProxyDigestAuthHandlerHTTPHandlerFileHandler
FTPHandlerCacheFTPHandlerDataHandlerUnknownHandlerHTTPErrorProcessorurlopeninstall_openerbuild_openerpathname2urlurl2pathname
getproxiesurlretrieve
urlcleanup	URLopenerFancyURLopener   cafilecapath	cadefaultc      	      C   s   | s | s | rl t  s' t d   n  t j d t j d | d |  } t d | d d  } t |  } n" t d  k r t   a } n t } | j |  | |  S)NzSSL support not availableZ	cert_reqsr:   r;   contextcheck_hostnameT)		_have_ssl
ValueErrorsslZ_create_stdlib_contextZCERT_REQUIREDHTTPSHandlerr1   _openeropen)	urldatatimeoutr:   r;   r<   r=   Zhttps_handleropener rI   $/usr/lib/python3.4/urllib/request.pyr/      s    	c             C   s
   |  a  d  S)N)rC   )rH   rI   rI   rJ   r0      s    c             C   s  t  |   \ } } t j t |  |   D} | j   } | d k rb | rb t j j |  | f S| rz t | d  } n( t	 j
 d d  } | j } t j |  |  | | f }	 d }
 d } d } d } d	 | k r t | d
  } n  | r| | |
 |  n  x\ | j |
  } | s!Pn  | t |  7} | j |  | d 7} | r| | |
 |  qqWd QXWd QX| d k r| | k  rt d | | f |	   n  |	 S)aW  
    Retrieve a URL into a temporary location on disk.

    Requires a URL argument. If a filename is passed, it is used as
    the temporary file location. The reporthook argument should be
    a callable that accepts a block number, a read size, and the
    total file size of the URL target. The data argument should be
    valid URL encoded data.

    If a filename is passed and the URL points to a local resource,
    the result is a copy from local file to new file.

    Returns a tuple containing the path to the newly created
    data file as well as the resulting HTTPMessage object.
    filewbZdeleteFi         r   zcontent-lengthzContent-LengthNz1retrieval incomplete: got only %i out of %i bytesi    )r   
contextlibclosingr/   infoospathnormpathrD   tempfileZNamedTemporaryFilename_url_tempfilesappendintreadlenwriter   )rE   filename
reporthookrF   Zurl_typerT   fpheaderstfpresultbssizer[   blocknumblockrI   rI   rJ   r5      sD    	
"c              C   sW   x4 t  D], }  y t j |   Wq t k
 r2 Yq Xq Wt  d  d   =t rS d  a n  d  S)N)rX   rS   unlinkOSErrorrC   )Z	temp_filerI   rI   rJ   r6      s    	z:\d+$c             C   sY   |  j  } t |  d } | d k r: |  j d d  } n  t j d | d  } | j   S)zReturn request-host, as defined by RFC 2965.

    Variation from RFC: returned value is lowercased, for convenient
    comparison.

    rN    Host)full_urlr   
get_header_cut_port_resublower)requestrE   hostrI   rI   rJ   request_host   s    	rs   c               @   s*  e  Z d  Z d i  d d d d d  Z e d d    Z e j d d    Z e j d d    Z e d	 d
    Z e j d d
    Z e j d d
    Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d d  Z d d    Z d! d"   Z d S)#r   NFc       	      C   s   | |  _  i  |  _ i  |  _ d  |  _ | |  _ d  |  _ x* | j   D] \ } } |  j | |  qC W| d  k r~ t |   } n  | |  _	 | |  _
 | r | |  _ n  d  S)N)rl   ra   unredirected_hdrs_datarF   _tunnel_hostitems
add_headerrs   origin_req_hostunverifiablemethod)	selfrE   rF   ra   ry   rz   r{   keyvaluerI   rI   rJ   __init__   s    								zRequest.__init__c             C   s&   |  j  r d j |  j |  j   S|  j S)Nz{}#{})fragmentformat	_full_url)r|   rI   rI   rJ   rl     s    	zRequest.full_urlc             C   s8   t  |  |  _ t |  j  \ |  _ |  _ |  j   d  S)N)r   r   r   r   _parse)r|   rE   rI   rI   rJ   rl     s    c             C   s   d  |  _  d  |  _ d |  _ d  S)Nrj   )r   r   selector)r|   rI   rI   rJ   rl     s    		c             C   s   |  j  S)N)ru   )r|   rI   rI   rJ   rF   $  s    zRequest.datac             C   s>   | |  j  k r: | |  _  |  j d  r: |  j d  q: n  d  S)NzContent-length)ru   
has_headerremove_header)r|   rF   rI   rI   rJ   rF   (  s    	c             C   s   d  |  _  d  S)N)rF   )r|   rI   rI   rJ   rF   2  s    c             C   sw   t  |  j  \ |  _ } |  j d  k r= t d |  j   n  t |  \ |  _ |  _ |  j rs t |  j  |  _ n  d  S)Nzunknown url type: %r)	r   r   typer@   rl   r   rr   r   r
   )r|   restrI   rI   rJ   r   6  s    	zRequest._parsec             C   s+   |  j  d k	 r d n d } t |  d |  S)z3Return a string indicating the HTTP request method.NPOSTGETr{   )rF   getattr)r|   Zdefault_methodrI   rI   rJ   
get_method>  s    zRequest.get_methodc             C   s   |  j  S)N)rl   )r|   rI   rI   rJ   get_full_urlC  s    zRequest.get_full_urlc             C   sJ   |  j  d k r( |  j r( |  j |  _ n | |  _  |  j |  _ | |  _ d  S)Nhttps)r   rv   rr   rl   r   )r|   rr   r   rI   rI   rJ   	set_proxyF  s
    	zRequest.set_proxyc             C   s   |  j  |  j k S)N)r   rl   )r|   rI   rI   rJ   	has_proxyN  s    zRequest.has_proxyc             C   s   | |  j  | j   <d  S)N)ra   
capitalize)r|   r}   valrI   rI   rJ   rx   Q  s    zRequest.add_headerc             C   s   | |  j  | j   <d  S)N)rt   r   )r|   r}   r   rI   rI   rJ   add_unredirected_headerU  s    zRequest.add_unredirected_headerc             C   s   | |  j  k p | |  j k S)N)ra   rt   )r|   header_namerI   rI   rJ   r   Y  s    zRequest.has_headerc             C   s"   |  j  j | |  j j | |   S)N)ra   getrt   )r|   r   defaultrI   rI   rJ   rm   ]  s    	zRequest.get_headerc             C   s*   |  j  j | d   |  j j | d   d  S)N)ra   poprt   )r|   r   rI   rI   rJ   r   b  s    zRequest.remove_headerc             C   s/   |  j  j   } | j |  j  t | j    S)N)rt   copyupdatera   listrw   )r|   hdrsrI   rI   rJ   header_itemsf  s    zRequest.header_items)__name__
__module____qualname__r   propertyrl   setterdeleterrF   r   r   r   r   r   rx   r   r   rm   r   r   rI   rI   rI   rJ   r      s(   
c               @   sp   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 e j d
 d  Z	 d	 d d  Z
 d d   Z d	 S)r   c             C   sM   d t  } d | f g |  _ g  |  _ i  |  _ i  |  _ i  |  _ i  |  _ d  S)NzPython-urllib/%sz
User-agent)__version__
addheadershandlershandle_openhandle_errorprocess_responseprocess_request)r|   Zclient_versionrI   rI   rJ   r   l  s    
				zOpenerDirector.__init__c             C   s  t  | d  s( t d t |    n  d } xxt |  D]j} | d k rS q; n  | j d  } | d  |  } | | d d   } | j d	  r
| j d  | d } | | d d   } y t |  } Wn t k
 r Yn X|  j j	 | i   }	 |	 |  j | <n] | d
 k r(| } |  j
 }	 n? | d k rF| } |  j }	 n! | d k r; | } |  j }	 n q; |	 j | g   }
 |
 rt j |
 |  n |
 j |  d } q; W| rt j |  j |  | j |   n  d  S)N
add_parentz%expected BaseHandler instance, got %rFredirect_requestdo_open
proxy_open_rN   errorrD   responserq   T)zredirect_requestzdo_openz
proxy_open)hasattr	TypeErrorr   dirfind
startswithrZ   r@   r   r   r   r   r   
setdefaultbisectZinsortrY   r   r   )r|   handlerZaddedmethiprotocolZ	conditionjkindlookupr   rI   rI   rJ   add_handlerw  sJ    
zOpenerDirector.add_handlerc             C   s   d  S)NrI   )r|   rI   rI   rJ   close  s    zOpenerDirector.closec       	      G   sR   | j  | f   } x9 | D]1 } t | |  } | |   } | d  k	 r | Sq Wd  S)N)r   r   )	r|   chainr   	meth_nameargsr   r   funcrc   rI   rI   rJ   _call_chain  s    zOpenerDirector._call_chainNc       
      C   s   t  | t  r! t | |  } n | } | d  k	 r? | | _ n  | | _ | j } | d } x8 |  j j | g   D]! } t | |  } | |  } qq W|  j	 | |  }	 | d } x; |  j
 j | g   D]$ } t | |  } | | |	  }	 q W|	 S)NZ_requestZ	_response)
isinstancestrr   rF   rG   r   r   r   r   _openr   )
r|   fullurlrF   rG   reqr   r   Z	processorr   r   rI   rI   rJ   rD     s"    		

zOpenerDirector.openc             C   sp   |  j  |  j d d |  } | r% | S| j } |  j  |  j | | d |  } | rW | S|  j  |  j d d |  S)Nr   Zdefault_openr   unknownunknown_open)r   r   r   )r|   r   rF   rc   r   rI   rI   rJ   r     s    	zOpenerDirector._openc             G   s   | d
 k r< |  j  d } | d } d | } d } | } n |  j  } | d } d } | | | f | } |  j |   } | r | S| r | d d	 f | } |  j |   Sd  S)Nhttpr      zhttp_error_%srN   Z_errorr   r   http_error_default)zhttpzhttps)r   r   )r|   protor   dictr   Zhttp_errZ	orig_argsrc   rI   rI   rJ   r     s     

		
zOpenerDirector.error)r   r   r   r   r   r   r   socket_GLOBAL_DEFAULT_TIMEOUTrD   r   r   rI   rI   rI   rJ   r   k  s   /c           	   G   sC  t    } t t t t t t t t t	 g	 } t
 t j d  rL | j t  n  t   } xo | D]g } x^ |  D]V } t | t  r t | |  r | j |  q qi t | |  ri | j |  qi qi Wq\ Wx | D] } | j |  q Wx | D] } | j |    q Wx6 |  D]. } t | t  r.|   } n  | j |  qW| S)a*  Create an opener object from a list of handlers.

    The opener will use several default handlers, including support
    for HTTP, FTP and when applicable HTTPS.

    If any of the handlers passed as arguments are subclasses of the
    default handlers, the default handlers will not be used.
    HTTPSConnection)r   r   r-   r(   r   r   r*   r)   r.   r,   r   r   clientrY   rB   setr   r   
issubclassaddremover   )r   rH   Zdefault_classesskipklassZcheckhrI   rI   rJ   r1     s0    						c               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	r   i  c             C   s   | |  _  d  S)N)parent)r|   r   rI   rI   rJ   r      s    zBaseHandler.add_parentc             C   s   d  S)NrI   )r|   rI   rI   rJ   r   #  s    zBaseHandler.closec             C   s#   t  | d  s d S|  j | j k  S)Nhandler_orderT)r   r   )r|   otherrI   rI   rJ   __lt__'  s    zBaseHandler.__lt__N)r   r   r   r   r   r   r   rI   rI   rI   rJ   r     s   c               @   s.   e  Z d  Z d Z d Z d d   Z e Z d S)r.   zProcess HTTP error responses.i  c             C   sd   | j  | j | j   } } } d | k o7 d k  n s` |  j j d | | | | |  } n  | S)N   i,  r   )codemsgrR   r   r   )r|   rq   r   r   r   r   rI   rI   rJ   http_response4  s
     	z HTTPErrorProcessor.http_responseN)r   r   r   __doc__r   r   https_responserI   rI   rI   rJ   r.   0  s   c               @   s   e  Z d  Z d d   Z d S)r   c             C   s   t  | j | | | |   d  S)N)r   rl   )r|   r   r`   r   r   r   rI   rI   rJ   r   B  s    z*HTTPDefaultErrorHandler.http_error_defaultN)r   r   r   r   rI   rI   rI   rJ   r   A  s   c               @   sH   e  Z d  Z d Z d Z d d   Z d d   Z e Z Z Z	 d Z
 d S)	r      
   c       	         s   | j    } | d k r$ | d k p9 | d k o9 | d k sZ t | j | | | |   n  | j d d	  } d   t   f d d   | j j   D  } t | d | d | j d d S)a  Return a Request or None in response to a redirect.

        This is called by the http_error_30x methods when a
        redirection response is received.  If a redirection should
        take place, return a new Request to allow http_error_30x to
        perform the redirect.  Otherwise, raise HTTPError if no-one
        else should try to handle this url.  Return None if you can't
        but another Handler might.
        -  .  /  3  r   HEADr    z%20content-lengthcontent-typec             3   s3   |  ]) \ } } | j      k r | | f Vq d  S)N)rp   ).0kv)CONTENT_HEADERSrI   rJ   	<genexpr>d  s    	z7HTTPRedirectHandler.redirect_request.<locals>.<genexpr>ra   ry   rz   T)r   r   r   r   )zGETr   )r   r   r   )r   r   )	r   r   rl   replacer   ra   rw   r   ry   )	r|   r   r`   r   r   ra   newurlmZ
newheadersrI   )r   rJ   r   M  s    
(		z$HTTPRedirectHandler.redirect_requestc       
      C   s  d | k r | d } n d | k r2 | d } n d  St  |  } | j d k rv t | | d | | f | |   n  | j s t |  } d | d	 <n  t |  } t | j |  } |  j | | | | | |  } | d  k r d  St	 | d
  r[| j
 }	 | _
 |	 j | d  |  j k s3t |	  |  j k rot | j | |  j | | |   qon i  }	 | _
 | _
 |	 j | d  d |	 | <| j   | j   |  j j | d | j S)Nlocationurir   r   ftprj   z+%s - Redirection to url '%s' is not allowed/r   redirect_dictr   rN   rG   )zhttpzhttpszftprj   )r   schemer   rT   r   r   r   rl   r   r   r   r   max_repeatsr\   max_redirectionsinf_msgr[   r   r   rD   rG   )
r|   r   r`   r   r   ra   r   urlpartsnewZvisitedrI   rI   rJ   http_error_302o  s<    	

z"HTTPRedirectHandler.http_error_302zoThe HTTP server returned a redirect error that would lead to an infinite loop.
The last 30x error message was:
N)r   r   r   r   r   r   r  http_error_301http_error_303http_error_307r  rI   rI   rI   rJ   r   E  s   "7c       	      C   s   t  |   \ } } | j d  s0 d } |  } nY | j d  sR t d |    n  | j d d  } | d k ry d } n  | d |  } t |  \ } } | d k	 r t |  \ } } n
 d } } | | | | f S)a  Return (scheme, user, password, host/port) given a URL or an authority.

    If a URL is supplied, it must have an authority (host:port) component.
    According to RFC 3986, having an authority component means the URL must
    have two slashes after the scheme.
    r   Nz//zproxy URL with no authority: %rr   rN   rO   )r   r   r@   r   r   r   )	proxyr   Zr_scheme	authorityendZuserinfohostportuserpasswordrI   rI   rJ   _parse_proxy  s    		
r  c               @   s1   e  Z d  Z d Z d d d  Z d d   Z d S)r   d   Nc          	   C   s   | d  k r t    } n  t | d  s3 t d   | |  _ x@ | j   D]2 \ } } t |  d | | | |  j d d   qI Wd  S)Nkeyszproxies must be a mappingz%s_openc             S   s   | |  | |  S)NrI   )rr  r   r   rI   rI   rJ   <lambda>  s    z'ProxyHandler.__init__.<locals>.<lambda>)r4   r   AssertionErrorproxiesrw   setattrr   )r|   r  r   rE   rI   rI   rJ   r     s    	zProxyHandler.__init__c             C   s  | j  } t |  \ } } } } | d  k r6 | } n  | j rR t | j  rR d  S| r | r d t |  t |  f }	 t j |	 j    j d  }
 | j	 d d |
  n  t |  } | j
 | |  | | k s | d k r d  S|  j j | d | j Sd  S)Nz%s:%sasciizProxy-authorizationzBasic r   rG   )r   r  rr   proxy_bypassr
   base64	b64encodeencodedecoderx   r   r   rD   rG   )r|   r   r  r   Z	orig_typeZ
proxy_typer  r  r  Z	user_passZcredsrI   rI   rJ   r     s     		zProxyHandler.proxy_open)r   r   r   r   r   r   rI   rI   rI   rJ   r     s   
c               @   sO   e  Z d  Z d d   Z d d   Z d d   Z d d d	  Z d
 d   Z d S)r    c             C   s   i  |  _  d  S)N)passwd)r|   rI   rI   rJ   r     s    zHTTPPasswordMgr.__init__c                s   t  | t  r | g } n  |  j k r: i   j | <n  xG d D]?   t    f d d   | D  } | | f  j | | <qA Wd  S)NTFc                s"   g  |  ] }  j  |     q SrI   )
reduce_uri)r   u)default_portr|   rI   rJ   
<listcomp>  s   	 z0HTTPPasswordMgr.add_password.<locals>.<listcomp>)TF)r   r   r  tuple)r|   realmr   r  r  Zreduced_urirI   )r  r|   rJ   add_password  s    zHTTPPasswordMgr.add_passwordc       	      C   s   |  j  j | i   } xd d D]\ } |  j | |  } xA | j   D]3 \ } } x$ | D] } |  j | |  rT | SqT WqA Wq Wd S)NTF)TF)NN)r  r   r  rw   	is_suburi)	r|   r"  authuriZdomainsr  Zreduced_authuriZurisZauthinfor   rI   rI   rJ   find_user_password  s    z"HTTPPasswordMgr.find_user_passwordTc       
      C   s   t  |  } | d r= | d } | d } | d p7 d } n d } | } d } t |  \ } } | r | d k r | d k	 r i d d 6d d	 6j |  }	 |	 d k	 r d
 | |	 f } q n  | | f S)z@Accept authority or URI and extract only the authority and path.rN   r   r   r   NP   r   i  r   z%s:%d)r   r   r   )
r|   r   r  partsr   r	  rT   rr   portZdportrI   rI   rJ   r    s    


zHTTPPasswordMgr.reduce_uric             C   si   | | k r d S| d | d k r( d St  j | d | d f  } t |  t | d  k re d Sd S)zcCheck if test is below base in a URI tree

        Both args must be URIs in reduced form.
        Tr   FrN   )	posixpathcommonprefixr\   )r|   basetestZcommonrI   rI   rJ   r$  %  s    zHTTPPasswordMgr.is_suburiN)r   r   r   r   r#  r&  r  r$  rI   rI   rI   rJ   r      s
   
c               @   s   e  Z d  Z d d   Z d S)r!   c             C   sD   t  j |  | |  \ } } | d  k	 r1 | | f St  j |  d  |  S)N)r    r&  )r|   r"  r%  r  r  rI   rI   rJ   r&  6  s
    
z2HTTPPasswordMgrWithDefaultRealm.find_user_passwordN)r   r   r   r&  rI   rI   rI   rJ   r!   4  s   c               @   sL   e  Z d  Z e j d e j  Z d d d  Z d d   Z d d   Z	 d S)	r"   z1(?:.*,)*[ 	]*([^ 	]+)[ 	]+realm=(["']?)([^"']*)\2Nc             C   s4   | d  k r t    } n  | |  _ |  j j |  _ d  S)N)r    r  r#  )r|   Zpassword_mgrrI   rI   rJ   r   L  s    	z!AbstractBasicAuthHandler.__init__c       	      C   s   | j  | d   } | r | j   d } | j   d k rM t d |   q t j j |  } | r | j   \ } } } | d k r t j	 d t
 d  n  | j   d k r |  j | | |  Sq n  d  S)	Nr   basiczDAbstractBasicAuthHandler does not support the following scheme: '%s'"'zBasic Auth Realm was unquotedr   )r/  r0  )r   splitrp   r@   r"   rxsearchgroupswarningswarnUserWarningretry_http_basic_auth)	r|   authreqrr   r   ra   r   Zmor	   r"  rI   rI   rJ   http_error_auth_reqedR  s    	z.AbstractBasicAuthHandler.http_error_auth_reqedc             C   s   |  j  j | |  \ } } | d  k	 r d | | f } d t j | j    j d  } | j |  j d   | k rx d  S| j |  j |  |  j	 j
 | d | j Sd  Sd  S)Nz%s:%szBasic r  rG   )r  r&  r  r  r  r  rm   auth_headerr   r   rD   rG   )r|   rr   r   r"  r  pwrawauthrI   rI   rJ   r8  h  s    "z.AbstractBasicAuthHandler.retry_http_basic_auth)
r   r   r   recompileIr2  r   r:  r8  rI   rI   rI   rJ   r"   >  s
   	c               @   s"   e  Z d  Z d Z d d   Z d S)r#   Authorizationc             C   s%   | j  } |  j d | | |  } | S)Nzwww-authenticate)rl   r:  )r|   r   r`   r   r   ra   rE   r   rI   rI   rJ   http_error_401y  s    		z#HTTPBasicAuthHandler.http_error_401N)r   r   r   r;  rC  rI   rI   rI   rJ   r#   u  s   c               @   s"   e  Z d  Z d Z d d   Z d S)r$   zProxy-authorizationc             C   s%   | j  } |  j d | | |  } | S)Nzproxy-authenticate)rr   r:  )r|   r   r`   r   r   ra   r	  r   rI   rI   rJ   http_error_407  s    		z$ProxyBasicAuthHandler.http_error_407N)r   r   r   r;  rD  rI   rI   rI   rJ   r$     s   c               @   ss   e  Z d  Z d d d  Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z d d   Z	 d d   Z
 d S)r%   Nc             C   sO   | d  k r t    } n  | |  _ |  j j |  _ d |  _ d |  _ d  |  _ d  S)Nr   )r    r  r#  retriednonce_count
last_nonce)r|   r  rI   rI   rJ   r     s    			z"AbstractDigestAuthHandler.__init__c             C   s   d |  _  d  S)Nr   )rE  )r|   rI   rI   rJ   reset_retry_count  s    z+AbstractDigestAuthHandler.reset_retry_countc             C   s   | j  | d   } |  j d k r? t | j d d | d    n |  j d 7_ | r | j   d } | j   d k r |  j | |  S| j   d k r t d |   q n  d  S)	N   i  zdigest auth failedrN   r   Zdigestr.  zEAbstractDigestAuthHandler does not support the following scheme: '%s')r   rE  r   rl   r1  rp   retry_http_digest_authr@   )r|   r;  rr   r   ra   r9  r   rI   rI   rJ   r:    s    z/AbstractDigestAuthHandler.http_error_auth_reqedc             C   s   | j  d d  \ } } t t d  t |    } |  j | |  } | r d | } | j j |  j d   | k rw d  S| j |  j |  |  j	 j
 | d | j } | Sd  S)Nr   rN   z	Digest %srG   )r1  parse_keqv_listfilterparse_http_listget_authorizationra   r   r;  r   r   rD   rG   )r|   r   r>  tokenZ	challengechalZauth_valZresprI   rI   rJ   rJ    s    
z0AbstractDigestAuthHandler.retry_http_digest_authc             C   sX   d |  j  | t j   f } | j d  t d  } t j |  j   } | d  d  S)Nz	%s:%s:%s:r  rM      )rF  timeZctimer  _randombyteshashlibsha1	hexdigest)r|   noncesbdigrI   rI   rJ   
get_cnonce  s    z$AbstractDigestAuthHandler.get_cnoncec             C   s_  yK | d } | d } | j  d  } | j  d d  } | j  d d   } Wn t k
 rc d  SYn X|  j |  \ } }	 | d  k r d  S|  j j | | j  \ }
 } |
 d  k r d  S| j d  k	 r |  j | j |  } n d  } d |
 | | f } d | j   | j	 f } | d	 k r| |  j
 k r=|  j d
 7_ n d
 |  _ | |  _
 d |  j } |  j |  } d | | | | | |  f } |	 | |  |  } nD | d  k r|	 | |  d | | |  f  } n t d |   d |
 | | | j	 | f } | r| d | 7} n  | r0| d | 7} n  | d | 7} | r[| d | | f 7} n  | S)Nr"  rW  qop	algorithmMD5opaquez%s:%s:%sz%s:%sr>  rN   z%08xz%s:%s:%s:%s:%szqop '%s' is not supported.z>username="%s", realm="%s", nonce="%s", uri="%s", response="%s"z, opaque="%s"z, digest="%s"z, algorithm="%s"z, qop=auth, nc=%s, cnonce="%s")r   KeyErrorget_algorithm_implsr  r&  rl   rF   get_entity_digestr   r   rG  rF  r[  r   )r|   r   rP  r"  rW  r\  r]  r_  HKDr  r<  ZentdigZA1ZA2ZncvalueZcnonceZnoncebitZrespdigr,  rI   rI   rJ   rN    sV    

			(
z+AbstractDigestAuthHandler.get_authorizationc                sR   | d k r d d     n | d k r6 d d     n    f d d   }   | f S)Nr^  c             S   s   t  j |  j d   j   S)Nr  )rT  Zmd5r  rV  )xrI   rI   rJ   r    s    z?AbstractDigestAuthHandler.get_algorithm_impls.<locals>.<lambda>ZSHAc             S   s   t  j |  j d   j   S)Nr  )rT  rU  r  rV  )re  rI   rI   rJ   r    s    c                s     d |  | f  S)Nz%s:%srI   )rX  d)rc  rI   rJ   r    s    rI   )r|   r]  rd  rI   )rc  rJ   ra    s    z-AbstractDigestAuthHandler.get_algorithm_implsc             C   s   d  S)NrI   )r|   rF   rP  rI   rI   rJ   rb    s    z+AbstractDigestAuthHandler.get_entity_digest)r   r   r   r   rH  r:  rJ  r[  rN  ra  rb  rI   rI   rI   rJ   r%     s   	<
c               @   s.   e  Z d  Z d Z d Z d Z d d   Z d S)r&   zAn authentication protocol defined by RFC 2069

    Digest authentication improves on basic authentication because it
    does not transmit passwords in the clear.
    rB  i  c             C   s9   t  | j  d } |  j d | | |  } |  j   | S)NrN   zwww-authenticate)r   rl   r:  rH  )r|   r   r`   r   r   ra   rr   retryrI   rI   rJ   rC  *  s
    	
z$HTTPDigestAuthHandler.http_error_401N)r   r   r   r   r;  r   rC  rI   rI   rI   rJ   r&      s   c               @   s(   e  Z d  Z d Z d Z d d   Z d S)r'   zProxy-Authorizationi  c             C   s/   | j  } |  j d | | |  } |  j   | S)Nzproxy-authenticate)rr   r:  rH  )r|   r   r`   r   r   ra   rr   rg  rI   rI   rJ   rD  7  s
    		
z%ProxyDigestAuthHandler.http_error_407N)r   r   r   r;  r   rD  rI   rI   rI   rJ   r'   2  s   c               @   sC   e  Z d  Z d d d  Z d d   Z d d   Z d d	   Z d
 S)AbstractHTTPHandlerr   c             C   s   | |  _  d  S)N)_debuglevel)r|   
debuglevelrI   rI   rJ   r   @  s    zAbstractHTTPHandler.__init__c             C   s   | |  _  d  S)N)ri  )r|   levelrI   rI   rJ   set_http_debuglevelC  s    z'AbstractHTTPHandler.set_http_debuglevelc             C   s  | j  } | s t d   n  | j d  k	 r| j } t | t  rZ d } t |   n  | j d  s| | j d d  n  | j d  sy t |  } WnC t k
 r t | t	 j
  r t d t |  | f   n  YqX| j d d t |  | j  qn  | } | j   rDt | j  \ } } t |  \ } }	 n  | j d  sf| j d |  n  xH |  j j D]: \ }
 } |
 j   }
 | j |
  ss| j |
 |  qsqsW| S)	Nzno host givenzLPOST data should be bytes or an iterable of bytes. It cannot be of type str.zContent-typez!application/x-www-form-urlencodedzContent-lengthzBContent-Length should be specified for iterable data of type %r %rz%drk   )rr   r   rF   r   r   r   r   r   
memoryviewcollectionsIterabler@   r   r\   itemsizer   r   r   r   r   r   r   )r|   rq   rr   rF   r   ZmvZsel_hostr   ZselZsel_pathrW   r~   rI   rI   rJ   do_request_F  sB    		
	!zAbstractHTTPHandler.do_request_c       
         s  | j  } | s t d   n  | | d | j | } t | j      j t   f d d   | j j   D   d   d <t d d     j   D    | j r i  } d } |   k r   | | | <  | =n  | j	 | j d	 | n  yj y& | j
 | j   | j | j    Wn1 t k
 rK} z t |   WYd
 d
 } ~ Xn X| j   }	 Wn | j     Yn X| j r| j j   d
 | _ n  | j   |	 _ |	 j |	 _ |	 S)zReturn an HTTPResponse object for the request, using http_class.

        http_class must implement the HTTPConnection API from http.client.
        zno host givenrG   c             3   s-   |  ]# \ } } |   k r | | f Vq d  S)NrI   )r   r   r   )ra   rI   rJ   r   {  s    	z.AbstractHTTPHandler.do_open.<locals>.<genexpr>r   
Connectionc             s   s'   |  ] \ } } | j    | f Vq d  S)N)title)r   rW   r   rI   rI   rJ   r     s    zProxy-Authorizationra   N)rr   r   rG   r   rt   r   ra   rw   rv   Z
set_tunnelrq   r   r   rF   ri   getresponser   Zsockr   rE   reasonr   )
r|   Z
http_classr   Zhttp_conn_argsrr   r   Ztunnel_headersZproxy_auth_hdrerrr  rI   )ra   rJ   r   n  s<    	/
	
&
	zAbstractHTTPHandler.do_openN)r   r   r   r   rl  rq  r   rI   rI   rI   rJ   rh  >  s   (rh  c               @   s%   e  Z d  Z d d   Z e j Z d S)r(   c             C   s   |  j  t j j |  S)N)r   r   r   HTTPConnection)r|   r   rI   rI   rJ   	http_open  s    zHTTPHandler.http_openN)r   r   r   rx  rh  rq  http_requestrI   rI   rI   rJ   r(     s   r   c               @   s:   e  Z d  Z d d d d d  Z d d   Z e j Z d S)rB   r   Nc             C   s&   t  j |  |  | |  _ | |  _ d  S)N)rh  r   _context_check_hostname)r|   rj  r=   r>   rI   rI   rJ   r     s    	zHTTPSHandler.__init__c             C   s(   |  j  t j j | d |  j d |  j S)Nr=   r>   )r   r   r   r   rz  r{  )r|   r   rI   rI   rJ   
https_open  s    zHTTPSHandler.https_open)r   r   r   r   r|  rh  rq  https_requestrI   rI   rI   rJ   rB     s   rB   c               @   sC   e  Z d  Z d d d  Z d d   Z d d   Z e Z e Z d S)r   Nc             C   s7   d d  l  } | d  k r* | j j   } n  | |  _ d  S)Nr   )Zhttp.cookiejar	cookiejarZ	CookieJar)r|   r~  r   rI   rI   rJ   r     s    zHTTPCookieProcessor.__init__c             C   s   |  j  j |  | S)N)r~  Zadd_cookie_header)r|   rq   rI   rI   rJ   ry    s    z HTTPCookieProcessor.http_requestc             C   s   |  j  j | |  | S)N)r~  Zextract_cookies)r|   rq   r   rI   rI   rJ   r     s    z!HTTPCookieProcessor.http_response)r   r   r   r   ry  r   r}  r   rI   rI   rI   rJ   r     s
   c               @   s   e  Z d  Z d d   Z d S)r-   c             C   s   | j  } t d |   d  S)Nzunknown url type: %s)r   r   )r|   r   r   rI   rI   rJ   r     s    	zUnknownHandler.unknown_openN)r   r   r   r   rI   rI   rI   rJ   r-     s   c             C   sp   i  } xc |  D][ } | j  d d  \ } } | d d k r^ | d d k r^ | d d  } n  | | | <q W| S)z>Parse list of key=value strings where keys are not duplicated.=rN   r   r/  rO   rO   )r1  )lZparsedZeltr   r   rI   rI   rJ   rK    s     rK  c             C   s   g  } d } d } } x |  D] } | r? | | 7} d } q n  | r | d k r] d } q n | d k rr d } n  | | 7} q n  | d k r | j  |  d } q n  | d k r d } n  | | 7} q W| r | j  |  n  d d   | D S)	ap  Parse lists as described by RFC 2068 Section 2.

    In particular, parse comma-separated lists where the elements of
    the list may include quoted-strings.  A quoted-string could
    contain a comma.  A non-quoted string could have quotes in the
    middle.  Neither commas nor quotes count if they are escaped.
    Only double-quotes count, not single-quotes.
    rj   F\Tr/  ,c             S   s   g  |  ] } | j     q SrI   )strip)r   partrI   rI   rJ   r     s   	 z#parse_http_list.<locals>.<listcomp>)rY   )rX  Zresr  escaper	   ZcurrI   rI   rJ   rM    s4    	

	
	rM  c               @   s:   e  Z d  Z d d   Z d Z d d   Z d d   Z d S)r)   c             C   s   | j  } | d  d  d k rt | d d  d k rt | j rt | j d k rt | j |  j   k r t d   q n |  j |  Sd  S)Nr   z//r9   r   	localhostz-file:// scheme is supported only on localhost)r   rr   	get_namesr   open_local_file)r|   r   rE   rI   rI   rJ   	file_open  s    	5zFileHandler.file_openNc             C   s}   t  j d  k rv y7 t t j d  d t j t j    d  t  _ Wqv t j k
 rr t j d  f t  _ Yqv Xn  t  j S)Nr  r   )r)   namesr!  r   gethostbyname_exgethostnamegaierrorgethostbyname)r|   rI   rI   rJ   r     s    $zFileHandler.get_namesc             C   sa  d d  l  } d d  l } | j } | j } t |  } y t j |  } | j } | j j	 | j
 d d }	 | j |  d }
 | j d |
 p d | |	 f  } | r t |  \ } } n  | s | rt |  |  j   k r| r d | | } n
 d | } t t | d  | |  SWn1 t k
 rP} z t |   WYd  d  } ~ Xn Xt d   d  S)	Nr   usegmtTz6Content-type: %s
Content-length: %d
Last-modified: %s
z
text/plainzfile://rbzfile not on local host)email.utils	mimetypesrr   r   r3   rS   statst_sizeutils
formatdatest_mtime
guess_typemessage_from_stringr   _safe_gethostbynamer  r   rD   ri   r   )r|   r   emailr  rr   r^   Z	localfilestatsre   modifiedmtypera   r)  ZorigurlexprI   rI   rJ   r  +  s0    			
zFileHandler.open_local_file)r   r   r   r  r  r  r  rI   rI   rI   rJ   r)     s   
c             C   s1   y t  j |   SWn t  j k
 r, d  SYn Xd  S)N)r   r  r  )rr   rI   rI   rJ   r  G  s    r  c               @   s(   e  Z d  Z d d   Z d d   Z d S)r*   c             C   s  d d  l  } d d  l } | j } | s6 t d   n  t |  \ } } | d  k r` | j } n t |  } t |  \ } } | r t |  \ } } n d  } t	 |  } | p d } | p d } y t
 j |  } Wn1 t k
 r	} z t |   WYd  d  } ~ Xn Xt | j  \ }	 }
 |	 j d  } t t t	 |   } | d  d  | d } } | r| d r| d d   } n  y|  j | | | | | | j  } | rd pd } xM |
 D]E } t |  \ } } | j   d k r| d k r| j   } qqW| j | |  \ } } d } | j | j  d } | rS| d | 7} n  | d  k	 r|| d k r|| d | 7} n  t j |  } t | | | j  SWnQ | j k
 r} z. t d |  } | j t j    d   WYd  d  } ~ Xn Xd  S)Nr   zftp error: no host givenrj   r   rN   rA  Dr   aAr   rf  zContent-type: %s
zContent-length: %d
zftp error: %rr   rO   rO   )r  r  r   rA  rf  r  )!ftplibr  rr   r   r   FTP_PORTrZ   r   r   r
   r   r  ri   r   r   r1  r   mapconnect_ftprG   r   rp   upperretrfiler  rl   r  r  r   
all_errorswith_tracebacksysexc_info)r|   r   r  r  rr   r)  r  r  r   rT   attrsdirsrK   Zfwr   attrr~   r`   retrlenra   r  r  excrI   rI   rJ   ftp_openN  s\    	!zFTPHandler.ftp_openc          	   C   s   t  | | | | | | d d S)N
persistentF)
ftpwrapper)r|   r  r  rr   r)  r  rG   rI   rI   rJ   r    s    zFTPHandler.connect_ftpN)r   r   r   r  r  rI   rI   rI   rJ   r*   M  s   5c               @   sX   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d S)r+   c             C   s1   i  |  _  i  |  _ d |  _ d |  _ d |  _ d  S)Nr   <   rQ  )cacherG   soonestdelay	max_conns)r|   rI   rI   rJ   r     s
    				zCacheFTPHandler.__init__c             C   s   | |  _  d  S)N)r  )r|   trI   rI   rJ   
setTimeout  s    zCacheFTPHandler.setTimeoutc             C   s   | |  _  d  S)N)r  )r|   r   rI   rI   rJ   setMaxConns  s    zCacheFTPHandler.setMaxConnsc             C   s   | | | d j  |  | f } | |  j k rJ t j   |  j |  j | <n< t | | | | | |  |  j | <t j   |  j |  j | <|  j   |  j | S)Nr   )joinr  rR  r  rG   r  check_cache)r|   r  r  rr   r)  r  rG   r}   rI   rI   rJ   r    s    
zCacheFTPHandler.connect_ftpc             C   s   t  j    } |  j | k rx xZ t |  j j    D]@ \ } } | | k  r1 |  j | j   |  j | =|  j | =q1 q1 Wn  t t |  j j     |  _ t	 |  j  |  j
 k rxJ t |  j j    D]3 \ } } | |  j k r |  j | =|  j | =Pq q Wt t |  j j     |  _ n  d  S)N)rR  r  r   rG   rw   r  r   minvaluesr\   r  )r|   r  r   r   rI   rI   rJ   r    s    "
"

zCacheFTPHandler.check_cachec             C   sB   x! |  j  j   D] } | j   q W|  j  j   |  j j   d  S)N)r  r  r   clearrG   )r|   connrI   rI   rJ   clear_cache  s    zCacheFTPHandler.clear_cacheN)	r   r   r   r   r  r  r  r  r  rI   rI   rI   rJ   r+     s   c               @   s   e  Z d  Z d d   Z d S)r,   c             C   s   | j  } | j d d  \ } } | j d d  \ } } t |  } | j d  rv t j |  } | d  d  } n  | s d } n  t j d | t |  f  } t	 t
 j |  | |  S)	N:rN   r  z;base64   ztext/plain;charset=US-ASCIIz$Content-type: %s
Content-length: %d
i)rl   r1  r   endswithr  decodebytesr  r  r\   r   ioBytesIO)r|   r   rE   r   rF   Z	mediatypera   rI   rI   rJ   	data_open  s    
			zDataHandler.data_openN)r   r   r   r  rI   rI   rI   rJ   r,     s   r   nt)r3   r2   c             C   s
   t  |   S)zOS-specific conversion from a relative URL of the 'file' scheme
        to a file system path; not recommended for general use.)r
   )pathnamerI   rI   rJ   r3     s    c             C   s
   t  |   S)zOS-specific conversion from a file system path to a relative URL
        of the 'file' scheme; not recommended for general use.)r	   )r  rI   rI   rJ   r2     s    c               @   s4  e  Z d  Z d Z d Z d e Z d d d  Z d d   Z d d	   Z	 d
 d   Z
 d d   Z d d d  Z d d d  Z d d d  Z d d d d d  Z d d   Z d d d  Z d d d  Z d d   Z e r d d   Z d d  d!  Z n  d" d#   Z d$ d%   Z d& d'   Z d d( d)  Z d S)*r7   a,  Class to open URLs.
    This is a class rather than just a subroutine because we may need
    more than one set of global protocol-specific options.
    Note -- this is a base class for those who don't want the
    automatic handling of errors type 302 (relocated) and 401
    (authorization needed).NzPython-urllib/%sc             K   s   d i |  j  j d 6} t j | t d d | d  k rE t   } n  t | d  s` t d   | |  _ | j	 d  |  _
 | j	 d  |  _ d	 |  j f g |  _ g  |  _ t j |  _ d  |  _ t |  _ d  S)
NzW%(class)s style of invoking requests is deprecated. Use newer urlopen functions/methodsclass
stacklevelr9   r  zproxies must be a mappingkey_file	cert_filez
User-Agent)	__class__r   r5  r6  DeprecationWarningr4   r   r  r  r   r  r  versionr   _URLopener__tempfilesrS   rh   _URLopener__unlink	tempcacheftpcache)r|   r  Zx509r   rI   rI   rJ   r     s    			zURLopener.__init__c             C   s   |  j    d  S)N)r   )r|   rI   rI   rJ   __del__  s    zURLopener.__del__c             C   s   |  j    d  S)N)cleanup)r|   rI   rI   rJ   r     s    zURLopener.closec             C   ss   |  j  rV x7 |  j  D], } y |  j |  Wq t k
 r> Yq Xq W|  j  d  d   =n  |  j ro |  j j   n  d  S)N)r  r  ri   r  r  )r|   rK   rI   rI   rJ   r  "  s    			zURLopener.cleanupc             G   s   |  j  j |  d S)zdAdd a header to be used by the HTTP interface only
        e.g. u.addheader('Accept', 'sound/basic')N)r   rY   )r|   r   rI   rI   rJ   	addheader0  s    zURLopener.addheaderc             C   s  t  t |   } t | d d } |  j rn | |  j k rn |  j | \ } } t | d  } t | | |  St |  \ } } | s d } n  | |  j k r |  j | } t |  \ } }	 t |	  \ }
 } |
 | f } n d } d | } | |  _	 | j
 d d  } t |  |  sD| r1|  j | | |  S|  j | |  Sn  y9 | d k rft |  |  |  St |  |  | |  SWna t t f k
 r  YnG t k
 r} z' t d	 |  j t j   d
   WYd d } ~ Xn Xd S)z6Use URLopener().open(file) instead of open(file, 'r').safez%/:=&?~#+!$,;'@()*[]|r  rK   NZopen_-r   zsocket errorr   )r   r   r	   r  rD   r   r   r  r   r   r   r   open_unknown_proxyopen_unknownr   r   r   ri   r  r  r  )r|   r   rF   r^   ra   r`   urltyperE   r  	proxyhostrr   r   rW   r   rI   rI   rJ   rD   6  s<    	
	zURLopener.openc             C   s(   t  |  \ } } t d d |   d S)z/Overridable interface to open unknown URL type.z	url errorzunknown url typeN)r   ri   )r|   r   rF   r   rE   rI   rI   rJ   r  Z  s    zURLopener.open_unknownc             C   s,   t  |  \ } } t d d | |   d S)z/Overridable interface to open unknown URL type.z	url errorzinvalid proxy for %sN)r   ri   )r|   r  r   rF   r   rE   rI   rI   rJ   r  _  s    zURLopener.open_unknown_proxyc              C   s  t  t |   } |  j r5 | |  j k r5 |  j | St |  \ } } | d k r | sf | d k r yC |  j |  } | j   } | j   t t |  d  | f SWq t	 k
 r }	 z WYd d }	 ~	 Xq Xn  |  j
 | |  } z| j   }
 | rt
 | d  } n d d l } t |  \ } } t | p7d  \ } } t | pOd  \ } } t | pgd  \ } } t j j |  d } | j |  \ } } |  j j |  t j | d  } z | |
 f } |  j d k	 r| |  j | <n  d } d } d } d } d	 |
 k r%t |
 d
  } n  | r>| | | |  n  x\ | j |  } | sZPn  | t |  7} | j |  | d 7} | rA| | | |  qAqAWd | j   XWd | j   X| d k r| | k  rt d | | f |   n  | S)ztretrieve(url) returns (filename, headers) for a local object
        or (tempfilename, headers) for a remote object.NrK   rN   rL   r   rj   i   rM   zcontent-lengthzContent-Lengthz1retrieval incomplete: got only %i out of %i bytesi    rO   )r   r   r  r   r  rR   r   r3   r   ri   rD   rV   r   r   rS   rT   splitextZmkstempr  rY   fdopenrZ   r[   r\   r]   r   )r|   rE   r^   r_   rF   r   Zurl1r`   r   r   ra   rb   rV   ZgarbagerT   suffixfdrc   rd   re   r[   rf   rg   rI   rI   rJ   retrievee  sl    

zURLopener.retrievec             C   s  d } d } t  | t  r] t |  \ } } | rT t |  \ } } t |  } n  | } n | \ } } t |  \ } } t |  \ }	 }
 |
 } d } |	 j   d k r d } n^ t |
  \ } }
 | r t |  \ } } n  | r d |	 | |
 f } n  t |  r| } n  | s*t d d   n  | r]t |  } t	 j
 | j    j d  } n d } | rt |  } t	 j
 | j    j d  } n d } | |  } i  } | rd | | d <n  | rd | | d	 <n  | r| | d
 <n  d | d <x! |  j D] \ } } | | | <qW| d k	 rLd | d <| j d | | |  n | j d | d | y | j   } Wn$ t j j k
 rt d   Yn Xd | j k od k  n rt | | j d | | j  S|  j | | j | j | j | j |  Sd S)a  Make an HTTP connection using connection_class.

        This is an internal method that should be called from
        open_http() or open_https().

        Arguments:
        - connection_factory should take a host name and return an
          HTTPConnection instance.
        - url is the url to retrieval or a host, relative-path pair.
        - data is payload for a POST request or None.
        Nr   z	%s://%s%sz
http errorzno host givenr  zBasic %szProxy-AuthorizationrB  rk   r   rr  z!application/x-www-form-urlencodedzContent-Typer   r   ra   z$http protocol error: bad status liner   i,  zhttp:)r   r   r   r   r
   r   rp   r  ri   r  r  r  r  r   rq   rt  r   r   ZBadStatusLiner   Zstatusr   r   
http_errorr`   ru  )r|   Zconnection_factoryrE   rF   Zuser_passwdZproxy_passwdrr   r   Zrealhostr  r   Z
proxy_authr>  Z	http_connra   headerr~   r   rI   rI   rJ   _open_generic_http  sr    			 !!


	zURLopener._open_generic_httpc             C   s   |  j  t j j | |  S)zUse HTTP protocol.)r  r   r   rw  )r|   rE   rF   rI   rI   rJ   	open_http  s    zURLopener.open_httpc       
      C   s   d | } t  |  |  rw t |  |  } | d k rO | | | | | |  }	 n | | | | | | |  }	 |	 rw |	 Sn  |  j | | | | |  S)zHandle http errors.

        Derived class can override this, or provide specific handlers
        named http_error_DDD where DDD is the 3-digit error code.zhttp_error_%dN)r   r   r   )
r|   rE   r`   errcodeerrmsgra   rF   rW   r{   rc   rI   rI   rJ   r    s    
 zURLopener.http_errorc             C   s&   | j    t | | | | d   d S)z>Default error handler: close the connection and raise OSError.N)r   r   )r|   rE   r`   r  r  ra   rI   rI   rJ   r     s    
zURLopener.http_error_defaultc             C   s"   t  j j | d |  j d |  j S)Nr  r  )r   r   r   r  r  )r|   rr   rI   rI   rJ   _https_connection  s    	zURLopener._https_connectionc             C   s   |  j  |  j | |  S)zUse HTTPS protocol.)r  r  )r|   rE   rF   rI   rI   rJ   
open_https"  s    zURLopener.open_httpsc             C   s   t  | t  s t d   n  | d d  d k ru | d d  d k ru | d d  j   d k ru t d	   n |  j |  Sd S)
z/Use local file or FTP depending on form of URL.zEfile error: proxy support for file protocol currently not implementedNr   z//r9   r      z
localhost/z-file:// scheme is supported only on localhost)r   r   r   rp   r@   r  )r|   rE   rI   rI   rJ   	open_file&  s
    HzURLopener.open_filec             C   s  d d l  } d d l } t |  \ } } t |  } y t j |  } Wn: t k
 r } z t | j | j	   WYd d } ~ Xn X| j
 }	 | j j | j d d }
 | j |  d } | j d | p d |	 |
 f  } | s'| } | d d  d k rd	 | } n  t t | d
  | |  St |  \ } } | rt j |  t   f t   k r| } | d d  d k rd	 | } n) | d d  d k rt d |   n  t t | d
  | |  St d   d S)zUse local file.r   Nr  Tz6Content-Type: %s
Content-Length: %d
Last-modified: %s
z
text/plainrN   r   zfile://r  r   z./zAlocal file url may start with / or file:. Unknown url of type: %sz#local file error: not on local host)r  r  r   r3   rS   r  ri   r   strerrorr^   r  r  r  r  r  r  r   rD   r   r   r  r  thishostr@   )r|   rE   r  r  rr   rK   Z	localnamer  ere   r  r  ra   Zurlfiler)  rI   rI   rJ   r  /  s:    (	"zURLopener.open_local_filec             C   s  t  | t  s t d   n  d d l } t |  \ } } | sQ t d   n  t |  \ } } t |  \ } } | r t |  \ } } n d } t |  } t | p d  } t | p d  } t	 j
 |  } | s d d l } | j } n t |  } t |  \ } }	 t |  } | j d  }
 |
 d d  |
 d }
 } |
 rk|
 d rk|
 d d  }
 n  |
 r|
 d rd |
 d <n  | | | d j |
  f } t |  j  t k rxJ t |  j  D]6 } | | k r|  j | } |  j | =| j   qqWn  y9| |  j k r:t | | | | |
  |  j | <n  | sId } n d	 } xM |	 D]E } t |  \ } } | j   d
 k rV| d k rV| j   } qVqVW|  j | j | |  \ } } | j d |  d } d } | r| d | 7} n  | d k	 r| d k r| d | 7} n  t j |  } t | | d |  SWnK t   k
 r} z( t d |  j  t! j"   d   WYd d } ~ Xn Xd S)zUse FTP protocol.zCftp error: proxy support for ftp protocol currently not implementedr   Nzftp error: no host givenrj   r   rN   r  rA  r   r  r  r   rf  zftp:zContent-Type: %s
zContent-Length: %d
zftp error %rr   rO   rO   )r  r  r   rA  rf  r  )#r   r   r   r  r   r   r   r   r
   r   r  r  r  rZ   r   r1  r  r\   r  MAXFTPCACHEr   r   r  r   rp   r  r  r  r  r  r   	ftperrorsr  r  r  )r|   rE   r  rr   rT   r)  r  r  r  r  r  rK   r}   r   r   r   r  r~   r`   r  r  ra   r  rI   rI   rJ   open_ftpO  sp        
" 	zURLopener.open_ftpc       	      C   s  t  | t  s t d   n  y | j d d  \ } } Wn! t k
 r] t d d   Yn X| sm d } n  | j d  } | d k r d	 | | d
  k r | | d d
  } | d
 |  } n d } g  } | j d t j	 d t j
 t j      | j d |  | d k r>t j | j d   j d  } n t |  } | j d t |   | j d  | j |  d j |  } t j |  } t j |  } t | | |  S)zUse "data" URL.zEdata error: proxy support for data protocol currently not implementedr  rN   z
data errorzbad data URLztext/plain;charset=US-ASCII;r   r  Nrj   zDate: %sz%a, %d %b %Y %H:%M:%S GMTzContent-type: %sr  r  zlatin-1zContent-Length: %d
)r   r   r   r1  r@   ri   rfindrY   rR  ZstrftimeZgmtimer  r  r  r  r
   r\   r  r  r  r  StringIOr   )	r|   rE   rF   r   Zsemiencodingr   ra   frI   rI   rJ   	open_data  s6    	"$zURLopener.open_data)r   r   r   r   r  r   r  r   r  r   r  r  rD   r  r  r  r  r  r  r   r?   r  r  r  r  r  r  rI   rI   rI   rJ   r7     s.   
$B\	 :c               @   s   e  Z d  Z d Z d d   Z d d   Z d d d  Z d	 d
   Z d d d  Z d d d  Z	 d d d  Z
 d d d d  Z d d d d  Z d d d  Z d d d  Z d d d  Z d d d  Z d d d   Z d! d"   Z d S)#r8   z?Derived class with handlers for errors we can handle (perhaps).c             O   s2   t  j |  | |  i  |  _ d |  _ d |  _ d  S)Nr   r   )r7   r   
auth_cachetriesmaxtries)r|   r   kwargsrI   rI   rJ   r     s    		zFancyURLopener.__init__c             C   s   t  | | d | |  S)z3Default error handling -- don't raise an exception.zhttp:)r   )r|   rE   r`   r  r  ra   rI   rI   rJ   r     s    z!FancyURLopener.http_error_defaultNc       	      C   s   |  j  d 7_  |  j rm |  j  |  j k rm t |  d  rE |  j } n	 |  j } d |  _  | | | d d |  S|  j | | | | | |  } d |  _  | S)z%Error 302 -- relocated (temporarily).rN   http_error_500r   i  z)Internal Server Error: Redirect Recursion)r  r  r   r  r   redirect_internal)	r|   rE   r`   r  r  ra   rF   r   rc   rI   rI   rJ   r    s    		
		zFancyURLopener.http_error_302c       	      C   s   d | k r | d } n d | k r2 | d } n d  S| j    t |  j d | |  } t |  } | j d	 k r t | | | d | | |   n  |  j |  S)
Nr   r   r  r   r   r   rj   z( Redirection to url '%s' is not allowed.)zhttpzhttpszftprj   )r   r   r   r   r   r   rD   )	r|   rE   r`   r  r  ra   rF   r   r  rI   rI   rJ   r    s    
	z FancyURLopener.redirect_internalc             C   s   |  j  | | | | | |  S)z*Error 301 -- also relocated (permanently).)r  )r|   rE   r`   r  r  ra   rF   rI   rI   rJ   r    s    zFancyURLopener.http_error_301c             C   s   |  j  | | | | | |  S)z;Error 303 -- also relocated (essentially identical to 302).)r  )r|   rE   r`   r  r  ra   rF   rI   rI   rJ   r    s    zFancyURLopener.http_error_303c             C   sE   | d k r( |  j  | | | | | |  S|  j | | | | |  Sd S)z1Error 307 -- relocated, but turn POST into error.N)r  r   )r|   rE   r`   r  r  ra   rF   rI   rI   rJ   r    s    zFancyURLopener.http_error_307Fc             C   s$  d | k r+ t  j |  | | | | |  n  | d } t j d |  }	 |	 sl t  j |  | | | | |  n  |	 j   \ }
 } |
 j   d k r t  j |  | | | | |  n  | s t  j |  | | | | |  n  d |  j d } | d k rt |  |  | |  St |  |  | | |  Sd S)z_Error 401 -- authentication required.
        This function supports Basic authentication only.zwww-authenticatez![ 	]*([^ 	]+)[ 	]+realm="([^"]*)"r.  Zretry__basic_authN)r7   r   r?  matchr4  rp   r   r   )r|   rE   r`   r  r  ra   rF   rg  stuffr  r   r"  rW   rI   rI   rJ   rC    s&    

zFancyURLopener.http_error_401c             C   s$  d | k r+ t  j |  | | | | |  n  | d } t j d |  }	 |	 sl t  j |  | | | | |  n  |	 j   \ }
 } |
 j   d k r t  j |  | | | | |  n  | s t  j |  | | | | |  n  d |  j d } | d k rt |  |  | |  St |  |  | | |  Sd S)zeError 407 -- proxy authentication required.
        This function supports Basic authentication only.zproxy-authenticatez![ 	]*([^ 	]+)[ 	]+realm="([^"]*)"r.  Zretry_proxy_r  N)r7   r   r?  r  r4  rp   r   r   )r|   rE   r`   r  r  ra   rF   rg  r  r  r   r"  rW   rI   rI   rJ   rD    s&    

zFancyURLopener.http_error_407c             C   s  t  |  \ } } d | | } |  j d } t |  \ } }	 t  |	  \ }	 }
 |	 j d  d } |	 | d   }	 |  j |	 | |  \ } } | p | s d  Sd t | d d t | d d |	 f }	 d |	 |
 |  j d <| d  k r |  j |  S|  j | |  Sd  S)Nzhttp://r   @rN   z%s:%s@%sr  rj   )r   r  r   r   get_user_passwdr	   rD   )r|   rE   r"  rF   rr   r   r   r  r  r  proxyselectorr   r  r  rI   rI   rJ   retry_proxy_http_basic_auth-  s      z*FancyURLopener.retry_proxy_http_basic_authc             C   s  t  |  \ } } d | | } |  j d } t |  \ } }	 t  |	  \ }	 }
 |	 j d  d } |	 | d   }	 |  j |	 | |  \ } } | p | s d  Sd t | d d t | d d |	 f }	 d |	 |
 |  j d <| d  k r |  j |  S|  j | |  Sd  S)Nzhttps://r   r  rN   z%s:%s@%sr  rj   )r   r  r   r   r  r	   rD   )r|   rE   r"  rF   rr   r   r   r  r  r  r  r   r  r  rI   rI   rJ   retry_proxy_https_basic_auth?  s      z+FancyURLopener.retry_proxy_https_basic_authc       
      C   s   t  |  \ } } | j d  d } | | d   } |  j | | |  \ } } | pY | s` d  Sd t | d d t | d d | f } d | | }	 | d  k r |  j |	  S|  j |	 |  Sd  S)Nr  rN   z%s:%s@%sr  rj   zhttp://)r   r   r  r	   rD   )
r|   rE   r"  rF   rr   r   r   r  r  r   rI   rI   rJ   r8  Q  s     z$FancyURLopener.retry_http_basic_authc       
      C   s   t  |  \ } } | j d  d } | | d   } |  j | | |  \ } } | pY | s` d  Sd t | d d t | d d | f } d | | }	 | d  k r |  j |	  S|  j |	 |  Sd  S)Nr  rN   z%s:%s@%sr  rj   zhttps://)r   r   r  r	   rD   )
r|   rE   r"  rF   rr   r   r   r  r  r   rI   rI   rJ   retry_https_basic_auth_  s     z%FancyURLopener.retry_https_basic_authr   c             C   s   | d | j    } | |  j k rD | r6 |  j | =qD |  j | Sn  |  j | |  \ } } | sh | r~ | | f |  j | <n  | | f S)Nr  )rp   r  prompt_user_passwd)r|   rr   r"  r  r}   r  r  rI   rI   rJ   r  m  s     zFancyURLopener.get_user_passwdc             C   sp   d d l  } y@ t d | | f  } | j  d | | | f  } | | f SWn t k
 rk t   d SYn Xd S)z#Override this in a GUI environment!r   NzEnter username for %s at %s: z#Enter password for %s in %s at %s: )NN)getpassinputKeyboardInterruptprint)r|   rr   r"  r  r  r  rI   rI   rJ   r  x  s    	z!FancyURLopener.prompt_user_passwd)r   r   r   r   r   r   r  r  r  r  r  rC  rD  r	  r
  r8  r  r  r  rI   rI   rI   rJ   r8     s$   c               C   s"   t  d k r t j d  a  n  t  S)z8Return the IP address of the magic hostname 'localhost'.Nr  )
_localhostr   r  rI   rI   rI   rJ   r    s    r  c               C   sg   t  d k rc y# t t j t j    d  a  Wqc t j k
 r_ t t j d  d  a  Yqc Xn  t  S)z,Return the IP addresses of the current host.Nr   r  )	_thishostr!  r   r  r  r  rI   rI   rI   rJ   r    s    #!r  c              C   s(   t  d k r$ d d l }  |  j a  n  t  S)z1Return the set of errors raised by the FTP class.Nr   )
_ftperrorsr  r  )r  rI   rI   rJ   r    s    r  c               C   s"   t  d k r t j d  a  n  t  S)z%Return an empty email Message object.Nrj   )
_noheadersr  r  rI   rI   rI   rJ   	noheaders  s    r  c               @   sp   e  Z d  Z d Z d d d d  Z d d   Z d d	   Z d
 d   Z d d   Z d d   Z	 d d   Z
 d S)r  z;Class used by open_ftp() for cache of open FTP connections.NTc             C   sV   | |  _  | |  _ | |  _ | |  _ | |  _ | |  _ d |  _ | |  _ |  j   d  S)Nr   )	r  r  rr   r)  r  rG   refcount	keepaliveinit)r|   r  r  rr   r)  r  rG   r  rI   rI   rJ   r     s    								zftpwrapper.__init__c             C   s   d d  l  } d |  _ | j   |  _ |  j j |  j |  j |  j  |  j j |  j	 |  j
  d j |  j  } |  j j |  d  S)Nr   r   )r  busyZFTPr   Zconnectrr   r)  rG   Zloginr  r  r  r  cwd)r|   r  Z_targetrI   rI   rJ   r    s    	zftpwrapper.initc          -   C   s:  d d  l  } |  j   | d k r1 d } d } n d | } d } y |  j j |  Wn/ | j k
 r |  j   |  j j |  Yn Xd  } | r0| r0y& d | } |  j j |  \ } } Wq0| j k
 r,} zG t |  d  d  d	 k rt	 d
 |  j
 t j   d   n  WYd  d  } ~ Xq0Xn  | s|  j j d  | r|  j j   }	 zV y |  j j |  Wn; | j k
 r} z t	 d
 |  |  WYd  d  } ~ Xn XWd  |  j j |	  Xd | } n d } |  j j |  \ } } n  d |  _ t | j d  |  j  }
 |  j d 7_ | j   |
 | f S)Nr   rf  r  zTYPE ArN   zTYPE zRETR r9   Z550zftp error: %rr   zLIST ZLISTr  )rf  r  )r  endtransferr   Zvoidcmdr  r  ZntransfercmdZ
error_permr   r   r  r  r  pwdr  r  r   Zmakefile
file_closer  r   )r|   rK   r   r  cmdisdirr  r  ru  r  ZftpobjrI   rI   rJ   r    sN    
  	
 

,*	
zftpwrapper.retrfilec             C   s   d |  _  d  S)Nr   )r  )r|   rI   rI   rJ   r    s    zftpwrapper.endtransferc             C   s)   d |  _  |  j d k r% |  j   n  d  S)NFr   )r  r  
real_close)r|   rI   rI   rJ   r     s    	zftpwrapper.closec             C   sC   |  j    |  j d 8_ |  j d k r? |  j r? |  j   n  d  S)NrN   r   )r  r  r  r   )r|   rI   rI   rJ   r    s    
zftpwrapper.file_closec             C   s7   |  j    y |  j j   Wn t   k
 r2 Yn Xd  S)N)r  r   r   r  )r|   rI   rI   rJ   r   	  s
    
zftpwrapper.real_close)r   r   r   r   r   r  r  r  r   r  r   rI   rI   rI   rJ   r    s   	-r  c              C   si   i  }  x\ t  j j   D]K \ } } | j   } | r | d d  d k r | |  | d d  <q q W|  S)a  Return a dictionary of scheme -> proxy server URL mappings.

    Scan the environment for variables named <scheme>_proxy;
    this seems to be the standard convention.  If you need a
    different way, you can pass a proxies dictionary to the
    [Fancy]URLopener constructor.

       N_proxyii)rS   environrw   rp   )r  rW   r~   rI   rI   rJ   getproxies_environment		  s    	r$  c             C   s   t  j j d d  p' t  j j d d  } | d k r: d St |   \ } } d d   | j d  D } x6 | D]. } | ro | j |  s |  j |  ro d Sqo Wd	 S)
zTest if proxies should not be used for a particular host.

    Checks the environment for a variable named no_proxy, which should
    be a list of DNS suffixes separated by commas, or '*' for all hosts.
    no_proxyrj   ZNO_PROXY*rN   c             S   s   g  |  ] } | j     q SrI   )r  )r   r  rI   rI   rJ   r   &	  s   	 z,proxy_bypass_environment.<locals>.<listcomp>r  r   )rS   r#  r   r   r1  r  )rr   r%  hostonlyr)  Zno_proxy_listrW   rI   rI   rJ   proxy_bypass_environment	  s    *$r(  c             C   s  d d l  m  } t |   \ } } d d   } d |  k rK | d rK d Sn  d } x+| j d	 f   D]} | sv qd n  t j d
 |  } | d k	 rh| d k r y t j |  } | |  } Wq t k
 r wd Yq Xn  | | j d   }	 | j d  }
 |
 d k r-d | j d  j	 d  d }
 n t
 |
 d d   }
 d |
 }
 | |
 ?|	 |
 ?k r{d Sqd | |  |  rd d Sqd Wd S)aj  
    Return True iff this host shouldn't be accessed using a proxy

    This function uses the MacOSX framework SystemConfiguration
    to fetch the proxy information.

    proxy_settings come from _scproxy._get_proxy_settings or get mocked ie:
    { 'exclude_simple': bool,
      'exceptions': ['foo.bar', '*.bar.com', '127.0.0.1', '10.1', '10.0/16']
    }
    r   )fnmatchc             S   s   |  j  d  } t t t |   } t |  d k rY | d d d d g d  d  } n  | d d >| d d >B| d d >B| d	 BS)
N.r   r      rN   rQ  r   rM   r9   )r1  r   r  rZ   r\   )ZipAddrr(  rI   rI   rJ   ip2num@	  s
    #z,_proxy_bypass_macosx_sysconf.<locals>.ip2numr*  Zexclude_simpleTN
exceptionsz(\d+(?:\.\d+)*)(/\d+)?rN   r   rM       F)r)  r   r   r?  r  r   r  ri   groupcountrZ   )rr   proxy_settingsr)  r'  r)  r,  ZhostIPr~   r   r,  maskrI   rI   rJ   _proxy_bypass_macosx_sysconf0	  s:    
 #
r3  darwin)_get_proxy_settings_get_proxiesc             C   s   t    } t |  |  S)N)r5  r3  )rr   r1  rI   rI   rJ   proxy_bypass_macosx_sysconfo	  s    	r7  c               C   s   t    S)zReturn a dictionary of scheme -> proxy server URL mappings.

        This function uses the MacOSX framework SystemConfiguration
        to fetch the proxy information.
        )r6  rI   rI   rI   rJ   getproxies_macosx_sysconfs	  s    r8  c             C   s!   t    r t |   St |   Sd  S)N)r$  r(  r7  )rr   rI   rI   rJ   r  }	  s    	
r  c               C   s   t    p t   S)N)r$  r8  rI   rI   rI   rJ   r4   	  s    c              C   sl  i  }  y d d l  } Wn t k
 r. |  SYn Xy| j | j d  } | j | d  d } | r?t | j | d  d  } d | k r x | j d  D]M } | j d d  \ } } t j d	 |  s d
 | | f } n  | |  | <q Wq?| d d  d k r| |  d <q?d | |  d <d | |  d <d | |  d <n  | j	   Wn t
 t t f k
 rgYn X|  S)zxReturn a dictionary of scheme -> proxy server URL mappings.

        Win32 uses the registry to store proxies.

        r   Nz;Software\Microsoft\Windows\CurrentVersion\Internet SettingsProxyEnableZProxyServerr  r  rN   z^([^/:]+)://z%s://%srI  zhttp:r   z	http://%sz
https://%sr   zftp://%sr   )winregImportErrorOpenKeyHKEY_CURRENT_USERQueryValueExr   r1  r?  r  ZCloseri   r@   r   )r  r:  internetSettingsproxyEnableZproxyServerpr   ZaddressrI   rI   rJ   getproxies_registry	  s6    		rB  c               C   s   t    p t   S)zReturn a dictionary of scheme -> proxy server URL mappings.

        Returns settings gathered from the environment, if specified,
        or the registry.

        )r$  rB  rI   rI   rI   rJ   r4   	  s    c          &   C   s  y d d  l  } Wn t k
 r( d SYn XyK | j | j d  } | j | d  d } t | j | d  d  } Wn t k
 r d SYn X| s | r d St |   \ } } | g }  y/ t j	 |  } | | k r |  j
 |  n  Wn t k
 r Yn Xy/ t j |  } | | k r,|  j
 |  n  Wn t k
 rAYn X| j d  } x | D] }	 |	 d k r}d | k r}d Sn  |	 j d d	  }	 |	 j d
 d  }	 |	 j d d  }	 x* |  D]" }
 t j |	 |
 t j  rd SqWqXWd S)Nr   z;Software\Microsoft\Windows\CurrentVersion\Internet Settingsr9  ZProxyOverrider  z<local>r*  rN   z\.r&  z.*?)r:  r;  r<  r=  r>  r   ri   r   r   r  rY   Zgetfqdnr1  r   r?  r  rA  )rr   r:  r?  r@  ZproxyOverrideZrawHostr)  ZaddrZfqdnr-  r   rI   rI   rJ   proxy_bypass_registry	  sP    				rD  c             C   s!   t    r t |   St |   Sd S)zReturn a dictionary of scheme -> proxy server URL mappings.

        Returns settings gathered from the environment, if specified,
        or the registry.

        N)r$  r(  rD  )rr   rI   rI   rJ   r  	  s    	
)}r   r  r   r  rT  Zhttp.clientr   r  rS   r*  r?  r   r  rR  rn  rV   rP   r5  Zurllib.errorr   r   r   Zurllib.parser   r   r   r   r	   r
   r   r   r   r   r   r   r   r   r   r   r   r   Zurllib.responser   r   rA   r;  r?   __all__r  r   rC   r   r/   r0   rX   r5   r6   r@  ASCIIrn   rs   r   r   r1   r   r.   r   r   r  r   r    r!   r"   r#   r$   urandomrS  r%   r&   r'   rh  r(   r   r   rB   rY   r   r-   rK  rM  r)   r  r*   r+   r,   r  rW   Z
nturl2pathr3   r2   r  r7   r8   r  r  r  r  r  r  r  r  r  r$  r(  r3  platformZ_scproxyr5  r6  r7  r8  r  r4   rB  rD  rI   rI   rI   rJ   <module>D   s   v					?n$h*@
7	q
+4:5! 

[<
-	2                                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/python3.4/urllib/__pycache__/response.cpython-34.pyc                                        0100644 0000000 0000000 00000006431 13077704336 022373  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s   d  Z  d d l Z d d d d g Z Gd d   d e j  Z Gd d   d e  Z Gd	 d   d e  Z Gd
 d   d e  Z d S)a  Response classes used by urllib.

The base class, addbase, defines a minimal file-like interface,
including read() and readline().  The typical response object is an
addinfourl instance, which defines an info() method that returns
headers and a geturl() method that returns the url.
    Naddbaseaddclosehookaddinfo
addinfourlc                   sL   e  Z d  Z d Z   f d d   Z d d   Z d d   Z d d	   Z   S)
r   zOBase class for addinfo and addclosehook. Is a good idea for garbage collection.c                s,   t  t |   j | d d d | |  _ d  S)Nz<urllib response>ZdeleteF)superr   __init__fp)selfr   )	__class__ %/usr/lib/python3.4/urllib/response.pyr      s    zaddbase.__init__c             C   s    d |  j  j t |   |  j f S)Nz<%s at %r whose fp = %r>)r
   __name__idfile)r	   r   r   r   __repr__   s    zaddbase.__repr__c             C   s   |  j  j r t d   n  |  S)NzI/O operation on closed file)r   closed
ValueError)r	   r   r   r   	__enter__   s    zaddbase.__enter__c             C   s   |  j    d  S)N)close)r	   typevalue	tracebackr   r   r   __exit__!   s    zaddbase.__exit__)r   
__module____qualname____doc__r   r   r   r   r   r   )r
   r   r      s
   c                   s:   e  Z d  Z d Z   f d d   Z   f d d   Z   S)r   z*Class to add a close hook to an open file.c                s,   t  t |   j |  | |  _ | |  _ d  S)N)r   r   r   	closehookhookargs)r	   r   r   r   )r
   r   r   r   (   s    	zaddclosehook.__init__c                sE   |  j  r. |  j  |  j   d  |  _  d  |  _ n  t t |   j   d  S)N)r   r   r   r   r   )r	   )r
   r   r   r   -   s
    		zaddclosehook.close)r   r   r   r   r   r   r   r   )r
   r   r   %   s   c                   s4   e  Z d  Z d Z   f d d   Z d d   Z   S)r   z.class to add an info() method to an open file.c                s#   t  t |   j |  | |  _ d  S)N)r   r   r   headers)r	   r   r   )r
   r   r   r   8   s    zaddinfo.__init__c             C   s   |  j  S)N)r   )r	   r   r   r   info<   s    zaddinfo.info)r   r   r   r   r   r   r   r   )r
   r   r   5   s   c                   sC   e  Z d  Z d Z d   f d d  Z d d   Z d d   Z   S)	r   z9class to add info() and geturl() methods to an open file.Nc                s/   t  t |   j | |  | |  _ | |  _ d  S)N)r   r   r   urlcode)r	   r   r   r    r!   )r
   r   r   r   C   s    	zaddinfourl.__init__c             C   s   |  j  S)N)r!   )r	   r   r   r   getcodeH   s    zaddinfourl.getcodec             C   s   |  j  S)N)r    )r	   r   r   r   geturlK   s    zaddinfourl.geturl)r   r   r   r   r   r"   r#   r   r   )r
   r   r   @   s   )r   Ztempfile__all__Z_TemporaryFileWrapperr   r   r   r   r   r   r   r   <module>   s                                                                                                                                                                                                                                          usr/lib/python3.4/urllib/__pycache__/robotparser.cpython-34.pyc                                     0100644 0000000 0000000 00000015124 13077704336 023076  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T4                 @   sd   d  Z  d d l Z d d l Z d g Z Gd d   d  Z Gd d   d  Z Gd d   d  Z d S)	a%   robotparser.py

    Copyright (C) 2000  Bastian Kleineidam

    You can choose between two licenses when using this package:
    1) GNU GPLv2
    2) PSF license for Python 2.2

    The robots.txt Exclusion Protocol is implemented as specified in
    http://www.robotstxt.org/norobots-rfc.txt
    NRobotFileParserc               @   s   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d S)r   zs This class provides a set of methods to read, parse and answer
    questions about a single robots.txt file.

     c             C   s>   g  |  _  d  |  _ d |  _ d |  _ |  j |  d |  _ d  S)NFr   )entriesdefault_entrydisallow_all	allow_allset_urllast_checked)selfurl r   (/usr/lib/python3.4/urllib/robotparser.py__init__   s    				zRobotFileParser.__init__c             C   s   |  j  S)zReturns the time the robots.txt file was last fetched.

        This is useful for long-running web spiders that need to
        check for new robots.txt files periodically.

        )r	   )r
   r   r   r   mtime   s    zRobotFileParser.mtimec             C   s   d d l  } | j    |  _ d S)zYSets the time the robots.txt file was last fetched to the
        current time.

        r   N)timer	   )r
   r   r   r   r   modified(   s    zRobotFileParser.modifiedc             C   s5   | |  _  t j j |  d d  \ |  _ |  _ d S)z,Sets the URL referring to a robots.txt file.      N)r   urllibparseurlparseZhostpath)r
   r   r   r   r   r   0   s    	zRobotFileParser.set_urlc             C   s   y t  j j |  j  } Wnp t  j j k
 r } zJ | j d k rO d |  _ n* | j d k ry | j d k  ry d |  _ n  WYd d } ~ Xn) X| j	   } |  j
 | j d  j    d S)	z4Reads the robots.txt URL and feeds it to the parser.    Ti  i  Nzutf-8)r   r   )r   ZrequestZurlopenr   errorZ	HTTPErrorcoder   r   readr   decode
splitlines)r
   ferrrawr   r   r   r   5   s    zRobotFileParser.readc             C   sA   d | j  k r- |  j d  k r= | |  _ q= n |  j j |  d  S)N*)
useragentsr   r   append)r
   entryr   r   r   
_add_entryB   s    zRobotFileParser._add_entryc             C   s  d } t    } |  j   x| D]} | sx | d k rJ t    } d } qx | d k rx |  j |  t    } d } qx n  | j d  } | d k r | d |  } n  | j   } | s q  n  | j d d  } t |  d k r  | d j   j   | d <t j	 j
 | d j    | d <| d d k rn| d k rQ|  j |  t    } n  | j j | d  d } q| d d k r| d k r| j j t | d d	   d } qq| d d
 k r| d k r| j j t | d d   d } qqq  q  W| d k r|  j |  n  d S)zParse the input lines from a robots.txt file.

        We allow that a user-agent: line is not preceded by
        one or more blank lines.
        r   r      #N:z
user-agentZdisallowFZallowT)Entryr   r&   findstripsplitlenlowerr   r   unquoter#   r$   	rulelinesRuleLine)r
   linesstater%   lineir   r   r   r   K   sL    
	
			 	zRobotFileParser.parsec             C   s   |  j  r d S|  j r d S|  j s' d St j j t j j |   } t j j d d | j | j	 | j
 | j f  } t j j |  } | s d } n  x- |  j D]" } | j |  r | j |  Sq W|  j r |  j j |  Sd S)z=using the parsed robots.txt decide if useragent can fetch urlFTr   /)r   r   r	   r   r   r   r0   
urlunparser   ZparamsZqueryZfragmentquoter   
applies_to	allowancer   )r
   	useragentr   Z
parsed_urlr%   r   r   r   	can_fetch   s$    					zRobotFileParser.can_fetchc             C   s   d j  d d   |  j D  S)Nr   c             S   s    g  |  ] } t  |  d   q S)
)str).0r%   r   r   r   
<listcomp>   s   	 z+RobotFileParser.__str__.<locals>.<listcomp>)joinr   )r
   r   r   r   __str__   s    zRobotFileParser.__str__N)__name__
__module____qualname____doc__r   r   r   r   r   r&   r   r=   rC   r   r   r   r   r      s   		4c               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	r2   zoA rule line is a single "Allow:" (allowance==True) or "Disallow:"
       (allowance==False) followed by a path.c             C   s\   | d k r | r d } n  t  j j t  j j |   } t  j j |  |  _ | |  _ d  S)Nr   T)r   r   r8   r   r9   r   r;   )r
   r   r;   r   r   r   r      s
    	zRuleLine.__init__c             C   s   |  j  d k p | j |  j   S)Nr"   )r   
startswith)r
   filenamer   r   r   r:      s    zRuleLine.applies_toc             C   s   |  j  r d p d d |  j S)NZAllowZDisallowz: )r;   r   )r
   r   r   r   rC      s    zRuleLine.__str__N)rD   rE   rF   rG   r   r:   rC   r   r   r   r   r2      s   r2   c               @   sF   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 S)r*   z?An entry has one or more user-agents and zero or more rulelinesc             C   s   g  |  _  g  |  _ d  S)N)r#   r1   )r
   r   r   r   r      s    	zEntry.__init__c             C   sj   g  } x' |  j  D] } | j d | d g  q Wx* |  j D] } | j t |  d g  q: Wd j |  S)NzUser-agent: r>   r   )r#   extendr1   r?   rB   )r
   Zretagentr5   r   r   r   rC      s    zEntry.__str__c             C   s]   | j  d  d j   } x= |  j D]2 } | d k r9 d S| j   } | | k r# d Sq# Wd S)z2check if this entry applies to the specified agentr7   r   r"   TF)r-   r/   r#   )r
   r<   rK   r   r   r   r:      s    zEntry.applies_toc             C   s.   x' |  j  D] } | j |  r
 | j Sq
 Wd S)zZPreconditions:
        - our agent applies to this entry
        - filename is URL decodedT)r1   r:   r;   )r
   rI   r5   r   r   r   r;      s    zEntry.allowanceN)rD   rE   rF   rG   r   rC   r:   r;   r   r   r   r   r*      s
   r*   )rG   Zurllib.parser   Zurllib.request__all__r   r2   r*   r   r   r   r   <module>   s
   	                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/python3.4/urllib/error.py                                                                   0100644 0000000 0000000 00000005153 12415221640 015367  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Exception classes raised by urllib.

The base exception class is URLError, which inherits from OSError.  It
doesn't define any behavior of its own, but is the base class for all
exceptions defined in this package.

HTTPError is an exception class that is also a valid HTTP response
instance.  It behaves this way because HTTP protocol errors are valid
responses, with a status code, headers, and a body.  In some contexts,
an application may want to handle an exception like a regular
response.
"""

import urllib.response

__all__ = ['URLError', 'HTTPError', 'ContentTooShortError']


# do these error classes make sense?
# make sure all of the OSError stuff is overridden.  we just want to be
# subtypes.

class URLError(OSError):
    # URLError is a sub-type of OSError, but it doesn't share any of
    # the implementation.  need to override __init__ and __str__.
    # It sets self.args for compatibility with other EnvironmentError
    # subclasses, but args doesn't have the typical format with errno in
    # slot 0 and strerror in slot 1.  This may be better than nothing.
    def __init__(self, reason, filename=None):
        self.args = reason,
        self.reason = reason
        if filename is not None:
            self.filename = filename

    def __str__(self):
        return '<urlopen error %s>' % self.reason

class HTTPError(URLError, urllib.response.addinfourl):
    """Raised when HTTP error occurs, but also acts like non-error return"""
    __super_init = urllib.response.addinfourl.__init__

    def __init__(self, url, code, msg, hdrs, fp):
        self.code = code
        self.msg = msg
        self.hdrs = hdrs
        self.fp = fp
        self.filename = url
        # The addinfourl classes depend on fp being a valid file
        # object.  In some cases, the HTTPError may not have a valid
        # file object.  If this happens, the simplest workaround is to
        # not initialize the base classes.
        if fp is not None:
            self.__super_init(fp, hdrs, url, code)

    def __str__(self):
        return 'HTTP Error %s: %s' % (self.code, self.msg)

    # since URLError specifies a .reason attribute, HTTPError should also
    #  provide this attribute. See issue13211 for discussion.
    @property
    def reason(self):
        return self.msg

    @property
    def headers(self):
        return self.hdrs

    @headers.setter
    def headers(self, headers):
        self.hdrs = headers

# exception raised when downloaded size does not match content-length
class ContentTooShortError(URLError):
    def __init__(self, message, content):
        URLError.__init__(self, message)
        self.content = content
                                                                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python3.4/urllib/parse.py                                                                   0100644 0000000 0000000 00000104624 12415221640 015353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Parse (absolute and relative) URLs.

urlparse module is based upon the following RFC specifications.

RFC 3986 (STD66): "Uniform Resource Identifiers" by T. Berners-Lee, R. Fielding
and L.  Masinter, January 2005.

RFC 2732 : "Format for Literal IPv6 Addresses in URL's by R.Hinden, B.Carpenter
and L.Masinter, December 1999.

RFC 2396:  "Uniform Resource Identifiers (URI)": Generic Syntax by T.
Berners-Lee, R. Fielding, and L. Masinter, August 1998.

RFC 2368: "The mailto URL scheme", by P.Hoffman , L Masinter, J. Zawinski, July 1998.

RFC 1808: "Relative Uniform Resource Locators", by R. Fielding, UC Irvine, June
1995.

RFC 1738: "Uniform Resource Locators (URL)" by T. Berners-Lee, L. Masinter, M.
McCahill, December 1994

RFC 3986 is considered the current standard and any future changes to
urlparse module should conform with it.  The urlparse module is
currently not entirely compliant with this RFC due to defacto
scenarios for parsing, and for backward compatibility purposes, some
parsing quirks from older RFCs are retained. The testcases in
test_urlparse.py provides a good indicator of parsing behavior.
"""

import re
import sys
import collections

__all__ = ["urlparse", "urlunparse", "urljoin", "urldefrag",
           "urlsplit", "urlunsplit", "urlencode", "parse_qs",
           "parse_qsl", "quote", "quote_plus", "quote_from_bytes",
           "unquote", "unquote_plus", "unquote_to_bytes"]

# A classification of schemes ('' means apply by default)
uses_relative = ['ftp', 'http', 'gopher', 'nntp', 'imap',
                 'wais', 'file', 'https', 'shttp', 'mms',
                 'prospero', 'rtsp', 'rtspu', '', 'sftp',
                 'svn', 'svn+ssh']
uses_netloc = ['ftp', 'http', 'gopher', 'nntp', 'telnet',
               'imap', 'wais', 'file', 'mms', 'https', 'shttp',
               'snews', 'prospero', 'rtsp', 'rtspu', 'rsync', '',
               'svn', 'svn+ssh', 'sftp', 'nfs', 'git', 'git+ssh']
uses_params = ['ftp', 'hdl', 'prospero', 'http', 'imap',
               'https', 'shttp', 'rtsp', 'rtspu', 'sip', 'sips',
               'mms', '', 'sftp', 'tel']

# These are not actually used anymore, but should stay for backwards
# compatibility.  (They are undocumented, but have a public-looking name.)
non_hierarchical = ['gopher', 'hdl', 'mailto', 'news',
                    'telnet', 'wais', 'imap', 'snews', 'sip', 'sips']
uses_query = ['http', 'wais', 'imap', 'https', 'shttp', 'mms',
              'gopher', 'rtsp', 'rtspu', 'sip', 'sips', '']
uses_fragment = ['ftp', 'hdl', 'http', 'gopher', 'news',
                 'nntp', 'wais', 'https', 'shttp', 'snews',
                 'file', 'prospero', '']

# Characters valid in scheme names
scheme_chars = ('abcdefghijklmnopqrstuvwxyz'
                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                '0123456789'
                '+-.')

# XXX: Consider replacing with functools.lru_cache
MAX_CACHE_SIZE = 20
_parse_cache = {}

def clear_cache():
    """Clear the parse cache and the quoters cache."""
    _parse_cache.clear()
    _safe_quoters.clear()


# Helpers for bytes handling
# For 3.2, we deliberately require applications that
# handle improperly quoted URLs to do their own
# decoding and encoding. If valid use cases are
# presented, we may relax this by using latin-1
# decoding internally for 3.3
_implicit_encoding = 'ascii'
_implicit_errors = 'strict'

def _noop(obj):
    return obj

def _encode_result(obj, encoding=_implicit_encoding,
                        errors=_implicit_errors):
    return obj.encode(encoding, errors)

def _decode_args(args, encoding=_implicit_encoding,
                       errors=_implicit_errors):
    return tuple(x.decode(encoding, errors) if x else '' for x in args)

def _coerce_args(*args):
    # Invokes decode if necessary to create str args
    # and returns the coerced inputs along with
    # an appropriate result coercion function
    #   - noop for str inputs
    #   - encoding function otherwise
    str_input = isinstance(args[0], str)
    for arg in args[1:]:
        # We special-case the empty string to support the
        # "scheme=''" default argument to some functions
        if arg and isinstance(arg, str) != str_input:
            raise TypeError("Cannot mix str and non-str arguments")
    if str_input:
        return args + (_noop,)
    return _decode_args(args) + (_encode_result,)

# Result objects are more helpful than simple tuples
class _ResultMixinStr(object):
    """Standard approach to encoding parsed results from str to bytes"""
    __slots__ = ()

    def encode(self, encoding='ascii', errors='strict'):
        return self._encoded_counterpart(*(x.encode(encoding, errors) for x in self))


class _ResultMixinBytes(object):
    """Standard approach to decoding parsed results from bytes to str"""
    __slots__ = ()

    def decode(self, encoding='ascii', errors='strict'):
        return self._decoded_counterpart(*(x.decode(encoding, errors) for x in self))


class _NetlocResultMixinBase(object):
    """Shared methods for the parsed result objects containing a netloc element"""
    __slots__ = ()

    @property
    def username(self):
        return self._userinfo[0]

    @property
    def password(self):
        return self._userinfo[1]

    @property
    def hostname(self):
        hostname = self._hostinfo[0]
        if not hostname:
            hostname = None
        elif hostname is not None:
            hostname = hostname.lower()
        return hostname

    @property
    def port(self):
        port = self._hostinfo[1]
        if port is not None:
            port = int(port, 10)
            # Return None on an illegal port
            if not ( 0 <= port <= 65535):
                return None
        return port


class _NetlocResultMixinStr(_NetlocResultMixinBase, _ResultMixinStr):
    __slots__ = ()

    @property
    def _userinfo(self):
        netloc = self.netloc
        userinfo, have_info, hostinfo = netloc.rpartition('@')
        if have_info:
            username, have_password, password = userinfo.partition(':')
            if not have_password:
                password = None
        else:
            username = password = None
        return username, password

    @property
    def _hostinfo(self):
        netloc = self.netloc
        _, _, hostinfo = netloc.rpartition('@')
        _, have_open_br, bracketed = hostinfo.partition('[')
        if have_open_br:
            hostname, _, port = bracketed.partition(']')
            _, _, port = port.partition(':')
        else:
            hostname, _, port = hostinfo.partition(':')
        if not port:
            port = None
        return hostname, port


class _NetlocResultMixinBytes(_NetlocResultMixinBase, _ResultMixinBytes):
    __slots__ = ()

    @property
    def _userinfo(self):
        netloc = self.netloc
        userinfo, have_info, hostinfo = netloc.rpartition(b'@')
        if have_info:
            username, have_password, password = userinfo.partition(b':')
            if not have_password:
                password = None
        else:
            username = password = None
        return username, password

    @property
    def _hostinfo(self):
        netloc = self.netloc
        _, _, hostinfo = netloc.rpartition(b'@')
        _, have_open_br, bracketed = hostinfo.partition(b'[')
        if have_open_br:
            hostname, _, port = bracketed.partition(b']')
            _, _, port = port.partition(b':')
        else:
            hostname, _, port = hostinfo.partition(b':')
        if not port:
            port = None
        return hostname, port


from collections import namedtuple

_DefragResultBase = namedtuple('DefragResult', 'url fragment')
_SplitResultBase = namedtuple('SplitResult', 'scheme netloc path query fragment')
_ParseResultBase = namedtuple('ParseResult', 'scheme netloc path params query fragment')

# For backwards compatibility, alias _NetlocResultMixinStr
# ResultBase is no longer part of the documented API, but it is
# retained since deprecating it isn't worth the hassle
ResultBase = _NetlocResultMixinStr

# Structured result objects for string data
class DefragResult(_DefragResultBase, _ResultMixinStr):
    __slots__ = ()
    def geturl(self):
        if self.fragment:
            return self.url + '#' + self.fragment
        else:
            return self.url

class SplitResult(_SplitResultBase, _NetlocResultMixinStr):
    __slots__ = ()
    def geturl(self):
        return urlunsplit(self)

class ParseResult(_ParseResultBase, _NetlocResultMixinStr):
    __slots__ = ()
    def geturl(self):
        return urlunparse(self)

# Structured result objects for bytes data
class DefragResultBytes(_DefragResultBase, _ResultMixinBytes):
    __slots__ = ()
    def geturl(self):
        if self.fragment:
            return self.url + b'#' + self.fragment
        else:
            return self.url

class SplitResultBytes(_SplitResultBase, _NetlocResultMixinBytes):
    __slots__ = ()
    def geturl(self):
        return urlunsplit(self)

class ParseResultBytes(_ParseResultBase, _NetlocResultMixinBytes):
    __slots__ = ()
    def geturl(self):
        return urlunparse(self)

# Set up the encode/decode result pairs
def _fix_result_transcoding():
    _result_pairs = (
        (DefragResult, DefragResultBytes),
        (SplitResult, SplitResultBytes),
        (ParseResult, ParseResultBytes),
    )
    for _decoded, _encoded in _result_pairs:
        _decoded._encoded_counterpart = _encoded
        _encoded._decoded_counterpart = _decoded

_fix_result_transcoding()
del _fix_result_transcoding

def urlparse(url, scheme='', allow_fragments=True):
    """Parse a URL into 6 components:
    <scheme>://<netloc>/<path>;<params>?<query>#<fragment>
    Return a 6-tuple: (scheme, netloc, path, params, query, fragment).
    Note that we don't break the components up in smaller bits
    (e.g. netloc is a single string) and we don't expand % escapes."""
    url, scheme, _coerce_result = _coerce_args(url, scheme)
    splitresult = urlsplit(url, scheme, allow_fragments)
    scheme, netloc, url, query, fragment = splitresult
    if scheme in uses_params and ';' in url:
        url, params = _splitparams(url)
    else:
        params = ''
    result = ParseResult(scheme, netloc, url, params, query, fragment)
    return _coerce_result(result)

def _splitparams(url):
    if '/'  in url:
        i = url.find(';', url.rfind('/'))
        if i < 0:
            return url, ''
    else:
        i = url.find(';')
    return url[:i], url[i+1:]

def _splitnetloc(url, start=0):
    delim = len(url)   # position of end of domain part of url, default is end
    for c in '/?#':    # look for delimiters; the order is NOT important
        wdelim = url.find(c, start)        # find first of this delim
        if wdelim >= 0:                    # if found
            delim = min(delim, wdelim)     # use earliest delim position
    return url[start:delim], url[delim:]   # return (domain, rest)

def urlsplit(url, scheme='', allow_fragments=True):
    """Parse a URL into 5 components:
    <scheme>://<netloc>/<path>?<query>#<fragment>
    Return a 5-tuple: (scheme, netloc, path, query, fragment).
    Note that we don't break the components up in smaller bits
    (e.g. netloc is a single string) and we don't expand % escapes."""
    url, scheme, _coerce_result = _coerce_args(url, scheme)
    allow_fragments = bool(allow_fragments)
    key = url, scheme, allow_fragments, type(url), type(scheme)
    cached = _parse_cache.get(key, None)
    if cached:
        return _coerce_result(cached)
    if len(_parse_cache) >= MAX_CACHE_SIZE: # avoid runaway growth
        clear_cache()
    netloc = query = fragment = ''
    i = url.find(':')
    if i > 0:
        if url[:i] == 'http': # optimize the common case
            scheme = url[:i].lower()
            url = url[i+1:]
            if url[:2] == '//':
                netloc, url = _splitnetloc(url, 2)
                if (('[' in netloc and ']' not in netloc) or
                        (']' in netloc and '[' not in netloc)):
                    raise ValueError("Invalid IPv6 URL")
            if allow_fragments and '#' in url:
                url, fragment = url.split('#', 1)
            if '?' in url:
                url, query = url.split('?', 1)
            v = SplitResult(scheme, netloc, url, query, fragment)
            _parse_cache[key] = v
            return _coerce_result(v)
        for c in url[:i]:
            if c not in scheme_chars:
                break
        else:
            # make sure "url" is not actually a port number (in which case
            # "scheme" is really part of the path)
            rest = url[i+1:]
            if not rest or any(c not in '0123456789' for c in rest):
                # not a port number
                scheme, url = url[:i].lower(), rest

    if url[:2] == '//':
        netloc, url = _splitnetloc(url, 2)
        if (('[' in netloc and ']' not in netloc) or
                (']' in netloc and '[' not in netloc)):
            raise ValueError("Invalid IPv6 URL")
    if allow_fragments and '#' in url:
        url, fragment = url.split('#', 1)
    if '?' in url:
        url, query = url.split('?', 1)
    v = SplitResult(scheme, netloc, url, query, fragment)
    _parse_cache[key] = v
    return _coerce_result(v)

def urlunparse(components):
    """Put a parsed URL back together again.  This may result in a
    slightly different, but equivalent URL, if the URL that was parsed
    originally had redundant delimiters, e.g. a ? with an empty query
    (the draft states that these are equivalent)."""
    scheme, netloc, url, params, query, fragment, _coerce_result = (
                                                  _coerce_args(*components))
    if params:
        url = "%s;%s" % (url, params)
    return _coerce_result(urlunsplit((scheme, netloc, url, query, fragment)))

def urlunsplit(components):
    """Combine the elements of a tuple as returned by urlsplit() into a
    complete URL as a string. The data argument can be any five-item iterable.
    This may result in a slightly different, but equivalent URL, if the URL that
    was parsed originally had unnecessary delimiters (for example, a ? with an
    empty query; the RFC states that these are equivalent)."""
    scheme, netloc, url, query, fragment, _coerce_result = (
                                          _coerce_args(*components))
    if netloc or (scheme and scheme in uses_netloc and url[:2] != '//'):
        if url and url[:1] != '/': url = '/' + url
        url = '//' + (netloc or '') + url
    if scheme:
        url = scheme + ':' + url
    if query:
        url = url + '?' + query
    if fragment:
        url = url + '#' + fragment
    return _coerce_result(url)

def urljoin(base, url, allow_fragments=True):
    """Join a base URL and a possibly relative URL to form an absolute
    interpretation of the latter."""
    if not base:
        return url
    if not url:
        return base
    base, url, _coerce_result = _coerce_args(base, url)
    bscheme, bnetloc, bpath, bparams, bquery, bfragment = \
            urlparse(base, '', allow_fragments)
    scheme, netloc, path, params, query, fragment = \
            urlparse(url, bscheme, allow_fragments)
    if scheme != bscheme or scheme not in uses_relative:
        return _coerce_result(url)
    if scheme in uses_netloc:
        if netloc:
            return _coerce_result(urlunparse((scheme, netloc, path,
                                              params, query, fragment)))
        netloc = bnetloc
    if path[:1] == '/':
        return _coerce_result(urlunparse((scheme, netloc, path,
                                          params, query, fragment)))
    if not path and not params:
        path = bpath
        params = bparams
        if not query:
            query = bquery
        return _coerce_result(urlunparse((scheme, netloc, path,
                                          params, query, fragment)))
    segments = bpath.split('/')[:-1] + path.split('/')
    # XXX The stuff below is bogus in various ways...
    if segments[-1] == '.':
        segments[-1] = ''
    while '.' in segments:
        segments.remove('.')
    while 1:
        i = 1
        n = len(segments) - 1
        while i < n:
            if (segments[i] == '..'
                and segments[i-1] not in ('', '..')):
                del segments[i-1:i+1]
                break
            i = i+1
        else:
            break
    if segments == ['', '..']:
        segments[-1] = ''
    elif len(segments) >= 2 and segments[-1] == '..':
        segments[-2:] = ['']
    return _coerce_result(urlunparse((scheme, netloc, '/'.join(segments),
                                      params, query, fragment)))

def urldefrag(url):
    """Removes any existing fragment from URL.

    Returns a tuple of the defragmented URL and the fragment.  If
    the URL contained no fragments, the second element is the
    empty string.
    """
    url, _coerce_result = _coerce_args(url)
    if '#' in url:
        s, n, p, a, q, frag = urlparse(url)
        defrag = urlunparse((s, n, p, a, q, ''))
    else:
        frag = ''
        defrag = url
    return _coerce_result(DefragResult(defrag, frag))

_hexdig = '0123456789ABCDEFabcdef'
_hextobyte = None

def unquote_to_bytes(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    res = [bits[0]]
    append = res.append
    # Delay the initialization of the table to not waste memory
    # if the function is never called
    global _hextobyte
    if _hextobyte is None:
        _hextobyte = {(a + b).encode(): bytes([int(a + b, 16)])
                      for a in _hexdig for b in _hexdig}
    for item in bits[1:]:
        try:
            append(_hextobyte[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)

_asciire = re.compile('([\x00-\x7f]+)')

def unquote(string, encoding='utf-8', errors='replace'):
    """Replace %xx escapes by their single-character equivalent. The optional
    encoding and errors parameters specify how to decode percent-encoded
    sequences into Unicode characters, as accepted by the bytes.decode()
    method.
    By default, percent-encoded sequences are decoded with UTF-8, and invalid
    sequences are replaced by a placeholder character.

    unquote('abc%20def') -> 'abc def'.
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _asciire.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)

def parse_qs(qs, keep_blank_values=False, strict_parsing=False,
             encoding='utf-8', errors='replace'):
    """Parse a query given as a string argument.

        Arguments:

        qs: percent-encoded query string to be parsed

        keep_blank_values: flag indicating whether blank values in
            percent-encoded queries should be treated as blank strings.
            A true value indicates that blanks should be retained as
            blank strings.  The default false value indicates that
            blank values are to be ignored and treated as if they were
            not included.

        strict_parsing: flag indicating what to do with parsing errors.
            If false (the default), errors are silently ignored.
            If true, errors raise a ValueError exception.

        encoding and errors: specify how to decode percent-encoded sequences
            into Unicode characters, as accepted by the bytes.decode() method.
    """
    parsed_result = {}
    pairs = parse_qsl(qs, keep_blank_values, strict_parsing,
                      encoding=encoding, errors=errors)
    for name, value in pairs:
        if name in parsed_result:
            parsed_result[name].append(value)
        else:
            parsed_result[name] = [value]
    return parsed_result

def parse_qsl(qs, keep_blank_values=False, strict_parsing=False,
              encoding='utf-8', errors='replace'):
    """Parse a query given as a string argument.

    Arguments:

    qs: percent-encoded query string to be parsed

    keep_blank_values: flag indicating whether blank values in
        percent-encoded queries should be treated as blank strings.  A
        true value indicates that blanks should be retained as blank
        strings.  The default false value indicates that blank values
        are to be ignored and treated as if they were  not included.

    strict_parsing: flag indicating what to do with parsing errors. If
        false (the default), errors are silently ignored. If true,
        errors raise a ValueError exception.

    encoding and errors: specify how to decode percent-encoded sequences
        into Unicode characters, as accepted by the bytes.decode() method.

    Returns a list, as G-d intended.
    """
    qs, _coerce_result = _coerce_args(qs)
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    r = []
    for name_value in pairs:
        if not name_value and not strict_parsing:
            continue
        nv = name_value.split('=', 1)
        if len(nv) != 2:
            if strict_parsing:
                raise ValueError("bad query field: %r" % (name_value,))
            # Handle case of a control-name with no equal sign
            if keep_blank_values:
                nv.append('')
            else:
                continue
        if len(nv[1]) or keep_blank_values:
            name = nv[0].replace('+', ' ')
            name = unquote(name, encoding=encoding, errors=errors)
            name = _coerce_result(name)
            value = nv[1].replace('+', ' ')
            value = unquote(value, encoding=encoding, errors=errors)
            value = _coerce_result(value)
            r.append((name, value))
    return r

def unquote_plus(string, encoding='utf-8', errors='replace'):
    """Like unquote(), but also replace plus signs by spaces, as required for
    unquoting HTML form values.

    unquote_plus('%7e/abc+def') -> '~/abc def'
    """
    string = string.replace('+', ' ')
    return unquote(string, encoding, errors)

_ALWAYS_SAFE = frozenset(b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                         b'abcdefghijklmnopqrstuvwxyz'
                         b'0123456789'
                         b'_.-')
_ALWAYS_SAFE_BYTES = bytes(_ALWAYS_SAFE)
_safe_quoters = {}

class Quoter(collections.defaultdict):
    """A mapping from bytes (in range(0,256)) to strings.

    String values are percent-encoded byte values, unless the key < 128, and
    in the "safe" set (either the specified safe set, or default set).
    """
    # Keeps a cache internally, using defaultdict, for efficiency (lookups
    # of cached keys don't call Python code at all).
    def __init__(self, safe):
        """safe: bytes object."""
        self.safe = _ALWAYS_SAFE.union(safe)

    def __repr__(self):
        # Without this, will just display as a defaultdict
        return "<Quoter %r>" % dict(self)

    def __missing__(self, b):
        # Handle a cache miss. Store quoted string in cache and return.
        res = chr(b) if b in self.safe else '%{:02X}'.format(b)
        self[b] = res
        return res

def quote(string, safe='/', encoding=None, errors=None):
    """quote('abc def') -> 'abc%20def'

    Each part of a URL, e.g. the path info, the query, etc., has a
    different set of reserved characters that must be quoted.

    RFC 2396 Uniform Resource Identifiers (URI): Generic Syntax lists
    the following reserved characters.

    reserved    = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
                  "$" | ","

    Each of these characters is reserved in some component of a URL,
    but not necessarily in all of them.

    By default, the quote function is intended for quoting the path
    section of a URL.  Thus, it will not encode '/'.  This character
    is reserved, but in typical usage the quote function is being
    called on a path where the existing slash characters are used as
    reserved characters.

    string and safe may be either str or bytes objects. encoding must
    not be specified if string is a str.

    The optional encoding and errors parameters specify how to deal with
    non-ASCII characters, as accepted by the str.encode method.
    By default, encoding='utf-8' (characters are encoded with UTF-8), and
    errors='strict' (unsupported characters raise a UnicodeEncodeError).
    """
    if isinstance(string, str):
        if not string:
            return string
        if encoding is None:
            encoding = 'utf-8'
        if errors is None:
            errors = 'strict'
        string = string.encode(encoding, errors)
    else:
        if encoding is not None:
            raise TypeError("quote() doesn't support 'encoding' for bytes")
        if errors is not None:
            raise TypeError("quote() doesn't support 'errors' for bytes")
    return quote_from_bytes(string, safe)

def quote_plus(string, safe='', encoding=None, errors=None):
    """Like quote(), but also replace ' ' with '+', as required for quoting
    HTML form values. Plus signs in the original string are escaped unless
    they are included in safe. It also does not have safe default to '/'.
    """
    # Check if ' ' in string, where string may either be a str or bytes.  If
    # there are no spaces, the regular quote will produce the right answer.
    if ((isinstance(string, str) and ' ' not in string) or
        (isinstance(string, bytes) and b' ' not in string)):
        return quote(string, safe, encoding, errors)
    if isinstance(safe, str):
        space = ' '
    else:
        space = b' '
    string = quote(string, safe + space, encoding, errors)
    return string.replace(' ', '+')

def quote_from_bytes(bs, safe='/'):
    """Like quote(), but accepts a bytes object rather than a str, and does
    not perform string-to-bytes encoding.  It always returns an ASCII string.
    quote_from_bytes(b'abc def\x3f') -> 'abc%20def%3f'
    """
    if not isinstance(bs, (bytes, bytearray)):
        raise TypeError("quote_from_bytes() expected bytes")
    if not bs:
        return ''
    if isinstance(safe, str):
        # Normalize 'safe' by converting to bytes and removing non-ASCII chars
        safe = safe.encode('ascii', 'ignore')
    else:
        safe = bytes([c for c in safe if c < 128])
    if not bs.rstrip(_ALWAYS_SAFE_BYTES + safe):
        return bs.decode()
    try:
        quoter = _safe_quoters[safe]
    except KeyError:
        _safe_quoters[safe] = quoter = Quoter(safe).__getitem__
    return ''.join([quoter(char) for char in bs])

def urlencode(query, doseq=False, safe='', encoding=None, errors=None):
    """Encode a dict or sequence of two-element tuples into a URL query string.

    If any values in the query arg are sequences and doseq is true, each
    sequence element is converted to a separate parameter.

    If the query arg is a sequence of two-element tuples, the order of the
    parameters in the output will match the order of parameters in the
    input.

    The components of a query arg may each be either a string or a bytes type.
    When a component is a string, the safe, encoding and error parameters are
    sent to the quote_plus function for encoding.
    """

    if hasattr(query, "items"):
        query = query.items()
    else:
        # It's a bother at times that strings and string-like objects are
        # sequences.
        try:
            # non-sequence items should not work with len()
            # non-empty strings will fail this
            if len(query) and not isinstance(query[0], tuple):
                raise TypeError
            # Zero-length sequences of all types will get here and succeed,
            # but that's a minor nit.  Since the original implementation
            # allowed empty dicts that type of behavior probably should be
            # preserved for consistency
        except TypeError:
            ty, va, tb = sys.exc_info()
            raise TypeError("not a valid non-string sequence "
                            "or mapping object").with_traceback(tb)

    l = []
    if not doseq:
        for k, v in query:
            if isinstance(k, bytes):
                k = quote_plus(k, safe)
            else:
                k = quote_plus(str(k), safe, encoding, errors)

            if isinstance(v, bytes):
                v = quote_plus(v, safe)
            else:
                v = quote_plus(str(v), safe, encoding, errors)
            l.append(k + '=' + v)
    else:
        for k, v in query:
            if isinstance(k, bytes):
                k = quote_plus(k, safe)
            else:
                k = quote_plus(str(k), safe, encoding, errors)

            if isinstance(v, bytes):
                v = quote_plus(v, safe)
                l.append(k + '=' + v)
            elif isinstance(v, str):
                v = quote_plus(v, safe, encoding, errors)
                l.append(k + '=' + v)
            else:
                try:
                    # Is this a sufficient test for sequence-ness?
                    x = len(v)
                except TypeError:
                    # not a sequence
                    v = quote_plus(str(v), safe, encoding, errors)
                    l.append(k + '=' + v)
                else:
                    # loop over the sequence
                    for elt in v:
                        if isinstance(elt, bytes):
                            elt = quote_plus(elt, safe)
                        else:
                            elt = quote_plus(str(elt), safe, encoding, errors)
                        l.append(k + '=' + elt)
    return '&'.join(l)

# Utilities to parse URLs (most of these return None for missing parts):
# unwrap('<URL:type://host/path>') --> 'type://host/path'
# splittype('type:opaquestring') --> 'type', 'opaquestring'
# splithost('//host[:port]/path') --> 'host[:port]', '/path'
# splituser('user[:passwd]@host[:port]') --> 'user[:passwd]', 'host[:port]'
# splitpasswd('user:passwd') -> 'user', 'passwd'
# splitport('host:port') --> 'host', 'port'
# splitquery('/path?query') --> '/path', 'query'
# splittag('/path#tag') --> '/path', 'tag'
# splitattr('/path;attr1=value1;attr2=value2;...') ->
#   '/path', ['attr1=value1', 'attr2=value2', ...]
# splitvalue('attr=value') --> 'attr', 'value'
# urllib.parse.unquote('abc%20def') -> 'abc def'
# quote('abc def') -> 'abc%20def')

def to_bytes(url):
    """to_bytes(u"URL") --> 'URL'."""
    # Most URL schemes require ASCII. If that changes, the conversion
    # can be relaxed.
    # XXX get rid of to_bytes()
    if isinstance(url, str):
        try:
            url = url.encode("ASCII").decode()
        except UnicodeError:
            raise UnicodeError("URL " + repr(url) +
                               " contains non-ASCII characters")
    return url

def unwrap(url):
    """unwrap('<URL:type://host/path>') --> 'type://host/path'."""
    url = str(url).strip()
    if url[:1] == '<' and url[-1:] == '>':
        url = url[1:-1].strip()
    if url[:4] == 'URL:': url = url[4:].strip()
    return url

_typeprog = None
def splittype(url):
    """splittype('type:opaquestring') --> 'type', 'opaquestring'."""
    global _typeprog
    if _typeprog is None:
        _typeprog = re.compile('^([^/:]+):')

    match = _typeprog.match(url)
    if match:
        scheme = match.group(1)
        return scheme.lower(), url[len(scheme) + 1:]
    return None, url

_hostprog = None
def splithost(url):
    """splithost('//host[:port]/path') --> 'host[:port]', '/path'."""
    global _hostprog
    if _hostprog is None:
        _hostprog = re.compile('^//([^/?]*)(.*)$')

    match = _hostprog.match(url)
    if match:
        host_port = match.group(1)
        path = match.group(2)
        if path and not path.startswith('/'):
            path = '/' + path
        return host_port, path
    return None, url

_userprog = None
def splituser(host):
    """splituser('user[:passwd]@host[:port]') --> 'user[:passwd]', 'host[:port]'."""
    global _userprog
    if _userprog is None:
        _userprog = re.compile('^(.*)@(.*)$')

    match = _userprog.match(host)
    if match: return match.group(1, 2)
    return None, host

_passwdprog = None
def splitpasswd(user):
    """splitpasswd('user:passwd') -> 'user', 'passwd'."""
    global _passwdprog
    if _passwdprog is None:
        _passwdprog = re.compile('^([^:]*):(.*)$',re.S)

    match = _passwdprog.match(user)
    if match: return match.group(1, 2)
    return user, None

# splittag('/path#tag') --> '/path', 'tag'
_portprog = None
def splitport(host):
    """splitport('host:port') --> 'host', 'port'."""
    global _portprog
    if _portprog is None:
        _portprog = re.compile('^(.*):([0-9]*)$')

    match = _portprog.match(host)
    if match:
        host, port = match.groups()
        if port:
            return host, port
    return host, None

_nportprog = None
def splitnport(host, defport=-1):
    """Split host and port, returning numeric port.
    Return given default port if no ':' found; defaults to -1.
    Return numerical port if a valid number are found after ':'.
    Return None if ':' but not a valid number."""
    global _nportprog
    if _nportprog is None:
        _nportprog = re.compile('^(.*):(.*)$')

    match = _nportprog.match(host)
    if match:
        host, port = match.group(1, 2)
        if port:
            try:
                nport = int(port)
            except ValueError:
                nport = None
            return host, nport
    return host, defport

_queryprog = None
def splitquery(url):
    """splitquery('/path?query') --> '/path', 'query'."""
    global _queryprog
    if _queryprog is None:
        _queryprog = re.compile('^(.*)\?([^?]*)$')

    match = _queryprog.match(url)
    if match: return match.group(1, 2)
    return url, None

_tagprog = None
def splittag(url):
    """splittag('/path#tag') --> '/path', 'tag'."""
    global _tagprog
    if _tagprog is None:
        _tagprog = re.compile('^(.*)#([^#]*)$')

    match = _tagprog.match(url)
    if match: return match.group(1, 2)
    return url, None

def splitattr(url):
    """splitattr('/path;attr1=value1;attr2=value2;...') ->
        '/path', ['attr1=value1', 'attr2=value2', ...]."""
    words = url.split(';')
    return words[0], words[1:]

_valueprog = None
def splitvalue(attr):
    """splitvalue('attr=value') --> 'attr', 'value'."""
    global _valueprog
    if _valueprog is None:
        _valueprog = re.compile('^([^=]*)=(.*)$')

    match = _valueprog.match(attr)
    if match: return match.group(1, 2)
    return attr, None
                                                                                                            usr/lib/python3.4/urllib/request.py                                                                 0100644 0000000 0000000 00000264755 12415221640 015745  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """An extensible library for opening URLs using a variety of protocols

The simplest way to use this module is to call the urlopen function,
which accepts a string containing a URL or a Request object (described
below).  It opens the URL and returns the results as file-like
object; the returned object has some extra methods described below.

The OpenerDirector manages a collection of Handler objects that do
all the actual work.  Each Handler implements a particular protocol or
option.  The OpenerDirector is a composite object that invokes the
Handlers needed to open the requested URL.  For example, the
HTTPHandler performs HTTP GET and POST requests and deals with
non-error returns.  The HTTPRedirectHandler automatically deals with
HTTP 301, 302, 303 and 307 redirect errors, and the HTTPDigestAuthHandler
deals with digest authentication.

urlopen(url, data=None) -- Basic usage is the same as original
urllib.  pass the url and optionally data to post to an HTTP URL, and
get a file-like object back.  One difference is that you can also pass
a Request instance instead of URL.  Raises a URLError (subclass of
OSError); for HTTP errors, raises an HTTPError, which can also be
treated as a valid response.

build_opener -- Function that creates a new OpenerDirector instance.
Will install the default handlers.  Accepts one or more Handlers as
arguments, either instances or Handler classes that it will
instantiate.  If one of the argument is a subclass of the default
handler, the argument will be installed instead of the default.

install_opener -- Installs a new opener as the default opener.

objects of interest:

OpenerDirector -- Sets up the User Agent as the Python-urllib client and manages
the Handler classes, while dealing with requests and responses.

Request -- An object that encapsulates the state of a request.  The
state can be as simple as the URL.  It can also include extra HTTP
headers, e.g. a User-Agent.

BaseHandler --

internals:
BaseHandler and parent
_call_chain conventions

Example usage:

import urllib.request

# set up authentication info
authinfo = urllib.request.HTTPBasicAuthHandler()
authinfo.add_password(realm='PDQ Application',
                      uri='https://mahler:8092/site-updates.py',
                      user='klem',
                      passwd='geheim$parole')

proxy_support = urllib.request.ProxyHandler({"http" : "http://ahad-haam:3128"})

# build a new opener that adds authentication and caching FTP handlers
opener = urllib.request.build_opener(proxy_support, authinfo,
                                     urllib.request.CacheFTPHandler)

# install it
urllib.request.install_opener(opener)

f = urllib.request.urlopen('http://www.python.org/')
"""

# XXX issues:
# If an authentication error handler that tries to perform
# authentication for some reason but fails, how should the error be
# signalled?  The client needs to know the HTTP error code.  But if
# the handler knows that the problem was, e.g., that it didn't know
# that hash algo that requested in the challenge, it would be good to
# pass that information along to the client, too.
# ftp errors aren't handled cleanly
# check digest against correct (i.e. non-apache) implementation

# Possible extensions:
# complex proxies  XXX not sure what exactly was meant by this
# abstract factory for opener

import base64
import bisect
import email
import hashlib
import http.client
import io
import os
import posixpath
import re
import socket
import sys
import time
import collections
import tempfile
import contextlib
import warnings


from urllib.error import URLError, HTTPError, ContentTooShortError
from urllib.parse import (
    urlparse, urlsplit, urljoin, unwrap, quote, unquote,
    splittype, splithost, splitport, splituser, splitpasswd,
    splitattr, splitquery, splitvalue, splittag, to_bytes,
    unquote_to_bytes, urlunparse)
from urllib.response import addinfourl, addclosehook

# check for SSL
try:
    import ssl
except ImportError:
    _have_ssl = False
else:
    _have_ssl = True

__all__ = [
    # Classes
    'Request', 'OpenerDirector', 'BaseHandler', 'HTTPDefaultErrorHandler',
    'HTTPRedirectHandler', 'HTTPCookieProcessor', 'ProxyHandler',
    'HTTPPasswordMgr', 'HTTPPasswordMgrWithDefaultRealm',
    'AbstractBasicAuthHandler', 'HTTPBasicAuthHandler', 'ProxyBasicAuthHandler',
    'AbstractDigestAuthHandler', 'HTTPDigestAuthHandler', 'ProxyDigestAuthHandler',
    'HTTPHandler', 'FileHandler', 'FTPHandler', 'CacheFTPHandler', 'DataHandler',
    'UnknownHandler', 'HTTPErrorProcessor',
    # Functions
    'urlopen', 'install_opener', 'build_opener',
    'pathname2url', 'url2pathname', 'getproxies',
    # Legacy interface
    'urlretrieve', 'urlcleanup', 'URLopener', 'FancyURLopener',
]

# used in User-Agent header sent
__version__ = sys.version[:3]

_opener = None
def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
            *, cafile=None, capath=None, cadefault=False):
    global _opener
    if cafile or capath or cadefault:
        if not _have_ssl:
            raise ValueError('SSL support not available')
        context = ssl._create_stdlib_context(cert_reqs=ssl.CERT_REQUIRED,
                                             cafile=cafile,
                                             capath=capath)
        https_handler = HTTPSHandler(context=context, check_hostname=True)
        opener = build_opener(https_handler)
    elif _opener is None:
        _opener = opener = build_opener()
    else:
        opener = _opener
    return opener.open(url, data, timeout)

def install_opener(opener):
    global _opener
    _opener = opener

_url_tempfiles = []
def urlretrieve(url, filename=None, reporthook=None, data=None):
    """
    Retrieve a URL into a temporary location on disk.

    Requires a URL argument. If a filename is passed, it is used as
    the temporary file location. The reporthook argument should be
    a callable that accepts a block number, a read size, and the
    total file size of the URL target. The data argument should be
    valid URL encoded data.

    If a filename is passed and the URL points to a local resource,
    the result is a copy from local file to new file.

    Returns a tuple containing the path to the newly created
    data file as well as the resulting HTTPMessage object.
    """
    url_type, path = splittype(url)

    with contextlib.closing(urlopen(url, data)) as fp:
        headers = fp.info()

        # Just return the local path and the "headers" for file://
        # URLs. No sense in performing a copy unless requested.
        if url_type == "file" and not filename:
            return os.path.normpath(path), headers

        # Handle temporary file setup.
        if filename:
            tfp = open(filename, 'wb')
        else:
            tfp = tempfile.NamedTemporaryFile(delete=False)
            filename = tfp.name
            _url_tempfiles.append(filename)

        with tfp:
            result = filename, headers
            bs = 1024*8
            size = -1
            read = 0
            blocknum = 0
            if "content-length" in headers:
                size = int(headers["Content-Length"])

            if reporthook:
                reporthook(blocknum, bs, size)

            while True:
                block = fp.read(bs)
                if not block:
                    break
                read += len(block)
                tfp.write(block)
                blocknum += 1
                if reporthook:
                    reporthook(blocknum, bs, size)

    if size >= 0 and read < size:
        raise ContentTooShortError(
            "retrieval incomplete: got only %i out of %i bytes"
            % (read, size), result)

    return result

def urlcleanup():
    for temp_file in _url_tempfiles:
        try:
            os.unlink(temp_file)
        except OSError:
            pass

    del _url_tempfiles[:]
    global _opener
    if _opener:
        _opener = None

# copied from cookielib.py
_cut_port_re = re.compile(r":\d+$", re.ASCII)
def request_host(request):
    """Return request-host, as defined by RFC 2965.

    Variation from RFC: returned value is lowercased, for convenient
    comparison.

    """
    url = request.full_url
    host = urlparse(url)[1]
    if host == "":
        host = request.get_header("Host", "")

    # remove port, if present
    host = _cut_port_re.sub("", host, 1)
    return host.lower()

class Request:

    def __init__(self, url, data=None, headers={},
                 origin_req_host=None, unverifiable=False,
                 method=None):
        self.full_url = url
        self.headers = {}
        self.unredirected_hdrs = {}
        self._data = None
        self.data = data
        self._tunnel_host = None
        for key, value in headers.items():
            self.add_header(key, value)
        if origin_req_host is None:
            origin_req_host = request_host(self)
        self.origin_req_host = origin_req_host
        self.unverifiable = unverifiable
        if method:
            self.method = method

    @property
    def full_url(self):
        if self.fragment:
            return '{}#{}'.format(self._full_url, self.fragment)
        return self._full_url

    @full_url.setter
    def full_url(self, url):
        # unwrap('<URL:type://host/path>') --> 'type://host/path'
        self._full_url = unwrap(url)
        self._full_url, self.fragment = splittag(self._full_url)
        self._parse()

    @full_url.deleter
    def full_url(self):
        self._full_url = None
        self.fragment = None
        self.selector = ''

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, data):
        if data != self._data:
            self._data = data
            # issue 16464
            # if we change data we need to remove content-length header
            # (cause it's most probably calculated for previous value)
            if self.has_header("Content-length"):
                self.remove_header("Content-length")

    @data.deleter
    def data(self):
        self.data = None

    def _parse(self):
        self.type, rest = splittype(self._full_url)
        if self.type is None:
            raise ValueError("unknown url type: %r" % self.full_url)
        self.host, self.selector = splithost(rest)
        if self.host:
            self.host = unquote(self.host)

    def get_method(self):
        """Return a string indicating the HTTP request method."""
        default_method = "POST" if self.data is not None else "GET"
        return getattr(self, 'method', default_method)

    def get_full_url(self):
        return self.full_url

    def set_proxy(self, host, type):
        if self.type == 'https' and not self._tunnel_host:
            self._tunnel_host = self.host
        else:
            self.type= type
            self.selector = self.full_url
        self.host = host

    def has_proxy(self):
        return self.selector == self.full_url

    def add_header(self, key, val):
        # useful for something like authentication
        self.headers[key.capitalize()] = val

    def add_unredirected_header(self, key, val):
        # will not be added to a redirected request
        self.unredirected_hdrs[key.capitalize()] = val

    def has_header(self, header_name):
        return (header_name in self.headers or
                header_name in self.unredirected_hdrs)

    def get_header(self, header_name, default=None):
        return self.headers.get(
            header_name,
            self.unredirected_hdrs.get(header_name, default))

    def remove_header(self, header_name):
        self.headers.pop(header_name, None)
        self.unredirected_hdrs.pop(header_name, None)

    def header_items(self):
        hdrs = self.unredirected_hdrs.copy()
        hdrs.update(self.headers)
        return list(hdrs.items())

class OpenerDirector:
    def __init__(self):
        client_version = "Python-urllib/%s" % __version__
        self.addheaders = [('User-agent', client_version)]
        # self.handlers is retained only for backward compatibility
        self.handlers = []
        # manage the individual handlers
        self.handle_open = {}
        self.handle_error = {}
        self.process_response = {}
        self.process_request = {}

    def add_handler(self, handler):
        if not hasattr(handler, "add_parent"):
            raise TypeError("expected BaseHandler instance, got %r" %
                            type(handler))

        added = False
        for meth in dir(handler):
            if meth in ["redirect_request", "do_open", "proxy_open"]:
                # oops, coincidental match
                continue

            i = meth.find("_")
            protocol = meth[:i]
            condition = meth[i+1:]

            if condition.startswith("error"):
                j = condition.find("_") + i + 1
                kind = meth[j+1:]
                try:
                    kind = int(kind)
                except ValueError:
                    pass
                lookup = self.handle_error.get(protocol, {})
                self.handle_error[protocol] = lookup
            elif condition == "open":
                kind = protocol
                lookup = self.handle_open
            elif condition == "response":
                kind = protocol
                lookup = self.process_response
            elif condition == "request":
                kind = protocol
                lookup = self.process_request
            else:
                continue

            handlers = lookup.setdefault(kind, [])
            if handlers:
                bisect.insort(handlers, handler)
            else:
                handlers.append(handler)
            added = True

        if added:
            bisect.insort(self.handlers, handler)
            handler.add_parent(self)

    def close(self):
        # Only exists for backwards compatibility.
        pass

    def _call_chain(self, chain, kind, meth_name, *args):
        # Handlers raise an exception if no one else should try to handle
        # the request, or return None if they can't but another handler
        # could.  Otherwise, they return the response.
        handlers = chain.get(kind, ())
        for handler in handlers:
            func = getattr(handler, meth_name)
            result = func(*args)
            if result is not None:
                return result

    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
        # accept a URL or a Request object
        if isinstance(fullurl, str):
            req = Request(fullurl, data)
        else:
            req = fullurl
            if data is not None:
                req.data = data

        req.timeout = timeout
        protocol = req.type

        # pre-process request
        meth_name = protocol+"_request"
        for processor in self.process_request.get(protocol, []):
            meth = getattr(processor, meth_name)
            req = meth(req)

        response = self._open(req, data)

        # post-process response
        meth_name = protocol+"_response"
        for processor in self.process_response.get(protocol, []):
            meth = getattr(processor, meth_name)
            response = meth(req, response)

        return response

    def _open(self, req, data=None):
        result = self._call_chain(self.handle_open, 'default',
                                  'default_open', req)
        if result:
            return result

        protocol = req.type
        result = self._call_chain(self.handle_open, protocol, protocol +
                                  '_open', req)
        if result:
            return result

        return self._call_chain(self.handle_open, 'unknown',
                                'unknown_open', req)

    def error(self, proto, *args):
        if proto in ('http', 'https'):
            # XXX http[s] protocols are special-cased
            dict = self.handle_error['http'] # https is not different than http
            proto = args[2]  # YUCK!
            meth_name = 'http_error_%s' % proto
            http_err = 1
            orig_args = args
        else:
            dict = self.handle_error
            meth_name = proto + '_error'
            http_err = 0
        args = (dict, proto, meth_name) + args
        result = self._call_chain(*args)
        if result:
            return result

        if http_err:
            args = (dict, 'default', 'http_error_default') + orig_args
            return self._call_chain(*args)

# XXX probably also want an abstract factory that knows when it makes
# sense to skip a superclass in favor of a subclass and when it might
# make sense to include both

def build_opener(*handlers):
    """Create an opener object from a list of handlers.

    The opener will use several default handlers, including support
    for HTTP, FTP and when applicable HTTPS.

    If any of the handlers passed as arguments are subclasses of the
    default handlers, the default handlers will not be used.
    """
    opener = OpenerDirector()
    default_classes = [ProxyHandler, UnknownHandler, HTTPHandler,
                       HTTPDefaultErrorHandler, HTTPRedirectHandler,
                       FTPHandler, FileHandler, HTTPErrorProcessor,
                       DataHandler]
    if hasattr(http.client, "HTTPSConnection"):
        default_classes.append(HTTPSHandler)
    skip = set()
    for klass in default_classes:
        for check in handlers:
            if isinstance(check, type):
                if issubclass(check, klass):
                    skip.add(klass)
            elif isinstance(check, klass):
                skip.add(klass)
    for klass in skip:
        default_classes.remove(klass)

    for klass in default_classes:
        opener.add_handler(klass())

    for h in handlers:
        if isinstance(h, type):
            h = h()
        opener.add_handler(h)
    return opener

class BaseHandler:
    handler_order = 500

    def add_parent(self, parent):
        self.parent = parent

    def close(self):
        # Only exists for backwards compatibility
        pass

    def __lt__(self, other):
        if not hasattr(other, "handler_order"):
            # Try to preserve the old behavior of having custom classes
            # inserted after default ones (works only for custom user
            # classes which are not aware of handler_order).
            return True
        return self.handler_order < other.handler_order


class HTTPErrorProcessor(BaseHandler):
    """Process HTTP error responses."""
    handler_order = 1000  # after all other processing

    def http_response(self, request, response):
        code, msg, hdrs = response.code, response.msg, response.info()

        # According to RFC 2616, "2xx" code indicates that the client's
        # request was successfully received, understood, and accepted.
        if not (200 <= code < 300):
            response = self.parent.error(
                'http', request, response, code, msg, hdrs)

        return response

    https_response = http_response

class HTTPDefaultErrorHandler(BaseHandler):
    def http_error_default(self, req, fp, code, msg, hdrs):
        raise HTTPError(req.full_url, code, msg, hdrs, fp)

class HTTPRedirectHandler(BaseHandler):
    # maximum number of redirections to any single URL
    # this is needed because of the state that cookies introduce
    max_repeats = 4
    # maximum total number of redirections (regardless of URL) before
    # assuming we're in a loop
    max_redirections = 10

    def redirect_request(self, req, fp, code, msg, headers, newurl):
        """Return a Request or None in response to a redirect.

        This is called by the http_error_30x methods when a
        redirection response is received.  If a redirection should
        take place, return a new Request to allow http_error_30x to
        perform the redirect.  Otherwise, raise HTTPError if no-one
        else should try to handle this url.  Return None if you can't
        but another Handler might.
        """
        m = req.get_method()
        if (not (code in (301, 302, 303, 307) and m in ("GET", "HEAD")
            or code in (301, 302, 303) and m == "POST")):
            raise HTTPError(req.full_url, code, msg, headers, fp)

        # Strictly (according to RFC 2616), 301 or 302 in response to
        # a POST MUST NOT cause a redirection without confirmation
        # from the user (of urllib.request, in this case).  In practice,
        # essentially all clients do redirect in this case, so we do
        # the same.
        # be conciliant with URIs containing a space
        newurl = newurl.replace(' ', '%20')
        CONTENT_HEADERS = ("content-length", "content-type")
        newheaders = dict((k, v) for k, v in req.headers.items()
                          if k.lower() not in CONTENT_HEADERS)
        return Request(newurl,
                       headers=newheaders,
                       origin_req_host=req.origin_req_host,
                       unverifiable=True)

    # Implementation note: To avoid the server sending us into an
    # infinite loop, the request object needs to track what URLs we
    # have already seen.  Do this by adding a handler-specific
    # attribute to the Request object.
    def http_error_302(self, req, fp, code, msg, headers):
        # Some servers (incorrectly) return multiple Location headers
        # (so probably same goes for URI).  Use first header.
        if "location" in headers:
            newurl = headers["location"]
        elif "uri" in headers:
            newurl = headers["uri"]
        else:
            return

        # fix a possible malformed URL
        urlparts = urlparse(newurl)

        # For security reasons we don't allow redirection to anything other
        # than http, https or ftp.

        if urlparts.scheme not in ('http', 'https', 'ftp', ''):
            raise HTTPError(
                newurl, code,
                "%s - Redirection to url '%s' is not allowed" % (msg, newurl),
                headers, fp)

        if not urlparts.path:
            urlparts = list(urlparts)
            urlparts[2] = "/"
        newurl = urlunparse(urlparts)

        newurl = urljoin(req.full_url, newurl)

        # XXX Probably want to forget about the state of the current
        # request, although that might interact poorly with other
        # handlers that also use handler-specific request attributes
        new = self.redirect_request(req, fp, code, msg, headers, newurl)
        if new is None:
            return

        # loop detection
        # .redirect_dict has a key url if url was previously visited.
        if hasattr(req, 'redirect_dict'):
            visited = new.redirect_dict = req.redirect_dict
            if (visited.get(newurl, 0) >= self.max_repeats or
                len(visited) >= self.max_redirections):
                raise HTTPError(req.full_url, code,
                                self.inf_msg + msg, headers, fp)
        else:
            visited = new.redirect_dict = req.redirect_dict = {}
        visited[newurl] = visited.get(newurl, 0) + 1

        # Don't close the fp until we are sure that we won't use it
        # with HTTPError.
        fp.read()
        fp.close()

        return self.parent.open(new, timeout=req.timeout)

    http_error_301 = http_error_303 = http_error_307 = http_error_302

    inf_msg = "The HTTP server returned a redirect error that would " \
              "lead to an infinite loop.\n" \
              "The last 30x error message was:\n"


def _parse_proxy(proxy):
    """Return (scheme, user, password, host/port) given a URL or an authority.

    If a URL is supplied, it must have an authority (host:port) component.
    According to RFC 3986, having an authority component means the URL must
    have two slashes after the scheme.
    """
    scheme, r_scheme = splittype(proxy)
    if not r_scheme.startswith("/"):
        # authority
        scheme = None
        authority = proxy
    else:
        # URL
        if not r_scheme.startswith("//"):
            raise ValueError("proxy URL with no authority: %r" % proxy)
        # We have an authority, so for RFC 3986-compliant URLs (by ss 3.
        # and 3.3.), path is empty or starts with '/'
        end = r_scheme.find("/", 2)
        if end == -1:
            end = None
        authority = r_scheme[2:end]
    userinfo, hostport = splituser(authority)
    if userinfo is not None:
        user, password = splitpasswd(userinfo)
    else:
        user = password = None
    return scheme, user, password, hostport

class ProxyHandler(BaseHandler):
    # Proxies must be in front
    handler_order = 100

    def __init__(self, proxies=None):
        if proxies is None:
            proxies = getproxies()
        assert hasattr(proxies, 'keys'), "proxies must be a mapping"
        self.proxies = proxies
        for type, url in proxies.items():
            setattr(self, '%s_open' % type,
                    lambda r, proxy=url, type=type, meth=self.proxy_open:
                        meth(r, proxy, type))

    def proxy_open(self, req, proxy, type):
        orig_type = req.type
        proxy_type, user, password, hostport = _parse_proxy(proxy)
        if proxy_type is None:
            proxy_type = orig_type

        if req.host and proxy_bypass(req.host):
            return None

        if user and password:
            user_pass = '%s:%s' % (unquote(user),
                                   unquote(password))
            creds = base64.b64encode(user_pass.encode()).decode("ascii")
            req.add_header('Proxy-authorization', 'Basic ' + creds)
        hostport = unquote(hostport)
        req.set_proxy(hostport, proxy_type)
        if orig_type == proxy_type or orig_type == 'https':
            # let other handlers take care of it
            return None
        else:
            # need to start over, because the other handlers don't
            # grok the proxy's URL type
            # e.g. if we have a constructor arg proxies like so:
            # {'http': 'ftp://proxy.example.com'}, we may end up turning
            # a request for http://acme.example.com/a into one for
            # ftp://proxy.example.com/a
            return self.parent.open(req, timeout=req.timeout)

class HTTPPasswordMgr:

    def __init__(self):
        self.passwd = {}

    def add_password(self, realm, uri, user, passwd):
        # uri could be a single URI or a sequence
        if isinstance(uri, str):
            uri = [uri]
        if realm not in self.passwd:
            self.passwd[realm] = {}
        for default_port in True, False:
            reduced_uri = tuple(
                [self.reduce_uri(u, default_port) for u in uri])
            self.passwd[realm][reduced_uri] = (user, passwd)

    def find_user_password(self, realm, authuri):
        domains = self.passwd.get(realm, {})
        for default_port in True, False:
            reduced_authuri = self.reduce_uri(authuri, default_port)
            for uris, authinfo in domains.items():
                for uri in uris:
                    if self.is_suburi(uri, reduced_authuri):
                        return authinfo
        return None, None

    def reduce_uri(self, uri, default_port=True):
        """Accept authority or URI and extract only the authority and path."""
        # note HTTP URLs do not have a userinfo component
        parts = urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {"http": 80,
                     "https": 443,
                     }.get(scheme)
            if dport is not None:
                authority = "%s:%d" % (host, dport)
        return authority, path

    def is_suburi(self, base, test):
        """Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


class HTTPPasswordMgrWithDefaultRealm(HTTPPasswordMgr):

    def find_user_password(self, realm, authuri):
        user, password = HTTPPasswordMgr.find_user_password(self, realm,
                                                            authuri)
        if user is not None:
            return user, password
        return HTTPPasswordMgr.find_user_password(self, None, authuri)


class AbstractBasicAuthHandler:

    # XXX this allows for multiple auth-schemes, but will stupidly pick
    # the last one with a realm specified.

    # allow for double- and single-quoted realm values
    # (single quotes are a violation of the RFC, but appear in the wild)
    rx = re.compile('(?:.*,)*[ \t]*([^ \t]+)[ \t]+'
                    'realm=(["\']?)([^"\']*)\\2', re.I)

    # XXX could pre-emptively send auth info already accepted (RFC 2617,
    # end of section 2, and section 1.2 immediately after "credentials"
    # production).

    def __init__(self, password_mgr=None):
        if password_mgr is None:
            password_mgr = HTTPPasswordMgr()
        self.passwd = password_mgr
        self.add_password = self.passwd.add_password

    def http_error_auth_reqed(self, authreq, host, req, headers):
        # host may be an authority (without userinfo) or a URL with an
        # authority
        # XXX could be multiple headers
        authreq = headers.get(authreq, None)

        if authreq:
            scheme = authreq.split()[0]
            if scheme.lower() != 'basic':
                raise ValueError("AbstractBasicAuthHandler does not"
                                 " support the following scheme: '%s'" %
                                 scheme)
            else:
                mo = AbstractBasicAuthHandler.rx.search(authreq)
                if mo:
                    scheme, quote, realm = mo.groups()
                    if quote not in ['"',"'"]:
                        warnings.warn("Basic Auth Realm was unquoted",
                                      UserWarning, 2)
                    if scheme.lower() == 'basic':
                        return self.retry_http_basic_auth(host, req, realm)

    def retry_http_basic_auth(self, host, req, realm):
        user, pw = self.passwd.find_user_password(realm, host)
        if pw is not None:
            raw = "%s:%s" % (user, pw)
            auth = "Basic " + base64.b64encode(raw.encode()).decode("ascii")
            if req.get_header(self.auth_header, None) == auth:
                return None
            req.add_unredirected_header(self.auth_header, auth)
            return self.parent.open(req, timeout=req.timeout)
        else:
            return None


class HTTPBasicAuthHandler(AbstractBasicAuthHandler, BaseHandler):

    auth_header = 'Authorization'

    def http_error_401(self, req, fp, code, msg, headers):
        url = req.full_url
        response = self.http_error_auth_reqed('www-authenticate',
                                          url, req, headers)
        return response


class ProxyBasicAuthHandler(AbstractBasicAuthHandler, BaseHandler):

    auth_header = 'Proxy-authorization'

    def http_error_407(self, req, fp, code, msg, headers):
        # http_error_auth_reqed requires that there is no userinfo component in
        # authority.  Assume there isn't one, since urllib.request does not (and
        # should not, RFC 3986 s. 3.2.1) support requests for URLs containing
        # userinfo.
        authority = req.host
        response = self.http_error_auth_reqed('proxy-authenticate',
                                          authority, req, headers)
        return response


# Return n random bytes.
_randombytes = os.urandom


class AbstractDigestAuthHandler:
    # Digest authentication is specified in RFC 2617.

    # XXX The client does not inspect the Authentication-Info header
    # in a successful response.

    # XXX It should be possible to test this implementation against
    # a mock server that just generates a static set of challenges.

    # XXX qop="auth-int" supports is shaky

    def __init__(self, passwd=None):
        if passwd is None:
            passwd = HTTPPasswordMgr()
        self.passwd = passwd
        self.add_password = self.passwd.add_password
        self.retried = 0
        self.nonce_count = 0
        self.last_nonce = None

    def reset_retry_count(self):
        self.retried = 0

    def http_error_auth_reqed(self, auth_header, host, req, headers):
        authreq = headers.get(auth_header, None)
        if self.retried > 5:
            # Don't fail endlessly - if we failed once, we'll probably
            # fail a second time. Hm. Unless the Password Manager is
            # prompting for the information. Crap. This isn't great
            # but it's better than the current 'repeat until recursion
            # depth exceeded' approach <wink>
            raise HTTPError(req.full_url, 401, "digest auth failed",
                            headers, None)
        else:
            self.retried += 1
        if authreq:
            scheme = authreq.split()[0]
            if scheme.lower() == 'digest':
                return self.retry_http_digest_auth(req, authreq)
            elif scheme.lower() != 'basic':
                raise ValueError("AbstractDigestAuthHandler does not support"
                                 " the following scheme: '%s'" % scheme)

    def retry_http_digest_auth(self, req, auth):
        token, challenge = auth.split(' ', 1)
        chal = parse_keqv_list(filter(None, parse_http_list(challenge)))
        auth = self.get_authorization(req, chal)
        if auth:
            auth_val = 'Digest %s' % auth
            if req.headers.get(self.auth_header, None) == auth_val:
                return None
            req.add_unredirected_header(self.auth_header, auth_val)
            resp = self.parent.open(req, timeout=req.timeout)
            return resp

    def get_cnonce(self, nonce):
        # The cnonce-value is an opaque
        # quoted string value provided by the client and used by both client
        # and server to avoid chosen plaintext attacks, to provide mutual
        # authentication, and to provide some message integrity protection.
        # This isn't a fabulous effort, but it's probably Good Enough.
        s = "%s:%s:%s:" % (self.nonce_count, nonce, time.ctime())
        b = s.encode("ascii") + _randombytes(8)
        dig = hashlib.sha1(b).hexdigest()
        return dig[:16]

    def get_authorization(self, req, chal):
        try:
            realm = chal['realm']
            nonce = chal['nonce']
            qop = chal.get('qop')
            algorithm = chal.get('algorithm', 'MD5')
            # mod_digest doesn't send an opaque, even though it isn't
            # supposed to be optional
            opaque = chal.get('opaque', None)
        except KeyError:
            return None

        H, KD = self.get_algorithm_impls(algorithm)
        if H is None:
            return None

        user, pw = self.passwd.find_user_password(realm, req.full_url)
        if user is None:
            return None

        # XXX not implemented yet
        if req.data is not None:
            entdig = self.get_entity_digest(req.data, chal)
        else:
            entdig = None

        A1 = "%s:%s:%s" % (user, realm, pw)
        A2 = "%s:%s" % (req.get_method(),
                        # XXX selector: what about proxies and full urls
                        req.selector)
        if qop == 'auth':
            if nonce == self.last_nonce:
                self.nonce_count += 1
            else:
                self.nonce_count = 1
                self.last_nonce = nonce
            ncvalue = '%08x' % self.nonce_count
            cnonce = self.get_cnonce(nonce)
            noncebit = "%s:%s:%s:%s:%s" % (nonce, ncvalue, cnonce, qop, H(A2))
            respdig = KD(H(A1), noncebit)
        elif qop is None:
            respdig = KD(H(A1), "%s:%s" % (nonce, H(A2)))
        else:
            # XXX handle auth-int.
            raise URLError("qop '%s' is not supported." % qop)

        # XXX should the partial digests be encoded too?

        base = 'username="%s", realm="%s", nonce="%s", uri="%s", ' \
               'response="%s"' % (user, realm, nonce, req.selector,
                                  respdig)
        if opaque:
            base += ', opaque="%s"' % opaque
        if entdig:
            base += ', digest="%s"' % entdig
        base += ', algorithm="%s"' % algorithm
        if qop:
            base += ', qop=auth, nc=%s, cnonce="%s"' % (ncvalue, cnonce)
        return base

    def get_algorithm_impls(self, algorithm):
        # lambdas assume digest modules are imported at the top level
        if algorithm == 'MD5':
            H = lambda x: hashlib.md5(x.encode("ascii")).hexdigest()
        elif algorithm == 'SHA':
            H = lambda x: hashlib.sha1(x.encode("ascii")).hexdigest()
        # XXX MD5-sess
        KD = lambda s, d: H("%s:%s" % (s, d))
        return H, KD

    def get_entity_digest(self, data, chal):
        # XXX not implemented yet
        return None


class HTTPDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler):
    """An authentication protocol defined by RFC 2069

    Digest authentication improves on basic authentication because it
    does not transmit passwords in the clear.
    """

    auth_header = 'Authorization'
    handler_order = 490  # before Basic auth

    def http_error_401(self, req, fp, code, msg, headers):
        host = urlparse(req.full_url)[1]
        retry = self.http_error_auth_reqed('www-authenticate',
                                           host, req, headers)
        self.reset_retry_count()
        return retry


class ProxyDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler):

    auth_header = 'Proxy-Authorization'
    handler_order = 490  # before Basic auth

    def http_error_407(self, req, fp, code, msg, headers):
        host = req.host
        retry = self.http_error_auth_reqed('proxy-authenticate',
                                           host, req, headers)
        self.reset_retry_count()
        return retry

class AbstractHTTPHandler(BaseHandler):

    def __init__(self, debuglevel=0):
        self._debuglevel = debuglevel

    def set_http_debuglevel(self, level):
        self._debuglevel = level

    def do_request_(self, request):
        host = request.host
        if not host:
            raise URLError('no host given')

        if request.data is not None:  # POST
            data = request.data
            if isinstance(data, str):
                msg = "POST data should be bytes or an iterable of bytes. " \
                      "It cannot be of type str."
                raise TypeError(msg)
            if not request.has_header('Content-type'):
                request.add_unredirected_header(
                    'Content-type',
                    'application/x-www-form-urlencoded')
            if not request.has_header('Content-length'):
                try:
                    mv = memoryview(data)
                except TypeError:
                    if isinstance(data, collections.Iterable):
                        raise ValueError("Content-Length should be specified "
                                "for iterable data of type %r %r" % (type(data),
                                data))
                else:
                    request.add_unredirected_header(
                            'Content-length', '%d' % (len(mv) * mv.itemsize))

        sel_host = host
        if request.has_proxy():
            scheme, sel = splittype(request.selector)
            sel_host, sel_path = splithost(sel)
        if not request.has_header('Host'):
            request.add_unredirected_header('Host', sel_host)
        for name, value in self.parent.addheaders:
            name = name.capitalize()
            if not request.has_header(name):
                request.add_unredirected_header(name, value)

        return request

    def do_open(self, http_class, req, **http_conn_args):
        """Return an HTTPResponse object for the request, using http_class.

        http_class must implement the HTTPConnection API from http.client.
        """
        host = req.host
        if not host:
            raise URLError('no host given')

        # will parse host:port
        h = http_class(host, timeout=req.timeout, **http_conn_args)

        headers = dict(req.unredirected_hdrs)
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers))

        # TODO(jhylton): Should this be redesigned to handle
        # persistent connections?

        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn't prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers["Connection"] = "close"
        headers = dict((name.title(), val) for name, val in headers.items())

        if req._tunnel_host:
            tunnel_headers = {}
            proxy_auth_hdr = "Proxy-Authorization"
            if proxy_auth_hdr in headers:
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr]
            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)

        try:
            try:
                h.request(req.get_method(), req.selector, req.data, headers)
            except OSError as err: # timeout error
                raise URLError(err)
            r = h.getresponse()
        except:
            h.close()
            raise

        # If the server does not send us a 'Connection: close' header,
        # HTTPConnection assumes the socket should be left open. Manually
        # mark the socket to be closed when this response object goes away.
        if h.sock:
            h.sock.close()
            h.sock = None

        r.url = req.get_full_url()
        # This line replaces the .msg attribute of the HTTPResponse
        # with .headers, because urllib clients expect the response to
        # have the reason in .msg.  It would be good to mark this
        # attribute is deprecated and get then to use info() or
        # .headers.
        r.msg = r.reason
        return r


class HTTPHandler(AbstractHTTPHandler):

    def http_open(self, req):
        return self.do_open(http.client.HTTPConnection, req)

    http_request = AbstractHTTPHandler.do_request_

if hasattr(http.client, 'HTTPSConnection'):

    class HTTPSHandler(AbstractHTTPHandler):

        def __init__(self, debuglevel=0, context=None, check_hostname=None):
            AbstractHTTPHandler.__init__(self, debuglevel)
            self._context = context
            self._check_hostname = check_hostname

        def https_open(self, req):
            return self.do_open(http.client.HTTPSConnection, req,
                context=self._context, check_hostname=self._check_hostname)

        https_request = AbstractHTTPHandler.do_request_

    __all__.append('HTTPSHandler')

class HTTPCookieProcessor(BaseHandler):
    def __init__(self, cookiejar=None):
        import http.cookiejar
        if cookiejar is None:
            cookiejar = http.cookiejar.CookieJar()
        self.cookiejar = cookiejar

    def http_request(self, request):
        self.cookiejar.add_cookie_header(request)
        return request

    def http_response(self, request, response):
        self.cookiejar.extract_cookies(response, request)
        return response

    https_request = http_request
    https_response = http_response

class UnknownHandler(BaseHandler):
    def unknown_open(self, req):
        type = req.type
        raise URLError('unknown url type: %s' % type)

def parse_keqv_list(l):
    """Parse list of key=value strings where keys are not duplicated."""
    parsed = {}
    for elt in l:
        k, v = elt.split('=', 1)
        if v[0] == '"' and v[-1] == '"':
            v = v[1:-1]
        parsed[k] = v
    return parsed

def parse_http_list(s):
    """Parse lists as described by RFC 2068 Section 2.

    In particular, parse comma-separated lists where the elements of
    the list may include quoted-strings.  A quoted-string could
    contain a comma.  A non-quoted string could have quotes in the
    middle.  Neither commas nor quotes count if they are escaped.
    Only double-quotes count, not single-quotes.
    """
    res = []
    part = ''

    escape = quote = False
    for cur in s:
        if escape:
            part += cur
            escape = False
            continue
        if quote:
            if cur == '\\':
                escape = True
                continue
            elif cur == '"':
                quote = False
            part += cur
            continue

        if cur == ',':
            res.append(part)
            part = ''
            continue

        if cur == '"':
            quote = True

        part += cur

    # append last part
    if part:
        res.append(part)

    return [part.strip() for part in res]

class FileHandler(BaseHandler):
    # Use local file or FTP depending on form of URL
    def file_open(self, req):
        url = req.selector
        if url[:2] == '//' and url[2:3] != '/' and (req.host and
                req.host != 'localhost'):
            if not req.host in self.get_names():
                raise URLError("file:// scheme is supported only on localhost")
        else:
            return self.open_local_file(req)

    # names for the localhost
    names = None
    def get_names(self):
        if FileHandler.names is None:
            try:
                FileHandler.names = tuple(
                    socket.gethostbyname_ex('localhost')[2] +
                    socket.gethostbyname_ex(socket.gethostname())[2])
            except socket.gaierror:
                FileHandler.names = (socket.gethostbyname('localhost'),)
        return FileHandler.names

    # not entirely sure what the rules are here
    def open_local_file(self, req):
        import email.utils
        import mimetypes
        host = req.host
        filename = req.selector
        localfile = url2pathname(filename)
        try:
            stats = os.stat(localfile)
            size = stats.st_size
            modified = email.utils.formatdate(stats.st_mtime, usegmt=True)
            mtype = mimetypes.guess_type(filename)[0]
            headers = email.message_from_string(
                'Content-type: %s\nContent-length: %d\nLast-modified: %s\n' %
                (mtype or 'text/plain', size, modified))
            if host:
                host, port = splitport(host)
            if not host or \
                (not port and _safe_gethostbyname(host) in self.get_names()):
                if host:
                    origurl = 'file://' + host + filename
                else:
                    origurl = 'file://' + filename
                return addinfourl(open(localfile, 'rb'), headers, origurl)
        except OSError as exp:
            # users shouldn't expect OSErrors coming from urlopen()
            raise URLError(exp)
        raise URLError('file not on local host')

def _safe_gethostbyname(host):
    try:
        return socket.gethostbyname(host)
    except socket.gaierror:
        return None

class FTPHandler(BaseHandler):
    def ftp_open(self, req):
        import ftplib
        import mimetypes
        host = req.host
        if not host:
            raise URLError('ftp error: no host given')
        host, port = splitport(host)
        if port is None:
            port = ftplib.FTP_PORT
        else:
            port = int(port)

        # username/password handling
        user, host = splituser(host)
        if user:
            user, passwd = splitpasswd(user)
        else:
            passwd = None
        host = unquote(host)
        user = user or ''
        passwd = passwd or ''

        try:
            host = socket.gethostbyname(host)
        except OSError as msg:
            raise URLError(msg)
        path, attrs = splitattr(req.selector)
        dirs = path.split('/')
        dirs = list(map(unquote, dirs))
        dirs, file = dirs[:-1], dirs[-1]
        if dirs and not dirs[0]:
            dirs = dirs[1:]
        try:
            fw = self.connect_ftp(user, passwd, host, port, dirs, req.timeout)
            type = file and 'I' or 'D'
            for attr in attrs:
                attr, value = splitvalue(attr)
                if attr.lower() == 'type' and \
                   value in ('a', 'A', 'i', 'I', 'd', 'D'):
                    type = value.upper()
            fp, retrlen = fw.retrfile(file, type)
            headers = ""
            mtype = mimetypes.guess_type(req.full_url)[0]
            if mtype:
                headers += "Content-type: %s\n" % mtype
            if retrlen is not None and retrlen >= 0:
                headers += "Content-length: %d\n" % retrlen
            headers = email.message_from_string(headers)
            return addinfourl(fp, headers, req.full_url)
        except ftplib.all_errors as exp:
            exc = URLError('ftp error: %r' % exp)
            raise exc.with_traceback(sys.exc_info()[2])

    def connect_ftp(self, user, passwd, host, port, dirs, timeout):
        return ftpwrapper(user, passwd, host, port, dirs, timeout,
                          persistent=False)

class CacheFTPHandler(FTPHandler):
    # XXX would be nice to have pluggable cache strategies
    # XXX this stuff is definitely not thread safe
    def __init__(self):
        self.cache = {}
        self.timeout = {}
        self.soonest = 0
        self.delay = 60
        self.max_conns = 16

    def setTimeout(self, t):
        self.delay = t

    def setMaxConns(self, m):
        self.max_conns = m

    def connect_ftp(self, user, passwd, host, port, dirs, timeout):
        key = user, host, port, '/'.join(dirs), timeout
        if key in self.cache:
            self.timeout[key] = time.time() + self.delay
        else:
            self.cache[key] = ftpwrapper(user, passwd, host, port,
                                         dirs, timeout)
            self.timeout[key] = time.time() + self.delay
        self.check_cache()
        return self.cache[key]

    def check_cache(self):
        # first check for old ones
        t = time.time()
        if self.soonest <= t:
            for k, v in list(self.timeout.items()):
                if v < t:
                    self.cache[k].close()
                    del self.cache[k]
                    del self.timeout[k]
        self.soonest = min(list(self.timeout.values()))

        # then check the size
        if len(self.cache) == self.max_conns:
            for k, v in list(self.timeout.items()):
                if v == self.soonest:
                    del self.cache[k]
                    del self.timeout[k]
                    break
            self.soonest = min(list(self.timeout.values()))

    def clear_cache(self):
        for conn in self.cache.values():
            conn.close()
        self.cache.clear()
        self.timeout.clear()

class DataHandler(BaseHandler):
    def data_open(self, req):
        # data URLs as specified in RFC 2397.
        #
        # ignores POSTed data
        #
        # syntax:
        # dataurl   := "data:" [ mediatype ] [ ";base64" ] "," data
        # mediatype := [ type "/" subtype ] *( ";" parameter )
        # data      := *urlchar
        # parameter := attribute "=" value
        url = req.full_url

        scheme, data = url.split(":",1)
        mediatype, data = data.split(",",1)

        # even base64 encoded data URLs might be quoted so unquote in any case:
        data = unquote_to_bytes(data)
        if mediatype.endswith(";base64"):
            data = base64.decodebytes(data)
            mediatype = mediatype[:-7]

        if not mediatype:
            mediatype = "text/plain;charset=US-ASCII"

        headers = email.message_from_string("Content-type: %s\nContent-length: %d\n" %
            (mediatype, len(data)))

        return addinfourl(io.BytesIO(data), headers, url)


# Code move from the old urllib module

MAXFTPCACHE = 10        # Trim the ftp cache beyond this size

# Helper for non-unix systems
if os.name == 'nt':
    from nturl2path import url2pathname, pathname2url
else:
    def url2pathname(pathname):
        """OS-specific conversion from a relative URL of the 'file' scheme
        to a file system path; not recommended for general use."""
        return unquote(pathname)

    def pathname2url(pathname):
        """OS-specific conversion from a file system path to a relative URL
        of the 'file' scheme; not recommended for general use."""
        return quote(pathname)

# This really consists of two pieces:
# (1) a class which handles opening of all sorts of URLs
#     (plus assorted utilities etc.)
# (2) a set of functions for parsing URLs
# XXX Should these be separated out into different modules?


ftpcache = {}
class URLopener:
    """Class to open URLs.
    This is a class rather than just a subroutine because we may need
    more than one set of global protocol-specific options.
    Note -- this is a base class for those who don't want the
    automatic handling of errors type 302 (relocated) and 401
    (authorization needed)."""

    __tempfiles = None

    version = "Python-urllib/%s" % __version__

    # Constructor
    def __init__(self, proxies=None, **x509):
        msg = "%(class)s style of invoking requests is deprecated. " \
              "Use newer urlopen functions/methods" % {'class': self.__class__.__name__}
        warnings.warn(msg, DeprecationWarning, stacklevel=3)
        if proxies is None:
            proxies = getproxies()
        assert hasattr(proxies, 'keys'), "proxies must be a mapping"
        self.proxies = proxies
        self.key_file = x509.get('key_file')
        self.cert_file = x509.get('cert_file')
        self.addheaders = [('User-Agent', self.version)]
        self.__tempfiles = []
        self.__unlink = os.unlink # See cleanup()
        self.tempcache = None
        # Undocumented feature: if you assign {} to tempcache,
        # it is used to cache files retrieved with
        # self.retrieve().  This is not enabled by default
        # since it does not work for changing documents (and I
        # haven't got the logic to check expiration headers
        # yet).
        self.ftpcache = ftpcache
        # Undocumented feature: you can use a different
        # ftp cache by assigning to the .ftpcache member;
        # in case you want logically independent URL openers
        # XXX This is not threadsafe.  Bah.

    def __del__(self):
        self.close()

    def close(self):
        self.cleanup()

    def cleanup(self):
        # This code sometimes runs when the rest of this module
        # has already been deleted, so it can't use any globals
        # or import anything.
        if self.__tempfiles:
            for file in self.__tempfiles:
                try:
                    self.__unlink(file)
                except OSError:
                    pass
            del self.__tempfiles[:]
        if self.tempcache:
            self.tempcache.clear()

    def addheader(self, *args):
        """Add a header to be used by the HTTP interface only
        e.g. u.addheader('Accept', 'sound/basic')"""
        self.addheaders.append(args)

    # External interface
    def open(self, fullurl, data=None):
        """Use URLopener().open(file) instead of open(file, 'r')."""
        fullurl = unwrap(to_bytes(fullurl))
        fullurl = quote(fullurl, safe="%/:=&?~#+!$,;'@()*[]|")
        if self.tempcache and fullurl in self.tempcache:
            filename, headers = self.tempcache[fullurl]
            fp = open(filename, 'rb')
            return addinfourl(fp, headers, fullurl)
        urltype, url = splittype(fullurl)
        if not urltype:
            urltype = 'file'
        if urltype in self.proxies:
            proxy = self.proxies[urltype]
            urltype, proxyhost = splittype(proxy)
            host, selector = splithost(proxyhost)
            url = (host, fullurl) # Signal special case to open_*()
        else:
            proxy = None
        name = 'open_' + urltype
        self.type = urltype
        name = name.replace('-', '_')
        if not hasattr(self, name):
            if proxy:
                return self.open_unknown_proxy(proxy, fullurl, data)
            else:
                return self.open_unknown(fullurl, data)
        try:
            if data is None:
                return getattr(self, name)(url)
            else:
                return getattr(self, name)(url, data)
        except (HTTPError, URLError):
            raise
        except OSError as msg:
            raise OSError('socket error', msg).with_traceback(sys.exc_info()[2])

    def open_unknown(self, fullurl, data=None):
        """Overridable interface to open unknown URL type."""
        type, url = splittype(fullurl)
        raise OSError('url error', 'unknown url type', type)

    def open_unknown_proxy(self, proxy, fullurl, data=None):
        """Overridable interface to open unknown URL type."""
        type, url = splittype(fullurl)
        raise OSError('url error', 'invalid proxy for %s' % type, proxy)

    # External interface
    def retrieve(self, url, filename=None, reporthook=None, data=None):
        """retrieve(url) returns (filename, headers) for a local object
        or (tempfilename, headers) for a remote object."""
        url = unwrap(to_bytes(url))
        if self.tempcache and url in self.tempcache:
            return self.tempcache[url]
        type, url1 = splittype(url)
        if filename is None and (not type or type == 'file'):
            try:
                fp = self.open_local_file(url1)
                hdrs = fp.info()
                fp.close()
                return url2pathname(splithost(url1)[1]), hdrs
            except OSError as msg:
                pass
        fp = self.open(url, data)
        try:
            headers = fp.info()
            if filename:
                tfp = open(filename, 'wb')
            else:
                import tempfile
                garbage, path = splittype(url)
                garbage, path = splithost(path or "")
                path, garbage = splitquery(path or "")
                path, garbage = splitattr(path or "")
                suffix = os.path.splitext(path)[1]
                (fd, filename) = tempfile.mkstemp(suffix)
                self.__tempfiles.append(filename)
                tfp = os.fdopen(fd, 'wb')
            try:
                result = filename, headers
                if self.tempcache is not None:
                    self.tempcache[url] = result
                bs = 1024*8
                size = -1
                read = 0
                blocknum = 0
                if "content-length" in headers:
                    size = int(headers["Content-Length"])
                if reporthook:
                    reporthook(blocknum, bs, size)
                while 1:
                    block = fp.read(bs)
                    if not block:
                        break
                    read += len(block)
                    tfp.write(block)
                    blocknum += 1
                    if reporthook:
                        reporthook(blocknum, bs, size)
            finally:
                tfp.close()
        finally:
            fp.close()

        # raise exception if actual size does not match content-length header
        if size >= 0 and read < size:
            raise ContentTooShortError(
                "retrieval incomplete: got only %i out of %i bytes"
                % (read, size), result)

        return result

    # Each method named open_<type> knows how to open that type of URL

    def _open_generic_http(self, connection_factory, url, data):
        """Make an HTTP connection using connection_class.

        This is an internal method that should be called from
        open_http() or open_https().

        Arguments:
        - connection_factory should take a host name and return an
          HTTPConnection instance.
        - url is the url to retrieval or a host, relative-path pair.
        - data is payload for a POST request or None.
        """

        user_passwd = None
        proxy_passwd= None
        if isinstance(url, str):
            host, selector = splithost(url)
            if host:
                user_passwd, host = splituser(host)
                host = unquote(host)
            realhost = host
        else:
            host, selector = url
            # check whether the proxy contains authorization information
            proxy_passwd, host = splituser(host)
            # now we proceed with the url we want to obtain
            urltype, rest = splittype(selector)
            url = rest
            user_passwd = None
            if urltype.lower() != 'http':
                realhost = None
            else:
                realhost, rest = splithost(rest)
                if realhost:
                    user_passwd, realhost = splituser(realhost)
                if user_passwd:
                    selector = "%s://%s%s" % (urltype, realhost, rest)
                if proxy_bypass(realhost):
                    host = realhost

        if not host: raise OSError('http error', 'no host given')

        if proxy_passwd:
            proxy_passwd = unquote(proxy_passwd)
            proxy_auth = base64.b64encode(proxy_passwd.encode()).decode('ascii')
        else:
            proxy_auth = None

        if user_passwd:
            user_passwd = unquote(user_passwd)
            auth = base64.b64encode(user_passwd.encode()).decode('ascii')
        else:
            auth = None
        http_conn = connection_factory(host)
        headers = {}
        if proxy_auth:
            headers["Proxy-Authorization"] = "Basic %s" % proxy_auth
        if auth:
            headers["Authorization"] =  "Basic %s" % auth
        if realhost:
            headers["Host"] = realhost

        # Add Connection:close as we don't support persistent connections yet.
        # This helps in closing the socket and avoiding ResourceWarning

        headers["Connection"] = "close"

        for header, value in self.addheaders:
            headers[header] = value

        if data is not None:
            headers["Content-Type"] = "application/x-www-form-urlencoded"
            http_conn.request("POST", selector, data, headers)
        else:
            http_conn.request("GET", selector, headers=headers)

        try:
            response = http_conn.getresponse()
        except http.client.BadStatusLine:
            # something went wrong with the HTTP status line
            raise URLError("http protocol error: bad status line")

        # According to RFC 2616, "2xx" code indicates that the client's
        # request was successfully received, understood, and accepted.
        if 200 <= response.status < 300:
            return addinfourl(response, response.msg, "http:" + url,
                              response.status)
        else:
            return self.http_error(
                url, response.fp,
                response.status, response.reason, response.msg, data)

    def open_http(self, url, data=None):
        """Use HTTP protocol."""
        return self._open_generic_http(http.client.HTTPConnection, url, data)

    def http_error(self, url, fp, errcode, errmsg, headers, data=None):
        """Handle http errors.

        Derived class can override this, or provide specific handlers
        named http_error_DDD where DDD is the 3-digit error code."""
        # First check if there's a specific handler for this error
        name = 'http_error_%d' % errcode
        if hasattr(self, name):
            method = getattr(self, name)
            if data is None:
                result = method(url, fp, errcode, errmsg, headers)
            else:
                result = method(url, fp, errcode, errmsg, headers, data)
            if result: return result
        return self.http_error_default(url, fp, errcode, errmsg, headers)

    def http_error_default(self, url, fp, errcode, errmsg, headers):
        """Default error handler: close the connection and raise OSError."""
        fp.close()
        raise HTTPError(url, errcode, errmsg, headers, None)

    if _have_ssl:
        def _https_connection(self, host):
            return http.client.HTTPSConnection(host,
                                           key_file=self.key_file,
                                           cert_file=self.cert_file)

        def open_https(self, url, data=None):
            """Use HTTPS protocol."""
            return self._open_generic_http(self._https_connection, url, data)

    def open_file(self, url):
        """Use local file or FTP depending on form of URL."""
        if not isinstance(url, str):
            raise URLError('file error: proxy support for file protocol currently not implemented')
        if url[:2] == '//' and url[2:3] != '/' and url[2:12].lower() != 'localhost/':
            raise ValueError("file:// scheme is supported only on localhost")
        else:
            return self.open_local_file(url)

    def open_local_file(self, url):
        """Use local file."""
        import email.utils
        import mimetypes
        host, file = splithost(url)
        localname = url2pathname(file)
        try:
            stats = os.stat(localname)
        except OSError as e:
            raise URLError(e.strerror, e.filename)
        size = stats.st_size
        modified = email.utils.formatdate(stats.st_mtime, usegmt=True)
        mtype = mimetypes.guess_type(url)[0]
        headers = email.message_from_string(
            'Content-Type: %s\nContent-Length: %d\nLast-modified: %s\n' %
            (mtype or 'text/plain', size, modified))
        if not host:
            urlfile = file
            if file[:1] == '/':
                urlfile = 'file://' + file
            return addinfourl(open(localname, 'rb'), headers, urlfile)
        host, port = splitport(host)
        if (not port
           and socket.gethostbyname(host) in ((localhost(),) + thishost())):
            urlfile = file
            if file[:1] == '/':
                urlfile = 'file://' + file
            elif file[:2] == './':
                raise ValueError("local file url may start with / or file:. Unknown url of type: %s" % url)
            return addinfourl(open(localname, 'rb'), headers, urlfile)
        raise URLError('local file error: not on local host')

    def open_ftp(self, url):
        """Use FTP protocol."""
        if not isinstance(url, str):
            raise URLError('ftp error: proxy support for ftp protocol currently not implemented')
        import mimetypes
        host, path = splithost(url)
        if not host: raise URLError('ftp error: no host given')
        host, port = splitport(host)
        user, host = splituser(host)
        if user: user, passwd = splitpasswd(user)
        else: passwd = None
        host = unquote(host)
        user = unquote(user or '')
        passwd = unquote(passwd or '')
        host = socket.gethostbyname(host)
        if not port:
            import ftplib
            port = ftplib.FTP_PORT
        else:
            port = int(port)
        path, attrs = splitattr(path)
        path = unquote(path)
        dirs = path.split('/')
        dirs, file = dirs[:-1], dirs[-1]
        if dirs and not dirs[0]: dirs = dirs[1:]
        if dirs and not dirs[0]: dirs[0] = '/'
        key = user, host, port, '/'.join(dirs)
        # XXX thread unsafe!
        if len(self.ftpcache) > MAXFTPCACHE:
            # Prune the cache, rather arbitrarily
            for k in list(self.ftpcache):
                if k != key:
                    v = self.ftpcache[k]
                    del self.ftpcache[k]
                    v.close()
        try:
            if key not in self.ftpcache:
                self.ftpcache[key] = \
                    ftpwrapper(user, passwd, host, port, dirs)
            if not file: type = 'D'
            else: type = 'I'
            for attr in attrs:
                attr, value = splitvalue(attr)
                if attr.lower() == 'type' and \
                   value in ('a', 'A', 'i', 'I', 'd', 'D'):
                    type = value.upper()
            (fp, retrlen) = self.ftpcache[key].retrfile(file, type)
            mtype = mimetypes.guess_type("ftp:" + url)[0]
            headers = ""
            if mtype:
                headers += "Content-Type: %s\n" % mtype
            if retrlen is not None and retrlen >= 0:
                headers += "Content-Length: %d\n" % retrlen
            headers = email.message_from_string(headers)
            return addinfourl(fp, headers, "ftp:" + url)
        except ftperrors() as exp:
            raise URLError('ftp error %r' % exp).with_traceback(sys.exc_info()[2])

    def open_data(self, url, data=None):
        """Use "data" URL."""
        if not isinstance(url, str):
            raise URLError('data error: proxy support for data protocol currently not implemented')
        # ignore POSTed data
        #
        # syntax of data URLs:
        # dataurl   := "data:" [ mediatype ] [ ";base64" ] "," data
        # mediatype := [ type "/" subtype ] *( ";" parameter )
        # data      := *urlchar
        # parameter := attribute "=" value
        try:
            [type, data] = url.split(',', 1)
        except ValueError:
            raise OSError('data error', 'bad data URL')
        if not type:
            type = 'text/plain;charset=US-ASCII'
        semi = type.rfind(';')
        if semi >= 0 and '=' not in type[semi:]:
            encoding = type[semi+1:]
            type = type[:semi]
        else:
            encoding = ''
        msg = []
        msg.append('Date: %s'%time.strftime('%a, %d %b %Y %H:%M:%S GMT',
                                            time.gmtime(time.time())))
        msg.append('Content-type: %s' % type)
        if encoding == 'base64':
            # XXX is this encoding/decoding ok?
            data = base64.decodebytes(data.encode('ascii')).decode('latin-1')
        else:
            data = unquote(data)
        msg.append('Content-Length: %d' % len(data))
        msg.append('')
        msg.append(data)
        msg = '\n'.join(msg)
        headers = email.message_from_string(msg)
        f = io.StringIO(msg)
        #f.fileno = None     # needed for addinfourl
        return addinfourl(f, headers, url)


class FancyURLopener(URLopener):
    """Derived class with handlers for errors we can handle (perhaps)."""

    def __init__(self, *args, **kwargs):
        URLopener.__init__(self, *args, **kwargs)
        self.auth_cache = {}
        self.tries = 0
        self.maxtries = 10

    def http_error_default(self, url, fp, errcode, errmsg, headers):
        """Default error handling -- don't raise an exception."""
        return addinfourl(fp, headers, "http:" + url, errcode)

    def http_error_302(self, url, fp, errcode, errmsg, headers, data=None):
        """Error 302 -- relocated (temporarily)."""
        self.tries += 1
        if self.maxtries and self.tries >= self.maxtries:
            if hasattr(self, "http_error_500"):
                meth = self.http_error_500
            else:
                meth = self.http_error_default
            self.tries = 0
            return meth(url, fp, 500,
                        "Internal Server Error: Redirect Recursion", headers)
        result = self.redirect_internal(url, fp, errcode, errmsg, headers,
                                        data)
        self.tries = 0
        return result

    def redirect_internal(self, url, fp, errcode, errmsg, headers, data):
        if 'location' in headers:
            newurl = headers['location']
        elif 'uri' in headers:
            newurl = headers['uri']
        else:
            return
        fp.close()

        # In case the server sent a relative URL, join with original:
        newurl = urljoin(self.type + ":" + url, newurl)

        urlparts = urlparse(newurl)

        # For security reasons, we don't allow redirection to anything other
        # than http, https and ftp.

        # We are using newer HTTPError with older redirect_internal method
        # This older method will get deprecated in 3.3

        if urlparts.scheme not in ('http', 'https', 'ftp', ''):
            raise HTTPError(newurl, errcode,
                            errmsg +
                            " Redirection to url '%s' is not allowed." % newurl,
                            headers, fp)

        return self.open(newurl)

    def http_error_301(self, url, fp, errcode, errmsg, headers, data=None):
        """Error 301 -- also relocated (permanently)."""
        return self.http_error_302(url, fp, errcode, errmsg, headers, data)

    def http_error_303(self, url, fp, errcode, errmsg, headers, data=None):
        """Error 303 -- also relocated (essentially identical to 302)."""
        return self.http_error_302(url, fp, errcode, errmsg, headers, data)

    def http_error_307(self, url, fp, errcode, errmsg, headers, data=None):
        """Error 307 -- relocated, but turn POST into error."""
        if data is None:
            return self.http_error_302(url, fp, errcode, errmsg, headers, data)
        else:
            return self.http_error_default(url, fp, errcode, errmsg, headers)

    def http_error_401(self, url, fp, errcode, errmsg, headers, data=None,
            retry=False):
        """Error 401 -- authentication required.
        This function supports Basic authentication only."""
        if 'www-authenticate' not in headers:
            URLopener.http_error_default(self, url, fp,
                                         errcode, errmsg, headers)
        stuff = headers['www-authenticate']
        match = re.match('[ \t]*([^ \t]+)[ \t]+realm="([^"]*)"', stuff)
        if not match:
            URLopener.http_error_default(self, url, fp,
                                         errcode, errmsg, headers)
        scheme, realm = match.groups()
        if scheme.lower() != 'basic':
            URLopener.http_error_default(self, url, fp,
                                         errcode, errmsg, headers)
        if not retry:
            URLopener.http_error_default(self, url, fp, errcode, errmsg,
                    headers)
        name = 'retry_' + self.type + '_basic_auth'
        if data is None:
            return getattr(self,name)(url, realm)
        else:
            return getattr(self,name)(url, realm, data)

    def http_error_407(self, url, fp, errcode, errmsg, headers, data=None,
            retry=False):
        """Error 407 -- proxy authentication required.
        This function supports Basic authentication only."""
        if 'proxy-authenticate' not in headers:
            URLopener.http_error_default(self, url, fp,
                                         errcode, errmsg, headers)
        stuff = headers['proxy-authenticate']
        match = re.match('[ \t]*([^ \t]+)[ \t]+realm="([^"]*)"', stuff)
        if not match:
            URLopener.http_error_default(self, url, fp,
                                         errcode, errmsg, headers)
        scheme, realm = match.groups()
        if scheme.lower() != 'basic':
            URLopener.http_error_default(self, url, fp,
                                         errcode, errmsg, headers)
        if not retry:
            URLopener.http_error_default(self, url, fp, errcode, errmsg,
                    headers)
        name = 'retry_proxy_' + self.type + '_basic_auth'
        if data is None:
            return getattr(self,name)(url, realm)
        else:
            return getattr(self,name)(url, realm, data)

    def retry_proxy_http_basic_auth(self, url, realm, data=None):
        host, selector = splithost(url)
        newurl = 'http://' + host + selector
        proxy = self.proxies['http']
        urltype, proxyhost = splittype(proxy)
        proxyhost, proxyselector = splithost(proxyhost)
        i = proxyhost.find('@') + 1
        proxyhost = proxyhost[i:]
        user, passwd = self.get_user_passwd(proxyhost, realm, i)
        if not (user or passwd): return None
        proxyhost = "%s:%s@%s" % (quote(user, safe=''),
                                  quote(passwd, safe=''), proxyhost)
        self.proxies['http'] = 'http://' + proxyhost + proxyselector
        if data is None:
            return self.open(newurl)
        else:
            return self.open(newurl, data)

    def retry_proxy_https_basic_auth(self, url, realm, data=None):
        host, selector = splithost(url)
        newurl = 'https://' + host + selector
        proxy = self.proxies['https']
        urltype, proxyhost = splittype(proxy)
        proxyhost, proxyselector = splithost(proxyhost)
        i = proxyhost.find('@') + 1
        proxyhost = proxyhost[i:]
        user, passwd = self.get_user_passwd(proxyhost, realm, i)
        if not (user or passwd): return None
        proxyhost = "%s:%s@%s" % (quote(user, safe=''),
                                  quote(passwd, safe=''), proxyhost)
        self.proxies['https'] = 'https://' + proxyhost + proxyselector
        if data is None:
            return self.open(newurl)
        else:
            return self.open(newurl, data)

    def retry_http_basic_auth(self, url, realm, data=None):
        host, selector = splithost(url)
        i = host.find('@') + 1
        host = host[i:]
        user, passwd = self.get_user_passwd(host, realm, i)
        if not (user or passwd): return None
        host = "%s:%s@%s" % (quote(user, safe=''),
                             quote(passwd, safe=''), host)
        newurl = 'http://' + host + selector
        if data is None:
            return self.open(newurl)
        else:
            return self.open(newurl, data)

    def retry_https_basic_auth(self, url, realm, data=None):
        host, selector = splithost(url)
        i = host.find('@') + 1
        host = host[i:]
        user, passwd = self.get_user_passwd(host, realm, i)
        if not (user or passwd): return None
        host = "%s:%s@%s" % (quote(user, safe=''),
                             quote(passwd, safe=''), host)
        newurl = 'https://' + host + selector
        if data is None:
            return self.open(newurl)
        else:
            return self.open(newurl, data)

    def get_user_passwd(self, host, realm, clear_cache=0):
        key = realm + '@' + host.lower()
        if key in self.auth_cache:
            if clear_cache:
                del self.auth_cache[key]
            else:
                return self.auth_cache[key]
        user, passwd = self.prompt_user_passwd(host, realm)
        if user or passwd: self.auth_cache[key] = (user, passwd)
        return user, passwd

    def prompt_user_passwd(self, host, realm):
        """Override this in a GUI environment!"""
        import getpass
        try:
            user = input("Enter username for %s at %s: " % (realm, host))
            passwd = getpass.getpass("Enter password for %s in %s at %s: " %
                (user, realm, host))
            return user, passwd
        except KeyboardInterrupt:
            print()
            return None, None


# Utility functions

_localhost = None
def localhost():
    """Return the IP address of the magic hostname 'localhost'."""
    global _localhost
    if _localhost is None:
        _localhost = socket.gethostbyname('localhost')
    return _localhost

_thishost = None
def thishost():
    """Return the IP addresses of the current host."""
    global _thishost
    if _thishost is None:
        try:
            _thishost = tuple(socket.gethostbyname_ex(socket.gethostname())[2])
        except socket.gaierror:
            _thishost = tuple(socket.gethostbyname_ex('localhost')[2])
    return _thishost

_ftperrors = None
def ftperrors():
    """Return the set of errors raised by the FTP class."""
    global _ftperrors
    if _ftperrors is None:
        import ftplib
        _ftperrors = ftplib.all_errors
    return _ftperrors

_noheaders = None
def noheaders():
    """Return an empty email Message object."""
    global _noheaders
    if _noheaders is None:
        _noheaders = email.message_from_string("")
    return _noheaders


# Utility classes

class ftpwrapper:
    """Class used by open_ftp() for cache of open FTP connections."""

    def __init__(self, user, passwd, host, port, dirs, timeout=None,
                 persistent=True):
        self.user = user
        self.passwd = passwd
        self.host = host
        self.port = port
        self.dirs = dirs
        self.timeout = timeout
        self.refcount = 0
        self.keepalive = persistent
        self.init()

    def init(self):
        import ftplib
        self.busy = 0
        self.ftp = ftplib.FTP()
        self.ftp.connect(self.host, self.port, self.timeout)
        self.ftp.login(self.user, self.passwd)
        _target = '/'.join(self.dirs)
        self.ftp.cwd(_target)

    def retrfile(self, file, type):
        import ftplib
        self.endtransfer()
        if type in ('d', 'D'): cmd = 'TYPE A'; isdir = 1
        else: cmd = 'TYPE ' + type; isdir = 0
        try:
            self.ftp.voidcmd(cmd)
        except ftplib.all_errors:
            self.init()
            self.ftp.voidcmd(cmd)
        conn = None
        if file and not isdir:
            # Try to retrieve as a file
            try:
                cmd = 'RETR ' + file
                conn, retrlen = self.ftp.ntransfercmd(cmd)
            except ftplib.error_perm as reason:
                if str(reason)[:3] != '550':
                    raise URLError('ftp error: %r' % reason).with_traceback(
                        sys.exc_info()[2])
        if not conn:
            # Set transfer mode to ASCII!
            self.ftp.voidcmd('TYPE A')
            # Try a directory listing. Verify that directory exists.
            if file:
                pwd = self.ftp.pwd()
                try:
                    try:
                        self.ftp.cwd(file)
                    except ftplib.error_perm as reason:
                        raise URLError('ftp error: %r' % reason) from reason
                finally:
                    self.ftp.cwd(pwd)
                cmd = 'LIST ' + file
            else:
                cmd = 'LIST'
            conn, retrlen = self.ftp.ntransfercmd(cmd)
        self.busy = 1

        ftpobj = addclosehook(conn.makefile('rb'), self.file_close)
        self.refcount += 1
        conn.close()
        # Pass back both a suitably decorated object and a retrieval length
        return (ftpobj, retrlen)

    def endtransfer(self):
        self.busy = 0

    def close(self):
        self.keepalive = False
        if self.refcount <= 0:
            self.real_close()

    def file_close(self):
        self.endtransfer()
        self.refcount -= 1
        if self.refcount <= 0 and not self.keepalive:
            self.real_close()

    def real_close(self):
        self.endtransfer()
        try:
            self.ftp.close()
        except ftperrors():
            pass

# Proxy handling
def getproxies_environment():
    """Return a dictionary of scheme -> proxy server URL mappings.

    Scan the environment for variables named <scheme>_proxy;
    this seems to be the standard convention.  If you need a
    different way, you can pass a proxies dictionary to the
    [Fancy]URLopener constructor.

    """
    proxies = {}
    for name, value in os.environ.items():
        name = name.lower()
        if value and name[-6:] == '_proxy':
            proxies[name[:-6]] = value
    return proxies

def proxy_bypass_environment(host):
    """Test if proxies should not be used for a particular host.

    Checks the environment for a variable named no_proxy, which should
    be a list of DNS suffixes separated by commas, or '*' for all hosts.
    """
    no_proxy = os.environ.get('no_proxy', '') or os.environ.get('NO_PROXY', '')
    # '*' is special case for always bypass
    if no_proxy == '*':
        return 1
    # strip port off host
    hostonly, port = splitport(host)
    # check if the host ends with any of the DNS suffixes
    no_proxy_list = [proxy.strip() for proxy in no_proxy.split(',')]
    for name in no_proxy_list:
        if name and (hostonly.endswith(name) or host.endswith(name)):
            return 1
    # otherwise, don't bypass
    return 0


# This code tests an OSX specific data structure but is testable on all
# platforms
def _proxy_bypass_macosx_sysconf(host, proxy_settings):
    """
    Return True iff this host shouldn't be accessed using a proxy

    This function uses the MacOSX framework SystemConfiguration
    to fetch the proxy information.

    proxy_settings come from _scproxy._get_proxy_settings or get mocked ie:
    { 'exclude_simple': bool,
      'exceptions': ['foo.bar', '*.bar.com', '127.0.0.1', '10.1', '10.0/16']
    }
    """
    from fnmatch import fnmatch

    hostonly, port = splitport(host)

    def ip2num(ipAddr):
        parts = ipAddr.split('.')
        parts = list(map(int, parts))
        if len(parts) != 4:
            parts = (parts + [0, 0, 0, 0])[:4]
        return (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8) | parts[3]

    # Check for simple host names:
    if '.' not in host:
        if proxy_settings['exclude_simple']:
            return True

    hostIP = None

    for value in proxy_settings.get('exceptions', ()):
        # Items in the list are strings like these: *.local, 169.254/16
        if not value: continue

        m = re.match(r"(\d+(?:\.\d+)*)(/\d+)?", value)
        if m is not None:
            if hostIP is None:
                try:
                    hostIP = socket.gethostbyname(hostonly)
                    hostIP = ip2num(hostIP)
                except OSError:
                    continue

            base = ip2num(m.group(1))
            mask = m.group(2)
            if mask is None:
                mask = 8 * (m.group(1).count('.') + 1)
            else:
                mask = int(mask[1:])
            mask = 32 - mask

            if (hostIP >> mask) == (base >> mask):
                return True

        elif fnmatch(host, value):
            return True

    return False


if sys.platform == 'darwin':
    from _scproxy import _get_proxy_settings, _get_proxies

    def proxy_bypass_macosx_sysconf(host):
        proxy_settings = _get_proxy_settings()
        return _proxy_bypass_macosx_sysconf(host, proxy_settings)

    def getproxies_macosx_sysconf():
        """Return a dictionary of scheme -> proxy server URL mappings.

        This function uses the MacOSX framework SystemConfiguration
        to fetch the proxy information.
        """
        return _get_proxies()



    def proxy_bypass(host):
        if getproxies_environment():
            return proxy_bypass_environment(host)
        else:
            return proxy_bypass_macosx_sysconf(host)

    def getproxies():
        return getproxies_environment() or getproxies_macosx_sysconf()


elif os.name == 'nt':
    def getproxies_registry():
        """Return a dictionary of scheme -> proxy server URL mappings.

        Win32 uses the registry to store proxies.

        """
        proxies = {}
        try:
            import winreg
        except ImportError:
            # Std module, so should be around - but you never know!
            return proxies
        try:
            internetSettings = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
                r'Software\Microsoft\Windows\CurrentVersion\Internet Settings')
            proxyEnable = winreg.QueryValueEx(internetSettings,
                                               'ProxyEnable')[0]
            if proxyEnable:
                # Returned as Unicode but problems if not converted to ASCII
                proxyServer = str(winreg.QueryValueEx(internetSettings,
                                                       'ProxyServer')[0])
                if '=' in proxyServer:
                    # Per-protocol settings
                    for p in proxyServer.split(';'):
                        protocol, address = p.split('=', 1)
                        # See if address has a type:// prefix
                        if not re.match('^([^/:]+)://', address):
                            address = '%s://%s' % (protocol, address)
                        proxies[protocol] = address
                else:
                    # Use one setting for all protocols
                    if proxyServer[:5] == 'http:':
                        proxies['http'] = proxyServer
                    else:
                        proxies['http'] = 'http://%s' % proxyServer
                        proxies['https'] = 'https://%s' % proxyServer
                        proxies['ftp'] = 'ftp://%s' % proxyServer
            internetSettings.Close()
        except (OSError, ValueError, TypeError):
            # Either registry key not found etc, or the value in an
            # unexpected format.
            # proxies already set up to be empty so nothing to do
            pass
        return proxies

    def getproxies():
        """Return a dictionary of scheme -> proxy server URL mappings.

        Returns settings gathered from the environment, if specified,
        or the registry.

        """
        return getproxies_environment() or getproxies_registry()

    def proxy_bypass_registry(host):
        try:
            import winreg
        except ImportError:
            # Std modules, so should be around - but you never know!
            return 0
        try:
            internetSettings = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
                r'Software\Microsoft\Windows\CurrentVersion\Internet Settings')
            proxyEnable = winreg.QueryValueEx(internetSettings,
                                               'ProxyEnable')[0]
            proxyOverride = str(winreg.QueryValueEx(internetSettings,
                                                     'ProxyOverride')[0])
            # ^^^^ Returned as Unicode but problems if not converted to ASCII
        except OSError:
            return 0
        if not proxyEnable or not proxyOverride:
            return 0
        # try to make a host list from name and IP address.
        rawHost, port = splitport(host)
        host = [rawHost]
        try:
            addr = socket.gethostbyname(rawHost)
            if addr != rawHost:
                host.append(addr)
        except OSError:
            pass
        try:
            fqdn = socket.getfqdn(rawHost)
            if fqdn != rawHost:
                host.append(fqdn)
        except OSError:
            pass
        # make a check value list from the registry entry: replace the
        # '<local>' string by the localhost entry and the corresponding
        # canonical entry.
        proxyOverride = proxyOverride.split(';')
        # now check if we match one of the registry values.
        for test in proxyOverride:
            if test == '<local>':
                if '.' not in rawHost:
                    return 1
            test = test.replace(".", r"\.")     # mask dots
            test = test.replace("*", r".*")     # change glob sequence
            test = test.replace("?", r".")      # change glob char
            for val in host:
                if re.match(test, val, re.I):
                    return 1
        return 0

    def proxy_bypass(host):
        """Return a dictionary of scheme -> proxy server URL mappings.

        Returns settings gathered from the environment, if specified,
        or the registry.

        """
        if getproxies_environment():
            return proxy_bypass_environment(host)
        else:
            return proxy_bypass_registry(host)

else:
    # By default use environment variables
    getproxies = getproxies_environment
    proxy_bypass = proxy_bypass_environment
                   usr/lib/python3.4/urllib/response.py                                                                0100644 0000000 0000000 00000004214 12415221640 016071  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Response classes used by urllib.

The base class, addbase, defines a minimal file-like interface,
including read() and readline().  The typical response object is an
addinfourl instance, which defines an info() method that returns
headers and a geturl() method that returns the url.
"""

import tempfile

__all__ = ['addbase', 'addclosehook', 'addinfo', 'addinfourl']


class addbase(tempfile._TemporaryFileWrapper):
    """Base class for addinfo and addclosehook. Is a good idea for garbage collection."""

    # XXX Add a method to expose the timeout on the underlying socket?

    def __init__(self, fp):
        super(addbase,  self).__init__(fp, '<urllib response>', delete=False)
        # Keep reference around as this was part of the original API.
        self.fp = fp

    def __repr__(self):
        return '<%s at %r whose fp = %r>' % (self.__class__.__name__,
                                             id(self), self.file)

    def __enter__(self):
        if self.fp.closed:
            raise ValueError("I/O operation on closed file")
        return self

    def __exit__(self, type, value, traceback):
        self.close()


class addclosehook(addbase):
    """Class to add a close hook to an open file."""

    def __init__(self, fp, closehook, *hookargs):
        super(addclosehook, self).__init__(fp)
        self.closehook = closehook
        self.hookargs = hookargs

    def close(self):
        if self.closehook:
            self.closehook(*self.hookargs)
            self.closehook = None
            self.hookargs = None
        super(addclosehook, self).close()


class addinfo(addbase):
    """class to add an info() method to an open file."""

    def __init__(self, fp, headers):
        super(addinfo, self).__init__(fp)
        self.headers = headers

    def info(self):
        return self.headers


class addinfourl(addinfo):
    """class to add info() and geturl() methods to an open file."""

    def __init__(self, fp, headers, url, code=None):
        super(addinfourl, self).__init__(fp, headers)
        self.url = url
        self.code = code

    def getcode(self):
        return self.code

    def geturl(self):
        return self.url
                                                                                                                                                                                                                                                                                                                                                                                    usr/lib/python3.4/urllib/robotparser.py                                                             0100644 0000000 0000000 00000015464 12415221640 016606  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """ robotparser.py

    Copyright (C) 2000  Bastian Kleineidam

    You can choose between two licenses when using this package:
    1) GNU GPLv2
    2) PSF license for Python 2.2

    The robots.txt Exclusion Protocol is implemented as specified in
    http://www.robotstxt.org/norobots-rfc.txt
"""

import urllib.parse, urllib.request

__all__ = ["RobotFileParser"]

class RobotFileParser:
    """ This class provides a set of methods to read, parse and answer
    questions about a single robots.txt file.

    """

    def __init__(self, url=''):
        self.entries = []
        self.default_entry = None
        self.disallow_all = False
        self.allow_all = False
        self.set_url(url)
        self.last_checked = 0

    def mtime(self):
        """Returns the time the robots.txt file was last fetched.

        This is useful for long-running web spiders that need to
        check for new robots.txt files periodically.

        """
        return self.last_checked

    def modified(self):
        """Sets the time the robots.txt file was last fetched to the
        current time.

        """
        import time
        self.last_checked = time.time()

    def set_url(self, url):
        """Sets the URL referring to a robots.txt file."""
        self.url = url
        self.host, self.path = urllib.parse.urlparse(url)[1:3]

    def read(self):
        """Reads the robots.txt URL and feeds it to the parser."""
        try:
            f = urllib.request.urlopen(self.url)
        except urllib.error.HTTPError as err:
            if err.code in (401, 403):
                self.disallow_all = True
            elif err.code >= 400 and err.code < 500:
                self.allow_all = True
        else:
            raw = f.read()
            self.parse(raw.decode("utf-8").splitlines())

    def _add_entry(self, entry):
        if "*" in entry.useragents:
            # the default entry is considered last
            if self.default_entry is None:
                # the first default entry wins
                self.default_entry = entry
        else:
            self.entries.append(entry)

    def parse(self, lines):
        """Parse the input lines from a robots.txt file.

        We allow that a user-agent: line is not preceded by
        one or more blank lines.
        """
        # states:
        #   0: start state
        #   1: saw user-agent line
        #   2: saw an allow or disallow line
        state = 0
        entry = Entry()

        self.modified()
        for line in lines:
            if not line:
                if state == 1:
                    entry = Entry()
                    state = 0
                elif state == 2:
                    self._add_entry(entry)
                    entry = Entry()
                    state = 0
            # remove optional comment and strip line
            i = line.find('#')
            if i >= 0:
                line = line[:i]
            line = line.strip()
            if not line:
                continue
            line = line.split(':', 1)
            if len(line) == 2:
                line[0] = line[0].strip().lower()
                line[1] = urllib.parse.unquote(line[1].strip())
                if line[0] == "user-agent":
                    if state == 2:
                        self._add_entry(entry)
                        entry = Entry()
                    entry.useragents.append(line[1])
                    state = 1
                elif line[0] == "disallow":
                    if state != 0:
                        entry.rulelines.append(RuleLine(line[1], False))
                        state = 2
                elif line[0] == "allow":
                    if state != 0:
                        entry.rulelines.append(RuleLine(line[1], True))
                        state = 2
        if state == 2:
            self._add_entry(entry)


    def can_fetch(self, useragent, url):
        """using the parsed robots.txt decide if useragent can fetch url"""
        if self.disallow_all:
            return False
        if self.allow_all:
            return True
        # Until the robots.txt file has been read or found not
        # to exist, we must assume that no url is allowable.
        # This prevents false positives when a user erronenously
        # calls can_fetch() before calling read().
        if not self.last_checked:
            return False
        # search for given user agent matches
        # the first match counts
        parsed_url = urllib.parse.urlparse(urllib.parse.unquote(url))
        url = urllib.parse.urlunparse(('','',parsed_url.path,
            parsed_url.params,parsed_url.query, parsed_url.fragment))
        url = urllib.parse.quote(url)
        if not url:
            url = "/"
        for entry in self.entries:
            if entry.applies_to(useragent):
                return entry.allowance(url)
        # try the default entry last
        if self.default_entry:
            return self.default_entry.allowance(url)
        # agent not found ==> access granted
        return True

    def __str__(self):
        return ''.join([str(entry) + "\n" for entry in self.entries])


class RuleLine:
    """A rule line is a single "Allow:" (allowance==True) or "Disallow:"
       (allowance==False) followed by a path."""
    def __init__(self, path, allowance):
        if path == '' and not allowance:
            # an empty value means allow all
            allowance = True
        path = urllib.parse.urlunparse(urllib.parse.urlparse(path))
        self.path = urllib.parse.quote(path)
        self.allowance = allowance

    def applies_to(self, filename):
        return self.path == "*" or filename.startswith(self.path)

    def __str__(self):
        return (self.allowance and "Allow" or "Disallow") + ": " + self.path


class Entry:
    """An entry has one or more user-agents and zero or more rulelines"""
    def __init__(self):
        self.useragents = []
        self.rulelines = []

    def __str__(self):
        ret = []
        for agent in self.useragents:
            ret.extend(["User-agent: ", agent, "\n"])
        for line in self.rulelines:
            ret.extend([str(line), "\n"])
        return ''.join(ret)

    def applies_to(self, useragent):
        """check if this entry applies to the specified agent"""
        # split the name token and make it lower case
        useragent = useragent.split("/")[0].lower()
        for agent in self.useragents:
            if agent == '*':
                # we have the catch-all agent
                return True
            agent = agent.lower()
            if agent in useragent:
                return True
        return False

    def allowance(self, filename):
        """Preconditions:
        - our agent applies to this entry
        - filename is URL decoded"""
        for line in self.rulelines:
            if line.applies_to(filename):
                return line.allowance
        return True
                                                                                                                                                                                                            usr/lib/python3.4/uu.py                                                                             0100755 0000000 0000000 00000015141 12415221651 013401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python3.4

# Copyright 1994 by Lance Ellinghouse
# Cathedral City, California Republic, United States of America.
#                        All Rights Reserved
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies and that
# both that copyright notice and this permission notice appear in
# supporting documentation, and that the name of Lance Ellinghouse
# not be used in advertising or publicity pertaining to distribution
# of the software without specific, written prior permission.
# LANCE ELLINGHOUSE DISCLAIMS ALL WARRANTIES WITH REGARD TO
# THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS, IN NO EVENT SHALL LANCE ELLINGHOUSE CENTRUM BE LIABLE
# FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
# Modified by Jack Jansen, CWI, July 1995:
# - Use binascii module to do the actual line-by-line conversion
#   between ascii and binary. This results in a 1000-fold speedup. The C
#   version is still 5 times faster, though.
# - Arguments more compliant with python standard

"""Implementation of the UUencode and UUdecode functions.

encode(in_file, out_file [,name, mode])
decode(in_file [, out_file, mode])
"""

import binascii
import os
import sys

__all__ = ["Error", "encode", "decode"]

class Error(Exception):
    pass

def encode(in_file, out_file, name=None, mode=None):
    """Uuencode file"""
    #
    # If in_file is a pathname open it and change defaults
    #
    opened_files = []
    try:
        if in_file == '-':
            in_file = sys.stdin.buffer
        elif isinstance(in_file, str):
            if name is None:
                name = os.path.basename(in_file)
            if mode is None:
                try:
                    mode = os.stat(in_file).st_mode
                except AttributeError:
                    pass
            in_file = open(in_file, 'rb')
            opened_files.append(in_file)
        #
        # Open out_file if it is a pathname
        #
        if out_file == '-':
            out_file = sys.stdout.buffer
        elif isinstance(out_file, str):
            out_file = open(out_file, 'wb')
            opened_files.append(out_file)
        #
        # Set defaults for name and mode
        #
        if name is None:
            name = '-'
        if mode is None:
            mode = 0o666
        #
        # Write the data
        #
        out_file.write(('begin %o %s\n' % ((mode & 0o777), name)).encode("ascii"))
        data = in_file.read(45)
        while len(data) > 0:
            out_file.write(binascii.b2a_uu(data))
            data = in_file.read(45)
        out_file.write(b' \nend\n')
    finally:
        for f in opened_files:
            f.close()


def decode(in_file, out_file=None, mode=None, quiet=False):
    """Decode uuencoded file"""
    #
    # Open the input file, if needed.
    #
    opened_files = []
    if in_file == '-':
        in_file = sys.stdin.buffer
    elif isinstance(in_file, str):
        in_file = open(in_file, 'rb')
        opened_files.append(in_file)

    try:
        #
        # Read until a begin is encountered or we've exhausted the file
        #
        while True:
            hdr = in_file.readline()
            if not hdr:
                raise Error('No valid begin line found in input file')
            if not hdr.startswith(b'begin'):
                continue
            hdrfields = hdr.split(b' ', 2)
            if len(hdrfields) == 3 and hdrfields[0] == b'begin':
                try:
                    int(hdrfields[1], 8)
                    break
                except ValueError:
                    pass
        if out_file is None:
            # If the filename isn't ASCII, what's up with that?!?
            out_file = hdrfields[2].rstrip(b' \t\r\n\f').decode("ascii")
            if os.path.exists(out_file):
                raise Error('Cannot overwrite existing file: %s' % out_file)
        if mode is None:
            mode = int(hdrfields[1], 8)
        #
        # Open the output file
        #
        if out_file == '-':
            out_file = sys.stdout.buffer
        elif isinstance(out_file, str):
            fp = open(out_file, 'wb')
            try:
                os.path.chmod(out_file, mode)
            except AttributeError:
                pass
            out_file = fp
            opened_files.append(out_file)
        #
        # Main decoding loop
        #
        s = in_file.readline()
        while s and s.strip(b' \t\r\n\f') != b'end':
            try:
                data = binascii.a2b_uu(s)
            except binascii.Error as v:
                # Workaround for broken uuencoders by /Fredrik Lundh
                nbytes = (((s[0]-32) & 63) * 4 + 5) // 3
                data = binascii.a2b_uu(s[:nbytes])
                if not quiet:
                    sys.stderr.write("Warning: %s\n" % v)
            out_file.write(data)
            s = in_file.readline()
        if not s:
            raise Error('Truncated input file')
    finally:
        for f in opened_files:
            f.close()

def test():
    """uuencode/uudecode main program"""

    import optparse
    parser = optparse.OptionParser(usage='usage: %prog [-d] [-t] [input [output]]')
    parser.add_option('-d', '--decode', dest='decode', help='Decode (instead of encode)?', default=False, action='store_true')
    parser.add_option('-t', '--text', dest='text', help='data is text, encoded format unix-compatible text?', default=False, action='store_true')

    (options, args) = parser.parse_args()
    if len(args) > 2:
        parser.error('incorrect number of arguments')
        sys.exit(1)

    # Use the binary streams underlying stdin/stdout
    input = sys.stdin.buffer
    output = sys.stdout.buffer
    if len(args) > 0:
        input = args[0]
    if len(args) > 1:
        output = args[1]

    if options.decode:
        if options.text:
            if isinstance(output, str):
                output = open(output, 'wb')
            else:
                print(sys.argv[0], ': cannot do -t to stdout')
                sys.exit(1)
        decode(input, output)
    else:
        if options.text:
            if isinstance(input, str):
                input = open(input, 'rb')
            else:
                print(sys.argv[0], ': cannot do -t from stdin')
                sys.exit(1)
        encode(input, output)

if __name__ == '__main__':
    test()
                                                                                                                                                                                                                                                                                                                                                                                                                               usr/lib/python3.4/uuid.py                                                                           0100644 0000000 0000000 00000053663 12415221636 013731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        r"""UUID objects (universally unique identifiers) according to RFC 4122.

This module provides immutable UUID objects (class UUID) and the functions
uuid1(), uuid3(), uuid4(), uuid5() for generating version 1, 3, 4, and 5
UUIDs as specified in RFC 4122.

If all you want is a unique ID, you should probably call uuid1() or uuid4().
Note that uuid1() may compromise privacy since it creates a UUID containing
the computer's network address.  uuid4() creates a random UUID.

Typical usage:

    >>> import uuid

    # make a UUID based on the host ID and current time
    >>> uuid.uuid1()    # doctest: +SKIP
    UUID('a8098c1a-f86e-11da-bd1a-00112444be1e')

    # make a UUID using an MD5 hash of a namespace UUID and a name
    >>> uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')
    UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e')

    # make a random UUID
    >>> uuid.uuid4()    # doctest: +SKIP
    UUID('16fd2706-8baf-433b-82eb-8c7fada847da')

    # make a UUID using a SHA-1 hash of a namespace UUID and a name
    >>> uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')
    UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d')

    # make a UUID from a string of hex digits (braces and hyphens ignored)
    >>> x = uuid.UUID('{00010203-0405-0607-0809-0a0b0c0d0e0f}')

    # convert a UUID to a string of hex digits in standard form
    >>> str(x)
    '00010203-0405-0607-0809-0a0b0c0d0e0f'

    # get the raw 16 bytes of the UUID
    >>> x.bytes
    b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'

    # make a UUID from a 16-byte string
    >>> uuid.UUID(bytes=x.bytes)
    UUID('00010203-0405-0607-0809-0a0b0c0d0e0f')
"""

__author__ = 'Ka-Ping Yee <ping@zesty.ca>'

RESERVED_NCS, RFC_4122, RESERVED_MICROSOFT, RESERVED_FUTURE = [
    'reserved for NCS compatibility', 'specified in RFC 4122',
    'reserved for Microsoft compatibility', 'reserved for future definition']

int_ = int      # The built-in int type
bytes_ = bytes  # The built-in bytes type

class UUID(object):
    """Instances of the UUID class represent UUIDs as specified in RFC 4122.
    UUID objects are immutable, hashable, and usable as dictionary keys.
    Converting a UUID to a string with str() yields something in the form
    '12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts
    five possible forms: a similar string of hexadecimal digits, or a tuple
    of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
    48-bit values respectively) as an argument named 'fields', or a string
    of 16 bytes (with all the integer fields in big-endian order) as an
    argument named 'bytes', or a string of 16 bytes (with the first three
    fields in little-endian order) as an argument named 'bytes_le', or a
    single 128-bit integer as an argument named 'int'.

    UUIDs have these read-only attributes:

        bytes       the UUID as a 16-byte string (containing the six
                    integer fields in big-endian byte order)

        bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                    and time_hi_version in little-endian byte order)

        fields      a tuple of the six integer fields of the UUID,
                    which are also available as six individual attributes
                    and two derived attributes:

            time_low                the first 32 bits of the UUID
            time_mid                the next 16 bits of the UUID
            time_hi_version         the next 16 bits of the UUID
            clock_seq_hi_variant    the next 8 bits of the UUID
            clock_seq_low           the next 8 bits of the UUID
            node                    the last 48 bits of the UUID

            time                    the 60-bit timestamp
            clock_seq               the 14-bit sequence number

        hex         the UUID as a 32-character hexadecimal string

        int         the UUID as a 128-bit integer

        urn         the UUID as a URN as specified in RFC 4122

        variant     the UUID variant (one of the constants RESERVED_NCS,
                    RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

        version     the UUID version number (1 through 5, meaningful only
                    when the variant is RFC_4122)
    """

    def __init__(self, hex=None, bytes=None, bytes_le=None, fields=None,
                       int=None, version=None):
        r"""Create a UUID from either a string of 32 hexadecimal digits,
        a string of 16 bytes as the 'bytes' argument, a string of 16 bytes
        in little-endian order as the 'bytes_le' argument, a tuple of six
        integers (32-bit time_low, 16-bit time_mid, 16-bit time_hi_version,
        8-bit clock_seq_hi_variant, 8-bit clock_seq_low, 48-bit node) as
        the 'fields' argument, or a single 128-bit integer as the 'int'
        argument.  When a string of hex digits is given, curly braces,
        hyphens, and a URN prefix are all optional.  For example, these
        expressions all yield the same UUID:

        UUID('{12345678-1234-5678-1234-567812345678}')
        UUID('12345678123456781234567812345678')
        UUID('urn:uuid:12345678-1234-5678-1234-567812345678')
        UUID(bytes='\x12\x34\x56\x78'*4)
        UUID(bytes_le='\x78\x56\x34\x12\x34\x12\x78\x56' +
                      '\x12\x34\x56\x78\x12\x34\x56\x78')
        UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))
        UUID(int=0x12345678123456781234567812345678)

        Exactly one of 'hex', 'bytes', 'bytes_le', 'fields', or 'int' must
        be given.  The 'version' argument is optional; if given, the resulting
        UUID will have its variant and version set according to RFC 4122,
        overriding the given 'hex', 'bytes', 'bytes_le', 'fields', or 'int'.
        """

        if [hex, bytes, bytes_le, fields, int].count(None) != 4:
            raise TypeError('need one of hex, bytes, bytes_le, fields, or int')
        if hex is not None:
            hex = hex.replace('urn:', '').replace('uuid:', '')
            hex = hex.strip('{}').replace('-', '')
            if len(hex) != 32:
                raise ValueError('badly formed hexadecimal UUID string')
            int = int_(hex, 16)
        if bytes_le is not None:
            if len(bytes_le) != 16:
                raise ValueError('bytes_le is not a 16-char string')
            bytes = (bytes_(reversed(bytes_le[0:4])) +
                     bytes_(reversed(bytes_le[4:6])) +
                     bytes_(reversed(bytes_le[6:8])) +
                     bytes_le[8:])
        if bytes is not None:
            if len(bytes) != 16:
                raise ValueError('bytes is not a 16-char string')
            assert isinstance(bytes, bytes_), repr(bytes)
            int = int_.from_bytes(bytes, byteorder='big')
        if fields is not None:
            if len(fields) != 6:
                raise ValueError('fields is not a 6-tuple')
            (time_low, time_mid, time_hi_version,
             clock_seq_hi_variant, clock_seq_low, node) = fields
            if not 0 <= time_low < 1<<32:
                raise ValueError('field 1 out of range (need a 32-bit value)')
            if not 0 <= time_mid < 1<<16:
                raise ValueError('field 2 out of range (need a 16-bit value)')
            if not 0 <= time_hi_version < 1<<16:
                raise ValueError('field 3 out of range (need a 16-bit value)')
            if not 0 <= clock_seq_hi_variant < 1<<8:
                raise ValueError('field 4 out of range (need an 8-bit value)')
            if not 0 <= clock_seq_low < 1<<8:
                raise ValueError('field 5 out of range (need an 8-bit value)')
            if not 0 <= node < 1<<48:
                raise ValueError('field 6 out of range (need a 48-bit value)')
            clock_seq = (clock_seq_hi_variant << 8) | clock_seq_low
            int = ((time_low << 96) | (time_mid << 80) |
                   (time_hi_version << 64) | (clock_seq << 48) | node)
        if int is not None:
            if not 0 <= int < 1<<128:
                raise ValueError('int is out of range (need a 128-bit value)')
        if version is not None:
            if not 1 <= version <= 5:
                raise ValueError('illegal version number')
            # Set the variant to RFC 4122.
            int &= ~(0xc000 << 48)
            int |= 0x8000 << 48
            # Set the version number.
            int &= ~(0xf000 << 64)
            int |= version << 76
        self.__dict__['int'] = int

    def __eq__(self, other):
        if isinstance(other, UUID):
            return self.int == other.int
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, UUID):
            return self.int != other.int
        return NotImplemented

    # Q. What's the value of being able to sort UUIDs?
    # A. Use them as keys in a B-Tree or similar mapping.

    def __lt__(self, other):
        if isinstance(other, UUID):
            return self.int < other.int
        return NotImplemented

    def __gt__(self, other):
        if isinstance(other, UUID):
            return self.int > other.int
        return NotImplemented

    def __le__(self, other):
        if isinstance(other, UUID):
            return self.int <= other.int
        return NotImplemented

    def __ge__(self, other):
        if isinstance(other, UUID):
            return self.int >= other.int
        return NotImplemented

    def __hash__(self):
        return hash(self.int)

    def __int__(self):
        return self.int

    def __repr__(self):
        return 'UUID(%r)' % str(self)

    def __setattr__(self, name, value):
        raise TypeError('UUID objects are immutable')

    def __str__(self):
        hex = '%032x' % self.int
        return '%s-%s-%s-%s-%s' % (
            hex[:8], hex[8:12], hex[12:16], hex[16:20], hex[20:])

    @property
    def bytes(self):
        bytes = bytearray()
        for shift in range(0, 128, 8):
            bytes.insert(0, (self.int >> shift) & 0xff)
        return bytes_(bytes)

    @property
    def bytes_le(self):
        bytes = self.bytes
        return (bytes_(reversed(bytes[0:4])) +
                bytes_(reversed(bytes[4:6])) +
                bytes_(reversed(bytes[6:8])) +
                bytes[8:])

    @property
    def fields(self):
        return (self.time_low, self.time_mid, self.time_hi_version,
                self.clock_seq_hi_variant, self.clock_seq_low, self.node)

    @property
    def time_low(self):
        return self.int >> 96

    @property
    def time_mid(self):
        return (self.int >> 80) & 0xffff

    @property
    def time_hi_version(self):
        return (self.int >> 64) & 0xffff

    @property
    def clock_seq_hi_variant(self):
        return (self.int >> 56) & 0xff

    @property
    def clock_seq_low(self):
        return (self.int >> 48) & 0xff

    @property
    def time(self):
        return (((self.time_hi_version & 0x0fff) << 48) |
                (self.time_mid << 32) | self.time_low)

    @property
    def clock_seq(self):
        return (((self.clock_seq_hi_variant & 0x3f) << 8) |
                self.clock_seq_low)

    @property
    def node(self):
        return self.int & 0xffffffffffff

    @property
    def hex(self):
        return '%032x' % self.int

    @property
    def urn(self):
        return 'urn:uuid:' + str(self)

    @property
    def variant(self):
        if not self.int & (0x8000 << 48):
            return RESERVED_NCS
        elif not self.int & (0x4000 << 48):
            return RFC_4122
        elif not self.int & (0x2000 << 48):
            return RESERVED_MICROSOFT
        else:
            return RESERVED_FUTURE

    @property
    def version(self):
        # The version bits are only meaningful for RFC 4122 UUIDs.
        if self.variant == RFC_4122:
            return int((self.int >> 76) & 0xf)

def _find_mac(command, args, hw_identifiers, get_index):
    import os, shutil
    executable = shutil.which(command)
    if executable is None:
        path = os.pathsep.join(('/sbin', '/usr/sbin'))
        executable = shutil.which(command, path=path)
        if executable is None:
            return None

    try:
        # LC_ALL to ensure English output, 2>/dev/null to prevent output on
        # stderr (Note: we don't have an example where the words we search for
        # are actually localized, but in theory some system could do so.)
        cmd = 'LC_ALL=C %s %s 2>/dev/null' % (executable, args)
        with os.popen(cmd) as pipe:
            for line in pipe:
                words = line.lower().split()
                for i in range(len(words)):
                    if words[i] in hw_identifiers:
                        try:
                            return int(
                                words[get_index(i)].replace(':', ''), 16)
                        except (ValueError, IndexError):
                            # Virtual interfaces, such as those provided by
                            # VPNs, do not have a colon-delimited MAC address
                            # as expected, but a 16-byte HWAddr separated by
                            # dashes. These should be ignored in favor of a
                            # real MAC address
                            pass
    except OSError:
        pass

def _ifconfig_getnode():
    """Get the hardware address on Unix by running ifconfig."""

    # This works on Linux ('' or '-a'), Tru64 ('-av'), but not all Unixes.
    for args in ('', '-a', '-av'):
        mac = _find_mac('ifconfig', args, ['hwaddr', 'ether'], lambda i: i+1)
        if mac:
            return mac

    import socket
    ip_addr = socket.gethostbyname(socket.gethostname())

    # Try getting the MAC addr from arp based on our IP address (Solaris).
    mac = _find_mac('arp', '-an', [ip_addr], lambda i: -1)
    if mac:
        return mac

    # This might work on HP-UX.
    mac = _find_mac('lanscan', '-ai', ['lan0'], lambda i: 0)
    if mac:
        return mac

    return None

def _ipconfig_getnode():
    """Get the hardware address on Windows by running ipconfig.exe."""
    import os, re
    dirs = ['', r'c:\windows\system32', r'c:\winnt\system32']
    try:
        import ctypes
        buffer = ctypes.create_string_buffer(300)
        ctypes.windll.kernel32.GetSystemDirectoryA(buffer, 300)
        dirs.insert(0, buffer.value.decode('mbcs'))
    except:
        pass
    for dir in dirs:
        try:
            pipe = os.popen(os.path.join(dir, 'ipconfig') + ' /all')
        except OSError:
            continue
        with pipe:
            for line in pipe:
                value = line.split(':')[-1].strip().lower()
                if re.match('([0-9a-f][0-9a-f]-){5}[0-9a-f][0-9a-f]', value):
                    return int(value.replace('-', ''), 16)

def _netbios_getnode():
    """Get the hardware address on Windows using NetBIOS calls.
    See http://support.microsoft.com/kb/118623 for details."""
    import win32wnet, netbios
    ncb = netbios.NCB()
    ncb.Command = netbios.NCBENUM
    ncb.Buffer = adapters = netbios.LANA_ENUM()
    adapters._pack()
    if win32wnet.Netbios(ncb) != 0:
        return
    adapters._unpack()
    for i in range(adapters.length):
        ncb.Reset()
        ncb.Command = netbios.NCBRESET
        ncb.Lana_num = ord(adapters.lana[i])
        if win32wnet.Netbios(ncb) != 0:
            continue
        ncb.Reset()
        ncb.Command = netbios.NCBASTAT
        ncb.Lana_num = ord(adapters.lana[i])
        ncb.Callname = '*'.ljust(16)
        ncb.Buffer = status = netbios.ADAPTER_STATUS()
        if win32wnet.Netbios(ncb) != 0:
            continue
        status._unpack()
        bytes = status.adapter_address
        return ((bytes[0]<<40) + (bytes[1]<<32) + (bytes[2]<<24) +
                (bytes[3]<<16) + (bytes[4]<<8) + bytes[5])

# Thanks to Thomas Heller for ctypes and for his help with its use here.

# If ctypes is available, use it to find system routines for UUID generation.
# XXX This makes the module non-thread-safe!
_uuid_generate_random = _uuid_generate_time = _UuidCreate = None
try:
    import ctypes, ctypes.util

    # The uuid_generate_* routines are provided by libuuid on at least
    # Linux and FreeBSD, and provided by libc on Mac OS X.
    for libname in ['uuid', 'c']:
        try:
            lib = ctypes.CDLL(ctypes.util.find_library(libname))
        except:
            continue
        if hasattr(lib, 'uuid_generate_random'):
            _uuid_generate_random = lib.uuid_generate_random
        if hasattr(lib, 'uuid_generate_time'):
            _uuid_generate_time = lib.uuid_generate_time
            if _uuid_generate_random is not None:
                break  # found everything we were looking for

    # The uuid_generate_* functions are broken on MacOS X 10.5, as noted
    # in issue #8621 the function generates the same sequence of values
    # in the parent process and all children created using fork (unless
    # those children use exec as well).
    #
    # Assume that the uuid_generate functions are broken from 10.5 onward,
    # the test can be adjusted when a later version is fixed.
    import sys
    if sys.platform == 'darwin':
        import os
        if int(os.uname().release.split('.')[0]) >= 9:
            _uuid_generate_random = _uuid_generate_time = None

    # On Windows prior to 2000, UuidCreate gives a UUID containing the
    # hardware address.  On Windows 2000 and later, UuidCreate makes a
    # random UUID and UuidCreateSequential gives a UUID containing the
    # hardware address.  These routines are provided by the RPC runtime.
    # NOTE:  at least on Tim's WinXP Pro SP2 desktop box, while the last
    # 6 bytes returned by UuidCreateSequential are fixed, they don't appear
    # to bear any relationship to the MAC address of any network device
    # on the box.
    try:
        lib = ctypes.windll.rpcrt4
    except:
        lib = None
    _UuidCreate = getattr(lib, 'UuidCreateSequential',
                          getattr(lib, 'UuidCreate', None))
except:
    pass

def _unixdll_getnode():
    """Get the hardware address on Unix using ctypes."""
    _buffer = ctypes.create_string_buffer(16)
    _uuid_generate_time(_buffer)
    return UUID(bytes=bytes_(_buffer.raw)).node

def _windll_getnode():
    """Get the hardware address on Windows using ctypes."""
    _buffer = ctypes.create_string_buffer(16)
    if _UuidCreate(_buffer) == 0:
        return UUID(bytes=bytes_(_buffer.raw)).node

def _random_getnode():
    """Get a random node ID, with eighth bit set as suggested by RFC 4122."""
    import random
    return random.randrange(0, 1<<48) | 0x010000000000

_node = None

def getnode():
    """Get the hardware address as a 48-bit positive integer.

    The first time this runs, it may launch a separate program, which could
    be quite slow.  If all attempts to obtain the hardware address fail, we
    choose a random 48-bit number with its eighth bit set to 1 as recommended
    in RFC 4122.
    """

    global _node
    if _node is not None:
        return _node

    import sys
    if sys.platform == 'win32':
        getters = [_windll_getnode, _netbios_getnode, _ipconfig_getnode]
    else:
        getters = [_unixdll_getnode, _ifconfig_getnode]

    for getter in getters + [_random_getnode]:
        try:
            _node = getter()
        except:
            continue
        if _node is not None:
            return _node

_last_timestamp = None

def uuid1(node=None, clock_seq=None):
    """Generate a UUID from a host ID, sequence number, and the current time.
    If 'node' is not given, getnode() is used to obtain the hardware
    address.  If 'clock_seq' is given, it is used as the sequence number;
    otherwise a random 14-bit sequence number is chosen."""

    # When the system provides a version-1 UUID generator, use it (but don't
    # use UuidCreate here because its UUIDs don't conform to RFC 4122).
    if _uuid_generate_time and node is clock_seq is None:
        _buffer = ctypes.create_string_buffer(16)
        _uuid_generate_time(_buffer)
        return UUID(bytes=bytes_(_buffer.raw))

    global _last_timestamp
    import time
    nanoseconds = int(time.time() * 1e9)
    # 0x01b21dd213814000 is the number of 100-ns intervals between the
    # UUID epoch 1582-10-15 00:00:00 and the Unix epoch 1970-01-01 00:00:00.
    timestamp = int(nanoseconds/100) + 0x01b21dd213814000
    if _last_timestamp is not None and timestamp <= _last_timestamp:
        timestamp = _last_timestamp + 1
    _last_timestamp = timestamp
    if clock_seq is None:
        import random
        clock_seq = random.randrange(1<<14) # instead of stable storage
    time_low = timestamp & 0xffffffff
    time_mid = (timestamp >> 32) & 0xffff
    time_hi_version = (timestamp >> 48) & 0x0fff
    clock_seq_low = clock_seq & 0xff
    clock_seq_hi_variant = (clock_seq >> 8) & 0x3f
    if node is None:
        node = getnode()
    return UUID(fields=(time_low, time_mid, time_hi_version,
                        clock_seq_hi_variant, clock_seq_low, node), version=1)

def uuid3(namespace, name):
    """Generate a UUID from the MD5 hash of a namespace UUID and a name."""
    from hashlib import md5
    hash = md5(namespace.bytes + bytes(name, "utf-8")).digest()
    return UUID(bytes=hash[:16], version=3)

def uuid4():
    """Generate a random UUID."""

    # When the system provides a version-4 UUID generator, use it.
    if _uuid_generate_random:
        _buffer = ctypes.create_string_buffer(16)
        _uuid_generate_random(_buffer)
        return UUID(bytes=bytes_(_buffer.raw))

    # Otherwise, get randomness from urandom or the 'random' module.
    try:
        import os
        return UUID(bytes=os.urandom(16), version=4)
    except:
        import random
        bytes = bytes_(random.randrange(256) for i in range(16))
        return UUID(bytes=bytes, version=4)

def uuid5(namespace, name):
    """Generate a UUID from the SHA-1 hash of a namespace UUID and a name."""
    from hashlib import sha1
    hash = sha1(namespace.bytes + bytes(name, "utf-8")).digest()
    return UUID(bytes=hash[:16], version=5)

# The following standard UUIDs are for use with uuid3() or uuid5().

NAMESPACE_DNS = UUID('6ba7b810-9dad-11d1-80b4-00c04fd430c8')
NAMESPACE_URL = UUID('6ba7b811-9dad-11d1-80b4-00c04fd430c8')
NAMESPACE_OID = UUID('6ba7b812-9dad-11d1-80b4-00c04fd430c8')
NAMESPACE_X500 = UUID('6ba7b814-9dad-11d1-80b4-00c04fd430c8')
                                                                             usr/lib/python3.4/venv/                                                                             0040755 0000000 0000000 00000000000 13077704335 013364  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/venv/__init__.py                                                                  0100644 0000000 0000000 00000046072 12415221640 015467  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """
Virtual environment (venv) package for Python. Based on PEP 405.

Copyright (C) 2011-2014 Vinay Sajip.
Licensed to the PSF under a contributor agreement.

usage: python -m venv [-h] [--system-site-packages] [--symlinks] [--clear]
            [--upgrade]
            ENV_DIR [ENV_DIR ...]

Creates virtual Python environments in one or more target directories.

positional arguments:
  ENV_DIR               A directory to create the environment in.

optional arguments:
  -h, --help            show this help message and exit
  --system-site-packages
                        Give the virtual environment access to the system
                        site-packages dir.
  --symlinks            Attempt to symlink rather than copy.
  --clear               Delete the environment directory if it already exists.
                        If not specified and the directory exists, an error is
                        raised.
  --upgrade             Upgrade the environment directory to use this version
                        of Python, assuming Python has been upgraded in-place.
  --without-pip         Skips installing or upgrading pip in the virtual
                        environment (pip is bootstrapped by default)
"""
import logging
import os
import shutil
import subprocess
import sys
import types

logger = logging.getLogger(__name__)


class EnvBuilder:
    """
    This class exists to allow virtual environment creation to be
    customized. The constructor parameters determine the builder's
    behaviour when called upon to create a virtual environment.

    By default, the builder makes the system (global) site-packages dir
    *un*available to the created environment.

    If invoked using the Python -m option, the default is to use copying
    on Windows platforms but symlinks elsewhere. If instantiated some
    other way, the default is to *not* use symlinks.

    :param system_site_packages: If True, the system (global) site-packages
                                 dir is available to created environments.
    :param clear: If True and the target directory exists, it is deleted.
                  Otherwise, if the target directory exists, an error is
                  raised.
    :param symlinks: If True, attempt to symlink rather than copy files into
                     virtual environment.
    :param upgrade: If True, upgrade an existing virtual environment.
    :param with_pip: If True, ensure pip is installed in the virtual
                     environment
    """

    def __init__(self, system_site_packages=False, clear=False,
                 symlinks=False, upgrade=False, with_pip=False):
        self.system_site_packages = system_site_packages
        self.clear = clear
        self.symlinks = symlinks
        self.upgrade = upgrade
        self.with_pip = with_pip

    def create(self, env_dir):
        """
        Create a virtual environment in a directory.

        :param env_dir: The target directory to create an environment in.

        """
        env_dir = os.path.abspath(env_dir)
        context = self.ensure_directories(env_dir)
        self.create_configuration(context)
        self.setup_python(context)
        if self.with_pip:
            self._setup_pip(context)
        if not self.upgrade:
            self.setup_scripts(context)
            self.post_setup(context)

    def clear_directory(self, path):
        for fn in os.listdir(path):
            fn = os.path.join(path, fn)
            if os.path.islink(fn) or os.path.isfile(fn):
                os.remove(fn)
            elif os.path.isdir(fn):
                shutil.rmtree(fn)

    def ensure_directories(self, env_dir):
        """
        Create the directories for the environment.

        Returns a context object which holds paths in the environment,
        for use by subsequent logic.
        """

        def create_if_needed(d):
            if not os.path.exists(d):
                os.makedirs(d)
            elif os.path.islink(d) or os.path.isfile(d):
                raise ValueError('Unable to create directory %r' % d)

        if os.path.exists(env_dir) and self.clear:
            self.clear_directory(env_dir)
        context = types.SimpleNamespace()
        context.env_dir = env_dir
        context.env_name = os.path.split(env_dir)[1]
        context.prompt = '(%s) ' % context.env_name
        create_if_needed(env_dir)
        env = os.environ
        if sys.platform == 'darwin' and '__PYVENV_LAUNCHER__' in env:
            executable = os.environ['__PYVENV_LAUNCHER__']
        else:
            executable = sys.executable
        dirname, exename = os.path.split(os.path.abspath(executable))
        context.executable = executable
        context.python_dir = dirname
        context.python_exe = exename
        if sys.platform == 'win32':
            binname = 'Scripts'
            incpath = 'Include'
            libpath = os.path.join(env_dir, 'Lib', 'site-packages')
        else:
            binname = 'bin'
            incpath = 'include'
            libpath = os.path.join(env_dir, 'lib',
                                   'python%d.%d' % sys.version_info[:2],
                                   'site-packages')
        context.inc_path = path = os.path.join(env_dir, incpath)
        create_if_needed(path)
        create_if_needed(libpath)
        # Issue 21197: create lib64 as a symlink to lib on 64-bit non-OS X POSIX
        if ((sys.maxsize > 2**32) and (os.name == 'posix') and
            (sys.platform != 'darwin')):
            p = os.path.join(env_dir, 'lib')
            link_path = os.path.join(env_dir, 'lib64')
            if not os.path.exists(link_path):   # Issue #21643
                os.symlink(p, link_path)
        context.bin_path = binpath = os.path.join(env_dir, binname)
        context.bin_name = binname
        context.env_exe = os.path.join(binpath, exename)
        create_if_needed(binpath)
        return context

    def create_configuration(self, context):
        """
        Create a configuration file indicating where the environment's Python
        was copied from, and whether the system site-packages should be made
        available in the environment.

        :param context: The information for the environment creation request
                        being processed.
        """
        context.cfg_path = path = os.path.join(context.env_dir, 'pyvenv.cfg')
        with open(path, 'w', encoding='utf-8') as f:
            f.write('home = %s\n' % context.python_dir)
            if self.system_site_packages:
                incl = 'true'
            else:
                incl = 'false'
            f.write('include-system-site-packages = %s\n' % incl)
            f.write('version = %d.%d.%d\n' % sys.version_info[:3])

    if os.name == 'nt':
        def include_binary(self, f):
            if f.endswith(('.pyd', '.dll')):
                result = True
            else:
                result = f.startswith('python') and f.endswith('.exe')
            return result

    def symlink_or_copy(self, src, dst):
        """
        Try symlinking a file, and if that fails, fall back to copying.
        """
        force_copy = not self.symlinks
        if not force_copy:
            try:
                if not os.path.islink(dst): # can't link to itself!
                    os.symlink(src, dst)
            except Exception:   # may need to use a more specific exception
                logger.warning('Unable to symlink %r to %r', src, dst)
                force_copy = True
        if force_copy:
            shutil.copyfile(src, dst)

    def setup_python(self, context):
        """
        Set up a Python executable in the environment.

        :param context: The information for the environment creation request
                        being processed.
        """
        binpath = context.bin_path
        exename = context.python_exe
        path = context.env_exe
        copier = self.symlink_or_copy
        copier(context.executable, path)
        dirname = context.python_dir
        if os.name != 'nt':
            if not os.path.islink(path):
                os.chmod(path, 0o755)
            for suffix in ('python', 'python3'):
                path = os.path.join(binpath, suffix)
                if not os.path.exists(path):
                    # Issue 18807: make copies if
                    # symlinks are not wanted
                    copier(context.env_exe, path)
                    if not os.path.islink(path):
                        os.chmod(path, 0o755)
        else:
            subdir = 'DLLs'
            include = self.include_binary
            files = [f for f in os.listdir(dirname) if include(f)]
            for f in files:
                src = os.path.join(dirname, f)
                dst = os.path.join(binpath, f)
                if dst != context.env_exe:  # already done, above
                    copier(src, dst)
            dirname = os.path.join(dirname, subdir)
            if os.path.isdir(dirname):
                files = [f for f in os.listdir(dirname) if include(f)]
                for f in files:
                    src = os.path.join(dirname, f)
                    dst = os.path.join(binpath, f)
                    copier(src, dst)
            # copy init.tcl over
            for root, dirs, files in os.walk(context.python_dir):
                if 'init.tcl' in files:
                    tcldir = os.path.basename(root)
                    tcldir = os.path.join(context.env_dir, 'Lib', tcldir)
                    if not os.path.exists(tcldir):
                        os.makedirs(tcldir)
                    src = os.path.join(root, 'init.tcl')
                    dst = os.path.join(tcldir, 'init.tcl')
                    shutil.copyfile(src, dst)
                    break

    def _setup_pip(self, context):
        """Installs or upgrades pip in a virtual environment"""
        # We run ensurepip in isolated mode to avoid side effects from
        # environment vars, the current directory and anything else
        # intended for the global Python environment
        cmd = [context.env_exe, '-Im', 'ensurepip', '--upgrade',
                                                    '--default-pip']
        subprocess.check_output(cmd, stderr=subprocess.STDOUT)

    def setup_scripts(self, context):
        """
        Set up scripts into the created environment from a directory.

        This method installs the default scripts into the environment
        being created. You can prevent the default installation by overriding
        this method if you really need to, or if you need to specify
        a different location for the scripts to install. By default, the
        'scripts' directory in the venv package is used as the source of
        scripts to install.
        """
        path = os.path.abspath(os.path.dirname(__file__))
        path = os.path.join(path, 'scripts')
        self.install_scripts(context, path)

    def post_setup(self, context):
        """
        Hook for post-setup modification of the venv. Subclasses may install
        additional packages or scripts here, add activation shell scripts, etc.

        :param context: The information for the environment creation request
                        being processed.
        """
        pass

    def replace_variables(self, text, context):
        """
        Replace variable placeholders in script text with context-specific
        variables.

        Return the text passed in , but with variables replaced.

        :param text: The text in which to replace placeholder variables.
        :param context: The information for the environment creation request
                        being processed.
        """
        text = text.replace('__VENV_DIR__', context.env_dir)
        text = text.replace('__VENV_NAME__', context.env_name)
        text = text.replace('__VENV_PROMPT__', context.prompt)
        text = text.replace('__VENV_BIN_NAME__', context.bin_name)
        text = text.replace('__VENV_PYTHON__', context.env_exe)
        return text

    def install_scripts(self, context, path):
        """
        Install scripts into the created environment from a directory.

        :param context: The information for the environment creation request
                        being processed.
        :param path:    Absolute pathname of a directory containing script.
                        Scripts in the 'common' subdirectory of this directory,
                        and those in the directory named for the platform
                        being run on, are installed in the created environment.
                        Placeholder variables are replaced with environment-
                        specific values.
        """
        binpath = context.bin_path
        plen = len(path)
        for root, dirs, files in os.walk(path):
            if root == path: # at top-level, remove irrelevant dirs
                for d in dirs[:]:
                    if d not in ('common', os.name):
                        dirs.remove(d)
                continue # ignore files in top level
            for f in files:
                srcfile = os.path.join(root, f)
                suffix = root[plen:].split(os.sep)[2:]
                if not suffix:
                    dstdir = binpath
                else:
                    dstdir = os.path.join(binpath, *suffix)
                if not os.path.exists(dstdir):
                    os.makedirs(dstdir)
                dstfile = os.path.join(dstdir, f)
                with open(srcfile, 'rb') as f:
                    data = f.read()
                if srcfile.endswith('.exe'):
                    mode = 'wb'
                else:
                    mode = 'w'
                    try:
                        data = data.decode('utf-8')
                        data = self.replace_variables(data, context)
                    except UnicodeDecodeError as e:
                        data = None
                        logger.warning('unable to copy script %r, '
                                       'may be binary: %s', srcfile, e)
                if data is not None:
                    with open(dstfile, mode) as f:
                        f.write(data)
                    shutil.copymode(srcfile, dstfile)


def create(env_dir, system_site_packages=False, clear=False,
                    symlinks=False, with_pip=False):
    """
    Create a virtual environment in a directory.

    By default, makes the system (global) site-packages dir *un*available to
    the created environment, and uses copying rather than symlinking for files
    obtained from the source Python installation.

    :param env_dir: The target directory to create an environment in.
    :param system_site_packages: If True, the system (global) site-packages
                                 dir is available to the environment.
    :param clear: If True and the target directory exists, it is deleted.
                  Otherwise, if the target directory exists, an error is
                  raised.
    :param symlinks: If True, attempt to symlink rather than copy files into
                     virtual environment.
    :param with_pip: If True, ensure pip is installed in the virtual
                     environment
    """
    builder = EnvBuilder(system_site_packages=system_site_packages,
                         clear=clear, symlinks=symlinks, with_pip=with_pip)
    builder.create(env_dir)

def main(args=None):
    compatible = True
    if sys.version_info < (3, 3):
        compatible = False
    elif not hasattr(sys, 'base_prefix'):
        compatible = False
    if not compatible:
        raise ValueError('This script is only for use with Python >= 3.3')
    else:
        import argparse

        parser = argparse.ArgumentParser(prog=__name__,
                                         description='Creates virtual Python '
                                                     'environments in one or '
                                                     'more target '
                                                     'directories.',
                                         epilog='Once an environment has been '
                                                'created, you may wish to '
                                                'activate it, e.g. by '
                                                'sourcing an activate script '
                                                'in its bin directory.')
        parser.add_argument('dirs', metavar='ENV_DIR', nargs='+',
                            help='A directory to create the environment in.')
        parser.add_argument('--system-site-packages', default=False,
                            action='store_true', dest='system_site',
                            help='Give the virtual environment access to the '
                                 'system site-packages dir.')
        if os.name == 'nt':
            use_symlinks = False
        else:
            use_symlinks = True
        group = parser.add_mutually_exclusive_group()
        group.add_argument('--symlinks', default=use_symlinks,
                           action='store_true', dest='symlinks',
                           help='Try to use symlinks rather than copies, '
                                'when symlinks are not the default for '
                                'the platform.')
        group.add_argument('--copies', default=not use_symlinks,
                           action='store_false', dest='symlinks',
                           help='Try to use copies rather than symlinks, '
                                'even when symlinks are the default for '
                                'the platform.')
        parser.add_argument('--clear', default=False, action='store_true',
                            dest='clear', help='Delete the contents of the '
                                               'environment directory if it '
                                               'already exists, before '
                                               'environment creation.')
        parser.add_argument('--upgrade', default=False, action='store_true',
                            dest='upgrade', help='Upgrade the environment '
                                               'directory to use this version '
                                               'of Python, assuming Python '
                                               'has been upgraded in-place.')
        parser.add_argument('--without-pip', dest='with_pip',
                            default=True, action='store_false',
                            help='Skips installing or upgrading pip in the '
                                 'virtual environment (pip is bootstrapped '
                                 'by default)')
        options = parser.parse_args(args)
        if options.upgrade and options.clear:
            raise ValueError('you cannot supply --upgrade and --clear together.')
        builder = EnvBuilder(system_site_packages=options.system_site,
                             clear=options.clear,
                             symlinks=options.symlinks,
                             upgrade=options.upgrade,
                             with_pip=options.with_pip)
        for d in options.dirs:
            builder.create(d)

if __name__ == '__main__':
    rc = 1
    try:
        main()
        rc = 0
    except Exception as e:
        print('Error: %s' % e, file=sys.stderr)
    sys.exit(rc)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python3.4/venv/__main__.py                                                                  0100644 0000000 0000000 00000000221 12415221640 015432  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import sys
from . import main

rc = 1
try:
    main()
    rc = 0
except Exception as e:
    print('Error: %s' % e, file=sys.stderr)
sys.exit(rc)
                                                                                                                                                                                                                                                                                                                                                                               usr/lib/python3.4/venv/__pycache__/                                                                 0040755 0000000 0000000 00000000000 13077704335 015574  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/venv/__pycache__/__init__.cpython-34.pyc                                          0100644 0000000 0000000 00000037666 13077704335 021776  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T:L                 @   s  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z e j e  Z	 Gd d   d  Z
 d d d d d d  Z d d d	  Z e d
 k r	d Z y e   d Z Wn< e k
 r Z z e d e d e j WYd d Z [ Xn Xe j e  n  d S)a  
Virtual environment (venv) package for Python. Based on PEP 405.

Copyright (C) 2011-2014 Vinay Sajip.
Licensed to the PSF under a contributor agreement.

usage: python -m venv [-h] [--system-site-packages] [--symlinks] [--clear]
            [--upgrade]
            ENV_DIR [ENV_DIR ...]

Creates virtual Python environments in one or more target directories.

positional arguments:
  ENV_DIR               A directory to create the environment in.

optional arguments:
  -h, --help            show this help message and exit
  --system-site-packages
                        Give the virtual environment access to the system
                        site-packages dir.
  --symlinks            Attempt to symlink rather than copy.
  --clear               Delete the environment directory if it already exists.
                        If not specified and the directory exists, an error is
                        raised.
  --upgrade             Upgrade the environment directory to use this version
                        of Python, assuming Python has been upgraded in-place.
  --without-pip         Skips installing or upgrading pip in the virtual
                        environment (pip is bootstrapped by default)
    Nc               @   s   e  Z d  Z d Z d d d d d d d  Z d d   Z d d   Z d	 d
   Z d d   Z e	 j
 d k r{ d d   Z n  d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S)
EnvBuilderan  
    This class exists to allow virtual environment creation to be
    customized. The constructor parameters determine the builder's
    behaviour when called upon to create a virtual environment.

    By default, the builder makes the system (global) site-packages dir
    *un*available to the created environment.

    If invoked using the Python -m option, the default is to use copying
    on Windows platforms but symlinks elsewhere. If instantiated some
    other way, the default is to *not* use symlinks.

    :param system_site_packages: If True, the system (global) site-packages
                                 dir is available to created environments.
    :param clear: If True and the target directory exists, it is deleted.
                  Otherwise, if the target directory exists, an error is
                  raised.
    :param symlinks: If True, attempt to symlink rather than copy files into
                     virtual environment.
    :param upgrade: If True, upgrade an existing virtual environment.
    :param with_pip: If True, ensure pip is installed in the virtual
                     environment
    Fc             C   s1   | |  _  | |  _ | |  _ | |  _ | |  _ d  S)N)system_site_packagesclearsymlinksupgradewith_pip)selfr   r   r   r   r    r	   #/usr/lib/python3.4/venv/__init__.py__init__A   s
    				zEnvBuilder.__init__c             C   s~   t  j j |  } |  j |  } |  j |  |  j |  |  j rT |  j |  n  |  j sz |  j	 |  |  j
 |  n  d S)z
        Create a virtual environment in a directory.

        :param env_dir: The target directory to create an environment in.

        N)ospathabspathensure_directoriescreate_configurationsetup_pythonr   
_setup_pipr   setup_scripts
post_setup)r   env_dircontextr	   r	   r
   createI   s    		zEnvBuilder.createc             C   s   x t  j |  D]q } t  j j | |  } t  j j |  sO t  j j |  r_ t  j |  q t  j j |  r t j	 |  q q Wd  S)N)
r   listdirr   joinislinkisfileremoveisdirshutilZrmtree)r   r   fnr	   r	   r
   clear_directoryZ   s    $zEnvBuilder.clear_directoryc             C   sc  d d   } t  j j |  r7 |  j r7 |  j |  n  t j   } | | _ t  j j |  d | _	 d | j	 | _
 | |  t  j } t j d k r d | k r t  j d } n	 t j } t  j j t  j j |   \ } } | | _ | | _ | | _ t j d k r1d } d	 }	 t  j j | d
 d  }
 n8 d } d }	 t  j j | d d t j d d  d  }
 t  j j | |	  | _ } | |  | |
  t j d k rt  j d k rt j d k rt  j j | d  } t  j j | d  } t  j j |  st  j | |  qn  t  j j | |  | _ } | | _ t  j j | |  | _ | |  | S)z
        Create the directories for the environment.

        Returns a context object which holds paths in the environment,
        for use by subsequent logic.
        c             S   s]   t  j j |   s" t  j |   n7 t  j j |   sF t  j j |   rY t d |    n  d  S)NzUnable to create directory %r)r   r   existsmakedirsr   r   
ValueError)dr	   r	   r
   create_if_neededj   s    $z7EnvBuilder.ensure_directories.<locals>.create_if_needed   z(%s) darwinZ__PYVENV_LAUNCHER__Zwin32ZScriptsZIncludeLibzsite-packagesbinincludeZlibzpython%d.%dN       posixZlib64l        )r   r   r!   r   r    typesSimpleNamespacer   splitenv_namepromptenvironsysplatform
executabler   
python_dir
python_exer   version_infoZinc_pathmaxsizenamesymlinkbin_pathbin_nameenv_exe)r   r   r%   r   envr6   dirnameexenameZbinnameZincpathZlibpathr   pZ	link_pathbinpathr	   r	   r
   r   b   sN    	
		$				

	
zEnvBuilder.ensure_directoriesc             C   s   t  j j | j d  | _ } t | d d d b } | j d | j  |  j r] d } n d } | j d |  | j d	 t	 j
 d
 d   Wd
 QXd
 S)aA  
        Create a configuration file indicating where the environment's Python
        was copied from, and whether the system site-packages should be made
        available in the environment.

        :param context: The information for the environment creation request
                        being processed.
        z
pyvenv.cfgwencodingzutf-8z
home = %s
ZtrueZfalsez"include-system-site-packages = %s
zversion = %d.%d.%d
N   )r   r   r   r   Zcfg_pathopenwriter7   r   r4   r9   )r   r   r   fZinclr	   r	   r
   r      s    			zEnvBuilder.create_configurationntc             C   s:   | j  d  r d } n | j d  o3 | j  d  } | S)N.pyd.dllTpythonz.exe)rL   rM   )endswith
startswith)r   rJ   resultr	   r	   r
   include_binary   s    	zEnvBuilder.include_binaryc             C   s   |  j  } | sj y) t j j |  s8 t j | |  n  Wqj t k
 rf t j d | |  d } Yqj Xn  | r t j	 | |  n  d S)zQ
        Try symlinking a file, and if that fails, fall back to copying.
        zUnable to symlink %r to %rTN)
r   r   r   r   r<   	Exceptionloggerwarningr   copyfile)r   srcdstZ
force_copyr	   r	   r
   symlink_or_copy   s    
zEnvBuilder.symlink_or_copyc                s  | j  } | j } | j } |  j } | | j |  | j } t j d k r t j j	 |  sq t j
 | d  n  xNd D]e } t j j | |  } t j j |  sx | | j |  t j j	 |  s t j
 | d  q qx qx Wnd } |  j     f d d   t j |  D }	 xW |	 D]O }
 t j j | |
  } t j j | |
  } | | j k r| | |  qqWt j j | |  } t j j |  r  f d d   t j |  D }	 xH |	 D]= }
 t j j | |
  } t j j | |
  } | | |  qWn  x t j | j  D] \ } } }	 d	 |	 k rt j j |  } t j j | j d
 |  } t j j |  st j |  n  t j j | d	  } t j j | d	  } t j | |  PqqWd S)z
        Set up a Python executable in the environment.

        :param context: The information for the environment creation request
                        being processed.
        rK   i  rN   python3ZDLLsc                s"   g  |  ] }   |  r |  q Sr	   r	   ).0rJ   )r*   r	   r
   
<listcomp>   s   	 z+EnvBuilder.setup_python.<locals>.<listcomp>c                s"   g  |  ] }   |  r |  q Sr	   r	   )r[   rJ   )r*   r	   r
   r\      s   	 zinit.tclr(   N)zpythonrZ   )r=   r8   r?   rY   r6   r7   r   r;   r   r   chmodr   r!   rR   r   r   walkbasenamer   r"   r   rV   )r   r   rD   rB   r   ZcopierrA   suffixZsubdirfilesrJ   rW   rX   rootdirsZtcldirr	   )r*   r
   r      sP    						"""zEnvBuilder.setup_pythonc             C   s2   | j  d d d d g } t j | d t j d S)z1Installs or upgrades pip in a virtual environmentz-ImZ	ensurepipz	--upgradez--default-pipstderrN)r?   
subprocessZcheck_outputZSTDOUT)r   r   cmdr	   r	   r
   r      s    	zEnvBuilder._setup_pipc             C   sG   t  j j t  j j t   } t  j j | d  } |  j | |  d S)a  
        Set up scripts into the created environment from a directory.

        This method installs the default scripts into the environment
        being created. You can prevent the default installation by overriding
        this method if you really need to, or if you need to specify
        a different location for the scripts to install. By default, the
        'scripts' directory in the venv package is used as the source of
        scripts to install.
        ZscriptsN)r   r   r   rA   __file__r   install_scripts)r   r   r   r	   r	   r
   r     s    zEnvBuilder.setup_scriptsc             C   s   d S)a  
        Hook for post-setup modification of the venv. Subclasses may install
        additional packages or scripts here, add activation shell scripts, etc.

        :param context: The information for the environment creation request
                        being processed.
        Nr	   )r   r   r	   r	   r
   r     s    zEnvBuilder.post_setupc             C   sm   | j  d | j  } | j  d | j  } | j  d | j  } | j  d | j  } | j  d | j  } | S)ai  
        Replace variable placeholders in script text with context-specific
        variables.

        Return the text passed in , but with variables replaced.

        :param text: The text in which to replace placeholder variables.
        :param context: The information for the environment creation request
                        being processed.
        Z__VENV_DIR__Z__VENV_NAME__Z__VENV_PROMPT__Z__VENV_BIN_NAME__Z__VENV_PYTHON__)replacer   r1   r2   r>   r?   )r   textr   r	   r	   r
   replace_variables  s    zEnvBuilder.replace_variablesc             C   s!  | j  } t |  } xt j |  D]\ } } } | | k r x= | d d  D]+ } | d t j f k rQ | j |  qQ qQ Wq% n  x| D]}	 t j j | |	  }
 | | d  j t j	  d d  } | s | } n t j j | |  } t j j
 |  st j |  n  t j j | |	  } t |
 d   }	 |	 j   } Wd QX|
 j d  red } nl d } y% | j d  } |  j | |  } Wn> t k
 r} z d } t j d	 |
 |  WYd d } ~ Xn X| d k	 r t | |   }	 |	 j |  Wd QXt j |
 |  q q Wq% Wd S)
as  
        Install scripts into the created environment from a directory.

        :param context: The information for the environment creation request
                        being processed.
        :param path:    Absolute pathname of a directory containing script.
                        Scripts in the 'common' subdirectory of this directory,
                        and those in the directory named for the platform
                        being run on, are installed in the created environment.
                        Placeholder variables are replaced with environment-
                        specific values.
        NZcommonr+   rbz.exewbrE   zutf-8z+unable to copy script %r, may be binary: %s)r=   lenr   r^   r;   r   r   r   r0   sepr!   r"   rH   readrO   decoderk   UnicodeDecodeErrorrT   rU   rI   r   Zcopymode)r   r   r   rD   Zplenrb   rc   ra   r$   rJ   Zsrcfiler`   ZdstdirZdstfiledatamodeer	   r	   r
   rh   ,  sB    	&			zEnvBuilder.install_scriptsN)__name__
__module____qualname____doc__r   r   r    r   r   r   r;   rR   rY   r   r   r   r   rk   rh   r	   r	   r	   r
   r   (   s    84	
r   Fc          	   C   s2   t  d | d | d | d |  } | j |   d S)ah  
    Create a virtual environment in a directory.

    By default, makes the system (global) site-packages dir *un*available to
    the created environment, and uses copying rather than symlinking for files
    obtained from the source Python installation.

    :param env_dir: The target directory to create an environment in.
    :param system_site_packages: If True, the system (global) site-packages
                                 dir is available to the environment.
    :param clear: If True and the target directory exists, it is deleted.
                  Otherwise, if the target directory exists, an error is
                  raised.
    :param symlinks: If True, attempt to symlink rather than copy files into
                     virtual environment.
    :param with_pip: If True, ensure pip is installed in the virtual
                     environment
    r   r   r   r   N)r   r   )r   r   r   r   r   builderr	   r	   r
   r   ^  s    r   c       	      C   s(  d } t  j d, k  r d } n t t  d  s6 d } n  | sK t d   nd d  l } | j d t d d	 d
 d  } | j d d d d d d d | j d d d d d d d d d t j	 d k r d } n d } | j
   } | j d d | d d d d d d | j d d | d d d d d d  | j d! d d d d d d" d d# | j d$ d d d d d d% d d& | j d' d d( d d d d d d) | j |   } | j r| j rt d*   n  t d+ | j d" | j d | j d% | j d( | j  } x | j D] } | j |  qWd  S)-NTrG   Fbase_prefixz.This script is only for use with Python >= 3.3r   progZdescriptionzFCreates virtual Python environments in one or more target directories.Zepilogz|Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory.rc   metavarZENV_DIRnargs+helpz)A directory to create the environment in.z--system-site-packagesdefaultaction
store_truedestsystem_sitezDGive the virtual environment access to the system site-packages dir.rK   z
--symlinksr   z[Try to use symlinks rather than copies, when symlinks are not the default for the platform.z--copiesZstore_falsez\Try to use copies rather than symlinks, even when symlinks are the default for the platform.z--clearr   zcDelete the contents of the environment directory if it already exists, before environment creation.z	--upgrader   zlUpgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place.z--without-pipr   z]Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default)z1you cannot supply --upgrade and --clear together.r   )rG   rG   )r4   r9   hasattrr#   argparseArgumentParserrv   add_argumentr   r;   Zadd_mutually_exclusive_group
parse_argsr   r   r   r   r   r   rc   r   )	argsZ
compatibler   parserZuse_symlinksgroupZoptionsrz   r$   r	   r	   r
   mainv  sV    							r   __main__r&   z	Error: %sfile)ry   Zloggingr   r   re   r4   r.   Z	getLoggerrv   rT   r   r   r   ZrcrS   ru   printrd   exitr	   r	   r	   r
   <module>   s(    7D
*                                                                          usr/lib/python3.4/venv/__pycache__/__main__.cpython-34.pyc                                          0100644 0000000 0000000 00000000530 13077704335 021733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                  @   s   d  d l  Z  d d l m Z d Z y e   d  Z Wn< e k
 rq Z z e d e d e  j WYd d Z [ Xn Xe  j e  d S)    N   )mainz	Error: %sfile)	sys r   Zrc	Exceptioneprintstderrexit r   r   #/usr/lib/python3.4/venv/__main__.py<module>   s   
*                                                                                                                                                                        usr/lib/python3.4/venv/scripts/                                                                     0040755 0000000 0000000 00000000000 13077704266 015056  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/venv/scripts/posix/                                                               0040755 0000000 0000000 00000000000 13077704266 016220  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/venv/scripts/posix/activate                                                       0100644 0000000 0000000 00000004156 12415221640 017727  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # This file must be used with "source bin/activate" *from bash*
# you cannot run it directly

deactivate () {
    # reset old environment variables
    if [ -n "$_OLD_VIRTUAL_PATH" ] ; then
        PATH="$_OLD_VIRTUAL_PATH"
        export PATH
        unset _OLD_VIRTUAL_PATH
    fi
    if [ -n "$_OLD_VIRTUAL_PYTHONHOME" ] ; then
        PYTHONHOME="$_OLD_VIRTUAL_PYTHONHOME"
        export PYTHONHOME
        unset _OLD_VIRTUAL_PYTHONHOME
    fi

    # This should detect bash and zsh, which have a hash command that must
    # be called to get it to forget past commands.  Without forgetting
    # past commands the $PATH changes we made may not be respected
    if [ -n "$BASH" -o -n "$ZSH_VERSION" ] ; then
        hash -r
    fi

    if [ -n "$_OLD_VIRTUAL_PS1" ] ; then
        PS1="$_OLD_VIRTUAL_PS1"
        export PS1
        unset _OLD_VIRTUAL_PS1
    fi

    unset VIRTUAL_ENV
    if [ ! "$1" = "nondestructive" ] ; then
    # Self destruct!
        unset -f deactivate
    fi
}

# unset irrelavent variables
deactivate nondestructive

VIRTUAL_ENV="__VENV_DIR__"
export VIRTUAL_ENV

_OLD_VIRTUAL_PATH="$PATH"
PATH="$VIRTUAL_ENV/__VENV_BIN_NAME__:$PATH"
export PATH

# unset PYTHONHOME if set
# this will fail if PYTHONHOME is set to the empty string (which is bad anyway)
# could use `if (set -u; : $PYTHONHOME) ;` in bash
if [ -n "$PYTHONHOME" ] ; then
    _OLD_VIRTUAL_PYTHONHOME="$PYTHONHOME"
    unset PYTHONHOME
fi

if [ -z "$VIRTUAL_ENV_DISABLE_PROMPT" ] ; then
    _OLD_VIRTUAL_PS1="$PS1"
    if [ "x__VENV_PROMPT__" != x ] ; then
	PS1="__VENV_PROMPT__$PS1"
    else
    if [ "`basename \"$VIRTUAL_ENV\"`" = "__" ] ; then
        # special case for Aspen magic directories
        # see http://www.zetadev.com/software/aspen/
        PS1="[`basename \`dirname \"$VIRTUAL_ENV\"\``] $PS1"
    else
        PS1="(`basename \"$VIRTUAL_ENV\"`)$PS1"
    fi
    fi
    export PS1
fi

# This should detect bash and zsh, which have a hash command that must
# be called to get it to forget past commands.  Without forgetting
# past commands the $PATH changes we made may not be respected
if [ -n "$BASH" -o -n "$ZSH_VERSION" ] ; then
    hash -r
fi
                                                                                                                                                                                                                                                                                                                                                                                                                  usr/lib/python3.4/venv/scripts/posix/activate.csh                                                   0100644 0000000 0000000 00000002374 12415221640 020503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # This file must be used with "source bin/activate.csh" *from csh*.
# You cannot run it directly.
# Created by Davide Di Blasi <davidedb@gmail.com>.
# Ported to Python 3.3 venv by Andrew Svetlov <andrew.svetlov@gmail.com>

alias deactivate 'test $?_OLD_VIRTUAL_PATH != 0 && setenv PATH "$_OLD_VIRTUAL_PATH" && unset _OLD_VIRTUAL_PATH; rehash; test $?_OLD_VIRTUAL_PROMPT != 0 && set prompt="$_OLD_VIRTUAL_PROMPT" && unset _OLD_VIRTUAL_PROMPT; unsetenv VIRTUAL_ENV; test "\!:*" != "nondestructive" && unalias deactivate'

# Unset irrelavent variables.
deactivate nondestructive

setenv VIRTUAL_ENV "__VENV_DIR__"

set _OLD_VIRTUAL_PATH="$PATH"
setenv PATH "$VIRTUAL_ENV/__VENV_BIN_NAME__:$PATH"


set _OLD_VIRTUAL_PROMPT="$prompt"

if (! "$?VIRTUAL_ENV_DISABLE_PROMPT") then
    if ("__VENV_NAME__" != "") then
        set env_name = "__VENV_NAME__"
    else
        if (`basename "VIRTUAL_ENV"` == "__") then
            # special case for Aspen magic directories
            # see http://www.zetadev.com/software/aspen/
            set env_name = `basename \`dirname "$VIRTUAL_ENV"\``
        else
            set env_name = `basename "$VIRTUAL_ENV"`
        endif
    endif
    set prompt = "[$env_name] $prompt"
    unset env_name
endif

alias pydoc python -m pydoc

rehash
                                                                                                                                                                                                                                                                    usr/lib/python3.4/venv/scripts/posix/activate.fish                                                  0100644 0000000 0000000 00000004552 12415221640 020657  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        