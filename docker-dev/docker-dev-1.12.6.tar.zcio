lid,		/* cylinder high valid*/
	mATACylinderLoValid			= 1 << bATACylinderLoValid,		/* cylinder low valid*/
	mATASectorNumValid			= 1 << bATASectorNumValid,		/* sector number valid*/
	mATASectorCntValid			= 1 << bATASectorCntValid,		/* sector count valid*/
	mATAErrFeaturesValid		= 1 << bATAErrFeaturesValid,	/* error/features valid*/
	mATADataValid				= 1 << bATADataValid			/* data valid*/

} ;


enum ataFlags{
	bATAFlagQuiesce				= 20,
	bATAFlagNoIRQ				= 19,							/* bit Number of no IRQ protocol flag*/
	bATAFlag48BitLBA			= 18,
	bATAFlagDMAQueued			= 17,
	bATAFlagOverlapped			= 16,
	bATAFlagUseConfigSpeed		= 15,							/* bit number of use configured speed flag*/
	bATAFlagByteSwap			= 14,							/* bit number of byte swap flag*/
	bATAFlagIORead				= 13,							/* bit number of I/O read flag*/
	bATAFlagIOWrite				= 12,							/* bit number of I/O write flag*/
	bATAFlagTFAccessResult 		= 8,							/* bit number of get register results on command completion.*/
	bATAFlagUseDMA				= 7,							/* bit number of use DMA flag*/
	bATAFlagProtocolATAPI		= 5,							/* bit number of ATAPI protocol*/
	bATAFlagImmediate			= 1,							/* bit number of immediate flag */
	bATAFlagTFAccess			= 0,							/* bit number of TF access */

	mATAFlagQuiesce				= 1 << bATAFlagQuiesce,
	mATAFlagUseNoIRQ			= 1 << bATAFlagNoIRQ,  			/* Special purpose! Avoid using! No-IRQ, polled synchronous protocol valid only for PIO commands*/
	mATAFlag48BitLBA			= 1 << bATAFlag48BitLBA,		/* Use 48 bit extended LBA protocol on this command. Requires support from the controller.*/
	mATAFlagDMAQueued			= 1 << bATAFlagDMAQueued,		/* Use tagged dma queuing protocol on this command. Requires support from the controller.*/
	mATAFlagOverlapped			= 1 << bATAFlagOverlapped,		/* Use overllaped protocol on this command. Requires support from the controller.*/
	mATAFlagUseConfigSpeed		= 1 << bATAFlagUseConfigSpeed,  /* Use the configured interface speed = true. False = use default PIO (slow) speed. valid only for PIO commands*/
	mATAFlagByteSwap			= 1 << bATAFlagByteSwap,		/* Swap data bytes (read - after; write - before)*/
	mATAFlagIORead				= 1 << bATAFlagIORead,			/* Read (in) operation*/
	mATAFlagIOWrite				= 1 << bATAFlagIOWrite,			/* Write (out) operation*/
	mATAFlagTFAccessResult		= 1 << bATAFlagTFAccessResult,  /* get contents of TaskFile registers indicated in TFMask on command completion, even if no error*/
	mATAFlagUseDMA				= 1 << bATAFlagUseDMA,
	mATAFlagProtocolATAPI		= 1 << bATAFlagProtocolATAPI,	/* ATAPI protocol indicator*/
	mATAFlagImmediate			= 1 << bATAFlagImmediate,		/* Put command at head of queue */
	mATAFlagTFAccess			= 1 << bATAFlagTFAccess,		/* Return Taskfile on error status*/

} ;

/* The Function codes sent to controllers*/
enum ataOpcode {

	kATANoOp = 0, 
	kATAFnExecIO ,		/* Execute ATA I/O */
	kATAPIFnExecIO,		/* ATAPI I/O */
	kATAFnRegAccess ,	/* Register Access */

	kATAFnQFlush ,		/* I/O Queue flush requests for your unit number */
	kATAFnBusReset 	/* Reset ATA bus */

} ;


/* The ATA Event codes */
/* sent when calling the device driver's event handler*/
enum ataEventCode {
	kATANullEvent				= 0x00,							/* Just kidding -- nothing happened*/
	kATAOnlineEvent				= 0x01,							/* An ATA device has come online*/
	kATAOfflineEvent			= 0x02,							/* An ATA device has gone offline*/
	kATARemovedEvent			= 0x03,							/* An ATA device has been removed from the bus*/
	kATAResetEvent				= 0x04,							/* Someone gave a hard reset to the drive*/
	kATAOfflineRequest			= 0x05,							/* Someone requesting to offline the drive*/
	kATAEjectRequest			= 0x06,							/* Someone requesting to eject the drive*/
	kATAPIResetEvent			= 0x07,							/* Someone gave a ATAPI reset to the drive*/
	kATAReservedEvent			= 0x80							/* RESERVED*/
};


// These need to be combined with a new enumeration of the current ATA/ATAPI command set.
// Some opcodes are of interest to ATA controllers, since they imply special protocols 
// or handling.   Device Reset, Execute Device Diagnostics have subtle side effects that
// controllers need to be aware of, so we snoop for those commands being issued.
// the rest are here for informational purposes.

// BUG make new enum for all current ATA commands.

enum {
	kSOFTRESET	=	0x008,			// ATAPI Soft Reset command
	kPACKET		=	0x0A0,			// ATAPI Packet command
	kID_DRIVE	=	0x0A1			// ATAPI Identify drive command
};
/* ATA Command Opcode definition*/
enum {
	kATAcmdWORetry				= 0x01,							/* Without I/O retry option*/
	kATAcmdNOP					= 0x0000,						/* NOP operation - media detect*/
	kATAcmdRecal				= 0x0010,						/* Recalibrate command */
	kATAcmdRead					= 0x0020,						/* Read command */
	kATAcmdReadLong				= 0x0022,						/* Read Long command*/
	kATAcmdReadExtended			= 0x0024,						/* Read Extended (with retries)*/
	kATAcmdReadDMAExtended		= 0x0025,						/* Read DMA Extended (with retries)*/
	kATAcmdWrite				= 0x0030,						/* Write command */
	kATAcmdWriteLong			= 0x0032,						/* Write Long*/
	kATAcmdWriteExtended		= 0x0034,						/* Write Extended (with retries)*/
	kATAcmdWriteDMAExtended		= 0x0035,						/* Write DMA Extended (with retries)*/
	kATAcmdWriteVerify			= 0x003C,						/* Write verify*/
	kATAcmdReadVerify			= 0x0040,						/* Read Verify command */
	kATAcmdFormatTrack			= 0x0050,						/* Format Track command */
	kATAcmdSeek					= 0x0070,						/* Seek command */
	kATAcmdDiagnostic			= 0x0090,						/* Drive Diagnostic command */
	kATAcmdInitDrive			= 0x0091,						/* Init drive parameters command */
	kATAcmdReadMultiple			= 0x00C4,						/* Read multiple*/
	kATAcmdWriteMultiple		= 0x00C5,						/* Write multiple*/
	kATAcmdSetRWMultiple		= 0x00C6,						/* Set Multiple for Read/Write Multiple*/
	kATAcmdReadDMA				= 0x00C8,						/* Read DMA (with retries)*/
	kATAcmdWriteDMA				= 0x00CA,						/* Write DMA (with retries)*/
	kATAcmdMCAcknowledge		= 0x00DB,						/* Acknowledge media change - removable*/
	kATAcmdDoorLock				= 0x00DE,						/* Door lock*/
	kATAcmdDoorUnlock			= 0x00DF,						/* Door unlock*/
	kATAcmdStandbyImmed			= 0x00E0,						/* Standby Immediate*/
	kATAcmdIdleImmed			= 0x00E1,						/* Idle Immediate*/
	kATAcmdStandby				= 0x00E2,						/* Standby*/
	kATAcmdIdle					= 0x00E3,						/* Idle*/
	kATAcmdReadBuffer			= 0x00E4,						/* Read sector buffer command */
	kATAcmdCheckPowerMode		= 0x00E5,						/* Check power mode command	<04/04/94>*/
	kATAcmdSleep				= 0x00E6,						/* Sleep*/
	kATAcmdFlushCache			= 0x00E7,						/* Flush Cache */
	kATAcmdWriteBuffer			= 0x00E8,						/* Write sector buffer command */
	kATAcmdWriteSame			= 0x00E9,						/* Write same data to multiple sectors*/
	kATAcmdFlushCacheExtended	= 0x00EA,						/* Flush Cache Extended */
	kATAcmdDriveIdentify		= 0x00EC,						/* Identify Drive command */
	kATAcmdMediaEject			= 0x00ED,						/* Media Eject*/
	kATAcmdSetFeatures			= 0x00EF						/* Set Features*/
};

/* Set feature command opcodes*/
enum {
	kATAEnableWriteCache		= 0x02,							/*		Enable write cache*/
	kATASetTransferMode			= 0x03,							/*		Set transfer mode*/
	kATAEnableAPM				= 0x05,							/* 		Enable Advanced Power Management*/
	kATASetPIOMode				= 0x08,							/*		PIO Flow Control Tx Mode bit*/
	kATADisableWriteCache		= 0x82,							/*		disable write cache*/
	kATAEnableReadAhead			= 0xAA							/*		Read look-ahead enable*/
};

// revisit the opcode enumerations.

//////////////////////


/* task file for ata */
typedef struct ataTaskFile {

	UInt8 							ataTFFeatures;				/* <-> Error(R) or ataTFFeatures(W) register image */
	UInt8 							ataTFCount;					/* <-> Sector count/remaining */
	UInt8 							ataTFSector;				/* <-> Sector start/finish */
	UInt8 							ataTFCylLo;					/* <-> ataTFCylLo					*/
	UInt8 							ataTFCylHigh;				/* <-> ataTFCylHigh  */
	UInt8 							ataTFSDH;					/* <-> ataTFSDH register image*/
	UInt8 							ataTFCommand;				/* <-> Status(R) or Command(W) register image */

} ataTaskFile;


typedef struct ataRegisterImage {

	ataTaskFile						taskFile;
	UInt16							ataDataRegister;			/* <-> Data register. */
	UInt8 							ataAltSDevCReg;				/* <->: Alternate status(R) or Device Control(W) register image*/

} ataRegisterImage ;


typedef struct ATAPICmdPacket{

	UInt16 							atapiPacketSize;			/* Size of command packet in bytes	*/
	UInt16 							atapiCommandByte[8];		/* The command packet itself*/

}ATAPICmdPacket;



// Error and result codes:  TBD
enum {
		kATAErrUnknownType = -1,
		kATANoErr = 0,
		kATAQueueEmpty = 1,
		kATAUnknownOpcode,
		kATATimeoutErr,
		kATAInvalidDevID,
		kATAErrDevBusy,
		kATAModeNotSupported,
		kATADevIntNoCmd,
		kATADeviceError,
		kATADMAErr
};


#endif /* !_IOATATYPES_H */
                                                                                                              IOPCIATA.h                                                                                          0100644 0001750 0001750 00000014242 12567452152 034136  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/ata                                                            /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 
#ifndef _DRV_PCI_ATA_H
#define _DRV_PCI_ATA_H

#include <libkern/c++/OSObject.h>
#include <IOKit/IOTypes.h>
#include "IOATAController.h"
#include <IOKit/IOMemoryCursor.h>
#include <IOKit/IOBufferMemoryDescriptor.h>

#include <IOKit/IOInterruptEventSource.h>

/*! @class IOPCIATA
    @abstract The base class for  PCI-IDE ata controller family.
    @discussion class defining the common elements of bus-mastering PCI ATA controllers which meet or at least loosely follow the pci bus mastering pci-ide controller spec. Header doc is incomplete, but source is heavily commented.

*/



class IOPCIATA : public IOATAController
{
    OSDeclareDefaultStructors(IOPCIATA);

public:

	/*--- Overrides from IOATAController ---*/
	virtual bool init(OSDictionary * properties);
    virtual bool start( IOService* provider );

protected:

	// The DMA states: not in use, in use and running with additional passes needed,
	// in use on final pass, transfer complete, and failure
	enum ATADMAState 
	{
		// DMA state flags
		kATADMAInactive,
		kATADMAStarting,
		kATADMAActive,
		kATADMAStatus,
		kATADMAComplete,
		kATADMAError,
	
	};
	
	enum {
		// PRD flags	
		kLast_PRD =	0x8000,
		kContinue_PRD = 0,
	
	};
	
		
	enum {
		mBMCmdStartOutput = 0x01,  						// start engine to transfer from memory to device.
		mBMCmdStartInput = (1 << 3 ) | 0x01,  	// start engine to transfer from device to memory
		mBMCmdStop = 0x00,								// halt engine.
	};
	
	enum {	
		// bus master status register definitions.
		bBMStatusSimplex = 7,  	// 0 = simultaneous transactions allowed. 1 = primary and secondary busses may not be active at same time.
		bBMStatusDrv1 = 6,     	// 1 = device 1 and bus are already configured by some other software/firmware
		bBMStatusDrv0 = 5,     	// 1 = device 0 and bus are already configured by some other software/firmware
		bBMStatusInt = 2,		// 1 = device has asserted INTRQ and all data is flushed to/from memory.
		bBMStatusError = 1,		// 1 = an error in the DMA has occured. Software clears by writing 1 to this bit.
		bBMStatusActive = 0,	// 1 = DMA engine is active.
	};
	
	enum{
	
		mBMStatusSimplex = 	1 << 7,
		mBMStatusDrv1 = 	1 << 6,
		mBMStatusDrv0 = 	1 << 5,
		mBMStatusInt = 		1 << 2,
		mBMStatusError = 	1 << 1,
		mBMStatusActive = 	1
	};
		
	// the physical region descriptor used for the dma engine.
	struct PRD
	{
		UInt32	bufferPtr;		// address
		UInt16	byteCount;		// 16 bit byte count where 0x0000 = 64K
		UInt16	flags;			// 0 in flags means contine, 0x80 means stop
	};	


	// descendants of this class MUST initialize these values
	// prior to activating any DMA command.
	IOATARegPtr8 _bmCommandReg;
	IOATARegPtr8 _bmStatusReg;
	IOATARegPtr32 _bmPRDAddresReg;	
	
	// semaphore for DMA state
	UInt32	_dmaState;
	
	// table of PRD descriptors
	PRD*	_prdTable;
	IOPhysicalAddress _prdTablePhysical;	
	
	IONaturalMemoryCursor*	_DMACursor;		

	// override from IOATAController
	// activate the DMA engine as per the current command
	virtual IOReturn startDMA( void );

	// override from IOATAController
	// safely halt the DMA engine  regardless of state
	virtual IOReturn stopDMA( void );

	// allocate memory for the PRD descriptors.
	virtual bool allocDMAChannel(void);
	
	// fill CC with stop commands.
	virtual void initATADMAChains (PRD* descPtr);
	
	// fill out a PRD, respecting endianess
	virtual void setPRD(UInt8 *bffr, UInt16 count, PRD *tableElement, UInt16 end);
	
	// setup the CC with IO commands
	virtual IOReturn createChannelCommands(void);
	
	// deallocate memory for the DMA engine
	virtual bool freeDMAChannel(void);
	
	// clean up on device interrupt
	virtual IOReturn handleDeviceInterrupt(void);
	
	// activate the DMA engine
	virtual void activateDMAEngine(void);
	
	// shutdown the DMA engine
	virtual void stopDMAEngine(void);
	
	// safely suspend the DMA engine
	virtual void shutDownATADMA (void);
	
	// overrides
	virtual void free();
protected:
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the IOPCIATA class in the future.
    */
    typedef struct ExpansionData
    {
    	IOBufferMemoryDescriptor*	_prdBuffer;
    } ExpansionData;

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

private:
    OSMetaClassDeclareReservedUnused(IOPCIATA, 0);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 1);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 2);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 3);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 4);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 5);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 6);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 7);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 8);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 9);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 10);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 11);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 12);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 13);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 14);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 15);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 16);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 17);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 18);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 19);
    OSMetaClassDeclareReservedUnused(IOPCIATA, 20);
};

#endif // _DRV_PCI_ATA_H
                                                                                                                                                                                                                                                                                                                                                              audio/                                                                                              0040755 0001750 0001750 00000000000 12612224741 033120  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                BigNum128.h                                                                                         0100644 0001750 0001750 00000005614 12567452612 034721  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2012 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __BIGNUM128_H__
#define __BIGNUM128_H__

#include <libkern/OSTypes.h>
#include <stdint.h>

class U128
{
public:
	U128(uint64_t _lo = 0) : lo(_lo), hi(0)				{ };
	U128(uint64_t _hi, uint64_t _lo)	: lo(_lo), hi(_hi)	{ };
	inline bool operator==( const U128 &A ) const	 	{ return ( A.hi == hi ) && ( A.lo == lo ); }
	inline bool operator>( const U128 &A ) const		{ return ( ( A.hi > hi ) || ( ( A.hi == hi ) && ( A.lo > lo ) ) ); }
	inline bool operator<( const U128 &A ) const 		{ return !( ( A.hi > hi ) || ( ( A.hi == hi ) && ( A.lo > lo ) ) ); }

	U128 operator++( int )
	{
		if ( ++lo==0 )
			hi++;

		return *this;
	}
	
	U128 operator--( int )
	{
		if ( 0 == lo-- )
		{
			hi--;
		}
		return *this;
	}

	U128& operator=( const U128 &A )
	{
		hi = A.hi;
		lo = A.lo;
		
		return *this;
	}
	
	U128 operator+( const U128 &A ) const
	{
		U128	result(A.hi + hi, A.lo + lo);
		
		if ( ( result.lo < A.lo ) || ( result.lo < lo ) )
		{
			result.hi++;
		}
		
		return result;
	}
	
	U128& operator+=( const U128 &A )
	{
		U128	result(A.hi + hi, A.lo + lo);
		
		if ( ( result.lo < A.lo ) || ( result.lo < lo ) )
		{
			result.hi++;
		}
		
		*this = result;

		return *this;
	}

	friend U128 operator-( const U128 &A, const U128 &B )		// assumes A >= B
	{
		U128 C = A;

		C.hi -= B.hi;
		C.lo -= B.lo;

		if ( C.lo > A.lo )		 // borrow ?
		{
			C.hi--;
		}

		return C;
	}

	
	friend U128 operator<<( const U128& A, int n )
	{
		U128 res = A;
		
		while ( n-- )
		{
			res.hi <<= 1;
			res.hi |= ( ( res.lo & MSB64 ) ? 1 : 0 );
			res.lo <<= 1;
		}
		
		return res;
	}
	
	friend U128 operator>>( const U128& A, int n )
	{
		U128 res = A;

		while ( n-- )
		{
			res.lo >>= 1;
			res.lo |= ( ( res.hi & 0x1 ) ? MSB64 : 0 );
			res.hi >>= 1;
		}
		
		return res;
	}

public:

#ifdef __BIG_ENDIAN__
	uint64_t		hi;
	uint64_t		lo;
#else
	uint64_t		lo;
	uint64_t		hi;
#endif

private:
	enum { MSB64 = 0x8000000000000000ULL };
};

extern U128 UInt64mult(const uint64_t A, const uint64_t B);

#endif			//__BIGNUM128_H__





                                                                                                                    IOAudioBlitterLibDispatch.h                                                                         0100644 0001750 0001750 00000021462 12567452612 040232  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*	Copyright: 	© Copyright 2011 Apple Computer, Inc. All rights reserved.
 
 Disclaimer:	IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
 ("Apple") in consideration of your agreement to the following terms, and your
 use, installation, modification or redistribution of this Apple software
 constitutes acceptance of these terms.  If you do not agree with these terms,
 please do not use, install, modify or redistribute this Apple software.
 
 In consideration of your agreement to abide by the following terms, and subject
 to these terms, Apple grants you a personal, non-exclusive license, under Apple’s
 copyrights in this original Apple software (the "Apple Software"), to use,
 reproduce, modify and redistribute the Apple Software, with or without
 modifications, in source and/or binary forms; provided that if you redistribute
 the Apple Software in its entirety and without modifications, you must retain
 this notice and the following text and disclaimers in all such redistributions of
 the Apple Software.  Neither the name, trademarks, service marks or logos of
 Apple Computer, Inc. may be used to endorse or promote products derived from the
 Apple Software without specific prior written permission from Apple.  Except as
 expressly stated in this notice, no other rights or licenses, express or implied,
 are granted by Apple herein, including but not limited to any patent rights that
 may be infringed by your derivative works or by other works in which the Apple
 Software may be incorporated.
 
 The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
 WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
 WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
 COMBINATION WITH YOUR PRODUCTS.
 
 IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
 OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
 (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
 ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/*!
 * @header IOAudioBlitterLibDispatch
 */

#ifndef __IOAudioBlitterLibDispatch_h__
#define __IOAudioBlitterLibDispatch_h__

#include <libkern/OSTypes.h>


#pragma mark -
#pragma mark Alternate names

// Alternate names for the functions below: these explicitly specify the endianness of the integer format instead of "native"/"swap"
#if TARGET_RT_BIG_ENDIAN
#define	IOAF_BEInt16ToFloat32	IOAF_NativeInt16ToFloat32
#define	IOAF_LEInt16ToFloat32	IOAF_SwapInt16ToFloat32
#define	IOAF_BEInt24ToFloat32	IOAF_NativeInt24ToFloat32
#define	IOAF_LEInt24ToFloat32	IOAF_SwapInt24ToFloat32
#define	IOAF_BEInt32ToFloat32	IOAF_NativeInt32ToFloat32
#define	IOAF_LEInt32ToFloat32	IOAF_SwapInt32ToFloat32

#define IOAF_Float32ToBEInt16	IOAF_Float32ToNativeInt16
#define IOAF_Float32ToLEInt16	IOAF_Float32ToSwapInt16
#define IOAF_Float32ToBEInt24	IOAF_Float32ToNativeInt24
#define IOAF_Float32ToLEInt24	IOAF_Float32ToSwapInt24
#define IOAF_Float32ToBEInt32	IOAF_Float32ToNativeInt32
#define IOAF_Float32ToLEInt32	IOAF_Float32ToSwapInt32
#else
#define	IOAF_LEInt16ToFloat32	IOAF_NativeInt16ToFloat32
#define	IOAF_BEInt16ToFloat32	IOAF_SwapInt16ToFloat32
#define	IOAF_LEInt24ToFloat32	IOAF_NativeInt24ToFloat32
#define	IOAF_BEInt24ToFloat32	IOAF_SwapInt24ToFloat32
#define	IOAF_LEInt32ToFloat32	IOAF_NativeInt32ToFloat32
#define	IOAF_BEInt32ToFloat32	IOAF_SwapInt32ToFloat32

#define IOAF_Float32ToLEInt16	IOAF_Float32ToNativeInt16
#define IOAF_Float32ToBEInt16	IOAF_Float32ToSwapInt16
#define IOAF_Float32ToLEInt24	IOAF_Float32ToNativeInt24
#define IOAF_Float32ToBEInt24	IOAF_Float32ToSwapInt24
#define IOAF_Float32ToLEInt32	IOAF_Float32ToNativeInt32
#define IOAF_Float32ToBEInt32	IOAF_Float32ToSwapInt32
#endif

/*!
 * @typedef Float32
 * @abstract Convenience type that represent a 32-bit floating point number
 */
typedef float	Float32;

/*!
 * @typedef Float64
 * @abstract Convenience type that represent a 64-bit floating point number
 */
typedef double	Float64;

/*!
 * @function IOAF_NativeInt16ToFloat32
 * @abstract Converts native 16-bit integer float to 32-bit float
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_NativeInt16ToFloat32( const SInt16 *src, Float32 *dest, unsigned int count );

/*!
 * @function IOAF_SwapInt16ToFloat32
 * @abstract Converts non-native 16-bit integer float to 32-bit float
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_SwapInt16ToFloat32( const SInt16 *src, Float32 *dest, unsigned int count );

/*!
 * @function IOAF_NativeInt24ToFloat32
 * @abstract Converts native 24-bit integer float to 32-bit float
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_NativeInt24ToFloat32( const UInt8 *src, Float32 *dest, unsigned int count );

/*!
 * @function IOAF_SwapInt24ToFloat32
 * @abstract Converts non-native 24-bit integer float to 32-bit float
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_SwapInt24ToFloat32( const UInt8 *src, Float32 *dest, unsigned int count );

/*!
 * @function IOAF_NativeInt32ToFloat32
 * @abstract Converts native 32-bit integer float to 32-bit float
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_NativeInt32ToFloat32( const SInt32 *src, Float32 *dest, unsigned int count );

/*!
 * @function IOAF_SwapInt32ToFloat32
 * @abstract Converts non-native 32-bit integer float to 32-bit float
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_SwapInt32ToFloat32( const SInt32 *src, Float32 *dest, unsigned int count );

/*!
 * @function IOAF_Float32ToNativeInt16
 * @abstract Converts 32-bit floating point to native 16-bit integer
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_Float32ToNativeInt16( const Float32 *src, SInt16 *dest, unsigned int count );

/*!
 * @function IOAF_Float32ToSwapInt16
 * @abstract Converts 32-bit floating point to non-native 16-bit integer
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_Float32ToSwapInt16( const Float32 *src, SInt16 *dest, unsigned int count );

/*!
 * @function IOAF_Float32ToNativeInt24
 * @abstract Converts 32-bit floating point to native 24-bit integer
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_Float32ToNativeInt24( const Float32 *src, UInt8 *dest, unsigned int count );

/*!
 * @function IOAF_Float32ToSwapInt24
 * @abstract Converts 32-bit floating point to non-native 24-bit integer
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_Float32ToSwapInt24( const Float32 *src, UInt8 *dest, unsigned int count );

/*!
 * @function IOAF_Float32ToNativeInt32
 * @abstract Converts 32-bit floating point to native 32-bit integer
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_Float32ToNativeInt32( const Float32 *src, SInt32 *dest, unsigned int count );

/*!
 * @function IOAF_Float32ToSwapInt32
 * @abstract Converts 32-bit floating point to non-native 32-bit integer
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_Float32ToSwapInt32( const Float32 *src, SInt32 *dest, unsigned int count );

/*!
 * @function IOAF_bcopy_WriteCombine
 * @abstract An efficient bcopy from "write combine" memory to regular memory. It is safe to assume that all memory has been copied when the function has completed
 * @param src Pointer to the data to convert
 * @param dest Pointer to the converted data
 * @param count The number of items to convert
 */
extern void IOAF_bcopy_WriteCombine(const void *src, void *dest, unsigned int count );

#endif // __IOAudioBlitterLibDispatch_h__
                                                                                                                                                                                                              IOAudioControl.h                                                                                    0100644 0001750 0001750 00000102510 12567452612 036130  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOAUDIOCONTROL_H
#define _IOKIT_IOAUDIOCONTROL_H

#include <IOKit/IOService.h>
#include <AvailabilityMacros.h>
#ifndef IOAUDIOFAMILY_SELF_BUILD
#include <IOKit/audio/IOAudioEngine.h>
#else
#include "IOAudioEngine.h"
#endif

class IOAudioPort;
class OSDictionary;
class OSSet;
class IOAudioUserClient;
class IOAudioControlUserClient;
class IOWorkLoop;
class IOCommandGate;

/*!
 * @class IOAudioControl
 * @abstract Represents any controllable attribute of an IOAudioDevice.
 * @discussion An IOAudioControl instance may belong to one IOAudioPort.  Additionally, it may associated 
 *  with an IOAudioEngine as a default control for that IOAudioEngine.
 *
 *  When its value changes, it sends a notification to the CoreAudio.framework (HAL).  It also makes a call
 *  to the ValueChangeHandler.
 *
 *  The base IOAudioControl class contains a type, a value and a channel ID representing the channel(s) which 
 *  the control acts on.  It may also contain a readable format for the name of the channel as well as a 
 *  control ID that can be used to identify unique controls.  Additionally it may contain a subType and a usage.  
 *  Each type has its own set of possible subTypes.  There currently four different control types defined: 
 *  kIOAudioControlTypeLevel, kIOAudioControlTypeToggle, kIOAudioControlTypeSelector.  
 *  Each one is represented by a subclass of IOAudioControl: IOAudioLevelControl, IOAudioToggleControl, 
 *  IOAudioSelectorControl.  The level control defines a range of allowed values and has 
 *  a defined subtype of kIOAudioLevelControlSubTypeVolume used to define a volume control.  The toggle control 
 *  allows for a boolean value and has a defined subtype kIOAudioToggleControlSubTypeMute for a mute control.  The 
 *  selector control has a list of allowed selections with a value and description for each allowed selection and 
 *  has the following sub types: kIOAudioSelectorControlSubTypeOutput for an output selector and 
 *  kIOAudioSelectorControlSubTypeInput for an input selector.  See the subclass documentation for a more 
 *  complete description of each 
 * 
 *  There are enums for default channel ID values and common channel names in IOAudioTypes.h.  The channel ID 
 *  values are prefixed with 'kIOAudioControlChannelID' and the common channel names are prefixed with
 *  'kIOAudioControlChannelName'.  All of the attributes of the IOAudioControl are stored in the registry.
 *  The key used for each attribute is defined in IOAudioTypes.h with the define matching the following
 *  pattern: 'kIOAudioControl<attribute name>Key'.  For example: kIOAudioControlChannelIDKey.
 *
 *  In addition to the existing defined control types, drivers can define their own as well for other purposes.
 *
 *  Changes to the IOAudioControl's value made by the CoreAudio.framework are done through the IORegistry.  
 *  When the CoreAudio.framework initiates a value change, the control receives a setProperties() message. 
 *  The setProperties() implementation looks for the property 'IOAudioControlValue' and if present, calls 
 *  setValue() on the driver's IOWorkLoop with the new value.  The setValue() function first checks to see 
 *  if the new value is different.  If so, it calls performValueChange() to call through to the driver
 *  to make the change in the hardware.  If that call succeeds the value is changed and the new value is set
 *  in the registry.  Additionally notifications are sent to all clients that have registered for them.
 */
class IOAudioControl : public IOService
{
    friend class IOAudioPort;
    friend class IOAudioDevice;
    friend class IOAudioEngine;
    
    OSDeclareDefaultStructors(IOAudioControl)
    
public:

    /*!
     * @typedef IntValueChangeHandler
     * @abstract Handler function used to make a notification when a value is to be changed.
     * @param target Reference supplied when the handler was registered.
     * @param audioControl The IOAudioControl that is changing.
	 * @param oldValue The old value of the control.
     * @param newValue The new value the control is being changed to.
	 * @result Must return kIOReturnSuccess when the hardware is successfully updated.
     */
    typedef IOReturn (*IntValueChangeHandler)(OSObject *target, IOAudioControl *audioControl, SInt32 oldValue, SInt32 newValue ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    typedef IOReturn (*DataValueChangeHandler)(OSObject *target, IOAudioControl *audioControl, const void *oldData, UInt32 oldDataSize, const void *newData, UInt32 newDataSize ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    typedef IOReturn (*ObjectValueChangeHandler)(OSObject *target, IOAudioControl *audioControl, OSObject *oldValue, OSObject *newValue ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
protected:
    /*! @var workLoop 
        The IOWorkLoop for the audio driver - shared from the IOAudioDevice. 
    */
    IOWorkLoop 		*workLoop;
    /*! @var commandGate 
        The IOCommandGate for this control - attached to the driver's IOWorkLoop.
    */
    IOCommandGate	*commandGate;
    
    /*! @var isStarted 
        Internal state keeping track of when the IOAudioControl has been started. 
    */
    bool		isStarted;

    /*! @var controlID 
        An optional identifier that can be used to identify the control. 
    */
    UInt32 		controlID;
    /*! @var channelID 
        The ID of the channel this control affects - may be kIOAudioControlChannelIDAll if it represents all channels.
    */
    UInt32		channelID;
    
    UInt32		type;
    UInt32		subType;
    UInt32		usage;
    
    OSObject	*value;
    
    typedef enum {
        kIntValueChangeHandler,
        kDataValueChangeHandler,
        kObjectValueChangeHandler
    } ValueChangeHandlerType;
    
    ValueChangeHandlerType valueChangeHandlerType;

    union {
        IntValueChangeHandler		intHandler;
        DataValueChangeHandler		dataHandler;
        ObjectValueChangeHandler	objectHandler;
    } valueChangeHandler;
    
    OSObject	*valueChangeTarget;
    
    /*! @var clients
        A list of user clients that have requested value change notifications. 
    */ 
    OSSet		*userClients;

protected:
    struct ExpansionData {
		IOAudioEngine *				providerEngine;
		OSArray *					notificationQueue;
		UInt32						commandGateStatus;			// <rdar://8518215>
		SInt32						commandGateUsage;			// <rdar://8518215>
	};
    
    ExpansionData *reserved;
    
public:
	// OSMetaClassDeclareReservedUsed(IOAudioControl, 0);
	virtual void sendChangeNotification(UInt32 notificationType ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioControl, 1);
    /*!
	 * @function setReadOnlyFlag
     * @abstract Call this function to say that a control is read only.
	 * This call cannot be undone, so if a control is only temporarily unsetable,
	 * do not use this call but instead return an error from the control handler.
     */
	virtual void setReadOnlyFlag( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioControl, 2);
	virtual void sendQueuedNotifications(void ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioControl, 3);
    /*!
     * @function createUserClient
     * @abstract Creates a new IOAudioControlUserClient instance.
     * @discussion This function is called by newUserClient() to create a new IOAudioControlUserClient instance.  This function may be overridden by subclasses that need to add functionality
     *  to the IOAudioControlUserClient.  In that case, they must subclass IOAudioControlUserClient
     *  and return a new, initialized instance of that subclass.
	 *  A derived class that requires overriding of createUserClient should override the version with the properties
	 *  parameter for Intel targets, and without the properties parameter for PPC targets.  The #if __i386__ directive
	 *  can be used to select between the two behaviors.
     * @param task The task requesting the new user client.
     * @param securityID Optional security paramater passed in by the client - ignored.
     * @param type Optional user client type passed in by the client.
     * @param newUserClient The IOAudioControlUserClient * must be stored in this param on a successful
     *  completion.
     * @param properties A dictionary of additional properties for the connection.
     * @result Returns kIOReturnSuccess on success.
     */
    virtual IOReturn createUserClient(task_t task, void *securityID, UInt32 taskType, IOAudioControlUserClient **newUserClient, OSDictionary *properties) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

private:
    OSMetaClassDeclareReservedUsed(IOAudioControl, 0);
    OSMetaClassDeclareReservedUsed(IOAudioControl, 1);
    OSMetaClassDeclareReservedUsed(IOAudioControl, 2);
    OSMetaClassDeclareReservedUsed(IOAudioControl, 3);

    OSMetaClassDeclareReservedUnused(IOAudioControl, 4);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 5);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 6);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 7);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 8);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 9);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 10);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 11);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 12);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 13);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 14);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 15);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 16);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 17);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 18);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 19);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 20);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 21);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 22);
    OSMetaClassDeclareReservedUnused(IOAudioControl, 23);
    
public:

    /*!
     * @function withAttributes
     * @abstract Static function that allocates a new IOAudioControl with the given attributes.
     * @param type The type of the control.  Common, known types are defined in IOAudioTypes.h.  They currently
     *  consist of kIOAudioControlTypeLevel, kIOAudioControlTypeToggle, kIOAudioControlTypeSelector.
     * @param channelID The ID of the channel(s) that the control acts on.  Common IDs are located in IOAudioTypes.h.
     * @param channelName An optional name for the channel.  Common names are located in IOAudioDefines.h.  Any name not
     *  defined in IOAudioDefines.h must be localized in order to be properly displayed in multiple languages.
     * @param cntrlID An optional ID for the control that can be used to uniquely identify controls
     * @param subType An optional subType specific to the given type
     * @param usage An optional value specifying how the control will be used.  Currently defined usages are kIOAudioControlUsageInput, 
     *  kIOAudioControlUsageOutput and kIOAudioControlUsagePassThru.  This value is used when a control is set as a default control
     *  on an IOAudioEngine.
     * @result Returns a newly allocated and initialized IOAudioControl.
     */
    static IOAudioControl *withAttributes(UInt32 type,
                                          OSObject *initialValue,
                                          UInt32 channelID,
                                          const char *channelName = 0,
                                          UInt32 cntrlID = 0,
                                          UInt32 subType = 0,
                                          UInt32 usage = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 ;

    /*!
     * @function init
     * @abstract Initializes a newly allocated IOAudioControl with the given attributes.
     * @param type The type of the control.  Common, known types are defined in IOAudioTypes.h.  They currently
     *  consist of kIOAudioControlTypeLevel, kIOAudioControlTypeToggle, kIOAudioControlTypeSelector.
     * @param channelID The ID of the channel(s) that the control acts on.  Common IDs are located in IOAudioTypes.h.
     * @param channelName An optional name for the channel.  Common names are located in IOAudioDefines.h.  Any name not
     *  defined in IOAudioDefines.h must be localized in order to be properly displayed in multiple languages.
     * @param cntrlID An optional ID for the control that can be used to uniquely identify controls
     * @param subType An optional subType specific to the given type
     * @param usage An optional value specifying how the control will be used.  Currently defined usages are kIOAudioControlUsageInput, 
     *  kIOAudioControlUsageOutput and kIOAudioControlUsagePassThru.  This value is used when a control is set as a default control
     *  on an IOAudioEngine.
     * @param properties Standard property list passed to the init() function of any new IOService.  This dictionary
     *  gets stored in the registry entry for this instance.
     * @result Returns true on success.
     */
    virtual bool init(UInt32 type,
                      OSObject *initialValue,
                      UInt32 channelID,
                      const char *channelName = 0,
                      UInt32 cntrlID = 0,
                      UInt32 subType = 0,
                      UInt32 usage = 0,
                      OSDictionary *properties = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 ;
                      
    /*!
     * @function free
     * @abstract Frees all of the resources allocated by the IOAudioControl.
     * @discussion Do not call this directly.  This is called automatically by the system when the instance's
     *  refcount goes to 0.  To decrement the refcount, call release() on the object.
     */
    virtual void free( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function start
     * @abstract Starts a newly created IOAudioControl.
     * @discussion This is called automatically by IOAudioPort when addAudioControl() is called or by IOAudioEngine 
     *  when addDefaultAudioControl() is called.  It will only be called by the first call to either addAudioControl() or
     *  addDefaultAudioControl().
     * @param provider The IOAudioPort or IOAudioEngine that owns this control.
     * @result Returns true on success.
     */
    virtual bool start(IOService *provider) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
	virtual bool attachAndStart(IOService *provider) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getIsStarted
     * @abstract Returns true after start() has been called.
     * @discussion Used by IOAudioPort and IOAudioEngine to decide if the control needs to be started.
     */
    virtual bool getIsStarted() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function stop
     * @abstract Stops the control when the provider is going away.
     * @param provider The IOAudioPort or IOAudioEngine that owns this control.
     */
    virtual void stop(IOService *provider) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function getWorkLoop
     * @abstract Returns the IOWorkLoop for the whole audio driver.
     */
    virtual IOWorkLoop *getWorkLoop() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getCommandGate
     * @abstract Returns the IOCommandGate for this IOAudioControl.
     */
    virtual IOCommandGate *getCommandGate() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 ;

    /*!
     * @function newUserClient
     * @abstract Creates a new user client object for this IOAudioControl instance.
     * @discussion This is called automatically by I/O Kit when a user process opens a connection to this
     *  IOAudioControl.  This is typically done when the user process needs to register for value change
     *  notifications.  This implementation allocates a new IOAudioControlUserClient object.  There is no
     *  need to call this directly.
	 *  A derived class that requires overriding of newUserClient should override the version with the properties
	 *  parameter for Intel targets, and without the properties parameter for PPC targets.  The #if __i386__ directive
	 *  can be used to select between the two behaviors.
     * @param task The task requesting the new user client.
     * @param securityID Optional security paramater passed in by the client - ignored.
     * @param type Optional user client type passed in by the client - 0 for the default user client type.
     * @param handler The new IOUserClient * must be stored in this param on a successful completion.
     * @param properties A dictionary of additional properties for the connection.
     * @result Returns kIOReturnSuccess on success.  May also result kIOReturnError or kIOReturnNoMemory.
     */
    virtual IOReturn newUserClient(task_t task, void *securityID, UInt32 type, IOUserClient **handler) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn newUserClient(task_t task, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function createUserClient
     * @abstract Creates a new IOAudioControlUserClient instance.
     * @discussion This function is called by newUserClient() to create a new IOAudioControlUserClient instance.  This function may be overridden by subclasses that need to add functionality
     *  to the IOAudioControlUserClient.  In that case, they must subclass IOAudioControlUserClient
     *  and return a new, initialized instance of that subclass.
	 *  A derived class that requires overriding of createUserClient should override the version with the properties
	 *  parameter for Intel targets, and without the properties parameter for PPC targets.  The #if __i386__ directive
	 *  can be used to select between the two behaviors.
     * @param task The task requesting the new user client.
     * @param securityID Optional security paramater passed in by the client - ignored.
     * @param type Optional user client type passed in by the client.
     * @param newUserClient The IOAudioControlUserClient * must be stored in this param on a successful
     *  completion.
     * @result Returns kIOReturnSuccess on success.
     */
    virtual IOReturn createUserClient(task_t task, void *securityID, UInt32 type, IOAudioControlUserClient **newUserClient) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 ;
    
    /*!
     * @function clientClosed
     * @abstract Called automatically by the IOAudioControlUserClient when a user client closes its
     *  connection to the control.
     * @param client The user client object that has disconnected.
     */
    virtual void clientClosed(IOAudioControlUserClient *client) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setProperties
     * @abstract Changes a property of this IOService. 
     * @discussion This is called when the user client changes a property of this 
     *  IOAudioControl.  In this case it is used to change the value.  This function
     *  looks for that property and then calls setValue() through the IOCommandGate and
     *  setValueAction().
     * @param properties An OSDictionary containing the properties to change.
     * @result Returns kIOReturnSuccess on success.
     */
    virtual IOReturn setProperties(OSObject *properties) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void setValueChangeHandler(IntValueChangeHandler intValueChangeHandler, OSObject *target) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void setValueChangeHandler(DataValueChangeHandler dataValueChangeHandler, OSObject *target) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void setValueChangeHandler(ObjectValueChangeHandler objectValueChangeHandler, OSObject *target) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual void setValueChangeTarget(OSObject *target) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function flushValue
     * @abstract Forces the control to be flushed out to the hardware.
     * @discussion This function calls performValueChange() directly with the current value of the IOAudioControl.
     * @result Returns the result of performValueChange() - kIOReturnSuccess on success.
     */
    virtual IOReturn flushValue() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setValueAction
     * @abstract IOCommandGate Action which calls setValue() while holding the IOCommandGate.
     * @discussion This is needed to allow setValue() to be called on the IOWorkLoop.
     * @param owner The owner of the IOCommandGate (the IOAudioControl in this case).
     * @param arg1 The new value for the IOAudioControl.
     * @result Returns the result of setValue() - kIOReturnSuccess on success.
     */
    static IOReturn setValueAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	static IOReturn _setValueAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>
	
    /*!
     * @function setValue
     * @abstract Sets the value for this control.
     * @discussion When the control's value is changed, a call is made to performValueChange().  If that call
     *  succeeds, the value is set and sendValueChangeNotification() is called to send a notification to the
     *  user clients.  This function must be called on the IOWorkLoop.
     * @param newValue The new value for this control.
     * @result Returns kIOReturnSuccess if the value is successfully set.
     */
    virtual IOReturn setValue(OSObject *newValue ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn setValue(SInt32 intValue ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function hardwareValueChanged
     * @abstract Updates the value for this control and sends out the value changed notification.
     * @discussion This is designed to be called by the driver when it detects that the hardware's value has
     *  changed without driver intervention (e.g. when an external event causes the change).  The difference between
     *  hardwareValueChanged() and setValue() is that hardwareValueChanged() doesn't call performValueChange() which 
     *  sends a message back to the driver to cause it to change the hardware with the new value.  This function must
     *  be called on the IOWorkLoop.
     * @param newValue The new value for this control.
     * @result Returns kIOReturnSuccess if the value is successfully updated.
     */
    virtual IOReturn hardwareValueChanged(OSObject *newValue ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getValue 
     * @abstract Returns the current value of the control.
     */
    virtual OSObject *getValue( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual SInt32 getIntValue( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual const void *getDataBytes( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual UInt32 getDataLength( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getControlID 
     * @abstract Returns the control ID for the control.
     */
    virtual UInt32 getControlID( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getChannelID 
     * @abstract Returns the channel ID for the control.
     */
    virtual UInt32 getChannelID( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual UInt32 getType( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual UInt32 getSubType( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual UInt32 getUsage( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual void setCoreAudioPropertyID(UInt32 propertyID ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	void setWorkLoop(IOWorkLoop *wl ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

protected:
    /*!
     * @function sendValueChangeNotification
     * @abstract Called when the value has changed for the control.
     * @discussion This function sends out the value change notification to the user clients.
     */
    virtual void sendValueChangeNotification( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function setChannelName 
     * @abstract Called at init time to set the channel name for this IOAudioControl.
     */
    virtual void setChannelName(const char *channelName ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setChannelID 
     * @abstract Called at init time to set the channel ID for this IOAudioControl.
     */
    virtual void setChannelID(UInt32 newChannelID ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void setChannelNumber(SInt32 channelNumber ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setSubType 
     * @abstract Called at init time to set the control subType.
     */
    virtual void setType(UInt32 type ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setType 
     * @abstract Called at init time to set the control type.
     */
    virtual void setSubType(UInt32 subType ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setUsage 
     * @abstract Called at init time to set the control usage.
     */
    virtual void setUsage(UInt32 usage ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setControlID
     * @abstract Sets the controlID for this control.
     * @discussion The control ID is an optional attribute that can be used to track IOAudioControls.  A typical
     *  use is for the IOAudioDevice to assign a unique controlID to each control that it creates and then
     *  do a switch statement on the id of the control when it gets an audioControlValueChanged() notification.
     *  Typically the control ID is set when the object is created and doesn't need to be called again.
     * @param cntrlID The control ID for the control.
     */
    virtual void setControlID(UInt32 cntrlID ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function validateValue
     * @abstract Called by setValue() to verify that the value is valid.
     * @param newValue The new value to be verified.
     * @result Returns kIOReturnSuccess if the value is valid.
     */
    virtual IOReturn validateValue(OSObject *newValue ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function updateValue
     * @abstract Called by setValue() in order to update the value and the registry.
     * @discussion It also calls
     *  sendValueChangedNotification() to send notifications to the user clients.
     * @param newValue The new value to b updated.
     * @result Returns kIOReturnSuccess if the value is successfully updated.
     */
    virtual IOReturn updateValue(OSObject *newValue ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn _setValue(OSObject *newValue ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function performValueChange
     * @abstract Called by setValue() to make the call to the valueChangeHandler
     *  to update the hardware.
     * @result Returns the result of the handler call (or kIOReturnError on an error).
     */
    virtual IOReturn performValueChange(OSObject *newValue ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function addUserClientAction
     * @abstract IOCommandGate Action which calls addUserClient() while holding the IOCommandGate.
     * @discussion This is needed to allow addUserClient() to be called on the IOWorkLoop.
     * @param owner The owner of the IOCommandGate (the IOAudioControl in this case).
     * @param arg1 The IOAudioControlUserClient to be added.
     * @result Returns the result of addUserClient() - kIOReturnSuccess on success.
     */
    static IOReturn addUserClientAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
	static IOReturn _addUserClientAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>

    /*!
     * @function removeUserClientAction
     * @abstract IOCommandGate Action which calls removeUserClient() while holding the IOCommandGate.
     * @discussion This is needed to allow removeUserClient() to be called on the IOWorkLoop.
     * @param owner The owner of the IOCommandGate (the IOAudioControl in this case).
     * @param arg1 The IOAudioControlUserClient to be removed.
     * @result Returns the result of removeUserClient() - kIOReturnSuccess on success.
     */
    static IOReturn removeUserClientAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
	static IOReturn _removeUserClientAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>

    /*!
     * @function detachUserClientsAction
     */
     static IOReturn detachUserClientsAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function addUserClient
     * @abstract Called on the IOWorkLoop to add a new IOAudioControlUserClient.
     * @discussion There is no need to call this directly.  It is called on the workLoop 
     *  by newUserClient() through addUserClientAction().
     * @param newUserClient The IOAudioControlUserClientto be added.
     * @result Returns kIOReturnSuccess on success.
     */
    virtual IOReturn addUserClient(IOAudioControlUserClient *newUserClient ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function removeUserClient
     * @abstract Called on the IOWorkLoop to remove an IOAudioControlUserClient.
     * @discussion This is called on the IOWorkLoop by clientClosed() through
     *  removeUserClientAction() when the user client is going away.  It should
     *  not be called directly. 
     * @param userClient The IOAudioControlUserClient to be removed.
     * @result Returns kIOReturnSuccess on success.
     */
    virtual IOReturn removeUserClient(IOAudioControlUserClient *userClient ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn detachUserClients( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	static void setCommandGateUsage(IOAudioControl *control, bool increment ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;		// <rdar://8518215>

};

#endif /* _IOKIT_IOAUDIOCONTROL_H */

                                                                                                                                                                                        IOAudioControlUserClient.h                                                                          0100644 0001750 0001750 00000010542 12567452612 040131  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOAUDIOCONTROLUSERCLIENT_H
#define _IOKIT_IOAUDIOCONTROLUSERCLIENT_H

#include <AvailabilityMacros.h>
#include <IOKit/IOUserClient.h>

#ifndef IOAUDIOFAMILY_SELF_BUILD
#include <IOKit/audio/IOAudioTypes.h>
#else
#include "IOAudioTypes.h"
#endif

class IOAudioControl;

class IOAudioControlUserClient : public IOUserClient
{
    OSDeclareDefaultStructors(IOAudioControlUserClient)
    
protected:
    task_t 				clientTask;
    IOAudioControl *			audioControl;
    IOAudioNotificationMessage *	notificationMessage;

    virtual IOReturn clientClose( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn clientDied( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

protected:
    struct ExpansionData { };
    
    ExpansionData *reserved;

public:
	virtual void sendChangeNotification(UInt32 notificationType ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    // OSMetaClassDeclareReservedUsed(IOAudioControlUserClient, 1);
    virtual bool initWithAudioControl(IOAudioControl *control, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

private:
    OSMetaClassDeclareReservedUsed(IOAudioControlUserClient, 0);
    OSMetaClassDeclareReservedUsed(IOAudioControlUserClient, 1);

    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 2);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 3);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 4);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 5);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 6);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 7);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 8);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 9);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 10);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 11);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 12);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 13);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 14);
    OSMetaClassDeclareReservedUnused(IOAudioControlUserClient, 15);

public:
    static IOAudioControlUserClient *withAudioControl(IOAudioControl *control, task_t clientTask, void *securityID, UInt32 type ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    static IOAudioControlUserClient *withAudioControl(IOAudioControl *control, task_t clientTask, void *securityID, UInt32 type, OSDictionary *properties ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual bool initWithAudioControl(IOAudioControl *control, task_t owningTask, void *securityID, UInt32 type ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
    virtual void free( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual IOReturn registerNotificationPort(mach_port_t port, UInt32 type, UInt32 refCon ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual void sendValueChangeNotification( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
};

#endif /* _IOKIT_IOAUDIOCONTROLUSERCLIENT_H */
                                                                                                                                                              IOAudioDebug.h                                                                                      0100644 0001750 0001750 00000004120 12567452612 035534  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOAUDIODEBUG_H
#define _IOAUDIODEBUG_H

#include <IOKit/IOTypes.h>
#include <sys/kdebug.h>


#ifdef DEBUG
	#define DEBUG_LEVEL 3						//<rdar://problem/9725460>
	//#define DEBUG_USE_FIRELOG 1
	#define DEBUG_USE_FIREWIRE_KPRINTF 1
	
	#ifdef DEBUG_USE_FIRELOG
	#include <IOKit/firewire/FireLog.h>
	#define audioDebugIOLog( level, message... ) \
		do {FireLog(  message ); FireLog("\n");} while (0)
	#endif
	
	#ifdef DEBUG_USE_IOUSBLOG
	#include <IOKit/usb/IOUSBLog.h>
	#define audioDebugIOLog( level, message... ) \
		do {USBLog( level, message );} while (0)
	#endif

	#ifdef DEBUG_USE_FIREWIRE_KPRINTF
	#define audioDebugIOLog( level, message... ) \
		do { if (level <= DEBUG_LEVEL) kprintf( message );} while (0)
	#endif



	#ifdef assert
		#undef assert

		#define AssertionMessage( cond, file, line ) \
			"assert \"" #cond "\" failed in " #file " at line " #line

		#define AssertionFailed( cond, file, line ) \
			panic(AssertionMessage( cond, file, line ));

		#define	assert( cond )								\
			if( !(cond) ) {									\
				AssertionFailed( cond, __FILE__, __LINE__ )	\
			}
	#endif
#else
	#define audioDebugIOLog( level, message... ) ;
#endif


#endif /* _IOAUDIODEBUG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                IOAudioDefines.h                                                                                    0100644 0001750 0001750 00000044400 12567452612 036070  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2013 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOAUDIODEFINES_H
#define _IOAUDIODEFINES_H

#define kIOAudioDeviceClassName		"IOAudioDevice"
#define kIOAudioEngineClassName		"IOAudioEngine"
#define kIOAudioStreamClassName		"IOAudioStream"
#define kIOAudioPortClassName		"IOAudioPort"
#define kIOAudioControlClassName	"IOAudioControl"

/*!
 * @defined kIOAudioSampleRateKey
 * @abstract The key in the IORegistry for the IOAudioEngine sample rate attribute
 * @discussion This value is represented as an integer in samples per second.
 */
#define kIOAudioSampleRateKey				"IOAudioSampleRate"

#define kIOAudioSampleRateWholeNumberKey	"IOAudioSampleRateWholeNumber"
#define kIOAudioSampleRateFractionKey		"IOAudioSampleRateFraction"



/******
 *
 * IOAudioDevice  defines
 *
 *****/


/*!
 * @defined kIOAudioDeviceNameKey
 * @abstract The key in the IORegistry for the IOAudioDevice name attribute.
 */
#define kIOAudioDeviceNameKey				"IOAudioDeviceName"

#define kIOAudioDeviceShortNameKey			"IOAudioDeviceShortName"

/*!
 * @defined kIOAudioDeviceManufacturerNameKey
 * @abstract The key in the IORegistry for the IOAudioDevice manufacturer name attribute.
 */
#define kIOAudioDeviceManufacturerNameKey	"IOAudioDeviceManufacturerName"

#define kIOAudioDeviceLocalizedBundleKey	"IOAudioDeviceLocalizedBundle"

#define kIOAudioDeviceTransportTypeKey		"IOAudioDeviceTransportType"

#define kIOAudioDeviceConfigurationAppKey	"IOAudioDeviceConfigurationApplication"

#define kIOAudioDeviceCanBeDefaults			"IOAudioDeviceCanBeDefaults"

#define kIOAudioDeviceModelIDKey			"IOAudioDeviceModelID"


/*!
 * @defined kIOAudioDeviceIconName
 * @abstract The key in the IORegistry for the IOAudioDevice icon name attribute.
 */
#define kIOAudioDeviceIconNameKey		"IOAudioDeviceIconName"

#define kIOAudioDeviceIconTypeKey		"IOAudioDeviceIconType"

#define kIOAudioDeviceIconSubDirKey	"IOAudioDeviceIconSubDir"

/*****
 *
 * IOAudioEngine defines
 *
 *****/


 /*!
 * @defined kIOAudioEngineStateKey
 * @abstract The key in the IORegistry for the IOAudioEngine state atrribute
 * @discussion The value for this key may be one of: "Running", "Stopped" or "Paused".  Currently the "Paused"
 *  state is unimplemented.
 */
#define kIOAudioEngineStateKey		"IOAudioEngineState"

/*!
 * @defined kIOAudioEngineOutputSampleLatencyKey
 * @abstract The key in the IORegistry for the IOAudioEngine output sample latency key
 * @discussion 
 */
#define kIOAudioEngineOutputSampleLatencyKey		"IOAudioEngineOutputSampleLatency"

/*!
 * @defined kIOAudioStreamSampleLatencyKey
 * @abstract The key in the IORegistry for the IOAudioStream output sample latency key
 * @discussion Tells the HAL how much latency is on a particular stream.  If two streams
 * on the same engine have different latencies (e.g. one is analog, one is digital), then
 * set this property on both streams to inform the HAL of the latency differences.  Alternately,
 * you can set the engine latency, and just include the latency additional to that for the particular
 * stream.  The HAL will add the engine and stream latency numbers together to get the total latency.
 */
#define kIOAudioStreamSampleLatencyKey				"IOAudioStreamSampleLatency"

#define kIOAudioEngineInputSampleLatencyKey			"IOAudioEngineInputSampleLatency"

#define kIOAudioEngineSampleOffsetKey				"IOAudioEngineSampleOffset"

#define kIOAudioEngineInputSampleOffsetKey			"IOAudioEngineInputSampleOffset"

#define kIOAudioEngineNumSampleFramesPerBufferKey	"IOAudioEngineNumSampleFramesPerBuffer"

#define kIOAudioEngineCoreAudioPlugInKey			"IOAudioEngineCoreAudioPlugIn"

#define kIOAudioEngineNumActiveUserClientsKey		"IOAudioEngineNumActiveUserClients"

#define kIOAudioEngineUserClientActiveKey			"IOAudioEngineUserClientActive"

#define kIOAudioEngineGlobalUniqueIDKey				"IOAudioEngineGlobalUniqueID"

#define kIOAudioEngineDescriptionKey				"IOAudioEngineDescription"

#define kIOAudioEngineClockIsStableKey				"IOAudioEngineClockIsStable"

#define kIOAudioEngineClockDomainKey				"IOAudioEngineClockDomain"

#define kIOAudioEngineIsHiddenKey               "IOAudioEngineIsHidden"
/*!
 * @defined kIOAudioEngineFullChannelNamesKey
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary of fully constructed names for each channel keyed by the device channel
 * @discussion 
 */
#define	kIOAudioEngineFullChannelNamesKey			"IOAudioEngineChannelNames"

/*!
 * @defined kIOAudioEngineFullChannelCategoryNamesKey
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary of category names for each channel keyed by the device channel
 * @discussion 
 */
#define	kIOAudioEngineFullChannelCategoryNamesKey	"IOAudioEngineChannelCategoryNames"

/*!
 * @defined kIOAudioEngineFullChannelNamesKey
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary of number names for each channel keyed by the device channel
 * @discussion 
 */
#define	kIOAudioEngineFullChannelNumberNamesKey			"IOAudioEngineChannelNumberNames"

#define	kIOAudioEngineFullChannelNameKeyInputFormat		"InputChannel%u"

#define	kIOAudioEngineFullChannelNameKeyOutputFormat	"OutputChannel%u"

#define kIOAudioEngineFlavorKey							"IOAudioEngineFlavor"

#define	kIOAudioEngineAlwaysLoadCoreAudioPlugInKey		"IOAudioEngineAlwaysLoadCoreAudioPlugIn"

/*!
 * @defined kIOAudioEngineInputChannelLayoutKey
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary describes an array of OSNumber data that describe the spatial position of each channel.  See IOAudioTypes.h.
 * @discussion
 */

#ifndef __OPEN_SOURCE__
//	<rdar://6868206>
#endif
#define kIOAudioEngineInputChannelLayoutKey				"IOAudioEngineInputChannelLayout"

/*!
 * @defined kIOAudioEngineOutputChannelLayoutKey
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary describes an array of OSNumber data that describe the spatial position of each channel.  See IOAudioTypes.h.
 * @discussion
 */

#ifndef __OPEN_SOURCE__
//	<rdar://6868206>
#endif
#define kIOAudioEngineOutputChannelLayoutKey			"IOAudioEngineOutputChannelLayout"

/*!
 * @defined kIOAudioEngineDisableClockBoundsCheck
 * @abstract The key in the IORegistry for the IOAudioEngine's dictionary implemented as an OSBoolean that is used to disable the bounds checking on timestamps being passed to the HAL.
 * @discussion By using this key and setting the value to true the driver is asserting that it guarantees that all zero timestamps passed to the HAL increment appropriately at the 
				correct period. This key is used to disable the HAL test that the timestamp is within 1ms of the current time, so that a driver may pass a timestamp that is more than
				1ms in the future. This may be useful when a timestamp is based on a large DMA read/write which encompasses the wrap point but occurs many samples before the end of that point.
 */
#define kIOAudioEngineDisableClockBoundsCheck		"IOAudioEngineDisableClockBoundsCheck"

/*****
 *
 * IOAudioStream defines
 *
 *****/
 
 
#define kIOAudioStreamIDKey					"IOAudioStreamID"
#define kIOAudioStreamDescriptionKey		"IOAudioStreamDescription"
#define kIOAudioStreamNumClientsKey			"IOAudioStreamNumClients"

/*!
 * @defined kIOAudioStreamDirectionKey
 * @abstract The key in the IORegistry for the IOAudioStream direction attribute.
 * @discussion The value for this key may be either "Output" or "Input".
 */
#define kIOAudioStreamDirectionKey				"IOAudioStreamDirection"

#define kIOAudioStreamStartingChannelIDKey		"IOAudioStreamStartingChannelID"
#define kIOAudioStreamStartingChannelNumberKey	"IOAudioStreamStartingChannelNumber"
#define kIOAudioStreamAvailableKey				"IOAudioStreamAvailable"

#define kIOAudioStreamFormatKey					"IOAudioStreamFormat"
#define kIOAudioStreamAvailableFormatsKey		"IOAudioStreamAvailableFormats"

#define kIOAudioStreamNumChannelsKey			"IOAudioStreamNumChannels"
#define kIOAudioStreamSampleFormatKey			"IOAudioStreamSampleFormat"

#define kIOAudioStreamNumericRepresentationKey	"IOAudioStreamNumericRepresentation"

#define kIOAudioStreamFormatFlagsKey			"IOAudioStreamFormatFlags"
#define kIOAudioStreamFramesPerPacketKey		"IOAudioStreamFramesPerPacket"
#define kIOAudioStreamBytesPerPacketKey			"IOAudioStreamBytesPerPacket"


#define kIOAudioStreamBitDepthKey				"IOAudioStreamBitDepth"
#define kIOAudioStreamBitWidthKey				"IOAudioStreamBitWidth"
    
#define kIOAudioStreamAlignmentKey				"IOAudioStreamAlignment"

#define kIOAudioStreamByteOrderKey				"IOAudioStreamByteOrder"

#define kIOAudioStreamIsMixableKey				"IOAudioStreamIsMixable"

#define kIOAudioStreamMinimumSampleRateKey		"IOAudioStreamMinimumSampleRate"
#define kIOAudioStreamMaximumSampleRateKey		"IOAudioStreamMaximumSampleRate"

#define kIOAudioStreamDriverTagKey				"IOAudioStreamDriverTag"

#define kIOAudioStreamTerminalTypeKey			"IOAudioStreamTerminalType"

/*****
 *
 * IOAudioPort defines
 *
 *****/
 
 
 /*!
 * @defined kIOAudioPortTypeKey
 * @abstract The key in the IORegistry for the IOAudioPort type attribute.
 * @discussion This is a driver-defined text attribute that may contain any type.
 *  Common types are defined as: "Speaker", "Headphones", "Microphone", "CD", "Line", "Digital", "Mixer", "PassThru".
 */
#define kIOAudioPortTypeKey			"IOAudioPortType"

/*!
 * @defined kIOAudioPortSubTypeKey
 * @abstract The key in the IORegistry for the IOAudioPort subtype attribute.
 * @discussion The IOAudioPort subtype is a driver-defined text attribute designed to complement the type
 *  attribute.
 */
#define kIOAudioPortSubTypeKey		"IOAudioPortSubType"

/*!
 * @defined kIOAudioPortNameKey
 * @abstract The key in the IORegistry for the IOAudioPort name attribute.
 */
#define kIOAudioPortNameKey			"IOAudioPortName"



/*****
 *
 * IOAudioControl defines
 *
 *****/
 
 
 /*!
 * @defined kIOAudioControlTypeKey
 * @abstract The key in the IORegistry for the IOAudioCntrol type attribute.
 * @discussion The value of this text attribute may be defined by the driver, however system-defined
 *  types recognized by the upper-level software are "Level", "Mute", "Selector".
 */
#define kIOAudioControlTypeKey		"IOAudioControlType"

#define kIOAudioControlSubTypeKey	"IOAudioControlSubType"

#define kIOAudioControlUsageKey		"IOAudioControlUsage"

#define kIOAudioControlIDKey		"IOAudioControlID"

/*!
 * @defined kIOAudioControlChannelIDKey
 * @abstract The key in the IORegistry for the IOAudioControl channel ID attribute
 * @discussion The value for this key is an integer which may be driver defined.  Default values for
 *  common channel types are provided in the following defines.
 */
#define kIOAudioControlChannelIDKey		"IOAudioControlChannelID"

#define kIOAudioControlChannelNumberKey			"IOAudioControlChannelNumber"

#define kIOAudioControlCoreAudioPropertyIDKey	"IOAudioControlCoreAudioPropertyID"
/*!
 * @defined kIOAudioControlChannelNameKey
 * @abstract The key in the IORegistry for the IOAudioControl name attribute.
 * @discussion This name should be a human-readable name for the channel(s) represented by the port.
 *  *** NOTE *** We really need to make all of the human-readable attributes that have potential to
 *  be used in a GUI localizable.  There will need to be localized strings in the kext bundle matching
 *  the text.
 */
#define kIOAudioControlChannelNameKey		"IOAudioControlChannelName"

/*!
 * @defined kIOAudioControlChannelNameAll
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for all channels.
 */
#define kIOAudioControlChannelNameAll		"All Channels"

/*!
 * @defined kIOAudioControlChannelNameLeft
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the left channel.
 */
#define kIOAudioControlChannelNameLeft		"Left"

/*!
 * @defined kIOAudioControlChannelNameRight
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the right channel.
 */
#define kIOAudioControlChannelNameRight		"Right"

/*!
 * @defined kIOAudioControlChannelNameCenter
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the center channel.
 */
#define kIOAudioControlChannelNameCenter	"Center"

/*!
 * @defined kIOAudioControlChannelNameLeftRear
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the left rear channel.
 */
#define kIOAudioControlChannelNameLeftRear	"LeftRear"

/*!
 * @defined kIOAudioControlChannelNameRightRear
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the right rear channel.
 */
#define kIOAudioControlChannelNameRightRear	"RightRear"

/*!
 * @defined kIOAudioControlChannelNameSub
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the sub/LFE channel.
 */
#define kIOAudioControlChannelNameSub		"Sub"

/*!
 * @defined kIOAudioControlChannelNameFrontLeftCenter
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the FrontLeftCenter channel.
 */
#define kIOAudioControlChannelNameFrontLeftCenter		"FrontLeftCenter"

/*!
 * @defined kIOAudioControlChannelNameFrontRightCenter
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the FrontRightCenter channel.
 */
#define kIOAudioControlChannelNameFrontRightCenter		"FrontRightCenter"

/*!
 * @defined kIOAudioControlChannelNameRearCenter
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the RearCenter channel.
 */
#define kIOAudioControlChannelNameRearCenter		"RearCenter"

/*!
 * @defined kIOAudioControlChannelNameSurroundLeft
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the SurroundLeft channel.
 */
#define kIOAudioControlChannelNameSurroundLeft		"SurroundLeft"

/*!
 * @defined kIOAudioControlChannelNameSurroundRight
 * @abstract The value for the kIOAudioControlChannelNameKey in the IORegistry representing
 *  the channel name for the SurroundRight channel.
 */
#define kIOAudioControlChannelNameSurroundRight		"SurroundRight"


/*!
 * @defined kIOAudioControlValueKey
 * @abstract The key in the IORegistry for the IOAudioControl value attribute.
 * @discussion The value returned by this key is a 32-bit integer representing the current value of the IOAudioControl.
 */
#define kIOAudioControlValueKey				"IOAudioControlValue"

/*!
 * @defined kIOAudioControlValueIsReadOnlyKey
 * @abstract The key in the IORegistry for the IOAudioControl value-is-read-only attribute.
 * @discussion The value returned by this key is a 32-bit integer but the value doesn't have any direct meaning.
 *  Instead, the presence of this key indicates that the value for the control is read-only
 */
#define kIOAudioControlValueIsReadOnlyKey	"IOAudioControlValueIsReadOnly"

/*!
 * @defined kIOAudioLevelControlMinValueKey
 * @abstract The key in the IORegistry for the IOAudioControl minimum value attribute.
 * @discussion The value returned by this key is a 32-bit integer representing the minimum value for the IOAudioControl.
 *  This is currently only valid for Level controls or other driver-defined controls that have a minimum and maximum
 *  value.
 */
#define kIOAudioLevelControlMinValueKey		"IOAudioLevelControlMinValue"

/*!
 * @defined kIOAudioLevelControlMaxValueKey
 * @abstract The key in the IORegistry for the IOAudioControl maximum value attribute.
 * @discussion The value returned by this key is a 32-bit integer representing the maximum value for the IOAudioControl.
 *  This is currently only valid for Level controls or other driver-defined controls that have a minimum and maximum
 *  value.
 */
#define kIOAudioLevelControlMaxValueKey		"IOAudioLevelControlMaxValue"

/*!
 * @defined kIOAudioLevelControlMinDBKey
 * @abstract The key in the IORgistry for the IOAudioControl minimum db value attribute.
 * @discussion The value returned by this key is a fixed point value in 16.16 format represented as a 32-bit
 *  integer.  It represents the minimum value in db for the IOAudioControl.  This value matches the minimum
 *  value attribute.  This is currently valid for Level controls or other driver-defined controls that have a
 *  minimum and maximum db value.
 */
#define kIOAudioLevelControlMinDBKey		"IOAudioLevelControlMinDB"

/*!
 * @defined kIOAudioLevelControlMaxDBKey
 * @abstract The key in the IORgistry for the IOAudioControl maximum db value attribute.
 * @discussion The value returned by this key is a fixed point value in 16.16 format represented as a 32-bit
 *  integer.  It represents the maximum value in db for the IOAudioControl.  This value matches the maximum
 *  value attribute.  This is currently valid for Level controls or other driver-defined controls that have a
 *  minimum and maximum db value.
 */
#define kIOAudioLevelControlMaxDBKey		"IOAudioLevelControlMaxDB"

#define kIOAudioLevelControlRangesKey		"IOAudioLevelControlRanges"

#define kIOAudioLevelControlUseLinearScale	"IOAudioLevelControlUseLinearScale"

#define kIOAudioSelectorControlAvailableSelectionsKey	"IOAudioSelectorControlAvailableSelections"
#define kIOAudioSelectorControlSelectionValueKey		"IOAudioSelectorControlSelectionValue"
#define kIOAudioSelectorControlSelectionDescriptionKey	"IOAudioSelectorControlSelectionDescriptionKey"
#define kIOAudioSelectorControlTransportValueKey		"IOAudioSelectorControlTransportValue"					// <rdar://8202424>

#define kIOAudioSelectorControlClockSourceKey			"IOAudioSelectorControlClockSourceKey"


#endif /* _IOAUDIODEFINES_H */
                                                                                                                                                                                                                                                                IOAudioDevice.h                                                                                     0100644 0001750 0001750 00000131336 12567452612 035717  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOAudioDevice
 */

#ifndef _IOKIT_IOAUDIODEVICE_H
#define _IOKIT_IOAUDIODEVICE_H

#include <IOKit/IOService.h>
#include <AvailabilityMacros.h>

#ifndef IOAUDIOFAMILY_SELF_BUILD
#include <IOKit/audio/IOAudioTypes.h>
#include <IOKit/audio/IOAudioStream.h>
#else
#include "IOAudioTypes.h"
#include "IOAudioStream.h"
#endif

class IOAudioEngine;
class IOAudioStream;
class IOAudioPort;
class IOAudioControl;
class OSDictionary;
class OSSet;
class OSArray;
class IOTimerEventSource;
class IOCommandGate;

/*!
 * @enum IOAudioDevicePowerState
 * @abstract Identifies the power state of the audio device
 * @discussion A newly created IOAudioDevices defaults to the idle state.
 * @constant kIOAudioDeviceSleep State set when the system is going to sleep
 * @constant kIOAudioDeviceIdle State when the system is awake but none of the IOAudioEngines are in use
 * @constant kIOAudioDeviceActive State when one ore more IOAudioEngines are in use.  This state transition must complete before the system will begin playing audio.
 */
typedef enum _IOAudioDevicePowerState {
    kIOAudioDeviceSleep 	= 0,	// When sleeping
    kIOAudioDeviceIdle		= 1,	// When no audio engines running
    kIOAudioDeviceActive 	= 2		// audio engines running
} IOAudioDevicePowerState;

/*!
 * @class IOAudioDevice
 * @abstract Abstract base class for a single piece of audio hardware.  The IOAudioDevice provides
 *  the central coordination point for an audio driver.
 * @discussion An audio driver is required to subclass IOAudioDevice in order to provide
 *  working audio to the system.  A single driver instance will contain a single instance of the 
 *  driver's IOAudioDevice subclass.  The subclass is responsible for mapping all hardware device
 *  resources from the service provider nub.  It must control access to the hardware so that the
 *  hardware doesn't get into an inconsistent state.  It is possible that different threads may make
 *  requests of the hardware at the same time.  The IOAudioDevice superclass provides an IOWorkLoop
 *  and IOCommandGate on the IOWorkLoop through which all hardware accesses may be synchronized.
 *  All entry points to all parts of the driver controlled by the IOAudioFamily will be synchronized
 *  through this one IOWorkLoop.
 *
 *  The IOAudioDevice subclass is responsible for creating the rest of the pieces of the driver.
 *  It must identify and create all IOAudioEngines that are not automatically created by the system
 *  (i.e. those that are not matched and instantiated by IOKit directly).
 *
 *  The IOAudioDevice subclass must enumerate and create all IOAudioControls to match
 *  the device capabilities.
 *
 *  It must also execute control value chages when requested by the system (i.e. volume adjustments).
 *
 *  In order to allow sleep and wake to work on the system, the IOAudioDevice subclass is responsible
 *  for performing the necessary actions to sleep and wake its hardware (and restore necessary state
 *  on wake).
 *
 *  The IOAudioDevice class provides timer services that allow different elements in the audio driver
 *  to receive timer notifications as needed.  These services were designed with the idea that most
 *  timed events in a typical audio driver need to be done at least as often as a certain interval.
 *  Further, it is designed with the idea that being called more often than the specified interval
 *  doesn't hurt anything - and in fact may help.  With this in mind, the timer services provided
 *  by the IOAudioDevice class allow different targets to register for timer callbacks at least as
 *  often as the specified interval.  The actual interval will be the smallest of the intervals of
 *  all of the callbacks.  This way, we avoid the overhead of having many timers in a single audio
 *  device.  As an example, each output IOAudioEngine has a timer to run the erase head.  It doesn't hurt
 *  to have the erase head run more often.  Also, a typical IOAudioDevice subclass may need to run a timer
 *  to check for device state changes (e.g. jack insertions).
 *
 *  There are a number of strings passed from the driver to the CoreAudio.framework and then into
 *  applications.  All of those strings should be localized by the driver.  In order to do that
 *  the kext bundle should have localized string files following the Mac OS X localization 
 *  instructions.  The IOAudioDevice should contain a property with the name of the bundle/kext
 *  that contains the localized string resources.  To do that, the driver's personality in 
 *  the bundle resources could have a property named 'IOAudioDeviceLocalizedBundle' with the path 
 *  of the bundle/kext relative to '/System/Library/Extensions'.  It could also be set by the 
 *  IOAudioDevice subclass in its initHardware() function.  To do so, call
 *  setProperty(kIOAudioDeviceLocalizedBundleKey, "Driver.kext").
 *
 *  In a typical driver, the IOAudioDevice subclass will implement initHardware() to perform the
 *  hardware initialization and driver construction.  Within that initialization it must create at 
 *  least one IOAudioEngine instance and activate it.  In order to activate a new IOAudioEngine
 *  activateAudioEngine() should be called for each one.  It must create the IOAudioControls 
 *  matching the hardware capabilities to allow the system to set volume, mute and input selection.  
 *  To add those controls to the driver, each control should be attached to the IOAudioEngine to
 *  which it applies by calling addDefaultAudioControl() on the IOAudioEngine.
 *  During initialization it should also call setDeviceName(), setDeviceShortName() and 
 *  setManufacturerName() with localized strings representing each of the attributes.
 *
 *  If the driver is to work properly after sleep/wake, it must implement performPowerStateChange()
 *  and deal with the sleep and wake transitions.  It may also deal with the idle state transitions
 *  to turn off device power when it isn't in use (especially useful for devices attached to a 
 *  portable running on battery power).
 */

#ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
	#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 101000
		#warning IOAudioDevice is deprecated use <CoreAudio/AudioServerPlugIn.h> instead.
	#endif
#endif

class IOAudioDevice : public IOService
{
    friend class IOAudioEngine;
    
    OSDeclareDefaultStructors(IOAudioDevice)

protected:
    /*! @var workLoop The IOWorkLoop for the driver - this is shared with the other objects in the driver */
    IOWorkLoop				*workLoop;
    /*! @var commandGate The IOCommandGate for this IOAudioDevice.  It is attached to workLoop */
    IOCommandGate			*commandGate;
    /*! @var timerEventSource An IOTimerEventSource attached to workLoop used for the timer services */
    IOTimerEventSource		*timerEventSource;

    /*! @var duringStartup State variable set to true while the driver is starting up and false all other times */
    bool			duringStartup;
    /*! @var familyManagePower Set to true if the family is supposed to manage power - this is the default state.  It can be changed early in the initialization process with a call to setFamilyManagePower(). */
    bool			familyManagePower;
    /*! @var asyncPowerStateChangeInProgress Set to true while an asynchronous power change is pending and false all other times. */
    bool			asyncPowerStateChangeInProgress;
    
    /*! @var numRunningAudioEngines The number of running IOAudioEngines.  This is used to maintain idle vs active power state. */
    UInt32			numRunningAudioEngines;
    
    /*! @var currentPowerState Used to track the existing power state - can be fetched by calling getPowerState() */
    IOAudioDevicePowerState	currentPowerState;
    /*! @var pendingPowerState If a power state change is in progress, this represents the pending power state.  All other times this is the same as the currentPowerState. */
    IOAudioDevicePowerState	pendingPowerState;

    /*! @var audioEngines The set of IOAudioEngine objects vended by the IOAudioDevice. */
    OSArray *			audioEngines;
    /*! @var timerEvents
     *  @abstract The set of timer events in use by the device.  
     *  @discussion The key for the dictionary is the target of the event.  This means that a single target may
     *   have only a single event associated with it.
     */
    OSDictionary *		timerEvents;
    /*! @var audioPorts The set of IOAudioPort objects associated with the IOAudioDevice */
    OSSet *			audioPorts;

    /*! @var minimumInterval The smallest timer interval requested by all timer event targets. */
    AbsoluteTime		minimumInterval;
    /*! @var previousTimerFire The time of the last timer event.
     *  @discussion This is used to schedule the next timer event.
     */
    AbsoluteTime		previousTimerFire;

public:
    /*! @var gIOAudioPlane
     *   A static IORegistryPlane representing the new IOAudioPlane that the IOAudioFamily uses
     *   to represent the signal chain of the device.
     */
    static const IORegistryPlane *gIOAudioPlane;

protected:
    struct ExpansionData {
		unsigned long long			idleSleepDelayTime;
		IOTimerEventSource *		idleTimer;
	};
    
    ExpansionData *reserved;
    
public:
	static void idleAudioSleepHandlerTimer(OSObject *owner, IOTimerEventSource *sender ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn setAggressiveness(unsigned long type, unsigned long newLevel ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioDevice, 0);
	virtual void setDeviceTransportType(const UInt32 transportType ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioDevice, 1);
    /*!
	 * @function setIdleAudioSleepTime
     * @abstract This function is to be called by a driver that doesn't want to be told about the audio
	 * going idle immediately, but at some point in the future.
	 * @discussion This is useful if the device will want to power down its hardware into an idle sleep
	 * state, but doesn't want to do that unless audio hasn't been used for a while.  Calling this function
	 * immediately changes the idle sleep timer and queues it up if the idle is different from the previous
	 * idle time.  The idle time defaults to 0, which means be called immediately (backwards compatible with
	 * previous versions of IOAudioFamily).  A value of 0xffffffffffffffffULL means don't ever tell the
	 * driver about going idle.
     * @param sleepDelay The amount of time, in nanoseconds, before the hardware should be told to go idle.
     */
	virtual void setIdleAudioSleepTime(unsigned long long sleepDelay ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioDevice, 2);
	virtual void scheduleIdleAudioSleep(void ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioDevice, 3);
    /*!
	 * @function setConfigurationApplicationBundle
     * @abstract This function is to be called if an external configuration application is available to set
	 * which application to launch.
	 * @discussion This is useful for device drivers that are too complex to be represented by the Sound Preferences
	 * panel.  The bundle ID is a more flexible way of specifying where the application is than a hard coded path.
     * @param bundleID The bundle ID of the application to be launched by the HAL for configuration of the device and its engine(s).
     */
	virtual void setConfigurationApplicationBundle(const char *bundleID ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioDevice, 4);
    /*!
	 * @function setDeviceCanBeDefault
     * @abstract This function is to be called to tell CoreAudio if this device shouldn't be a default device.
	 * @discussion This is useful for device drivers that don't want to be a default device.  Can be called with
	 * kIOAudioDeviceCanBeDefaultNothing to prevent CoreAudio from allowing this device to be any default device, or it
	 * can be called with any combination of kIOAudioDeviceCanBeDefaultInput, kIOAudioDeviceCanBeDefaultOutput, or
	 * kIOAudioDeviceCanBeSystemOutput.  The default is 
	 * (kIOAudioDeviceCanBeDefaultInput | kIOAudioDeviceCanBeDefaultOutput | kIOAudioDeviceCanBeSystemOutput).
     * @param defaultsFlags The flags to instruct CoreAudio to allow this device to be only the indicated default devices.
     */
	virtual void setDeviceCanBeDefault(UInt32 defaultsFlags ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioDevice, 5);
	virtual void setDeviceModelName(const char * modelName ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

private:
	OSMetaClassDeclareReservedUsed(IOAudioDevice, 0);
	OSMetaClassDeclareReservedUsed(IOAudioDevice, 1);
	OSMetaClassDeclareReservedUsed(IOAudioDevice, 2);
	OSMetaClassDeclareReservedUsed(IOAudioDevice, 3);
	OSMetaClassDeclareReservedUsed(IOAudioDevice, 4);
	OSMetaClassDeclareReservedUsed(IOAudioDevice, 5);

	OSMetaClassDeclareReservedUnused(IOAudioDevice, 6);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 7);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 8);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 9);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 10);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 11);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 12);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 13);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 14);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 15);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 16);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 17);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 18);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 19);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 20);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 21);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 22);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 23);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 24);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 25);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 26);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 27);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 28);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 29);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 30);
	OSMetaClassDeclareReservedUnused(IOAudioDevice, 31);
	

public:
    // Initialization
    
    /*!
     * @function init
     * @abstract Initialize a newly created instance of IOAudioDevice.
     * @discussion This implementation initializes all of the data structures and variables used by the
     *  IOAudioDevice.  The currentPowerState and pendingPowerState variables are set to kIOAudioDeviceIdle.
     *  A subclass that overrides this method must call the superclass' implementation.
     * @param properties
     *  An OSDictionary of the device properties that gets passed to super::init and set
     *  in the IORegistry.
     * @result true if initialization was successful
     */
    virtual bool init(OSDictionary *properties ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function free
     * @abstract Frees resources used by the IOAudioDevice instance
     * @discussion This method will deactivate all audio audio engines and release the audioEngines OSSet.
     *  It will also deactivate all of the audio ports and release the audioPorts OSSet.  It will release
     *  the timerEvents OSDictionary as well as cancel any outstanding timer callbacks.  It will clean up
     *  all of the event sources and the workLoop.
     *
     *  Do not call this directly.  This is called automatically by the system when the instance's
     *  refcount goes to 0.  To decrement the refcount, call release() on the object.
     */
     
    virtual void free( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function start
     * @abstract This function is called automatically by the system to tell the driver to start vending
     *  services to the rest of the system.
     * @discussion The start() implementation in IOAudioDevice starts by calling start() on its superclass.
     *  It then calls initHardware() which the subclass should override to properly initialize itself and 
     *  the hardware.  If that call succeeds, it sets up power management if the family is supposed to 
     *  manage power (checking the familyManagePower variable).  Then finally it calls registerService() 
     *  to make the IOAudioDevice visible in the IORegistry.
     * @param provider
     *  This is the service provider nub that provides access to the hardware resources.
     * @result Returns true on success
     */
    virtual bool start(IOService *provider ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function stop
     * @abstract This is responsible for stopping the device after the system is done with it (or
     *  if the device is removed from the system).
     * @discussion The IOAudioDevice implentation of stop() disables the timer services, deactivates 
     *  all of the audio audio engines and audio ports and stops power management of the device.
     *  The audio engine and port deactivation causes all of the audio engines to get stopped and 
     *  all of the audio engine and port resources and objects to be released.  A subclass' implementation 
     *  may could shut down hardware here if necessary.  If this function is overridden by a subclass,
     *  the superclass' implementation must be called.
     * @param provider
     *  The service provider nub for the device.
     */
    virtual void stop(IOService *provider ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual bool willTerminate(IOService *provider, IOOptionBits options ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function initHardware
     * @abstract This function is called by start() to provide a convenient place for the subclass to 
     *  perform its initialization.
     * @discussion In a typical implementation, a driver would implementation this function and perform
     *  a number of tasks.  Those include mapping hardware resources, initializing the hardware to a known
     *  state, creating the IOAudioEngines, IOAudioControls and IOAudioStreams.  Additionally it 
     *  should also call setDeviceName(), setDeviceShortName(), setManufacturerName().  Upon return of
     *  this function, the device should be ready to begin vending services to the system.
     * @param provider
     *  The service provider nub for the device.
     * @result This function should return true on a successful initialization.
     */
    virtual bool initHardware(IOService *provider ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function setDeviceName
     * @abstract Sets the name of the device
     * @discussion This method should be called during initialization or startup.  It should
     *  be set by the time initHardware() completes.  The device name is used by the 
     *  CoreAudio.framework to identify the particular piece of hardware.  This string should
     *  should be localized by the driver.
     */
    virtual void setDeviceName(const char *deviceName ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function setDeviceShortName
     * @abstract Sets the short name of the device
     * @discussion The short name is a shorter representation of the device name.  It may be used
     *  by applications when the device name is too long.  It should be set by the time initHardware()
     *  completes.  The string should be localized by the driver.
     */
    virtual void setDeviceShortName(const char *shortName ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setManufacturerName
     * @abstract Sets the manufacturer name of the device
     * @discussion This method should be called during initialization or startup.  This should be 
     *  called by the time initHardware() completes.  The string should be localized by the driver.
     */
    virtual void setManufacturerName(const char *manufacturerName ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    
    // IOWorkLoop, IOCommandGate management
    
    /*!
     * @function getWorkLoop
     * @abstract Returns the IOWorkLoop for the driver
     * @discussion The IOWorkLoop is used to synchronized all critical aspects of the driver.  This
     *  includes all entry points to the driver as well as power management.
     */
    virtual IOWorkLoop *getWorkLoop() const AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function getCommandGate
     * @abstract Returns the IOCommandGate for this IOAudioDevice
     * @discussion This IOCommandGate allows calls into this IOAudioDevice to be synchronized on 
     *  the IOWorkLoop.
     */
    virtual IOCommandGate *getCommandGate() const AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    
    // IOAudioEngine management
    
    /*!
     * @function activateAudioEngine
     * @abstract This simply calls activateAudioEngine(IOAudioEngine *audioEngine, 
     *  bool shouldStartAudioEngine) with a value of true for shouldStartAudioEngine.
     * @param audioEngine
     *  The IOAudioEngine instance to be activated.  It is treated as a newly 
     *  allocated instance.
     * @result Returns true if the audio engine was successfully activated.
     */
    virtual IOReturn activateAudioEngine(IOAudioEngine *audioEngine ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function activateAudioEngine
     * @abstract This is called to add a new IOAudioEngine object to the IOAudioDevice.
     * @discussion Once the IOAudioEngine has been activated by this function, it is ready
     *  to begin moving audio data.  This should be called either during the subclass' initHardware()
     *  implementation for each IOAudioEngine the device creates.  Or it should be called by
     *  the IOAudioEngine itself if the audio engine was automatically created by IOKit's matching
     *  process.  The system won't be able to properly track and control IOAudioEngines if
     *  they are not activated though this function.
     *  This implementation will retain the IOAudioEngine while it maintains control of it.  
     *  When the audio engine is deactivated, the IOAudioEngine will be released.  If the 
     *  IOAudioDevice subclass is passing a newly instantiated IOAudioEngine, it will need to release 
     *  the audio engine after it has been activated.  This will insure that the refCount on the audio engine 
     *  is correct when it gets deactivated when the driver is stopped.  That allows the audio engine to be
     *  freed when it is no longer needed.
     * @param audioEngine
     *  The IOAudioEngine instance to be activated.
     * @param shouldStartAudioEngine
     *  If true, the audio engine is treated as a newly allocated IOAudioEngine
     *  instance and is appropriately attached and started according to IOKit convention.  If it is false
     *  it is assumed that some other process (possibly the IOKit matching process) has started the
     *  IOAudioEngine and will skip that step.
     * @result Returns true if the audio engine was successfully activated.
     */
    virtual IOReturn activateAudioEngine(IOAudioEngine *audioEngine, bool shouldStartAudioEngine ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function deactivateAllAudioEngines
     * @abstract Deactivates all of the audio engines in the device.
     * @discussion This is called by the stop() and free() methods in IOAudioDevice to completely
     *  shut down all audio engines as the driver is being shut down.
     */
    virtual void deactivateAllAudioEngines( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    
    // Power management
    
    /*!
     * @function setFamilyManagePower
     * @abstract Called set whether or not the family should manage the device power throught the
     *  IOService power management APIs.
     * @discussion The default behavior is for the family to manage power.  It is only necessary to 
     *  call this function if the driver does not want the family to manage power.  It is not
     *  recommended that this function be called because it makes power management much more
     *  difficult for the driver.  If this function is to be called, it must be called before
     *  initHardware() completes.  Immediately after initHardware() is called by start(), 
     *  the power management system is initialized if the family is to manage power.
     * @param manage Set to false if it is not desired that the family does the power management
     */
    virtual void setFamilyManagePower(bool manage ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function setPowerState
     * @abstract Called by the power management system in IOService when the power state of this 
     *  service needs to change.
     * @discussion The default implementation of IOAudioDevice sets up two power states for IOService
     *  to use.  State 0 is sleep and state 1 is wake.  This function should not be called directly.
     *  It is only supposed to be used by the IOService power management services.
     * @param powerStateOrdinal
     *  The number of the power state as defined by the IOAudioDevice - 
     *  0 for sleep, 1 for wake.
     * @param device The power management policy maker.
     * @result Returns kIOPMAckImplied (0) when the power state change is complete.  Otherwise the an
     *  upper bound on the number of microseconds until the state change is complete is returned.
     */
    virtual IOReturn setPowerState(unsigned long powerStateOrdinal, IOService *device ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function setPowerStateAction
     * @abstract IOCommandGate Action which calls protectedSetPowerState() while holding the IOCommandGate
     * @discussion This is needed to allow protectedSetPowerState() to be called on the IOWorkLoop
     * @param owner The owner of the IOCommandGate (the IOAudioDevice in this case)
     * @param arg1 The powerStateOrdinal to be passed to protectedSetPowerState()
     * @param arg2 The device to be passed to protectedSetPowerState()
     * @result Returns the result of protectedSetPowerState()
     */
    static IOReturn setPowerStateAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
	static IOReturn _setPowerStateAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://8508064>

    /*!
     * @function protectedSetPowerState
     * @abstract Called by setPowerStateAction() to deal with a power state change from the IOService
     *  power management facility.
     * @discussion This function is responsible for performing the necessary sleep and wake tasks
     *  when the system is sleeping or waking.  If an outstanding power state change is in progress,
     *  it will wait until the state changes has completed.  While sleeping, all audio engines are
     *  stopped before calling initiatePowerStateChange() to call performPowerStateChange() to let
     *  the driver deal with the sleep request.  When waking, it determines if the device should be
     *  idle or active and continues to call initiatePowerStateChange().  If initiatePowerStateChange()
     *  indicates that the power state change is occuring asynchronously, it returns the number of
     *  microseconds.  This function must be called on the IOWorkLoop, but should not be called
     *  directly.
     * @param powerStateOrdinal Param passed to setPowerState() - 0 for sleep, 1 for wake
     * @param device Param passed to setPowerState - the device initiating the power state change
     * @result Returns 0 if the power state change is complete - the number of microseconds until 
     *  complete if its asynchronous.
     */
    virtual IOReturn protectedSetPowerState(unsigned long powerStateOrdinal, IOService *device ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function performPowerStateChange
     * @abstract This function is called by the IOAudioDevice when a power state change is needed.
     * @discussion In order to deal with power state changes, a subclass must override this function.
     *  Any combination of old and new power states may be passed to this function.  If work is to
     *  be performed while transitioning to sleep, check for a newPowerState of kIOAudioDeviceSleep.
     *  If work is to be performed while transitioning from sleep, check for an oldPowerState of
     *  kIOAudioDeviceSleep.  A power state of kIOAudioDeviceIdle means the system is awake, but
     *  no clients are currently playing or recording audio (i.e. no IOAudioEngines are active).
     *  A power state of kIOAudioDeviceActive means that at least one IOAudioEngine is active.
     *  It is possible for a power state change to be performed synchronously or asynchronously.
     *  In the case of a synchronous power state change, simple leave microsecondsUntilComplete
     *  alone and return kIOReturnSuccess.  If an asynchronous power state change is needed the 
     *  driver should do whatever needed to schedule another thread to finish the state change
     *  and set the microsecondsUntilComplete to an upper bound on the amount of time it will
     *  take to complete the power state change.  Then when the power state change is complete,
     *  a call must be made to completePowerStateChange().  During an asynchronous power state
     *  change, the current power state will remain the same as before the transition began, 
     *  and the pendingPowerState is set to the new power state that will be set when the 
     *  change is complete.
     * @param oldPowerState The power state before the power state change
     * @param newPowerState The power state being transitioned to
     * @param microsecondsUntilComplete
     *  A pointer to a value representing an upper bound on
     *  the number of microseconds to complete an asynchronous power state change.  It points
     *  to a value of zero at the start and if it remains zero, the state change is complete
     *  upon a successful return from the function.
     * @result Returns kIOReturnSuccess on a successful completion
     */
    virtual IOReturn performPowerStateChange(IOAudioDevicePowerState oldPowerState,
                                                IOAudioDevicePowerState newPowerState,
                                                UInt32 *microsecondsUntilComplete ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
                                                    
    /*!
     * @function completePowerStateChange
     * @abstract Called when a power state change is complete
     * @discussion In the case of an asynchronous power state change, a subclass is responsible
     *  for calling this function.  It is safe to call this function if not on the IOWorkLoop.
     *  This function calls protectedCompletePowerStateChange() through the IOCommandGate and
     *  completePowerStateChangeAction().  If the call is already on the IOWorkLoop, it is safe
     *  to call protectedCompletePowerStateChange() directly.
     * @result Returns kIOReturnSuccess on a successful completion
     */
    virtual IOReturn completePowerStateChange( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function completePowerStateChangeAction
     * @abstract IOCommandGate Action which calls protectedCompletePowerStateChange() while holding the
     *  IOCommandGate.
     * @discussion This is needed to allow protectedCompletePowerStateChange() to be called on the IOWorkLoop.
     * @param owner The owner of the IOCommandGate (the IOAudioDevice in this case)
     * @result Returns the result of protectedCompletePowerStateChange()
     */
    static IOReturn completePowerStateChangeAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function protectedCompletePowerStateChange
     * @abstract Called on the IOWorkLoop when a power state change is complete.
     * @discussion This function does the work to complete a power state change (both synchronous and
     *  asynchronous).  If the system is waking from sleep, the timer system is restarted and the 
     *  audio engines are resumed.  If this was called as a result of an asynchronous power state changed
     *  it makes the IOService power management call acknowledgePowerChange() and resets the
     *  asyncPowerStateChangeInProgress variable.  Finally it sets the currentPowerState to the
     *  pendingPowerState.  This function must be called on the IOWorkLoop.  If a subclass is not
     *  on the IOWorkLoop (e.g. holding the IOCommandGate), call completePowerStateChange() instead.
     * @result Returns kIOReturnSuccess on success
     */
    virtual IOReturn protectedCompletePowerStateChange( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getPowerState
     * @abstract Returns the current power state (the old power state if a change is in progress).
     * @result The current power state
     */
    virtual IOAudioDevicePowerState getPowerState( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function getPendingPowerState
     * @abstract Returns the pending power state if a state change is in progress.  Otherwise it 
     *  returns the current power state change.
     * @result The pending power state
     */
    virtual IOAudioDevicePowerState getPendingPowerState( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function waitForPendingPowerStateChange
     * @abstract Called internally to wait until a pending power state change is complete.
     * @discussion This is only used by internal functions to wait during pending power
     *  state changes.  It is used to prevent multiple power state changes at the same time.
     *  This function must be called while holding the IOCommandGate.  If an asynchronous 
     *  power state change is in progress this function will block until the state change
     *  if complete.  Once complete, it will return while still holding the IOCommandGate.
     */
    virtual void waitForPendingPowerStateChange( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function initiatePowerStateChange
     * @abstract Called internally to execute a power state change
     * @discussion This function must be called on the IOWorkLoop.  It calls performPowerStateChange()
     *  to let the driver process the state change.  If the state change is completed synchronously
     *  by the driver (subclass) it calls protectedCompletePowerStateChange().  If done asynchronously
     *  it returns the microsecondsUntilComplete that was set by performPowerStateChange().  This
     *  function should not be called directly.
     * @param microsecondsUntilComplete
     *  Pointer to the microsecondsUntilComplete that should be set
     *  by performPowerStateChange if an asynchronous power state change was started.
     * @result Returns kIOReturnSuccess on success
     */
    virtual IOReturn initiatePowerStateChange(UInt32 *microsecondsUntilComplete = NULL ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    

    // IOAudioControl management
    
    /*!
     * @function flushAudioControls
     * @abstract Forces each IOAudioControl in the driver to have its value flushed out to the hardware.
     *  That will cause either the IOAudioControl's ValueChangeHandler to be called.
     * @discussion This can be used to force the hardware to get updated with the current value 
     *  of each control.  It may be useful during wake for example.
     */
    virtual void flushAudioControls( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;


    // Timer services
    
    /*!
     * @typedef TimerEvent
     * @abstract Generic timer event callback for IOAudioDevice timer targets
     * @discussion TimerEvent callback function takes two arguments; the target of
     *  the timer event and the IOAudioDevice sending the event.
     * @param target The target of the timer event - passed in when the timer event was registered
     * @param audioDevice The IOAudioDevice sending the event
     */
    typedef void (*TimerEvent)(OSObject *target, IOAudioDevice *audioDevice ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function addTimerEvent
     * @abstract Adds a TimerEvent callback for the given target called at least as often
     *  as specified in interval.
     * @discussion The frequency of the timer event callbacks will be the smallest interval
     *  specified by all targets.  Only one interval and callback may be specified per target.
     *  If a addTimerEvent is called twice with the same target, the second one overrides the
     *  first.  There is currently a bug triggered if the first call had the smallest interval.
     *  In that case, that smallest interval would still be used.
     * @param target This parameter is the target object of the TimerEvent.
     * @param event The callback function called each time the timer fires.
     * @param interval The callback will be called at least this often.
     * @result Returns kIOReturnSuccess if the timer event was successfully added.
     */
    virtual IOReturn addTimerEvent(OSObject *target, TimerEvent event, AbsoluteTime interval ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function removeTimerEvent
     * @abstract Removes the timer event for the given target.
     * @discussion If the interval for the target to be removed is the smallest interval,
     *  the timer interval is recalculated based on the remaining targets.  The next fire
     *  time is readjusted based on the new interval compared to the last fire time.
     * @param target The target whose timer event will be removed.
     */
    virtual void removeTimerEvent(OSObject *target ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function removeAllTimerEvents
     * @abstract Removes all timer events and stops the timer
     * @discussion Called during teardown of the driver
     */    
    virtual void removeAllTimerEvents( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    
    // IOAudioPort management

    /*!
     * @function attachAudioPort
     * @abstract Adds the port to the IOAudioDevice's list of ports and attaches the port to its parent
     *  and attaches the child to the port.
     * @discussion This function provides the functionality to represent the device's signal chain in the
     *  IOAudioPlane in the IORegistry.  An IOAudioPort's parent(s) are before it in the signal chain
     *  and its children are after it.  This method may be called multiple times for a single IOAudioPort.
     *  This is necessary when there are many children or parents.  Once a relationship is made, it is not
     *  necessary to make the reverse relationship.  A NULL value may be passed in for either the parent
     *  or child or both.
     *  The IOAudioPort passed in should be a newly allocated IOAudioPort instance.  This function will
     *  appropriately attach and start the port object.  NOTE: It is not necessary to use IOAudioPorts
     *  in a fully functional audio driver.
     * @param port The newly created IOAudioPort instance to be activated.
     * @param parent A parent IOAudioPort or IOAudioEngine of the given port.
     * @param child A child IOAudioPort or IOAudioEngine of the given port.
     * @result Returns true when the port has been successfully added and attached.
     */
    virtual IOReturn attachAudioPort(IOAudioPort *port, IORegistryEntry *parent, IORegistryEntry *child ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function detachAllAudioPorts
     * @abstract Deactivates all of the ports in the device.
     * @discussion This is called by the stop() and free() methods in IOAudioDevice to completely
     *  shut down all ports as the driver is being shut down.
     */
    virtual void detachAllAudioPorts( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

protected:
    /*!
     * @function timerFired
     * @abstract Internal static function called when the timer fires.
     * @discussion This function simply calls dispatchTimerEvents() on the IOAudioDevice to do just that.
     * @param target The IOAudioDevice instance that initiated the timer callback.
     * @param sender The IOTimerEventSources calling this callback
     */
    static void timerFired(OSObject *target, IOTimerEventSource *sender ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function dispatchTimerEvents
     * @abstract Called by timerFired() to cause the timer event callbacks to be called.
     * @discussion This method iterates through all of the timer event targets and calls
     *  the callback on each.  Unless the force flag is set to true, the timer events will
     *  only be dispatched if the power state is not kIOAudioDeviceSleep.  This prevents
     *  unexpected timer firings while making wake->sleep->wake transitions.  This function must
     *  be called on the IOWorkLoop.
     * @param force
     *  A bool param to allow the timer events to be dispatched even if the 
     *  device is in the kIOAudioDeviceSleep power state.
     */
    virtual void dispatchTimerEvents(bool force ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function audioEngineStarting
     * @abstract Called by IOAudioEngine when it is starting up
     * @discussion This should only be called while on the IOWorkLoop.  It is not intended to be called
     *  directly.  It is called when an IOAudioEngine is starting up to allow the IOAudioDevice
     *  to keep track of running audio engines and change the power state from kIOAudioDeviceIdle to
     *  kIOAudioDeviceActive when the first audio engine starts up.  If the state change is done
     *  asynchronously, it waits for the state change to complete.  This is to ensure that the
     *  system doesn't start playing audio until the IOAudioDevice has completed its transition
     *  to kIOAudioDeviceActive.
     */
    virtual void audioEngineStarting( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function audioEngineStopped
     * @abstract Called by IOAudioEngine when it has stopped
     * @discussion This should only be called while on the IOWorkLoop.  It is not intended to be called
     *  directly.  It is called when an IOAudioEngine has stopped to allow the IOAudioDevice
     *  to keep track of running audio engines and change the power state from kIOAudioDeviceActive
     *  to kIOAudioDeviceIdle when the last audio engine stops.  If the state change is done 
     *  asynchronously, it waits for the state change to complete.
     */
    virtual void audioEngineStopped( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
};

#endif /* _IOKIT_IOAUDIODEVICE_H */
                                                                                                                                                                                                                                                                                                  IOAudioEngine.h                                                                                     0100644 0001750 0001750 00000150120 12567452612 035715  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOAudioEngine
 */

#ifndef _IOKIT_IOAUDIOENGINE_H
#define _IOKIT_IOAUDIOENGINE_H

#include <IOKit/IOService.h>
#include <AvailabilityMacros.h>

#ifndef IOAUDIOFAMILY_SELF_BUILD
#include <IOKit/audio/IOAudioTypes.h>
#else
#include "IOAudioTypes.h"
#endif
#include <IOKit/IOBufferMemoryDescriptor.h>

class OSDictionary;
class OSCollection;
class OSOrderedSet;
class IOAudioEngineUserClient;
class IOAudioDevice;
class IOAudioStream;
class IOAudioControl;
class IOCommandGate;

#define IOAUDIOENGINE_DEFAULT_NUM_ERASES_PER_BUFFER	4

/*!
 * @typedef IOAudioEnginePosition
 * @abstract Represents a position in an audio audio engine.
 * @discussion This position is based on the sample frame within a 
 *  loop around the sample buffer, and the loop count which starts at 0 when the audio engine
 *  begins playback.
 * @field fSampleFrame The sample frame within the buffer - starts at 0.
 * @field fLoopCount The number of times the ring buffer has looped.
 */
typedef struct {
    UInt32	fSampleFrame;
    UInt32	fLoopCount;
} IOAudioEnginePosition;

#define CMP_IOAUDIOENGINEPOSITION(p1, p2) \
    (((p1)->fLoopCount > (p2)->fLoopCount) ? 1 :	\
        ((p1)->fLoopCount == (p2)->fLoopCount) && ((p1)->fSampleFrame > (p2)->fSampleFrame) ? 1 :	\
            ((p1)->fLoopCount == (p2)->fLoopCount) && ((p1)->fSampleFrame == (p2)->fSampleFrame) ? 0 : -1)
            
#define IOAUDIOENGINEPOSITION_IS_ZERO(p1) (((p1)->fLoopCount == 0) && ((p1)->fSampleFrame == 0))

/*!
 * @class IOAudioEngine
 * @abstract Abstract base class for a single audio audio / I/O engine.
 * @discussion An IOAudioEngine is defined by a single I/O engine to transfer data to
 *  or from one or more sample buffers.  Each sample buffer is represented by a single IOAudioStream
 *  instance.  A single IOAudioEngine must contain at least one IOAudioStream, but has no upper
 *  limit on the number of IOAudioStreams it may contain.  An IOAudioEngine instance may contain
 *  both input and output IOAudioStreams.
 *
 *  An audio driver must subclass IOAudioEngine in order to provide certain services.  An 
 *  IOAudioEngine subclass must start and stop the I/O engine when requested.  The I/O
 *  engine should be continuously running and loop around from end to beginning.  While the audio
 *  engine is running, it must take a timestamp as the sample buffer(s) wrap around and start at
 *  the beginning.  The CoreAudio.framework uses the timestamp to calculate the exact position of
 *  the audio engine.  An IOAudioEngine subclass must implement getCurrentSampleFrame() to provide
 *  a sample position on demand.  Finally, an IOAudioEngine subclass must provide clipping and
 *  format conversion routines to go to/from the CoreAudio.framework's native float format.
 *
 *  If multiple stream formats or sample rates are allowed, the IOAudioEngine
 *  subclass must provide support for changing the hardware when a format or sample rate is
 *  changed.
 *
 *  There are several attributes associated with a single IOAudioEngine: 
 *
 *  The IOAudioEngine superclass provides a shared status buffer that contains all of the dynamic pieces
 *  of information about the audio engine (type IOAudioEngineStatus).  It runs an erase process on
 *  all of the output streams.  The erase head is used to zero out the mix and sample buffers after
 *  the samples have been played.  Additionally, the IOAudioEngine superclass handles the 
 *  communication with the CoreAudio.framework and makes the decision to start and stop the
 *  audio engine when it detects it is in use.
 *
 *  In order for an audio device to play back or record sound, an IOAudioEngine subclass must be created.
 *  The subclass must initialize all of the necessary hardware resources to prepare for starting the
 *  audio I/O engine.  It typically will perform these tasks in the initHardware() method.  A subclass 
 *  may also implement a stop() method which is called as the driver is being torn down.  This is 
 *  typically called in preparation of removing the device from the system for removable devices.
 *
 *  In addition to initializing the necessary hardware, there are a number of other tasks an 
 *  IOAudioEngine must do during initHardware().  It must create the necessary IOAudioStream objects
 *  to match the device capabilities.  Each IOAudioStream must be added using addAudioStream().  It
 *  also should create the IOAudioControls needed to control the various attributes of the audio engine:
 *  output volume, mute, input gain, input selection, analog passthru.  To do that, addDefaultAudioControl()
 *  should be called with each IOAudioControl to be attached to the IOAudioEngine.  In order to provide
 *  for proper synchronization, the latency of the audio engine should be specified with setSampleLatency().
 *  This value represents the latency between the timestamp taken at the beginning of the buffer and 
 *  when the audio is actually played (or recorded) by the device.  If a device is block based or if
 *  there is a need to keep the CoreAudio.framework a certain number of samples ahead of (or behind for
 *  input) the I/O head, that value should be specified using setSampleOffset().  If this is not specified
 *  the CoreAudio.framework may attempt to get as close to the I/O head as possible.
 *
 *  The following fields in the shared IOAudioEngineStatus struct must be maintained by the subclass
 *  implementation:
 *  <pre>
 *  <t>  fCurrentLoopCount - the number of times the sample buffer has wrapped around to the beginning
 *  <t>  fLastLoopTime - timestamp of the most recent time that the I/O engine looped back to the 
 *  beginning of the sample buffer
 *  </pre>
 *  It is critically important that the fLastLoopTime field be as accurate as possible.  It is 
 *  the basis for the entire timer and synchronization mechanism used by the audio system.
 *
 *  At init time, the IOAudioEngine subclass must call setNumSampleFramesPerBuffer() to indicate how large
 *  each of the sample buffers are (measured in sample frames).  Within a single IOAudioEngine, all sample
 *  buffers must be the same size and be running at the same sample rate.  If different buffers/streams can
 *  be run at different rates, separate IOAudioEngines should be used.  The IOAudioEngine subclass must
 *  also call setSampleRate() at init time to indicate the starting sample rate of the device.
 *
 */

#ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
	#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 101000
		#warning IOAudioEngine is deprecated use <CoreAudio/AudioServerPlugIn.h> instead.
	#endif
#endif

class IOAudioEngine : public IOService
{
    OSDeclareAbstractStructors(IOAudioEngine)
    
    friend class IOAudioEngineUserClient;
    friend class IOAudioDevice;
    friend class IOAudioStream;
    
public:
    /*! @var gSampleRateWholeNumberKey */
    static const OSSymbol	*gSampleRateWholeNumberKey;
    /*! @var gSampleRateFractionKey */
    static const OSSymbol	*gSampleRateFractionKey;
    
    /*! @var numSampleFramesPerBuffer */
    UInt32			numSampleFramesPerBuffer;
    
    /*! @var sampleRate 
     *  The current sample rate of the audio engine in samples per second. */
    IOAudioSampleRate			sampleRate;

    /*! @var numErasesPerBuffer 
     *  The number of times the erase head get scheduled to run for each 
     *   cycle of the audio engine. */
    UInt32			numErasesPerBuffer;
    /*! @var runEraseHead 
     *  Set to true if the erase head is to run when the audio engine is running.  This is the case if there are any output streams. */
    bool			runEraseHead;
    
    /*! @var audioEngineStopPosition 
     *  When all clients have disconnected, this is set to one buffer length past the
    *    current audio engine position at the time.  Then when the stop position is reached, the audio engine
    *    is stopped */
    IOAudioEnginePosition	audioEngineStopPosition;

    /*! @var isRegistered 
     *  Internal state variable to keep track or whether registerService() has been called. */
    bool			isRegistered;
    /*! @var configurationChangeInProgress 
     *  Set to true after beginConfigurationChange() and false upon a 
    *    subsequent call to completeConfigurationChange() or cancelConfigurationChange(). */
    bool			configurationChangeInProgress;
    
    /*! @var state 
     *  The current state of the IOAudioEngine - running, stopped, paused. */
    IOAudioEngineState		state;

    /*! @var status 
     *  Status struct shared with the CoreAudio.framework. */
    IOAudioEngineStatus *	status;

    /*! @var audioDevice 
     *  The IOAudioDevice instance to which the IOAudioEngine belongs. */
    IOAudioDevice *		audioDevice;
    
    /*! @var workLoop 
     *  The IOWorkLoop for the audio driver - shared with the IOAudioDevice. */
    IOWorkLoop 			*workLoop;
    /*! @var commandGate 
     *  The IOCommandGate for this audio engine - attached to the driver's IOWorkLoop. */
    IOCommandGate		*commandGate;

    /*! @var inputStreams 
     *  An OSSet of all of the input IOAudioStreams attached to this IOAudioEngine. */
    OSOrderedSet 	*inputStreams;
    UInt32			maxNumInputChannels;
    /*! @var outputStreams 
     *  An OSSet of all of the output IOAudioStreams attached to this IOAudioEngine. */
    OSOrderedSet	*outputStreams;
    UInt32			maxNumOutputChannels;
    /*! @var userClients 
     *  An OSSet of all of the currently connected user clients. */
    OSSet			*userClients;
    /*! @var defaultAudioControls 
     *  All of the IOAudioControls that affect this audio engine. */
    OSSet			*defaultAudioControls;
    
    /*! @var numActiveUserClients 
     *  A total of the active user clients - those that are currently playing or 
     *    recording audio. */
    UInt32			numActiveUserClients;
    UInt32			sampleOffset;				// used for input and output if inputSampleOffset is not set, if inputSampleOffset is set used as output only 
		      
    UInt32			index;
    bool			duringStartup;

protected:

    /*!
     * @var deviceStartedAudioEngine 
     *  Used by the IOAudioDevice to determine responsibility for shutting
     *  the audio engine down when it is no longer needed.
     */
    bool			deviceStartedAudioEngine;
    
protected:
    struct ExpansionData {
		UInt32								pauseCount;
		IOBufferMemoryDescriptor			*statusDescriptor;
		IOBufferMemoryDescriptor			*bytesInInputBufferArrayDescriptor;
		IOBufferMemoryDescriptor			*bytesInOutputBufferArrayDescriptor;
		UInt32								mixClipOverhead;
		OSArray								*streams;
	    UInt32								inputSampleOffset;
		UInt32								commandGateStatus;			// <rdar://8518215>
		SInt32								commandGateUsage;			// <rdar://8518215>
	};
    
    ExpansionData   *reserved;

//	static UInt32	sInstanceCount;	

public:
	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 0 );
    virtual IOReturn performFormatChange(IOAudioStream *audioStream, const IOAudioStreamFormat *newFormat, const IOAudioStreamFormatExtension *formatExtension, const IOAudioSampleRate *newSampleRate ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 1 );
	virtual IOBufferMemoryDescriptor * getStatusDescriptor( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 2 );
	virtual IOReturn getNearestStartTime(IOAudioStream *audioStream, IOAudioTimeStamp *ioTimeStamp, bool isInput ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 3);
	virtual IOBufferMemoryDescriptor * getBytesInInputBufferArrayDescriptor( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 4);
	virtual IOBufferMemoryDescriptor * getBytesInOutputBufferArrayDescriptor( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 5);
    /*!
	 * @function eraseOutputSamples
     * @abstract This function allows for the actual erasing of the mix and sample buffer to be overridden by
	 * a child class.
	 * @param mixBuf Pointer to the IOAudioFamily allocated mix buffer.
	 * @param sampleBuf Pointer to the child class' sample buffer.
	 * @param firstSampleFrame Index to the first sample frame to erase.
	 * @param numSampleFrames Number of sample frames to erase.
	 * @param streamFormat Format of the data to be erased.
	 * @param audioStream Pointer to stream object that corresponds to the sample buffer being erased.
	 * @result Must return kIOReturnSuccess if the samples have been erased.
     */
	virtual IOReturn eraseOutputSamples(const void *mixBuf, void *sampleBuf, UInt32 firstSampleFrame, UInt32 numSampleFrames, const IOAudioStreamFormat *streamFormat, IOAudioStream *audioStream ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 6);
    /*!
	 * @function setClockIsStable
     * @abstract This function sets a flag that CoreAudio uses to select its sample rate tracking algorithm.  Set
	 * this to TRUE unless that results in dropped audio.  If the driver is experiencing unexplained dropouts
	 * setting this FALSE might help.
	 * @param clockIsStable TRUE tells CoreAudio to use an agressive PLL to quickly lock to the engine's sample rate
	 * while FALSE tells CoreAudio to adjust more slowly to perceived sample rate changes that might just be the
	 * result of an unstable clock.
     */
	virtual void setClockIsStable(bool clockIsStable ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 7);
	/*!
     * @function setMixClipOverhead
     * @abstract Used to tell IOAudioFamily when the watchdog timer must fire by.
     * @discussion setMixClipOverhead allows an audio engine to tell IOAudioFamily how much time
	 * an engine will take to mix and clip its samples, in percent.
	 * The default value is 10, meaning 10%.  This will cause IOAudioFamily to make
	 * the watchdog timer fire when there is just over 10% of the time to complete
	 * a buffer set left (e.g. 51 samples when the HAL is using a buffer size of 512
	 * samples).
     * @param newMixClipOverhead How much time per buffer should be made available for the
	 * mix and clip routines to run.  Valid values are 1 through 99, inclusive.
     * @result return no error
	*/
	virtual void setMixClipOverhead(UInt32 newMixClipOverhead ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 8);
    /*!
	 * @function setClockDomain
     * @abstract Sets a property that CoreAudio uses to determine how devices are synchronized.  If an audio device can tell that it is
	 * synchronized to another engine, it should set this value to that engine's clock domain.  If an audio device can be a clock master, it may publish
	 * its own clock domain for other devices to use.
	 * @param clockDomain is the unique ID of another engine that this engine realizes it is synchronized to, use the default value kIOAudioNewClockDomain 
	 * to have IOAudioEngine create a unique clock domain.
     */
	virtual void setClockDomain(UInt32 clockDomain = kIOAudioNewClockDomain ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 9);
    /*!
	 * @function convertInputSamplesVBR
     * @abstract Override this method if you want to return a different number of sample frames than was requested.  
     */
	virtual IOReturn convertInputSamplesVBR(const void *sampleBuf, void *destBuf, UInt32 firstSampleFrame, UInt32 &numSampleFrames, const IOAudioStreamFormat *streamFormat, IOAudioStream *audioStream ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 10);
    /*!
	 * @function setInputSampleOffset
     * @abstract set the offset CoreAudio will read from off the current read pointer
	 * @param numSamples size of offset in sample
	 */
    virtual void setInputSampleOffset(UInt32 numSamples ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 11);
    /*!
	 * @function setOutputSampleOffset
     * @abstract set the offset CoreAudio will write at off the current write pointer
	 * @param numSamples size of offset in sample
	 */
    virtual void setOutputSampleOffset(UInt32 numSamples ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

protected:
	
	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 12);
    virtual IOReturn createUserClient(task_t task, void *securityID, UInt32 type, IOAudioEngineUserClient **newUserClient, OSDictionary *properties ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

public:
	
	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 13);
	/*! 
	 * @function setAttributeForConnection
	 * @abstract Generic method to set some attribute of the audio engine, specific to one connection.
	 * @discussion IOAudioEngine subclasses may implement this method to allow arbitrary attribute/value pairs to be set, specific to one connection. 
	 * @param attribute Defines the attribute to be set. 
	 * @param value The new value for the attribute.
	 * @result an IOReturn code.
	 */
	
    virtual IOReturn setAttributeForConnection( SInt32 connectIndex, UInt32 attribute, uintptr_t value  ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	// OSMetaClassDeclareReservedUsed(IOAudioEngine, 14);
	/*! @function getAttributeForConnection
	 * @abstract Generic method to retrieve some attribute of the audio engine, specific to one connection.
	 * @discussion IOAudioEngine subclasses may implement this method to allow arbitrary attribute/value pairs to be returned, specific to one connection. 
	 * @param attribute Defines the attribute to be returned. Some defined attributes are:<br> 
	 * @param value Returns the value for the attribute.
	 * @result an IOReturn code.
	 */
	
    virtual IOReturn getAttributeForConnection( SInt32 connectIndex, UInt32 attribute, uintptr_t * value  ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

private:
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 0);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 1);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 2);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 3);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 4);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 5);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 6);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 7);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 8);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 9);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 10);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 11);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 12);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 13);
	OSMetaClassDeclareReservedUsed(IOAudioEngine, 14);

	OSMetaClassDeclareReservedUnused(IOAudioEngine, 15);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 16);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 17);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 18);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 19);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 20);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 21);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 22);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 23);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 24);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 25);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 26);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 27);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 28);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 29);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 30);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 31);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 32);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 33);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 34);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 35);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 36);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 37);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 38);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 39);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 40);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 41);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 42);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 43);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 44);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 45);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 46);
	OSMetaClassDeclareReservedUnused(IOAudioEngine, 47);

public:
    /*!
     * @function createDictionaryFromSampleRate
     * @abstract Generates a dictionary matching the given sample rate.
     * @discussion This is an internal routine used to generate a dictionary matching the given sample rate.  It is used to generate a sample rate dictionary for the I/O Registry - used by the 
     *  CoreAudio.framework.
     * @result Returns the newly create OSDictionary.
     */
    static OSDictionary *createDictionaryFromSampleRate(const IOAudioSampleRate *sampleRate, OSDictionary *rateDict = 0 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function createSampleRateFromDictionary
     * @abstract Generates a sample rate from an OSDictionary.
     * @discussion This is an internal routine used to generate a sample rate from an OSDictionary.  It is used to generate a sample rate give a new OSDictionary from the IORegistry - coming
     *  from the CoreAudio.framework.
     * @result Returns the sample rate.
     */
    static IOAudioSampleRate *createSampleRateFromDictionary(const OSDictionary *rateDict, IOAudioSampleRate *sampleRate = 0 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function init
     * @abstract Performs initialization of a newly allocated IOAudioEngine.
     * @discussion This function is responsible for initialization of all of the general attributes of
     *  a new IOAudioEngine.  It initializes instance variables to their default
     *  values and allocates the shared status buffer.  Subclasses will likely want to override this method
     *  and do all of their common initialization in their implementation.  They do need to be sure to call
     *  IOAudioEngine's implementation of init and pay attention to the return value.
     * @param properties The default properties for the IOAudioEngine.
     * @result Returns true if initialization was successful.
     */
    virtual bool init(OSDictionary *properties ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function free
     * @abstract Frees all of the resources allocated by the IOAudioEngine.
     * @discussion Do not call this directly.  This is called automatically by the system when the instance's
     *  refcount goes to 0.  To decrement the refcount, call release() on the object.
     */
    virtual void free( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getWorkLoop
     * @abstract Returns the IOWorkLoop for the driver.
     */
    virtual IOWorkLoop *getWorkLoop() const;
    
    /*!
     * @function getCommandGate
     * @abstract Returns the IOCommandGate for this IOAudioEngine.
     */
    virtual IOCommandGate *getCommandGate() const;
    
    /*!
     * @function start
     * @abstract A simple cover function for start(IOService *, IOAudioDevice *) that assumes the provider
     *  is the IOAudioDevice.
     * @discussion Subclasses will want to override start(IOService *, IOAudioDevice *) rather than this
     *  one.
     * @param provider The service provider for the IOAudioEngine (the IOAudioDevice in this case).
     * @result Returns true if the IOAudioEngine was successfully started.
     */
    virtual bool start(IOService *provider ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function start
     * @abstract Standard IOKit start() routine called to start an IOService.
     * @discussion This function is called in order to prepare the IOAudioEngine for use.  It does NOT
     *  mean that the audio I/O engine itself should be started.  This implementation gets the IOWorkLoop
     *  from the IOAudioDevice and allocates an IOCommandGate.  Finally it calls initHardware() in which
     *  all of the subclass-specific device initialization should be done.  Upon return from initHardware()
     *  all IOAudioStreams should be created and added to the audio engine.  Also, all IOAudioControls
     *  for this IOAudioEngine should be created and attached.
     * @param provider The service provider for the IOAudioEngine.
     * @param device The IOAudioDevice to which this IOAudioEngine belongs.
     * @result Returns true if the service was successfully started.
     */
    virtual bool start(IOService *provider, IOAudioDevice *device ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function initHardware
     * @abstract This function is called by start() to provide a convenient place for the subclass to
     *  perform its hardware initialization.
     * @discussion Upon return from this function, all IOAudioStreams and IOAudioControls should be created
     *  and the audio engine should be ready to be started when a client requests that playback begin.
     * @function provider The service provider numb for this audio engine - typically the IOAudioDevice.
     * @result Returns true if the hardware was successfully initialized.
     */
    virtual bool initHardware(IOService *provider ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function stop
     * @abstract Stops the service and prepares for the driver to be terminated.
     * @discussion This function is called before the driver is terminated and usually means that the device
     *  has been removed from the system.
     * @param provider The service provider for the IOAudioEngine.
     */
    virtual void stop(IOService *provider ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function registerService
     * @abstract Called when this audio engine is ready to begin vending services.
     * @discussion This function is called by IOAudioDevice::activateAudioEngine() once the audio engine
     *  has been fully initialized and is ready to begin audio playback.
     * @param options
     */
    virtual void registerService(IOOptionBits options = 0 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void setAudioDevice(IOAudioDevice *device ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void setIndex(UInt32 index ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void setDescription(const char *description ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function newUserClient
     * @abstract Requests a new user client object for this service.
     * @discussion This function is called automatically by I/O Kit when a user process attempts
     *  to connect to this service.  It allocates a new IOAudioEngineUserClient object and increments
     *  the number of connections for this audio engine.  If this is the first user client for this IOAudioEngine,
     *  it calls startAudioEngine().  There is no need to call this function directly.
	 *  A derived class that requires overriding of newUserClient should override the version with the properties
	 *  parameter for Intel targets, and without the properties parameter for PPC targets.  The #if __i386__ directive
	 *  can be used to select between the two behaviors.
     * @param task The task requesting the new user client.
     * @param securityID Optional security paramater passed in by the client - ignored.
     * @param type Optional user client type passed in by the client - ignored.
     * @param handler The new IOUserClient * must be stored in this param on a successful completion.
     * @param properties A dictionary of additional properties for the connection.
     * @result Returns kIOReturnSuccess on success.  May also result kIOReturnError or kIOReturnNoMemory.
     */
    virtual IOReturn newUserClient(task_t task, void *securityID, UInt32 type, IOUserClient **handler ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn newUserClient(task_t task, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function addAudioStream
     * @abstract Adds an IOAudioStream to the audio engine.
     * @discussion This function is called by the driver to add an IOAudioStream to the audio engine.  This must be called at least once to make sure the audio engine has at least one IOAudioStream.
     * @param stream The IOAudioStream to be added.
     * @result Returns kIOReturnSuccess if the stream was successfully added.
     */
    virtual IOReturn addAudioStream(IOAudioStream *stream ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOAudioStream *getAudioStream(IOAudioStreamDirection direction, UInt32 channelID ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void lockAllStreams( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void unlockAllStreams( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void updateChannelNumbers( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function resetStatusBuffer
     * @abstract Resets the status buffer to its default values.
     * @discussion This is called during startAudioEngine() and resumeAudioEngine() to clear out the status buffer
     *  in preparation of starting up the I/O engine.  There is no need to call this directly.
     */
    virtual void resetStatusBuffer( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function clearAllSampleBuffers
     * @abstract Zeros out all of the sample and mix buffers associated with the IOAudioEngine
     * @discussion This is called during resumeAudioEngine() since the audio engine gets started back at the
     *  beginning of the sample buffer.
     */
    virtual void clearAllSampleBuffers( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function getCurrentSampleFrame
     * @abstract Gets the current sample frame from the IOAudioEngine subclass.
     * @result
     */
    virtual UInt32 getCurrentSampleFrame() = 0;

    /*!
     * @function startAudioEngine
     * @abstract Starts the audio I/O engine.
     * @discussion This method is called automatically when the audio engine is placed into use the first time.
     *  This must be overridden by the subclass.  No call to the superclass's implementation is
     *  necessary.  The subclass's implementation must start up the audio I/O engine.  This includes any audio
     *  engine that needs to be started as well as any interrupts that need to be enabled.  Upon successfully
     *  starting the engine, the subclass's implementation must call setState(kIOAudioEngineRunning).  If
     *  it has also checked the state using getState() earlier in the implementation, the stateLock must be
     *  acquired for the entire initialization process (using IORecursiveLockLock(stateLock) and
     *  IORecursiveLockUnlock(stateLock)) to ensure that the state remains consistent.  See the general class
     *  comments for an example.
     * @result Must return kIOReturnSuccess on a successful start of the engine.
     */
    virtual IOReturn startAudioEngine( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function stopAudioEngine
     * @abstract Stops the audio I/O engine.
     * @discussion This method is called automatically when the last client disconnects from this audio engine.
     *  It must be overridden by the subclass.  No call to the superclass's implementation is necessary.
     *  The subclass's implementation must stop the audio I/O engine.  The audio engine (if it exists) should
     *  be stopped and any interrupts disabled.  Upon successfully stopping the engine, the subclass must call
     *  setState(kAudioEngineStopped).  If it has also checked the state using getState() earlier in the
     *  implementation, the stateLock must be acquired for the entire initialization process (using
     *  IORecursiveLockLock(stateLock) and IORecursiveLockUnlock(stateLock)) to ensure that the state remains
     *  consistent.
     * @result Must return kIOReturnSuccess on a successful stop of the engine.
     */
    virtual IOReturn stopAudioEngine( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn pauseAudioEngine( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn resumeAudioEngine( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function performAudioEngineStart
     * @abstract Called to start the audio I/O engine
     * @discussion This method is called by startAudioEngine().  This must be overridden by the subclass.
	 *	No call to the superclass' implementation is necessary.  The subclass' implementation must start up the
	 *	audio I/O engine.  This includes any audio engine that needs to be started as well as any interrupts
	 *	that need to be enabled.
     * @result Must return kIOReturnSuccess on a successful start of the engine.
     */
    virtual IOReturn performAudioEngineStart( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function performAudioEngineStop
     * @abstract Called to stop the audio I/O engine
     * @discussion This method is called by stopAudioEngine() and pauseAudioEngine.
     *  This must be overridden by the subclass.  No call to the superclass' implementation is
     *  necessary.  The subclass' implementation must stop the audio I/O engine.  This includes any audio
     *  engine that needs to be stopped as well as any interrupts that need to be disabled.
     * @result Must return kIOReturnSuccess on a successful stop of the engine.
     */
    virtual IOReturn performAudioEngineStop( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*! 
     * @function getState
     * @abstract Returns the current state of the IOAudioEngine.
     * @discussion If this method is called in preparation for calling setState(), the stateLock must
     *  be acquired before the first call to getState() and held until after the last call to setState().
     *  Be careful not to return from the code acquiring the lock while the lock is being held.  That
     *  will cause a deadlock situation.
     * @result The current state of the IOAudioEngine: kIOAudioEngineRunning, kIOAudioEngineStopped.
     */
    virtual IOAudioEngineState getState( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getSampleRate 
     * @abstract Returns the sample rate of the IOAudioEngine in samples per second.
     */
    virtual const IOAudioSampleRate *getSampleRate( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn hardwareSampleRateChanged(const IOAudioSampleRate *sampleRate ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getRunEraseHead 
     * @abstract Returns true if the audio engine will run the erase head when the audio engine is running.
     */
    virtual bool getRunEraseHead( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getStatus 
     * @abstract Returns a pointer to the shared status buffer.
     */
    virtual const IOAudioEngineStatus *getStatus( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function timerCallback
     * @abstract A static method used as a callback for the IOAudioDevice timer services.
     * @discussion This method implements the IOAudioDevice::TimerEvent type.
     * @param arg1 The IOAudioEngine that is the target of the event.
     * @param device The IOAudioDevice that sent the timer event.
     */
    static void timerCallback(OSObject *arg1, IOAudioDevice *device ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function timerFired
     * @abstract Indicates the timer has fired.
     * @discussion This method is called by timerCallback to indicate the timer has fired.  This method calls performErase() and performFlush() to do erase head processing and
     *  audio engine flushing each time the timer event fires.
     */
    virtual void timerFired( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function getTimerInterval
     * @abstract Gets the timer interval for use by the timer event.
     * @discussion This method is called each time the timer event is enabled through addTimer().  The default
     *  implementation is set to return a value such that the timer event runs n times each cycle of the audio
     *  engine through the sample buffer.  The value n is stored as the instance variable: numErasesPerBuffer.
     *  The default value of numErasesPerBuffer is set to IOAUDIOENGINE_DEFAULT_NUM_ERASES_PER_BUFFER which is 4.
     *  A subclass may change the value of numErasesPerBuffer or override getTimerInterval.  If it is overridden,
     *  the subclass should call the superclass's implementation, compare its interval with the superclass's and
     *  return the smaller of the two.
     * @result Returns the interval for the timer event.
     */
    virtual AbsoluteTime getTimerInterval( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function performErase
     * @abstract Performs erase head processing.
     * @discussion This method is called automatically each time the timer event fires and erases the sample
     *  buffer and mix buffer from the previous location up to the current location of the audio engine.
     */
    virtual void performErase( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function performFlush
     * @abstract Performs the flush operation.
     * @discussion This method is called automatically each time the timer event fires.  It stops the audio engine
     *  if there are no more clients and the audio engine is passed the latest flush ending position.
     */
    virtual void performFlush( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void stopEngineAtPosition(IOAudioEnginePosition *endingPosition ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual IOReturn mixOutputSamples(const void *sourceBuf, void *mixBuf, UInt32 firstSampleFrame, UInt32 numSampleFrames, const IOAudioStreamFormat *streamFormat, IOAudioStream *audioStream ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn clipOutputSamples(const void *mixBuf, void *sampleBuf, UInt32 firstSampleFrame, UInt32 numSampleFrames, const IOAudioStreamFormat *streamFormat, IOAudioStream *audioStream ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void resetClipPosition(IOAudioStream *audioStream, UInt32 clipSampleFrame ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn convertInputSamples(const void *sampleBuf, void *destBuf, UInt32 firstSampleFrame, UInt32 numSampleFrames, const IOAudioStreamFormat *streamFormat, IOAudioStream *audioStream ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void takeTimeStamp(bool incrementLoopCount = true, AbsoluteTime *timestamp = NULL ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn getLoopCountAndTimeStamp(UInt32 *loopCount, AbsoluteTime *timestamp ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual IOReturn calculateSampleTimeout(AbsoluteTime *sampleInterval, UInt32 numSampleFrames, IOAudioEnginePosition *startingPosition, AbsoluteTime *wakeupTime ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn performFormatChange(IOAudioStream *audioStream, const IOAudioStreamFormat *newFormat, const IOAudioSampleRate *newSampleRate ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void beginConfigurationChange( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void completeConfigurationChange( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void cancelConfigurationChange( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual IOReturn addDefaultAudioControl(IOAudioControl *defaultAudioControl ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn removeDefaultAudioControl(IOAudioControl *defaultAudioControl ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void removeAllDefaultAudioControls( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual OSString *getGlobalUniqueID( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual OSString *getLocalUniqueID( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

protected:

    /*!
     * @function initKeys
     * @abstract Generates the OSSymbols with the keys.
     * @discussion Do not call this directly.  This is an internal initialization routine.
     */ 
    static void initKeys( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void setNumSampleFramesPerBuffer(UInt32 numSampleFrames ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual UInt32 getNumSampleFramesPerBuffer( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setState
     * @abstract Indicates that the audio engine is in the specified state.
     * @discussion This method simply sets the internal state of the audio engine to the specified state.  It does not
     *  affect a change to the state.  It does however keep other internal state-related attributes consistent.
     *  For example, it enables or disables the timer as needed when the state changes to running or stopped.
     * @param newState The state the audio engine is in.
     * @result Returns the old state.
     */
    virtual IOAudioEngineState setState(IOAudioEngineState newState ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setSampleRate
     * @abstract Records the sample rate of the audio engine.
     * @discussion  This method must be called during initialization of a new audio engine to record the audio engine's
     *  initial sample rate.  It also is intended to be used to record changes to the sample rate during use.
     *  Currently changing sample rates after the audio engine has been started is not supported.
     *  It may require that the sample buffers be re-sized.  This will be available in an upcoming release.
     * @param newSampleRate The sample rate of the audio engine in samples per second.
     */
    virtual void setSampleRate(const IOAudioSampleRate *newSampleRate ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setSampleLatency
     * @abstract Sets the sample latency for the audio engine.
     * @discussion The sample latency represents the number of samples ahead of the playback head
     *  that it is safe to write into the sample buffer.  The audio device API will never write
     *  closer to the playback head than the number of samples specified.  For input audio engines
     *  the number of samples is behind the record head.
     */
    virtual void setSampleLatency(UInt32 numSamples ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void setOutputSampleLatency(UInt32 numSamples ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void setInputSampleLatency(UInt32 numSamples ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void setSampleOffset(UInt32 numSamples ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setRunEraseHead
     * @abstract Tells the audio engine whether or not to run the erase head.
     * @discussion By default, output audio engines run the erase head and input audio engines do not.  This method can
     *  be called after setDirection() is called in order to change the default behavior.
     * @param runEraseHead The audio engine will run the erase head if this value is true.
     */
    virtual void setRunEraseHead(bool runEraseHead ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function clientClosed
     * @abstract Called automatically when a user client closes its connection to the audio engine.
     * @discussion This method decrements the number of connections to the audio engine and if they reach
     *  zero, the audio engine is called with a call to stopAudioEngine().  This method should not be called directly.
     * @param client The user client that has disconnected.
     */
    virtual void clientClosed(IOAudioEngineUserClient *client ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function addTimer
     * @abstract Enables the timer event for the audio engine.
     * @discussion There is a timer event needed by the IOAudioEngine for processing the erase head
     *  and performing flushing operations. When the timer fires, the method timerFired() is ultimately
     *  called which in turn calls performErase() and performFlush().  This is called automatically
     *  to enable the timer event for this audio engine.  It is called by setState() when the audio engine state
     *  is set to kIOAudioEngineRunning.  When the timer is no longer needed, removeTimer() is called.
     *  There is no need to call this directly.  
     */
    virtual void addTimer( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function removeTimer
     * @abstract Disables the timer event for the audio engine.
     * @discussion  This method is called automatically to disable the timer event for this audio engine.
     *  There is need to call it directly.  This method is called by setState() when the audio engine state
     *  is changed from kIOAudioEngineRunning to one of the stopped states.
     */
    virtual void removeTimer( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual void sendFormatChangeNotification(IOAudioStream *audioStream ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void sendNotification(UInt32 notificationType ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn createUserClient(task_t task, void *securityID, UInt32 type, IOAudioEngineUserClient **newUserClient ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	static IOReturn _addUserClientAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;		// <rdar://7529580>
    static IOReturn addUserClientAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	static IOReturn _removeUserClientAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>
    static IOReturn removeUserClientAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    static IOReturn detachUserClientsAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4 ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn addUserClient(IOAudioEngineUserClient *newUserClient ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn removeUserClient(IOAudioEngineUserClient *userClient ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn detachUserClients( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn startClient(IOAudioEngineUserClient *userClient ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn stopClient(IOAudioEngineUserClient *userClient ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn incrementActiveUserClients( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn decrementActiveUserClients( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void detachAudioStreams( ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	void setWorkLoopOnAllAudioControls(IOWorkLoop *wl ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	static inline void lockStreamForIO(IOAudioStream *stream ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	static inline void unlockStreamForIO(IOAudioStream *stream ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// These aren't virtual by design
	UInt32 getNextStreamID(IOAudioStream * newStream ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	IOAudioStream * getStreamForID(UInt32 streamID ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	IOReturn waitForEngineResume ( void );										// <rdar://15485249>

	static void setCommandGateUsage(IOAudioEngine *engine, bool increment ) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;		// <rdar://8518215>

};

#endif /* _IOKIT_IOAUDIOENGINE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                IOAudioEngineUserClient.h                                                                           0100644 0001750 0001750 00000044336 12567452612 037726  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOAUDIOENGINEUSERCLIENT_H
#define _IOKIT_IOAUDIOENGINEUSERCLIENT_H

#include <IOKit/IOUserClient.h>
#include <AvailabilityMacros.h>

#ifndef IOAUDIOFAMILY_SELF_BUILD
#include <IOKit/audio/IOAudioEngine.h>
#include <IOKit/audio/IOAudioTypes.h>
#else
#include "IOAudioEngine.h"
#include "IOAudioTypes.h"
#endif
#include <IOKit/IOBufferMemoryDescriptor.h>

class IOAudioEngine;
class IOAudioStream;
class IOMemoryDescriptor;
class IOCommandGate;
class IOWorkLoop;

class IOAudioEngineUserClient;
class IOAudioClientBufferSet;
struct IOAudioFormatNotification;

typedef struct IOAudioClientBuffer
{
    IOAudioEngineUserClient		*userClient;
    IOAudioStream 				*audioStream;
    void						*sourceBuffer;
    IOMemoryDescriptor			*sourceBufferDescriptor;
    IOMemoryMap					*sourceBufferMap;
    void						*unmappedSourceBuffer; 
    UInt32						numSampleFrames;
    UInt32						numChannels;
    IOAudioEnginePosition		mixedPosition;
    struct IOAudioClientBuffer	*mNextBuffer32;
    struct IOAudioClientBuffer	*nextClip;
    struct IOAudioClientBuffer	*previousClip;
    struct IOAudioClientBuffer	*nextClient;
	IOAudioBufferDataDescriptor *bufferDataDescriptor;
} IOAudioClientBuffer;

/* IOAudioClientBuffer64 added for binary compatibility with old PPC drivers covered by <rdar://problem/4651809> */
typedef struct IOAudioClientBuffer64 
{
    IOAudioClientBuffer				mAudioClientBuffer32;
    mach_vm_address_t				mUnmappedSourceBuffer64;
    struct IOAudioClientBuffer64	*mNextBuffer64;
} IOAudioClientBuffer64;

typedef struct IOAudioClientBufferExtendedInfo
{
	// Added stuff for registerClientParameterBuffer
	UInt32						bufferSetID;
	void						*paramBuffer;
	IOMemoryDescriptor			*paramBufferDescriptor;
	IOMemoryMap					*paramBufferMap;
	void						*unmappedParamBuffer;
	struct IOAudioClientBufferExtendedInfo	*mNextExtended;
} IOAudioClientBufferExtendedInfo;

/* IOAudioClientBufferExtendedInfo64 added for binary compatibility with old PPC drivers covered by <rdar://problem/4651809>  */
typedef struct IOAudioClientBufferExtendedInfo64 
{
	IOAudioClientBufferExtendedInfo mAudioClientBufferExtended32;
	mach_vm_address_t			mUnmappedParamBuffer64;
	struct IOAudioClientBufferExtendedInfo64	*mNextExtended64;
}	IOAudioClientBufferExtendedInfo64;


class IOAudioEngineUserClient : public IOUserClient
{
	OSDeclareDefaultStructors(IOAudioEngineUserClient)
	
	friend class IOAudioEngine;
	friend class IOAudioClientBufferSet;
	friend class IOAudioStream;
	
protected:
	IOAudioEngine				*audioEngine;
	
	IOWorkLoop					*workLoop;
	IOCommandGate				*commandGate;
	
	IOExternalMethod			old_methods[5];		// It's size can't be changed for binary compatibility reasons, no longer used.
	IOExternalTrap				trap;
	
	task_t						clientTask;
	UInt32						numSampleFrames;		// Never used...
	
	IOAudioClientBufferSet		*clientBufferSetList;
	IORecursiveLock 			*clientBufferLock;
	
	IOAudioNotificationMessage	*notificationMessage;
	
	bool						online;
	
protected:
	struct ExpansionData {
		IOAudioClientBufferExtendedInfo64	*extendedInfo;
		IOExternalMethod					methods[kIOAudioEngineNumCalls];		// This size can be changed, this is the new methods pointer
		UInt32								classicMode;
		UInt32								commandGateStatus;						// <rdar://8518215>
		SInt32								commandGateUsage;						// <rdar://8518215>
	};

// <rdar://101000004> START
	ExpansionData *reserved;
	
public:
	virtual IOReturn externalMethod( uint32_t selector, IOExternalMethodArguments * arguments, 	IOExternalMethodDispatch * dispatch, 
									OSObject * target, 	void * reference) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// New code added here...
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 0);	
	virtual IOReturn registerClientParameterBuffer (void * parameterBuffer, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;  // unused function
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 1);	
	virtual IOAudioClientBufferExtendedInfo * findExtendedInfo(UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 2);	
	virtual IOReturn getNearestStartTime(IOAudioStream *audioStream, IOAudioTimeStamp *ioTimeStamp, UInt32 isInput) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 3);	
	virtual IOReturn getClientNearestStartTime(IOAudioStream *audioStream, IOAudioTimeStamp *ioTimeStamp, UInt32 isInput) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 4);	
	virtual IOReturn safeRegisterClientBuffer(UInt32 audioStreamIndex, void * sourceBuffer, UInt32 bufSizeInBytes, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 5);	
	virtual bool initWithAudioEngine(IOAudioEngine *engine, task_t task, void *securityToken, UInt32 type, OSDictionary *properties) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 6);	<rdar://problems/5321701>
	virtual IOReturn safeRegisterClientBuffer64(UInt32 audioStreamIndex, mach_vm_address_t * sourceBuffer, UInt32 bufSizeInBytes, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 7);	<rdar://problems/5321701>
	virtual IOReturn registerClientBuffer64(IOAudioStream *audioStream, mach_vm_address_t sourceBuffer, UInt32 bufSizeInBytes, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 8);	<rdar://problems/5321701>
	virtual IOReturn registerBuffer64(IOAudioStream *audioStream, mach_vm_address_t sourceBuffer, UInt32 bufSizeInBytes, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 9);	<rdar://problems/5321701>
	virtual IOReturn unregisterBuffer64(mach_vm_address_t sourceBuffer, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 10);	<rdar://problems/5321701>
	virtual IOReturn unregisterClientBuffer64(mach_vm_address_t  * sourceBuffer, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 11);	 <rdar://problems/5321701>
	virtual IOAudioClientBufferExtendedInfo64 * findExtendedInfo64(UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	
	
private:
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 0);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 1);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 2);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 3);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 4);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 5);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 6);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 7);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 8);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 9);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 10);
	OSMetaClassDeclareReservedUsed(IOAudioEngineUserClient, 11);
	
	
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 12);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 13);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 14);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 15);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 16);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 17);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 18);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 19);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 20);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 21);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 22);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 23);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 24);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 25);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 26);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 27);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 28);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 29);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 30);
	OSMetaClassDeclareReservedUnused(IOAudioEngineUserClient, 31);
	
protected:
	virtual IOReturn clientClose() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn clientDied() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	static IOReturn _closeClientAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>
	static IOReturn closeClientAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn closeClient() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	
	virtual IOReturn clientMemoryForType(UInt32 type, UInt32 *flags, IOMemoryDescriptor **memory) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOExternalMethod *getExternalMethodForIndex(UInt32 index) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOExternalTrap *getExternalTrapForIndex(UInt32 index) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn registerNotificationPort(mach_port_t port, UInt32 type, UInt32 refCon) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	static IOReturn _registerNotificationAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>
	static IOReturn registerNotificationAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn registerNotification(mach_port_t port, UInt32 refCon) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	virtual void setOnline(bool newOnline) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual IOReturn performClientOutput(UInt32 firstSampleFrame, UInt32 loopCount, IOAudioClientBufferSet *bufferSet, UInt32 sampleIntervalHi, UInt32 sampleIntervalLo) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn performClientInput(UInt32 firstSampleFrame, IOAudioClientBufferSet *bufferSet) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual void performWatchdogOutput(IOAudioClientBufferSet *clientBufferSet, UInt32 generationCount) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual void lockBuffers() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual void unlockBuffers() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	static void setCommandGateUsage(IOAudioEngineUserClient *userClient, bool increment) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;		// <rdar://8518215>

public:
	
	static IOAudioEngineUserClient *withAudioEngine(IOAudioEngine *engine, task_t clientTask, void *securityToken, UInt32 type) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	static IOAudioEngineUserClient *withAudioEngine(IOAudioEngine *engine, task_t clientTask, void *securityToken, UInt32 type, OSDictionary *properties) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual bool initWithAudioEngine(IOAudioEngine *engine, task_t task, void *securityToken, UInt32 type) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual void free() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual void freeClientBufferSetList() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual void freeClientBuffer(IOAudioClientBuffer64 *clientBuffer) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual void stop(IOService *provider) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual bool isOnline() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual IOReturn registerBuffer(IOAudioStream *audioStream, void* sourceBuffer, UInt32 bufSizeInBytes, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn unregisterBuffer( void * sourceBuffer, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	static IOReturn _registerBufferAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>
	static IOReturn registerBufferAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	static IOReturn _unregisterBufferAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>
	static IOReturn unregisterBufferAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual IOReturn registerClientBuffer(IOAudioStream *audioStream, void * sourceBuffer, UInt32 bufSizeInBytes, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn unregisterClientBuffer(void * sourceBuffer, UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	static IOReturn _getNearestStartTimeAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>
	static IOReturn getNearestStartTimeAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual IOAudioClientBufferSet *findBufferSet(UInt32 bufferSetID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual void removeBufferSet(IOAudioClientBufferSet *bufferSet) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual IOReturn getConnectionID(UInt32 *connectionID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual IOReturn clientStart() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn clientStop() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	static IOReturn _startClientAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>
	static IOReturn startClientAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	static IOReturn _stopClientAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://7529580>
	static IOReturn stopClientAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual IOReturn startClient() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn stopClient() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual IOReturn performClientIO(UInt32 firstSampleFrame, UInt32 loopCount, bool inputIO, UInt32 bufferSetID, UInt32 sampleIntervalHi, UInt32 sampleIntervalLo) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	virtual void sendFormatChangeNotification(IOAudioStream *audioStream) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	virtual IOReturn sendNotification(UInt32 notificationType) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
};

// <rdar://101000004> END


#endif /* _IOKIT_IOAUDIOENGINEUSERCLIENT_H */
                                                                                                                                                                                                                                                                                                  IOAudioLevelControl.h                                                                               0100644 0001750 0001750 00000024236 12567452612 037130  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOAUDIOLEVELCONTROL_H
#define _IOKIT_IOAUDIOLEVELCONTROL_H

#include <AvailabilityMacros.h>

#ifndef IOAUDIOFAMILY_SELF_BUILD
#include <IOKit/audio/IOAudioControl.h>
#else
#include "IOAudioControl.h"
#endif

class OSArray;

/*!
 * @class IOAudioLevelControl
 * @abstract
 * @discussion
 */

class IOAudioLevelControl : public IOAudioControl
{
    OSDeclareDefaultStructors(IOAudioLevelControl)

protected:
    SInt32	minValue;
    SInt32	maxValue;
    IOFixed	minDB;
    IOFixed	maxDB;
    
    OSArray *ranges;
    
protected:
    struct ExpansionData { };
    
    ExpansionData *reserved;

public:
	static IOAudioLevelControl *createPassThruVolumeControl (SInt32 initialValue,
                                                                SInt32 minValue,
                                                                SInt32 maxValue,
                                                                IOFixed minDB,
                                                                IOFixed maxDB,
                                                                UInt32 channelID,
                                                                const char *channelName,
                                                                UInt32 cntrlID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

	// OSMetaClassDefineReservedUnused(IOAudioLevelControl, 0);
    /*!
	 * @function setLinearScale
     * @abstract This function tells CoreAudio if it should apply a curve to the scaler representation of the volume.
	 * @param useLinearScale TRUE instructs CoreAudio to not apply a curve to the scaler representation of the volume,
	 * FALSE instructs CoreAudio to apply a curve, which is CoreAudio's default behavior.
     */
	virtual void setLinearScale(bool useLinearScale) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

private:
    OSMetaClassDeclareReservedUsed(IOAudioLevelControl, 0);

    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 1);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 2);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 3);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 4);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 5);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 6);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 7);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 8);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 9);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 10);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 11);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 12);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 13);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 14);
    OSMetaClassDeclareReservedUnused(IOAudioLevelControl, 15);

public:
    /*!
     * @function create
     * @abstract Allocates a new level control with the given attributes
     * @param initialValue The initial value of the control
     * @param minValue The lowest possible value the control may have 
     * @param maxValue The highest possible value the control may have
     * @param minDB A fixed point representation of the db value matching minValue 
     * @param maxDB A fixed point representation of the db value matching maxValue 
     * @param channelID The ID of the channel(s) that the control acts on.  Common IDs are located in IOAudioTypes.h.
     * @param channelName An optional name for the channel.  Common names are located in IOAudioTypes.h.
     * @param cntrlID An optional ID for the control that can be used to uniquely identify controls.
     * @result Returns a newly allocted and initialized level IOAudioControl
     */
    static IOAudioLevelControl *create(SInt32 initialValue,
                                       SInt32 minValue,
                                       SInt32 maxValue,
                                       IOFixed minDB,
                                       IOFixed maxDB,
                                       UInt32 channelID,
                                       const char *channelName = 0,
                                       UInt32 cntrlID = 0,
                                       UInt32 subType = 0,
                                       UInt32 usage = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
                                       
    static IOAudioLevelControl *createVolumeControl(SInt32 initialValue,
                                                    SInt32 minValue,
                                                    SInt32 maxValue,
                                                    IOFixed minDB,
                                                    IOFixed maxDB,
                                                    UInt32 channelID,
                                                    const char *channelName = 0,
                                                    UInt32 cntrlID = 0,
                                                    UInt32 usage = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function init
     * @abstract Initializes a newly allocated IOAudioLevelControl with the given attributes
     * @param initialValue The initial value of the control
     * @param minValue The lowest possible value the control may have 
     * @param maxValue The highest possible value the control may have
     * @param minDB A fixed point representation of the db value matching minValue 
     * @param maxDB A fixed point representation of the db value matching maxValue 
     * @param channelID The ID of the channel(s) that the control acts on.  Common IDs are located in IOAudioTypes.h.
     * @param channelName An optional name for the channel.  Common names are located in IOAudioTypes.h.
     * @param cntrlID An optional ID for the control that can be used to uniquely identify controls.
     * @param properties Standard property list passed to the init() function of any new IOService.  This dictionary
     *  gets stored in the registry entry for this service.
     * @result Returns true on success
     */
    virtual bool init(SInt32 initialValue,
                      SInt32 minValue,
                      SInt32 maxValue,
                      IOFixed minDB,
                      IOFixed maxDB,
                      UInt32 channelID,
                      const char *channelName = 0,
                      UInt32 cntrlID = 0,
                      UInt32 subType = 0,
                      UInt32 usage = 0,
                      OSDictionary *properties = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
                      
    virtual void free() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function setMinValue
     * @abstract Sets the minimum value the control may have
     * @param minValue The minimum value for the control
     */
    virtual void setMinValue(SInt32 minValue) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual SInt32 getMinValue() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
     
    /*!
     * @function setMaxValue
     * @abstract Sets the maximum value the control may have
     * @param maxValue The maximum value for the control
     */ 
    virtual void setMaxValue(SInt32 maxValue) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual SInt32 getMaxValue() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
     
     /*!
     * @function setMinDB
     * @abstract Sets the minimum value in db that the control may have
     * @discussion This value is represented as an IOFixed value which is a fixed point number.  The IOFixed
     *  type is a 16.16 fixed point value.
     * @param minDB The minimum value in db for the control
     */
    virtual void setMinDB(IOFixed minDB) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual IOFixed getMinDB() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    /*!
     * @function setMaxDB
     * @abstract Sets the maximum value in db that the control may have
     * @discussion This value is represented as an IOFixed value which is a fixed point number.  The IOFixed
     *  type is a 16.16 fixed point value.
     * @param maxDB The maximum value in db for the control
     */
    virtual void setMaxDB(IOFixed maxDB) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual IOFixed getMaxDB() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn addRange(SInt32 minValue, SInt32 maxValue, IOFixed minDB, IOFixed maxDB) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn addNegativeInfinity(SInt32 negativeInfinityValue) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn validateValue(OSObject *newValue) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
};

#endif /* _IOKIT_IOAUDIOLEVELCONTROL_H */
                                                                                                                                                                                                                                                                                                                                                                  IOAudioPort.h                                                                                       0100644 0001750 0001750 00000023025 12567452612 035437  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOAUDIOPORT_H
#define _IOKIT_IOAUDIOPORT_H

#include <IOKit/IOService.h>
#include <AvailabilityMacros.h>

class IOAudioDevice;
class IOAudioControl;
class OSDictionary;

/*!
 * @class IOAudioPort
 * @abstract Represents a logical or physical port or functional unit in an audio device.
 * @discussion An IOAudioPort represents an element in the signal chain in the audio device.  It may contain
 *  one or more controls (represented by IOAudioControl) by which different attributes of the port may be
 *  represented and adjusted.
 *
 *  IOAudioPort objects are connected up in the IORegistry in the IOAudioPlane to represent the signal chain of
 *  the device.  They may be connected to other IOAudioPorts as well as IOAudioEngines to indicate they either
 *  feed into or are fed by one of the audio engines (i.e. they provide input to or take output from the computer).
 */
class IOAudioPort : public IOService
{
    friend class IOAudioDevice;

    OSDeclareDefaultStructors(IOAudioPort)

public:
    /* @var audioDevice The IOAudioDevice that this IOAudioPort belongs to. */
    IOAudioDevice *	audioDevice;
    /* @var audioControls A set containg all of the IOAudioControl instances that belong to the port. */
    OSSet *		audioControls;
    bool		isRegistered;

protected:
    struct ExpansionData { };
    
    ExpansionData *reserved;
    
private:
    OSMetaClassDeclareReservedUnused(IOAudioPort, 0);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 1);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 2);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 3);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 4);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 5);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 6);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 7);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 8);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 9);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 10);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 11);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 12);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 13);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 14);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 15);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 16);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 17);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 18);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 19);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 20);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 21);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 22);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 23);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 24);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 25);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 26);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 27);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 28);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 29);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 30);
    OSMetaClassDeclareReservedUnused(IOAudioPort, 31);

public:
    /*!
     * @function withAttributes
     * @abstract Allocates a new IOAudioPort instance with the given attributes
     * @discussion This static method allocates a new IOAudioPort and calls initWithAttributes() on it with
     *  the parameters passed in to it.
     * @param portType A readable string representing the type of port.  Common port types are defined in
     *  IOAudioTypes.h and are prefixed with 'kIOAudioPortType'.  Please provide feedback if there are
     *  other common port types that should be included.
     * @param portName A readable string representing the name of the port.  For example: 'Internal Speaker',
     *  'Line Out'.  This field is optional, but useful for providing information to the application/user.
     * @param subType Developer defined readable string representing a subtype for the port. (optional)
     * @param properties Standard property list passed to the init of any new IOService.  This dictionary
     *  gets stored in the registry for this instance. (optional)
     * @result Returns the newly allocated and initialized IOAudioPort instance.
     */
    static IOAudioPort *withAttributes(UInt32 portType, const char *portName = 0, UInt32 subType = 0, OSDictionary *properties = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function initWithAttributes
     * @abstract Initializes a newly allocated IOAudioPort instance with the given attributes
     * @discussion The properties parameter is passed on the superclass' init().  The portType, subType
     *  and properties parameters are optional, however portType is recommended.
     * @param portType A readable string representing the type of port.  Common port types are defined in
     *  IOAudioTypes.h and are prefixed with 'kIOAudioPortType'.  Please provide feedback if there are
     *  other common port types that should be included.
     * @param portName A readable string representing the name of the port.  For example: 'Internal Speaker',
     *  'Line Out'.  This field is optional, but useful for providing information to the application/user.
     * @param subType Developer defined readable string representing a subtype for the port. (optional)
     * @param properties Standard property list passed to the init of any new IOService.  This dictionary
     *  gets stored in the registry for this instance. (optional)
     * @result Returns true on success.
     */
    virtual bool initWithAttributes(UInt32 portType, const char *portName = 0, UInt32 subType = 0, OSDictionary *properties = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function free
     * @abstract Frees all of the resources allocated by the IOAudioPort.
     * @discussion Do not call this directly.  This is called automatically by the system when the instance's
     *  refcount goes to 0.  To decrement the refcount, call release() on the object.
     */
    virtual void free() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function start
     * @abstract Called to start a newly created IOAudioPort.
     * @discussion This is called automatically by IOAudioDevice when attachAudioPort() is called.
     * @param provider The IOAudioDevice that owns this port
     * @result Returns true on success
     */
    virtual bool start(IOService *provider) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function stop
     * @abstract Called when the IOAudioDevice is stopping when it is no longer available.
     * @discussion This method calls deactivateAudioControls() to shut down all of the controls associated with
     *  this port.
     * @param provider The IOAudioDevice that owns this port
     */
    virtual void stop(IOService *provider) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual void registerService(IOOptionBits options = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual IOAudioDevice *getAudioDevice() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function addAudioControl
     * @abstract Adds a newly created IOAudioControl instance to the port.
     * @discussion This method is responsible for starting the new IOAudioControl and adding it to the internal
     *  audioControls array.
     * @param control A newly created IOAudioControl instance that should belong to this port.
     * @result Returns true on successfully staring the IOAudioControl.
     */
    virtual IOReturn addAudioControl(IOAudioControl *control) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function deactivateAudioControls
     * @abstract Called to shut down all of the audio controls for this port.
     * @discussion This will stop all of the audio controls and release them so that the instances may be
     *  freed.  This is called from the free() method.
     */
    virtual void deactivateAudioControls() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

protected:
    virtual void setType(UInt32 portType) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void setSubType(UInt32 subType) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void setName(const char *name) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
};

#endif /* _IOKIT_IOAUDIOPORT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           IOAudioSelectorControl.h                                                                            0100644 0001750 0001750 00000015461 12567452612 037641  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOAUDIOSELECTORCONTROL_H
#define _IOKIT_IOAUDIOSELECTORCONTROL_H

#include <AvailabilityMacros.h>

#ifndef IOAUDIOFAMILY_SELF_BUILD
#include <IOKit/audio/IOAudioControl.h>
#else
#include "IOAudioControl.h"
#endif

class OSString;
class OSArray;

class IOAudioSelectorControl : public IOAudioControl
{
    OSDeclareDefaultStructors(IOAudioSelectorControl)
    
protected:

    OSArray *availableSelections;

protected:
    struct ExpansionData { };
    
    ExpansionData *reserved;

public:
	static IOAudioSelectorControl *createOutputSelector(SInt32 initialValue,
															UInt32 channelID,
															const char *channelName = 0,
															UInt32 cntrlID = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	static IOAudioSelectorControl *createOutputClockSelector(SInt32 initialValue,
                                                                    UInt32 channelID,
																	UInt32 clockSource,
                                                                    const char *channelName = 0,
                                                                    UInt32 cntrlID = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	static IOAudioSelectorControl *createInputClockSelector(SInt32 initialValue,
                                                                    UInt32 channelID,
																	UInt32 clockSource,
                                                                    const char *channelName = 0,
                                                                    UInt32 cntrlID = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    // OSMetaClassDeclareReservedUsed(IOAudioSelectorControl, 0);
	virtual IOReturn removeAvailableSelection(SInt32 selectionValue) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    // OSMetaClassDeclareReservedUsed(IOAudioSelectorControl, 1);
	virtual IOReturn replaceAvailableSelection(SInt32 selectionValue, const char *selectionDescription) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    // OSMetaClassDeclareReservedUsed(IOAudioSelectorControl, 2);
	virtual IOReturn replaceAvailableSelection(SInt32 selectionValue, OSString *selectionDescription) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    // OSMetaClassDeclareReservedUsed(IOAudioSelectorControl, 3);
	virtual IOReturn addAvailableSelection(SInt32 selectionValue, OSString *selectionDescription, const char* pszName, OSObject* tag) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;		// <rdar://8202424>

private:
    OSMetaClassDeclareReservedUsed(IOAudioSelectorControl, 0);
    OSMetaClassDeclareReservedUsed(IOAudioSelectorControl, 1);
    OSMetaClassDeclareReservedUsed(IOAudioSelectorControl, 2);
    OSMetaClassDeclareReservedUsed(IOAudioSelectorControl, 3);			// <rdar://8202424>

    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 4);		// <rdar://8202424>

    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 5);		// <rdar://8202424>
    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 6);
    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 7);
    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 8);
    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 9);
    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 10);
    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 11);
    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 12);
    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 13);
    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 14);
    OSMetaClassDeclareReservedUnused(IOAudioSelectorControl, 15);

public:
    static IOAudioSelectorControl *create(SInt32 initialValue,
                                            UInt32 channelID,
                                            const char *channelName = 0,
                                            UInt32 cntrlID = 0,
                                            UInt32 subType = 0,
                                            UInt32 usage = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
                                            
    static IOAudioSelectorControl *createInputSelector(SInt32 initialValue,
                                                        UInt32 channelID,
                                                        const char *channelName = 0,
                                                        UInt32 cntrlID = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
                                                        
    virtual bool init(SInt32 initialValue,
                      UInt32 channelID,
                      const char *channelName = 0,
                      UInt32 cntrlID = 0,
                      UInt32 subType = 0,
                      UInt32 usage = 0,
                      OSDictionary *properties = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual void free() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual IOReturn addAvailableSelection(SInt32 selectionValue, const char *selectionDescription) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn addAvailableSelection(SInt32 selectionValue, OSString *selectionDescription) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual bool valueExists(SInt32 selectorValue) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual IOReturn validateValue(OSObject *newValue) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

};

#endif /* _IOKIT_IOAUDIOSELECTORCONTROL_H */
                                                                                                                                                                                                               IOAudioStream.h                                                                                     0100644 0001750 0001750 00000045036 12567452612 035754  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOAUDIOSTREAM_H
#define _IOKIT_IOAUDIOSTREAM_H

#include <IOKit/IOService.h>
#include <AvailabilityMacros.h>

#ifndef IOAUDIOFAMILY_SELF_BUILD
#include <IOKit/audio/IOAudioEngine.h>
#include <IOKit/audio/IOAudioTypes.h>
#else
#include "IOAudioEngine.h"
#include "IOAudioTypes.h"
#endif

class OSSymbol;
class OSArray;
class OSDictionary;
class OSSet;

class IOCommandGate;
class IOAudioControl;

struct IOAudioClientBuffer;
struct IOAudioStreamFormatDesc;

/*!
 * @class IOAudioStream
 * @abstract This class wraps a single sample buffer in an audio driver.
 * @discussion An IOAudioStream represents one hardware sample buffer as well as the direction
 *  of that buffer, the mix buffer that multiple clients mix into as well as a list of
 *  all of the formats to which this buffer can be set.
 *
 *  When an IOAudioEngine is created during init time in the driver, an IOAudioStream must be
 *  created for each sample buffer in the device.  Typically, the sample buffer will be interleaved 
 *  (or single channel), as a non-interleaved buffer should be divided into multiple single-channel
 *  buffers (and multiple IOAudioStreams).
 *
 *  Additionally, when an IOAudioStream is created it must have all of the possible formats (and
 *  allowed sample rates for each format) set and must have the currently set format specified
 *  (addAvailableFormat() and setFormat()).
 */

class IOAudioStream : public IOService
{
    OSDeclareDefaultStructors(IOAudioStream)
    
    friend class IOAudioEngine;
    friend class IOAudioEngineUserClient;

public:

    typedef IOReturn (*AudioIOFunction)(const void *mixBuf, void *sampleBuf, UInt32 firstSampleFrame, UInt32 numSampleFrames, const IOAudioStreamFormat *streamFormat, IOAudioStream *audioStream) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    static const OSSymbol	*gDirectionKey;
    static const OSSymbol	*gNumChannelsKey;
    static const OSSymbol	*gSampleFormatKey;
    static const OSSymbol	*gNumericRepresentationKey;
    static const OSSymbol	*gBitDepthKey;
    static const OSSymbol	*gBitWidthKey;
    static const OSSymbol	*gAlignmentKey;
    static const OSSymbol	*gByteOrderKey;
    static const OSSymbol	*gIsMixableKey;
    static const OSSymbol	*gDriverTagKey;
    static const OSSymbol	*gMinimumSampleRateKey;
    static const OSSymbol	*gMaximumSampleRateKey;

    static void initKeys() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    static OSDictionary *createDictionaryFromFormat(const IOAudioStreamFormat *streamFormat, const IOAudioStreamFormatExtension *formatExtension, OSDictionary *formatDict = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    static IOAudioStreamFormat *createFormatFromDictionary(const OSDictionary *formatDict, IOAudioStreamFormat *streamFormat = 0, IOAudioStreamFormatExtension *formatExtension = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    IOAudioEngine 				*audioEngine;
    IOWorkLoop					*workLoop;
    IOCommandGate				*commandGate;
    IORecursiveLock				*streamIOLock;
    
    UInt32						numClients;

    IOAudioStreamDirection		direction;

    IOAudioStreamFormat			format;
    IOAudioStreamFormatDesc		*availableFormats;
    OSArray						*availableFormatDictionaries;
    UInt32						numAvailableFormats;
    
    UInt32						startingChannelID;
    UInt32						maxNumChannels;
    
    void						*sampleBuffer;
    UInt32						sampleBufferSize;

    void						*mixBuffer;
    UInt32						mixBufferSize;
    bool						streamAllocatedMixBuffer;
    
    AudioIOFunction				*audioIOFunctions;
    UInt32						numIOFunctions;
    
    bool						streamAvailable;
    
    OSSet						*defaultAudioControls;
    
    IOAudioEnginePosition		startingPosition;
    IOAudioEnginePosition		clippedPosition;
    
    IOAudioClientBuffer			*clientBufferListStart;
    IOAudioClientBuffer			*clientBufferListEnd;
    
    IOAudioClientBuffer			*userClientList;
	
protected:

	enum {
		kErrorLogClipMoreThanOneBufferAhead = 0,
		kErrorLogClipMoreThanOneBufferAheadPart2,
		kErrorLogClipPositionIsOff,
		kErrorLogAlreadyClipped,
		kErrorLogClipBuffersAreNULL,
		kErrorLogClipReturnsAnError,
		kErrorLogNumberOfCounters,			// needs to be after the last counter
		kErrorLogDumpCounters = 0xFFFF
	};

    struct ExpansionData {
		IOAudioStreamFormatExtension	streamFormatExtension;
		UInt32							mSampleFramesReadByEngine;
		IOReturn						mClipOutputStatus;
		unsigned int					mStreamErrorCounts[kErrorLogNumberOfCounters];
		bool							mStreamErrorCountsUpdated;						 
	};
    
    ExpansionData *reserved;

public:
// New code added here:
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 0);
    virtual const IOAudioStreamFormatExtension *getFormatExtension() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 1);
    virtual IOReturn setFormat(const IOAudioStreamFormat *streamFormat, const IOAudioStreamFormatExtension *formatExtension, bool callDriver = true) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 2);
    virtual IOReturn setFormat(const IOAudioStreamFormat *streamFormat, const IOAudioStreamFormatExtension *formatExtension, OSDictionary *formatDict, bool callDriver = true) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 3);
    virtual void addAvailableFormat(const IOAudioStreamFormat *streamFormat, const IOAudioStreamFormatExtension *formatExtension, const IOAudioSampleRate *minRate, const IOAudioSampleRate *maxRate, const AudioIOFunction *ioFunctionList = NULL, UInt32 numFunctions = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 4);
    virtual void addAvailableFormat(const IOAudioStreamFormat *streamFormat, const IOAudioStreamFormatExtension *formatExtension, const IOAudioSampleRate *minRate, const IOAudioSampleRate *maxRate, AudioIOFunction ioFunction) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 5);
    virtual bool validateFormat(IOAudioStreamFormat *streamFormat, IOAudioStreamFormatExtension *formatExtension, IOAudioStreamFormatDesc *formatDesc) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 6);
	virtual void setTerminalType(const UInt32 terminalType) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 7);
	virtual IOReturn mixOutputSamples(const void *sourceBuf, void *mixBuf, UInt32 firstSampleFrame, UInt32 numSampleFrames, const IOAudioStreamFormat *streamFormat, IOAudioStream *audioStream) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 8);
	virtual void setSampleLatency(UInt32 numSamples) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 9);
	virtual bool validateFormat(IOAudioStreamFormat *streamFormat, IOAudioStreamFormatExtension *formatExtension, IOAudioStreamFormatDesc *formatDesc, const IOAudioSampleRate *sampleRate) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 10);
	virtual UInt32 getNumSampleFramesRead() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	// OSMetaClassDeclareReservedUsed(IOAudioStream, 11);
	virtual void setDefaultNumSampleFramesRead(UInt32) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

private:
    OSMetaClassDeclareReservedUsed(IOAudioStream, 0);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 1);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 2);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 3);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 4);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 5);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 6);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 7);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 8);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 9);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 10);
    OSMetaClassDeclareReservedUsed(IOAudioStream, 11);

    OSMetaClassDeclareReservedUnused(IOAudioStream, 12);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 13);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 14);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 15);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 16);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 17);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 18);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 19);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 20);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 21);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 22);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 23);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 24);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 25);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 26);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 27);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 28);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 29);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 30);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 31);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 32);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 33);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 34);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 35);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 36);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 37);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 38);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 39);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 40);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 41);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 42);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 43);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 44);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 45);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 46);
    OSMetaClassDeclareReservedUnused(IOAudioStream, 47);

public:
    virtual bool initWithAudioEngine(IOAudioEngine *engine, IOAudioStreamDirection dir, UInt32 startChannelID, const char *streamDescription = NULL, OSDictionary *properties = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void free() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void stop(IOService *provider) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOWorkLoop *getWorkLoop() const;

    virtual IOReturn setProperties(OSObject *properties) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual IOAudioStreamDirection getDirection() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual void setSampleBuffer(void *buffer, UInt32 size) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void *getSampleBuffer() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual UInt32 getSampleBufferSize() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void setMixBuffer(void *buffer, UInt32 size) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void *getMixBuffer() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual UInt32 getMixBufferSize() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void numSampleFramesPerBufferChanged() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual void clearSampleBuffer() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void setIOFunction(AudioIOFunction ioFunction) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void setIOFunctionList(const AudioIOFunction *ioFunctionList, UInt32 numFunctions) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    virtual const IOAudioStreamFormat *getFormat() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    static IOReturn setFormatAction(OSObject *owner, void *arg1, void *arg2, void *arg3, void *arg4) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	static IOReturn _setFormatAction(OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;	// <rdar://8568040,8691669>
    virtual IOReturn setFormat(const IOAudioStreamFormat *streamFormat, bool callDriver = true) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn setFormat(OSDictionary *formatDict) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn setFormat(const IOAudioStreamFormat *streamFormat, OSDictionary *formatDict, bool callDriver = true) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn hardwareFormatChanged(const IOAudioStreamFormat *streamFormat) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void addAvailableFormat(const IOAudioStreamFormat *streamFormat, const IOAudioSampleRate *minRate, const IOAudioSampleRate *maxRate, const AudioIOFunction *ioFunctionList = NULL, UInt32 numFunctions = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void addAvailableFormat(const IOAudioStreamFormat *streamFormat, const IOAudioSampleRate *minRate, const IOAudioSampleRate *maxRate, AudioIOFunction ioFunction) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void clearAvailableFormats() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual bool validateFormat(IOAudioStreamFormat *streamFormat, IOAudioStreamFormatDesc *formatDesc) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual UInt32 getStartingChannelID() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual UInt32 getMaxNumChannels() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void setStreamAvailable(bool available) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual bool getStreamAvailable() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn addDefaultAudioControl(IOAudioControl *defaultAudioControl) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void removeDefaultAudioControls() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

protected:
    virtual void lockStreamForIO() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void unlockStreamForIO() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void updateNumClients() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn addClient(IOAudioClientBuffer *clientBuffer) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void removeClient(IOAudioClientBuffer *clientBuffer) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual UInt32 getNumClients() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual IOReturn processOutputSamples(IOAudioClientBuffer *clientBuffer, UInt32 firstSampleFrame, UInt32 loopCount, bool samplesAvailable) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual IOReturn readInputSamples(IOAudioClientBuffer *clientBuffer, UInt32 firstSampleFrame) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void resetClipInfo() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void clipIfNecessary() AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    virtual void clipOutputSamples(UInt32 startingSampleFrame, UInt32 numSampleFrames) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
    
    virtual void setStartingChannelNumber(UInt32 channelNumber) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

private:
    virtual void setDirection(IOAudioStreamDirection dir) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
	
	void safeLogError(int error , long unsigned int arg1 , long unsigned int arg2 , long unsigned int arg3 , long unsigned int arg4 , void* arg5, void* arg6) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

};

#endif /* _IOKIT_IOAUDIOSTREAM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  IOAudioTimeIntervalFilter.h                                                                         0100644 0001750 0001750 00000023300 12567452612 040260  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOAUDIOTIMEINTERVALFILTER_H
#define _IOAUDIOTIMEINTERVALFILTER_H

#include "BigNum128.h"

/*!
 @class IOAudioTimeIntervalFilter
 @abstract An abstract class that provides a filtered timeline based on snapshots from jittery time captures
 */
class IOAudioTimeIntervalFilter : public OSObject
{
	OSDeclareAbstractStructors(IOAudioTimeIntervalFilter)

public:
	/*!
	 @function reInitialiseFilter
	 @abstract Restart a new timeline sequence, with a new expected interval spacing
	 @param expectedInterval Expected interval of time captures. Pass zero to use the results from previous runs.
	 @param multiIntervalCount Count of multiple intervals to return from getMultiIntervalTime.
	 */
	virtual IOReturn reInitialiseFilter(uint32_t expectedInterval = 0, uint32_t multiIntervalCount = 1 );

    /*!
     * @function free
     * @abstract Frees all of the resources allocated by the IOAudioTimeIntervalFilter.
     * @discussion Do not call this directly.  This is called automatically by the system when the instance's
     *  refcount goes to 0.  To decrement the refcount, call release() on the object.
     */
    virtual void free();



	/*!
	 @function newTimePosition
	 @abstract Pass in the raw measured time position
	 @param rawSnapshot The raw time position. These should be approximately occurring every ExpectedInterval
	 @result A filtered time position
	 */

	virtual AbsoluteTime newTimePosition(AbsoluteTime rawSnapshot);

	/*!
	 @function getMultiIntervalTime
	 @abstract Return the time between the last MultiIntervalCount intervals of the filtered timeline
	 @result Return the time between the last MultiIntervalCount intervals of the filtered timeline
	 */
	virtual uint64_t getMultiIntervalTime(void);

	
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 0 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 1 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 2 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 3 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 4 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 5 );	
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 6 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 7 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 8 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 9 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 10 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 11 );	
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 12 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 13 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 14 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilter, 15 );

protected:
	/* <rdar://12136103> */
    struct ExpansionData
	{
	};
    
    ExpansionData   *reserved;
	
	/*!
	 @function initFilter
	 @abstract Construct a new instance of the TimeFilter class
	 @param ExpectedInterval Expected interval of time captures
	 @param MultiIntervalCount Optionally calculate the count between ExpectedInterval
	 */
	virtual bool initFilter(uint32_t expectedInterval, uint32_t multiIntervalCount = 1);

	/*!
	 @function calculateNewTimePosition
	 @abstract abstract method to calculate the new time position based on the raw snapshot
	 @param rawSnapshot Raw filter value
	 @result filtered time value
	 */
	virtual uint64_t calculateNewTimePosition(uint64_t rawSnapshot) = 0;

	inline int decCircularBufferPosition(int n, int dec = 1)	{ return (n + mMultiIntervalCount - dec) % mMultiIntervalCount;  }
	inline int incCircularBufferPosition(int n, int inc = 1)	{ return (n + mMultiIntervalCount + inc) % mMultiIntervalCount;  }

	uint32_t	mExpectedInterval;
	uint32_t	mMultiIntervalCount;
	
	uint64_t*	mIntervalTimeHistory;
	
    /*!
     * @var mIntervalTimeHistoryPointer 
     *  Points to the next time interval to be updated
     */
	int			mIntervalTimeHistoryPointer;

    /*!
     * @var mFilterCount 
     *  How many times the filter has been called since re-init
     */
	uint64_t	mFilterCount;
	
    IOLock*		timeIntervalLock;
};



/*!
 @class IOAudioTimeIntervalFilterIIR
 @abstract A concrete IOAudioTimeIntervalFilter class that provides an IIR-based filtered timeline based on snapshots from jittery time captures
 */

class IOAudioTimeIntervalFilterIIR : public IOAudioTimeIntervalFilter
{
    OSDeclareDefaultStructors(IOAudioTimeIntervalFilterIIR)

public:
	/*!
	 @function initFilter
	 @abstract Construct a new instance of the IIR TimeFilter class
	 @param ExpectedInterval Expected interval of time captures
	 @param MultiIntervalCount Optionally calculate the count between ExpectedInterval
	 @param filterCoef IIR filter coefficient. Increase this number for more aggressive smoothing
	 */
	virtual bool initFilter(uint32_t expectedInterval, uint32_t multiIntervalCount = 1, uint16_t filterCoef = 4);

	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 0 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 1 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 2 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 3 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 4 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 5 );	
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 6 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 7 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 8 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 9 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 10 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 11 );	
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 12 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 13 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 14 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterIIR, 15 );

protected:
	virtual void IIR(U128* filterVal, U128 input, int shiftAmount);
	virtual uint64_t calculateNewTimePosition(uint64_t rawSnapshot);
	
	U128		mFilteredSnapshot;
	U128		mFilteredOffset;
	uint16_t	mIIRCoef;
};



/*!
 @class IOAudioTimeIntervalFilterFIR
 @abstract A concrete IOAudioTimeIntervalFilter class that provides an FIR-based filtered timeline based on snapshots from jittery time captures
 */

class IOAudioTimeIntervalFilterFIR : public IOAudioTimeIntervalFilter
{
    OSDeclareDefaultStructors(IOAudioTimeIntervalFilterFIR)
	
public:
	/*!
	 @function initFilter
	 @abstract Construct a new instance of the IIR TimeFilter class
	 @param ExpectedInterval Expected interval of time captures
	 @param MultiIntervalCount Optionally calculate the count between ExpectedInterval
	 */
	virtual bool initFilter(uint32_t expectedInterval, uint32_t multiIntervalCount = 1);

    /*!
     * @function free
     * @abstract Frees all of the resources allocated by the IOAudioTimeIntervalFilter.
     * @discussion Do not call this directly.  This is called automatically by the system when the instance's
     *  refcount goes to 0.  To decrement the refcount, call release() on the object.
     */
    virtual void free();
	
	IOReturn reInitialiseFilter(uint32_t expectedInterval = 0, uint32_t multiIntervalCount = 1 );
	
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 0 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 1 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 2 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 3 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 4 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 5 );	
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 6 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 7 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 8 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 9 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 10 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 11 );	
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 12 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 13 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 14 );
	OSMetaClassDeclareReservedUnused (IOAudioTimeIntervalFilterFIR, 15 );
protected:

	virtual uint64_t calculateNewTimePosition(uint64_t rawSnapshot);
	virtual IOReturn setNewFilter(uint32_t numCoeffs, const uint64_t* filterCoefficients, uint32_t scale);

	U128 FIR(uint64_t *history, uint64_t input);

	uint64_t*	mCoeffs;
	uint64_t*	mDataOffsetHistory;
	uint64_t*	mDataHistory;
	uint32_t	mNumCoeffs;
	uint32_t	mFilterScale;
	uint32_t	mFilterWritePointer;
};

#endif		// _IOAUDIOTIMEINTERVALFILTER_H

                                                                                                                                                                                                                                                                                                                                IOAudioToggleControl.h                                                                              0100644 0001750 0001750 00000013312 12567452612 037273  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*   
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *   
 * @APPLE_LICENSE_HEADER_START@
 *   
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *  
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *  
 * @APPLE_LICENSE_HEADER_END@
 */  

#ifndef _IOKIT_IOAUDIOTOGGLECONTROL_H
#define _IOKIT_IOAUDIOTOGGLECONTROL_H

#include <AvailabilityMacros.h>

#ifndef IOAUDIOFAMILY_SELF_BUILD
#include <IOKit/audio/IOAudioControl.h>
#else
#include "IOAudioControl.h"
#endif

/*!
 * @class IOAudioToggleControl
 */

class IOAudioToggleControl : public IOAudioControl
{
    OSDeclareDefaultStructors(IOAudioToggleControl)

protected:
    struct ExpansionData { };
    
    ExpansionData *reserved;

// New code added here
public:
    /*!
     * @function createPassThruMuteControl
     * @abstract Allocates a new pass through mute control with the given attributes
     * @param initialValue The initial value of the control
     * @param channelID The ID of the channel(s) that the control acts on.  Common IDs are located in IOAudioTypes.h.
     * @param channelName An optional name for the channel.  Common names are located in IOAudioPort.h.
     * @param cntrlID An optional ID for the control that can be used to uniquely identify controls
     * @result Returns a newly allocated and initialized mute IOAudioControl
     */
	static IOAudioToggleControl *createPassThruMuteControl (bool initialValue,
																UInt32 channelID,
																const char *channelName,
																UInt32 cntrlID) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

private:
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 0);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 1);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 2);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 3);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 4);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 5);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 6);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 7);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 8);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 9);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 10);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 11);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 12);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 13);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 14);
    OSMetaClassDeclareReservedUnused(IOAudioToggleControl, 15);

public:
    /*!
     * @function create
     * @abstract Allocates a new mute control with the given attributes
     * @param initialValue The initial value of the control
     * @param channelID The ID of the channel(s) that the control acts on.  Common IDs are located in IOAudioTypes.h.
     * @param channelName An optional name for the channel.  Common names are located in IOAudioPort.h.
     * @param cntrlID An optional ID for the control that can be used to uniquely identify controls
     * @result Returns a newly allocated and initialized mute IOAudioControl
     */
    static IOAudioToggleControl *create(bool initialValue,
                                        UInt32 channelID,
                                        const char *channelName = 0,
                                        UInt32 cntrlID = 0,
                                        UInt32 subType = 0,
                                        UInt32 usage = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;
                                      
    static IOAudioToggleControl *createMuteControl(bool initialValue,
                                                    UInt32 channelID,
                                                    const char *channelName = 0,
                                                    UInt32 cntrlID = 0,
                                                    UInt32 usage = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

    /*!
     * @function init
     * @abstract Initializes a newly allocated IOAudioToggleControl with the given attributes
     * @param initialValue The initial value of the control
     * @param channelID The ID of the channel(s) that the control acts on.  Common IDs are located in IOAudioTypes.h.
     * @param channelName An optional name for the channel.  Common names are located in IOAudioPort.h.
     * @param cntrlID An optional ID for the control that can be used to uniquely identify controls
     * @result Returns truen on success
     */
    virtual bool init(bool initialValue,
                      UInt32 channelID, 
                      const char *channelName = 0,
                      UInt32 cntrlID = 0,
                      UInt32 subType = 0,
                      UInt32 usage = 0,
                      OSDictionary *properties = 0) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10;

};

#endif /* _IOKIT_IOAUDIOTOGGLECONTROL_H */
                                                                                                                                                                                                                                                                                                                      IOAudioTypes.h                                                                                      0100644 0001750 0001750 00000061632 12567452612 035625  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/audio                                                          /*
 * Copyright (c) 1998-2013 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOAUDIOTYPES_H
#define _IOKIT_IOAUDIOTYPES_H

#include <libkern/OSTypes.h>
#include <mach/message.h>


/*!
 * @enum IOAudioEngineMemory
 * @abstract Used to identify the type of memory requested by a client process to be mapped into its process space
 * @discussion This is the parameter to the type field of IOMapMemory when called on an IOAudioEngine.  This is
 *  only intended for use by the Audio Device API library.
 * @constant kIOAudioSampleBuffer This requests the IOAudioEngine's sample buffer
 * @constant kIOAudioStatusBuffer This requests the IOAudioEngine's status buffer.  It's type is IOAudioEngineStatus.
 * @constant kIOAudioMixBuffer This requests the IOAudioEngine's mix buffer
*/
typedef enum _IOAudioEngineMemory {
    kIOAudioStatusBuffer 			= 0,
    kIOAudioSampleBuffer			= 1,
    kIOAudioMixBuffer				= 2,
	kIOAudioBytesInInputBuffer		= 3,
	kIOAudioBytesInOutputBuffer		= 4
} IOAudioEngineMemory;

/*!
 * @enum IOAudioEngineCalls
 * @abstract The set of constants passed to IOAudioEngineUserClient::getExternalMethodForIndex() when making calls
 *  from the IOAudioFamily user client code.
 */
typedef enum _IOAudioEngineCalls {
    kIOAudioEngineCallRegisterClientBuffer			= 0,
    kIOAudioEngineCallUnregisterClientBuffer		= 1,
    kIOAudioEngineCallGetConnectionID				= 2,
    kIOAudioEngineCallStart							= 3,
    kIOAudioEngineCallStop							= 4,
	kIOAudioEngineCallGetNearestStartTime			= 5
} IOAudioEngineCalls;

/*! @defined kIOAudioEngineNumCalls The number of elements in the IOAudioEngineCalls enum. */
#define kIOAudioEngineNumCalls		6

typedef enum _IOAudioEngineTraps {
    kIOAudioEngineTrapPerformClientIO				= 0
} IOAudioEngineTraps;

typedef enum _IOAudioEngineNotifications {
    kIOAudioEngineAllNotifications 					= 0,
    kIOAudioEngineStreamFormatChangeNotification	= 1,
    kIOAudioEngineChangeNotification 				= 2,
    kIOAudioEngineStartedNotification 				= 3,
    kIOAudioEngineStoppedNotification 				= 4,
    kIOAudioEnginePausedNotification				= 5,
    kIOAudioEngineResumedNotification				= 6
} IOAudioEngineNotifications;

/*!
 * @enum IOAudioEngineState
 * @abstract Represents the state of an IOAudioEngine
 * @constant kIOAudioEngineRunning The IOAudioEngine is currently running - it is transferring data to or 
 *           from the device.
 * @constant kIOAudioEngineStopped The IOAudioEngine is currently stopped - no activity is occurring.
 */

typedef enum _IOAudioEngineState {
    kIOAudioEngineStopped							= 0,
    kIOAudioEngineRunning							= 1,
    kIOAudioEnginePaused							= 2,
    kIOAudioEngineResumed							= 3
} IOAudioEngineState;


/*!
 * @typedef IOAudioEngineStatus
 * @abstract Shared-memory structure giving audio engine status
 * @discussion
 * @field fVersion Indicates version of this structure
 * @field fCurrentLoopCount Number of times around the ring buffer since the audio engine started
 * @field fLastLoopTime Timestamp of the last time the ring buffer wrapped
 * @field fEraseHeadSampleFrame Location of the erase head in sample frames - erased up to but not
 *        including the given sample frame
 */

typedef struct _IOAudioEngineStatus {
    UInt32					fVersion;
    volatile UInt32			fCurrentLoopCount;
    volatile AbsoluteTime                    fLastLoopTime;
    volatile UInt32			fEraseHeadSampleFrame;
} IOAudioEngineStatus;

#define kIOAudioEngineCurrentStatusStructVersion		2

typedef struct _IOAudioStreamFormat {
    UInt32	fNumChannels;
    UInt32	fSampleFormat;
    UInt32	fNumericRepresentation;
    UInt8	fBitDepth;
    UInt8	fBitWidth;
    UInt8	fAlignment;
    UInt8	fByteOrder;
    UInt8	fIsMixable;
    UInt32	fDriverTag;
} IOAudioStreamFormat;

#define kFormatExtensionInvalidVersion					0
#define kFormatExtensionCurrentVersion					1

typedef struct _IOAudioStreamFormatExtension {
    UInt32	fVersion;
    UInt32	fFlags;
    UInt32	fFramesPerPacket;
    UInt32	fBytesPerPacket;
} IOAudioStreamFormatExtension;

typedef struct _IOAudioBufferDataDescriptor {
	UInt32	fActualDataByteSize;
	UInt32	fActualNumSampleFrames;
	UInt32	fTotalDataByteSize;
	UInt32	fNominalDataByteSize;
	UInt8	fData[1];
} IOAudioBufferDataDescriptor;

#define kStreamDataDescriptorInvalidVersion				0
#define kStreamDataDescriptorCurrentVersion				1

typedef struct _IOAudioStreamDataDescriptor {
    UInt32	fVersion;
    UInt32	fNumberOfStreams;
    UInt32	fStreamLength[1];			// Array with fNumberOfStreams number of entries
} IOAudioStreamDataDescriptor;

typedef struct _IOAudioSampleIntervalDescriptor {
	UInt32	sampleIntervalHi;
	UInt32	sampleIntervalLo;
} IOAudioSampleIntervalDescriptor;

/*!
    @struct         SMPTETime
    @abstract       A structure for holding a SMPTE time.
    @field          fSubframes
                        The number of subframes in the full message.
    @field          fSubframeDivisor
                        The number of subframes per frame (typically 80).
    @field          fCounter
                        The total number of messages received.
    @field          fType
                        The kind of SMPTE time using the SMPTE time type constants.
    @field          fFlags
                        A set of flags that indicate the SMPTE state.
    @field          fHours
                        The number of hourse in the full message.
    @field          fMinutes
                        The number of minutes in the full message.
    @field          fSeconds
                        The number of seconds in the full message.
    @field          fFrames
                        The number of frames in the full message.
*/
typedef struct _IOAudioSMPTETime
{
    SInt16  fSubframes;
    SInt16  fSubframeDivisor;
    UInt32  fCounter;
    UInt32  fType;
    UInt32  fFlags;
    SInt16  fHours;
    SInt16  fMinutes;
    SInt16  fSeconds;
    SInt16  fFrames;

} IOAudioSMPTETime;

//	constants describing SMPTE types (taken from the MTC spec), <rdar://11955717>
enum
{
	kIOAudioSMPTETimeType24			= 0,
	kIOAudioSMPTETimeType25			= 1,
	kIOAudioSMPTETimeType30Drop		= 2,
	kIOAudioSMPTETimeType30			= 3,
	kIOAudioSMPTETimeType2997		= 4,
	kIOAudioSMPTETimeType2997Drop	= 5,
    kIOAudioSMPTETimeType60         = 6,
    kIOAudioSMPTETimeType5994       = 7,
    kIOAudioSMPTETimeType60Drop     = 8,
    kIOAudioSMPTETimeType5994Drop   = 9,
    kIOAudioSMPTETimeType50         = 10,
    kIOAudioSMPTETimeType2398       = 11
};

//	flags describing a SMPTE time stamp
enum
{
	kIOAudioSMPTETimeValid		= (1L << 0),	//	the full time is valid
	kIOAudioSMPTETimeRunning	= (1L << 1)		//	time is running
};

//	A struct for encapsulating the parts of a time stamp. The flags
//	say which fields are valid.
typedef struct _IOAudioTimeStamp
{
	UInt64				fSampleTime;	//	the absolute sample time, was a Float64
	UInt64				fHostTime;		//	the host's root timebase's time
	UInt64				fRateScalar;	//	the system rate scalar, was a Float64
	UInt64				fWordClockTime;	//	the word clock time
	IOAudioSMPTETime	fSMPTETime;		//	the SMPTE time
	UInt32				fFlags;			//	the flags indicate which fields are valid
	UInt32				fReserved;		//	reserved, pads the structure out to force 8 byte alignment
} IOAudioTimeStamp;

//	flags for the AudioTimeStamp sturcture
enum
{
	kIOAudioTimeStampSampleTimeValid	= (1L << 0),
	kIOAudioTimeStampHostTimeValid		= (1L << 1),
	kIOAudioTimeStampRateScalarValid	= (1L << 2),
	kIOAudioTimeStampWordClockTimeValid	= (1L << 3),
	kIOAudioTimeStampSMPTETimeValid		= (1L << 4)
};

//	Some commonly used combinations of timestamp flags
enum
{
	kIOAudioTimeStampSampleHostTimeValid	= (kIOAudioTimeStampSampleTimeValid | kIOAudioTimeStampHostTimeValid)
};

/*!
* @enum IOAudioStreamDirection
 * @abstract Represents the direction of an IOAudioStream
 * @constant kIOAudioStreamDirectionOutput Output buffer
 * @constant kIOAudioStreamDirectionInput Input buffer
 */

typedef enum _IOAudioStreamDirection {
    kIOAudioStreamDirectionOutput	= 0,
    kIOAudioStreamDirectionInput	= 1
} IOAudioStreamDirection;

enum {
	kIOAudioDeviceCanBeDefaultNothing	= 0,
	kIOAudioDeviceCanBeDefaultInput		= (1L << 0),
	kIOAudioDeviceCanBeDefaultOutput	= (1L << 1),
	kIOAudioDeviceCanBeSystemOutput		= (1L << 2)
};

/*!
 * @defined kIOAudioEngineDefaultMixBufferSampleSize
 */

#define kIOAudioEngineDefaultMixBufferSampleSize		sizeof(float)

/* The following are for use only by the IOKit.framework audio family code */

/*!
 * @enum IOAudioControlCalls
 * @abstract The set of constants passed to IOAudioControlUserClient::getExternalMethodForIndex() when making calls
 *  from the IOAudioFamily user client code.
 * @constant kIOAudioControlCallSetValue Used to set the value of an IOAudioControl.
 * @constant kIOAudioControlCallGetValue Used to get the value of an IOAudioControl.
 */
typedef enum _IOAudioControlCalls {
    kIOAudioControlCallSetValue = 0,
    kIOAudioControlCallGetValue = 1
} IOAudioControlCalls;

/*! @defined kIOAudioControlNumCalls The number of elements in the IOAudioControlCalls enum. */
#define kIOAudioControlNumCalls 	2

/*!
 * @enum IOAudioControlNotifications
 * @abstract The set of constants passed in the type field of IOAudioControlUserClient::registerNotificaitonPort().
 * @constant kIOAudioControlValueChangeNotification Used to request value change notifications.
 * @constant kIOAudioControlRangeChangeNotification Used to request range change notifications.
 */
typedef enum _IOAudioControlNotifications {
    kIOAudioControlValueChangeNotification = 0,
	kIOAudioControlRangeChangeNotification = 1
} IOAudioControlNotifications;

/*!
 * @struct IOAudioNotificationMessage
 * @abstract Used in the mach message for IOAudio notifications.
 * @field messageHeader Standard mach message header
 * @field ref The param passed to registerNotificationPort() in refCon.
 */
typedef struct _IOAudioNotificationMessage {
    mach_msg_header_t	messageHeader;
    UInt32		type;
    UInt32		ref;
    void *		sender;
} IOAudioNotificationMessage;

typedef struct _IOAudioSampleRate {
    UInt32	whole;
    UInt32	fraction;
} IOAudioSampleRate;

#define kNoIdleAudioPowerDown		0xffffffffffffffffULL

enum {
    kIOAudioPortTypeOutput		= 'outp',
    kIOAudioPortTypeInput		= 'inpt',
    kIOAudioPortTypeMixer		= 'mixr',
    kIOAudioPortTypePassThru	= 'pass',
    kIOAudioPortTypeProcessing	= 'proc'
};

enum {
    kIOAudioOutputPortSubTypeInternalSpeaker	= 'ispk',
    kIOAudioOutputPortSubTypeExternalSpeaker	= 'espk',
    kIOAudioOutputPortSubTypeHeadphones			= 'hdpn',
    kIOAudioOutputPortSubTypeLine				= 'line',
    kIOAudioOutputPortSubTypeSPDIF				= 'spdf',
    
    kIOAudioInputPortSubTypeInternalMicrophone	= 'imic',
    kIOAudioInputPortSubTypeExternalMicrophone	= 'emic',
    kIOAudioInputPortSubTypeCD					= 'cd  ',
    kIOAudioInputPortSubTypeLine				= 'line',
    kIOAudioInputPortSubTypeSPDIF				= 'spdf'
};

enum {
    kIOAudioControlTypeLevel			= 'levl',
    kIOAudioControlTypeToggle			= 'togl',
	kIOAudioControlTypeJack				= 'jack',
    kIOAudioControlTypeSelector			= 'slct'
};

//	<rdar://8325563>	Added kIOAudioToggleControlSubTypePhantomPower, kIOAudioToggleControlSubTypePhaseInvert & 
//	kIOAudioSelectorControlSubTypeChannelHighPassFilter
enum {
    kIOAudioLevelControlSubTypeVolume						= 'vlme',
	kIOAudioLevelControlSubTypeLFEVolume					= 'subv',
	kIOAudioLevelControlSubTypePRAMVolume					= 'pram',
    kIOAudioToggleControlSubTypeMute						= 'mute',
    kIOAudioToggleControlSubTypeSolo						= 'solo',
	kIOAudioToggleControlSubTypeLFEMute						= 'subm',
	kIOAudioToggleControlSubTypeiSubAttach					= 'atch',
	kIOAudioToggleControlSubTypePhantomPower				= 'phan',
	kIOAudioToggleControlSubTypePhaseInvert					= 'phsi',
    kIOAudioSelectorControlSubTypeOutput					= 'outp',
    kIOAudioSelectorControlSubTypeInput						= 'inpt',
    kIOAudioSelectorControlSubTypeClockSource				= 'clck',
    kIOAudioSelectorControlSubTypeDestination				= 'dest',
	kIOAudioSelectorControlSubTypeChannelNominalLineLevel	= 'nlev',
	kIOAudioSelectorControlSubTypeChannelLevelPlus4dBu		= '4dbu',
	kIOAudioSelectorControlSubTypeChannelLevelMinus10dBV	= '10db',
	kIOAudioSelectorControlSubTypeChannelLevelMinus20dBV	= '20db',
	kIOAudioSelectorControlSubTypeChannelLevelMicLevel		= 'micl',
	kIOAudioSelectorControlSubTypeChannelLevelInstrumentLevel		= 'istl',
	kIOAudioSelectorControlSubTypeChannelHighPassFilter		= 'hipf'
};

enum {
    kIOAudioControlUsageOutput				= 'outp',
    kIOAudioControlUsageInput				= 'inpt',
    kIOAudioControlUsagePassThru			= 'pass',
    kIOAudioControlUsageCoreAudioProperty	= 'prop'
};

enum {
    kIOAudioControlChannelNumberInactive				= -1,
    kIOAudioControlChannelIDAll							= 0,
    kIOAudioControlChannelIDDefaultLeft					= 1,
    kIOAudioControlChannelIDDefaultRight				= 2,
    kIOAudioControlChannelIDDefaultCenter				= 3,
    kIOAudioControlChannelIDDefaultLeftRear				= 4,
    kIOAudioControlChannelIDDefaultRightRear			= 5,
    kIOAudioControlChannelIDDefaultSub					= 6,
    kIOAudioControlChannelIDDefaultFrontLeftCenter		= 7,
    kIOAudioControlChannelIDDefaultFrontRightCenter		= 8,
    kIOAudioControlChannelIDDefaultRearCenter			= 9,
    kIOAudioControlChannelIDDefaultSurroundLeft			= 10,
    kIOAudioControlChannelIDDefaultSurroundRight		= 11
};

enum {
    kIOAudioSelectorControlSelectionValueNone				= 'none',
    
    // Output-specific selection IDs 
    kIOAudioSelectorControlSelectionValueInternalSpeaker	= 'ispk',
    kIOAudioSelectorControlSelectionValueExternalSpeaker	= 'espk',
    kIOAudioSelectorControlSelectionValueHeadphones			= 'hdpn',
    
    // Input-specific selection IDs
    kIOAudioSelectorControlSelectionValueInternalMicrophone	= 'imic',
    kIOAudioSelectorControlSelectionValueExternalMicrophone	= 'emic',
    kIOAudioSelectorControlSelectionValueCD					= 'cd  ',
    
    // Common selection IDs
    kIOAudioSelectorControlSelectionValueLine				= 'line',
    kIOAudioSelectorControlSelectionValueSPDIF				= 'spdf'
};

enum {
    kIOAudioStreamSampleFormatLinearPCM		= 'lpcm',
    kIOAudioStreamSampleFormatIEEEFloat		= 'ieee',
    kIOAudioStreamSampleFormatALaw			= 'alaw',
    kIOAudioStreamSampleFormatMuLaw			= 'ulaw',
    kIOAudioStreamSampleFormatMPEG			= 'mpeg',
    kIOAudioStreamSampleFormatAC3			= 'ac-3',
    kIOAudioStreamSampleFormat1937AC3		= 'cac3',
    kIOAudioStreamSampleFormat1937MPEG1		= 'mpg1',
    kIOAudioStreamSampleFormat1937MPEG2		= 'mpg2',
	kIOAudioStreamSampleFormatTimeCode		= 'time'		//	a stream of IOAudioTimeStamp structures that capture any incoming time code information
};

enum {
    kIOAudioStreamNumericRepresentationSignedInt	= 'sint',
    kIOAudioStreamNumericRepresentationUnsignedInt	= 'uint',
	kIOAudioStreamNumericRepresentationIEEE754Float = 'flot'
};

enum {
	kIOAudioClockSelectorTypeInternal			= 'int ',
	kIOAudioClockSelectorTypeExternal			= 'ext ',
	kIOAudioClockSelectorTypeAESEBU				= 'asbu',
	kIOAudioClockSelectorTypeTOSLink			= 'tosl',
	kIOAudioClockSelectorTypeSPDIF				= 'spdf',
	kIOAudioClockSelectorTypeADATOptical		= 'adto',
	kIOAudioClockSelectorTypeADAT9Pin			= 'adt9',
	kIOAudioClockSelectorTypeSMPTE				= 'smpt',
	kIOAudioClockSelectorTypeVideo				= 'vdeo',
	kIOAudioClockSelectorTypeControl			= 'cnrl',
	kIOAudioClockSelectorTypeOther				= 'othr',
};

enum {
    kIOAudioStreamAlignmentLowByte					= 0,
    kIOAudioStreamAlignmentHighByte					= 1
};

enum {
    kIOAudioStreamByteOrderBigEndian				= 0,
    kIOAudioStreamByteOrderLittleEndian				= 1
};

enum {
    kIOAudioLevelControlNegativeInfinity			= 0xffffffff
};

enum {
    kIOAudioNewClockDomain							= 0xffffffff
};

// Device connection types
#ifndef __OPEN_SOURCE__
//	<rdar://7130813>	Added kIOAudioDeviceTransportTypeDisplayPort
#endif
enum {
	kIOAudioDeviceTransportTypeBuiltIn				= 'bltn',
	kIOAudioDeviceTransportTypePCI					= 'pci ',
	kIOAudioDeviceTransportTypeUSB					= 'usb ',
	kIOAudioDeviceTransportTypeFireWire				= '1394',
	kIOAudioDeviceTransportTypeNetwork				= 'ntwk',
	kIOAudioDeviceTransportTypeWireless				= 'wrls',
	kIOAudioDeviceTransportTypeOther				= 'othr',
	kIOAudioDeviceTransportTypeBluetooth			= 'blue',
	kIOAudioDeviceTransportTypeVirtual				= 'virt',
	kIOAudioDeviceTransportTypeDisplayPort			= 'dprt',
	kIOAudioDeviceTransportTypeHdmi					= 'hdmi',
    kIOAudioDeviceTransportTypeAVB            		= 'eavb',			//<rdar://10874672>
    kIOAudioDeviceTransportTypeThunderbolt    		= 'thun'			//<rdar://10874672>
};

// types that go nowhere
enum {
	OUTPUT_NULL										= 0x0100,
	INPUT_NULL										= 0x0101
};

// Input terminal types
enum {
	INPUT_UNDEFINED									= 0x0200,
	INPUT_MICROPHONE								= 0x0201,
	INPUT_DESKTOP_MICROPHONE						= 0x0202,
	INPUT_PERSONAL_MICROPHONE						= 0x0203,
	INPUT_OMNIDIRECTIONAL_MICROPHONE				= 0x0204,
	INPUT_MICROPHONE_ARRAY							= 0x0205,
	INPUT_PROCESSING_MICROPHONE_ARRAY				= 0x0206,
	INPUT_MODEM_AUDIO								= 0x207
};

// Output terminal types
enum {
	OUTPUT_UNDEFINED								= 0x0300,
	OUTPUT_SPEAKER									= 0x0301,
	OUTPUT_HEADPHONES								= 0x0302,
	OUTPUT_HEAD_MOUNTED_DISPLAY_AUDIO				= 0x0303,
	OUTPUT_DESKTOP_SPEAKER							= 0x0304,
	OUTPUT_ROOM_SPEAKER								= 0x0305,
	OUTPUT_COMMUNICATION_SPEAKER					= 0x0306,
	OUTPUT_LOW_FREQUENCY_EFFECTS_SPEAKER			= 0x0307
};

// Bi-directional terminal types
enum {
	BIDIRECTIONAL_UNDEFINED							= 0x0400,
	BIDIRECTIONAL_HANDSET							= 0x0401,
	BIDIRECTIONAL_HEADSET							= 0x0402,
	BIDIRECTIONAL_SPEAKERPHONE_NO_ECHO_REDX			= 0x0403,
	BIDIRECTIONAL_ECHO_SUPPRESSING_SPEAKERPHONE		= 0x0404,
	BIDIRECTIONAL_ECHO_CANCELING_SPEAKERPHONE		= 0x0405
};

// Telephony terminal types
enum {
	TELEPHONY_UNDEFINED								= 0x0500,
	TELEPHONY_PHONE_LINE							= 0x0501,
	TELEPHONY_TELEPHONE								= 0x0502,
	TELEPHONY_DOWN_LINE_PHONE						= 0x0503
};

// External terminal types
enum {
	EXTERNAL_UNDEFINED								= 0x0600,
	EXTERNAL_ANALOG_CONNECTOR						= 0x0601,
	EXTERNAL_DIGITAL_AUDIO_INTERFACE				= 0x0602,
	EXTERNAL_LINE_CONNECTOR							= 0x0603,
	EXTERNAL_LEGACY_AUDIO_CONNECTOR					= 0x0604,
	EXTERNAL_SPDIF_INTERFACE						= 0x0605,
	EXTERNAL_1394_DA_STREAM							= 0x0606,
	EXTERNAL_1394_DV_STREAM_SOUNDTRACK				= 0x0607,
	EXTERNAL_ADAT									= 0x0608,
	EXTERNAL_TDIF									= 0x0609,
	EXTERNAL_MADI									= 0x060A
};

// Embedded terminal types
enum {
	EMBEDDED_UNDEFINED								= 0x0700,
	EMBEDDED_LEVEL_CALIBRATION_NOISE_SOURCE			= 0x0701,
	EMBEDDED_EQUALIZATION_NOISE						= 0x0702,
	EMBEDDED_CD_PLAYER								= 0x0703,
	EMBEDDED_DAT									= 0x0704,
	EMBEDDED_DCC									= 0x0705,
	EMBEDDED_MINIDISK								= 0x0706,
	EMBEDDED_ANALOG_TAPE							= 0x0707,
	EMBEDDED_PHONOGRAPH								= 0x0708,
	EMBEDDED_VCR_AUDIO								= 0x0709,
	EMBEDDED_VIDEO_DISC_AUDIO						= 0x070A,
	EMBEDDED_DVD_AUDIO								= 0x070B,
	EMBEDDED_TV_TUNER_AUDIO							= 0x070C,
	EMBEDDED_SATELLITE_RECEIVER_AUDIO				= 0x070D,
	EMBEDDED_CABLE_TUNER_AUDIO						= 0x070E,
	EMBEDDED_DSS_AUDIO								= 0x070F,
	EMBEDDED_RADIO_RECEIVER							= 0x0710,
	EMBEDDED_RADIO_TRANSMITTER						= 0x0711,
	EMBEDDED_MULTITRACK_RECORDER					= 0x0712,
	EMBEDDED_SYNTHESIZER							= 0x0713
};

// Processing terminal types
enum {
	PROCESSOR_UNDEFINED								= 0x0800,
	PROCESSOR_GENERAL								= 0x0801
};

//	Channel spatial position types

#ifndef __OPEN_SOURCE__
//	<rdar://6868206>	NOTE: the following are derived from CoreAudioTypes.h
#endif

#define	kIOAudioChannelLabel_Discrete_field_ba		16
enum {
    kIOAudioChannelLabel_Unknown                  = 0xFFFFFFFF,   // unknown or unspecified other use
    kIOAudioChannelLabel_Unused                   = 0,            // channel is present, but has no intended use or destination
    kIOAudioChannelLabel_UseCoordinates           = 100,          // channel is described by the mCoordinates fields.
	
    kIOAudioChannelLabel_Left                     = 1,
    kIOAudioChannelLabel_Right                    = 2,
    kIOAudioChannelLabel_Center                   = 3,
    kIOAudioChannelLabel_LFEScreen                = 4,
    kIOAudioChannelLabel_LeftSurround             = 5,            // WAVE: "Back Left"
    kIOAudioChannelLabel_RightSurround            = 6,            // WAVE: "Back Right"
    kIOAudioChannelLabel_LeftCenter               = 7,
    kIOAudioChannelLabel_RightCenter              = 8,
    kIOAudioChannelLabel_CenterSurround           = 9,            // WAVE: "Back Center" or plain "Rear Surround"
    kIOAudioChannelLabel_LeftSurroundDirect       = 10,           // WAVE: "Side Left"
    kIOAudioChannelLabel_RightSurroundDirect      = 11,           // WAVE: "Side Right"
    kIOAudioChannelLabel_TopCenterSurround        = 12,
    kIOAudioChannelLabel_VerticalHeightLeft       = 13,           // WAVE: "Top Front Left"
    kIOAudioChannelLabel_VerticalHeightCenter     = 14,           // WAVE: "Top Front Center"
    kIOAudioChannelLabel_VerticalHeightRight      = 15,           // WAVE: "Top Front Right"
	
    kIOAudioChannelLabel_TopBackLeft              = 16,
    kIOAudioChannelLabel_TopBackCenter            = 17,
    kIOAudioChannelLabel_TopBackRight             = 18,
	
    kIOAudioChannelLabel_RearSurroundLeft         = 33,
    kIOAudioChannelLabel_RearSurroundRight        = 34,
    kIOAudioChannelLabel_LeftWide                 = 35,
    kIOAudioChannelLabel_RightWide                = 36,
    kIOAudioChannelLabel_LFE2                     = 37,
    kIOAudioChannelLabel_LeftTotal                = 38,           // matrix encoded 4 channels
    kIOAudioChannelLabel_RightTotal               = 39,           // matrix encoded 4 channels
    kIOAudioChannelLabel_HearingImpaired          = 40,
    kIOAudioChannelLabel_Narration                = 41,
    kIOAudioChannelLabel_Mono                     = 42,
    kIOAudioChannelLabel_DialogCentricMix         = 43,
	
    kIOAudioChannelLabel_CenterSurroundDirect     = 44,           // back center, non diffuse
    
    kIOAudioChannelLabel_Haptic                   = 45,
	
    // first order ambisonic channels
    kIOAudioChannelLabel_Ambisonic_W              = 200,
    kIOAudioChannelLabel_Ambisonic_X              = 201,
    kIOAudioChannelLabel_Ambisonic_Y              = 202,
    kIOAudioChannelLabel_Ambisonic_Z              = 203,
	
    // Mid/Side Recording
    kIOAudioChannelLabel_MS_Mid                   = 204,
    kIOAudioChannelLabel_MS_Side                  = 205,
	
    // X-Y Recording
    kIOAudioChannelLabel_XY_X                     = 206,
    kIOAudioChannelLabel_XY_Y                     = 207,
	
    // other
    kIOAudioChannelLabel_HeadphonesLeft           = 301,
    kIOAudioChannelLabel_HeadphonesRight          = 302,
    kIOAudioChannelLabel_ClickTrack               = 304,
    kIOAudioChannelLabel_ForeignLanguage          = 305,
	
    // generic discrete channel
    kIOAudioChannelLabel_Discrete                 = 400,
	
    // numbered discrete channel
    kIOAudioChannelLabel_Discrete_0               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 0,
    kIOAudioChannelLabel_Discrete_1               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 1,
    kIOAudioChannelLabel_Discrete_2               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 2,
    kIOAudioChannelLabel_Discrete_3               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 3,
    kIOAudioChannelLabel_Discrete_4               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 4,
    kIOAudioChannelLabel_Discrete_5               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 5,
    kIOAudioChannelLabel_Discrete_6               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 6,
    kIOAudioChannelLabel_Discrete_7               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 7,
    kIOAudioChannelLabel_Discrete_8               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 8,
    kIOAudioChannelLabel_Discrete_9               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 9,
    kIOAudioChannelLabel_Discrete_10              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 10,
    kIOAudioChannelLabel_Discrete_11              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 11,
    kIOAudioChannelLabel_Discrete_12              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 12,
    kIOAudioChannelLabel_Discrete_13              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 13,
    kIOAudioChannelLabel_Discrete_14              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 14,
    kIOAudioChannelLabel_Discrete_15              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 15,
    kIOAudioChannelLabel_Discrete_65535           = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 65535
};



#endif /* _IOKIT_IOAUDIOTYPES_H */
                                                                                                      avc/                                                                                                0040755 0001750 0001750 00000000000 12612224741 032570  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOFireWireAVCCommand.h                                                                              0100644 0001750 0001750 00000006742 12567452043 036553  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/avc                                                            /*
 * Copyright (c) 1998-2001 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _IOKIT_IOFireWireAVCCommand_H
#define _IOKIT_IOFireWireAVCCommand_H
 
#include <IOKit/firewire/IOFWCommand.h>

/*! @class IOFireWireAVCCommand
*/
class IOFireWireAVCCommand : public IOFWCommand
{
    OSDeclareDefaultStructors(IOFireWireAVCCommand)
    
protected:
    IOFWCommand 		*fWriteCmd;
    IOMemoryDescriptor	*fMem;
    const UInt8 		*fCommand;
    
    UInt32 	fCmdLen;
    UInt8 	*fResponse;
    UInt32 	*fResponseLen;
    int		fCurRetries;
    int		fMaxRetries;
    
    UInt32	fWriteGen;
    UInt16	fWriteNodeID;
    bool	bypassRobustCommandResponseMatching;
	
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { 
		bool 	fStarted;
		bool 	fSyncWakeupSignaled;
	};

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *fIOFireWireAVCCommandExpansion;
    
    static void writeDone(void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd);
    
    virtual IOReturn	complete(IOReturn status);
    virtual IOReturn	execute();
    virtual void		free();
    
public:
    virtual bool init(IOFireWireNub *device, const UInt8 * command, UInt32 cmdLen,
                                                    UInt8 * response, UInt32 * responseLen);
    virtual IOReturn reinit(IOFireWireNub *device, const UInt8 * command, UInt32 cmdLen,
                                                    UInt8 * response, UInt32 * responseLen);
                                                    
    static IOFireWireAVCCommand *withNub(IOFireWireNub *device, const UInt8 * command, UInt32 cmdLen,
                                                    UInt8 * response, UInt32 * responseLen);
                                                    
    static IOFireWireAVCCommand *withNub(IOFireWireNub *device, UInt32 generation,
                const UInt8 * command, UInt32 cmdLen, UInt8 * response, UInt32 * responseLen);
                                                    
    virtual UInt32 handleResponse(UInt16 nodeID, UInt32 len, const void *buf);

    virtual IOReturn resetInterimTimeout();

	virtual UInt32 handleResponseWithSimpleMatching(UInt16 nodeID, UInt32 len, const void *buf);

    virtual IOReturn 	submit(bool queue = false);

private:
    OSMetaClassDeclareReservedUsed(IOFireWireAVCCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCCommand, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCCommand, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCCommand, 3);
};

#endif // _IOKIT_IOFireWireAVCCommand_H

                              IOFireWireAVCConsts.h                                                                               0100644 0001750 0001750 00000017157 12567452043 036450  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/avc                                                            /*
 * Copyright (c) 1998-2001 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _IOKIT_IOFIREWIREAVCCONSTS_H
#define _IOKIT_IOFIREWIREAVCCONSTS_H

// Fields of AVC frame
typedef enum {
    kAVCCommandResponse = 0,
    kAVCAddress = 1,
    kAVCOpcode = 2,
    kAVCOperand0 = 3,
    kAVCOperand1 = 4,
    kAVCOperand2 = 5,
    kAVCOperand3 = 6,
    kAVCOperand4 = 7,
    kAVCOperand5 = 8,
    kAVCOperand6 = 9,
    kAVCOperand7 = 10,
    kAVCOperand8 = 11
} IOAVCFrameFields;

// Command/Response values
typedef enum {
    kAVCControlCommand                      = 0x00,
    kAVCStatusInquiryCommand                = 0x01,
    kAVCSpecificInquiryCommand				= 0x02,
    kAVCNotifyCommand						= 0x03,
    kAVCGeneralInquiryCommand				= 0x04,
    kAVCNotImplementedStatus				= 0x08,
    kAVCAcceptedStatus						= 0x09,
    kAVCRejectedStatus						= 0x0a,
    kAVCInTransitionStatus					= 0x0b,
    kAVCImplementedStatus					= 0x0c,
    kAVCChangedStatus						= 0x0d,
    kAVCInterimStatus						= 0x0f
} IOAVCCommandResponse;

// Opcodes
typedef enum {

    // Unit commands
    kAVCPlugInfoOpcode						= 0x02,
    kAVCOutputPlugSignalFormatOpcode		= 0x18,
    kAVCInputPlugSignalFormatOpcode			= 0x19,
    kAVCUnitInfoOpcode						= 0x30,
    kAVCSubunitInfoOpcode					= 0x31,
    kAVCConnectionsOpcode					= 0x22,
    kAVCConnectOpcode						= 0x24,
    kAVCDisconnectOpcode					= 0x25,
    kAVCPowerOpcode							= 0xB2,
	kAVCSignalSourceOpcode					= 0x1A,
	
    // Vendor dependent commands
    kAVCVendorDependentOpcode				= 0x00,

    // Subunit commands
    kAVCOutputSignalModeOpcode              = 0x78,
    kAVCInputSignalModeOpcode               = 0x79, 
    kAVCSignalModeSD525_60                  = 0x00,
    kAVCSignalModeSDL525_60                 = 0x04,
    kAVCSignalModeHD1125_60                 = 0x08,
    kAVCSignalModeSD625_50                  = 0x80, 
    kAVCSignalModeSDL625_50                 = 0x84, 
    kAVCSignalModeHD1250_50                 = 0x88,
    kAVCSignalModeDVCPro525_60				= 0x78,
    kAVCSignalModeDVCPro625_50				= 0xf8,
    
    kAVCSignalModeDummyOperand              = 0xff,
    kAVCSignalModeMask_50					= 0x80,
    kAVCSignalModeMask_STYPE				= 0x7c,          
    kAVCSignalModeMask_SDL					= 0x04,          
    kAVCSignalModeMask_DVCPro25				= 0x78        

} IOAVCOpcodes;

// Unit/Subunit types
typedef enum {
    kAVCVideoMonitor						= 0x00,
    kAVCAudio								= 0x01,
    kAVCPrinter								= 0x02,
    kAVCDiskRecorder						= 0x03,
    kAVCTapeRecorder						= 0x04,
    kAVCTuner								= 0x05,
    kAVCVideoCamera							= 0x07,
    kAVCCameraStorage						= 0x0b,
    kAVCVendorUnique						= 0x1c,
    kAVCNumSubUnitTypes						= 0x20
} IOAVCUnitTypes;

#define kAVCAllOpcodes 0xFF
#define kAVCAllSubunitsAndUnit 0xEE
#define kAVCMaxNumPlugs 31
#define kAVCAnyAvailableIsochPlug 0x7F
#define kAVCAnyAvailableExternalPlug 0xFF
#define kAVCAnyAvailableSubunitPlug 0xFF
#define kAVCMultiplePlugs 0xFD
#define kAVCInvalidPlug 0xFE


#define IOAVCAddress(type, id) (((type) << 3) | (id))
#define kAVCUnitAddress 0xff
#define IOAVCType(address) ((address) >> 3)
#define IOAVCId(address) ((address) & 0x7)

// Macros for Plug Control Register field manipulation

// Master control registers
#define kIOFWPCRDataRate FWBitRange(0,1)
#define kIOFWPCRDataRatePhase FWBitRangePhase(0,1)
#define kIOFWPCRExtension FWBitRange(8,15)
#define kIOFWPCRExtensionPhase FWBitRangePhase(8,15)
#define kIOFWPCRNumPlugs FWBitRange(27,31)
#define kIOFWPCRNumPlugsPhase FWBitRangePhase(27,31)

// master output register
#define kIOFWPCRBroadcastBase FWBitRange(2,7)
#define kIOFWPCRBroadcastBasePhase FWBitRangePhase(2,7)

// plug registers
#define kIOFWPCROnline FWBitRange(0,0)
#define kIOFWPCROnlinePhase FWBitRangePhase(0,0)
#define kIOFWPCRBroadcast FWBitRange(1,1)
#define kIOFWPCRBroadcastPhase FWBitRangePhase(1,1)
#define kIOFWPCRP2PCount FWBitRange(2,7)
#define kIOFWPCRP2PCountPhase FWBitRangePhase(2,7)
#define kIOFWPCRChannel FWBitRange(10,15)
#define kIOFWPCRChannelPhase FWBitRangePhase(10,15)

// Extra fields for output plug registers
#define kIOFWPCROutputDataRate FWBitRange(16,17)
#define kIOFWPCROutputDataRatePhase FWBitRangePhase(16,17)
#define kIOFWPCROutputOverhead FWBitRange(18,21)
#define kIOFWPCROutputOverheadPhase FWBitRangePhase(18,21)
#define kIOFWPCROutputPayload FWBitRange(22,31)
#define kIOFWPCROutputPayloadPhase FWBitRangePhase(22,31)

// async plug numbers

enum
{
	kFWAVCAsyncPlug0 	= 0xa0,
	kFWAVCAsyncPlug1 	= 0xa1,
	kFWAVCAsyncPlug2 	= 0xa2,
	kFWAVCAsyncPlug3 	= 0xa3,
	kFWAVCAsyncPlug4 	= 0xa4,
	kFWAVCAsyncPlug5 	= 0xa5,
	kFWAVCAsyncPlug6 	= 0xa6,
	kFWAVCAsyncPlug7 	= 0xa7,
	kFWAVCAsyncPlug8 	= 0xa8,
	kFWAVCAsyncPlug9 	= 0xa9,
	kFWAVCAsyncPlug10 	= 0xa1,
	kFWAVCAsyncPlug11	= 0xab,
	kFWAVCAsyncPlug12 	= 0xac,
	kFWAVCAsyncPlug13	= 0xad,
	kFWAVCAsyncPlug14	= 0xae,
	kFWAVCAsyncPlug15 	= 0xaf,
	kFWAVCAsyncPlug16 	= 0xb0,
	kFWAVCAsyncPlug17 	= 0xb1,
	kFWAVCAsyncPlug18	= 0xb2,
	kFWAVCAsyncPlug19 	= 0xb3,
	kFWAVCAsyncPlug20 	= 0xb4,
	kFWAVCAsyncPlug21 	= 0xb5,
	kFWAVCAsyncPlug22 	= 0xb6,
	kFWAVCAsyncPlug23 	= 0xb7,
	kFWAVCAsyncPlug24 	= 0xb8,
	kFWAVCAsyncPlug25 	= 0xb9,
	kFWAVCAsyncPlug26 	= 0xba,
	kFWAVCAsyncPlug27 	= 0xbb,
	kFWAVCAsyncPlug28 	= 0xbc,
	kFWAVCAsyncPlug29 	= 0xbd,
	kFWAVCAsyncPlug30	= 0xbe,
	kFWAVCAsyncPlugAny	= 0xbf
};

enum
{
    kFWAVCStateBusSuspended 	= 0,
    kFWAVCStateBusResumed 		= 1,
    kFWAVCStatePlugReconnected 	= 2,
    kFWAVCStatePlugDisconnected = 3,
    kFWAVCStateDeviceRemoved	= 4
};

enum
{
    kFWAVCConsumerMode_MORE		= 1,
    kFWAVCConsumerMode_LAST		= 4,
    kFWAVCConsumerMode_LESS		= 5,
    kFWAVCConsumerMode_JUNK		= 6,
    kFWAVCConsumerMode_LOST		= 7
};

enum
{
    kFWAVCProducerMode_SEND		= 5,
    kFWAVCProducerMode_TOSS		= 7
};


typedef enum
{
	IOFWAVCPlugSubunitSourceType,
	IOFWAVCPlugSubunitDestType,
	IOFWAVCPlugIsochInputType,
	IOFWAVCPlugIsochOutputType,
	IOFWAVCPlugAsynchInputType,
	IOFWAVCPlugAsynchOutputType,
	IOFWAVCPlugExternalInputType,
	IOFWAVCPlugExternalOutputType
} IOFWAVCPlugTypes;

typedef enum
{
	kIOFWAVCSubunitPlugMsgConnected,
	kIOFWAVCSubunitPlugMsgDisconnected,
	kIOFWAVCSubunitPlugMsgConnectedPlugModified,
	kIOFWAVCSubunitPlugMsgSignalFormatModified
} IOFWAVCSubunitPlugMessages;

// Some plug signal formats
#define kAVCPlugSignalFormatNTSCDV 0x80000000
#define kAVCPlugSignalFormatPalDV 0x80800000 
#define kAVCPlugSignalFormatMPEGTS 0xA0000000

// Possible states of an AVCAsynchronousCommand
typedef enum
{
	kAVCAsyncCommandStatePendingRequest,
	kAVCAsyncCommandStateRequestSent,
	kAVCAsyncCommandStateRequestFailed,
	kAVCAsyncCommandStateWaitingForResponse,
	kAVCAsyncCommandStateReceivedInterimResponse,
	kAVCAsyncCommandStateReceivedFinalResponse,
	kAVCAsyncCommandStateTimeOutBeforeResponse,
	kAVCAsyncCommandStateBusReset,
	kAVCAsyncCommandStateOutOfMemory,
	kAVCAsyncCommandStateCanceled
} IOFWAVCAsyncCommandState;

#endif // _IOKIT_IOFIREWIREAVCCONSTS_H
                                                                                                                                                                                                                                                                                                                                                                                                                 IOFireWireAVCRequestSpace.h                                                                         0100644 0001750 0001750 00000002213 12567452043 037566  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/avc                                                            /*
 * Copyright (c) 2001 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *
 *	IOFireWirePCRSpace.h
 *
 * Class to multiplex access to the FCP request address.
 */
#ifndef _IOKIT_IOFIREWIREAVCREQUESTSPACE_H
#define _IOKIT_IOFIREWIREAVCREQUESTSPACE_H

#endif /* _IOKIT_IOFIREWIREAVCREQUESTSPACE_H */
                                                                                                                                                                                                                                                                                                                                                                                     IOFireWireAVCTargetSpace.h                                                                          0100644 0001750 0001750 00000023362 12567452043 037374  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/avc                                                            /*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 *
 *	IOFireWireAVCTargetSpace.h
 *
 * Class to centralize the AVC Target mode support
 *
 */

#ifndef _IOKIT_IOFIREWIREAVCTARGETSPACE_H
#define _IOKIT_IOFIREWIREAVCTARGETSPACE_H

#include <IOKit/IOUserClient.h>
#include <IOKit/IOBufferMemoryDescriptor.h>

#include <IOKit/firewire/IOFWAddressSpace.h>
#include <IOKit/firewire/IOLocalConfigDirectory.h>
#include <IOKit/avc/IOFireWireAVCConsts.h>
#include <IOKit/avc/IOFireWireAVCUserClientCommon.h>

class IOFireWireAVCProtocolUserClient;
class AVCCommandHandlerInfo;
class AVCSubunitInfo;

typedef void (*IOFireWireAVCTargetCommandHandlerCallback)(const AVCCommandHandlerInfo *pCmdInfo,
														  UInt32 generation,
														  UInt16 nodeID,
														  const void *command,
														  UInt32 cmdLen,
														  IOFWSpeed &speed,
														  UInt32 handlerSearchIndex);

typedef void (*IOFireWireAVCSubunitPlugHandlerCallback)(const AVCSubunitInfo *pSubunitInfo,
														IOFWAVCSubunitPlugMessages plugMessage,
														IOFWAVCPlugTypes plugType,
														UInt32 plugNum,
														UInt32 messageParams,
														UInt32 generation,
														UInt16 nodeID);

/*!
@class AVCCommandHandlerInfo
@abstract internal class to manage installed command handlers
*/
class AVCCommandHandlerInfo : public OSObject
{
    OSDeclareDefaultStructors(AVCCommandHandlerInfo)
public:
	IOFireWireAVCProtocolUserClient * userClient;
	IOFireWireAVCTargetCommandHandlerCallback callBack;
	OSAsyncReference64 asyncRef;
	UInt32 subUnitTypeAndID;
	UInt32 opCode;
	uint64_t userCallBack;
	uint64_t userRefCon;
};

typedef struct _AVCSubunitPlugRecord
{
	UInt32 plugSignalFormat;
	UInt32 connectionCount;
}AVCSubunitPlugRecord;

/*!
@class AVCSubunitInfo
@abstract internal class to manage installed subunits
*/
class AVCSubunitInfo : public OSObject
{
    OSDeclareDefaultStructors(AVCSubunitInfo)
    bool init();
    void free();
public:
	static AVCSubunitInfo *create();
	IOFireWireAVCProtocolUserClient * userClient;
	IOFireWireAVCSubunitPlugHandlerCallback callBack;
	OSAsyncReference64 asyncRef;
	UInt32 subunitTypeAndID;
	UInt32 numSourcePlugs;
	UInt32 numDestPlugs;
	uint64_t userCallBack;
	uint64_t userRefCon;
	AVCSubunitPlugRecord *sourcePlugRecords;
	AVCSubunitPlugRecord *destPlugRecords;
};

typedef struct _AVCUnitPlugRecord
{
	UInt32 connectionCount;
}AVCUnitPlugRecord;

typedef struct _AVCUnitPlugs
{
	UInt32 numIsochInPlugs;
	UInt32 numIsochOutPlugs;
	UInt32 numExternalInPlugs;
	UInt32 numExternalOutPlugs;
	AVCUnitPlugRecord isochInPlugRecord[kAVCMaxNumPlugs];
	AVCUnitPlugRecord isochOutPlugRecord[kAVCMaxNumPlugs];
	AVCUnitPlugRecord externalInPlugRecord[kAVCMaxNumPlugs];
	AVCUnitPlugRecord externalOutPlugRecord[kAVCMaxNumPlugs];
}AVCUnitPlugs;

/*!
@class UCInfo
@abstract internal class to manage multiple protocol user clients
*/
class UCInfo : public OSObject
{
    OSDeclareDefaultStructors(UCInfo)
public:
    IOFireWireAVCProtocolUserClient *fUserClient;
};

/*!
@class AVCConnectionRecord
@abstract internal class to manage AVC connections
*/
class AVCConnectionRecord : public OSObject
{
    OSDeclareDefaultStructors(AVCConnectionRecord)
public:
	UInt32 sourceSubunitTypeAndID;
	IOFWAVCPlugTypes sourcePlugType;
	UInt32 sourcePlugNum;
	UInt32 destSubunitTypeAndID;
	IOFWAVCPlugTypes destPlugType;
	UInt32 destPlugNum;
	bool lockConnection;
	bool permConnection;
};

/*!
@class IOFireWireAVCTargetSpace
@abstract object to centralize the AVC Target mode support
*/
class IOFireWireAVCTargetSpace : public IOFWPseudoAddressSpace
{
    OSDeclareDefaultStructors(IOFireWireAVCTargetSpace)

protected:
    UInt32 fBuf[512];
    UInt32 fActivations;
	IOFireWireController *fController;
	IOLocalConfigDirectory * fAVCLocalConfigDirectory;
    OSArray * fUserClients;
	OSArray * fCommandHandlers;
	OSArray * fSubunits;
	OSArray * fConnectionRecords;
	AVCUnitPlugs fUnitPlugs;
	IORecursiveLock * fLock;

	/*! @struct ExpansionData
	@discussion This structure will be used to expand the capablilties of the class in the future.
	*/
    struct ExpansionData { };

	/*! @var reserved
	Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

    virtual UInt32 doWrite(UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len,
                           const void *buf, IOFWRequestRefCon refcon);


	IOReturn targetSendAVCResponse(UInt32 generation, UInt16 nodeID, IOBufferMemoryDescriptor *pBufMemDesc, UInt32 size);

	// Internal AVC Target Command Handlers
	IOReturn handleUnitInfoCommand(UInt16 nodeID, UInt32 generation, const char *buf, UInt32 len);
	IOReturn handleSubUnitInfoCommand(UInt16 nodeID, UInt32 generation, const char *buf, UInt32 len);
	IOReturn handlePlugInfoCommand(UInt16 nodeID, UInt32 generation, const char *buf, UInt32 len);
	IOReturn handlePowerCommand(UInt16 nodeID, UInt32 generation, const char *buf, UInt32 len);
	IOReturn handleConnectCommand(UInt16 nodeID, UInt32 generation, const char *buf, UInt32 len);
	IOReturn handleDisconnectCommand(UInt16 nodeID, UInt32 generation, const char *buf, UInt32 len);
	IOReturn handleInputPlugSignalFormatCommand(UInt16 nodeID, UInt32 generation, const char *buf, UInt32 len);
	IOReturn handleOutputPlugSignalFormatCommand(UInt16 nodeID, UInt32 generation, const char *buf, UInt32 len);
	IOReturn handleConnectionsCommand(UInt16 nodeID, UInt32 generation, const char *buf, UInt32 len);
	IOReturn handleSignalSourceCommand(UInt16 nodeID, UInt32 generation, const char *buf, UInt32 len);

	UInt32 subUnitOfTypeCount(UInt32 type);
	AVCSubunitInfo *getSubunitInfo(UInt32 subunitTypeAndID);
	bool canConnectDestPlug(UInt32 destSubunitTypeAndID,
						 IOFWAVCPlugTypes destPlugType,
						 UInt32 *destPlugNum);
	
public:

	// Activate/Deactivate Functions
	virtual IOReturn activateWithUserClient(IOFireWireAVCProtocolUserClient *userClient);
    virtual void deactivateWithUserClient(IOFireWireAVCProtocolUserClient *userClient);

	/*!
	@function init
	@abstract initializes the IOFireWireAVCTargetSpace object
	*/
    virtual bool init(IOFireWireController *controller);

	/*!
	@function getAVCTargetSpace
	@abstract returns the IOFireWireAVCTargetSpace object for the given FireWire bus
	@param bus The FireWire bus
	*/
    static IOFireWireAVCTargetSpace *getAVCTargetSpace(IOFireWireController *controller);

	/*!
	@function publishAVCUnitDirectory
	@abstract Creates a local AVC Unit directory if it doesn't already exist
	*/
    virtual IOReturn publishAVCUnitDirectory(void);

	virtual IOReturn installAVCCommandHandler(IOFireWireAVCProtocolUserClient *userClient,
										   IOFireWireAVCTargetCommandHandlerCallback callBack,
										   OSAsyncReference64 asyncRef,
										   UInt32 subUnitTypeAndID,
										   UInt32 opCode,
										   uint64_t userCallBack,
										   uint64_t userRefCon);

	virtual IOReturn addSubunit(IOFireWireAVCProtocolUserClient *userClient,
							 IOFireWireAVCSubunitPlugHandlerCallback callBack,
							 OSAsyncReference64 asyncRef,
							 UInt32 subunitType,
							 UInt32 numSourcePlugs,
							 UInt32 numDestPlugs,
							 uint64_t userCallBack,
							 uint64_t userRefCon,
							 UInt32 *subUnitID);

	virtual IOReturn setSubunitPlugSignalFormat(IOFireWireAVCProtocolUserClient *userClient,
											 UInt32 subunitTypeAndID,
											 IOFWAVCPlugTypes plugType,
											 UInt32 plugNum,
											 UInt32 signalFormat);

	virtual IOReturn getSubunitPlugSignalFormat(IOFireWireAVCProtocolUserClient *userClient,
											 UInt32 subunitTypeAndID,
											 IOFWAVCPlugTypes plugType,
											 UInt32 plugNum,
											 UInt32 *pSignalFormat);

	virtual IOReturn connectTargetPlugs(IOFireWireAVCProtocolUserClient *userClient,
									 AVCConnectTargetPlugsInParams *inParams,
									 AVCConnectTargetPlugsOutParams *outParams);

	virtual IOReturn disconnectTargetPlugs(IOFireWireAVCProtocolUserClient *userClient,
										UInt32 sourceSubunitTypeAndID,
										IOFWAVCPlugTypes sourcePlugType,
										UInt32 sourcePlugNum,
										UInt32 destSubunitTypeAndID,
										IOFWAVCPlugTypes destPlugType,
										UInt32 destPlugNum);

	virtual IOReturn getTargetPlugConnection(IOFireWireAVCProtocolUserClient *userClient,
										  AVCGetTargetPlugConnectionInParams *inParams,
										  AVCGetTargetPlugConnectionOutParams *outParams);

    virtual IOReturn findAVCRequestHandler(IOFireWireAVCProtocolUserClient *userClient,
										  UInt32 generation,
										  UInt16 nodeID,
										  IOFWSpeed speed,
										  UInt32 handlerSearchIndex,
										  const char *pCmdBuf,
										  UInt32 cmdLen);
	
	virtual void pcrModified(IOFWAVCPlugTypes plugType,
						  UInt32 plugNum,
						  UInt32 newValue);
	
private:
	OSMetaClassDeclareReservedUnused(IOFireWireAVCTargetSpace, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCTargetSpace, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCTargetSpace, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCTargetSpace, 3);
};

#endif /*_IOKIT_IOFIREWIREAVCTARGETSPACE_H */                                                                                                                                                                                                                                                                              IOFireWireAVCUnit.h                                                                                 0100644 0001750 0001750 00000035246 12567452043 036115  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/avc                                                            /*
 * Copyright (c) 1998-2001 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFIREWIREAVCUNIT_H
#define _IOKIT_IOFIREWIREAVCUNIT_H

#include <IOKit/IOService.h>
#include <IOKit/firewire/IOFWRegs.h>
#include <IOKit/firewire/IOFWAddressSpace.h>
#include <IOKit/firewire/IOFWCommand.h>
#include <IOKit/avc/IOFireWireAVCConsts.h>

extern const OSSymbol *gIOAVCUnitType;

class IOFireWireNub;
class IOFireWireAVCCommand;
class IOFireWirePCRSpace;
class IOFireWireAVCUnit;
class IOFireWireAVCSubUnit;
class IOFireWireAVCAsynchronousCommand;
class IOFireWireAVCNub;

// The callback prototype for AVC Asynchronous Commands
typedef void (*IOFireWireAVCAsynchronousCommandCallback)(void *pRefCon, IOFireWireAVCAsynchronousCommand *pCommandObject);

const UInt16 kIOFWAVCAsyncCmdFreed = 0xdead;

/*!
@class IOFireWireAVCAsynchronousCommand
*/
class IOFireWireAVCAsynchronousCommand : public IOCommand 
{
    OSDeclareDefaultStructors(IOFireWireAVCAsynchronousCommand)
	void free(void);

	friend class IOFireWireAVCUnit;
	
protected:
	/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */
    struct ExpansionData { };

	/*! @var reserved
		Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;
	
public:
	IOReturn init(const UInt8 * command, UInt32 len, IOFireWireAVCAsynchronousCommandCallback completionCallback, void *pClientRefCon);
	IOReturn submit(IOFireWireAVCNub *pAVCNub);
	IOReturn cancel(void);
	IOReturn reinit(const UInt8 * command, UInt32 cmdLen);

	// This function returns true if this command is currently waiting for a response
	bool isPending(void);
	
	IOFWAVCAsyncCommandState cmdState;
	void	*pRefCon;
	UInt8	*pCommandBuf;
	UInt32	cmdLen;
	UInt8	*pInterimResponseBuf;
	UInt32	interimResponseLen;
	UInt8	*pFinalResponseBuf;
	UInt32	finalResponseLen;

protected:
	IOFireWireAVCAsynchronousCommandCallback fCallback;
	IOFireWireAVCUnit *fAVCUnit;
	IOMemoryDescriptor *fMem;
	IOFWCommand *fWriteCmd;
	IOFWDelayCommand *fDelayCmd;
    UInt16 fWriteNodeID;
	UInt32 fWriteGen;
	
private:
	OSMetaClassDeclareReservedUnused(IOFireWireAVCAsynchronousCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCAsynchronousCommand, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCAsynchronousCommand, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCAsynchronousCommand, 3);
};

/*!
    @class IOFireWireAVCNub
    @abstract nub for AVC devices
*/
class IOFireWireAVCNub : public IOService
{
    OSDeclareDefaultStructors(IOFireWireAVCNub)

protected:
    IOFireWireNub * fDevice;

public:
    // execute AVC command
/*!
    @function AVCCommand
    @abstract Sends an AVC command to the device and stores the response.
    @param command Pointer to command to send.
    @param cmdLen Length of the command.
    @param response Pointer to place to store the response.
    @param responseLen Pointer to response length - initialize to the size of the buffer pointed to by response,
    updated to the number of bytes returned by the device.
*/
    virtual IOReturn AVCCommand(const UInt8 * command, UInt32 cmdLen, UInt8 * response, UInt32 *responseLen) = 0;

/*!
    @function AVCCommandInGeneration
    @abstract Sends an AVC command to the device and stores the response. The command must complete in the specified
    FireWire bus generation otherwise kIOFireWireBusReset is returned.
    @param generation The bus generation that the command must execute in.
    @param command Pointer to command to send.
    @param cmdLen Length of the command.
    @param response Pointer to place to store the response.
    @param responseLen Pointer to response length - initialize to the size of the buffer pointed to by response,
    updated to the number of bytes returned by the device.
*/
    virtual IOReturn AVCCommandInGeneration(UInt32 generation,
                const UInt8 * command, UInt32 cmdLen, UInt8 * response, UInt32 *responseLen) = 0;

/*!
    @function getDevice
    @abstract Returns the FireWire device nub that is this object's provider .
*/
    IOFireWireNub* getDevice() const
        {return fDevice;};

/*!
    @function updateAVCCommandTimeout
    @abstract By default, AVCCommands timeout 10 seconds after receiving an Interim response.
    This function resets the timeout of the current command to 10 seconds from the current time.
    Call this repeatedly for AVC commands that take a very long time to execute to prevent premature
    timeout.
*/
    virtual IOReturn updateAVCCommandTimeout() = 0;

private:
    OSMetaClassDeclareReservedUsed(IOFireWireAVCNub, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCNub, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCNub, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCNub, 3);
};

/*!
    @class IOFireWireAVCUnit
    @abstract nub for AVC devices
*/
class IOFireWireAVCUnit : public IOFireWireAVCNub
{
    OSDeclareDefaultStructors(IOFireWireAVCUnit)

	friend class IOFireWireAVCAsynchronousCommand;
	
protected:
    IOFWPseudoAddressSpace *fFCPResponseSpace;
    IOLock *avcLock;
    IOFireWireAVCCommand *fCommand;

    UInt8 fSubUnitCount[kAVCNumSubUnitTypes];
    
	bool fStarted;
    IOLock *cmdLock;
	
/*! @struct ExpansionData
    @discussion This structure is used to expand the capablilties of the class in a binary compatible way
    */    
    struct ExpansionData
	{
		OSArray * fAVCAsyncCommands;
		IOFireWireController *fControl;
		bool enableRobustAVCCommandResponseMatching;
	};

/*! @var fIOFireWireAVCUnitExpansion 
      */
    ExpansionData *fIOFireWireAVCUnitExpansion;
    
    static UInt32 AVCResponse(void *refcon, UInt16 nodeID, IOFWSpeed &speed,
                    FWAddress addr, UInt32 len, const void *buf, IOFWRequestRefCon requestRefcon);

    static void rescanSubUnits(void *arg);
    
    virtual void free(void);
    
    virtual void updateSubUnits(bool firstTime);

	static void AVCAsynchRequestWriteDone(void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd);
	static void AVCAsynchDelayDone(void *refcon, IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd);

public:
    // IOService overrides
    virtual bool start(IOService *provider);
    virtual IOReturn message(UInt32 type, IOService *provider, void *argument);
	virtual IOReturn setProperties (OSObject * properties );

/*! @function handleOpen
    @abstract Overrideable method to control the open / close behaviour of an IOService.
    @discussion See IOService for discussion.		
    @param forClient Designates the client of the provider requesting the open.
    @param options Options for the open, may be interpreted by the implementor of handleOpen.
    @result Return true if the open was successful, false otherwise.
*/

    virtual bool handleOpen(  IOService *	  forClient,
                              IOOptionBits	  options,
                              void *		  arg );
/*! 
    @function handleClose
    @abstract Overrideable method to control the open / close behaviour of an IOService.
    @discussion See IOService for discussion.
    @param forClient Designates the client of the provider requesting the close.
    @param options Options for the close, may be interpreted by the implementor of handleOpen. 
*/

    virtual void handleClose(   IOService *		forClient,
                                IOOptionBits	options );
    

/*!
    @function matchPropertyTable
    @abstract Matching language support
	Match on the following properties of the unit:
	Vendor_ID
	GUID
	Unit_Type
	and available sub-units, match if the device has at least the requested number of a sub-unit type:
	AVCSubUnit_0 -> AVCSubUnit_1f
*/
    virtual bool matchPropertyTable(OSDictionary * table);

    // execute AVC command
/*!
    @function AVCCommand
    @abstract Sends an AVC command to the device and stores the response.
    @param command Pointer to command to send.
    @param cmdLen Length of the command.
    @param response Pointer to place to store the response.
    @param responseLen Pointer to response length - initialize to the size of the buffer pointed to by response,
    updated to the number of bytes returned by the device.
*/
    virtual IOReturn AVCCommand(const UInt8 * command, UInt32 cmdLen, UInt8 * response, UInt32 *responseLen);

/*!
    @function AVCCommandInGeneration
    @abstract Sends an AVC command to the device and stores the response. The command must complete in the specified
    FireWire bus generation otherwise kIOFireWireBusReset is returned.
    @param generation The bus generation that the command must execute in.
    @param command Pointer to command to send.
    @param cmdLen Length of the command.
    @param response Pointer to place to store the response.
    @param responseLen Pointer to response length - initialize to the size of the buffer pointed to by response,
    updated to the number of bytes returned by the device.
*/
    virtual IOReturn AVCCommandInGeneration(UInt32 generation,
                const UInt8 * command, UInt32 cmdLen, UInt8 * response, UInt32 *responseLen);

/*!
    @function updateAVCCommandTimeout
    @abstract By default, AVCCommands timeout 10 seconds after receiving an Interim response.
    This function resets the timeout of the current command to 10 seconds from the current time.
    Call this repeatedly for AVC commands that take a very long time to execute to prevent premature
    timeout.
*/
    virtual IOReturn updateAVCCommandTimeout();

protected:
	UInt32 indexOfAVCAsynchronousCommandObject(IOFireWireAVCAsynchronousCommand *pCommandObject);
	void removeAVCAsynchronousCommandObjectAtIndex(UInt32 index);

	void lockAVCAsynchronousCommandLock();

	void unlockAVCAsynchronousCommandLock();
	
	bool available();
	
private:
		
    OSMetaClassDeclareReservedUnused(IOFireWireAVCUnit, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCUnit, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCUnit, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCUnit, 3);

};

/*!
    @class IOFireWireAVCSubUnit
    @abstract nub for sub unit of AVC devices. Just for matching, calls the AVC unit for all functions.
*/
class IOFireWireAVCSubUnit : public IOFireWireAVCNub
{
    OSDeclareDefaultStructors(IOFireWireAVCSubUnit)
	
	friend class IOFireWireAVCAsynchronousCommand;

protected:
    IOFireWireAVCUnit *fAVCUnit;
    
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;
    
public:
    virtual bool init(OSDictionary *propTable, IOFireWireAVCUnit *provider);

    // IOService overrides
    virtual IOReturn message(UInt32 type, IOService *provider, void *argument);

/*! @function handleOpen
    @abstract Overrideable method to control the open / close behaviour of an IOService.
    @discussion See IOService for discussion.		
    @param forClient Designates the client of the provider requesting the open.
    @param options Options for the open, may be interpreted by the implementor of handleOpen.
    @result Return true if the open was successful, false otherwise.
*/

    virtual bool handleOpen(  IOService *	  forClient,
                              IOOptionBits	  options,
                              void *		  arg );
/*! 
    @function handleClose
    @abstract Overrideable method to control the open / close behaviour of an IOService.
    @discussion See IOService for discussion.
    @param forClient Designates the client of the provider requesting the close.
    @param options Options for the close, may be interpreted by the implementor of handleOpen. 
*/

    virtual void handleClose(   IOService *		forClient,
                                IOOptionBits	options );
    

/*!
    @function matchPropertyTable
    @abstract Matching language support
	Match on the following properties of the sub unit:
	Vendor_ID
	GUID
	SubUnit_Type
*/
    virtual bool matchPropertyTable(OSDictionary * table);

    // execute AVC command
/*!
    @function AVCCommand
    @abstract Sends an AVC command to the device and stores the response.
    @param command Pointer to command to send.
    @param cmdLen Length of the command.
    @param response Pointer to place to store the response.
    @param responseLen Pointer to response length - initialize to the size of the buffer pointed to by response,
    updated to the number of bytes returned by the device.
*/
    virtual IOReturn AVCCommand(const UInt8 * command, UInt32 cmdLen, UInt8 * response, UInt32 *responseLen);

/*!
    @function AVCCommandInGeneration
    @abstract Sends an AVC command to the device and stores the response. The command must complete in the specified
    FireWire bus generation otherwise kIOFireWireBusReset is returned.
    @param generation The bus generation that the command must execute in.
    @param command Pointer to command to send.
    @param cmdLen Length of the command.
    @param response Pointer to place to store the response.
    @param responseLen Pointer to response length - initialize to the size of the buffer pointed to by response,
    updated to the number of bytes returned by the device.
*/
    virtual IOReturn AVCCommandInGeneration(UInt32 generation,
                const UInt8 * command, UInt32 cmdLen, UInt8 * response, UInt32 *responseLen);

/*!
    @function updateAVCCommandTimeout
    @abstract By default, AVCCommands timeout 10 seconds after receiving an Interim response.
    This function resets the timeout of the current command to 10 seconds from the current time.
    Call this repeatedly for AVC commands that take a very long time to execute to prevent premature
    timeout.
*/
    virtual IOReturn updateAVCCommandTimeout();

private:
    OSMetaClassDeclareReservedUnused(IOFireWireAVCSubUnit, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCSubUnit, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCSubUnit, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireAVCSubUnit, 3);

};

#endif // _IOKIT_IOFIREWIREAVCUNIT_H

                                                                                                                                                                                                                                                                                                                                                          IOFireWireAVCUserClientCommon.h                                                                     0100644 0001750 0001750 00000012637 12567452043 040423  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/avc                                                            /*
 * Copyright (c) 1998-2001 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFIREWIREAVCUSERCLIENTCOMMON_H_
#define _IOKIT_IOFIREWIREAVCUSERCLIENTCOMMON_H_

#include <IOKit/avc/IOFireWireAVCConsts.h>

#define kIOFireWireAVCLibConnection 13

enum IOFWAVCUserClientCommandCodes {
    kIOFWAVCUserClientOpen,						// kIOUCScalarIScalarO 0,0
    kIOFWAVCUserClientClose,					// kIOUCScalarIScalarO 0,0
    kIOFWAVCUserClientOpenWithSessionRef,		// kIOUCScalarIScalarO 1,0
	kIOFWAVCUserClientGetSessionRef,			// kIOUCScalarIScalarO 0,1
    kIOFWAVCUserClientAVCCommand,				// kIOUCStructIStructO -1,-1
    kIOFWAVCUserClientAVCCommandInGen,			// kIOUCStructIStructO -1,-1
    kIOFWAVCUserClientUpdateAVCCommandTimeout,	// kIOUCScalarIScalarO 0,0
    kIOFWAVCUserClientMakeP2PInputConnection,	// KIOUCScalarIScalarO 1, 0
    kIOFWAVCUserClientBreakP2PInputConnection,	// KIOUCScalarIScalarO 1, 0
    kIOFWAVCUserClientMakeP2POutputConnection,	// KIOUCScalarIScalarO 1, 0
    kIOFWAVCUserClientBreakP2POutputConnection,	// KIOUCScalarIScalarO 1, 0
	kIOFWAVCUserClientCreateAsyncAVCCommand,	// kIOUCStructIStructO -1,-1
	kIOFWAVCUserClientSubmitAsyncAVCCommand,	// kIOUCScalarIScalarO 1, 0
	kIOFWAVCUserClientCancelAsyncAVCCommand,	// kIOUCScalarIScalarO 1, 0
	kIOFWAVCUserClientReleaseAsyncAVCCommand,	// kIOUCScalarIScalarO 1, 0
	kIOFWAVCUserClientReinitAsyncAVCCommand,	// // kIOUCScalarIStructI 1, -1
    kIOFWAVCUserClientNumCommands
};

enum IOFWAVCUserClientAsyncCommandCodes {
    kIOFWAVCUserClientInstallAsyncAVCCommandCallback = kIOFWAVCUserClientNumCommands,	// kIOUCScalarIScalarO 1, 1
    kIOFWAVCUserClientNumAsyncCommands
};


enum IOFWAVCProtocolUserClientCommandCodes {
    kIOFWAVCProtocolUserClientSendAVCResponse,   		// kIOUCScalarIStructI 2, -1
    kIOFWAVCProtocolUserClientFreeInputPlug,			// kIOUCScalarIScalarO 1, 0
    kIOFWAVCProtocolUserClientReadInputPlug,			// kIOUCScalarIScalarO 1, 1
    kIOFWAVCProtocolUserClientUpdateInputPlug,			// kIOUCScalarIScalarO 3, 0
    kIOFWAVCProtocolUserClientFreeOutputPlug,			// kIOUCScalarIScalarO 1, 0
    kIOFWAVCProtocolUserClientReadOutputPlug,			// kIOUCScalarIScalarO 1, 1
    kIOFWAVCProtocolUserClientUpdateOutputPlug,			// kIOUCScalarIScalarO 3, 0
    kIOFWAVCProtocolUserClientReadOutputMasterPlug,		// kIOUCScalarIScalarO 0, 1
    kIOFWAVCProtocolUserClientUpdateOutputMasterPlug,	// kIOUCScalarIScalarO 2, 0
    kIOFWAVCProtocolUserClientReadInputMasterPlug,		// kIOUCScalarIScalarO 0, 1
    kIOFWAVCProtocolUserClientUpdateInputMasterPlug,	// kIOUCScalarIScalarO 2, 0
    kIOFWAVCProtocolUserClientPublishAVCUnitDirectory,	// kIOUCScalarIScalarO 0, 0
	kIOFWAVCProtocolUserClientSetSubunitPlugSignalFormat, // kIOUCScalarIScalarO 4, 0
	kIOFWAVCProtocolUserClientGetSubunitPlugSignalFormat, // kIOUCScalarIScalarO 3, 1
	kIOFWAVCProtocolUserClientConnectTargetPlugs,		// kIOUCStructIStructO
	kIOFWAVCProtocolUserClientDisconnectTargetPlugs,	// kIOUCScalarIScalarO 6, 0
	kIOFWAVCProtocolUserClientGetTargetPlugConnection,	// kIOUCStructIStructO
	kIOFWAVCProtocolUserClientAVCRequestNotHandled,		// kIOUCScalarIStructI 4, -1
    kIOFWAVCProtocolUserClientNumCommands
};

enum IOFWAVCProtocolUserClientAsyncCommandCodes {
    kIOFWAVCProtocolUserClientSetAVCRequestCallback = kIOFWAVCProtocolUserClientNumCommands,   		// kIOUCScalarIScalarO 2, 0
    kIOFWAVCProtocolUserClientAllocateInputPlug,			// kIOUCScalarIScalarO 1, 1
    kIOFWAVCProtocolUserClientAllocateOutputPlug,			// kIOUCScalarIScalarO 1, 1
    kIOFWAVCProtocolUserClientInstallAVCCommandHandler,		// kIOUCScalarIScalarO 4, 0
    kIOFWAVCProtocolUserClientAddSubunit,					// kIOUCScalarIScalarO 5, 1
    kIOFWAVCProtocolUserClientNumAsyncCommands
};

typedef struct _AVCConnectTargetPlugsInParams
{
	UInt32 sourceSubunitTypeAndID;
	IOFWAVCPlugTypes sourcePlugType;
	UInt32 sourcePlugNum;
	UInt32 destSubunitTypeAndID;
	IOFWAVCPlugTypes destPlugType;
	UInt32 destPlugNum;
	Boolean lockConnection;
	Boolean permConnection;
}AVCConnectTargetPlugsInParams;

typedef struct _AVCConnectTargetPlugsOutParams
{
	UInt32 sourcePlugNum;
	UInt32 destPlugNum;
}AVCConnectTargetPlugsOutParams;

typedef struct _AVCGetTargetPlugConnectionInParams
{
	UInt32 subunitTypeAndID;
	IOFWAVCPlugTypes plugType;
	UInt32 plugNum;
}AVCGetTargetPlugConnectionInParams;

typedef struct _AVCGetTargetPlugConnectionOutParams
{
	UInt32 connectedSubunitTypeAndID;
	IOFWAVCPlugTypes connectedPlugType;
	UInt32 connectedPlugNum;
	Boolean lockConnection;
	Boolean permConnection;
}AVCGetTargetPlugConnectionOutParams;

#define kAsyncCmdSharedBufInterimRespOffset 0
#define kAsyncCmdSharedBufFinalRespOffset 512

#endif // _IOKIT_IOFIREWIREAVCUSERCLIENTCOMMON_H_                                                                                                 IOFireWirePCRSpace.h                                                                                0100644 0001750 0001750 00000016265 12567452043 036244  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/avc                                                            /*
 * Copyright (c) 2001 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *
 *	IOFireWirePCRSpace.h
 *
 * Class to multiplex access to the PCR addresses.
 */
#ifndef _IOKIT_IOFIREWIREPCRSPACE_H
#define _IOKIT_IOFIREWIREPCRSPACE_H

#include <IOKit/firewire/IOFWAddressSpace.h>
#include <IOKit/avc/IOFireWireAVCTargetSpace.h>

/*!
    @typedef IOFireWirePCRCallback
	@abstract Callback called after a successful lock transaction to a plug.
    @param refcon refcon supplied to the IOFireWireFCPSpace when a client is registered
	@param nodeID is the node originating the request
	@param plugNo is the plug number
	@param oldVal is the value the plug used to contain
    @param newVal is the quad written into the plug

 */
typedef void (*IOFireWirePCRCallback)(void *refcon, UInt16 nodeID, UInt32 plug, UInt32 oldVal, UInt32 newVal);

class IOFireWireBus;

/*!
    @class IOFireWirePCRSpace
    @abstract object to multiplex users of the PCR plug registers
*/
class IOFireWirePCRSpace : public IOFWPseudoAddressSpace
{
    OSDeclareDefaultStructors(IOFireWirePCRSpace)
    
protected:
    struct Client {
        IOFireWirePCRCallback func;
        void * refcon;
    };
    UInt32 fBuf[64];
    
    Client fClients[64];
    UInt32 fActivations;
	IOFireWireAVCTargetSpace *	fAVCTargetSpace;
	IONotifier *fNotifier;
    
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;
    
    // Override to notify client of each plug seperately
    virtual UInt32 doWrite(UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len,
                           const void *buf, IOFWRequestRefCon refcon);
                          
    virtual IOReturn allocatePlug(void *refcon, IOFireWirePCRCallback func, UInt32 &plug, Client* head);
    virtual void freePlug(UInt32 plug, Client* head);
    virtual UInt32 readPlug(UInt32 plug);
    virtual IOReturn updatePlug(UInt32 plug, UInt32 oldVal, UInt32 newVal);
    
public:

    // Override to handle multiple activations (one per client)
    virtual IOReturn activate();
    virtual void deactivate();

/*!
    @function init
    @abstract initializes the IOFireWirePCRSpace object
*/
    virtual bool init(IOFireWireBus *bus);
/*!
    @function getPCRAddressSpace
    @abstract returns the IOFireWirePCRSpace object for the given FireWire bus
    @param bus The FireWire bus
*/
    static IOFireWirePCRSpace *getPCRAddressSpace(IOFireWireBus *bus);
/*!
    @function allocateInputPlug
    @abstract allocates an input plug.
    @param refcon arbitrary value passed back as first argument of callback.
    @param func callback function when a successful lock transaction to the plug has been performed
    @param plug set to the plug number if a plug is successfully allocated
*/
    virtual IOReturn allocateInputPlug(void *refcon, IOFireWirePCRCallback func, UInt32 &plug);
/*!
    @function freeInputPlug
    @abstract deallocates an input plug.
    @param plug value returned by allocateInputPlug.
*/
    virtual void freeInputPlug(UInt32 plug);
/*!
    @function readInputPlug
    @abstract returns the current value of an input plug.
    @param plug value returned by allocateInputPlug.
*/
    virtual UInt32 readInputPlug(UInt32 plug);
/*!
    @function updateInputPlug
    @abstract updates the value of an input plug (simulating a lock transaction).
    @param plug value returned by allocateInputPlug.
    @param oldVal value returned by readInputPlug.
    @param newVal new value to store in plug if it's current value is oldVal.
*/
    virtual IOReturn updateInputPlug(UInt32 plug, UInt32 oldVal, UInt32 newVal);
/*!
    @function allocateOutputPlug
    @abstract allocates an output plug.
    @param refcon arbitrary value passed back as first argument of callback.
    @param func callback function when a successful lock transaction to the plug has been performed
    @param plug set to the plug number if a plug is successfully allocated
*/
    virtual IOReturn allocateOutputPlug(void *refcon, IOFireWirePCRCallback func, UInt32 &plug);
/*!
    @function freeOutputPlug
    @abstract deallocates an output plug.
    @param plug value returned by allocateOutputPlug.
*/
    virtual void freeOutputPlug(UInt32 plug);
/*!
    @function readOutputPlug
    @abstract returns the current value of an output plug.
    @param plug value returned by allocateOutputPlug.
*/
    virtual UInt32 readOutputPlug(UInt32 plug);
/*!
    @function updateOutputPlug
    @abstract updates the value of an output plug (simulating a lock transaction).
    @param plug value returned by allocateOutputPlug.
    @param oldVal value returned by readOutputPlug.
    @param newVal new value to store in plug if it's current value is oldVal.
*/
    virtual IOReturn updateOutputPlug(UInt32 plug, UInt32 oldVal, UInt32 newVal);
/*!
    @function readOutputMasterPlug
    @abstract returns the current value of the output master plug.
*/
    virtual UInt32 readOutputMasterPlug();
/*!
    @function updateOutputMasterPlug
    @abstract updates the value of the master output plug (simulating a lock transaction).
    @param oldVal value returned by readOutputMasterPlug.
    @param newVal new value to store in plug if it's current value is oldVal.
*/
    virtual IOReturn updateOutputMasterPlug(UInt32 oldVal, UInt32 newVal);
/*!
    @function readInputMasterPlug
    @abstract returns the current value of the input master plug.
*/
    virtual UInt32 readInputMasterPlug();
/*!
    @function updateInputMasterPlug
    @abstract updates the value of the master input plug (simulating a lock transaction).
    @param oldVal value returned by readInputMasterPlug.
    @param newVal new value to store in plug if it's current value is oldVal.
*/
    virtual IOReturn updateInputMasterPlug(UInt32 oldVal, UInt32 newVal);

	/*!
		@function setAVCTargetSpacePointer
	 */
    virtual void setAVCTargetSpacePointer(IOFireWireAVCTargetSpace *pAVCTargetSpace);

	/*!
		@function clearAllP2PConnections
	 */
    virtual void clearAllP2PConnections(void);
	
private:
    OSMetaClassDeclareReservedUnused(IOFireWirePCRSpace, 0);
    OSMetaClassDeclareReservedUnused(IOFireWirePCRSpace, 1);
    OSMetaClassDeclareReservedUnused(IOFireWirePCRSpace, 2);
    OSMetaClassDeclareReservedUnused(IOFireWirePCRSpace, 3);

};

#endif /* _IOKIT_IOFIREWIREPCRSPACE_H */
                                                                                                                                                                                                                                                                                                                                           bluetooth/                                                                                          0040755 0001750 0001750 00000000000 12612224741 034024  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                Bluetooth.h                                                                                         0100644 0001750 0001750 00000314545 12567453167 036172  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/bluetooth                                                      /*
	File:		Bluetooth.h
	Contains:	Public interfaces for Bluetooth technology.
	Copyright:	(c) 2010 by Apple, Inc. All rights reserved.
*/

#pragma once

#ifdef KERNEL
#import	<IOKit/bluetooth/BluetoothAssignedNumbers.h>
#else
#import	<CoreFoundation/CFBase.h>
#import	<IOBluetooth/BluetoothAssignedNumbers.h>
#endif

#import <IOKit/IOTypes.h>
#import <libkern/OSByteOrder.h>

//---------------------------------------------------------------------------------------------------------------------------
/*!	@header		Bluetooth
	Bluetooth wireless technology
*/

#if defined(__cplusplus)
	#define IOBLUETOOTH_EXPORT extern "C"
#else
	#define IOBLUETOOTH_EXPORT extern
#endif

#ifdef	__cplusplus
	extern "C" {
#endif


#if 0

#pragma mark === Baseband ===
#endif

//===========================================================================================================================
//	Baseband
//===========================================================================================================================

typedef uint16_t		BluetoothConnectionHandle;		// Upper 4 bits are reserved.
typedef uint8_t		BluetoothLMPHandle;
enum
{
    kBluetoothConnectionHandleNone	= 0xffff
};

typedef uint8_t		BluetoothReasonCode;
typedef uint8_t		BluetoothEncryptionEnable;
enum
{
	kBluetoothEncryptionEnableOff           = 0x00,
	kBluetoothEncryptionEnableOn            = 0x01,
    
    kBluetoothEncryptionEnableBREDRE0       = 0x01,
    kBluetoothEncryptionEnableLEAESCCM      = 0x01,
    kBluetoothEncryptionEnableBREDRAESCCM   = 0x02
};

typedef uint8_t		BluetoothKeyFlag;
enum
{
	kBluetoothKeyFlagSemiPermanent 	= 0x00, 
	kBluetoothKeyFlagTemporary 		= 0x01
};

typedef uint8_t		BluetoothKeyType;
enum
{
	kBluetoothKeyTypeCombination					= 0x00, 
	kBluetoothKeyTypeLocalUnit						= 0x01,
	kBluetoothKeyTypeRemoteUnit						= 0x02,
	kBluetoothKeyTypeDebugCombination				= 0x03,
	kBluetoothKeyTypeUnauthenticatedCombination		= 0x04,
	kBluetoothKeyTypeAuthenticatedCombination		= 0x05,
	kBluetoothKeyTypeChangedCombination				= 0x06
};

// Packet types (Bluetooth spec section 7.1.5 - Create Connection)

typedef uint16_t		BluetoothPacketType;
enum
{
	kBluetoothPacketTypeReserved1	= 0x0001, 
	kBluetoothPacketType2DH1Omit	= 0x0002,	// Masks OUT this packet type
	kBluetoothPacketType3DH1Omit	= 0x0004,	// Masks OUT this packet type

	kBluetoothPacketTypeDM1			= 0x0008, 
	kBluetoothPacketTypeDH1			= 0x0010, 
	kBluetoothPacketTypeHV1			= 0x0020, 	// Reserved
	kBluetoothPacketTypeHV2			= 0x0040, 	// Reserved
	kBluetoothPacketTypeHV3			= 0x0080, 	// Reserved
	kBluetoothPacketTypeDV			= 0x0100, 	// Reserved
	kBluetoothPacketType2DH3Omit	= 0x0100,	// Masks OUT this packet type
	kBluetoothPacketType3DH3Omit	= 0x0200,	// Masks OUT this packet type
	kBluetoothPacketTypeAUX			= 0x0200,	// Deprecated
	
	kBluetoothPacketTypeDM3			= 0x0400, 
	kBluetoothPacketTypeDH3			= 0x0800,
	
	kBluetoothPacketType2DH5Omit	= 0x1000,	// Masks OUT this packet type
	kBluetoothPacketType3DM5Omit	= 0x2000,	// Masks OUT this packet type 
	
	kBluetoothPacketTypeDM5			= 0x4000, 
	kBluetoothPacketTypeDH5			= 0x8000, 
	
	kBluetoothPacketTypeEnd
};

// Setup Synchronous Packet types (Bluetooth 2.1 spec section 7.1.26 - Setup Synchronous Command)

enum
{
	kBluetoothSynchronousConnectionPacketTypeNone			= 0x0000,
	kBluetoothSynchronousConnectionPacketTypeHV1			= 0x0001,
	kBluetoothSynchronousConnectionPacketTypeHV2			= 0x0002,
	kBluetoothSynchronousConnectionPacketTypeHV3			= 0x0004,
	kBluetoothSynchronousConnectionPacketTypeEV3			= 0x0008,
	kBluetoothSynchronousConnectionPacketTypeEV4			= 0x0010,
	kBluetoothSynchronousConnectionPacketTypeEV5			= 0x0020,

	// masking out certain types:
	
	kBluetoothSynchronousConnectionPacketType2EV3Omit		= 0x0040,
	kBluetoothSynchronousConnectionPacketType3EV3Omit		= 0x0080,
	kBluetoothSynchronousConnectionPacketType2EV5Omit		= 0x0100,
	kBluetoothSynchronousConnectionPacketType3EV5Omit		= 0x0200,
	
	kBluetoothSynchronousConnectionPacketTypeFutureUse		= 0xFC00,
	
	kBluetoothSynchronousConnectionPacketTypeAll			= 0xFFFF,

	kBluetoothSynchronousConnectionPacketTypeEnd
};


// LAP/Inquiry Access Codes

typedef uint32_t		BluetoothLAP;
enum
{
	kBluetoothGeneralInquiryAccessCodeIndex		= 0, 			// General/Unlimited Inquiry Access Code (GIAC)
	kBluetoothGeneralInquiryAccessCodeLAPValue 	= 0x9E8B33, 	// General/Unlimited Inquiry Access Code (GIAC)
	
	kBluetoothLimitedInquiryAccessCodeIndex		= 1, 			// Limited Dedicated Inquiry Access Code (LIAC)
	kBluetoothLimitedInquiryAccessCodeLAPValue 	= 0x9E8B00, 	// Limited Dedicated Inquiry Access Code (LIAC)
	
	// All other access codes are reserved for future use (indices 2-63, LAP values 0x9E8B01-0x9E8B32 and 0x9E8B34-0x9E8B3F).
	
	kBluetoothLimitedInquiryAccessCodeEnd
};

// PageScanRepetitionMode

typedef	uint8_t	BluetoothPageScanRepetitionMode;
enum
{
	kBluetoothPageScanRepetitionModeR0 			= 0x00, 
	kBluetoothPageScanRepetitionModeR1 			= 0x01, 
	kBluetoothPageScanRepetitionModeR2 			= 0x02
	
	// All other values are reserved for future use.
};

// PageScanPeriodMode

typedef uint8_t	BluetoothPageScanPeriodMode;
enum
{
	kBluetoothPageScanPeriodModeP0 				= 0x00, 
	kBluetoothPageScanPeriodModeP1 				= 0x01, 
	kBluetoothPageScanPeriodModeP2 				= 0x02
	
	// All other values are reserved for future use.
};

// PageScanMode

typedef uint8_t	BluetoothPageScanMode;
enum
{
	kBluetoothPageScanModeMandatory 			= 0x00, 
	kBluetoothPageScanModeOptional1 			= 0x01, 
	kBluetoothPageScanModeOptional2 			= 0x02, 
	kBluetoothPageScanModeOptional3 			= 0x03
	
	// All other values are reserved for future use.
};
		
// PageScanType
		
typedef uint8_t	BluetoothHCIPageScanType;
enum BluetoothHCIPageScanTypes
{
	kBluetoothHCIPageScanTypeStandard		= 0x00,
	kBluetoothHCIPageScanTypeInterlaced		= 0x01,
			
	kBluetoothHCIPageScanTypeReservedStart	= 0x02,
	kBluetoothHCIPageScanTypeReservedEnd	= 0xFF
};	
		
// Erroneous Data Reporting
typedef uint8_t	BluetoothHCIErroneousDataReporting;
enum
{
	kBluetoothHCIErroneousDataReportingDisabled			= 0x00,
	kBluetoothHCIErroneousDataReportingEnabled			= 0x01,
			
	kBluetoothHCIErroneousDataReportingReservedStart	= 0x02,
	kBluetoothHCIErroneousDataReportingReservedEnd		= 0xFF
};		

#if 0
#pragma mark -
#pragma mark === Devices ===
#endif

typedef struct	BluetoothDeviceAddress		BluetoothDeviceAddress;
struct	BluetoothDeviceAddress
{
	uint8_t		data[ 6 ];
};

typedef struct	BluetoothKey				BluetoothKey;
struct	BluetoothKey
{
	uint8_t		data[ 16 ];
};

typedef struct  BluetoothIRK                BluetoothIRK;
struct BluetoothIRK
{
    uint8_t     data[ 16 ];
};
        
typedef struct	BluetoothPINCode			BluetoothPINCode;
struct	BluetoothPINCode
{
	uint8_t		data[ 16 ];		// PIN codes may be up to 128 bits.
};


//	Physical layout of the "class of device/service" field (see Bluetooth Assigned Numbers section 1.2):
//
//	 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//	 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  <- Bit Transmission Order
//	+---------------+---------------+---------------+
//	|    octet 3    |    octet 2    |    octet 1    | <- Octet Transmission Order
//	+---------------+---------------+---------------+
//	<------ 11 bits ----->< 5 bits ><- 6 bits ->
//	+---------------------+---------+-----------+-+-+
//	|   Service Classes   | Major   |  Minor    | | |
//	+-+-+-+-+-+-+-+-+-+-+-+  Device |   Device  |0|0|
//	| | | | | | | |*|*|*| |   Class |    Class  | | |
//	+-+-+-+-+-+-+-+-+-+-+-+---------+-----------+-+-+
//	 | | | | | | |       |                        |
//   | | | | | | |       + Limited Discoverable   +- Format Type
//	 | | | | | | +- Networking
//	 | | | | | +- Rendering
//	 | | | | +- Capturing
//	 | | | +- Object Transfer
//	 | | +- Audio
//	 | +- Telephony
//	 +- Information

typedef uint32_t		BluetoothClassOfDevice;

#define		BluetoothGetDeviceClassMajor( inCOD )		( (inCOD & 0x00001F00) >> 8 )
#define		BluetoothGetDeviceClassMinor( inCOD )		( (inCOD & 0x000000FC) >> 2 )
#define		BluetoothGetServiceClassMajor( inCOD )		( (inCOD & 0x00FFE000) >> 13 )
#define		BluetoothMakeClassOfDevice( inServiceClassMajor, inDeviceClassMajor, inDeviceClassMinor )		\
										(((inServiceClassMajor << 13) & 0x00FFE000) | ((inDeviceClassMajor << 8) & 0x00001F00) | ((inDeviceClassMinor << 2) & 0x000000FC))

///
/// Major Service Classes (11-bit value - bits 13-23 of Device/Service field)
///

typedef uint32_t		BluetoothServiceClassMajor;
// Service Class Major enum in BluetoothAssignedNumbers.h

///
/// Major Device Classes (5-bit value - bits 8-12 of Device/Service field)
///

typedef uint32_t		BluetoothDeviceClassMajor;
// Device Class Major enum in BluetoothAssignedNumbers.h

///
/// Minor Device Classes (6-bit value - bits 2-7 of Device/Service field)
///

typedef uint32_t		BluetoothDeviceClassMinor;
// Device Class Minor enum in BluetoothAssignedNumbers.h

// Misc Device Types

enum
{
	kBluetoothDeviceNameMaxLength	= 248
};

typedef uint8_t		BluetoothDeviceName[ 256 ];		// Max 248 bytes of UTF-8 encoded Unicode.
typedef uint16_t	BluetoothClockOffset;			// Bits 14-0 come from bits 16-2 of CLKslav-CLKmaster.
typedef uint8_t		BluetoothRole;					// 
typedef uint8_t		BluetoothAllowRoleSwitch;		// 0x00-0x01 valid, 0x02-0xFF reserved.
enum
{
	kBluetoothDontAllowRoleSwitch 	= 0x00, 
	kBluetoothAllowRoleSwitch 		= 0x01
};

enum
{
	kBluetoothRoleBecomeMaster 	= 0x00, 
	kBluetoothRoleRemainSlave 	= 0x01
};

typedef struct BluetoothSetEventMask	BluetoothSetEventMask;
struct	BluetoothSetEventMask
{
	uint8_t		data[ 8 ];
};

typedef uint8_t	BluetoothPINType;


#if 0
#pragma mark -
#pragma mark === L2CAP ===
#endif

//===========================================================================================================================
//	Logical Link Control and Adaptation Protocol (L2CAP)
//===========================================================================================================================


// ACL Packet values (Bluetooth L2CAP spec section 1).

enum
{
	kBluetoothL2CAPMaxPacketSize					= 65535,	// Max number of data bytes in an L2CAP packet.

	kBluetoothACLLogicalChannelReserved 			= 0, 		// [00] Reserved for future use
	kBluetoothACLLogicalChannelL2CAPContinue	 	= 1, 		// [01] Continuation of L2CAP packet.
	kBluetoothACLLogicalChannelL2CAPStart 			= 2, 		// [10] Start of L2CAP packet.
	kBluetoothACLLogicalChannelLMP	 				= 3			// [11] Link Manager Protocol packet.
};

// Channel Identifiers (Bluetooth L2CAP spec section 2.1).

typedef uint16_t		BluetoothL2CAPChannelID;
enum
{
	kBluetoothL2CAPChannelNull					= 0x0000, 	// Illegal, should not be used
	kBluetoothL2CAPChannelSignalling	 		= 0x0001, 	// L2CAP signalling channel
	kBluetoothL2CAPChannelConnectionLessData	= 0x0002, 	// L2CAP connection less data
	kBluetoothL2CAPChannelAMPManagerProtocol	= 0x0003,	// AMP Manager Protocol
	kBluetoothL2CAPChannelAttributeProtocol		= 0x0004,
	kBluetoothL2CAPChannelLESignalling			= 0x0005,
	kBluetoothL2CAPChannelSecurityManager		= 0x0006,
	// Range 0x0003 to 0x003F reserved for future use.
	kBluetoothL2CAPChannelReservedStart			= 0x0007,
    kBluetoothL2CAPChannelLEAP					= 0x002A,
    kBluetoothL2CAPChannelLEAS					= 0x002B,
	kBluetoothL2CAPChannelMagnet				= 0x003A, // Magnet
    kBluetoothL2CAPChannelReservedEnd			= 0x003F,
    
    // Range 0x0040 to 0xFFFF are dynamically allocated.
    kBluetoothL2CAPChannelDynamicStart			= 0x0040,
    kBluetoothL2CAPChannelDynamicEnd			= 0xffff,
	kBluetoothL2CAPChannelEnd					= 0xffff
};

typedef BluetoothL2CAPChannelID		BluetoothL2CAPGroupID;

// Protocol/Service Multiplexor (PSM) values (Bluetooth L2CAP spec section 5.2).

typedef uint16_t		BluetoothL2CAPPSM;
// PSM enum in BluetoothAssignedNumbers.h

// Command Codes

typedef enum
{
	kBluetoothL2CAPCommandCodeReserved							= 0x00, 
	kBluetoothL2CAPCommandCodeCommandReject						= 0x01, 
	kBluetoothL2CAPCommandCodeConnectionRequest					= 0x02, 
	kBluetoothL2CAPCommandCodeConnectionResponse				= 0x03, 
	kBluetoothL2CAPCommandCodeConfigureRequest					= 0x04, 
	kBluetoothL2CAPCommandCodeConfigureResponse					= 0x05, 
	kBluetoothL2CAPCommandCodeDisconnectionRequest				= 0x06, 
	kBluetoothL2CAPCommandCodeDisconnectionResponse				= 0x07, 
	kBluetoothL2CAPCommandCodeEchoRequest						= 0x08, 
	kBluetoothL2CAPCommandCodeEchoResponse						= 0x09, 
	kBluetoothL2CAPCommandCodeInformationRequest				= 0x0A, 
	kBluetoothL2CAPCommandCodeInformationResponse				= 0x0B,
	kBluetoothL2CAPCommandCodeCreateChannelRequest				= 0x0C,
	kBluetoothL2CAPCommandCodeCreateChannelResponse				= 0x0D,
	kBluetoothL2CAPCommandCodeMoveChannelRequest				= 0x0E,
	kBluetoothL2CAPCommandCodeMoveChannelResponse				= 0x0F,
	kBluetoothL2CAPCommandCodeMoveChannelConfirmation			= 0x10,
	kBluetoothL2CAPCommandCodeMoveChannelConfirmationResponse	= 0x11,
	kBluetoothL2CAPCommandCodeConnectionParameterUpdateRequest	= 0x12,
	kBluetoothL2CAPCommandCodeConnectionParameterUpdateResponse	= 0x13,
	kBluetoothL2CAPCommandCodeLECreditBasedConnectionRequest    = 0x14,
	kBluetoothL2CAPCommandCodeLECreditBasedConnectionResponse	= 0x15,
	kBluetoothL2CAPCommandCodeLEFlowControlCredit               = 0x16,
} BluetoothL2CAPCommandCode;

// Command Reject

typedef enum
{
	kBluetoothL2CAPCommandRejectReasonCommandNotUnderstood 	= 0x0000, 
	kBluetoothL2CAPCommandRejectReasonSignallingMTUExceeded = 0x0001, 
	kBluetoothL2CAPCommandRejectReasonInvalidCIDInRequest 	= 0x0002, 
} BluetoothL2CAPCommandRejectReason;

typedef uint16_t		BluetoothL2CAPMTU;
typedef	uint16_t		BluetoothL2CAPLinkTimeout;
typedef uint16_t		BluetoothL2CAPFlushTimeout;
enum
{
	kBluetoothL2CAPFlushTimeoutUseExisting 	= 0x0000, 
	kBluetoothL2CAPFlushTimeoutImmediate 	= 0x0001, 
	kBluetoothL2CAPFlushTimeoutForever 		= 0xFFFF, 
	
	kBluetoothL2CAPFlushTimeoutEnd
};

typedef struct BluetoothL2CAPQualityOfServiceOptions	BluetoothL2CAPQualityOfServiceOptions;
struct BluetoothL2CAPQualityOfServiceOptions
{
	uint8_t		flags;
	uint8_t		serviceType;
	uint32_t	tokenRate;
	uint32_t	tokenBucketSize;
	uint32_t	peakBandwidth;
	uint32_t	latency;
	uint32_t	delayVariation;
};

typedef struct BluetoothL2CAPRetransmissionAndFlowControlOptions BluetoothL2CAPRetransmissionAndFlowControlOptions;
struct BluetoothL2CAPRetransmissionAndFlowControlOptions
{
	uint8_t		flags;
	uint8_t		txWindowSize;
	uint8_t		maxTransmit;
	uint16_t	retransmissionTimeout;
	uint16_t	monitorTimeout;
	uint16_t	maxPDUPayloadSize;
};

enum
{
	kBluetoothL2CAPInfoTypeMaxConnectionlessMTUSize = 0x0001
};

// Packets

enum
{
	kBluetoothL2CAPPacketHeaderSize = 4
};

typedef uint16_t	BluetoothL2CAPByteCount;
typedef uint8_t		BluetoothL2CAPCommandID;
typedef uint16_t	BluetoothL2CAPCommandByteCount;

typedef enum
{
    kBluetoothL2CAPConnectionResultSuccessful				= 0x0000,
    kBluetoothL2CAPConnectionResultPending					= 0x0001,
    kBluetoothL2CAPConnectionResultRefusedPSMNotSupported	= 0x0002,
    kBluetoothL2CAPConnectionResultRefusedSecurityBlock		= 0x0003,
    kBluetoothL2CAPConnectionResultRefusedNoResources		= 0x0004,
} BluetoothL2CAPConnectionResult;

typedef enum 
{
    kBluetoothL2CAPConnectionStatusNoInfoAvailable			= 0x0000,
    kBluetoothL2CAPConnectionStatusAuthenticationPending	= 0x0001,
    kBluetoothL2CAPConnectionStatusAuthorizationPending		= 0x0002,
} BluetoothL2CAPConnectionStatus;

typedef enum
{
    kBluetoothL2CAPConfigurationResultSuccess					= 0x0000,
    kBluetoothL2CAPConfigurationResultUnacceptableParams		= 0x0001,
    kBluetoothL2CAPConfigurationResultRejected					= 0x0002,
    kBluetoothL2CAPConfigurationResultUnknownOptions			= 0x0003,
} BluetoothL2CAPConfigurationResult;

typedef enum
{
    kBluetoothL2CAPConfigurationOptionMTU                           = 0x01,
    kBluetoothL2CAPConfigurationOptionFlushTimeout                  = 0x02,
    kBluetoothL2CAPConfigurationOptionQoS                           = 0x03,
    kBluetoothL2CAPConfigurationOptionRetransmissionAndFlowControl  = 0x04,
    kBluetoothL2CAPConfigurationOptionFrameCheckSequence            = 0x05,
    kBluetoothL2CAPConfigurationOptionExtendedFlowSpecification     = 0x06,
    kBluetoothL2CAPConfigurationOptionExtendedWindowSize            = 0x07
} BluetoothL2CAPConfigurationOption;

enum
{
    kBluetoothL2CAPConfigurationOptionMTULength                             = 2,
    kBluetoothL2CAPConfigurationOptionFlushTimeoutLength                    = 2,
    kBluetoothL2CAPConfigurationOptionQoSLength                             = 22,
    kBluetoothL2CAPConfigurationOptionRetransmissionAndFlowControlLength    = 9
};

typedef enum
{
    kBluetoothL2CAPConfigurationBasicL2CAPModeFlag          = 0x00,
    kBluetoothL2CAPConfigurationRetransmissionModeFlag      = 0x01,
    kBluetoothL2CAPConfigurationFlowControlModeFlag         = 0x02,
    kBluetoothL2CAPConfigurationEnhancedRetransmissionMode  = 0x03,
    kBluetoothL2CAPConfigurationStreamingMode               = 0x04
} BluetoothL2CAPConfigurationRetransmissionAndFlowControlFlags;


typedef enum
{
    kBluetoothL2CAPInformationTypeConnectionlessMTU			= 0x0001,
    kBluetoothL2CAPInformationTypeExtendedFeatures			= 0x0002,
	kBluetoothL2CAPInformationTypeFixedChannelsSupported	= 0x0003,
} BluetoothL2CAPInformationType;

typedef enum
{
    kBluetoothL2CAPInformationResultSuccess			= 0x0000,
    kBluetoothL2CAPInformationResultNotSupported	= 0x0001,
} BluetoothL2CAPInformationResult;

typedef enum
{
    kBluetoothL2CAPInformationNoExtendedFeatures			= 0x00000000,
    kBluetoothL2CAPInformationFlowControlMode				= 0x00000001,
    kBluetoothL2CAPInformationRetransmissionMode			= 0x00000002,
    kBluetoothL2CAPInformationBidirectionalQoS				= 0x00000004,
	kBluetoothL2CAPInformationEnhancedRetransmissionMode	= 0x00000008,
	kBluetoothL2CAPInformationStreamingMode					= 0x00000010,
	kBluetoothL2CAPInformationFCSOption						= 0x00000020,
	kBluetoothL2CAPInformationExtendedFlowSpecification		= 0x00000040,
	kBluetoothL2CAPInformationFixedChannels					= 0x00000080,
	kBluetoothL2CAPInformationExtendedWindowSize			= 0x00000100,
	kBluetoothL2CAPUnicastConnectionlessDataReception		= 0x00000200,
} BluetoothL2CAPInformationExtendedFeaturesMask;

typedef enum
{
    kBluetoothL2CAPQoSTypeNoTraffic     = 0x00,
    kBluetoothL2CAPQoSTypeBestEffort	= 0x01,
    kBluetoothL2CAPQoSTypeGuaranteed	= 0x02,
} BluetoothL2CAPQoSType;

enum
{
	kBluetoothL2CAPMTULowEnergyDefault			= 0x001b,	// 27 bytes
	kBluetoothL2CAPMTUMinimum					= 0x0030,	// 48 bytes
	kBluetoothL2CAPMTUDefault					= 0x03F9,	// 11.10.08 - dropped back to 1017 from 1021 (don't aggravate the 3DH5 problem between CSR<->BRCM just yet)
	kBluetoothL2CAPMTUMaximum					= 0xffff,	
	kBluetoothL2CAPMTUStart						= 0x7fff,
	kBluetoothL2CAPMTUSIG						= 0x0030,	// 48 bytes
	kBluetoothL2CAPFlushTimeoutDefault			= kBluetoothL2CAPFlushTimeoutForever,	// 0xffff
	kBluetoothL2CAPQoSFlagsDefault				= 0,
	kBluetoothL2CAPQoSTypeDefault				= kBluetoothL2CAPQoSTypeBestEffort,	// 0x01
	kBluetoothL2CAPQoSTokenRateDefault			= 0x00000000,
	kBluetoothL2CAPQoSTokenBucketSizeDefault	= 0x00000000,
	kBluetoothL2CAPQoSPeakBandwidthDefault		= 0x00000000,
	kBluetoothL2CAPQoSLatencyDefault			= 0xffffffff,
	kBluetoothL2CAPQoSDelayVariationDefault		= 0xffffffff
};
		
#pragma mark === LE Security Manager ===

#define kBluetoothLESMPTimeout 30		
		
#define kBluetoothLESMPMinEncryptionKeySize 7
#define kBluetoothLESMPMaxEncryptionKeySize	16
		
enum BluetoothLESecurityManagerKeyDistributionFormat
{
	kBluetoothLESecurityManagerEncryptionKey			= (1 << 0L), // LTK, EDIV, RAND
	kBluetoothLESecurityManagerIDKey					= (1 << 1L), // IRK 
	kBluetoothLESecurityManagerSignKey					= (1 << 2L), // CSRK
    kBluetoothLESecurityManagerLinkKey					= (1 << 3L), // LinkKey
};				
		
typedef enum
{
	kBluetoothLESecurityManagerCommandCodeReserved                      = 0x00,
	kBluetoothLESecurityManagerCommandCodePairingRequest                = 0x01,
	kBluetoothLESecurityManagerCommandCodePairingResponse               = 0x02,
	kBluetoothLESecurityManagerCommandCodePairingConfirm                = 0x03,
	kBluetoothLESecurityManagerCommandCodePairingRandom                 = 0x04,
	kBluetoothLESecurityManagerCommandCodePairingFailed                 = 0x05,
	kBluetoothLESecurityManagerCommandCodeEncryptionInfo                = 0x06,
	kBluetoothLESecurityManagerCommandCodeMasterIdentification          = 0x07,
	kBluetoothLESecurityManagerCommandCodeIdentityInfo                  = 0x08,
	kBluetoothLESecurityManagerCommandCodeIdentityAddressInfo           = 0x09,
	kBluetoothLESecurityManagerCommandCodeSigningInfo                   = 0x0A,
    kBluetoothLESecurityManagerCommandCodeSecurityRequest               = 0x0B,
    kBluetoothLESecurityManagerCommandCodePairingPublicKey              = 0x0C,
    kBluetoothLESecurityManagerCommandCodePairingDHKeyCheck             = 0x0D,
    kBluetoothLESecurityManagerCommandCodePairingKeypressNotification	= 0x0E,
    
	// 0x0C - 0xFF reserved
	kBluetoothLESecurityManagerCommandCodeReservedStart                 = 0x0F,
	kBluetoothLESecurityManagerCommandCodeReservedEnd                   = 0xFF
} BluetoothLESecurityManagerCommandCode;

typedef enum
{
	kBluetoothLESecurityManagerUserInputCapabilityNoInput			= 0x01,
	kBluetoothLESecurityManagerUserInputCapabilityYesNo				= 0x02,
	kBluetoothLESecurityManagerUserInputCapabilityKeyboard			= 0x03
} BluetoothLESecurityManagerUserInputCapability;

typedef enum
{
	kBluetoothLESecurityManagerUserOutputCapabilityNoOutput			= 0x01,
	kBluetoothLESecurityManagerUserOutputCapabilityNumericOutput	= 0x02
} BluetoothLESecurityManagerUserOutputCapability;

typedef enum
{
	kBluetoothLESecurityManagerIOCapabilityDisplayOnly				= 0x00,
	kBluetoothLESecurityManagerIOCapabilityDisplayYesNo				= 0x01,
	kBluetoothLESecurityManagerIOCapabilityKeyboardOnly				= 0x02,
	kBluetoothLESecurityManagerIOCapabilityNoInputNoOutput          = 0x03,
	kBluetoothLESecurityManagerIOCapabilityKeyboardDisplay          = 0x04,
	
	// 0x05 - 0xFF reserved
	kBluetoothLESecurityManagerIOCapabilityReservedStart            = 0x05,
	kBluetoothLESecurityManagerIOCapabilityReservedEnd				= 0xFF
} BluetoothLESecurityManagerIOCapability;

typedef enum
{
	kBluetoothLESecurityManagerOOBAuthenticationDataNotPresent      = 0x00,
	kBluetoothLESecurityManagerOOBAuthenticationDataPresent         = 0x01,
	
	// 0x02 - 0xFF reserved
	kBluetoothLESecurityManagerOOBDataReservedStart					= 0x02,
	kBluetoothLESecurityManagerOOBDataReservedEnd					= 0xFF,
} BluetoothLESecurityManagerOOBData;

enum
{
	kBluetoothLESecurityManagerNoBonding							= 0,    // [00]
	kBluetoothLESecurityManagerBonding								= 1,    // [01]
	kBluetoothLESecurityManagerReservedStart						= 2,    // [10]
	kBluetoothLESecurityManagerReservedEnd							= 3     // [11]
};

typedef enum
{
	kBluetoothLESecurityManagerReasonCodeReserved                                           = 0x00,
	kBluetoothLESecurityManagerReasonCodePasskeyEntryFailed                                 = 0x01,
	kBluetoothLESecurityManagerReasonCodeOOBNotAvailbale                                    = 0x02,
	kBluetoothLESecurityManagerReasonCodeAuthenticationRequirements                         = 0x03,
	kBluetoothLESecurityManagerReasonCodeConfirmValueFailed                                 = 0x04,
	kBluetoothLESecurityManagerReasonCodePairingNotSupported                                = 0x05,
	kBluetoothLESecurityManagerReasonCodeEncryptionKeySize                                  = 0x06,
	kBluetoothLESecurityManagerReasonCodeCommandNotSupported                                = 0x07,
	kBluetoothLESecurityManagerReasonCodeUnspecifiedReason                                  = 0x08,
	kBluetoothLESecurityManagerReasonCodeRepeatedAttempts                                   = 0x09,
    kBluetoothLESecurityManagerReasonCodeInvalidParameters                                  = 0x0A,
    kBluetoothLESecurityManagerReasonCodeDHKeyCheckFailed                                   = 0x0B,
    kBluetoothLESecurityManagerReasonCodeNumericComparisonFailed                            = 0x0C,
    kBluetoothLESecurityManagerReasonCodeBREDRPairingInProgress                             = 0x0D,
    kBluetoothLESecurityManagerReasonCodeCrossTransportKeyDerivationGenerationNotAllowed    = 0x0E,
    
	kBluetoothLESecurityManagerReasonCodeReservedStart                                      = 0x0F,
	kBluetoothLESecurityManagerReasonCodeReservedEnd                                        = 0xFF
} BluetoothLESecurityManagerPairingFailedReasonCode;
        
typedef enum
{
    kBluetoothLESecurityManagerNotificationTypePasskeyEntryStarted      = 0,
    kBluetoothLESecurityManagerNotificationTypePasskeyDigitEntered      = 1,
    kBluetoothLESecurityManagerNotificationTypePasskeyDigitErased       = 2,
    kBluetoothLESecurityManagerNotificationTypePasskeyCleared           = 3,
    kBluetoothLESecurityManagerNotificationTypePasskeyEntryCompleted    = 4,
    
    kBluetoothLESecurityManagerNotificationTypeReservedStart            = 5,
    kBluetoothLESecurityManagerNotificationTypeReservedEnd              = 255,
}  BluetoothLESecurityManagerKeypressNotificationType;

		
		

#pragma mark === AMP Manager ===
typedef enum {
	kBluetoothAMPManagerCodeReserved							= 0x00,
	kBluetoothAMPManagerCodeAMPCommandReject					= 0x01,
	kBluetoothAMPManagerCodeAMPDiscoverRequest					= 0x02,
	kBluetoothAMPManagerCodeAMPDiscoverResponse					= 0x03,
	kBluetoothAMPManagerCodeAMPChangeNotify						= 0x04,
	kBluetoothAMPManagerCodeAMPChangeResponse					= 0x05,
	kBluetoothAMPManagerCodeAMPGetInfoRequest					= 0x06,
	kBluetoothAMPManagerCodeAMPGetInfoResponse					= 0x07,
	kBluetoothAMPManagerCodeAMPGetAssocRequest					= 0x08,
	kBluetoothAMPManagerCodeAMPGetAssocResponse					= 0x09,
	kBluetoothAMPManagerCodeAMPCreatePhysicalLinkRequest		= 0x0A,
	kBluetoothAMPManagerCodeAMPCreatePhysicalLinkResponse		= 0x0B,
	kBluetoothAMPManagerCodeAMPDisconnectPhysicalLinkRequest	= 0x0C,
	kBluetoothAMPManagerCodeAMPDisconnectPhysicalLinkResponse	= 0x0D,
} BluetoothAMPManagerCode;
		
typedef enum {
	kBluetoothAMPManagerCommandRejectReasonCommandNotRecognized	= 0x0000,
} BluetoothAMPCommandRejectReason;
		
typedef enum {
	kBluetoothAMPManagerDiscoverResponseControllerStatusPoweredDown		= 0x00,
	kBluetoothAMPManagerDiscoverResponseControllerStatusBluetoothOnly	= 0x01,
	kBluetoothAMPManagerDiscoverResponseControllerStatusNoCapacity		= 0x02,
	kBluetoothAMPManagerDiscoverResponseControllerStatusLowCapacity		= 0x03,
	kBluetoothAMPManagerDiscoverResponseControllerStatusMediumCapacity	= 0x04,
	kBluetoothAMPManagerDiscoverResponseControllerStatusHighCapacity	= 0x05,
	kBluetoothAMPManagerDiscoverResponseControllerStatusFullCapacity	= 0x06,
} BluetoothAMPDiscoverResponseControllerStatus;
		
typedef enum {
	kBluetoothAMPManagerGetInfoResponseSuccess				= 0x00,
	kBluetoothAMPManagerGetInfoResponseInvalidControllerID	= 0x01,
} BluetoothAMPGetInfoResponseStatus;
		
typedef enum {
	kBluetoothAMPManagerGetAssocResponseSuccess				= 0x00,
	kBluetoothAMPManagerGetAssocResponseInvalidControllerID	= 0x01,
} BluetoothAMPGetAssocResponseStatus;
		
typedef enum {
	kBluetoothAMPManagerCreatePhysicalLinkResponseSuccess										= 0x00,
	kBluetoothAMPManagerCreatePhysicalLinkResponseInvalidControllerID							= 0x01,
	kBluetoothAMPManagerCreatePhysicalLinkResponseUnableToStartLinkCreation						= 0x02,
	kBluetoothAMPManagerCreatePhysicalLinkResponseCollisionOccurred								= 0x03,
	kBluetoothAMPManagerCreatePhysicalLinkResponseAMPDisconnectedPhysicalLinkRequestReceived	= 0x04,
	kBluetoothAMPManagerCreatePhysicalLinkResponsePhysicalLinkAlreadyExists						= 0x05,
	kBluetoothAMPManagerCreatePhysicalLinkResponseSecurityViolation								= 0x06,
} BluetoothAMPCreatePhysicalLinkResponseStatus;
		
typedef enum {
	kBluetoothAMPManagerDisconnectPhysicalLinkResponseSuccess				= 0x00,
	kBluetoothAMPManagerDisconnectPhysicalLinkResponseInvalidControllerID	= 0x01,
	kBluetoothAMPManagerDisconnectPhysicalLinkResponseNoPhysicalLink		= 0x02,
} BluetoothAMPDisconnectPhysicalLinkResponseStatus;

#if 0
#pragma mark -
#pragma mark === HCI ===
#endif

//===========================================================================================================================
//	Host Controller Interface (HCI)
//===========================================================================================================================

//	HCI Command Packet
//	------------------
//	
//	                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
//	 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
//	+--------------------------------+---------------+--------------+
//	|            OpCode              |               |              |
//	+--------------------+-----------| Param Length  |  Params...   |
//	|         OCF        |    OGF    |               |              |
//	+--------------------+-----------+---------------+--------------+
//	|                                                               |
//	|                         Params...                             |
//	|                                                               |
//	+---------------------------------------------------------------+

// Commands
		
typedef uint8_t		BluetoothHCICommandOpCodeGroup;
typedef uint16_t		BluetoothHCICommandOpCodeCommand;
typedef uint16_t		BluetoothHCICommandOpCode;
typedef	uint32_t		BluetoothHCIVendorCommandSelector;

#define	BluetoothHCIMakeCommandOpCode( GROUP, CMD )				( ( ( ( GROUP ) & 0x003F ) << 10 ) | ( ( CMD ) & 0x03FF ) )
#define	BluetoothHCIMakeCommandOpCodeEndianSwap( GROUP, CMD )	( CFSwapInt16HostToLittle ( BluetoothHCIMakeCommandOpCode( GROUP, CMD ) ) )
#define	BluetoothHCIExtractCommandOpCodeGroup( OPCODE )			( ( ( OPCODE ) >> 10 ) & 0x003F )
#define	BluetoothHCIExtractCommandOpCodeCommand( OPCODE )		( ( OPCODE ) & 0x03FF )

#define BluetoothHCIMakeCommandOpCodeHostOrder(GROUP, CMD )	OSSwapLittleToHostConstInt16( ( ( ( GROUP ) & 0x003F ) << 10 ) | ( ( CMD ) & 0x03FF ) )


enum
{
	// Command Group: NoOp
	
	kBluetoothHCIOpCodeNoOp												= 0, 
	kBluetoothHCICommandGroupNoOp										= 0x00, 
		kBluetoothHCICommandNoOp										= 0x0000,
	
	// Command Group: Link Control
	
	kBluetoothHCICommandGroupLinkControl								= 0x01, 
		kBluetoothHCICommandInquiry										= 0x0001, 
		kBluetoothHCICommandInquiryCancel								= 0x0002, 
		kBluetoothHCICommandPeriodicInquiryMode							= 0x0003, 
		kBluetoothHCICommandExitPeriodicInquiryMode						= 0x0004, 
		kBluetoothHCICommandCreateConnection							= 0x0005, 
		kBluetoothHCICommandDisconnect									= 0x0006, 
		kBluetoothHCICommandAddSCOConnection							= 0x0007,	// DEPRECATED
		kBluetoothHCICommandCreateConnectionCancel						= 0x0008,
		kBluetoothHCICommandAcceptConnectionRequest						= 0x0009, 
		kBluetoothHCICommandRejectConnectionRequest						= 0x000A, 
		kBluetoothHCICommandLinkKeyRequestReply							= 0x000B, 
		kBluetoothHCICommandLinkKeyRequestNegativeReply					= 0x000C, 
		kBluetoothHCICommandPINCodeRequestReply							= 0x000D, 
		kBluetoothHCICommandPINCodeRequestNegativeReply					= 0x000E, 
		kBluetoothHCICommandChangeConnectionPacketType					= 0x000F, 
		kBluetoothHCICommandAuthenticationRequested						= 0x0011, 
		kBluetoothHCICommandSetConnectionEncryption						= 0x0013, 
		kBluetoothHCICommandChangeConnectionLinkKey						= 0x0015, 
		kBluetoothHCICommandMasterLinkKey								= 0x0017, 
		kBluetoothHCICommandRemoteNameRequest							= 0x0019, 
		kBluetoothHCICommandReadRemoteSupportedFeatures					= 0x001B, 
		kBluetoothHCICommandReadRemoteExtendedFeatures					= 0x001C, 
		kBluetoothHCICommandReadRemoteVersionInformation				= 0x001D, 
		kBluetoothHCICommandReadClockOffset								= 0x001F, 
		kBluetoothHCICommandRemoteNameRequestCancel						= 0x001A,
		kBluetoothHCICommandReadLMPHandle								= 0x0020,
		kBluetoothHCICommandSetupSynchronousConnection					= 0x0028,
		kBluetoothHCICommandAcceptSynchronousConnectionRequest			= 0x0029,
		kBluetoothHCICommandRejectSynchronousConnectionRequest			= 0x002A,
		kBluetoothHCICommandIOCapabilityRequestReply					= 0x002B,
		kBluetoothHCICommandUserConfirmationRequestReply				= 0x002C,
		kBluetoothHCICommandUserConfirmationRequestNegativeReply		= 0x002D,
		kBluetoothHCICommandUserPasskeyRequestReply						= 0x002E,
		kBluetoothHCICommandUserPasskeyRequestNegativeReply				= 0x002F,
		kBluetoothHCICommandRemoteOOBDataRequestReply					= 0x0030,
		kBluetoothHCICommandRemoteOOBDataRequestNegativeReply			= 0x0033,
		kBluetoothHCICommandIOCapabilityRequestNegativeReply			= 0x0034,
		kBluetoothHCICommandEnhancedSetupSynchronousConnection			= 0x003D,
		kBluetoothHCICommandEnhancedAcceptSynchronousConnectionRequest	= 0x003E,
		kBluetoothHCICommandTruncatedPage								= 0x003F,
		kBluetoothHCICommandTruncatedPageCancel							= 0x0040,
		kBluetoothHCICommandSetConnectionlessSlaveBroadcast				= 0x0041,
		kBluetoothHCICommandSetConnectionlessSlaveBroadcastReceive		= 0x0042,
		kBluetoothHCICommandStartSynchronizationTrain					= 0x0043,
		kBluetoothHCICommandReceiveSynchronizationTrain					= 0x0044,
		kBluetoothHCICommandRemoteOOBExtendedDataRequestReply			= 0x0045,

	// Command Group: Link Policy
	
	kBluetoothHCICommandGroupLinkPolicy									= 0x02, 
		kBluetoothHCICommandHoldMode									= 0x0001, 
		kBluetoothHCICommandSniffMode									= 0x0003, 
		kBluetoothHCICommandExitSniffMode								= 0x0004, 
		kBluetoothHCICommandParkMode									= 0x0005, 
		kBluetoothHCICommandExitParkMode								= 0x0006, 
		kBluetoothHCICommandQoSSetup									= 0x0007, 
		kBluetoothHCICommandRoleDiscovery								= 0x0009, 
		kBluetoothHCICommandSwitchRole									= 0x000B, 
		kBluetoothHCICommandReadLinkPolicySettings						= 0x000C, 
		kBluetoothHCICommandWriteLinkPolicySettings						= 0x000D, 
		kBluetoothHCICommandReadDefaultLinkPolicySettings				= 0x000E,
		kBluetoothHCICommandWriteDefaultLinkPolicySettings				= 0x000F,
		kBluetoothHCICommandFlowSpecification							= 0x0010,
		kBluetoothHCICommandSniffSubrating								= 0x0011,
		kBluetoothHCICommandAcceptSniffRequest							= 0x0031,
		kBluetoothHCICommandRejectSniffRequest							= 0x0032,
	
	// Command Group: Host Controller & Baseband
	
	kBluetoothHCICommandGroupHostController								= 0x03, 
		kBluetoothHCICommandSetEventMask								= 0x0001, 
		kBluetoothHCICommandReset										= 0x0003, 
		kBluetoothHCICommandSetEventFilter								= 0x0005, 
		kBluetoothHCICommandFlush										= 0x0008, 
		kBluetoothHCICommandReadPINType									= 0x0009, 
		kBluetoothHCICommandWritePINType								= 0x000A, 
		kBluetoothHCICommandCreateNewUnitKey							= 0x000B, 
		kBluetoothHCICommandReadStoredLinkKey							= 0x000D, 
		kBluetoothHCICommandWriteStoredLinkKey							= 0x0011, 
		kBluetoothHCICommandDeleteStoredLinkKey							= 0x0012, 
		kBluetoothHCICommandChangeLocalName								= 0x0013, 
		kBluetoothHCICommandReadLocalName								= 0x0014, 
		kBluetoothHCICommandReadConnectionAcceptTimeout					= 0x0015, 
		kBluetoothHCICommandWriteConnectionAcceptTimeout				= 0x0016, 
		kBluetoothHCICommandReadPageTimeout								= 0x0017, 
		kBluetoothHCICommandWritePageTimeout							= 0x0018, 
		kBluetoothHCICommandReadScanEnable								= 0x0019, 
		kBluetoothHCICommandWriteScanEnable								= 0x001A, 
		kBluetoothHCICommandReadPageScanActivity						= 0x001B, 
		kBluetoothHCICommandWritePageScanActivity						= 0x001C, 
		kBluetoothHCICommandReadInquiryScanActivity						= 0x001D, 
		kBluetoothHCICommandWriteInquiryScanActivity					= 0x001E, 
		kBluetoothHCICommandReadAuthenticationEnable					= 0x001F, 
		kBluetoothHCICommandWriteAuthenticationEnable					= 0x0020, 
		kBluetoothHCICommandReadEncryptionMode							= 0x0021,	// DEPRECATED
		kBluetoothHCICommandWriteEncryptionMode							= 0x0022,	// DEPRECATED
		kBluetoothHCICommandReadClassOfDevice							= 0x0023,
		kBluetoothHCICommandWriteClassOfDevice							= 0x0024, 
		kBluetoothHCICommandReadVoiceSetting							= 0x0025,
		kBluetoothHCICommandWriteVoiceSetting							= 0x0026, 
		kBluetoothHCICommandReadAutomaticFlushTimeout					= 0x0027, 
		kBluetoothHCICommandWriteAutomaticFlushTimeout					= 0x0028, 
		kBluetoothHCICommandReadNumberOfBroadcastRetransmissions		= 0x0029, 
		kBluetoothHCICommandWriteNumberOfBroadcastRetransmissions		= 0x002A, 
		kBluetoothHCICommandReadHoldModeActivity						= 0x002B, 
		kBluetoothHCICommandWriteHoldModeActivity						= 0x002C, 
		kBluetoothHCICommandReadTransmitPowerLevel						= 0x002D, 
		kBluetoothHCICommandReadSCOFlowControlEnable					= 0x002E, 
		kBluetoothHCICommandWriteSCOFlowControlEnable					= 0x002F, 
		kBluetoothHCICommandSetHostControllerToHostFlowControl			= 0x0031, 
		kBluetoothHCICommandHostBufferSize								= 0x0033, 
		kBluetoothHCICommandHostNumberOfCompletedPackets				= 0x0035, 
		kBluetoothHCICommandReadLinkSupervisionTimeout					= 0x0036, 
		kBluetoothHCICommandWriteLinkSupervisionTimeout					= 0x0037, 
		kBluetoothHCICommandReadNumberOfSupportedIAC					= 0x0038, 
		kBluetoothHCICommandReadCurrentIACLAP							= 0x0039, 
		kBluetoothHCICommandWriteCurrentIACLAP							= 0x003A, 
		kBluetoothHCICommandReadPageScanPeriodMode						= 0x003B,	// DEPRECATED 
		kBluetoothHCICommandWritePageScanPeriodMode						= 0x003C,	// DEPRECATED 
		kBluetoothHCICommandReadPageScanMode							= 0x003D,	// DEPRECATED 
		kBluetoothHCICommandWritePageScanMode							= 0x003E,	// DEPRECATED 
		kBluetoothHCICommandSetAFHClassification						= 0x003F, 		
		kBluetoothHCICommandReadInquiryScanType							= 0x0042, 		
		kBluetoothHCICommandWriteInquiryScanType						= 0x0043, 		
		kBluetoothHCICommandReadInquiryMode								= 0x0044, 		
		kBluetoothHCICommandWriteInquiryMode							= 0x0045,
		kBluetoothHCICommandReadPageScanType							= 0x0046,
		kBluetoothHCICommandWritePageScanType							= 0x0047,
		kBluetoothHCICommandReadAFHChannelAssessmentMode				= 0x0048,
		kBluetoothHCICommandWriteAFHChannelAssessmentMode				= 0x0049,
		kBluetoothHCICommandReadExtendedInquiryResponse					= 0x0051, 		
		kBluetoothHCICommandWriteExtendedInquiryResponse				= 0x0052,
		kBluetoothHCICommandRefreshEncryptionKey						= 0x0053,
		kBluetoothHCICommandReadSimplePairingMode						= 0x0055,
		kBluetoothHCICommandWriteSimplePairingMode						= 0x0056,
		kBluetoothHCICommandReadLocalOOBData							= 0x0057,
		kBluetoothHCICommandReadInquiryResponseTransmitPower			= 0x0058,
		kBluetoothHCICommandWriteInquiryResponseTransmitPower			= 0x0059,
		kBluetoothHCICommandSendKeypressNotification					= 0x0060,
		kBluetoothHCICommandReadDefaultErroneousDataReporting			= 0x005A,
		kBluetoothHCICommandWriteDefaultErroneousDataReporting			= 0x005B,
		kBluetoothHCICommandEnhancedFlush								= 0x005F,
		kBluetoothHCICommandReadLogicalLinkAcceptTimeout				= 0x0061,
		kBluetoothHCICommandWriteLogicalLinkAcceptTimeout				= 0x0062,
		kBluetoothHCICommandSetEventMaskPageTwo							= 0x0063,
		kBluetoothHCICommandReadLocationData							= 0x0064,
		kBluetoothHCICommandWriteLocationData							= 0x0065,
		kBluetoothHCICommandReadFlowControlMode							= 0x0066,
		kBluetoothHCICommandWriteFlowControlMode						= 0x0067,
		kBluetoothHCICommandReadEnhancedTransmitPowerLevel				= 0x0068,
		kBluetoothHCICommandReadBestEffortFlushTimeout					= 0x0069,
		kBluetoothHCICommandWriteBestEffortFlushTimeout					= 0x006A,
		kBluetoothHCICommandShortRangeMode								= 0x006B,
		kBluetoothHCICommandReadLEHostSupported							= 0x006C,
		kBluetoothHCICommandWriteLEHostSupported						= 0x006D,
		kBluetoothHCICommandSetMWSChannelParameters						= 0x006E,
		kBluetoothHCICommandSetExternalFrameConfiguration				= 0x006F,
		kBluetoothHCICommandSetMWSSignaling								= 0x0070,
		kBluetoothHCICommandSetMWSTransportLayer						= 0x0071,
		kBluetoothHCICommandSetMWSScanFrequencyTable					= 0x0072,
		kBluetoothHCICommandSetMWSPATTERNConfiguration					= 0x0073,
		kBluetoothHCICommandSetReservedLTADDR							= 0x0074,
		kBluetoothHCICommandDeleteReservedLTADDR						= 0x0075,
		kBluetoothHCICommandSetConnectionlessSlaveBroadcastData			= 0x0076,
		kBluetoothHCICommandReadSynchronizationTrainParameters			= 0x0077,
		kBluetoothHCICommandWriteSynchronizationTrainParameters			= 0x0078,
		kBluetoothHCICommandReadSecureConnectionsHostSupport			= 0x0079,
		kBluetoothHCICommandWriteSecureConnectionsHostSupport			= 0x007A,
		kBluetoothHCICommandReadAuthenticatedPayloadTimeout				= 0x007B,
		kBluetoothHCICommandWriteAuthenticatedPayloadTimeout			= 0x007C,
		kBluetoothHCICommandReadLocalOOBExtendedData					= 0x007D,
		kBluetoothHCICommandReadExtendedPageTimeout						= 0x007E,
		kBluetoothHCICommandWriteExtendedPageTimeout					= 0x007F,
		kBluetoothHCICommandReadExtendedInquiryLength					= 0x0080,
		kBluetoothHCICommandWriteExtendedInquiryLength					= 0x0081,

	// Command Group: Informational
	
	kBluetoothHCICommandGroupInformational								= 0x04, 
		kBluetoothHCICommandReadLocalVersionInformation					= 0x0001, 
		kBluetoothHCICommandReadLocalSupportedCommands					= 0x0002, 
		kBluetoothHCICommandReadLocalSupportedFeatures					= 0x0003, 
		kBluetoothHCICommandReadLocalExtendedFeatures					= 0x0004,
		kBluetoothHCICommandReadBufferSize								= 0x0005, 
		kBluetoothHCICommandReadCountryCode								= 0x0007,	// DEPRECATED 
		kBluetoothHCICommandReadDeviceAddress							= 0x0009,
		kBluetoothHCICommandReadDataBlockSize							= 0x000A,
		kBluetoothHCICommandReadLocalSupportedCodecs					= 0x000B,
	
	// Command Group: Status
	
	kBluetoothHCICommandGroupStatus										= 0x05, 
		kBluetoothHCICommandReadFailedContactCounter					= 0x0001, 
		kBluetoothHCICommandResetFailedContactCounter					= 0x0002, 
		kBluetoothHCICommandGetLinkQuality								= 0x0003, 
		kBluetoothHCICommandReadRSSI									= 0x0005, 
		kBluetoothHCICommandReadAFHMappings								= 0x0006,
		kBluetoothHCICommandReadClock									= 0x0007,
		kBluetoothHCICommandReadEncryptionKeySize						= 0x0008,
		kBluetoothHCICommandReadLocalAMPInfo							= 0x0009,
		kBluetoothHCICommandReadLocalAMPASSOC							= 0x000A,
		kBluetoothHCICommandWriteRemoteAMPASSOC							= 0x000B,
		kBluetoothHCICommandGetMWSTransportLayerConfiguration			= 0x000C,
		kBluetoothHCICommandSetTriggeredClockCapture					= 0x000D,

	// Command Group: Testing
	
	kBluetoothHCICommandGroupTesting									= 0x06, 
		kBluetoothHCICommandReadLoopbackMode							= 0x0001, 
		kBluetoothHCICommandWriteLoopbackMode							= 0x0002, 
		kBluetoothHCICommandEnableDeviceUnderTestMode					= 0x0003, 
		kBluetoothHCICommandWriteSimplePairingDebugMode					= 0x0004,
		kBluetoothHCICommandEnableAMPReceiverReports					= 0x0007,
		kBluetoothHCICommandAMPTestEnd									= 0x0008,
		kBluetoothHCICommandAMPTest										= 0x0009,

	// Command Group: Low Energy
	
	kBluetoothHCICommandGroupLowEnergy										= 0x08,
		kBluetoothHCICommandLESetEventMask									= 0x0001,
		kBluetoothHCICommandLEReadBufferSize								= 0x0002,
		kBluetoothHCICommandLEReadLocalSupportedFeatures					= 0x0003,
		kBluetoothHCICommandLESetRandomAddress								= 0x0005,
		kBluetoothHCICommandLESetAdvertisingParameters						= 0x0006,
		kBluetoothHCICommandLEReadAdvertisingChannelTxPower					= 0x0007,
		kBluetoothHCICommandLESetAdvertisingData							= 0x0008,
		kBluetoothHCICommandLESetScanResponseData							= 0x0009,
		kBluetoothHCICommandLESetAdvertiseEnable							= 0x000A,
		kBluetoothHCICommandLESetScanParameters								= 0x000B,
		kBluetoothHCICommandLESetScanEnable									= 0x000C,
		kBluetoothHCICommandLECreateConnection								= 0x000D,
		kBluetoothHCICommandLECreateConnectionCancel						= 0x000E,
		kBluetoothHCICommandLEReadWhiteListSize								= 0x000F,
		kBluetoothHCICommandLEClearWhiteList								= 0x0010,
		kBluetoothHCICommandLEAddDeviceToWhiteList							= 0x0011,
		kBluetoothHCICommandLERemoveDeviceFromWhiteList						= 0x0012,
		kBluetoothHCICommandLEConnectionUpdate								= 0x0013,
		kBluetoothHCICommandLESetHostChannelClassification					= 0x0014,
		kBluetoothHCICommandLEReadChannelMap								= 0x0015,
		kBluetoothHCICommandLEReadRemoteUsedFeatures						= 0x0016,
		kBluetoothHCICommandLEEncrypt										= 0x0017,
		kBluetoothHCICommandLERand											= 0x0018,
		kBluetoothHCICommandLEStartEncryption								= 0x0019,
		kBluetoothHCICommandLELongTermKeyRequestReply						= 0x001A,
		kBluetoothHCICommandLELongTermKeyRequestNegativeReply				= 0x001B,
		kBluetoothHCICommandLEReadSupportedStates							= 0x001C,
		kBluetoothHCICommandLEReceiverTest									= 0x001D,
		kBluetoothHCICommandLETransmitterTest								= 0x001E,
		kBluetoothHCICommandLETestEnd										= 0x001F,
		kBluetoothHCICommandLERemoteConnectionParameterRequestReply			= 0x0020,
		kBluetoothHCICommandLERemoteConnectionParameterRequestNegativeReply	= 0x0021,
		kBluetoothHCICommandLESetDataLength									= 0x0022,
		kBluetoothHCICommandLEReadSuggestedDefaultDataLength				= 0x0023,
		kBluetoothHCICommandLEWriteSuggestedDefaultDataLength				= 0x0024,
		kBluetoothHCICommandLEReadLocalP256PublicKey						= 0x0025,
		kBluetoothHCICommandLEGenerateDHKey									= 0x0026,
		kBluetoothHCICommandLEAddDeviceToResolvingList						= 0x0027,
		kBluetoothHCICommandLERemoveDeviceFromResolvingList					= 0x0028,
		kBluetoothHCICommandLEClearResolvingList							= 0x0029,
		kBluetoothHCICommandLEReadResolvingListSize							= 0x002A,
		kBluetoothHCICommandLEReadPeerResolvableAddress						= 0x002B,
		kBluetoothHCICommandLEReadLocalResolvableAddress					= 0x002C,
		kBluetoothHCICommandLESetAddressResolutionEnable					= 0x002D,
		kBluetoothHCICommandLESetResolvablePrivateAddressTimeout			= 0x002E,
		kBluetoothHCICommandLEReadMaximumDataLength							= 0x002F,
	
	// Command Group: Logo Testing (no commands yet)
	
	kBluetoothHCICommandGroupLogoTesting 								= 0x3E, 
	
	// Command Group: Vendor Specific
	kBluetoothHCICommandGroupVendorSpecific								= 0x3F, 
	
	kBluetoothHCICommandGroupMax										= 0x40, 
	kBluetoothHCICommandMax												= 0x03FF
};

// HCI Data Types

typedef uint8_t										BluetoothHCIQoSFlags;
typedef uint8_t										BluetoothHCIParamByteCount;
typedef uint16_t									BluetoothHCIACLDataByteCount;
typedef uint8_t										BluetoothHCISCODataByteCount;
typedef uint8_t										BluetoothHCIInquiryLength;
typedef uint8_t										BluetoothHCIResponseCount;
typedef uint8_t										BluetoothHCICountryCode;
typedef uint16_t									BluetoothHCIModeInterval;
typedef uint16_t									BluetoothHCISniffAttemptCount;
typedef uint16_t									BluetoothHCISniffTimeout;
typedef uint16_t									BluetoothHCIParkModeBeaconInterval;

typedef uint8_t										BluetoothMaxSlots;
typedef uint16_t									BluetoothManufacturerName;
typedef uint8_t										BluetoothLMPVersion;
typedef uint16_t									BluetoothLMPSubversion;

typedef uint8_t										BluetoothHCIConnectionMode;
enum BluetoothHCIConnectionModes
{
	kConnectionActiveMode					= 0,
	kConnectionHoldMode						= 1,
	kConnectionSniffMode					= 2,
	kConnectionParkMode						= 3,
	kConnectionModeReservedForFutureUse		= 4,
};
				
typedef struct	BluetoothHCISupportedCommands		BluetoothHCISupportedCommands;
struct BluetoothHCISupportedCommands
{
	uint8_t	data[64];
};		
		
typedef struct	BluetoothHCISupportedFeatures		BluetoothHCISupportedFeatures;
struct BluetoothHCISupportedFeatures
{
	uint8_t	data[8];
};

typedef uint8_t										BluetoothHCIPageNumber;
typedef struct	BluetoothHCIExtendedFeaturesInfo	BluetoothHCIExtendedFeaturesInfo;
struct BluetoothHCIExtendedFeaturesInfo
{
	BluetoothHCIPageNumber	page;
	BluetoothHCIPageNumber	maxPage;
	uint8_t					data[8];
};
		
enum BluetoothFeatureBits
{
	// Byte 0 of the support features data structure.

	kBluetoothFeatureThreeSlotPackets					= (1 << 0L),
	kBluetoothFeatureFiveSlotPackets					= (1 << 1L),
	kBluetoothFeatureEncryption							= (1 << 2L),
	kBluetoothFeatureSlotOffset							= (1 << 3L),
	kBluetoothFeatureTimingAccuracy						= (1 << 4L),
	kBluetoothFeatureSwitchRoles						= (1 << 5L),
	kBluetoothFeatureHoldMode							= (1 << 6L),
	kBluetoothFeatureSniffMode							= (1 << 7L),
	
	// Byte 1 of the support features data structure.

	kBluetoothFeatureParkMode							= (1 << 0L),
	kBluetoothFeatureRSSI								= (1 << 1L),
	kBluetoothFeaturePowerControlRequests				= (1 << 1L),
	kBluetoothFeatureChannelQuality						= (1 << 2L),
	kBluetoothFeatureSCOLink							= (1 << 3L),
	kBluetoothFeatureHV2Packets							= (1 << 4L),
	kBluetoothFeatureHV3Packets							= (1 << 5L),
	kBluetoothFeatureULawLog							= (1 << 6L),
	kBluetoothFeatureALawLog							= (1 << 7L),

	// Byte 2 of the support features data structure.

	kBluetoothFeatureCVSD								= (1 << 0L),
	kBluetoothFeaturePagingScheme						= (1 << 1L),
	kBluetoothFeaturePowerControl						= (1 << 2L),
	kBluetoothFeatureTransparentSCOData					= (1 << 3L),
	kBluetoothFeatureFlowControlLagBit0					= (1 << 4L),
	kBluetoothFeatureFlowControlLagBit1					= (1 << 5L),
	kBluetoothFeatureFlowControlLagBit2					= (1 << 6L),
	kBluetoothFeatureBroadcastEncryption				= (1 << 7L),	
	
	// Byte 3 of the support features data structure.	
	
	kBluetoothFeatureScatterMode						= (1 << 0L),
	kBluetoothFeatureEnhancedDataRateACL2MbpsMode		= (1 << 1L),	
	kBluetoothFeatureEnhancedDataRateACL3MbpsMode		= (1 << 2L),	
	kBluetoothFeatureEnhancedInquiryScan				= (1 << 3L),
	kBluetoothFeatureInterlacedInquiryScan				= (1 << 4L),	
	kBluetoothFeatureInterlacedPageScan					= (1 << 5L),		
	kBluetoothFeatureRSSIWithInquiryResult				= (1 << 6L),	
	kBluetoothFeatureExtendedSCOLink					= (1 << 7L),

	// Byte 4 of the support features data structure.	

	kBluetoothFeatureEV4Packets							= (1 << 0L),
	kBluetoothFeatureEV5Packets							= (1 << 1L),	
	kBluetoothFeatureAbsenceMasks						= (1 << 2L),
	kBluetoothFeatureAFHCapableSlave					= (1 << 3L),
	kBluetoothFeatureAFHClassificationSlave				= (1 << 4L),	
	kBluetoothFeatureAliasAuhentication					= (1 << 5L),
	kBluetoothFeatureLESupportedController				= (1 << 6L),
	kBluetoothFeature3SlotEnhancedDataRateACLPackets	= (1 << 7L),
	
	// Byte 5 of the support features data structure.

	kBluetoothFeature5SlotEnhancedDataRateACLPackets	= (1 << 0L), // 2.0 version of this header had this at the wrong bit location
	kBluetoothFeatureSniffSubrating						= (1 << 1L),
	kBluetoothFeaturePauseEncryption					= (1 << 2L),
	kBluetoothFeatureAFHCapableMaster					= (1 << 3L),
	kBluetoothFeatureAFHClassificationMaster			= (1 << 4L),
	kBluetoothFeatureEnhancedDataRateeSCO2MbpsMode		= (1 << 5L),
	kBluetoothFeatureEnhancedDataRateeSCO3MbpsMode		= (1 << 6L),
	kBluetoothFeature3SlotEnhancedDataRateeSCOPackets	= (1 << 7L),
	
	// Byte 6 of the support features data structure.	

	kBluetoothFeatureExtendedInquiryResponse			= (1 << 0L),
	kBluetoothFeatureSecureSimplePairing				= (1 << 3L),
	kBluetoothFeatureEncapsulatedPDU					= (1 << 4L),
	kBluetoothFeatureErroneousDataReporting				= (1 << 5L),
	kBluetoothFeatureNonFlushablePacketBoundaryFlag		= (1 << 6L),
	
	// Byte 7 of the support features data structure.

	kBluetoothFeatureLinkSupervisionTimeoutChangedEvent	= (1 << 0L),
	kBluetoothFeatureInquiryTransmissionPowerLevel		= (1 << 1L),
	kBluetoothFeatureExtendedFeatures					= (1 << 7L),
	
	// Byte 8 of the support features data structure (extended)

	kBluetoothFeatureSimpleSecurePairingHostMode		= (1 << 0L),

};

typedef struct BluetoothEventFilterCondition	BluetoothEventFilterCondition;
struct BluetoothEventFilterCondition
{
    uint8_t		data[ 7 ];
};        
        
typedef uint16_t										BluetoothHCIFailedContactCount;
typedef struct BluetoothHCIFailedContactInfo		BluetoothHCIFailedContactInfo;
struct BluetoothHCIFailedContactInfo
{
	BluetoothHCIFailedContactCount	count;
	BluetoothConnectionHandle		handle;
};

typedef SInt8										BluetoothHCIRSSIValue;	/* Valid Range: -127 to +20 */
typedef struct BluetoothHCIRSSIInfo					BluetoothHCIRSSIInfo;
struct BluetoothHCIRSSIInfo
{
	BluetoothConnectionHandle		handle;
	BluetoothHCIRSSIValue			RSSIValue;
};

typedef	uint8_t										BluetoothHCILinkQuality;
typedef struct BluetoothHCILinkQualityInfo			BluetoothHCILinkQualityInfo;
struct BluetoothHCILinkQualityInfo
{
	BluetoothConnectionHandle		handle;
	BluetoothHCILinkQuality			qualityValue;
};

typedef uint8_t	BluetoothHCIRole;
typedef struct	BluetoothHCIRoleInfo					BluetoothHCIRoleInfo;
struct BluetoothHCIRoleInfo
{
	uint8_t						role;
	BluetoothConnectionHandle	handle;
};

enum BluetoothHCIRoles
{
	kBluetoothHCIMasterRole				= 0x00,
	kBluetoothHCISlaveRole				= 0x01
};

typedef uint16_t										BluetoothHCILinkPolicySettings;
enum BluetoothHCILinkPolicySettingsValues
{
	kDisableAllLMModes					= 0x0000,
	kEnableMasterSlaveSwitch			= 0x0001,
	kEnableHoldMode						= 0x0002,
	kEnableSniffMode					= 0x0004,
	kEnableParkMode						= 0x0008,
	kReservedForFutureUse				= 0x0010
};

typedef struct	BluetoothHCILinkPolicySettingsInfo		BluetoothHCILinkPolicySettingsInfo;
struct BluetoothHCILinkPolicySettingsInfo
{
	BluetoothHCILinkPolicySettings		settings;
	BluetoothConnectionHandle			handle;
};


typedef struct BluetoothHCIQualityOfServiceSetupParams	BluetoothHCIQualityOfServiceSetupParams;
struct BluetoothHCIQualityOfServiceSetupParams
{
	uint8_t		flags;
	uint8_t		serviceType;
	uint32_t		tokenRate;
	uint32_t		peakBandwidth;
	uint32_t		latency;
	uint32_t		delayVariation;
};

typedef struct BluetoothHCISetupSynchronousConnectionParams	BluetoothHCISetupSynchronousConnectionParams;
struct BluetoothHCISetupSynchronousConnectionParams
{
	uint32_t		transmitBandwidth;
	uint32_t		receiveBandwidth;
	uint16_t		maxLatency;
	uint16_t		voiceSetting;
	uint8_t		retransmissionEffort;
	uint16_t		packetType;
};
		
typedef struct BluetoothHCIAcceptSynchronousConnectionRequestParams	BluetoothHCIAcceptSynchronousConnectionRequestParams;
struct BluetoothHCIAcceptSynchronousConnectionRequestParams
{
	uint32_t		transmitBandwidth;
	uint32_t		receiveBandwidth;
	uint16_t		maxLatency;
	uint16_t		contentFormat;
	uint8_t		retransmissionEffort;
	uint16_t		packetType;
};

typedef uint8_t	BluetoothHCILoopbackMode;
enum
{
	kBluetoothHCILoopbackModeOff		= 0x00,
	kBluetoothHCILoopbackModeLocal		= 0x01,
	kBluetoothHCILoopbackModeRemote		= 0x02
};
		
typedef struct BluetoothReadClockInfo BluetoothReadClockInfo;
struct BluetoothReadClockInfo
{
	BluetoothConnectionHandle	handle;
	uint32_t					clock;
	uint16_t					accuracy;			
};
        
typedef struct BluetoothHCIEventFlowSpecificationData BluetoothHCIEventFlowSpecificationData;
struct BluetoothHCIEventFlowSpecificationData
{
    BluetoothConnectionHandle					connectionHandle;
    uint8_t										flags;
    uint8_t										flowDirection;
    uint8_t										serviceType;
    uint32_t									tokenRate;
    uint32_t									tokenBucketSize;
    uint32_t									peakBandwidth;
    uint32_t									accessLatency;
};        
                
typedef uint32_t BluetoothHCIOperationID;
typedef uint32_t BluetoothHCIEventID;
typedef uint32_t BluetoothHCIDataID;
typedef uint32_t BluetoothHCISignalID;
typedef uint32_t BluetoothHCITransportID;
typedef uint32_t BluetoothHCITransportCommandID;
typedef uint32_t BluetoothHCIRequestID;
		

// Version Information

typedef struct	BluetoothHCIVersionInfo		BluetoothHCIVersionInfo;
struct	BluetoothHCIVersionInfo
{
	// Local & Remote information
	
	BluetoothManufacturerName	manufacturerName;
	BluetoothLMPVersion			lmpVersion;
	BluetoothLMPSubversion		lmpSubVersion;
	
	// Local information only
	
	uint8_t						hciVersion;
	uint16_t					hciRevision;
};

// HCI buffer sizes.

typedef struct	BluetoothHCIBufferSize		BluetoothHCIBufferSize;
struct	BluetoothHCIBufferSize
{
	uint16_t	ACLDataPacketLength;
	uint8_t		SCODataPacketLength;
	uint16_t	totalNumACLDataPackets;
	uint16_t	totalNumSCODataPackets;
};

typedef struct	BluetoothHCILEBufferSize	BluetoothHCILEBufferSize;
struct	BluetoothHCILEBufferSize
{
	uint16_t	ACLDataPacketLength;
	uint8_t		totalNumACLDataPackets;
};

// Timeouts
typedef uint16_t	BluetoothHCIConnectionAcceptTimeout;
typedef uint16_t	BluetoothHCIPageTimeout;
enum BluetoothHCITimeoutValues
{
	kDefaultPageTimeout			= 0x2710,
};

#define		BluetoothGetSlotsFromSeconds( inSeconds )		( (inSeconds/.000625 ) )
#define		BluetoothGetSecondsFromSlots( inSlots )			( (inSlots*.000625 ) )


// Link Keys
typedef uint16_t	BluetoothHCINumLinkKeysDeleted;
typedef uint8_t	BluetoothHCINumLinkKeysToWrite;
typedef uint8_t	BluetoothHCIDeleteStoredLinkKeyFlag;
enum BluetoothHCIDeleteStoredLinkKeyFlags
{
	kDeleteKeyForSpecifiedDeviceOnly			= 0x00,
	kDeleteAllStoredLinkKeys					= 0x01,
};

typedef uint8_t	BluetoothHCIReadStoredLinkKeysFlag;
enum BluetoothHCIReadStoredLinkKeysFlags
{
	kReturnLinkKeyForSpecifiedDeviceOnly		= 0x00,
	kReadAllStoredLinkKeys						= 0x01,
};

typedef struct	BluetoothHCIStoredLinkKeysInfo	BluetoothHCIStoredLinkKeysInfo;
struct BluetoothHCIStoredLinkKeysInfo
{
	uint16_t	numLinkKeysRead;
	uint16_t	maxNumLinkKeysAllowedInDevice;
};


// Page Scan

typedef uint8_t	BluetoothHCIPageScanMode;
enum BluetoothHCIPageScanModes
{
	kMandatoryPageScanMode		= 0x00,
	kOptionalPageScanMode1		= 0x01,
	kOptionalPageScanMode2		= 0x02,
	kOptionalPageScanMode3		= 0x03,
};

typedef uint8_t	BluetoothHCIPageScanPeriodMode;
enum BluetoothHCIPageScanPeriodModes
{
	kP0Mode						= 0x00,
	kP1Mode						= 0x01,
	kP2Mode						= 0x02,
};

typedef uint8_t	BluetoothHCIPageScanEnableState;
enum BluetoothHCIPageScanEnableStates
{
	kNoScansEnabled							= 0x00,
	kInquiryScanEnabledPageScanDisabled		= 0x01,
	kInquiryScanDisabledPageScanEnabled		= 0x02,
	kInquiryScanEnabledPageScanEnabled		= 0x03,
};

typedef struct	BluetoothHCIScanActivity	BluetoothHCIScanActivity;
struct BluetoothHCIScanActivity
{
	uint16_t 	scanInterval;
	uint16_t	scanWindow;
};

typedef struct	BluetoothHCIInquiryAccessCode	BluetoothHCIInquiryAccessCode;
struct BluetoothHCIInquiryAccessCode
{
	uint8_t 	data[3];
};

typedef uint8_t BluetoothHCIInquiryAccessCodeCount;
typedef struct	BluetoothHCICurrentInquiryAccessCodes	BluetoothHCICurrentInquiryAccessCodes;
struct BluetoothHCICurrentInquiryAccessCodes
{
	BluetoothHCIInquiryAccessCodeCount	count;	// Number of codes in array.
	BluetoothHCIInquiryAccessCode *		codes;	// Ptr to array of codes.
};

enum
{
	kMaximumNumberOfInquiryAccessCodes	= 0x40
};
		
typedef struct	BluetoothHCICurrentInquiryAccessCodesForWrite	BluetoothHCICurrentInquiryAccessCodesForWrite;
struct BluetoothHCICurrentInquiryAccessCodesForWrite
{
	BluetoothHCIInquiryAccessCodeCount	count;			// Number of codes in array (Range 0x01 to 0x40)
	uint8_t 							codes [kMaximumNumberOfInquiryAccessCodes * sizeof (BluetoothHCIInquiryAccessCode)];	// Array of bytes (maximum 192 bytes -- 64 * 3).
};
		
typedef	struct BluetoothHCILinkSupervisionTimeout	BluetoothHCILinkSupervisionTimeout;
struct BluetoothHCILinkSupervisionTimeout
{
	BluetoothConnectionHandle 	handle;
	uint16_t					timeout;
};

typedef uint8_t BluetoothHCIFlowControlState;
enum BluetoothHCISCOFlowControlStates
{
	kSCOFlowControlDisabled		= 0x00,
	kSCOFlowControlEnabled		= 0x01
};

enum BluetoothHCIGeneralFlowControlStates
{
	kHostControllerToHostFlowControlOff			= 0x00,
	kHCIACLDataPacketsOnHCISCODataPacketsOff	= 0x01,
	kHCIACLDataPacketsOffHCISCODataPacketsOn	= 0x02,
	kHCIACLDataPacketsOnHCISCODataPacketsOn		= 0x03,
};		
		
typedef SInt8 BluetoothHCITransmitPowerLevel;
typedef uint8_t BluetoothHCITransmitPowerLevelType;
enum BluetoothHCITransmitReadPowerLevelTypes
{
	kReadCurrentTransmitPowerLevel	= 0x00,
	kReadMaximumTransmitPowerLevel	= 0x01,
};

typedef uint8_t	BluetoothHCIAFHChannelAssessmentMode;	
enum BluetoothHCIAFHChannelAssessmentModes
{
	kAFHChannelAssessmentModeDisabled		= 0x00,
	kAFHChannelAssessmentModeEnabled		= 0x01
};


typedef struct BluetoothHCITransmitPowerLevelInfo	BluetoothHCITransmitPowerLevelInfo;
struct BluetoothHCITransmitPowerLevelInfo
{
	BluetoothConnectionHandle		handle;
	BluetoothHCITransmitPowerLevel	level; // Range: -70 <= N <= 20 (units are dBm)
};

typedef uint8_t	BluetoothHCINumBroadcastRetransmissions;
typedef uint8_t	BluetoothHCIHoldModeActivity;
enum BluetoothHCIHoldModeActivityStates
{
	kMaintainCurrentPowerState		= 0x00,
	kSuspendPageScan				= 0x01,
	kSuspendInquiryScan				= 0x02,
	kSuspendPeriodicInquiries		= 0x03,
};

typedef uint8_t BluetoothHCIAuthenticationEnable;
enum BluetoothHCIAuthentionEnableModes
{
	kAuthenticationDisabled			= 0x00,
	kAuthenticationEnabled			= 0x01,
};

typedef uint8_t	BluetoothHCIEncryptionMode;
enum BluetoothHCIEncryptionModes
{
	kEncryptionDisabled									= 0x00,		// Default.
	kEncryptionOnlyForPointToPointPackets				= 0x01,
	kEncryptionForBothPointToPointAndBroadcastPackets	= 0x02,
};

typedef uint16_t	BluetoothHCIAutomaticFlushTimeout;
typedef struct	BluetoothHCIAutomaticFlushTimeoutInfo	BluetoothHCIAutomaticFlushTimeoutInfo;
struct BluetoothHCIAutomaticFlushTimeoutInfo
{
	BluetoothConnectionHandle			handle;
	BluetoothHCIAutomaticFlushTimeout	timeout;
};

#define	kInfoStringMaxLength		35
typedef struct	BluetoothTransportInfo 		BluetoothTransportInfo;
typedef 		BluetoothTransportInfo*		BluetoothTransportInfoPtr;
struct			BluetoothTransportInfo
{
	uint32_t	productID;
	uint32_t	vendorID;
	uint32_t	type;
	char		productName[kInfoStringMaxLength];
	char		vendorName[kInfoStringMaxLength];
	
	uint64_t	totalDataBytesSent;
	uint64_t	totalSCOBytesSent;
	uint64_t	totalDataBytesReceived;
	uint64_t	totalSCOBytesReceived;
};

enum BluetoothTransportTypes
{
	kBluetoothTransportTypeUSB		= 0x01,
	kBluetoothTransportTypePCCard	= 0x02,
	kBluetoothTransportTypePCICard	= 0x03,
	kBluetoothTransportTypeUART		= 0x04
};

// Inquiries

typedef struct	BluetoothHCIInquiryResult	BluetoothHCIInquiryResult;
struct	BluetoothHCIInquiryResult
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothPageScanRepetitionMode		pageScanRepetitionMode;
	BluetoothHCIPageScanPeriodMode		pageScanPeriodMode;
	BluetoothHCIPageScanMode			pageScanMode;
	BluetoothClassOfDevice				classOfDevice;
	BluetoothClockOffset				clockOffset;
};

#define kBluetoothHCIInquiryResultsMaxResults 50
typedef struct	BluetoothHCIInquiryResults	BluetoothHCIInquiryResults;
struct	BluetoothHCIInquiryResults
{
	BluetoothHCIInquiryResult		results[kBluetoothHCIInquiryResultsMaxResults];
	IOItemCount						count;
};


//Inquiries with RSSI (v1.2 specification)

typedef struct	BluetoothHCIInquiryWithRSSIResult	BluetoothHCIInquiryWithRSSIResult;
struct	BluetoothHCIInquiryWithRSSIResult
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothPageScanRepetitionMode		pageScanRepetitionMode;
	uint8_t								reserved;
	BluetoothClassOfDevice				classOfDevice;
	BluetoothClockOffset				clockOffset;
	BluetoothHCIRSSIValue				RSSIValue;
};

typedef struct	BluetoothHCIInquiryWithRSSIResults	BluetoothHCIInquiryWithRSSIResults;
struct	BluetoothHCIInquiryWithRSSIResults
{
	BluetoothHCIInquiryWithRSSIResult	results[50];
	IOItemCount							count;
};

//Inquiries with 'Extended Inquiry Response' (v2.1 specification)

typedef uint8_t	BluetoothHCIFECRequired;
enum BluetoothHCIFECRequiredValues
{
	kBluetoothHCIFECRequired		= 0x00,
	kBluetoothHCIFECNotRequired		= 0x01
};

typedef	uint8_t	BluetoothHCIInquiryMode;
enum BluetoothHCIInquiryModes
{
	kBluetoothHCIInquiryModeResultFormatStandard								=	0x00,
	kBluetoothHCIInquiryModeResultFormatWithRSSI								=	0x01,
	kBluetoothHCIInquiryModeResultFormatWithRSSIOrExtendedInquiryResultFormat	=	0x02
};

typedef uint8_t	BluetoothHCIInquiryScanType;
enum BluetoothHCIInquiryScanTypes
{
	kBluetoothHCIInquiryScanTypeStandard		= 0x00,
	kBluetoothHCIInquiryScanTypeInterlaced		= 0x01,
	
	kBluetoothHCIInquiryScanTypeReservedStart	= 0x02,
	kBluetoothHCIInquiryScanTypeReservedEnd		= 0xFF
};						

typedef	uint8_t	BluetoothHCIExtendedInquiryResponseDataType;

typedef struct	BluetoothHCIExtendedInquiryResponse		BluetoothHCIExtendedInquiryResponse;	/* Extended Inquiry Response [EIR] data, consisting of a sequence of data structures in this format: [length(1byte)][data type(1byte)][data(e.g. device name)] */
struct	BluetoothHCIExtendedInquiryResponse
{
	uint8_t		data[ 240 ];
};

typedef struct	BluetoothHCIReadExtendedInquiryResponseResults	BluetoothHCIReadExtendedInquiryResponseResults;
struct	BluetoothHCIReadExtendedInquiryResponseResults
{
	BluetoothHCIFECRequired					outFECRequired;
	BluetoothHCIExtendedInquiryResponse		extendedInquiryResponse;
};

typedef struct	BluetoothHCIExtendedInquiryResult	BluetoothHCIExtendedInquiryResult;
struct	BluetoothHCIExtendedInquiryResult
{
	uint8_t								numberOfReponses;			/* always a value of 1 */
	BluetoothDeviceAddress				deviceAddress;
	BluetoothPageScanRepetitionMode		pageScanRepetitionMode;
	uint8_t								reserved;
	BluetoothClassOfDevice				classOfDevice;
	BluetoothClockOffset				clockOffset;
	BluetoothHCIRSSIValue				RSSIValue;
	BluetoothHCIExtendedInquiryResponse	extendedInquiryResponse;
};

typedef struct BluetoothHCIReadLMPHandleResults	BluetoothHCIReadLMPHandleResults;
struct BluetoothHCIReadLMPHandleResults
{
	BluetoothConnectionHandle		handle;
	BluetoothLMPHandle				lmp_handle;
	uint32_t						reserved;
};		
						
// 'Simple Pairing' (v2.1 specification)

typedef	uint8_t	BluetoothHCISimplePairingMode;
enum BluetoothHCISimplePairingModes
{
	kBluetoothHCISimplePairingModeNotSet									=	0x00,
	kBluetoothHCISimplePairingModeEnabled									=	0x01
};

typedef	uint8_t	BluetoothSimplePairingDebugMode;
enum BluetoothSimplePairingDebugModes
{
	kBluetoothHCISimplePairingDebugModeDisabled								=	0x00,
	kBluetoothHCISimplePairingDebugModeEnabled								=	0x01
};

typedef struct	BluetoothHCISimplePairingOOBData		BluetoothHCISimplePairingOOBData;
struct BluetoothHCISimplePairingOOBData
{
	uint8_t		data[ 16 ];
};

typedef struct BluetoothHCIReadLocalOOBDataResults BluetoothHCIReadLocalOOBDataResults;
struct	BluetoothHCIReadLocalOOBDataResults
{
	BluetoothHCISimplePairingOOBData		hash;
	BluetoothHCISimplePairingOOBData		randomizer;
};

typedef uint8_t	BluetoothIOCapability;
enum BluetoothIOCapabilities
{
	kBluetoothCapabilityTypeDisplayOnly			= 0x00,
	kBluetoothCapabilityTypeDisplayYesNo		= 0x01,
	kBluetoothCapabilityTypeKeyboardOnly		= 0x02,
	kBluetoothCapabilityTypeNoInputNoOutput		= 0x03
};

typedef uint8_t	BluetoothOOBDataPresence;
enum BluetoothOOBDataPresenceValues
{
	kBluetoothOOBAuthenticationDataNotPresent				= 0x00,
	kBluetoothOOBAuthenticationDataFromRemoteDevicePresent	= 0x01
};

typedef uint8_t	BluetoothAuthenticationRequirements;
enum BluetoothAuthenticationRequirementsValues
{
	kBluetoothAuthenticationRequirementsMITMProtectionNotRequired					= 0x00,		/* Numeric comparison with automatic accept allowed */
	kBluetoothAuthenticationRequirementsMITMProtectionRequired						= 0x01,		/* Refer to BluetoothIOCapabilities to determine authentication procedure */
	kBluetoothAuthenticationRequirementsMITMProtectionNotRequiredNoBonding			= 0x00,
	kBluetoothAuthenticationRequirementsMITMProtectionRequiredNoBonding				= 0x01,
	kBluetoothAuthenticationRequirementsMITMProtectionNotRequiredDedicatedBonding	= 0x02,
	kBluetoothAuthenticationRequirementsMITMProtectionRequiredDedicatedBonding		= 0x03,
	kBluetoothAuthenticationRequirementsMITMProtectionNotRequiredGeneralBonding		= 0x04,
	kBluetoothAuthenticationRequirementsMITMProtectionRequiredGeneralBonding		= 0x05
};

typedef struct BluetoothIOCapabilityResponse	BluetoothIOCapabilityResponse;
struct BluetoothIOCapabilityResponse
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothIOCapability				ioCapability;				/* possible values from BluetoothIOCapabilities above */
	BluetoothOOBDataPresence			OOBDataPresence;				
	BluetoothAuthenticationRequirements	authenticationRequirements;
};

typedef uint32_t	BluetoothPasskey;

typedef struct BluetoothUserPasskeyNotification	BluetoothUserPasskeyNotification;
struct BluetoothUserPasskeyNotification
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothPasskey					passkey;				/* passkey for display. valid values are 000000 - 999999 */
};

typedef uint8_t	BluetoothKeypressNotificationType;
enum BluetoothKeypressNotificationTypes
{
	kBluetoothKeypressNotificationTypePasskeyEntryStarted		= 0,
	kBluetoothKeypressNotificationTypePasskeyDigitEntered		= 1,
	kBluetoothKeypressNotificationTypePasskeyDigitErased		= 2,
	kBluetoothKeypressNotificationTypePasskeyCleared			= 3,
	kBluetoothKeypressNotificationTypePasskeyEntryCompleted		= 4
};
		
typedef struct BluetoothKeypressNotification	BluetoothKeypressNotification;
struct BluetoothKeypressNotification
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothKeypressNotificationType	notificationType;
};
		
typedef struct BluetoothRemoteHostSupportedFeaturesNotification	BluetoothRemoteHostSupportedFeaturesNotification;
struct BluetoothRemoteHostSupportedFeaturesNotification
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothHCISupportedFeatures		hostSupportedFeatures;
};		
		
typedef SInt8	TransmissionPower;

typedef struct BluetoothAFHHostChannelClassification	BluetoothAFHHostChannelClassification;
struct BluetoothAFHHostChannelClassification
{
	uint8_t		data[ 10 ];			/* 79 bits meaningful */
};

typedef uint8_t	BluetoothAFHMode;
typedef struct	BluetoothAFHResults					BluetoothAFHResults;
struct BluetoothAFHResults
{
	BluetoothConnectionHandle	handle;
	BluetoothAFHMode			mode;
	uint8_t						afhMap[10];
};

typedef uint32_t	BluetoothNumericValue;

typedef struct BluetoothUserConfirmationRequest	BluetoothUserConfirmationRequest;
struct BluetoothUserConfirmationRequest
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothNumericValue				numericValue;				/* numeric value for display. valid values are 000000 - 999999 */
};

typedef struct	BluetoothHCIEventSimplePairingCompleteResults 		BluetoothHCIEventSimplePairingCompleteResults;
struct			BluetoothHCIEventSimplePairingCompleteResults
{
	BluetoothDeviceAddress						deviceAddress;
};


// Packet Sizes

enum
{
	kBluetoothHCICommandPacketHeaderSize 	= 3, 
	kBluetoothHCICommandPacketMaxDataSize 	= 255, 
	kBluetoothHCIMaxCommandPacketSize		= kBluetoothHCICommandPacketHeaderSize + kBluetoothHCICommandPacketMaxDataSize, 
	
	kBluetoothHCIEventPacketHeaderSize	 	= 2, 
	kBluetoothHCIEventPacketMaxDataSize 	= 255, 
	kBluetoothHCIMaxEventPacketSize			= kBluetoothHCIEventPacketHeaderSize + kBluetoothHCIEventPacketMaxDataSize, 
	
	kBluetoothHCIDataPacketHeaderSize 		= 4, 
	kBluetoothHCIDataPacketMaxDataSize 		= 65535, 
	kBluetoothHCIMaxDataPacketSize			= kBluetoothHCIDataPacketHeaderSize + kBluetoothHCIDataPacketMaxDataSize
};

typedef uint8_t		BluetoothHCIEventCode;
typedef uint8_t		BluetoothLinkType;
enum BluetoothLinkTypes
{
	kBluetoothSCOConnection		= 0,
	kBluetoothACLConnection		= 1,
	kBluetoothESCOConnection	= 2,
    kBluetoothLinkTypeNone		= 0xff
};

typedef uint16_t		BluetoothHCIContentFormat; // 10 bits meaningful

typedef uint16_t		BluetoothHCIVoiceSetting; // 10 bits meaningful
enum
{
	// Input Coding
	kBluetoothVoiceSettingInputCodingMask					= 0x300,
	kBluetoothVoiceSettingInputCodingLinearInputCoding		= 0x000,
	kBluetoothVoiceSettingInputCodingULawInputCoding		= 0x100,
	kBluetoothVoiceSettingInputCodingALawInputCoding		= 0x200,
};

enum
{
	// Input Data Format
	kBluetoothVoiceSettingInputDataFormatMask				= 0x0C0,
	kBluetoothVoiceSettingInputDataFormat1sComplement		= 0x000,
	kBluetoothVoiceSettingInputDataFormat2sComplement		= 0x040,
	kBluetoothVoiceSettingInputDataFormatSignMagnitude		= 0x080,
	kBluetoothVoiceSettingInputDataFormatUnsigned			= 0x0C0,
};

enum
{
	// Input Sample Size
	kBluetoothVoiceSettingInputSampleSizeMask				= 0x020,
	kBluetoothVoiceSettingInputSampleSize8Bit				= 0x000,
	kBluetoothVoiceSettingInputSampleSize16Bit				= 0x020,
};

enum
{
	// Linear PCM Bit Position
	kBluetoothVoiceSettingPCMBitPositionMask				= 0x01C,
};

enum
{
	// Air Coding Format
	kBluetoothVoiceSettingAirCodingFormatMask				= 0x003,
	kBluetoothVoiceSettingAirCodingFormatCVSD				= 0x000,
	kBluetoothVoiceSettingAirCodingFormatULaw				= 0x001,
	kBluetoothVoiceSettingAirCodingFormatALaw				= 0x002,
	kBluetoothVoiceSettingAirCodingFormatTransparentData	= 0x003,
};

typedef uint8_t		BluetoothHCISupportedIAC;
typedef uint32_t	BluetoothHCITransmitBandwidth;
typedef uint32_t	BluetoothHCIReceiveBandwidth;
typedef uint16_t	BluetoothHCIMaxLatency;
typedef uint8_t		BluetoothHCIRetransmissionEffort;		
enum BluetoothHCIRetransmissionEffortTypes
{
	kHCIRetransmissionEffortTypeNone								= 0x00,
	kHCIRetransmissionEffortTypeAtLeastOneAndOptimizeForPower		= 0x01,
	kHCIRetransmissionEffortTypeAtLeastOneAndOptimizeLinkQuality	= 0x02,
	kHCIRetransmissionEffortTypeDontCare							= 0xFF,
};
		

// Setup Synchronous Packet types (Bluetooth 2.1 spec section 7.7.35  - Setup Synchronous Command Complete Event)

typedef uint8_t		BluetoothAirMode;
enum
{
	kBluetoothAirModeULawLog				= 0x00,
	kBluetoothAirModeALawLog				= 0x01,
	kBluetoothAirModeCVSD					= 0x02,
	kBluetoothAirModeTransparentData		= 0x03
};

typedef struct	BluetoothSynchronousConnectionInfo		BluetoothSynchronousConnectionInfo;
struct	BluetoothSynchronousConnectionInfo
{
	BluetoothHCITransmitBandwidth		transmitBandWidth;
	BluetoothHCIReceiveBandwidth		receiveBandWidth;
	BluetoothHCIMaxLatency				maxLatency;
	BluetoothHCIVoiceSetting			voiceSetting;
	BluetoothHCIRetransmissionEffort	retransmissionEffort;
	BluetoothPacketType					packetType;
};

typedef struct	BluetoothHCIEventSynchronousConnectionCompleteResults 	BluetoothHCIEventSynchronousConnectionCompleteResults;
struct			BluetoothHCIEventSynchronousConnectionCompleteResults
{
	BluetoothConnectionHandle			connectionHandle;
	BluetoothDeviceAddress				deviceAddress;
	BluetoothLinkType					linkType;
	uint8_t								transmissionInterval;
	uint8_t								retransmissionWindow;
	uint16_t							receivePacketLength;
	uint16_t							transmitPacketLength;
	BluetoothAirMode					airMode;
};

typedef struct	BluetoothHCIEventSynchronousConnectionChangedResults 	BluetoothHCIEventSynchronousConnectionChangedResults;
struct			BluetoothHCIEventSynchronousConnectionChangedResults
{
	BluetoothConnectionHandle			connectionHandle;
	uint8_t								transmissionInterval;
	uint8_t								retransmissionWindow;
	uint16_t							receivePacketLength;
	uint16_t							transmitPacketLength;
};

typedef uint8_t	BluetoothHCIStatus;
typedef uint8_t	BluetoothHCIEventStatus;

// Events.

enum
{
	kBluetoothHCIEventInquiryComplete									= 0x01,
	kBluetoothHCIEventInquiryResult										= 0x02,
	kBluetoothHCIEventConnectionComplete								= 0x03,
	kBluetoothHCIEventConnectionRequest									= 0x04,
	kBluetoothHCIEventDisconnectionComplete								= 0x05,
	kBluetoothHCIEventAuthenticationComplete							= 0x06,
	kBluetoothHCIEventRemoteNameRequestComplete							= 0x07,
	kBluetoothHCIEventEncryptionChange									= 0x08,
	kBluetoothHCIEventChangeConnectionLinkKeyComplete					= 0x09,
	kBluetoothHCIEventMasterLinkKeyComplete								= 0x0A,
	kBluetoothHCIEventReadRemoteSupportedFeaturesComplete				= 0x0B,
	kBluetoothHCIEventReadRemoteVersionInformationComplete				= 0x0C,
	kBluetoothHCIEventQoSSetupComplete									= 0x0D,
	kBluetoothHCIEventCommandComplete									= 0x0E,
	kBluetoothHCIEventCommandStatus										= 0x0F,
	kBluetoothHCIEventHardwareError										= 0x10,
	kBluetoothHCIEventFlushOccurred										= 0x11,
	kBluetoothHCIEventRoleChange										= 0x12,
	kBluetoothHCIEventNumberOfCompletedPackets							= 0x13,
	kBluetoothHCIEventModeChange										= 0x14,
	kBluetoothHCIEventReturnLinkKeys									= 0x15,
	kBluetoothHCIEventPINCodeRequest									= 0x16,
	kBluetoothHCIEventLinkKeyRequest									= 0x17,
	kBluetoothHCIEventLinkKeyNotification								= 0x18,
	kBluetoothHCIEventLoopbackCommand									= 0x19,
	kBluetoothHCIEventDataBufferOverflow								= 0x1A,
	kBluetoothHCIEventMaxSlotsChange									= 0x1B,
	kBluetoothHCIEventReadClockOffsetComplete							= 0x1C,
	kBluetoothHCIEventConnectionPacketType								= 0x1D,
	kBluetoothHCIEventQoSViolation										= 0x1E,
	kBluetoothHCIEventPageScanModeChange								= 0x1F,	// DEPRECATED
	kBluetoothHCIEventPageScanRepetitionModeChange						= 0x20,
	
	// [v1.2]

	kBluetoothHCIEventFlowSpecificationComplete							= 0x21,
	kBluetoothHCIEventInquiryResultWithRSSI								= 0x22,
	kBluetoothHCIEventReadRemoteExtendedFeaturesComplete				= 0x23,
	kBluetoothHCIEventSynchronousConnectionComplete						= 0x2C,
	kBluetoothHCIEventSynchronousConnectionChanged						= 0x2D,

	// [v2.1]

	kBluetoothHCIEventSniffSubrating									= 0x2E,
	kBluetoothHCIEventExtendedInquiryResult								= 0x2F,
	kBluetoothHCIEventEncryptionKeyRefreshComplete						= 0x30,
	kBluetoothHCIEventIOCapabilityRequest								= 0x31,
	kBluetoothHCIEventIOCapabilityResponse								= 0x32,
	kBluetoothHCIEventUserConfirmationRequest							= 0x33,
	kBluetoothHCIEventUserPasskeyRequest								= 0x34,
	kBluetoothHCIEventRemoteOOBDataRequest								= 0x35,
	kBluetoothHCIEventSimplePairingComplete								= 0x36,
	kBluetoothHCIEventLinkSupervisionTimeoutChanged						= 0x38,
	kBluetoothHCIEventEnhancedFlushComplete								= 0x39,
	kBluetoothHCIEventUserPasskeyNotification							= 0x3B,
	kBluetoothHCIEventKeypressNotification								= 0x3C,
	kBluetoothHCIEventRemoteHostSupportedFeaturesNotification			= 0x3D,
	
	// [v4.0] (All LE Events come through this event, and the first following byte is the subevent
	
	kBluetoothHCIEventLEMetaEvent										= 0x3E,
		kBluetoothHCISubEventLEConnectionComplete						= 0x01,
		kBluetoothHCISubEventLEAdvertisingReport						= 0x02,
		kBluetoothHCISubEventLEConnectionUpdateComplete					= 0x03,
		kBluetoothHCISubEventLEReadRemoteUsedFeaturesComplete			= 0x04,
		kBluetoothHCISubEventLELongTermKeyRequest						= 0x05,
	
	// [v3.0]
	
	kBluetoothHCIEventPhysicalLinkComplete								= 0x40,
	kBluetoothHCIEventChannelSelected									= 0x41,
	kBluetoothHCIEventDisconnectionPhysicalLinkComplete					= 0x42,
	kBluetoothHCIEventPhysicalLinkLossEarlyWarning						= 0x43,
	kBluetoothHCIEventPhysicalLinkRecovery								= 0x44,
	kBluetoothHCIEventLogicalLinkComplete								= 0x45,
	kBluetoothHCIEventDisconnectionLogicalLinkComplete					= 0x46,
	kBluetoothHCIEventFlowSpecModifyComplete							= 0x47,
	kBluetoothHCIEventNumberOfCompletedDataBlocks						= 0x48,
	kBluetoothHCIEventShortRangeModeChangeComplete						= 0x4C,
	kBluetoothHCIEventAMPStatusChange									= 0x4D,
	kBluetoothHCIEventAMPStartTest										= 0x49,
	kBluetoothHCIEventAMPTestEnd										= 0x4A,
	kBluetoothHCIEventAMPReceiverReport									= 0x4B,
	
	
	kBluetoothHCIEventLogoTesting										= 0xFE,
	kBluetoothHCIEventVendorSpecific									= 0xFF
};

// HCI Event Masks

// Event masks are 8 octets according to the spec. v2.1 introduces some event masks that
// actually exceed 32 bits so the 4 byte enum we had before Bluetooth 2.0 will still work for old
// the masks, but the new masks need to be defined as 64 bits.

typedef uint64_t	BluetoothHCIEventMask;

#define kBluetoothHCIEventMaskLEDefault64Bit									0x000000000000001FLL
#define	kBluetoothHCIEventMaskDefault64Bit										0x00001FFFFFFFFFFFLL
#define	kBluetoothHCIEventMaskAll64Bit											0xFFFFFFFFFFFFFFFFLL

	// [v1.2]

#define	kBluetoothHCIEventMaskFlowSpecificationCompleteEvent					0x0000000100000000LL
#define	kBluetoothHCIEventMaskInquiryResultWithRSSIEvent						0x0000000200000000LL
#define	kBluetoothHCIEventMaskReadRemoteExtendedFeaturesCompleteEvent			0x0000000400000000LL
#define	kBluetoothHCIEventMaskSynchronousConnectionCompleteEvent				0x0000080000000000LL
#define	kBluetoothHCIEventMaskSynchronousConnectionChangedEvent					0x0000100000000000LL

	// [v2.1]

#define	kBluetoothHCIEventMaskSniffSubratingEvent								0x0000200000000000LL
#define	kBluetoothHCIEventMaskExtendedInquiryResultEvent						0x0000400000000000LL
#define kBluetoothHCIEventMaskEncryptionChangeEvent								0x0000000000000080LL
#define kBluetoothHCIEventMaskEncryptionKeyRefreshCompleteEvent					0x0000800000000000LL
#define	kBluetoothHCIEventMaskLinkSupervisionTimeoutChangedEvent				0x0080000000000000LL
#define	kBluetoothHCIEventMaskEnhancedFlushCompleteEvent						0x0100000000000000LL
	
	// [v2.1 Secure Simple Pairing]

#define	kBluetoothHCIEventMaskIOCapabilityRequestEvent							0x0001000000000000LL
#define	kBluetoothHCIEventMaskIOCapabilityRequestReplyEvent						0x0002000000000000LL
#define	kBluetoothHCIEventMaskUserConfirmationRequestEvent						0x0004000000000000LL
#define	kBluetoothHCIEventMaskUserPasskeyRequestEvent							0x0008000000000000LL
#define	kBluetoothHCIEventMaskRemoteOOBDataRequestEvent							0x0010000000000000LL
#define	kBluetoothHCIEventMaskSimplePairingCompleteEvent						0x0020000000000000LL
#define kBluetoothHCIEvnetMaskLinkSupervisionTimeoutChangedEvent				0x0080000000000000LL
#define kBluetoothHCIEvnetMaskEnhancedFlushCompleteEvent						0x0100000000000000LL
#define	kBluetoothHCIEventMaskUserPasskeyNotificationEvent						0x0400000000000000LL
#define	kBluetoothHCIEventMaskKeypressNotificationEvent							0x0800000000000000LL
#define	kBluetoothHCIEventMaskRemoteHostSupportedFeaturesNotificationEvent		0x1000000000000000LL
#define	kBluetoothHCIEventMaskLEMetaEvent										0x2000000000000000LL
	
enum
{
	kBluetoothHCIEventMaskNone											= 0x00000000, 
	kBluetoothHCIEventMaskInquiryComplete								= 0x00000001, 
	kBluetoothHCIEventMaskInquiryResult									= 0x00000002, 
	kBluetoothHCIEventMaskConnectionComplete							= 0x00000004, 
	kBluetoothHCIEventMaskConnectionRequest								= 0x00000008, 
	kBluetoothHCIEventMaskDisconnectionComplete							= 0x00000010, 
	kBluetoothHCIEventMaskAuthenticationComplete						= 0x00000020, 
	kBluetoothHCIEventMaskRemoteNameRequestComplete						= 0x00000040, 
	kBluetoothHCIEventMaskEncryptionChange								= 0x00000080, 
	kBluetoothHCIEventMaskChangeConnectionLinkKeyComplete				= 0x00000100, 
	kBluetoothHCIEventMaskMasterLinkKeyComplete							= 0x00000200, 
	kBluetoothHCIEventMaskReadRemoteSupportedFeaturesComplete			= 0x00000400, 
	kBluetoothHCIEventMaskReadRemoteVersionInformationComplete			= 0x00000800, 
	kBluetoothHCIEventMaskQoSSetupComplete								= 0x00001000, 
	kBluetoothHCIEventMaskCommandComplete								= 0x00002000, 
	kBluetoothHCIEventMaskCommandStatus									= 0x00004000, 
	kBluetoothHCIEventMaskHardwareError									= 0x00008000, 
	kBluetoothHCIEventMaskFlushOccurred									= 0x00010000, 
	kBluetoothHCIEventMaskRoleChange									= 0x00020000, 
	
	kBluetoothHCIEventMaskNumberOfCompletedPackets						= 0x00040000, 
	kBluetoothHCIEventMaskModeChange									= 0x00080000, 
	kBluetoothHCIEventMaskReturnLinkKeys								= 0x00100000, 
	kBluetoothHCIEventMaskPINCodeRequest								= 0x00200000, 
	kBluetoothHCIEventMaskLinkKeyRequest								= 0x00400000, 
	kBluetoothHCIEventMaskLinkKeyNotification							= 0x00800000, 
	kBluetoothHCIEventMaskLoopbackCommand								= 0x01000000, 
	kBluetoothHCIEventMaskDataBufferOverflow							= 0x02000000, 
	kBluetoothHCIEventMaskMaxSlotsChange								= 0x04000000, 
	kBluetoothHCIEventMaskReadClockOffsetComplete						= 0x08000000, 
	kBluetoothHCIEventMaskConnectionPacketTypeChanged					= 0x10000000, 
	kBluetoothHCIEventMaskQoSViolation									= 0x20000000, 
	kBluetoothHCIEventMaskPageScanModeChange							= 0x40000000, 
	kBluetoothHCIEventMaskPageScanRepetitionModeChange					= 0x80000000, 
	
	kBluetoothHCIEventMaskAll											= 0xFFFFFFFF, 
	kBluetoothHCIEventMaskDefault										= kBluetoothHCIEventMaskAll		/* Use kBluetoothHCIEventMaskDefault64Bit above! */
};

// Event results structures.

typedef struct	BluetoothHCIEventConnectionCompleteResults		BluetoothHCIEventConnectionCompleteResults;
struct			BluetoothHCIEventConnectionCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothDeviceAddress						deviceAddress;
	BluetoothLinkType							linkType;
	BluetoothHCIEncryptionMode					encryptionMode;
};

typedef struct	BluetoothHCIEventLEConnectionCompleteResults		BluetoothHCIEventLEConnectionCompleteResults;
struct			BluetoothHCIEventLEConnectionCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
	uint8_t										role;
	uint8_t										peerAddressType;
	BluetoothDeviceAddress						peerAddress;
	uint16_t									connInterval;
	uint16_t									connLatency;
	uint16_t									supervisionTimeout;
	uint8_t										masterClockAccuracy;
} __attribute__((packed));		
	
typedef struct	BluetoothHCIEventLEConnectionUpdateCompleteResults		BluetoothHCIEventLEConnectionUpdateCompleteResults;
struct			BluetoothHCIEventLEConnectionUpdateCompleteResults
{
    BluetoothConnectionHandle					connectionHandle;
    uint16_t									connInterval;
    uint16_t									connLatency;
    uint16_t									supervisionTimeout;
} __attribute__((packed));
        
typedef struct	BluetoothHCIEventDisconnectionCompleteResults		BluetoothHCIEventDisconnectionCompleteResults;
struct			BluetoothHCIEventDisconnectionCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothReasonCode							reason;
};

typedef struct	BluetoothHCIEventReadSupportedFeaturesResults 	BluetoothHCIEventReadSupportedFeaturesResults;
struct 			BluetoothHCIEventReadSupportedFeaturesResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCISupportedFeatures				supportedFeatures;
};

typedef struct	BluetoothHCIEventReadExtendedFeaturesResults 	BluetoothHCIEventReadExtendedFeaturesResults;
struct 			BluetoothHCIEventReadExtendedFeaturesResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCIExtendedFeaturesInfo			supportedFeaturesInfo;
};
		
typedef struct	BluetoothHCIEventReadRemoteVersionInfoResults 	BluetoothHCIEventReadRemoteVersionInfoResults;
struct 			BluetoothHCIEventReadRemoteVersionInfoResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothLMPVersion							lmpVersion;
	BluetoothManufacturerName					manufacturerName;
	BluetoothLMPSubversion						lmpSubversion;
};

typedef struct	BluetoothHCIEventRemoteNameRequestResults 		BluetoothHCIEventRemoteNameRequestResults;
struct 			BluetoothHCIEventRemoteNameRequestResults
{
	BluetoothDeviceAddress						deviceAddress;
	BluetoothDeviceName							deviceName;
};

typedef struct	BluetoothHCIEventReadClockOffsetResults 		BluetoothHCIEventReadClockOffsetResults;
struct			BluetoothHCIEventReadClockOffsetResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothClockOffset						clockOffset;
};

typedef struct	BluetoothHCIEventConnectionRequestResults 		BluetoothHCIEventConnectionRequestResults;
struct			BluetoothHCIEventConnectionRequestResults
{
	BluetoothDeviceAddress						deviceAddress;
	BluetoothClassOfDevice						classOfDevice;
	BluetoothLinkType							linkType;
};

typedef struct	BluetoothHCIEventLinkKeyNotificationResults 		BluetoothHCIEventLinkKeyNotificationResults;
struct			BluetoothHCIEventLinkKeyNotificationResults
{
	BluetoothDeviceAddress						deviceAddress;
	BluetoothKey								linkKey;
	BluetoothKeyType							keyType;
};

typedef struct	BluetoothHCIEventMaxSlotsChangeResults 		BluetoothHCIEventMaxSlotsChangeResults;
struct			BluetoothHCIEventMaxSlotsChangeResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothMaxSlots							maxSlots;
};

typedef struct	BluetoothHCIEventModeChangeResults 		BluetoothHCIEventModeChangeResults;
struct			BluetoothHCIEventModeChangeResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCIConnectionMode					mode;
	BluetoothHCIModeInterval					modeInterval;
};

typedef struct	BluetoothHCIEventReturnLinkKeysResults	BluetoothHCIEventReturnLinkKeysResults;
struct			BluetoothHCIEventReturnLinkKeysResults
{
	uint8_t										numLinkKeys;
	struct {
		BluetoothDeviceAddress					deviceAddress;
		BluetoothKey							linkKey;
	} linkKeys[1];
};

typedef struct	BluetoothHCIEventAuthenticationCompleteResults 		BluetoothHCIEventAuthenticationCompleteResults;
struct			BluetoothHCIEventAuthenticationCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
};

typedef struct	BluetoothHCIEventEncryptionChangeResults 		BluetoothHCIEventEncryptionChangeResults;
struct			BluetoothHCIEventEncryptionChangeResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothEncryptionEnable					enable;
};

typedef struct	BluetoothHCIEventChangeConnectionLinkKeyCompleteResults 	BluetoothHCIEventChangeConnectionLinkKeyCompleteResults;
struct			BluetoothHCIEventChangeConnectionLinkKeyCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
};

typedef struct	BluetoothHCIEventMasterLinkKeyCompleteResults 	BluetoothHCIEventMasterLinkKeyCompleteResults;
struct			BluetoothHCIEventMasterLinkKeyCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothKeyFlag							keyFlag;
};

typedef struct	BluetoothHCIEventQoSSetupCompleteResults 	BluetoothHCIEventQoSSetupCompleteResults;
struct			BluetoothHCIEventQoSSetupCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCIQualityOfServiceSetupParams		setupParams;
};

typedef struct	BluetoothHCIEventHardwareErrorResults 	BluetoothHCIEventHardwareErrorResults;
struct			BluetoothHCIEventHardwareErrorResults
{
	BluetoothHCIStatus							error;
};

typedef struct	BluetoothHCIEventFlushOccurredResults 	BluetoothHCIEventFlushOccurredResults;
struct			BluetoothHCIEventFlushOccurredResults
{
	BluetoothConnectionHandle					connectionHandle;
};

typedef struct	BluetoothHCIEventRoleChangeResults 	BluetoothHCIEventRoleChangeResults;
struct			BluetoothHCIEventRoleChangeResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothDeviceAddress						deviceAddress;
	BluetoothRole								role;
};

typedef struct	BluetoothHCIEventDataBufferOverflowResults 	BluetoothHCIEventDataBufferOverflowResults;
struct			BluetoothHCIEventDataBufferOverflowResults
{
	BluetoothLinkType							linkType;
};

typedef struct	BluetoothHCIEventConnectionPacketTypeResults 	BluetoothHCIEventConnectionPacketTypeResults;
struct			BluetoothHCIEventConnectionPacketTypeResults
{
	BluetoothConnectionHandle					connectionHandle;
	BluetoothPacketType							packetType;
};

typedef struct	BluetoothHCIEventReadRemoteSupportedFeaturesResults 	BluetoothHCIEventReadRemoteSupportedFeaturesResults;
struct			BluetoothHCIEventReadRemoteSupportedFeaturesResults
{
	BluetoothHCIStatus							error;
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCISupportedFeatures				lmpFeatures;
};

typedef struct	BluetoothHCIEventReadRemoteExtendedFeaturesResults 	BluetoothHCIEventReadRemoteExtendedFeaturesResults;
struct			BluetoothHCIEventReadRemoteExtendedFeaturesResults
{
	BluetoothHCIStatus							error;
	BluetoothConnectionHandle					connectionHandle;
	BluetoothHCIPageNumber						page;
	BluetoothHCIPageNumber						maxPage;
	BluetoothHCISupportedFeatures				lmpFeatures;
};

typedef struct	BluetoothHCIEventQoSViolationResults 	BluetoothHCIEventQoSViolationResults;
struct			BluetoothHCIEventQoSViolationResults
{
	BluetoothConnectionHandle					connectionHandle;
};

typedef struct	BluetoothHCIEventPageScanModeChangeResults 	BluetoothHCIEventPageScanModeChangeResults;
struct			BluetoothHCIEventPageScanModeChangeResults
{
	BluetoothDeviceAddress			deviceAddress;
	BluetoothPageScanMode			pageScanMode;
};

typedef struct	BluetoothHCIEventPageScanRepetitionModeChangeResults 	BluetoothHCIEventPageScanRepetitionModeChangeResults;
struct			BluetoothHCIEventPageScanRepetitionModeChangeResults
{
	BluetoothDeviceAddress				deviceAddress;
	BluetoothPageScanRepetitionMode		pageScanRepetitionMode;
};

typedef struct	BluetoothHCIEventVendorSpecificResults 	BluetoothHCIEventVendorSpecificResults;
struct			BluetoothHCIEventVendorSpecificResults
{
	uint8_t								length;
	uint8_t								data[255];
};

typedef struct	BluetoothHCIEventEncryptionKeyRefreshCompleteResults		BluetoothHCIEventEncryptionKeyRefreshCompleteResults;
struct			BluetoothHCIEventEncryptionKeyRefreshCompleteResults
{
	BluetoothConnectionHandle					connectionHandle;
};

typedef struct BluetoothHCIEventSniffSubratingResults BluetoothHCIEventSniffSubratingResults;
struct BluetoothHCIEventSniffSubratingResults
{
	BluetoothConnectionHandle			connectionHandle;
	uint16_t							maxTransmitLatency;
	uint16_t							maxReceiveLatency;
	uint16_t							minRemoteTimeout;
	uint16_t							minLocalTimeout;			
};
	
// LE Meta Events	
typedef struct BluetoothHCIEventLEMetaResults BluetoothHCIEventLEMetaResults;
struct BluetoothHCIEventLEMetaResults
{
	uint8_t		length;
	uint8_t		data[255];
};
		
typedef struct BluetoothHCIEventLELongTermKeyRequestResults BluetoothHCIEventLELongTermKeyRequestResults;
struct BluetoothHCIEventLELongTermKeyRequestResults
{
	BluetoothConnectionHandle	connectionHandle;
	uint8_t						randomNumber[8];
	uint16_t					ediv;	
};
		
#define kNoNotifyProc	NULL
#define kNoUserRefCon	NULL

typedef struct BluetoothHCIRequestCallbackInfo BluetoothHCIRequestCallbackInfo;
struct BluetoothHCIRequestCallbackInfo
{
	mach_vm_address_t					userCallback;			// Proc to call when async handler is called.
	mach_vm_address_t					userRefCon;				// For user's info.
	mach_vm_address_t					internalRefCon;			// For our purposes.
	mach_vm_address_t 					asyncIDRefCon;			// For our aync calls.
	mach_vm_address_t					reserved;				// For the future. Currently Unused.
};

// Error codes

enum
{
	kBluetoothHCIErrorSuccess											= 0x00, 
	kBluetoothHCIErrorUnknownHCICommand									= 0x01, 
	kBluetoothHCIErrorNoConnection										= 0x02, 
	kBluetoothHCIErrorHardwareFailure									= 0x03, 
	kBluetoothHCIErrorPageTimeout										= 0x04, 
	kBluetoothHCIErrorAuthenticationFailure								= 0x05, 
	kBluetoothHCIErrorKeyMissing										= 0x06, 
	kBluetoothHCIErrorMemoryFull										= 0x07, 
	kBluetoothHCIErrorConnectionTimeout									= 0x08, 
	kBluetoothHCIErrorMaxNumberOfConnections							= 0x09, 
	kBluetoothHCIErrorMaxNumberOfSCOConnectionsToADevice				= 0x0A, 
	kBluetoothHCIErrorACLConnectionAlreadyExists						= 0x0B, 
	kBluetoothHCIErrorCommandDisallowed									= 0x0C, 
	kBluetoothHCIErrorHostRejectedLimitedResources						= 0x0D, 
	kBluetoothHCIErrorHostRejectedSecurityReasons						= 0x0E, 
	kBluetoothHCIErrorHostRejectedRemoteDeviceIsPersonal				= 0x0F, 
	kBluetoothHCIErrorHostTimeout										= 0x10, 
	kBluetoothHCIErrorUnsupportedFeatureOrParameterValue				= 0x11, 
	kBluetoothHCIErrorInvalidHCICommandParameters						= 0x12, 
	kBluetoothHCIErrorOtherEndTerminatedConnectionUserEnded				= 0x13, 
	kBluetoothHCIErrorOtherEndTerminatedConnectionLowResources			= 0x14, 
	kBluetoothHCIErrorOtherEndTerminatedConnectionAboutToPowerOff		= 0x15, 
	kBluetoothHCIErrorConnectionTerminatedByLocalHost					= 0x16, 
	kBluetoothHCIErrorRepeatedAttempts									= 0x17, 
	kBluetoothHCIErrorPairingNotAllowed									= 0x18, 
	kBluetoothHCIErrorUnknownLMPPDU										= 0x19, 
	kBluetoothHCIErrorUnsupportedRemoteFeature							= 0x1A, 
	kBluetoothHCIErrorSCOOffsetRejected									= 0x1B, 
	kBluetoothHCIErrorSCOIntervalRejected								= 0x1C, 
	kBluetoothHCIErrorSCOAirModeRejected								= 0x1D, 
	kBluetoothHCIErrorInvalidLMPParameters								= 0x1E, 
	kBluetoothHCIErrorUnspecifiedError									= 0x1F, 
	kBluetoothHCIErrorUnsupportedLMPParameterValue						= 0x20, 
	kBluetoothHCIErrorRoleChangeNotAllowed								= 0x21, 
	kBluetoothHCIErrorLMPResponseTimeout								= 0x22, 
	kBluetoothHCIErrorLMPErrorTransactionCollision						= 0x23, 
	kBluetoothHCIErrorLMPPDUNotAllowed									= 0x24, 
	kBluetoothHCIErrorEncryptionModeNotAcceptable						= 0x25, 	// Added Core Spec, v1.1
	kBluetoothHCIErrorUnitKeyUsed										= 0x26, 	// 1.1
	kBluetoothHCIErrorQoSNotSupported									= 0x27, 	// 1.1
	kBluetoothHCIErrorInstantPassed										= 0x28, 	// 1.1
	kBluetoothHCIErrorPairingWithUnitKeyNotSupported					= 0x29, 	// 1.1
	kBluetoothHCIErrorHostRejectedUnacceptableDeviceAddress				= 0x0F,		// 2.0+
	kBluetoothHCIErrorDifferentTransactionCollision						= 0x2A, 	// 1.2
	kBluetoothHCIErrorQoSUnacceptableParameter							= 0x2C, 	// 1.2
	kBluetoothHCIErrorQoSRejected										= 0x2D, 	// 1.2
	kBluetoothHCIErrorChannelClassificationNotSupported					= 0x2E, 	// 1.2
	kBluetoothHCIErrorInsufficientSecurity								= 0x2F, 	// 1.2
	kBluetoothHCIErrorParameterOutOfMandatoryRange						= 0x30,		// 1.2
	kBluetoothHCIErrorRoleSwitchPending									= 0x31,		// 1.2
	kBluetoothHCIErrorReservedSlotViolation								= 0x34,		// 1.2
	kBluetoothHCIErrorRoleSwitchFailed									= 0x35,		// 1.2
	kBluetoothHCIErrorExtendedInquiryResponseTooLarge					= 0x36, 	// 2.1
	kBluetoothHCIErrorSecureSimplePairingNotSupportedByHost				= 0x37, 	// 2.1
	kBluetoothHCIErrorHostBusyPairing                                   = 0x38,
	kBluetoothHCIErrorConnectionRejectedDueToNoSuitableChannelFound		= 0x39,
	kBluetoothHCIErrorControllerBusy                                    = 0x3A,
	kBluetoothHCIErrorUnacceptableConnectionInterval                    = 0x3B,
	kBluetoothHCIErrorDirectedAdvertisingTimeout                        = 0x3C,
	kBluetoothHCIErrorConnectionTerminatedDueToMICFailure				= 0x3D,
	kBluetoothHCIErrorConnectionFailedToBeEstablished                   = 0x3E,
	kBluetoothHCIErrorMACConnectionFailed                               = 0x3F,
	
	kBluetoothHCIErrorMax												= 0x3F
};

#if 0
#pragma mark === HCI Power Mode ===
#endif

//===========================================================================================================================
//	HCI Power Mode 
//===========================================================================================================================

typedef enum
{
	kBluetoothHCIPowerStateON				= 0x01,
	kBluetoothHCIPowerStateOFF				= 0x00,
	kBluetoothHCIPowerStateUnintialized		= 0xFF,	
} BluetoothHCIPowerState;

enum
{
	kBluetoothHCIErrorPowerIsOFF			= (kBluetoothHCIErrorMax + 1)
};

#if 0
#pragma mark === HCI USB Transport ===
#endif

//===========================================================================================================================
//	HCI USB Transport
//===========================================================================================================================

//---------------------------------------------------------------------------------------------------------------------------
/*!	@enum		BluetoothHCIUSBDeviceMatchingConstants
	@abstract	Bluetooth USB device matching constants
	@constant	kBluetoothHCITransportUSBClassCode			Wireless Controller
	@constant	kBluetoothHCITransportUSBSubClassCode		RF Controller
	@constant	kBluetoothHCITransportUSBProtocolCode		Bluetooth Programming
*/

enum
{
	kBluetoothHCITransportUSBClassCode		= 0xE0,
	kBluetoothHCITransportUSBSubClassCode	= 0x01,
	kBluetoothHCITransportUSBProtocolCode	= 0x01
};

#if 0
#pragma mark === TCI - L2CAP ===
#endif

//===========================================================================================================================
//	TCI - L2CAP
//===========================================================================================================================

enum
{
	kBluetoothL2CAPTCIEventIDReserved							= 0x00,
	kBluetoothL2CAPTCIEventIDL2CA_ConnectInd					= 0x01,
	kBluetoothL2CAPTCIEventIDL2CA_ConfigInd						= 0x02,
	kBluetoothL2CAPTCIEventIDL2CA_DisconnectInd					= 0x03,
	kBluetoothL2CAPTCIEventIDL2CA_QoSViolationInd				= 0x04,
	kBluetoothL2CAPTCIEventIDL2CA_TimeOutInd					= 0x05
};

enum
{
	kBluetoothL2CAPTCICommandReserved							= 0x0000,
	kBluetoothL2CAPTCICommandL2CA_ConnectReq					= 0x0001,
	kBluetoothL2CAPTCICommandL2CA_DisconnectReq					= 0x0002,
	kBluetoothL2CAPTCICommandL2CA_ConfigReq						= 0x0003,
	kBluetoothL2CAPTCICommandL2CA_DisableCLT					= 0x0004,
	kBluetoothL2CAPTCICommandL2CA_EnableCLT						= 0x0005,
	kBluetoothL2CAPTCICommandL2CA_GroupCreate					= 0x0006,
	kBluetoothL2CAPTCICommandL2CA_GroupClose					= 0x0007,
	kBluetoothL2CAPTCICommandL2CA_GroupAddMember				= 0x0008,
	kBluetoothL2CAPTCICommandL2CA_GroupRemoveMember				= 0x0009,
	kBluetoothL2CAPTCICommandL2CA_GroupMembership				= 0x000A,
	kBluetoothL2CAPTCICommandL2CA_WriteData						= 0x000B,
	kBluetoothL2CAPTCICommandL2CA_ReadData						= 0x000C,
	kBluetoothL2CAPTCICommandL2CA_Ping							= 0x000D,
	kBluetoothL2CAPTCICommandL2CA_GetInfo						= 0x000E,
	kBluetoothL2CAPTCICommandL2CA_Reserved1						= 0x000F,
	kBluetoothL2CAPTCICommandL2CA_Reserved2						= 0x0010,
	kBluetoothL2CAPTCICommandL2CA_ConnectResp					= 0x0011,
	kBluetoothL2CAPTCICommandL2CA_DisconnectResp				= 0x0012,
	kBluetoothL2CAPTCICommandL2CA_ConfigResp					= 0x0013
};

#if 0
#pragma mark -
#pragma mark === RFCOMM ===
#endif

//===========================================================================================================================
//	RFCOMM
//===========================================================================================================================
#define kMaxChannelIDPerSide	31

typedef uint8_t	BluetoothRFCOMMChannelID;

#define	RFCOMM_CHANNEL_ID_IS_VALID( CHANNEL ) (( CHANNEL >= 1 ) && ( CHANNEL <= 30 ))

typedef uint16_t	BluetoothRFCOMMMTU;

typedef enum BluetoothRFCOMMParityType
{
    kBluetoothRFCOMMParityTypeNoParity = 0, 
    kBluetoothRFCOMMParityTypeOddParity, 
    kBluetoothRFCOMMParityTypeEvenParity, 
    kBluetoothRFCOMMParityTypeMaxParity
} BluetoothRFCOMMParityType;

typedef enum BluetoothRFCOMMLineStatus
{
    BluetoothRFCOMMLineStatusNoError = 0, 
    BluetoothRFCOMMLineStatusOverrunError, 
    BluetoothRFCOMMLineStatusParityError, 
    BluetoothRFCOMMLineStatusFramingError
} BluetoothRFCOMMLineStatus;

#if 0
#pragma mark -
#pragma mark === SDP ===
#endif

//===========================================================================================================================
//	SDP
//===========================================================================================================================

typedef uint8_t	BluetoothSDPPDUID;
enum {
    kBluetoothSDPPDUIDReserved							= 0,
    kBluetoothSDPPDUIDErrorResponse						= 1,
    kBluetoothSDPPDUIDServiceSearchRequest				= 2,
    kBluetoothSDPPDUIDServiceSearchResponse				= 3,
    kBluetoothSDPPDUIDServiceAttributeRequest			= 4,
    kBluetoothSDPPDUIDServiceAttributeResponse			= 5,
    kBluetoothSDPPDUIDServiceSearchAttributeRequest		= 6,
    kBluetoothSDPPDUIDServiceSearchAttributeResponse	= 7
};

#define IS_REQUEST_PDU( _pduID ) (	( _pduID == kBluetoothSDPPDUIDServiceSearchRequest ) || \
                                    ( _pduID == kBluetoothSDPPDUIDServiceAttributeRequest ) || \
                                    ( _pduID == kBluetoothSDPPDUIDServiceSearchAttributeRequest ) )
                                    
#define IS_RESPONSE_PDU( _pduID ) (	( _pduID == kBluetoothSDPPDUIDErrorResponse ) || \
                                    ( _pduID == kBluetoothSDPPDUIDServiceSearchResponse ) || \
                                    ( _pduID == kBluetoothSDPPDUIDServiceAttributeResponse ) || \
                                    ( _pduID == kBluetoothSDPPDUIDServiceSearchAttributeResponse ) )

typedef uint16_t	BluetoothSDPErrorCode;
enum {
    kBluetoothSDPErrorCodeSuccess						= 0x0000,
    kBluetoothSDPErrorCodeReserved						= 0x0000,
    kBluetoothSDPErrorCodeInvalidSDPVersion				= 0x0001,
    kBluetoothSDPErrorCodeInvalidServiceRecordHandle	= 0x0002,
    kBluetoothSDPErrorCodeInvalidRequestSyntax			= 0x0003,
    kBluetoothSDPErrorCodeInvalidPDUSize				= 0x0004,
    kBluetoothSDPErrorCodeInvalidContinuationState		= 0x0005,
    kBluetoothSDPErrorCodeInsufficientResources			= 0x0006,
    
    kBluetoothSDPErrorCodeReservedStart					= 0x0007,
    kBluetoothSDPErrorCodeReservedEnd					= 0xFFFF
};

typedef uint16_t	BluetoothSDPTransactionID;

typedef uint32_t	BluetoothSDPServiceRecordHandle;

enum {
    kBluetoothSDPDataElementTypeNil						= 0,
    kBluetoothSDPDataElementTypeUnsignedInt				= 1,
    kBluetoothSDPDataElementTypeSignedInt				= 2,
    kBluetoothSDPDataElementTypeUUID					= 3,
    kBluetoothSDPDataElementTypeString					= 4,
    kBluetoothSDPDataElementTypeBoolean					= 5,
    kBluetoothSDPDataElementTypeDataElementSequence		= 6,
    kBluetoothSDPDataElementTypeDataElementAlternative	= 7,
    kBluetoothSDPDataElementTypeURL						= 8,
    kBluetoothSDPDataElementTypeReservedStart			= 9,
    kBluetoothSDPDataElementTypeReservedEnd				= 31
};

typedef uint16_t	BluetoothSDPUUID16;
typedef uint32_t	BluetoothSDPUUID32;

typedef uint8_t		BluetoothSDPDataElementTypeDescriptor;
typedef uint8_t		BluetoothSDPDataElementSizeDescriptor;

typedef uint16_t	BluetoothSDPServiceAttributeID;

#if 0
#pragma mark -
#pragma mark === LE ===
#endif
        
typedef enum {
    BluetoothLEScanTypePassive	= 0x00,
    BluetoothLEScanTypeActive	= 0x01
} BluetoothLEScanType;

typedef enum {
    BluetoothLEAddressTypePublic	= 0x00,
    BluetoothLEAddressTypeRandom	= 0x01
} BluetoothLEAddressType;
        
typedef enum {
    BluetoothLEScanFilterNone		= 0x00,
    BluetoothLEScanFilterWhitelist	= 0x01
} BluetoothLEScanFilter;
        
typedef enum {
    BluetoothLEScanDisable	= 0x00,
    BluetoothLEScanEnable	= 0x01
} BluetoothLEScan;
		
typedef enum {
	BluetoothLEConnectionIntervalMin	= 0x06,
	BluetoothLEConnectionIntervalMax	= 0x0C80
} BluetoothLEConnectionInterval;
		
typedef enum {
    BluetoothLEScanDuplicateFilterDisable	= 0x00,
    BluetoothLEScanDuplicateFilterEnable	= 0x01,
} BluetoothLEScanDuplicateFilter;
        
typedef enum {
    BluetoothLEAdvertisingTypeConnectableUndirected		= 0x00,
    BluetoothLEAdvertisingTypeConnectableDirected		= 0x01,
    BluetoothLEAdvertisingTypeDiscoverableUndirected	= 0x02,
    BluetoothLEAdvertisingTypeNonConnectableUndirected	= 0x03,
    BluetoothLEAdvertisingTypeScanResponse				= 0x04
} BluetoothLEAdvertisingType;

#ifdef	__cplusplus
	}
#endif
                                                                                                                                                           BluetoothAssignedNumbers.h                                                                          0100644 0001750 0001750 00000107227 12567453167 041201  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/bluetooth                                                      /*
	File:		BluetoothAssignedNumbers.h
	Copyright:	(c) 2001-2012 by Apple, Inc. All rights reserved.
*/

#pragma once

#ifdef	__cplusplus
	extern "C" {
#endif

#pragma mark -
#pragma mark === General ===

enum BluetoothCompanyIdentifers
{
	kBluetoothCompanyIdentiferEricssonTechnologyLicensing						=	0,
	kBluetoothCompanyIdentiferNokiaMobilePhones									=	1,
	kBluetoothCompanyIdentiferIntel												=	2,
	kBluetoothCompanyIdentiferIBM												=	3,
	kBluetoothCompanyIdentiferToshiba											=	4,
	kBluetoothCompanyIdentifer3Com												=	5,
	kBluetoothCompanyIdentiferMicrosoft											=	6,
	kBluetoothCompanyIdentiferLucent											=	7,
	kBluetoothCompanyIdentiferMotorola											=	8,
	kBluetoothCompanyIdentiferInfineonTechnologiesAG							=	9,
	kBluetoothCompanyIdentiferCambridgeSiliconRadio								=	10,
	kBluetoothCompanyIdentiferSiliconWave										=	11,
	kBluetoothCompanyIdentiferDigianswerAS										=	12,
	kBluetoothCompanyIdentiferTexasInstruments									=	13,
	kBluetoothCompanyIdentiferParthusTechnologies								=	14,
	kBluetoothCompanyIdentiferBroadcom											=	15,
	kBluetoothCompanyIdentiferMitelSemiconductor								=	16,
	kBluetoothCompanyIdentiferWidcomm											=	17,
	kBluetoothCompanyIdentiferZeevo												=	18,
	kBluetoothCompanyIdentiferAtmel												=	19,
	kBluetoothCompanyIdentiferMistubishiElectric								=	20,
	kBluetoothCompanyIdentiferRTXTelecom										=	21,
	kBluetoothCompanyIdentiferKCTechnology										=	22,
	kBluetoothCompanyIdentiferNewlogic											=	23,
	kBluetoothCompanyIdentiferTransilica										=	24,
	kBluetoothCompanyIdentiferRohdeandSchwarz									=	25,
	kBluetoothCompanyIdentiferTTPCom											=	26,
	kBluetoothCompanyIdentiferSigniaTechnologies								=	27,
	kBluetoothCompanyIdentiferConexantSystems									=	28,
	kBluetoothCompanyIdentiferQualcomm											=	29,
	kBluetoothCompanyIdentiferInventel											=	30,
	kBluetoothCompanyIdentiferAVMBerlin											=	31,
	kBluetoothCompanyIdentiferBandspeed											=	32,
	kBluetoothCompanyIdentiferMansella											=	33,
	kBluetoothCompanyIdentiferNEC												=	34,
	kBluetoothCompanyIdentiferWavePlusTechnology								=	35,
	kBluetoothCompanyIdentiferAlcatel											=	36,
	kBluetoothCompanyIdentiferPhilipsSemiconductor								=	37,
	kBluetoothCompanyIdentiferCTechnologies										=	38,
	kBluetoothCompanyIdentiferOpenInterface										=	39,
	kBluetoothCompanyIdentiferRFCMicroDevices									=	40,
	kBluetoothCompanyIdentiferHitachi											=	41,
	kBluetoothCompanyIdentiferSymbolTechnologies								=	42,
	kBluetoothCompanyIdentiferTenovis											=	43,
	kBluetoothCompanyIdentiferMacronixInternational								=	44,
	kBluetoothCompanyIdentiferGCTSemiconductor									=	45,
	kBluetoothCompanyIdentiferNorwoodSystems									=	46,
	kBluetoothCompanyIdentiferMewTelTechnology									=	47,
	kBluetoothCompanyIdentiferSTMicroelectronics								=	48,
	kBluetoothCompanyIdentiferSynopsys											=	49,
	kBluetoothCompanyIdentiferRedMCommunications								=	50,
	kBluetoothCompanyIdentiferCommil											=	51,
	kBluetoothCompanyIdentiferCATC												=	52,
	kBluetoothCompanyIdentiferEclipse											=	53,
	kBluetoothCompanyIdentiferRenesasTechnology									=	54,
	kBluetoothCompanyIdentiferMobilian											=	55,
	kBluetoothCompanyIdentiferTerax												=	56,
	kBluetoothCompanyIdentiferIntegratedSystemSolution							=	57,
	kBluetoothCompanyIdentiferMatsushitaElectricIndustrial						=	58,
	kBluetoothCompanyIdentiferGennum											=	59,
	kBluetoothCompanyIdentiferResearchInMotion									=	60,
	kBluetoothCompanyIdentiferIPextreme											=	61,
	kBluetoothCompanyIdentiferSystemsAndChips									=	62,
	kBluetoothCompanyIdentiferBluetoothSIG										=	63,
	kBluetoothCompanyIdentiferSeikoEpson										=	64,
	kBluetoothCompanyIdentiferIntegratedSiliconSolution							=	65,
	kBluetoothCompanyIdentiferCONWISETechnology									=	66,
	kBluetoothCompanyIdentiferParrotSA											=	67,
	kBluetoothCompanyIdentiferSocketCommunications								=	68,
	kBluetoothCompanyIdentiferAtherosCommunications								=	69,
	kBluetoothCompanyIdentiferMediaTek											=	70,
	kBluetoothCompanyIdentiferBluegiga											=	71,
	kBluetoothCompanyIdentiferMarvellTechnologyGroup							=	72,
	kBluetoothCompanyIdentifer3DSP												=	73,
	kBluetoothCompanyIdentiferAccelSemiconductor								=	74,
	kBluetoothCompanyIdentiferContinentialAutomotiveSystems						=	75,
	kBluetoothCompanyIdentiferApple												=	76,
	kBluetoothCompanyIdentiferStaccatoCommunications							=	77,
	kBluetoothCompanyIdentiferAvagoTechnologies									=	78,
	kBluetoothCompanyIdentiferAPT												=	79,
	kBluetoothCompanyIdentiferSiRFTechnology									=	80,
	kBluetoothCompanyIdentiferTZeroTechnologies									=	81,
	kBluetoothCompanyIdentiferJandM												=	82,
	kBluetoothCompanyIdentiferFree2Move											=	83,
	kBluetoothCompanyIdentifer3DiJoy											=	84,
	kBluetoothCompanyIdentiferPlantronics										=	85,
	kBluetoothCompanyIdentiferSonyEricssonMobileCommunications					=	86,
	kBluetoothCompanyIdentiferHarmonInternational								=	87,
	kBluetoothCompanyIdentiferVisio												=	88,
	kBluetoothCompanyIdentiferNordicSemiconductor								=	89,
	kBluetoothCompanyIdentiferEMMicroElectronicMarin							=	90,

	kBluetoothCompanyIdentiferInteropIdentifier									=	65535
};

#pragma mark -
#pragma mark === Baseband ===

//==================================================================================================================
//	Baseband
//==================================================================================================================

//
// Service Class Major
//

enum
{
	kBluetoothServiceClassMajorLimitedDiscoverableMode		= 0x001,	// Bit 13 - Limited Discoverable Mode
	kBluetoothServiceClassMajorReserved1					= 0x002, 	// Bit 14 - Reserved for future use.
	kBluetoothServiceClassMajorReserved2					= 0x004, 	// Bit 15 - Reserved for future use.
	kBluetoothServiceClassMajorPositioning					= 0x008, 	// Bit 16 - Positioning (Location ID)
	kBluetoothServiceClassMajorNetworking					= 0x010, 	// Bit 17 - LAN, Ad hoc, etc...
	kBluetoothServiceClassMajorRendering					= 0x020, 	// Bit 18 - Printing, Speaker, etc...
	kBluetoothServiceClassMajorCapturing					= 0x040,	// Bit 19 - Scanner, Microphone, etc...
	kBluetoothServiceClassMajorObjectTransfer				= 0x080,	// Bit 20 - v-Inbox, v-Folder, etc...
	kBluetoothServiceClassMajorAudio						= 0x100,	// Bit 21 - Speaker, Microphone, Headset, etc...
	kBluetoothServiceClassMajorTelephony					= 0x200,	// Bit 22 - Cordless telephony, Modem, Headset, etc...
	kBluetoothServiceClassMajorInformation					= 0x400,	// Bit 23 - Web server, WAP server, etc...
	
	kBluetoothServiceClassMajorAny							= '****',	// Pseudo-class - means anything acceptable.
	kBluetoothServiceClassMajorNone							= 'none',	// Pseudo-class - means no matching.
	
	kBluetoothServiceClassMajorEnd
};

//
// Device Class Major
//

enum
{
	kBluetoothDeviceClassMajorMiscellaneous					= 0x00, 	// [00000] Miscellaneous
	kBluetoothDeviceClassMajorComputer						= 0x01, 	// [00001] Desktop, Notebook, PDA, Organizers, etc...
	kBluetoothDeviceClassMajorPhone							= 0x02, 	// [00010] Cellular, Cordless, Payphone, Modem, etc...
	kBluetoothDeviceClassMajorLANAccessPoint				= 0x03, 	// [00011] LAN Access Point
    kBluetoothDeviceClassMajorAudio							= 0x04, 	// [00100] Headset, Speaker, Stereo, etc...
	kBluetoothDeviceClassMajorPeripheral					= 0x05, 	// [00101] Mouse, Joystick, Keyboards, etc...
    kBluetoothDeviceClassMajorImaging						= 0x06,		// [00110] Printing, scanner, camera, display, etc...
	kBluetoothDeviceClassMajorWearable						= 0x07,		// [00111] Wearable
	kBluetoothDeviceClassMajorToy							= 0x08,		// [01000] Toy
	kBluetoothDeviceClassMajorHealth						= 0x09,		// [01001] Health devices
	kBluetoothDeviceClassMajorUnclassified					= 0x1F, 	// [11111] Specific device code not assigned
	
	// Range 0x06 to 0x1E Reserved for future use.
	
	kBluetoothDeviceClassMajorAny							= '****',	// Pseudo-class - means anything acceptable.
	kBluetoothDeviceClassMajorNone							= 'none',	// Pseudo-class - means no matching.
	
	kBluetoothDeviceClassMajorEnd
};

//
// Device Class Minor
//

enum
{
	///
	/// Computer Minor Class
	///
	
	kBluetoothDeviceClassMinorComputerUnclassified			= 0x00, 	// [000000] Specific device code not assigned
	kBluetoothDeviceClassMinorComputerDesktopWorkstation	= 0x01, 	// [000001] Desktop workstation
	kBluetoothDeviceClassMinorComputerServer				= 0x02, 	// [000010] Server-class computer
	kBluetoothDeviceClassMinorComputerLaptop				= 0x03, 	// [000011] Laptop
	kBluetoothDeviceClassMinorComputerHandheld				= 0x04, 	// [000100] Handheld PC/PDA (clam shell)
	kBluetoothDeviceClassMinorComputerPalmSized				= 0x05, 	// [000101] Palm-sized PC/PDA
    kBluetoothDeviceClassMinorComputerWearable				= 0x06,		// [000110] Wearable computer (watch sized)
	
	// Range 0x06 to 0x7F Reserved for future use.
	
    
	///
	/// Phone Minor Class
	///
	
	kBluetoothDeviceClassMinorPhoneUnclassified				= 0x00, 	// [000000] Specific device code not assigned
	kBluetoothDeviceClassMinorPhoneCellular					= 0x01, 	// [000001] Cellular
	kBluetoothDeviceClassMinorPhoneCordless					= 0x02, 	// [000010] Cordless
	kBluetoothDeviceClassMinorPhoneSmartPhone				= 0x03, 	// [000011] Smart phone
	kBluetoothDeviceClassMinorPhoneWiredModemOrVoiceGateway	= 0x04, 	// [000100] Wired modem or voice gateway
    kBluetoothDeviceClassMinorPhoneCommonISDNAccess			= 0x05,		// [000101] Common ISDN Access
	
	// Range 0x05 to 0x7F Reserved for future use.
	
    
	///
	/// LAN Access Point Minor Class
	///
	
	// See the Bluetooth specification for LAN Access Point minor classes, which are broken into bits 5-7 for utilization and bits 2-4 for class.
	
    
	///
	/// Audio Minor Class
	///
	
	kBluetoothDeviceClassMinorAudioUnclassified					= 0x00, 	// [000000] Specific device code not assigned
	kBluetoothDeviceClassMinorAudioHeadset						= 0x01, 	// [000001] Device conforms to the Headset profile
    kBluetoothDeviceClassMinorAudioHandsFree					= 0x02,		// [000010] Hands-free
    kBluetoothDeviceClassMinorAudioReserved1					= 0x03,		// [000011] Reserved
    kBluetoothDeviceClassMinorAudioMicrophone					= 0x04,		// [000100] Microphone
    kBluetoothDeviceClassMinorAudioLoudspeaker					= 0x05,		// [000101] Loudspeaker
    kBluetoothDeviceClassMinorAudioHeadphones					= 0x06,		// [000110] Headphones
    kBluetoothDeviceClassMinorAudioPortable						= 0x07,		// [000111] Portable Audio
    kBluetoothDeviceClassMinorAudioCar							= 0x08,		// [001000] Car Audio
    kBluetoothDeviceClassMinorAudioSetTopBox					= 0x09,		// [001001] Set-top box
    kBluetoothDeviceClassMinorAudioHiFi							= 0x0a,		// [001010] HiFi Audio Device
    kBluetoothDeviceClassMinorAudioVCR							= 0x0b,		// [001011] VCR
    kBluetoothDeviceClassMinorAudioVideoCamera					= 0x0c,		// [001100] Video Camera
    kBluetoothDeviceClassMinorAudioCamcorder					= 0x0d,		// [001101] Camcorder
    kBluetoothDeviceClassMinorAudioVideoMonitor					= 0x0e,		// [001110] Video Monitor
    kBluetoothDeviceClassMinorAudioVideoDisplayAndLoudspeaker	= 0x0f,		// [001111] Video Display and Loudspeaker
    kBluetoothDeviceClassMinorAudioVideoConferencing			= 0x10,		// [010000] Video Conferencing
    kBluetoothDeviceClassMinorAudioReserved2					= 0x11,		// [010001] Reserved
    kBluetoothDeviceClassMinorAudioGamingToy					= 0x12,		// [010010] Gaming/Toy
    
	
	// Range 0x13 to 0x7F Reserved for future use.
	
    
	///
	/// Peripheral Minor Class
	///
    
    // Peripheral1 subclass is bits 7 & 6
    
    kBluetoothDeviceClassMinorPeripheral1Keyboard			= 0x10,		// [01XXXX] Keyboard
    kBluetoothDeviceClassMinorPeripheral1Pointing			= 0x20,		// [10XXXX] Pointing device
    kBluetoothDeviceClassMinorPeripheral1Combo				= 0x30,		// [11XXXX] Combo keyboard/pointing device
    
    // Peripheral2 subclass is bits 5-2
    
    kBluetoothDeviceClassMinorPeripheral2Unclassified		= 0x00,		// [XX0000] Uncategorized device
    kBluetoothDeviceClassMinorPeripheral2Joystick			= 0x01,		// [XX0001] Joystick
    kBluetoothDeviceClassMinorPeripheral2Gamepad			= 0x02,		// [XX0010] Gamepad
    kBluetoothDeviceClassMinorPeripheral2RemoteControl		= 0x03,		// [XX0011] Remote control
    kBluetoothDeviceClassMinorPeripheral2SensingDevice		= 0x04,		// [XX0100] Sensing device
    kBluetoothDeviceClassMinorPeripheral2DigitizerTablet	= 0x05,		// [XX0101] Digitizer Tablet	
    kBluetoothDeviceClassMinorPeripheral2CardReader			= 0x06,		// [XX0110] Card Reader
    kBluetoothDeviceClassMinorPeripheral2DigitalPen         = 0x07,     // [XX0111] Digital Pen
    kBluetoothDeviceClassMinorPeripheral2HandheldScanner    = 0x08,     // [XX1000] Handheld scanner for bar-codes, RFID, etc.
    kBluetoothDeviceClassMinorPeripheral2GesturalInputDevice = 0x09,    // [XX1001] Handheld gestural input device (e.g., "wand" form factor)
    
	kBluetoothDeviceClassMinorPeripheral2AnyPointing		= 'poin',	// Anything under MinorPeripheral1Pointing
	
    // Range 0x05 to 0x0f reserved for future use
	
    
	///
	/// Imaging Minor Class
	///
    
    // Imaging1 subclass is bits 7 - 4
    
    kBluetoothDeviceClassMinorImaging1Display				= 0x04,		// [XXX1XX] Display
    kBluetoothDeviceClassMinorImaging1Camera				= 0x08,		// [XX1XXX] Camera
    kBluetoothDeviceClassMinorImaging1Scanner				= 0x10,		// [X1XXXX] Scanner
    kBluetoothDeviceClassMinorImaging1Printer				= 0x20,		// [1XXXXX] Printer
    
    // Imaging2 subclass is bits 3 - 2
    
    kBluetoothDeviceClassMinorImaging2Unclassified			= 0x00,		// [XXXX00] Uncategorized, default
    
    // Range 0x01 - 0x03 reserved for future use
    
	///
	/// Wearable Minor Class
	///
        
    kBluetoothDeviceClassMinorWearableWristWatch			= 0x01,		// [000001] Watch
    kBluetoothDeviceClassMinorWearablePager					= 0x02,		// [000010] Pager
    kBluetoothDeviceClassMinorWearableJacket				= 0x03,		// [000011] Jacket
    kBluetoothDeviceClassMinorWearableHelmet				= 0x04,		// [000100] Helmet
    kBluetoothDeviceClassMinorWearableGlasses				= 0x05,		// [000101] Glasses
    
	///
	/// Toy Minor Class
	///
        
    kBluetoothDeviceClassMinorToyRobot						= 0x01,		// [000001] Robot
    kBluetoothDeviceClassMinorToyVehicle					= 0x02,		// [000010] Vehicle
    kBluetoothDeviceClassMinorToyDollActionFigure			= 0x03,		// [000011] Doll / Action Figure
    kBluetoothDeviceClassMinorToyController					= 0x04,		// [000100] Controller
    kBluetoothDeviceClassMinorToyGame						= 0x05,		// [000101] Game
    
	///
	/// Health Minor Class
	///
        
    kBluetoothDeviceClassMinorHealthUndefined				= 0x00,		// [000000] Undefined
    kBluetoothDeviceClassMinorHealthBloodPressureMonitor	= 0x01,		// [000001] Blood Pressure Monitor
    kBluetoothDeviceClassMinorHealthThermometer				= 0x02,		// [000010] Thermometer
    kBluetoothDeviceClassMinorHealthScale					= 0x03,		// [000011] Scale
    kBluetoothDeviceClassMinorHealthGlucoseMeter			= 0x04,		// [000100] Glucose Meter
    kBluetoothDeviceClassMinorHealthPulseOximeter			= 0x05,		// [000101] Pulse Oximeter
    kBluetoothDeviceClassMinorHealthHeartRateMonitor		= 0x06,		// [000111] Heart Rate Monitor
    kBluetoothDeviceClassMinorHealthDataDisplay				= 0x07,		// [001000] Display
    
	///
	///	Misc
	///
	
	kBluetoothDeviceClassMinorAny							= '****',	// Pseudo-class - means anything acceptable.
	kBluetoothDeviceClassMinorNone							= 'none',	// Pseudo-class - means no matching.
	
	kBluetoothDeviceClassMinorEnd
};
		
		
// Peripheral devices bits 7 & 6
#define BluetoothCoDMinorPeripheral1(minorClass) (minorClass & 0x30)
		
// Peripheral devices bits 5 - 2
#define BluetoothCoDMinorPeripheral2(minorClass) (minorClass & 0x0f)	
		
#pragma mark - LE Appearance
enum {
    kBluetoothGAPAppearanceUnknown                                  = 0,
    kBluetoothGAPAppearanceGenericPhone                             = 64,
    kBluetoothGAPAppearanceGenericComputer                          = 128,
    kBluetoothGAPAppearanceGenericWatch                             = 192,
    kBluetoothGAPAppearanceGenericClock                             = 256,
    kBluetoothGAPAppearanceGenericDisplay                           = 320,
    kBluetoothGAPAppearanceGenericRemoteControl                     = 384,
    kBluetoothGAPAppearanceGenericEyeGlasses                        = 448,
    kBluetoothGAPAppearanceGenericTag                               = 512,
    kBluetoothGAPAppearanceGenericKeyring                           = 576,
    kBluetoothGAPAppearanceGenericMediaPlayer                       = 640,
    kBluetoothGAPAppearanceGenericBarcodeScanner                    = 704,
    kBluetoothGAPAppearanceGenericThermometer                       = 768,
    kBluetoothGAPAppearanceGenericHeartrateSensor                   = 832,
    kBluetoothGAPAppearanceGenericBloodPressure                     = 896,
    kBluetoothGAPAppearanceGenericHumanInterfaceDevice              = 960,
    kBluetoothGAPAppearanceHumanInterfaceDeviceKeyboard             = 961,
    kBluetoothGAPAppearanceHumanInterfaceDeviceMouse                = 962,
    kBluetoothGAPAppearanceHumanInterfaceDeviceJoystick             = 963,
    kBluetoothGAPAppearanceHumanInterfaceDeviceGamepad              = 964,
    kBluetoothGAPAppearanceHumanInterfaceDeviceDigitizerTablet      = 965,
    kBluetoothGAPAppearanceHumanInterfaceDeviceCardReader           = 966,
    kBluetoothGAPAppearanceHumanInterfaceDeviceDigitalPen           = 967,
    kBluetoothGAPAppearanceHumanInterfaceDeviceBarcodeScanner       = 968,
    kBluetoothGAPAppearanceGenericGlucoseMeter                      = 1024,
    kBluetoothGAPAppearanceGenericRunningWalkingSensor              = 1088,
    kBluetoothGAPAppearanceGenericCycling                           = 1152,
};
        
#pragma mark -
#pragma mark === L2CAP ===

//===========================================================================================================================
//	L2CAP
//===========================================================================================================================

enum
{
    kBluetoothL2CAPPSMSDP						= 0x0001, 
    kBluetoothL2CAPPSMRFCOMM					= 0x0003, 
    kBluetoothL2CAPPSMTCS_BIN					= 0x0005,	// Telephony Control Specifictation / TCS Binary
    kBluetoothL2CAPPSMTCS_BIN_Cordless			= 0x0007,	// Telephony Control Specifictation / TCS Binary
    kBluetoothL2CAPPSMBNEP						= 0x000F,	// Bluetooth Network Encapsulation Protocol
    kBluetoothL2CAPPSMHIDControl				= 0x0011,	// HID profile - control interface
    kBluetoothL2CAPPSMHIDInterrupt				= 0x0013,	// HID profile - interrupt interface
    kBluetoothL2CAPPSMAVCTP						= 0x0017,	// Audio/Video Control Transport Protocol
    kBluetoothL2CAPPSMAVDTP						= 0x0019,	// Audio/Video Distribution Transport Protocol
    kBluetoothL2CAPPSMAVCTP_Browsing			= 0x001B,	// AVTCP (AVRCP) Browsing
    kBluetoothL2CAPPSMUID_C_Plane				= 0x001D,	// Unrestricted Digital Information Profile (UDI)
    kBluetoothL2CAPPSMATT						= 0x001F,	// Attribute Protocol
	
	// Range < 0x1000 reserved.
    kBluetoothL2CAPPSMReservedStart				= 0x0001,
    kBluetoothL2CAPPSMReservedEnd				= 0x1000,
    
	// Range 0x1001-0xFFFF dynamically assigned.
    kBluetoothL2CAPPSMDynamicStart				= 0x1001,
	kBluetoothL2CAPPSMD2D						= 0x100F,
    kBluetoothL2CAPPSMDynamicEnd				= 0xFFFF,
    
    kBluetoothL2CAPPSMNone						= 0x0000
};


#pragma mark -
#pragma mark === SDP ===

//===========================================================================================================================
//	Service Discovery Protocol
//===========================================================================================================================

enum
{
	// General
	
	kBluetoothSDPUUID16Base									= 0x0000, 	// 00000000-0000-1000-8000-00805f9b34fb
	
	// Protocols
	
	kBluetoothSDPUUID16SDP				 					= 0x0001, 	// 00000001-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16UDP 									= 0x0002, 	// 00000002-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16RFCOMM 								= 0x0003, 	// 00000003-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16TCP 									= 0x0004, 	// 00000004-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16TCSBIN 								= 0x0005, 	// 00000005-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16TCSAT 								= 0x0006, 	// 00000006-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16OBEX 								= 0x0008, 	// 00000008-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16IP 									= 0x0009, 	// 00000009-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16FTP 									= 0x000A, 	// 0000000A-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16HTTP 								= 0x000C, 	// 0000000C-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16WSP	 								= 0x000E, 	// 0000000E-0000-1000-8000-00805f9b34fb 
	kBluetoothSDPUUID16BNEP									= 0x000F,
	kBluetoothSDPUUID16UPNP									= 0x0010,
	kBluetoothSDPUUID16HIDP									= 0x0011,
	kBluetoothSDPUUID16HardcopyControlChannel				= 0x0012,
	kBluetoothSDPUUID16HardcopyDataChannel					= 0x0014,
	kBluetoothSDPUUID16HardcopyNotification					= 0x0016,
	kBluetoothSDPUUID16AVCTP								= 0x0017,
	kBluetoothSDPUUID16AVDTP								= 0x0019,
	kBluetoothSDPUUID16CMPT									= 0x001B,
	kBluetoothSDPUUID16UDI_C_Plane							= 0x001D,
	kBluetoothSDPUUID16MCAPControlChannel					= 0x001E,
	kBluetoothSDPUUID16MCAPDataChannel						= 0x001F,
	kBluetoothSDPUUID16L2CAP 								= 0x0100, 	// 00000100-0000-1000-8000-00805f9b34fb
};

enum SDPServiceClasses
{
	kBluetoothSDPUUID16ServiceClassServiceDiscoveryServer					= 0x1000,	// 00001000-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassBrowseGroupDescriptor					= 0x1001,	// 00001001-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassPublicBrowseGroup						= 0x1002,	// 00001002-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassSerialPort								= 0x1101,	// 00001101-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassLANAccessUsingPPP						= 0x1102,	// 00001102-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassDialupNetworking							= 0x1103,	// 00001103-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassIrMCSync									= 0x1104,	// 00001104-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassOBEXObjectPush							= 0x1105,	// 00001105-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassOBEXFileTransfer							= 0x1106,	// 00001106-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassIrMCSyncCommand							= 0x1107,	// 00001107-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassHeadset									= 0x1108,	// 00001108-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassCordlessTelephony						= 0x1109,	// 00001109-0000-1000-8000-00805f9b34fb
    kBluetoothSDPUUID16ServiceClassAudioSource								= 0x110A,
    kBluetoothSDPUUID16ServiceClassAudioSink								= 0x110B,
    kBluetoothSDPUUID16ServiceClassAVRemoteControlTarget					= 0x110C,
    kBluetoothSDPUUID16ServiceClassAdvancedAudioDistribution				= 0x110D,
    kBluetoothSDPUUID16ServiceClassAVRemoteControl							= 0x110E,
    kBluetoothSDPUUID16ServiceClassAVRemoteControlController				= 0x110F,
	kBluetoothSDPUUID16ServiceClassIntercom									= 0x1110,	// 00001110-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassFax										= 0x1111,	// 00001111-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassHeadsetAudioGateway						= 0x1112,	// 00001112-0000-1000-8000-00805f9b34fb
    kBluetoothSDPUUID16ServiceClassWAP										= 0x1113,
    kBluetoothSDPUUID16ServiceClassWAPClient								= 0x1114,
    kBluetoothSDPUUID16ServiceClassPANU										= 0x1115,
    kBluetoothSDPUUID16ServiceClassNAP										= 0x1116,
    kBluetoothSDPUUID16ServiceClassGN										= 0x1117,
    kBluetoothSDPUUID16ServiceClassDirectPrinting							= 0x1118,
    kBluetoothSDPUUID16ServiceClassReferencePrinting						= 0x1119,
    kBluetoothSDPUUID16ServiceClassImaging									= 0x111A,
    kBluetoothSDPUUID16ServiceClassImagingResponder							= 0x111B,
    kBluetoothSDPUUID16ServiceClassImagingAutomaticArchive					= 0x111C,
    kBluetoothSDPUUID16ServiceClassImagingReferencedObjects					= 0x111D,
    kBluetoothSDPUUID16ServiceClassHandsFree								= 0x111E,
    kBluetoothSDPUUID16ServiceClassHandsFreeAudioGateway					= 0x111F,
    kBluetoothSDPUUID16ServiceClassDirectPrintingReferenceObjectsService	= 0x1120,
    kBluetoothSDPUUID16ServiceClassReflectedUI								= 0x1121,
    kBluetoothSDPUUID16ServiceClassBasicPrinting							= 0x1122,
    kBluetoothSDPUUID16ServiceClassPrintingStatus							= 0x1123,
    kBluetoothSDPUUID16ServiceClassHumanInterfaceDeviceService				= 0x1124,
    kBluetoothSDPUUID16ServiceClassHardcopyCableReplacement					= 0x1125,
    kBluetoothSDPUUID16ServiceClassHCR_Print								= 0x1126,
    kBluetoothSDPUUID16ServiceClassHCR_Scan									= 0x1127,
    kBluetoothSDPUUID16ServiceClassCommonISDNAccess							= 0x1128,
    kBluetoothSDPUUID16ServiceClassVideoConferencingGW						= 0x1129,
    kBluetoothSDPUUID16ServiceClassUDI_MT									= 0x112A,
    kBluetoothSDPUUID16ServiceClassUDI_TA									= 0x112B,
    kBluetoothSDPUUID16ServiceClassAudioVideo								= 0x112C,
    kBluetoothSDPUUID16ServiceClassSIM_Access								= 0x112D,
    kBluetoothSDPUUID16ServiceClassPhonebookAccess_PCE						= 0x112E,
    kBluetoothSDPUUID16ServiceClassPhonebookAccess_PSE						= 0x112F,
    kBluetoothSDPUUID16ServiceClassPhonebookAccess							= 0x1130,
    kBluetoothSDPUUID16ServiceClassHeadset_HS								= 0x1131,
    kBluetoothSDPUUID16ServiceClassMessageAccessServer						= 0x1132,
    kBluetoothSDPUUID16ServiceClassMessageNotificationServer				= 0x1133,
    kBluetoothSDPUUID16ServiceClassMessageAccessProfile						= 0x1134,
    kBluetoothSDPUUID16ServiceClassGlobalNavigationSatelliteSystem			= 0x1135,
    kBluetoothSDPUUID16ServiceClassGlobalNavigationSatelliteSystemServer	= 0x1136,
	kBluetoothSDPUUID16ServiceClassPnPInformation							= 0x1200,	// 00001200-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassGenericNetworking						= 0x1201,	// 00001201-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassGenericFileTransfer						= 0x1202,	// 00001202-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassGenericAudio								= 0x1203,	// 00001203-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassGenericTelephony							= 0x1204,	// 00001204-0000-1000-8000-00805f9b34fb
	kBluetoothSDPUUID16ServiceClassVideoSource								= 0x1303,
	kBluetoothSDPUUID16ServiceClassVideoSink								= 0x1304,
	kBluetoothSDPUUID16ServiceClassVideoDistribution						= 0x1305,
	kBluetoothSDPUUID16ServiceClassHealthDevice								= 0x1400,
	kBluetoothSDPUUID16ServiceClassHealthDeviceSource						= 0x1401,
	kBluetoothSDPUUID16ServiceClassHealthDeviceSink							= 0x1402
};

enum SDPAttributeIdentifierCodes
{
	kBluetoothSDPAttributeIdentifierServiceRecordHandle					= 0x0000,
	kBluetoothSDPAttributeIdentifierServiceClassIDList					= 0x0001,
	kBluetoothSDPAttributeIdentifierServiceRecordState					= 0x0002,
	kBluetoothSDPAttributeIdentifierServiceID							= 0x0003,
	kBluetoothSDPAttributeIdentifierProtocolDescriptorList				= 0x0004,
	kBluetoothSDPAttributeIdentifierBrowseGroupList						= 0x0005,
	kBluetoothSDPAttributeIdentifierLanguageBaseAttributeIDList			= 0x0006,
	kBluetoothSDPAttributeIdentifierServiceInfoTimeToLive				= 0x0007,
	kBluetoothSDPAttributeIdentifierServiceAvailability					= 0x0008,
	kBluetoothSDPAttributeIdentifierBluetoothProfileDescriptorList		= 0x0009,
	kBluetoothSDPAttributeIdentifierDocumentationURL					= 0x000A,
	kBluetoothSDPAttributeIdentifierClientExecutableURL					= 0x000B,
	kBluetoothSDPAttributeIdentifierIconURL								= 0x000C,
	kBluetoothSDPAttributeIdentifierAdditionalProtocolsDescriptorList	= 0x000D,

    // Service Discovery Server
	kBluetoothSDPAttributeIdentifierVersionNumberList					= 0x0200,
	kBluetoothSDPAttributeIdentifierServiceDatabaseState				= 0x0201,
    
    // Browse Group Descriptor
    kBluetoothSDPAttributeIdentifierGroupID								= 0x0200,
    
    // PAN
    kBluetoothSDPAttributeIdentifierIPSubnet							= 0x0200,

    // HID																			Required		Type		Notes
    kBluetoothSDPAttributeIdentifierHIDReleaseNumber					= 0x0200,	// O			uint16
    kBluetoothSDPAttributeIdentifierHIDParserVersion					= 0x0201,	// M			uint16
    kBluetoothSDPAttributeIdentifierHIDDeviceSubclass					= 0x0202,	// M			uint8       Should match the low order 8 bits of CoD unless a combo device
    kBluetoothSDPAttributeIdentifierHIDCountryCode						= 0x0203,	// M			uint8
    kBluetoothSDPAttributeIdentifierHIDVirtualCable						= 0x0204,	// M			bool
    kBluetoothSDPAttributeIdentifierHIDReconnectInitiate				= 0x0205,	// M			bool
    kBluetoothSDPAttributeIdentifierHIDDescriptorList					= 0x0206,	// M			sequence    Layout is defined in Section 6.2 of the HID Specification
    kBluetoothSDPAttributeIdentifierHIDLangIDBaseList					= 0x0207,	// M			sequence
    kBluetoothSDPAttributeIdentifierHIDSDPDisable						= 0x0208,	// O			bool
    kBluetoothSDPAttributeIdentifierHIDBatteryPower						= 0x0209,	// O			bool
    kBluetoothSDPAttributeIdentifierHIDRemoteWake						= 0x020A,	// O			bool
    kBluetoothSDPAttributeIdentifierHIDProfileVersion					= 0x020B,	// M			uint16
    kBluetoothSDPAttributeIdentifierHIDSupervisionTimeout				= 0x020C,	// O			uint16		Default to 5 seconds or longer if not defined
    kBluetoothSDPAttributeIdentifierHIDNormallyConnectable				= 0x020D,	// O			bool
    kBluetoothSDPAttributeIdentifierHIDBootDevice						= 0x020E,	// M			bool		Only defined for mice and keyboards as of HID 1.0
    kBluetoothSDPAttributeIdentifierHIDSSRHostMaxLatency				= 0x020F,	// O			uint16
    kBluetoothSDPAttributeIdentifierHIDSSRHostMinTimeout				= 0x0210,	// O			uint16
    
	kBluetoothSDPAttributeIdentifierServiceVersion						= 0x0300,
	kBluetoothSDPAttributeIdentifierExternalNetwork						= 0x0301,	// Cordless telephony
    kBluetoothSDPAttributeIdentifierNetwork								= 0x0301,	// Handsfree Profile (HFP)
	kBluetoothSDPAttributeIdentifierSupportedDataStoresList				= 0x0301,	// Sync Profile
	kBluetoothSDPAttributeIdentifierFaxClass1Support					= 0x0302,	// Fax Profile
	kBluetoothSDPAttributeIdentifierRemoteAudioVolumeControl			= 0x0302,	// GAP???
	kBluetoothSDPAttributeIdentifierFaxClass2_0Support					= 0x0303,
	kBluetoothSDPAttributeIdentifierSupporterFormatsList				= 0x0303,
	kBluetoothSDPAttributeIdentifierFaxClass2Support					= 0x0304,
	kBluetoothSDPAttributeIdentifierAudioFeedbackSupport				= 0x0305,
    kBluetoothSDPAttributeIdentifierNetworkAddress						= 0x0306,	// WAP
    kBluetoothSDPAttributeIdentifierWAPGateway							= 0x0307,	// WAP
    kBluetoothSDPAttributeIdentifierHomepageURL							= 0x0308,	// WAP
    kBluetoothSDPAttributeIdentifierWAPStackType						= 0x0309,	// WAP
    kBluetoothSDPAttributeIdentifierSecurityDescription					= 0x030A,	// PAN
    kBluetoothSDPAttributeIdentifierNetAccessType						= 0x030B,	// PAN
    kBluetoothSDPAttributeIdentifierMaxNetAccessRate					= 0x030C,	// PAN
    kBluetoothSDPAttributeIdentifierSupportedCapabilities				= 0x0310,	// Imaging
    kBluetoothSDPAttributeIdentifierSupportedFeatures					= 0x0311,	// Imaging & HFP
    kBluetoothSDPAttributeIdentifierSupportedFunctions					= 0x0312,	// Imaging
    kBluetoothSDPAttributeIdentifierTotalImagingDataCapacity			= 0x0313,	// Imaging

	kBluetoothSDPAttributeIdentifierServiceName							= 0x0000, /* +language base offset*/
	kBluetoothSDPAttributeIdentifierServiceDescription					= 0x0001, /* +language base offset*/
	kBluetoothSDPAttributeIdentifierProviderName						= 0x0002  /* +language base offset*/
};

enum SDPAttributeDeviceIdentificationRecord
{
	// DeviceID v1.3																Required		Type		Section		Notes
	kBluetoothSDPAttributeDeviceIdentifierServiceDescription			= 0x0001,	// O			string		-
	kBluetoothSDPAttributeDeviceIdentifierDocumentationURL				= 0x000A,	// O			url			-
	kBluetoothSDPAttributeDeviceIdentifierClientExecutableURL			= 0x000B,	// O			url			-
	kBluetoothSDPAttributeDeviceIdentifierSpecificationID				= 0x0200,	// M			uint16		5.1
	kBluetoothSDPAttributeDeviceIdentifierVendorID						= 0x0201,	// M			uint16		5.2
	kBluetoothSDPAttributeDeviceIdentifierProductID						= 0x0202,	// M			uint16		5.3
	kBluetoothSDPAttributeDeviceIdentifierVersion						= 0x0203,	// M			uint16		5.4
	kBluetoothSDPAttributeDeviceIdentifierPrimaryRecord					= 0x0204,	// M			bool		5.5
	kBluetoothSDPAttributeDeviceIdentifierVendorIDSource				= 0x0205,	// M			uint16		5.6
	kBluetoothSDPAttributeDeviceIdentifierReservedRangeStart			= 0x0206,
	kBluetoothSDPAttributeDeviceIdentifierReservedRangeEnd				= 0x02FF
	
};

enum ProtocolParameters
{
    kBluetoothSDPProtocolParameterL2CAPPSM								= 1,
    kBluetoothSDPProtocolParameterRFCOMMChannel							= 1,
    kBluetoothSDPProtocolParameterTCPPort								= 1,
    kBluetoothSDPProtocolParameterUDPPort								= 1,
    kBluetoothSDPProtocolParameterBNEPVersion							= 1,
    kBluetoothSDPProtocolParameterBNEPSupportedNetworkPacketTypeList	= 2
};

//Inquiries with 'Extended Inquiry Response' (v2.1 specification)

enum BluetoothHCIExtendedInquiryResponseDataTypes
{
	kBluetoothHCIExtendedInquiryResponseDataTypeFlags										=	0x01,
	kBluetoothHCIExtendedInquiryResponseDataType16BitServiceClassUUIDsWithMoreAvailable		=	0x02,
	kBluetoothHCIExtendedInquiryResponseDataType16BitServiceClassUUIDsCompleteList			=	0x03,
	kBluetoothHCIExtendedInquiryResponseDataType32BitServiceClassUUIDsWithMoreAvailable		=	0x04,
	kBluetoothHCIExtendedInquiryResponseDataType32BitServiceClassUUIDsCompleteList			=	0x05,
	kBluetoothHCIExtendedInquiryResponseDataType128BitServiceClassUUIDsWithMoreAvailable	=	0x06,
	kBluetoothHCIExtendedInquiryResponseDataType128BitServiceClassUUIDsCompleteList			=	0x07,
	kBluetoothHCIExtendedInquiryResponseDataTypeShortenedLocalName							=	0x08,
	kBluetoothHCIExtendedInquiryResponseDataTypeCompleteLocalName							=	0x09,
    kBluetoothHCIExtendedInquiryResponseDataTypeTransmitPowerLevel                          =   0x0A,
    kBluetoothHCIExtendedInquiryResponseDataTypeSSPOOBClassOfDevice                         =   0x0D,
    kBluetoothHCIExtendedInquiryResponseDataTypeSSPOOBSimplePairingHashC                    =   0x0E,
    kBluetoothHCIExtendedInquiryResponseDataTypeSSPOOBSimplePairingRandomizerR              =   0x0F,
	kBluetoothHCIExtendedInquiryResponseDataTypeDeviceID									=	0x10,
	kBluetoothHCIExtendedInquiryResponseDataTypeSecurityManagerTKValue						=	0x10,
    kBluetoothHCIExtendedInquiryResponseDataTypeSecurityManagerOOBFlags                     =   0x11,
    kBluetoothHCIExtendedInquiryResponseDataTypeSlaveConnectionIntervalRange                =   0x12,
    kBluetoothHCIExtendedInquiryResponseDataTypeServiceSolicitation16BitUUIDs               =   0x14,
    kBluetoothHCIExtendedInquiryResponseDataTypeServiceSolicitation128BitUUIDs              =   0x15,
    kBluetoothHCIExtendedInquiryResponseDataTypeServiceData                                 =   0x16,
    kBluetoothHCIExtendedInquiryResponseDataTypePublicTargetAddress                         =   0x17,
    kBluetoothHCIExtendedInquiryResponseDataTypeRandomTargetAddress                         =   0x18,
    kBluetoothHCIExtendedInquiryResponseDataTypeAppearance                                  =   0x19,
	kBluetoothHCIExtendedInquiryResponseDataTypeManufacturerSpecificData					=	0xFF
};


// HCI Versions

enum BluetoothHCIVersions
{
	kBluetoothHCIVersionCoreSpecification1_0b												=	0x00,
	kBluetoothHCIVersionCoreSpecification1_1												=	0x01,
	kBluetoothHCIVersionCoreSpecification1_2												=	0x02,
	kBluetoothHCIVersionCoreSpecification2_0EDR												=	0x03,
	kBluetoothHCIVersionCoreSpecification2_1EDR												=	0x04,
	kBluetoothHCIVersionCoreSpecification3_0HS												=	0x05,
	kBluetoothHCIVersionCoreSpecification4_0												=	0x06,
	kBluetoothHCIVersionCoreSpecification4_1												=	0x07
};


// LMP Versions

enum BluetoothLMPVersions
{
	kBluetoothLMPVersionCoreSpecification1_0b												=	0x00,
	kBluetoothLMPVersionCoreSpecification1_1												=	0x01,
	kBluetoothLMPVersionCoreSpecification1_2												=	0x02,
	kBluetoothLMPVersionCoreSpecification2_0EDR												=	0x03,
	kBluetoothLMPVersionCoreSpecification2_1EDR												=	0x04,
	kBluetoothLMPVersionCoreSpecification3_0HS												=	0x05,
	kBluetoothLMPVersionCoreSpecification4_0												=	0x06,
	kBluetoothLMPVersionCoreSpecification4_1												=	0x07
};

#ifdef	__cplusplus
	}
#endif
                                                                                                                                                                                                                                                                                                                                                                         IOBluetoothHIDDriver.h                                                                              0100644 0001750 0001750 00000024127 12567453167 040115  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/bluetooth                                                      /*
	File:		IOBluetoothHIDDriver.h
	Contains:	Driver for generic Bluetooth HID devices.
	Copyright:	(c) 2001-2008 by Apple, all rights reserved.
*/

#ifndef IOBLUETOOTHHIDDRIVER_H
#define IOBLUETOOTHHIDDRIVER_H

#import <IOKit/hid/IOHIDDevice.h>
#import <IOKit/bluetooth/Bluetooth.h>

#import "IOKit/pwr_mgt/RootDomain.h"

//===========================================================================================================================
// Macros
//===========================================================================================================================

#define kBSKernelMonitor2Notification				'bsk2'

//===========================================================================================================================
// Forwards
//===========================================================================================================================

class IOTimerEventSource;
class IOWorkLoop;

class IOBluetoothL2CAPChannel;
class IOBluetoothDevice;
class IOWorkQueue;

//===========================================================================================================================
// IOBluetoothHIDDriver
//===========================================================================================================================

class IOBluetoothHIDDriver : public IOHIDDevice
{
	OSDeclareDefaultStructors( IOBluetoothHIDDriver )

    IOWorkLoop*					_workLoop;
	IOCommandGate*				_commandGate;
	
	IOWorkQueue					*_desyncWorkQueue;
	
	IOBluetoothL2CAPChannel*	_controlChannel;
    IOBluetoothL2CAPChannel*	_interruptChannel;

    IOBluetoothDevice*			_device;

	IOMemoryDescriptor*			_memDescriptor;
	IOMemoryDescriptor*			_getReportDescriptor;
	IONotifier*					_interruptOpenNotification;
	IOTimerEventSource*			_timer;
    IONotifier*					_sleepWakeNotifier;

	bool						_deviceReady;

	UInt8						_expectedReportID;
	UInt8						_expectedReportType;
	UInt8						_handshake;
	
	OSDictionary*				_deviceProperties;

	UInt16						_vendorIDSource;
	UInt16						_vendorID;
	UInt16						_productID;
	UInt16						_deviceVersion;
	uint32_t					_classOfDevice;
    UInt16                      _countryCode;
	
	BluetoothDeviceAddress		_deviceAddress;
	char						_deviceAddressString[20];
	
	uint32_t					_outstandingIO;
	bool						_sendOutstanding;
	
	// Debug / Behavior Modifiers
	UInt8						_verboseLevel;
	bool						_logPackets;
	bool						_decodePackets;
	bool						_logOutstandingIO;
	bool						_suppressDisconnectNotifications;
	bool						_suppressSetProtocol;
	bool						_driverIsAwake;
	bool						_reservedFlag4;
	UInt8						_reservedByte;
	
    struct ExpansionData 
    { 
        OSArray*				_sendQueue;
		
		uint8_t					*interruptBuffer;
		uint32_t				interruptBufferUsed;
		
		uint8_t					*controlBuffer;
		uint32_t				controlBufferUsed;

		uint8_t					deviceSupportsSuspend;

		uint32_t				getReportTimeoutMS;
		uint32_t				setReportTimeoutMS;
		
		uint32_t				outstandingMemoryBlockCount;
		bool					waitingForMemoryBlockCount;

		IOPMrootDomain *        fRootDomain;
		IOPMDriverAssertionID   fNoDeepSleepAssertionId;
		
		bool					mCommandGateCreated;
		bool					mCommandGateAdded;
		bool					mControlChannelRetained;
		bool					mWorkLoopRetained;
		
		bool					mCloseDownServicesCalled;
		
		bool					mGotNoDeepSleepAssertionID;
		
        OSString*				disconnectionNotificationString;
        OSString*				connectionNotificationString;
        
		IOTimerEventSource*		deviceConnectTimer;
		
		bool					mNeedToDropData;
		
		UInt32					mWakeTime;
		
		UInt32					mDriverLoadTime;
		
		IOTimerEventSource*		mReadyToSleepTimer;
		
		bool					mHandleStopBeingCalled;

		
    };
    ExpansionData	*_expansionData;
	
public:
	// Standard IOService Methods
    virtual IOService*  probe( IOService * provider, SInt32 * score );
	virtual bool		init( OSDictionary *properties );
	virtual void		free();
	virtual bool 		willTerminate( IOService * provider, IOOptionBits options );
	
	// Starting & Stopping
    virtual bool		handleStart( IOService * provider );
    virtual void		handleStop( IOService *  provider );
	virtual void		deviceReady();
	virtual void		closeDownServices();

	// Power Management
    virtual void		handleSleep();
    virtual void		handleWake();
    virtual void		handleShutdown();			// Does nothing
    virtual void		handleRestart();			// Does nothing
	
	// HID Properties
	virtual OSString*	newTransportString() const;
	virtual OSString*	newManufacturerString() const;
	virtual OSString*	newProductString() const;
	virtual OSNumber*	newVendorIDSourceNumber() const;
	virtual OSNumber*	newVendorIDNumber() const;
	virtual OSNumber*	newProductIDNumber() const;
	virtual OSNumber*	newVersionNumber() const;
    virtual IOReturn	newReportDescriptor( IOMemoryDescriptor ** descriptor ) const;
	virtual OSString*	newSerialNumberString() const;
	virtual OSNumber*	newLocationIDNumber() const;
    virtual OSNumber*	newCountryCodeNumber() const;
	virtual OSNumber*	newReportIntervalNumber() const;

	// Main UserLand Entry Points
    virtual IOReturn	getReport( IOMemoryDescriptor* report, IOHIDReportType reportType, IOOptionBits options = 0 );
    virtual IOReturn 	setReport( IOMemoryDescriptor* report, IOHIDReportType reportType, IOOptionBits options = 0 );
    virtual IOReturn	setProperties( OSObject* properties );

	// General IO
	virtual IOReturn	sendData( IOBluetoothL2CAPChannel* theChannel, void* theData, IOByteCount theSize );
    virtual void		processControlData( UInt8 *buffer, UInt16 length );
    virtual void		processInterruptData( UInt8 *buffer, UInt16 length );
	virtual IOReturn	waitForData( IOMemoryDescriptor* report, UInt8 btReportType, UInt8 reportID );
	virtual IOReturn	waitForHandshake();
	
	// HID Transaction Methods
	virtual IOReturn	hidControl( UInt8 controlOperation );
	virtual int			getProtocol();
	virtual IOReturn	setProtocol( UInt8 protocol );
	virtual int			getIdle();
	virtual IOReturn	setIdle( UInt8 idleRate );

	// Device Introspection
	virtual bool		isKeyboard();
	virtual bool		isMouse();
	
	// Misc
	virtual IOReturn	setPowerState( unsigned long powerStateOrdinal, IOService* whatDevice );
	virtual IOReturn	createCommandGate( IOService* provider );
	virtual IOReturn	getDeviceProperties( IOService* provider );
	virtual	bool		readDeviceName();
	
	// Command Gate Actions
	static	IOReturn	staticCloseDownServicesAction( OSObject* owner, void* arg1, void* arg2, void* arg3, void* arg4 );
	static	IOReturn	staticSendToAction( OSObject* owner, void* theChannel, void* theData, void *theSize, void* );
	static	IOReturn	staticPrepControlChannelAction( OSObject* owner, void* arg1, void* arg2, void* arg3, void* arg4 );
	static	IOReturn	staticInterruptChannelOpeningAction( OSObject* owner, void* newService, void* arg2, void* arg3, void* arg4 );
	static	IOReturn	staticWillTerminateAction( OSObject* owner, void* arg1, void* arg2, void* arg3, void* arg4 );
	
	// Work Loop Methods
	virtual void		closeDownServicesWL();
	virtual IOReturn	prepInterruptChannelWL();
	virtual IOReturn	getReportWL( IOMemoryDescriptor* report, IOHIDReportType reportType, IOOptionBits options );
	virtual IOReturn	setReportWL( IOMemoryDescriptor* report, IOHIDReportType reportType, IOOptionBits options );
	virtual IOReturn	processCommandWL( OSString* command, OSNumber* commandParameter );
	virtual IOReturn	getDevicePropertiesWL( IOService* provider );
	virtual IOReturn	interruptChannelOpeningWL( IOBluetoothL2CAPChannel* theChannel );

	// Timeout Handler
	static	void		deviceConnectTimerFired( OSObject* owner, IOTimerEventSource* sender );
	static	void		timerFired( OSObject* owner, IOTimerEventSource* sender );
	virtual void		handleTimeout();
	
	// IO Counting
	virtual void		incrementOutstandingIO();
	virtual void		decrementOutstandingIO();
	
	// ReadyToSleepTimeout Handler
	static	void		ReadyToSleepTimerFired( OSObject* owner, IOTimerEventSource* sender );
	
private:
	// Lazy Interrupt Channel Methods
	static	bool		interruptChannelOpeningCallback(	void* me, void* ignoreMe, IOService* newService, IONotifier *notifier );
    static	IOReturn 	powerStateHandler( void *target, void *refCon, UInt32 messageType, IOService *service, void *messageArgument, vm_size_t argSize );

public:
    OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver,  0 );
    virtual void        	sendDeviceDisconnectNotifications( void );

	OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver,  1 );
	virtual IOReturn		setPowerStateWL( unsigned long powerStateOrdinal, IOService* whatDevice ); 
    
	OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver,  2 );
    virtual void        	sendDeviceConnectNotifications( void );

	OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver,  3 );
    virtual void        	decrementOutstandingMemoryBlockCount( void );

	OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver,  4 );
    virtual IOReturn       	willTerminateWL( void );

	OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver,  5 );
	virtual void			messageClientsWithString( UInt32 type, OSString* message );
	
    OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver,  6 );
	virtual void			waitForInterruptChannel( void );
	
    OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver,  7 );
	virtual void			handleStopWL( IOService *  provider );
	
    OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver,  8 );
	virtual UInt32			GetCurrentTime( void );
	
    OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver,  9 );
	virtual void			handleReadyToSleepTimerFired();

    OSMetaClassDeclareReservedUsed( IOBluetoothHIDDriver, 10 );
	virtual	IOReturn		HIDCommandSleep (void		*	event,
											 UInt32			milliseconds,
											 char		*	calledByFunction,
											 bool			panicMachine);
	
    OSMetaClassDeclareReservedUnused( IOBluetoothHIDDriver, 11 );
    OSMetaClassDeclareReservedUnused( IOBluetoothHIDDriver, 12 );
    OSMetaClassDeclareReservedUnused( IOBluetoothHIDDriver, 13 );
    OSMetaClassDeclareReservedUnused( IOBluetoothHIDDriver, 14 );
    OSMetaClassDeclareReservedUnused( IOBluetoothHIDDriver, 15 );
    OSMetaClassDeclareReservedUnused( IOBluetoothHIDDriver, 16 );
    OSMetaClassDeclareReservedUnused( IOBluetoothHIDDriver, 17 );
    OSMetaClassDeclareReservedUnused( IOBluetoothHIDDriver, 18 );
    OSMetaClassDeclareReservedUnused( IOBluetoothHIDDriver, 19 );
};

#endif	// IOBLUETOOTHHIDDRIVER_H
                                                                                                                                                                                                                                                                                                                                                                                                                                         IOBluetoothHIDDriverTypes.h                                                                         0100644 0001750 0001750 00000003513 12567453167 041136  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/bluetooth                                                      /*
	File:		IOBluetoothHIDDriverTypes.h
	Contains:	Type defined for the IOBluetoothHIDDriver.h.
	Copyright:	(c) 2001-2008 by Apple, all rights reserved.
*/


#ifndef IOBLUETOOTHHIDDRIVERTYPES_H
#define IOBLUETOOTHHIDDRIVERTYPES_H

// Vendor ID Sources
//------------------
#define kVendorIDSourceBluetoothSIG				0x1
#define kVendorIDSourceUSBIF					0x2

// Bluetooth HID Transaction Headers
//----------------------------------
#define IOBTHID_HANDSHAKE_HEADER				0x00
#define IOBTHID_HID_CONTROL_HEADER				0x10
#define IOBTHID_GET_REPORT_HEADER				0x40
#define IOBTHID_SET_REPORT_HEADER				0x50
#define IOBTHID_GET_PROTOCOL_HEADER				0x60
#define IOBTHID_SET_PROTOCOL_HEADER				0x70
#define IOBTHID_GET_IDLE_HEADER					0x80
#define IOBTHID_SET_IDLE_HEADER					0x90
#define IOBTHID_DATA_HEADER						0xA0
#define IOBTHID_DATC_HEADER						0xB0

// Handshake Types
//----------------
#define IOBTHID_HANDSHAKE_SUCCESSFUL			0x0
#define IOBTHID_HANDSHAKE_NOT_READY				0x1
#define IOBTHID_HANDSHAKE_INVALID_REPORT_ID		0x2
#define IOBTHID_HANDSHAKE_UNSUPPORTED_REQUEST	0x3
#define IOBTHID_HANDSHAKE_INVALID_PARAMETER		0x4
#define IOBTHID_HANDSHAKE_ERR_UNKNOWN			0xD
#define IOBTHID_HANDSHAKE_ERR_FATAL				0xF

// HID_Control Types
//------------------
#define IOBTHID_CONTROL_NOP						0x0
#define IOBTHID_CONTROL_HARD_RESET				0x1
#define IOBTHID_CONTROL_SOFT_RESET				0x2
#define IOBTHID_CONTROL_SUSPEND					0x3
#define IOBTHID_CONTROL_EXIT_SUSPEND			0x4
#define IOBTHID_CONTROL_VC_UNPLUG				0x5

// Protocol Types
//---------------
#define IOBTHID_BOOT_PROTOCOL					0x0
#define IOBTHID_REPORT_PROTOCOL					0x1

// Report Types
//-------------
#define IOBTHID_RESERVED_REPORT					0x0
#define IOBTHID_OTHER_REPORT					0x0
#define IOBTHID_INPUT_REPORT					0x1
#define IOBTHID_OUTPUT_REPORT					0x2
#define IOBTHID_FEATURE_REPORT					0x3

#endif // IOBLUETOOTHHIDDRIVERTYPES_H
                                                                                                                                                                                     IOBluetoothTypes.h                                                                                  0100644 0001750 0001750 00000001364 12567453167 037437  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/bluetooth                                                      /*
	File:		IOBluetoothTypes.h
	Copyright:	© 2010 by Apple Inc. All rights reserved.
*/

#pragma once

#import <IOKit/IOReturn.h>

// Error returns
#ifndef sub_iokit_bluetooth
#define sub_iokit_bluetooth				err_sub(8)
#endif

#define iokit_bluetooth_err(return)		(sys_iokit|sub_iokit_bluetooth|return)

#define kIOBluetoothDeviceResetError			iokit_bluetooth_err(1)	// Device reset interrupted pending operation
#define kIOBluetoothConnectionAlreadyExists		iokit_bluetooth_err(2)	// Attempting to open a connection that already exists
#define kIOBluetoothNoHCIController				iokit_bluetooth_err(3)	// No HCI controller is present
#define kIOBluetoothHCIPowerStatesNotSupported	iokit_bluetooth_err(4)	// HCI controller does not support changing power states


                                                                                                                                                                                                                                                                            firewire/                                                                                           0040755 0001750 0001750 00000000000 12612224742 033634  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOConfigDirectory.h                                                                                 0100644 0001750 0001750 00000015475 12567451747 037360  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __IOCONFIGDIRECTORY_H__
#define __IOCONFIGDIRECTORY_H__

#include <libkern/c++/OSObject.h>
#include <IOKit/IOReturn.h>

#include <IOKit/firewire/IOFireWireFamilyCommon.h>

class OSData;
class OSString;
class OSIterator;
class IOFireWireDevice;

/*! @class IOConfigDirectory 
*/
class IOConfigDirectory : public OSObject
{
    OSDeclareAbstractStructors(IOConfigDirectory);

protected:
    int fStart;			// Offset into ROM of start of this dir
    int fType;			// Directory type
    int fNumEntries;		// In directory
    
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

    virtual bool initWithOffset(int start, int type);

    virtual const UInt32 *getBase() = 0;
    virtual IOReturn createIterator(UInt32 testVal, UInt32 testMask,
                                    OSIterator *&iterator);
    virtual IOConfigDirectory *getSubDir(int start, int type) = 0;

public:
    /*!
        @function update
        makes sure that the ROM has at least the specified capacity,
        and that the ROM is uptodate from its start to at least the
        specified quadlet offset.
        @result kIOReturnSuccess if the specified offset is now
        accessable at romBase[offset].
    */
    virtual IOReturn update(UInt32 offset, const UInt32 *&romBase) = 0;

    /*!
        @function getKeyType
        Gets the data type for the specified key
        @param type on return, set to the data type
        @result kIOReturnSuccess if the key exists in the dictionary
    */
    virtual IOReturn getKeyType(int key, IOConfigKeyType &type);
    /*!
        @function getKeyValue
        Gets the value for the specified key, in a variety of forms.
        @param value on return, set to the data type
        @param text if non-zero, on return points to the
        string description of the field, or NULL if no text found.
        @result kIOReturnSuccess if the key exists in the dictionary
        and is of a type appropriate for the value parameter
        @param value reference to variable to store the entry's value
    */
    virtual IOReturn getKeyValue(int key, UInt32 &value, OSString** text = NULL);
    virtual IOReturn getKeyValue(int key, OSData *&value,
                                 OSString** text = NULL);
    virtual IOReturn getKeyValue(int key, IOConfigDirectory *&value,
                                 OSString** text = NULL);
    virtual IOReturn getKeyOffset(int key, FWAddress &value,
                                  OSString** text = NULL);


    /*!
        @function getIndexType
        Gets the data type for entry at the specified index
        @param type on return, set to the data type
        @result kIOReturnSuccess if the index exists in the dictionary
    */
    virtual IOReturn getIndexType(int index, IOConfigKeyType &type);
    /*!
        @function getIndexKey
        Gets the key for entry at the specified index
        @param key on return, set to the key
        @result kIOReturnSuccess if the index exists in the dictionary
    */
    virtual IOReturn getIndexKey(int index, int &key);

    /*!
        @function getIndexValue
        Gets the value at the specified index of the directory,
        in a variety of forms.
        @param type on return, set to the data type
        @result kIOReturnSuccess if the index exists in the dictionary
        and is of a type appropriate for the value parameter
        @param value reference to variable to store the entry's value
    */
    virtual IOReturn getIndexValue(int index, UInt32 &value);
    virtual IOReturn getIndexValue(int index, OSData *&value);
    virtual IOReturn getIndexValue(int index, OSString *&value);
    virtual IOReturn getIndexValue(int index, IOConfigDirectory *&value);
    virtual IOReturn getIndexOffset(int index, FWAddress &value);
    virtual IOReturn getIndexOffset(int index, UInt32 &value);

    /*!
        @function getIndexEntry
        Gets the entry at the specified index of the directory,
        as a raw UInt32.
        @param entry on return, set to the entry value
        @result kIOReturnSuccess if the index exists in the dictionary
        @param value reference to variable to store the entry's value
    */
    virtual IOReturn getIndexEntry(int index, UInt32 &value);

    /*!
        @function getSubdirectories
        Creates an iterator over the subdirectories of the directory.
        @param iterator on return, set to point to an OSIterator
        @result kIOReturnSuccess if the iterator could be created
    */
    virtual IOReturn getSubdirectories(OSIterator *&iterator);

    /*!
        @function getKeySubdirectories
        Creates an iterator over subdirectories of a given type of the directory.
        @param key type of subdirectory to iterate over
        @param iterator on return, set to point to an OSIterator
        @result kIOReturnSuccess if the iterator could be created
    */
    virtual IOReturn getKeySubdirectories(int key, OSIterator *&iterator);

    int getType() const;
	
    int getNumEntries() const;

protected:
	
	virtual const UInt32 * lockData( void ) = 0;
	virtual void unlockData( void ) = 0;
	virtual IOReturn updateROMCache( UInt32 offset, UInt32 length ) = 0;
	virtual IOReturn checkROMState( void ) = 0;
	
private:
    OSMetaClassDeclareReservedUnused(IOConfigDirectory, 0);
    OSMetaClassDeclareReservedUnused(IOConfigDirectory, 1);
    OSMetaClassDeclareReservedUnused(IOConfigDirectory, 2);
    OSMetaClassDeclareReservedUnused(IOConfigDirectory, 3);
    OSMetaClassDeclareReservedUnused(IOConfigDirectory, 4);
    OSMetaClassDeclareReservedUnused(IOConfigDirectory, 5);
    OSMetaClassDeclareReservedUnused(IOConfigDirectory, 6);
    OSMetaClassDeclareReservedUnused(IOConfigDirectory, 7);
    OSMetaClassDeclareReservedUnused(IOConfigDirectory, 8);

};

#endif /* __IOCONFIGDIRECTORY_H__ */
                                                                                                                                                                                                   IOFWAddressSpace.h                                                                                  0100644 0001750 0001750 00000027212 12567451747 037054  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 *
 *	IOFWAddressSpace.h
 *
 * Classes which describe addresses in the local node which are accessable to other nodes
 * via firewire asynchronous read/write/lock requests.
 */
 
#ifndef _IOKIT_IOFWADDRESSSPACE_H
#define _IOKIT_IOFWADDRESSSPACE_H

#include <IOKit/IOMemoryDescriptor.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h>

class IOFireWireDevice;
class IOFireWireBus;
class IOFireWireController;

typedef void * IOFWRequestRefCon;

/*!	@function	FWWriteCallback
	@abstract	Callback called when a write request packet is received for
				a 'virtual' firewire address.
	@param		device	is the node originating the request
	@param		speed	is the FireWire speed of the request, update it if you need to control
						the speed of the reply, otherwise the response will be the same speed.
	@param		addr	is the address the device is requesting to write to
	@param		len		is the number of bytes to write
	@param		buf		contains the packet data
	@param		requestRefcon	refcon Can be queried for extra info about the request,
								using IOFireWireController::isLockRequest(), isQuadRequest()
	@result		return:
				kFWResponseComplete			= 0,	OK
				kFWResponseConflictError	= 4,	Resource conflict, may retry
				kFWResponseDataError		= 5,	Data not available
				kFWResponseTypeError		= 6,	Operation not supported
				kFWResponseAddressError		= 7		Address not valid in target device */
typedef UInt32 (*FWWriteCallback)(void *refcon, UInt16 nodeID, IOFWSpeed &speed,
                                  FWAddress addr, UInt32 len, const void *buf, IOFWRequestRefCon requestRefcon);

/*!	@function	FWReadCallback
	@abstract	Callback called when a read request packet is received for
				a 'virtual' firewire address.
	@param		 nodeID is the node originating the request
	@param		speed is the FireWire speed of the request, update it if you need to control
						the speed of the reply, otherwise the response will be the same speed.
	@param		addr is the address the device is requesting to read from
	@param		len is the number of bytes to read
	@param		buf contains the packet data
	@param		offset on return points to the offset into *buf of the packet data
	@param		requestRefcon   refcon to pass back if sending a delayed response. Also can be queried 
								for extra info about the request
	@result		return:
    kFWResponsePending			= -1,	Pseudo response, real response sent later.
	kFWResponseComplete			= 0,	OK!
	kFWResponseConflictError	= 4,	Resource conflict, may retry
	kFWResponseDataError		= 5,	Data not available
	kFWResponseTypeError		= 6,	Operation not supported
	kFWResponseAddressError		= 7		Address not valid in target device 

	A return of kFWResponsePending should be followed at some later time by a call to
	IOFireWireController::asyncReadResponse	*/ 
typedef UInt32 (*FWReadCallback)(void *refcon, UInt16 nodeID, IOFWSpeed &speed,
                                FWAddress addr, UInt32 len, IOMemoryDescriptor **buf,
                                 IOByteCount * offset, IOFWRequestRefCon requestRefcon);

class IOFWAddressSpace;

#pragma mark -

/*! @class IOFWAddressSpaceAux
	@discussion An IOFWAddressSpaceAux is for internal use only. You should never subclass IOFWAddressSpaceAux 
*/

class IOFWAddressSpaceAux : public OSObject
{
    OSDeclareDefaultStructors(IOFWAddressSpaceAux)

	friend class IOFWAddressSpace;
	
protected:
	
	IOFWAddressSpace * 		fPrimary;
	IOFireWireController *	fControl;
	
	OSSet *					fTrustedNodeSet;
    OSIterator *			fTrustedNodeSetIterator;
	
	bool					fExclusive;
	
	/*! 
		@struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
    */  
	  
    struct ExpansionData { };

	/*! 
		@var reserved
		Reserved for future use.  (Internal use only)  
	*/
    
	ExpansionData * reserved;

    virtual bool init( IOFWAddressSpace * primary );
	virtual	void free();

	virtual bool isTrustedNode( UInt16 nodeID );
	virtual void addTrustedNode( IOFireWireDevice * device );
	virtual void removeTrustedNode( IOFireWireDevice * device );
	virtual void removeAllTrustedNodes( void );

	bool isExclusive( void );
	void setExclusive( bool exclusive );
	
	virtual bool intersects( IOFWAddressSpace * space );
		
private:
    OSMetaClassDeclareReservedUsed(IOFWAddressSpaceAux, 0);
    OSMetaClassDeclareReservedUnused(IOFWAddressSpaceAux, 1);
    OSMetaClassDeclareReservedUnused(IOFWAddressSpaceAux, 2);
    OSMetaClassDeclareReservedUnused(IOFWAddressSpaceAux, 3);
    OSMetaClassDeclareReservedUnused(IOFWAddressSpaceAux, 4);
    OSMetaClassDeclareReservedUnused(IOFWAddressSpaceAux, 5);
    OSMetaClassDeclareReservedUnused(IOFWAddressSpaceAux, 6);
    OSMetaClassDeclareReservedUnused(IOFWAddressSpaceAux, 7);
    OSMetaClassDeclareReservedUnused(IOFWAddressSpaceAux, 8);
    OSMetaClassDeclareReservedUnused(IOFWAddressSpaceAux, 9);
	
};

#pragma mark -

/*
 * Base class for FireWire address space objects
 */
 
/*! 
	@class IOFWAddressSpace
*/

class IOFWAddressSpace : public OSObject
{
    OSDeclareAbstractStructors(IOFWAddressSpace)

	friend class IOFWAddressSpaceAux;
	
protected:
    
	IOFireWireController *fControl;

	/*!
		@struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
    */  
	  
    struct ExpansionData 
	{ 
		IOFWAddressSpaceAux * fAuxiliary; 
	};

	/*! 
		@var reserved
		Reserved for future use.  (Internal use only)  
	*/
	
    ExpansionData * fIOFWAddressSpaceExpansion;

    virtual bool init(IOFireWireBus *bus);
	virtual	void free();
  
public:

	/*!	@function	doRead
		@abstract	An abstract method for processing an address space read request
		@param		nodeID	FireWire Read from nodeID.
		@param		speed	at this 'speed'.
		@param		addr	with FireWire address 'addr'.
		@param		len		read 'len' bytes from nodeID.
		@param		buf		points to a memory descriptor containing the packet data.
		@param		offset	start from this 'offset' in 'buf'.
		@param		refcon  Can be queried for extra info about the request.
		@result		UIn32	returns kFWResponseComplete on success */
	virtual UInt32 doRead(UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len, 
					IOMemoryDescriptor **buf, IOByteCount * offset,
                          IOFWRequestRefCon refcon) = 0;
						  
	/*!	@function	doWrite
		@abstract	An abstract method for processing an address space write request
		@param		nodeID	FireWire Write to nodeID.
		@param		speed	at this 'speed'.
		@param		addr	with FireWire address 'addr'.
		@param		len		write 'len' bytes to nodeID.
		@param		buf		obtain bytes from location given by 'buf'.
		@param		refcon  Can be queried for extra info about the request.
		@result		UIn32	returns kFWResponseComplete on success */
    virtual UInt32 doWrite(UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len,
                           const void *buf, IOFWRequestRefCon refcon) = 0;

	/*!	@function	doLock
		@abstract	A method for processing a lock request.
		@param		nodeID	FireWire Lock request for nodeID.
		@param		speed	at this 'speed'.
		@param		addr	with FireWire address 'addr'.
		@param		inlen	'inlen' bytes to use.
		@param		newVal	new value to write at 'addr' location .
		@param		outLen	'outLen' bytes for result.
		@param		oldVal	old value read from 'addr' location.
		@param		extType	Type like kFWExtendedTCodeCompareSwap.
		@param		refcon  Can be queried for extra info about the request.
		@result		UIn32	returns kFWResponseComplete on success */
    virtual UInt32 doLock(UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 inlen,
                          const UInt32 *newVal, UInt32 &outLen, UInt32 *oldVal,
                          UInt32 extType, IOFWRequestRefCon refcon);

	/*!	@function	activate
		@abstract	Address space is ready for handling requests.
		@result		IOReturn
		*/
    virtual IOReturn activate();
	
	/*!	@function	deactivate
		@abstract	Address space request handler is disabled.
		@result		none
		*/
    virtual void deactivate();
    
	/*!	@function	contains
		@abstract	returns number of bytes starting at addr in this space
		@result		0 if it doesn't contain the address
		*/
    virtual UInt32 contains(FWAddress addr);

	/*!	@function	isTrustedNode
		@abstract	returns true if the node is added as a trusted node
		@param		nodeID is the nodeID to verify whether its trusted.
		@result		false if nodeID is not trusted
		*/
	inline bool isTrustedNode( UInt16 nodeID ) 
				{ return fIOFWAddressSpaceExpansion->fAuxiliary->isTrustedNode( nodeID ); }

	/*!	@function	addTrustedNode
		@abstract	Add a trusted node.
		@param		device object pointing to a FireWire node on the bus.
		@result		none
		*/
	inline void addTrustedNode( IOFireWireDevice * device )
				{ fIOFWAddressSpaceExpansion->fAuxiliary->addTrustedNode( device ); }
	
	/*!	@function	removeTrustedNode
		@abstract	Remove a trusted node.
		@param		device object pointing to a FireWire node on the bus.
		@result		none
		*/
	inline void removeTrustedNode( IOFireWireDevice * device )
				{ fIOFWAddressSpaceExpansion->fAuxiliary->removeTrustedNode( device ); }
		
	/*!	@function	removeAllTrustedNodes
		@abstract	Remove all trusted nodes.
		@result		none
		*/
	inline void removeAllTrustedNodes( void )
				{ fIOFWAddressSpaceExpansion->fAuxiliary->removeAllTrustedNodes(); }

	/*!	@function	isExclusive
		@abstract	Checks if an address space wants exclusive control of its address range
		@result		True if the address space is marked exclusive false otherwise
		*/

	inline bool isExclusive( void )
		{ return fIOFWAddressSpaceExpansion->fAuxiliary->isExclusive(); }

	/*!	@function	setExclusive
		@abstract	Sets if this address space requires exclusive control of its address range. Exclusivity should be set before an address space is activated.
		@param		exclusive  True if address space should be exclusive, false otherwise
		@result		none
	*/
		
	inline void setExclusive( bool exclusive )
		{ fIOFWAddressSpaceExpansion->fAuxiliary->setExclusive( exclusive ); }

	/*!	@function	intersects
		@abstract	Checks this address space intersects with the given address range. Currently only supports IOFWPsuedoAddressSpaces.
		@param		space  An address space to compare against
		@result		True if the address spaces intersect false otherwise
	*/
		
	inline bool intersects( IOFWAddressSpace * space )
		{ return fIOFWAddressSpaceExpansion->fAuxiliary->intersects( space ); }

		
protected:
	
	virtual IOFWAddressSpaceAux * createAuxiliary( void );
    
private:
    OSMetaClassDeclareReservedUsed(IOFWAddressSpace, 0);
    OSMetaClassDeclareReservedUsed(IOFWAddressSpace, 1);
    
};

// the physical and psuedo address space classes used to be defined here
// for backwards compatibility, we pull them in now.  the ifdefs surrounding
// the content of the header files ensures we do not multiply include a header.

#include <IOKit/firewire/IOFWPseudoAddressSpace.h>
#include <IOKit/firewire/IOFWPhysicalAddressSpace.h>

#endif /* _IOKIT_IOFWADDRESSSPACE */
                                                                                                                                                                                                                                                                                                                                                                                      IOFWAsyncStreamListener.h                                                                           0100644 0001750 0001750 00000010516 12567451747 040451  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2001 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _IOKIT_IOFWASYNCSTREAMLISTENER_H
#define _IOKIT_IOFWASYNCSTREAMLISTENER_H

#include <IOKit/firewire/IOFireWireLink.h>
#include <IOKit/firewire/IOFWCommand.h>
#include <IOKit/IOBufferMemoryDescriptor.h>
#include <IOKit/firewire/IOFWDCLProgram.h>

class IOFWAsyncStreamReceiver;
class IOFWAsyncStreamReceivePort;

/*! @class IOFWAsyncStreamListener
*/
class IOFWAsyncStreamListener : public OSObject
{
    OSDeclareDefaultStructors(IOFWAsyncStreamListener)

friend class IOFWAsyncStreamReceiver;
friend class IOFireWireController;

public:

/*!	@function initAll
	@abstract Creates an AsyncStream client for an Isoch channel.
	@param control	Points to IOFireWireController.
	@param channel	Isoch channel for listening.
	@param proc		Callback on packet reception.
	@param obj  Client's callback object.
	@result returns true on success, else false.	*/	
	bool initAll( IOFireWireController *control, UInt32 channel, FWAsyncStreamReceiveCallback proc, void *refcon );

/*!	@function setListenerHandler
	@abstract Set the callback that should be called to handle incoming async stream packets
	@param inReceiver The callback to set.
	@result Returns the callback that was previously set or nil for none.*/
	const FWAsyncStreamReceiveCallback setListenerHandler( FWAsyncStreamReceiveCallback inReceiver );

/*!	@function TurnOffNotification
	@abstract Turns off client callback notification.
	@result   none.	*/	
	inline void TurnOffNotification() { fNotify = false; };

/*!	@function TurnOnNotification
	@abstract Turns on client callback notification.
	@result   none.	*/	
	inline void TurnOnNotification() { fNotify = true; };

/*!	@function IsNotificationOn
	@abstract checks the notification state.
	@result   true if ON, else false	*/	
	inline bool IsNotificationOn() { return fNotify; };

/*!	@function setFlags
	@abstract set flags for the listener.
	@param flags indicate performance metrics.
	@result none.	*/	
	void setFlags( UInt32 flags );
	
/*!	@function getFlags
	@abstract get the flags of listener.
	@param none.
	@result flags.	*/	
	UInt32 getFlags();

/*!	@function getRefCon
	@abstract get the refcon specific to this listener.
	@param none.
	@result fRefCon refcon passed during initialization. */	
	inline void* getRefCon() { return fRefCon; };
	
/*!	@function getOverrunCounter
	@abstract get overrun counter from the DCL program.
	@param none.
	@result returns the counter value.	*/	
	UInt32 getOverrunCounter();
	
protected:

	FWAsyncStreamReceiveCallback	fClientProc; 
	void							*fRefCon;
	IOFWAsyncStreamReceiver			*fReceiver;
	bool							 fNotify;
	UInt32							 fFlags;
	IOFireWireController			*fControl;

/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;
    
    virtual void		free();

private:
/*!	function getReceiver
	abstract Returns the Async Stream receiver object which tracks multiple
	         IOFWAsyncStreamListeners for the same Isoc channel. */	
	inline IOFWAsyncStreamReceiver *getReceiver() { return fReceiver; };

/*!	function invokeClients
	abstract Invokes client's callback function with fRefCon.	*/	
	void invokeClients( UInt8 *buffer );
	
    OSMetaClassDeclareReservedUnused(IOFWAsyncStreamListener, 0);
    OSMetaClassDeclareReservedUnused(IOFWAsyncStreamListener, 1);
};
#endif // _IOKIT_IOFWASYNCSTREAMLISTENER_H

                                                                                                                                                                                  IOFWCommand.h                                                                                       0100644 0001750 0001750 00000070234 12567451747 036073  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *
 *	IOFWCommand.h
 *
 */
#ifndef _IOKIT_IOFWCOMMAND_H
#define _IOKIT_IOFWCOMMAND_H

#include <IOKit/IOCommand.h>
#include <IOKit/IOLib.h>

#include <IOKit/firewire/IOFireWireFamilyCommon.h>

#include <IOKit/firewire/IOFWSyncer.h>

#define kFWCmdDefaultRetries 3
#define kFWCmdZeroRetries 0
#define kFWCmdReducedRetries 2
#define kFWCmdIncreasedRetries 6

class IOMemoryDescriptor;
class IOSyncer;
class IOFireWireBus;
class IOFireWireController;
class IOFireWireNub;
class IOFWAddressSpace;	// Description of chunk of local FW address space
class IOFWCommand;
class IOFWBusCommand;
class IOFWAsyncStreamCommand;
class IOCommandGate;
class IOFWAsyncPHYCommand;

struct AsyncPendingTrans;

// Struct for head of command queue
/*!
    @struct IOFWCmdQ
    @abstract Structure for head of a queue of IOFWCommands
    @field fHead Points to the head of the queue, or NULL if queue is empty
    @field fTail Points to the tail of the queue, or NULL if queue is empty
    @function headChanged called when head command is changed, or the command
 	itself changes state.
*/

struct IOFWCmdQ
{
    IOFWCommand *fHead;
    IOFWCommand *fTail;
    bool executeQueue(bool all);
    virtual void headChanged(IOFWCommand *oldHead);
	
	virtual ~IOFWCmdQ() {}

	void checkProgress( void );
};

// Callback when device command completes asynchronously
typedef void (*FWDeviceCallback)(void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd);

// Callback when bus command completes asynchronously
typedef void (*FWBusCallback)(void *refcon, IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd);

// Callback when async stream command completes asynchronously
typedef void (*FWAsyncStreamCallback)(void *refcon, IOReturn status, IOFireWireBus *bus, IOFWAsyncStreamCommand *fwCmd);

// Callback when async stream command completes asynchronously
typedef void (*FWAsyncPHYCallback)(void *refcon, IOReturn status, IOFireWireBus *bus, IOFWAsyncPHYCommand *fwCmd );

// Callback when async stream packet is received
typedef void (*FWAsyncStreamReceiveCallback)(void *refcon, const void *buf);

#pragma mark -

/*
 * Base class for FireWire commands
 */
/*! @class IOFWCommand
*/
class IOFWCommand : public IOCommand
{
    OSDeclareAbstractStructors(IOFWCommand)

protected:
    IOReturn		fStatus;
    IOFireWireController *fControl;
    IOFWCommand *	fQueuePrev;
    IOFWCommand *	fQueueNext;
    IOFWCmdQ *		fQueue;
    UInt32			fTimeout;	// How long (in microsecs) after execute() to timeout
    AbsoluteTime	fDeadline;	// Time after which this command has timed out.
    IOFWSyncer *	fSyncWakeup;
    UInt8			fSync;
    UInt8			fCancelOnReset;
    UInt8			spare[2];
    
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct MemberVariables 
	{
		void *			fFWIMRefCon;
		IOReturn		fCompletionStatus;
		bool			fSubmitTimeLatched;
	    AbsoluteTime	fSubmitTime;
		bool			fFlush;
	};

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    MemberVariables * fMembers;

    virtual IOReturn	complete(IOReturn status);
    virtual void	updateTimer();
    virtual IOReturn	startExecution();
    
    /*	
     *	Execute the FWCommand immediately
     *	must be called with the workloop gate closed
     */
    virtual IOReturn	execute() = 0;

public:

    virtual bool	initWithController(IOFireWireController *control);
	virtual void	free( void );
	
    IOReturn		getStatus() const { return fStatus; };
    
    /*	
     *	Submit the FWCommand.
     *	if queue is false the command's execute()
     *	method will be called on the caller's thread, otherwise
     *	the command wil be queued for execution on the work loop thread.
     */                          
    virtual IOReturn 	submit(bool queue = false);

    /*
     * Cancel command, causes it to complete with given status
     */
    virtual IOReturn	cancel(IOReturn reason);

    /*!
        @function setHead
        inserts a command at the head of a queue.
        @param queue queue command is being added to
    */
    virtual void setHead(IOFWCmdQ &queue);
    /*!
        @function insertAfter
        inserts a command after the specified one.
        @param prev command to insert after
        @param queue queue command is being added to
    */
    virtual void insertAfter(IOFWCommand &prev);

    /*!
        @function removeFromQ
        Removes command from current queue.
    */
    virtual void removeFromQ();

    IOFWCommand *getPrevious() const
	{ return fQueuePrev; };
    IOFWCommand *getNext() const
        { return fQueueNext; };
    const AbsoluteTime &getDeadline() const
	{ return fDeadline; };

    bool cancelOnReset() const
    { return fCancelOnReset; };

    bool Busy() const
        { return fStatus == kIOReturnBusy || fStatus == kIOFireWirePending;};
    
    void setTimeout( UInt32 timeout )
        { fTimeout = timeout; };
        
    friend class IOFWCmdQ;

	void * getFWIMRefCon( void )
	{
		return fMembers->fFWIMRefCon;
	}
	
	void setFWIMRefCon( void * refcon )
	{
		fMembers->fFWIMRefCon = refcon;
	}

	void setFlush( bool flush )
	{
		fMembers->fFlush = flush;		
	}
	
	virtual IOReturn checkProgress( void );
	
private:
    OSMetaClassDeclareReservedUsed(IOFWCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFWCommand, 1);

};

#pragma mark -

/*
 * Bus control commands
 */
/*! @class IOFWBusCommand
*/
class IOFWBusCommand : public IOFWCommand
{
    OSDeclareAbstractStructors(IOFWBusCommand)

protected:
    FWBusCallback	fComplete;
    void *		fRefCon;

/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

    virtual IOReturn	complete(IOReturn status);

    virtual bool	initWithController(IOFireWireController *control,
				FWBusCallback completion=NULL, void *refcon=NULL);
    virtual IOReturn	reinit(FWBusCallback completion, void *refcon);

private:
    OSMetaClassDeclareReservedUnused(IOFWBusCommand, 0);

};

#pragma mark -

/*
 * Command to execute some code after a specified delay (in microseconds)
 * All it does is timeout after the specified delay, hence calling the completion
 * callback.
 */
/*! @class IOFWDelayCommand
*/
class IOFWDelayCommand : public IOFWBusCommand
{
    OSDeclareDefaultStructors(IOFWDelayCommand)

/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

protected:
    virtual IOReturn	execute();

public:
    virtual bool	initWithDelay(IOFireWireController *control, UInt32 uSecs,
                                FWBusCallback completion, void *refcon);
    virtual IOReturn	reinit(UInt32 uSecs, FWBusCallback completion, void *refcon);

private:
    OSMetaClassDeclareReservedUnused(IOFWDelayCommand, 0);

};

/*
 * Send an async request to a device
 */
class IOFWUserReadQuadletCommand ;
class IOFWUserWriteCommand ;

#pragma mark -

/*! @class IOFWAsyncCommand
*/
class IOFWAsyncCommand : public IOFWCommand
{
	OSDeclareAbstractStructors(IOFWAsyncCommand)

protected:
    IOFireWireNub *	fDevice;
    FWDeviceCallback	fComplete;
    void *		fRefCon;
    IOMemoryDescriptor *fMemDesc;
    AsyncPendingTrans *	fTrans;
    UInt32		fAddressHi;
    UInt32		fAddressLo;
    IOByteCount		fBytesTransferred;
    int			fSize;
    int			fSpeed;
    int			fMaxPack;
    int			fCurRetries;
    int			fMaxRetries;
    UInt32		fGeneration;	// bus topology fNodeID is valid for.
    UInt16		fNodeID;
    bool		fFailOnReset;
    bool		fWrite;

	typedef struct 
	{ 
		// some of our subclasses didn't have room for expansion data, so
		// we've reserved space for their use here.
		
		void *			fSubclassMembers;
		int				fMaxSpeed;
		int				fAckCode;
		UInt32			fResponseCode;
		UInt32			fFastRetryCount;
		int				fResponseSpeed;
		bool			fForceBlockRequests;
	} 
	MemberVariables;

    MemberVariables * fMembers;

    virtual IOReturn	complete(IOReturn status);
	virtual bool	initWithController(IOFireWireController *control);
    virtual bool	initAll(IOFireWireNub *device, FWAddress devAddress,
				IOMemoryDescriptor *hostMem,
				FWDeviceCallback completion, void *refcon, bool failOnReset);
    virtual bool	initAll(IOFireWireController *control,
                                UInt32 generation, FWAddress devAddress,
                                IOMemoryDescriptor *hostMem,
                                FWDeviceCallback completion, void *refcon);
	virtual void free( void );
    virtual IOReturn	reinit(FWAddress devAddress, IOMemoryDescriptor *hostMem,
				FWDeviceCallback completion, void *refcon, bool failOnReset);
    virtual IOReturn	reinit(UInt32 generation, FWAddress devAddress, IOMemoryDescriptor *hostMem,
                                FWDeviceCallback completion, void *refcon);
	bool createMemberVariables( void );
	void destroyMemberVariables( void );
public:
	// Utility for setting generation on newly created command
	virtual void	setGeneration(UInt32 generation)
	{ fGeneration = generation; }

    // To be called by IOFireWireController and derived classes.
    virtual void 	gotPacket(int rcode, const void* data, int size) = 0;
    virtual void	gotAck(int ackCode);

    // update nodeID/generation after bus reset, from the device object
    IOReturn		updateGeneration();
    // explicitly update nodeID/generation after bus reset
    IOReturn		updateNodeID(UInt32 generation, UInt16 nodeID);
    
    // Generally useful stuff
    IOByteCount		getBytesTransferred() const
    { return fBytesTransferred; };

    FWAddress		getAddress() const
    { return FWAddress(fAddressHi, fAddressLo, fNodeID); }

    bool		failOnReset() const
    { return fFailOnReset; }
    
    IOFireWireNub *	getDevice() const
    { return fDevice; }
    
    /*!
        @function setMaxPacket
        Sets the maximum size for block transfers used by the command.
        The command is initialized to use the maximum packet size calculated from the device's
        PHY speed, bus info block and the bus topology.
        Call this method before calling submit().
        @param maxBytes Maximum packet size in bytes. If the maxsize is 4 then quadlet transfers will be used.
    */
    IOReturn	setMaxPacket(UInt32 maxBytes)
    {
        if(fStatus == kIOReturnBusy || fStatus == kIOFireWirePending)
            return fStatus;
        fMaxPack = maxBytes;
        return kIOReturnSuccess;
    }

	void setMaxSpeed( int speed );
	
	void setAckCode( int ack );
	int getAckCode( void );
	
	void setRetries( int retries);
	int getMaxRetries( void );
	
	void setResponseCode( UInt32 rcode );
	UInt32 getResponseCode( void ) const;

	void setFastRetryCount( UInt32 count ) 
		{ fMembers->fFastRetryCount = count; };

	UInt32 getFastRetryCount( void ) 
		{ return fMembers->fFastRetryCount; };
		
	void setResponseSpeed( int speed ) 
		{ fMembers->fResponseSpeed = speed; };

	int getResponseSpeed( void ) 
		{ return fMembers->fResponseSpeed; };

	// forces even 4 byte transactions to be block requests
	void setForceBlockRequests( bool enabled )
		{ fMembers->fForceBlockRequests = enabled; }

	virtual IOReturn checkProgress( void );
			
private:
    OSMetaClassDeclareReservedUnused(IOFWAsyncCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFWAsyncCommand, 1);
    OSMetaClassDeclareReservedUnused(IOFWAsyncCommand, 2);
    OSMetaClassDeclareReservedUnused(IOFWAsyncCommand, 3);

};

#pragma mark -

/*
 * Concrete async requests - read, write and hordes of read/modify/write
 */
class IOFWReadCommand : public IOFWAsyncCommand
{
    OSDeclareDefaultStructors(IOFWReadCommand)

protected:
	
    virtual void 	gotPacket(int rcode, const void* data, int size);

    virtual IOReturn	execute();

public:
    virtual bool	initAll(IOFireWireNub *device, FWAddress devAddress,
				IOMemoryDescriptor *hostMem,
				FWDeviceCallback completion, void *refcon, bool failOnReset);
    virtual bool	initAll(IOFireWireController *control,
                                UInt32 generation, FWAddress devAddress,
                                IOMemoryDescriptor *hostMem,
                                FWDeviceCallback completion, void *refcon);
    virtual IOReturn	reinit(FWAddress devAddress, IOMemoryDescriptor *hostMem,
				FWDeviceCallback completion=NULL, void *refcon=NULL,
				bool failOnReset=false);
    virtual IOReturn	reinit(UInt32 generation, FWAddress devAddress, IOMemoryDescriptor *hostMem,
                                FWDeviceCallback completion=NULL, void *refcon=NULL);

private:
    OSMetaClassDeclareReservedUnused(IOFWReadCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFWReadCommand, 1);
};

#pragma mark -

/*!
	@class IOFWReadQuadCommand
	@discussion An easier to use version of IOFWReadCommand for use when the data to be transferred
	is an integer number of quads.
	Note that block read requests will be used for transfers greater than one quad unless setMaxPacket(4)
	is called.
*/

class IOFWReadQuadCommand : public IOFWAsyncCommand
{
    OSDeclareDefaultStructors(IOFWReadQuadCommand)

protected:

    UInt32 *	fQuads;

	typedef struct 
	{ 
		bool	fPingTime;
	}
	MemberVariables;
	
	bool createMemberVariables( void );
	void destroyMemberVariables( void );
	virtual void free( void );
	
    virtual void 	gotPacket(int rcode, const void* data, int size);

    virtual IOReturn	execute();

public:
    virtual bool	initAll(IOFireWireNub *device, FWAddress devAddress,
				UInt32 *quads, int numQuads,
				FWDeviceCallback completion, void *refcon, bool failOnReset);

    virtual bool	initAll(IOFireWireController *control,
                                UInt32 generation, FWAddress devAddress,
                                UInt32 *quads, int numQuads,
                                FWDeviceCallback completion, void *refcon);
    
    virtual IOReturn	reinit(FWAddress devAddress, UInt32 *quads, int numQuads,
				FWDeviceCallback completion=NULL, void *refcon=NULL,
				bool failOnReset=false);

    virtual IOReturn	reinit(UInt32 generation, FWAddress devAddress, UInt32 *quads, int numQuads,
                                FWDeviceCallback completion=NULL, void *refcon=NULL);

	void setPingTime( bool state ) 
		{ ((MemberVariables*)fMembers->fSubclassMembers)->fPingTime = state; };    

private:
    OSMetaClassDeclareReservedUnused(IOFWReadQuadCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFWReadQuadCommand, 1);
};

#pragma mark -

class IOFWWriteCommand : public IOFWAsyncCommand
{

    OSDeclareDefaultStructors(IOFWWriteCommand)

protected:

    int			fPackSize;
	
	typedef struct 
	{ 
		bool 	fDeferredNotify;
		bool	fFastRetryOnBusy;
	}
	MemberVariables;
		
    virtual IOReturn	execute();

    virtual void 	gotPacket( int rcode, const void* data, int size );

	bool createMemberVariables( void );
	void destroyMemberVariables( void );
	
public:

	virtual bool	initWithController(IOFireWireController *control);
    virtual bool	initAll(	IOFireWireNub *			device, 
								FWAddress 				devAddress,
								IOMemoryDescriptor *	hostMem,
								FWDeviceCallback 		completion, 
								void *					refcon, 
								bool 					failOnReset );
								
    virtual bool	initAll(	IOFireWireController *	control,
                                UInt32 					generation, 
								FWAddress 				devAddress,
                                IOMemoryDescriptor *	hostMem,
                                FWDeviceCallback 		completion, 
								void *					refcon );
	virtual void free( void );
								
    virtual IOReturn	reinit(	FWAddress 				devAddress, 
								IOMemoryDescriptor *	hostMem,
								FWDeviceCallback 		completion = NULL, 
								void *					refcon = NULL,
								bool 					failOnReset = false );
								
    virtual IOReturn	reinit(	UInt32 					generation, 
								FWAddress 				devAddress, 
								IOMemoryDescriptor *	hostMem,
                                FWDeviceCallback		completion = NULL, 
								void *					refcon = NULL );

	void setDeferredNotify( bool state ) 
		{ ((MemberVariables*)fMembers->fSubclassMembers)->fDeferredNotify = state; };

	void setFastRetryOnBusy( bool state ) 
		{ ((MemberVariables*)fMembers->fSubclassMembers)->fFastRetryOnBusy = state; };
	
private:

    OSMetaClassDeclareReservedUnused(IOFWWriteCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFWWriteCommand, 1);

};

#pragma mark -

/*!
	@class IOFWWriteQuadCommand
	@discussion An easier to use version of IOFWWriteCommand for use when the data to be transferred
	is small and an integer number of quads.
	Note that block read requests will be used for transfers greater than one quad unless setMaxPacket(4)
	is called.
	kMaxWriteQuads is the largest legal number of quads that this object can be asked to transfer
	(the data is copied into an internal buffer in init() and reinit()).
*/

class IOFWWriteQuadCommand : public IOFWAsyncCommand
{

    OSDeclareDefaultStructors(IOFWWriteQuadCommand)

public:

    enum 
	{
        kMaxWriteQuads = 8
    };
    
protected:

    UInt32					fQuads[kMaxWriteQuads];
    UInt32 *				fQPtr;
    int						fPackSize;
	
	typedef struct 
	{ 
		bool 					fDeferredNotify;
		IOMemoryDescriptor *	fMemory;
	} 
	MemberVariables;
	
    virtual void 	gotPacket( int rcode, const void* data, int size );

    virtual IOReturn	execute();

	bool createMemberVariables( void );
	void destroyMemberVariables( void );
	
public:
	virtual bool	initWithController(IOFireWireController *control);
    
	virtual bool	initAll(	IOFireWireNub *		device, 
								FWAddress 			devAddress,
								UInt32 *			quads, 
								int 				numQuads,
								FWDeviceCallback	completion, 
								void *				refcon, 
								bool 				failOnReset );
								
    virtual bool	initAll(	IOFireWireController *	control,
                                UInt32 					generation, 
								FWAddress 				devAddress,
                                UInt32 *				quads, 
								int 					numQuads,
                                FWDeviceCallback 		completion, 
								void *					refcon );

	virtual void free( void );

    virtual IOReturn	reinit(	FWAddress 			devAddress, 
								UInt32 *			quads, 
								int 				numQuads,
								FWDeviceCallback	completion = NULL, 
								void *				refcon = NULL,
								bool 				failOnReset = false );
								
    virtual IOReturn	reinit(	UInt32 				generation, 
								FWAddress 			devAddress, 
								UInt32 *			quads, 
								int 				numQuads,
                                FWDeviceCallback 	completion = NULL, 
								void *				refcon = NULL );

protected:
	
	void setQuads( UInt32 * quads, int numQuads );
	bool createMemoryDescriptor( void );
	void destroyMemoryDescriptor( void );

public:

 	void setDeferredNotify( bool state ) 
		{ ((MemberVariables*)fMembers->fSubclassMembers)->fDeferredNotify = state; };
	
private:
    
	OSMetaClassDeclareReservedUnused(IOFWWriteQuadCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFWWriteQuadCommand, 1);

};

/*
 * May need more parameters for some of these,
 * and/or derive from a base Lock transaction command
 */

#pragma mark -

/*! @class IOFWCompareAndSwapCommand
*/
class IOFWCompareAndSwapCommand : public IOFWAsyncCommand
{
    OSDeclareDefaultStructors(IOFWCompareAndSwapCommand)

protected:
    UInt32 					fInputVals[4];
    UInt32 					fOldVal[2];
	
	typedef struct 
	{ 
		IOMemoryDescriptor *	fMemory;
	} 
	MemberVariables;
	
	MemberVariables * fMembers;

    virtual void 	gotPacket(int rcode, const void* data, int size);

    virtual IOReturn	execute();

public:
    // Compare to cmpVal, and if equal replace with newVal.
    // Size = 1 for 32 bit operation (one quad), 2 for 64 bit (two quads)
	virtual bool	initWithController(IOFireWireController *control);
    virtual bool	initAll(IOFireWireNub *device, FWAddress devAddress,
				const UInt32 *cmpVal, const UInt32 *newVal, int size,
				FWDeviceCallback completion, void *refcon, bool failOnReset);
    virtual bool	initAll(IOFireWireController *control,
                                UInt32 generation, FWAddress devAddress,
                                const UInt32 *cmpVal, const UInt32 *newVal, int size,
                                FWDeviceCallback completion, void *refcon);

    virtual IOReturn	reinit(FWAddress devAddress, const UInt32 *cmpVal, const UInt32 *newVal, int size,
                                FWDeviceCallback completion=NULL, void *refcon=NULL, bool failOnReset=false);
    virtual IOReturn	reinit(UInt32 generation, FWAddress devAddress,
                                const UInt32 *cmpVal, const UInt32 *newVal, int size,
                                FWDeviceCallback completion=NULL, void *refcon=NULL);

    // sets oldVal to the old value returned by the device, and
    // returns true if it was the expected value, ie. the lock succeeded
    virtual bool	locked(UInt32 *oldVal);

	virtual void free( void );

protected:

	bool createMemberVariables( void );
	void destroyMemberVariables( void );
	
	void setInputVals( const UInt32 *	cmpVal, const UInt32 * newVal, int size );

	bool createMemoryDescriptor( void );
	void destroyMemoryDescriptor( void );
    
private:
    OSMetaClassDeclareReservedUnused(IOFWCompareAndSwapCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFWCompareAndSwapCommand, 1);
    OSMetaClassDeclareReservedUnused(IOFWCompareAndSwapCommand, 2);
    OSMetaClassDeclareReservedUnused(IOFWCompareAndSwapCommand, 3);

};

/*
 * Send an async stream packet
 */

#pragma mark -

/*! @class IOFWAsyncStreamCommand
*/
class IOFWAsyncStreamCommand : public IOFWCommand
{
	// temporary for debugging:
	friend class IOFireWireUserClient ;

	OSDeclareDefaultStructors(IOFWAsyncStreamCommand)

protected:
    FWAsyncStreamCallback	fComplete;
    void *					fRefCon;
    IOMemoryDescriptor 		* fMemDesc;
    int						fSpeed;
    int						fSize;
    int						fCurRetries;
    int						fMaxRetries;
    int						fChannel;
    int						fSyncBits;
    int						fTag;
    UInt32					fGeneration;	// bus topology fNodeID is valid for.
    bool					fFailOnReset;

	typedef struct 
	{ 	} 
	MemberVariables;

    MemberVariables * fMembers;		
	
    virtual IOReturn	complete(
    							IOReturn 				status);
    							
	// To be called by IOFireWireController and derived classes.
    virtual IOReturn	execute();

public:

    virtual bool		initAll(
    							IOFireWireController 	* control,
                                UInt32 					generation, 
                                UInt32 					channel,
                                UInt32 					sync,
                                UInt32 					tag,
                                IOMemoryDescriptor 		* hostMem,
                                UInt32					size,
                                int						speed,
                                FWAsyncStreamCallback	completion,
                                void 					* refcon);

	virtual void free( void );

    virtual IOReturn	reinit(	UInt32 					generation, 
                                UInt32 					channel,
                                UInt32 					sync,
                                UInt32 					tag,
                                IOMemoryDescriptor 		* hostMem,
                                UInt32					size,
                                int						speed,
                               	FWAsyncStreamCallback	completion,
                                void 					* refcon);
								
    virtual void				gotAck(
    							int 					ackCode);
	// Utility for setting generation on newly created command
	virtual void				setGeneration(
								UInt32 					generation)
	{ fGeneration = generation; }

 
    // update nodeID/generation after bus reset, from the device object
    IOReturn		updateGeneration();
    
    bool		failOnReset() const
    { return fFailOnReset; }

private:
    OSMetaClassDeclareReservedUnused(IOFWAsyncStreamCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFWAsyncStreamCommand, 1);

public:
    virtual bool		initAll(
    							IOFireWireController 	* control,
                                UInt32 					generation, 
                                UInt32 					channel,
                                UInt32 					sync,
                                UInt32 					tag,
                                IOMemoryDescriptor 		* hostMem,
                                UInt32					size,
                                int						speed,
                                FWAsyncStreamCallback	completion,
                                void 					* refcon,
								bool					failOnReset );
								
    
	virtual IOReturn	reinit(
								UInt32 					generation, 
                                UInt32 					channel,
                                UInt32 					sync,
                                UInt32 					tag,
                                IOMemoryDescriptor 		* hostMem,
                                UInt32					size,
                                int						speed,
                                FWAsyncStreamCallback 	completion,
                                void 					* refcon,
								bool					failOnReset);
	

};

/*
 * Send an async PHY packet
 */

#pragma mark -

/*! @class IOFWAsyncPHYCommand
*/
class IOFWAsyncPHYCommand : public IOFWCommand
{
	// temporary for debugging:
	friend class IOFireWireUserClient;

	OSDeclareDefaultStructors( IOFWAsyncPHYCommand )

protected:
	AsyncPendingTrans *		fTrans;
    FWAsyncPHYCallback		fComplete;
    void *					fRefCon;
    int						fCurRetries;
    int						fMaxRetries;
    UInt32					fGeneration;
    bool					fFailOnReset;
	UInt32					fData1;
	UInt32					fData2;
	int						fAckCode;
	UInt32					fResponseCode;
		
	typedef struct 
	{ 	} 
	MemberVariables;

    MemberVariables * fMembers;		
	
    virtual IOReturn	complete(
    							IOReturn 				status );
    							
	// To be called by IOFireWireController and derived classes.
    virtual IOReturn	execute();

	void setResponseCode( UInt32 rcode );
	void setAckCode( int ack );

public:

    virtual bool		initAll(
    							IOFireWireController 	* control,
                                UInt32 					generation, 
                                UInt32					data1,
								UInt32					data2,
                                FWAsyncPHYCallback		completion,
                                void 					* refcon,
								bool 					failOnReset );
	virtual void free( void );

    virtual IOReturn	reinit(	UInt32 					generation, 
								UInt32					data1,
								UInt32					data2,
                               	FWAsyncPHYCallback		completion,
                                void 					* refcon,
								bool 					failOnReset );

    virtual void				gotAck(
    							int 					ackCode );
								
	// Utility for setting generation on newly created command
	virtual void				setGeneration(
								UInt32 					generation )
			{ fGeneration = generation; }

 
    // update nodeID/generation after bus reset, from the device object
    IOReturn		updateGeneration();
    
    bool		failOnReset() const
		{ return fFailOnReset; }
    

	virtual void gotPacket( int rcode  );

	int getAckCode( void );
	UInt32 getResponseCode( void ) const;

	void setRetries( int retries);
private:
    OSMetaClassDeclareReservedUnused(IOFWAsyncPHYCommand, 0);
    OSMetaClassDeclareReservedUnused(IOFWAsyncPHYCommand, 1);
    OSMetaClassDeclareReservedUnused(IOFWAsyncPHYCommand, 2);
    OSMetaClassDeclareReservedUnused(IOFWAsyncPHYCommand, 3);
    OSMetaClassDeclareReservedUnused(IOFWAsyncPHYCommand, 4);
    OSMetaClassDeclareReservedUnused(IOFWAsyncPHYCommand, 5);
    OSMetaClassDeclareReservedUnused(IOFWAsyncPHYCommand, 6);
    OSMetaClassDeclareReservedUnused(IOFWAsyncPHYCommand, 7);
};

#endif /* _IOKIT_IOFWCOMMAND_H */
                                                                                                                                                                                                                                                                                                                                                                    IOFWDCL.h                                                                                           0100644 0001750 0001750 00000017764 12567451747 035130  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
*  IOFWDCL.h
*  IOFireWireFamily
*
*  Created by Niels on Fri Feb 21 2003.
*  Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
*
*	$Log: not supported by cvs2svn $
*	Revision 1.19  2007/03/14 01:01:12  collin
*	*** empty log message ***
*	
*	Revision 1.18  2007/01/26 23:42:19  ayanowit
*	another fix for nuDCL rosetta mode
*	
*	Revision 1.17  2006/08/16 01:41:41  collin
*	*** empty log message ***
*	
*	Revision 1.16  2006/03/09 22:26:46  niels
*	fix 4466075
*	
*	Revision 1.15  2006/03/09 22:20:14  niels
*	fix 4466075
*	
*	Revision 1.14  2006/03/09 21:40:44  niels
*	fix 4466075
*	
*	Revision 1.13  2006/02/09 00:21:50  niels
*	merge chardonnay branch to tot
*	
*	Revision 1.12.4.1  2005/08/06 01:31:31  collin
*	*** empty log message ***
*	
*	Revision 1.12  2005/02/18 03:19:03  niels
*	fix isight
*	
*	Revision 1.11  2004/04/19 21:51:49  niels
*	*** empty log message ***
*	
*	Revision 1.10  2004/03/25 00:00:23  niels
*	fix panic allocating large physical address spaces
*	
*	Revision 1.9  2003/10/31 02:40:58  niels
*	*** empty log message ***
*	
*	Revision 1.8  2003/08/26 05:11:21  niels
*	*** empty log message ***
*	
*	Revision 1.7  2003/08/25 08:39:15  niels
*	*** empty log message ***
*	
*	Revision 1.6  2003/08/18 23:18:14  niels
*	*** empty log message ***
*	
*	Revision 1.5  2003/08/08 22:30:32  niels
*	*** empty log message ***
*	
*	Revision 1.4  2003/07/30 05:22:14  niels
*	*** empty log message ***
*	
*	Revision 1.3  2003/07/29 22:49:22  niels
*	*** empty log message ***
*	
*	Revision 1.2  2003/07/21 06:52:58  niels
*	merge isoch to TOT
*	
*	Revision 1.1.2.5  2003/07/18 00:17:41  niels
*	*** empty log message ***
*	
*	Revision 1.1.2.4  2003/07/14 22:08:53  niels
*	*** empty log message ***
*	
*	Revision 1.1.2.3  2003/07/11 18:15:33  niels
*	*** empty log message ***
*	
*	Revision 1.1.2.2  2003/07/03 22:10:24  niels
*	fix iidc/dv rcv
*	
*	Revision 1.1.2.1  2003/07/01 20:54:06  niels
*	isoch merge
*	
*/

#import <IOKit/firewire/IOFireWireFamilyCommon.h>

#import <libkern/c++/OSObject.h>
#import <libkern/c++/OSSet.h>
#import <IOKit/IOTypes.h>

class IODCLProgram ;
class OSIterator ;
class IOFireWireLink ;
class IOMemoryMap ;

/*! @class IOFWDCL
*/

class IOFWDCL : public OSObject
{
	OSDeclareAbstractStructors( IOFWDCL ) ;
	
	public:
	
		typedef void (*Callback)( void * refcon ) ;

		enum
		{
			kDynamic					= BIT(1)//kNuDCLDynamic,
			,kUpdateBeforeCallback		= BIT(2)//kNuDCLUpdateBeforeCallback
			,kUser						= BIT(18) // kNuDCLUser
			,kBigEndianUpdates			= BIT(19) // NOTE: Don't change this without making similar change to IOFireWireLib's NuDCL::Export(...)!
		} ;

		class InternalData 
		{
			public:
			
				IOFWDCL *			lastBranch ;
		} ;

	protected:
		
		IOFWDCL*			fBranch ;
		Callback			fCallback ;
		volatile UInt32 *	fTimeStampPtr ;
		UInt32				fRangeCount ;
		IOVirtualRange *	fRanges ;
		OSSet*				fUpdateList ;
		OSIterator *		fUpdateIterator ;
		volatile UInt32 *	fUserStatusPtr ;
		void*				fRefcon ;
		UInt32				fFlags ;
		
		InternalData *		fLoLevel ;

	public:

		//
		// IOFWDCL public API:
		//
		
		virtual bool		initWithRanges ( 
											OSSet * 				updateSet, 
											unsigned 				rangesCount = 0, 
											IOVirtualRange 			ranges [] = NULL ) ;

		void				setBranch( IOFWDCL* branch ) ;
		IOFWDCL*			getBranch()	const ;
		void				setTimeStampPtr ( UInt32* timeStampPtr ) ;
		UInt32*				getTimeStampPtr () const ;
		void				setCallback( Callback callback ) ;
		Callback			getCallback() const ;
		void				setStatusPtr( UInt32* statusPtr ) ;
		UInt32*				getStatusPtr() const ;
		void				setRefcon( void * refcon ) ;
		void *				getRefcon() const ;
		const OSSet*		getUpdateList() const ;
		
		virtual IOReturn	addRange ( IOVirtualRange& range ) ;
		virtual IOReturn	setRanges ( UInt32 numRanges, IOVirtualRange ranges[] ) ;
		virtual UInt32		getRanges( UInt32 maxRanges, IOVirtualRange ranges[] ) const ;
		virtual UInt32		countRanges() ;
		virtual IOReturn	getSpan( IOVirtualRange& result ) const ;
		virtual IOByteCount	getSize() const ;
		IOReturn			appendUpdateList( IOFWDCL* updateDCL ) ;
		IOReturn			setUpdateList( OSSet* updateList ) ;
		void				emptyUpdateList() ; 
		void				setFlags( UInt32 flags ) ;
		UInt32				getFlags() const ;
		

		virtual void		update() = 0 ;

		// OSObject
		
		virtual void		free () ;
		
	public:
		
		//
		// internal use only; please don't use... 
		//
		
		virtual IOReturn				compile( IODCLProgram & , bool & ) = 0 ;
		virtual void					link () = 0 ;

		OSMetaClassDeclareReservedUnused ( IOFWDCL, 4 ) ;		// used to be relink()

	public :
		virtual bool					interrupt( bool &, IOFWDCL * & ) = 0 ;
		virtual void					finalize ( IODCLProgram & ) ;
		virtual IOReturn				importUserDCL (
														UInt8 *				data,
														IOByteCount &		dataSize,
														IOMemoryMap *		bufferMap,
														const OSArray *		dcl ) ;
			
	protected :
	
		friend class IOFWDCLFriend ;
		
	public :
	
		// dump DCL info...
		virtual void					debug() ;

	public:
		
		//
		// internal use only; please don't use... 
		//
		
		virtual bool					checkForInterrupt() = 0 ;

    OSMetaClassDeclareReservedUsed ( IOFWDCL, 0 ) ;
    OSMetaClassDeclareReservedUnused ( IOFWDCL, 1 ) ;
    OSMetaClassDeclareReservedUnused ( IOFWDCL, 2 ) ;
    OSMetaClassDeclareReservedUnused ( IOFWDCL, 3 ) ;
//	OSMetaClassDeclareReservedUnused ( ***, 4 ) ;			// used above

} ;

#pragma mark -

/*! @class IOFWReceiveDCL
*/

class IOFWReceiveDCL : public IOFWDCL
{
	OSDeclareAbstractStructors( IOFWReceiveDCL )

	protected :
	
		UInt8		fHeaderBytes ;
		bool		fWait ;
	
	public:

		// me
		virtual bool		initWithParams( 
											OSSet *				updateSet, 
											UInt8				headerBytes, 
											unsigned			rangesCount, 
											IOVirtualRange		ranges [] ) ;	
		IOReturn			setWaitControl( bool wait ) ;

	public :

		// internal use only:
		virtual IOReturn				importUserDCL (
														UInt8 *				data,
														IOByteCount &		dataSize,
														IOMemoryMap *		bufferMap,
														const OSArray *		dcl ) ;
	
	protected :
	
		virtual void		debug() ;

} ;

#pragma mark -

/*! @class IOFWSendDCL
*/

class IOFWSendDCL : public IOFWDCL
{
	OSDeclareAbstractStructors( IOFWSendDCL )

	protected:
	
		UInt32 * 	fUserHeaderPtr ;			// pointer to 2 quadlets containing isoch header for this packet
		UInt32 *	fUserHeaderMaskPtr ;		// pointer to 2 quadlets; used to mask header quadlets
		IOFWDCL *	fSkipBranchDCL ;
		Callback	fSkipCallback ;
		void *		fSkipRefcon ;
		UInt8		fSync ;
		UInt8		fTag ;

	public:

		// OSObject
		virtual void		free() ;
		
		// IOFWDCL
		virtual IOReturn	addRange ( IOVirtualRange& range ) ;
		virtual IOReturn	setRanges ( UInt32 numRanges, IOVirtualRange ranges[] ) ;

		// me
		virtual bool		initWithParams( OSSet * 				updateSet, 
											unsigned 				rangesCount = 0, 
											IOVirtualRange 			ranges [] = NULL,
											UInt8					sync = 0,
											UInt8					tag = 0 ) ;
		
		void				setUserHeaderPtr( UInt32* userHeaderPtr, UInt32 * maskPtr ) ;
		UInt32 *			getUserHeaderPtr() ;
		UInt32 *			getUserHeaderMask() ;
		void				setSkipBranch( IOFWDCL * skipBranchDCL ) ;
		IOFWDCL *			getSkipBranch() const ;
		void				setSkipCallback( Callback callback ) ;
		Callback			getSkipCallback() const ;
		void				setSkipRefcon( void * refcon = 0 ) ;
		void *				getSkipRefcon() const ;										
		void				setSync( UInt8 sync ) ;
		UInt8				getSync() const ;												
		void				setTag( UInt8 tag ) ;											
		UInt8				getTag() const ;

	public :
	
		// internal use only:
		virtual IOReturn				importUserDCL (
														UInt8 *				data,
														IOByteCount &		dataSize,
														IOMemoryMap *		bufferMap,
														const OSArray *		dcl ) ;
	protected :
	
		virtual void		debug() ;
} ;

#pragma mark -

/*! @class IOFWSkipCycleDCL
*/

class IOFWSkipCycleDCL : public IOFWDCL
{
	OSDeclareAbstractStructors( IOFWSkipCycleDCL )

	public:
	
		virtual bool		init() ;
		
		virtual IOReturn	addRange ( IOVirtualRange& range ) ;
		virtual IOReturn	setRanges ( UInt32 numRanges, IOVirtualRange ranges[] ) ;
		virtual IOReturn	getSpan( IOVirtualRange& result ) ;

	protected :
	
		virtual void		debug() ;
} ;
            IOFWDCLPool.h                                                                                       0100644 0001750 0001750 00000010140 12567451747 035737  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 *  IOFWNuDCLPool.h
 *  IOFireWireFamily
 *
 *  Created by Niels on Fri Mar 07 2003.
 *  Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 *	$Log: not supported by cvs2svn $
 *	Revision 1.14  2008/03/03 23:31:42  ayanowit
 *	another gcc-42 fix.
 *	
 *	Revision 1.13  2007/01/26 20:52:31  ayanowit
 *	changes to user-space isoch stuff to support 64-bit apps.
 *	
 *	Revision 1.12  2006/02/09 00:21:50  niels
 *	merge chardonnay branch to tot
 *	
 *	Revision 1.11  2005/04/12 20:09:13  niels
 *	fix memory leak importing NuDCL programs from user space
 *	
 *	Revision 1.10.20.2  2006/01/31 04:49:50  collin
 *	*** empty log message ***
 *	
 *	Revision 1.10  2003/11/07 21:24:28  niels
 *	*** empty log message ***
 *	
 *	Revision 1.9  2003/11/07 21:01:18  niels
 *	*** empty log message ***
 *	
 *	Revision 1.8  2003/08/25 08:39:15  niels
 *	*** empty log message ***
 *	
 *	Revision 1.7  2003/08/22 18:15:16  niels
 *	*** empty log message ***
 *	
 *	Revision 1.6  2003/08/15 04:36:55  niels
 *	*** empty log message ***
 *	
 *	Revision 1.5  2003/07/30 05:22:14  niels
 *	*** empty log message ***
 *	
 *	Revision 1.4  2003/07/21 08:48:20  niels
 *	*** empty log message ***
 *	
 *	Revision 1.3  2003/07/21 07:52:13  niels
 *	*** empty log message ***
 *	
 *	Revision 1.2  2003/07/21 06:52:58  niels
 *	merge isoch to TOT
 *	
 *	Revision 1.1.2.3  2003/07/11 18:15:34  niels
 *	*** empty log message ***
 *	
 *	Revision 1.1.2.2  2003/07/09 21:24:00  niels
 *	*** empty log message ***
 *	
 *	Revision 1.1.2.1  2003/07/01 20:54:06  niels
 *	isoch merge
 *	
 */

#import <libkern/c++/OSObject.h>
#import <libkern/c++/OSArray.h>
#import <IOKit/IOTypes.h>

class IOFireWireLink ;
class IOFWDCL ;
class IOFWReceiveDCL ;
class IOFWSendDCL ;
class IOFWSkipCycleDCL ;
class IOFireWireUserClient ;
class IOMemoryDescriptor ;
class IOMemoryMap ;
class OSSet;

/*! @class IOFWDCLPool
	@discussion You should never subclass IOFWDCLPool 
*/

class IOFWDCLPool : public OSObject
{
	OSDeclareAbstractStructors( IOFWDCLPool )

	friend class IOFireWireUserClient ;
	friend class IOFWUserLocalIsochPort ;
	
	protected:
	
		class Expansion*		fReserved ;		// for class expansion

		IOFireWireLink *		fLink ;
		UInt8					fCurrentTag ;
		UInt8					fCurrentSync ;
		OSArray*				fProgram ;
		DCLNuDCLLeader			fLeader ;
	
	public:
		
		// OSObject
		
		virtual void						free() ;
		
		// me
		
		virtual bool	 					initWithLink ( IOFireWireLink& link, UInt32 capacity ) ;
		
		virtual void						setCurrentTagAndSync ( UInt8 tag, UInt8 sync ) ;
		
		virtual IOFWReceiveDCL*				appendReceiveDCL ( 
													OSSet * 				updateSet, 
													UInt8 					headerBytes,
													UInt32					rangesCount,
													IOVirtualRange			ranges[] ) ;
		virtual IOFWSendDCL*				appendSendDCL ( 
													OSSet * 				updateSet, 
													UInt32					rangesCount,
													IOVirtualRange			ranges[] ) ;
		virtual IOFWSkipCycleDCL*			appendSkipCycleDCL () ;
		virtual const OSArray *				getProgramRef () const ;
		
	protected :
	
		IOReturn							importUserProgram (
													IOMemoryDescriptor *	userExportDesc,
													unsigned				bufferRangeCount,
													IOAddressRange			bufferRanges[],
													IOMemoryMap *			bufferMap ) ;
		IOReturn							importUserDCL(
													IOFWDCL *				dcl,
													void * 					importData,
													IOByteCount &			dataSize,
													IOMemoryMap *			bufferMap ) ;
													

	protected :
	
		virtual IOFWReceiveDCL *			allocReceiveDCL () = 0 ;
		virtual IOFWSendDCL *				allocSendDCL () = 0 ;
		virtual IOFWSkipCycleDCL *			allocSkipCycleDCL () = 0 ;

	private :
	
		void								appendDCL( IOFWDCL * dcl ) ;

	public :
	
		DCLCommand *						getProgram() ;
													
    OSMetaClassDeclareReservedUnused ( IOFWDCLPool, 0);
    OSMetaClassDeclareReservedUnused ( IOFWDCLPool, 1);
    OSMetaClassDeclareReservedUnused ( IOFWDCLPool, 2);
    OSMetaClassDeclareReservedUnused ( IOFWDCLPool, 3);
    OSMetaClassDeclareReservedUnused ( IOFWDCLPool, 4);
    OSMetaClassDeclareReservedUnused ( IOFWDCLPool, 5);
    OSMetaClassDeclareReservedUnused ( IOFWDCLPool, 6);
    OSMetaClassDeclareReservedUnused ( IOFWDCLPool, 7);		
} ;
                                                                                                                                                                                                                                                                                                                                                                                                                                IOFWDCLProgram.h                                                                                    0100644 0001750 0001750 00000007671 12567451747 036454  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999-2002 Apple Computer, Inc.  All rights reserved.
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_IOFWDCLPROGRAM_H
#define _IOKIT_IOFWDCLPROGRAM_H

#include <libkern/c++/OSObject.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h>
#include <IOKit/firewire/IOFireWireBus.h>
#include <IOKit/IOMemoryCursor.h>

/*! @class IODCLProgram
*/
class IODCLProgram : public OSObject
{
    OSDeclareAbstractStructors(IODCLProgram)

	private :	
	
		void * 						reserved0 ;//fDCLTaskToKernel;
		void * 						reserved1 ;//fDataTaskToKernel;
		void *		 				reserved2 ;//fDataBase;
		void *		 				reserved3 ;//		IOMemoryDescriptor *		fDCLDesc;
		IOMemoryMap *				fBufferMem ;
		void *		 				reserved5 ;//		IOMemoryCursor *			fDataCursor;

	protected:
	
	/*! @struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
		*/    
		struct ExpansionData 
		{
			IOFWIsochResourceFlags		resourceFlags ;
            IODMACommand *              fDMACommand;
		};
		
	/*! @var reserved
		Reserved for future use.  (Internal use only)  */
		ExpansionData *					fExpansionData ;
	
	public :
	
		virtual void			setIsochResourceFlags ( IOFWIsochResourceFlags flags ) ;	// formerly getPhysicalSegs()
		IOFWIsochResourceFlags	getIsochResourceFlags () const ;
		
	protected:
	
		virtual void 			free () ;
	
	public:
	
		virtual bool 			init ( IOFireWireBus::DCLTaskInfo * info = NULL ) ;
		virtual IOReturn 		allocateHW (
										IOFWSpeed 			speed, 
										UInt32 				chan) = 0;
		virtual IOReturn 		releaseHW () = 0;
		virtual IOReturn 		compile (
										IOFWSpeed 			speed, 
										UInt32 				chan) = 0;
		virtual IOReturn 		notify (
												IOFWDCLNotificationType		notificationType,
												DCLCommand ** 				dclCommandList, 
												UInt32 						numDCLCommands ) = 0;
		virtual IOReturn 		start () = 0;
		virtual void 			stop () = 0;
		virtual IOReturn 		pause ();
		virtual IOReturn 		resume ();
				
		virtual void			setForceStopProc( 
												IOFWIsochChannel::ForceStopNotificationProc proc, 
												void * 						refCon,
												IOFWIsochChannel *			channel ) ;
	protected :
	
		void					generateBufferMap( DCLCommand * program ) ;
		IOReturn				virtualToPhysical( 
												IOVirtualRange						ranges[], 
												unsigned							rangeCount, 
												IOMemoryCursor::IOPhysicalSegment	outSegments[], 
												unsigned &							outPhysicalSegmentCount, 
												unsigned							maxSegments ) ;

	public :
	
		IOMemoryMap *			getBufferMap() const ;

	public :
	
		// close/open isoch workloop gate...
		// clients should not need to call these.
		virtual void			closeGate() = 0 ;
		virtual void			openGate() = 0 ;

		virtual IOReturn		synchronizeWithIO() = 0 ;
		
	private:
	
		OSMetaClassDeclareReservedUsed(IODCLProgram, 0);
		OSMetaClassDeclareReservedUsed(IODCLProgram, 1);
		OSMetaClassDeclareReservedUnused(IODCLProgram, 2);
		OSMetaClassDeclareReservedUnused(IODCLProgram, 3);
		OSMetaClassDeclareReservedUnused(IODCLProgram, 4);
	
};

#endif /* ! _IOKIT_IOFWDCLPROGRAM_H */

                                                                       IOFWDCLTranslator.h                                                                                 0100644 0001750 0001750 00000006322 12567451747 037166  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999-2002 Apple Computer, Inc.  All rights reserved.
 *
 * A DCL program to interpret (in software) a program that's too complicated
 * for the DMA engine.
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_IOFWDCLTRANSLATOR_H
#define _IOKIT_IOFWDCLTRANSLATOR_H

#include <libkern/c++/OSObject.h>
#include <IOKit/firewire/IOFWDCLProgram.h>


/*! @class IODCLTranslator
*/

class IODCLTranslator : public IODCLProgram
{
    OSDeclareAbstractStructors(IODCLTranslator)

protected:
    enum
    {
        kNumPingPongs				= 2,
        kNumPacketsPerPingPong		= 500,
        kMaxIsochPacketSize			= 1000,
        kPingPongBufferSize			= kNumPingPongs * kNumPacketsPerPingPong * kMaxIsochPacketSize
    };

    // Opcodes and buffer for pingpong program
    DCLLabel			fStartLabel;
    DCLTransferPacket	fTransfers[kNumPingPongs*kNumPacketsPerPingPong];
    DCLCallProc			fCalls[kNumPingPongs];
    DCLJump				fJumpToStart;
    UInt8				fBuffer[kPingPongBufferSize];

    IODCLProgram *		fHWProgram;				// Hardware program executing our opcodes
    DCLCommand*			fToInterpret;			// The commands to interpret
    DCLCommand*			fCurrentDCLCommand;		// Current command to interpret
    int					fPingCount;				// Are we pinging or ponging?
    UInt32				fPacketHeader;

    static void ListeningDCLPingPongProc(DCLCommand* pDCLCommand);
    static void TalkingDCLPingPongProc(DCLCommand* pDCLCommand);

public:
    virtual bool init(DCLCommand* toInterpret);
    virtual IOReturn allocateHW(IOFWSpeed speed, UInt32 chan);
    virtual IOReturn releaseHW();
    virtual IOReturn notify(IOFWDCLNotificationType notificationType,
	DCLCommand** dclCommandList, UInt32 numDCLCommands);
    virtual void stop();

    DCLCommand* getTranslatorOpcodes();
    void setHWProgram(IODCLProgram *program);
};

/*! @class IODCLTranslateTalk
*/

class IODCLTranslateTalk : public IODCLTranslator
{
    OSDeclareDefaultStructors(IODCLTranslateTalk)

protected:

public:
    virtual IOReturn compile(IOFWSpeed speed, UInt32 chan);
    virtual IOReturn start();

};

/*! @class IODCLTranslateListen
*/

class IODCLTranslateListen : public IODCLTranslator
{
    OSDeclareDefaultStructors(IODCLTranslateListen)

protected:

public:
    virtual IOReturn compile(IOFWSpeed speed, UInt32 chan);
    virtual IOReturn start();

};
#endif /* ! _IOKIT_IOFWDCLPROGRAM_H */

                                                                                                                                                                                                                                                                                                              IOFWIsochChannel.h                                                                                  0100644 0001750 0001750 00000010232 12567451747 037043  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999-2002 Apple Computer, Inc.  All rights reserved.
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_IOFWISOCHCHANNEL_H
#define _IOKIT_IOFWISOCHCHANNEL_H

#include <libkern/c++/OSObject.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h>

enum
{
    kFWIsochChannelUnknownCondition	= 0,
    kFWIsochChannelNotEnoughBandwidth	= 1,
    kFWIsochChannelChannelNotAvailable	= 2
};

class IOFireWireController;
class IOFWIsochChannel;
class IOFWIsochPort;
class OSSet;
class IOFWReadQuadCommand;
class IOFWCompareAndSwapCommand;

/*! @class IOFWIsochChannel
*/
class IOFWIsochChannel : public OSObject
{
    OSDeclareDefaultStructors(IOFWIsochChannel)

	public:

		typedef IOReturn (ForceStopNotificationProc)(void* refCon, IOFWIsochChannel* channel, UInt32 stopCondition );

protected:
    IOFireWireController *			fControl;
    ForceStopNotificationProc* 		fStopProc;
    void *							fStopRefCon;
    IOFWIsochPort *					fTalker;
    OSSet *							fListeners;
    bool							fDoIRM;
    UInt32							fBandwidth;	// Allocation units used
    UInt32							fPacketSize;
    IOFWSpeed						fPrefSpeed;
    IOFWSpeed						fSpeed;		// Actual speed used
    UInt32							fChannel;	// Actual channel used
    IOFWReadQuadCommand *			fReadCmd;
    IOFWCompareAndSwapCommand *		fLockCmd;
    UInt32							fGeneration;	// When bandwidth was allocated
    
	IOLock *		fLock;
	
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

    static void					threadFunc( void * arg );
    
    virtual IOReturn			updateBandwidth(bool claim);
    virtual void				reallocBandwidth( UInt32 generation );	
    virtual void				free();

public:
    // Called from IOFireWireController
    virtual bool 				init( IOFireWireController *control, bool doIRM, UInt32 packetSize, 
										IOFWSpeed prefSpeed, ForceStopNotificationProc* stopProc,
										void *stopRefCon );
    virtual void 				handleBusReset();

    // Called by clients
    virtual IOReturn 			setTalker(IOFWIsochPort *talker);
    virtual IOReturn 			addListener(IOFWIsochPort *listener);

    virtual IOReturn 			allocateChannel();
    virtual IOReturn 			releaseChannel();
    virtual IOReturn 			start();
    virtual IOReturn 			stop();

protected:
	// handles IRM and channel determination and allocation.
	// called by both user and kernel isoch channels
	IOReturn					allocateChannelBegin( IOFWSpeed speed, UInt64 allowedChans, UInt32 * channel = NULL ) ;

	// handles IRM and channel allocation.
	// called by both user and kernel isoch channels
	IOReturn					releaseChannelComplete() ;

	IOReturn	checkMemoryInRange( IOMemoryDescriptor * memory );

private:
    OSMetaClassDeclareReservedUnused(IOFWIsochChannel, 0);
    OSMetaClassDeclareReservedUnused(IOFWIsochChannel, 1);
    OSMetaClassDeclareReservedUnused(IOFWIsochChannel, 2);
    OSMetaClassDeclareReservedUnused(IOFWIsochChannel, 3);

};

typedef IOFWIsochChannel::ForceStopNotificationProc 	FWIsochChannelForceStopNotificationProc ;
typedef IOFWIsochChannel::ForceStopNotificationProc* 	FWIsochChannelForceStopNotificationProcPtr ;

#endif /* ! _IOKIT_IOFWISOCHCHANNEL_H */

                                                                                                                                                                                                                                                                                                                                                                      IOFWIsochPort.h                                                                                     0100644 0001750 0001750 00000004257 12567451747 036431  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999-2002 Apple Computer, Inc.  All rights reserved.
 *
 * IOFWIsochPort is an abstract object that represents hardware on the bus
 * (locally or remotely) that sends or receives isochronous packets.
 * Local ports are implemented by the local device driver,
 * Remote ports are implemented by the driver for the remote device.
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_IOFWISOCHPORT_H
#define _IOKIT_IOFWISOCHPORT_H

#include <libkern/c++/OSObject.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h>

/*! @class IOFWIsochPort
*/

class IOFWIsochPort : public OSObject
{
    OSDeclareAbstractStructors(IOFWIsochPort)

public:
	// Return maximum speed and channels supported
	// (bit n set = chan n supported)
    virtual IOReturn getSupported(IOFWSpeed &maxSpeed, UInt64 &chanSupported) = 0;

	// Allocate hardware resources for port
    virtual IOReturn allocatePort(IOFWSpeed speed, UInt32 chan) = 0;
    virtual IOReturn releasePort() = 0;		// Free hardware resources
    virtual IOReturn start() = 0;		// Start port processing packets
    virtual IOReturn stop() = 0;		// Stop processing packets

private:
    OSMetaClassDeclareReservedUnused(IOFWIsochPort, 0);
    OSMetaClassDeclareReservedUnused(IOFWIsochPort, 1);

};

#endif /* ! _IOKIT_IOFWISOCHPORT_H */

                                                                                                                                                                                                                                                                                                                                                 IOFWLocalIsochPort.h                                                                                0100644 0001750 0001750 00000007740 12567451747 037404  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999-2002 Apple Computer, Inc.  All rights reserved.
 *
 * IOFWIsochPort is an abstract object that represents hardware on the bus
 * (locally or remotely) that sends or receives isochronous packets.
 * Local ports are implemented by the local device driver,
 * Remote ports are implemented by the driver for the remote device.
 *
 * HISTORY
 *
 * $Log: not supported by cvs2svn $
 * Revision 1.9  2003/08/30 00:16:44  collin
 * *** empty log message ***
 *
 * Revision 1.8  2003/08/15 04:36:55  niels
 * *** empty log message ***
 *
 * Revision 1.7  2003/07/29 22:49:22  niels
 * *** empty log message ***
 *
 * Revision 1.6  2003/07/21 06:52:58  niels
 * merge isoch to TOT
 *
 * Revision 1.5.14.1  2003/07/01 20:54:07  niels
 * isoch merge
 *
 */


#ifndef _IOKIT_IOFWLOCALISOCHPORT_H
#define _IOKIT_IOFWLOCALISOCHPORT_H

#import <IOKit/firewire/IOFireWireFamilyCommon.h>
#import <IOKit/firewire/IOFWIsochPort.h>

class IOFireWireController;
class IODCLProgram;

/*! @class IOFWLocalIsochPort
*/
class IOFWLocalIsochPort : public IOFWIsochPort
{
    OSDeclareDefaultStructors(IOFWLocalIsochPort)

	protected:
	
		IOFireWireController *	fControl;
		IODCLProgram *			fProgram;
	
	/*! @struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
		*/    
		struct ExpansionData
		{
		} ;
	
		ExpansionData *			fExpansion ;

	protected :
	
		virtual void 			free ( void ) ;

	public:
	
		virtual bool 			init (
										IODCLProgram *			program, 
										IOFireWireController *	control ) ;
	
		// Return maximum speed and channels supported
		// (bit n set = chan n supported)
		virtual IOReturn 		getSupported (
										IOFWSpeed &				maxSpeed, 
										UInt64 &				chanSupported ) ;
	
		// Allocate hardware resources for port
		virtual IOReturn 		allocatePort (
										IOFWSpeed 				speed, 
										UInt32 					chan ) ;
		virtual IOReturn 		releasePort ( void ) ;	// Free hardware resources
		virtual IOReturn 		start ( void ) ;		// Start port processing packets
		virtual IOReturn 		stop ( void ) ;		// Stop processing packets
	
		/*! @function notify
			@abstract Informs hardware of a change to the DCL program.
			@param notificationType Type of change.
			@param dclCommandList List of DCL commands that have been changed.
			@param numDCLCommands Number of commands in list.
			@result IOKit error code. */
		virtual IOReturn 		notify(
										IOFWDCLNotificationType 	notificationType,
										DCLCommand ** 				dclCommandList, 
										UInt32 						numDCLCommands ) ;
		static void				printDCLProgram (
										const DCLCommand *		dcl,
										UInt32					count = 0,
										void (*printFN)( const char *format, ...) = NULL,
										unsigned				lineDelayMS = 0 ) ;
		IOReturn				setIsochResourceFlags (
										IOFWIsochResourceFlags	flags ) ;
		IODCLProgram *			getProgramRef() const ;

		IOReturn				synchronizeWithIO() ;

	private:

		OSMetaClassDeclareReservedUnused ( IOFWLocalIsochPort, 0 ) ;
		OSMetaClassDeclareReservedUnused ( IOFWLocalIsochPort, 1 ) ;
};

#endif /* ! _IOKIT_IOFWLOCALISOCHPORT_H */

                                IOFWPHYPacketListener.h                                                                             0100644 0001750 0001750 00000005102 12567451747 040003  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 2007 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
 
#ifndef _IOFWPHYPACKETLISTENER_H_
#define _IOFWPHYPACKETLISTENER_H_

#include <libkern/c++/OSObject.h>

class IOFireWireController;

// Callback when phy packet is received
typedef void (*FWPHYPacketCallback)( void *refcon, UInt32 data1, UInt32 data2 );

/*! @class IOFWPHYPacketListener
*/

class IOFWPHYPacketListener : public OSObject
{
	OSDeclareDefaultStructors( IOFWPHYPacketListener );

	friend class IOFireWireController;
	
protected:
	
	IOFireWireController *		fControl;
	FWPHYPacketCallback			fCallback;
	void *						fRefCon;

	static IOFWPHYPacketListener * createWithController( IOFireWireController * controller );

    virtual bool initWithController( IOFireWireController * control );
    virtual void free( void );

public:

	virtual IOReturn activate( void );
	virtual void deactivate( void );

	virtual void setCallback( FWPHYPacketCallback callback );
	virtual void setRefCon( void * refcon );
	virtual void * getRefCon( void );

protected:
	virtual void processPHYPacket( UInt32 data1, UInt32 data2 );

    OSMetaClassDeclareReservedUnused( IOFWPHYPacketListener, 0 );
    OSMetaClassDeclareReservedUnused( IOFWPHYPacketListener, 1 );
    OSMetaClassDeclareReservedUnused( IOFWPHYPacketListener, 2 );
    OSMetaClassDeclareReservedUnused( IOFWPHYPacketListener, 3 );
    OSMetaClassDeclareReservedUnused( IOFWPHYPacketListener, 4 );
    OSMetaClassDeclareReservedUnused( IOFWPHYPacketListener, 5 );
    OSMetaClassDeclareReservedUnused( IOFWPHYPacketListener, 6 );
    OSMetaClassDeclareReservedUnused( IOFWPHYPacketListener, 7 );
    OSMetaClassDeclareReservedUnused( IOFWPHYPacketListener, 8 );
    OSMetaClassDeclareReservedUnused( IOFWPHYPacketListener, 9 );
};

#endif                                                                                                                                                                                                                                                                                                                                                                                                                                                              IOFWPhysicalAddressSpace.h                                                                          0100644 0001750 0001750 00000022523 12567451747 040551  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 
#ifndef _IOKIT_IOFWPHYSICALADDRESSSPACE_H
#define _IOKIT_IOFWPHYSICALADDRESSSPACE_H

#include <IOKit/firewire/IOFWAddressSpace.h>
#include <IOKit/IODMACommand.h>

/*
 * Direct physical memory <-> FireWire address.
 * Accesses to these addresses may be handled automatically by the
 * hardware without notification.
 *
 * The 64 bit FireWire address of (32 bit) physical addr xxxx:xxxx is hostNode:0000:xxxx:xxxx
 */

class IOFWPhysicalAddressSpace;

struct FWSegment
{
	FWAddress	address;
	UInt32		length;
};

#pragma mark -

/*! 
	@class IOFWPhysicalAddressSpaceAux
*/

class IOFWPhysicalAddressSpaceAux : public IOFWAddressSpaceAux
{
    OSDeclareDefaultStructors(IOFWPhysicalAddressSpaceAux)

	friend class IOFWAddressSpace;
	friend class IOFWPhysicalAddressSpace;
	
protected:
	
	/*! 
		@struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
    */  
	  
    struct ExpansionData { };

	/*! 
		@var reserved
		Reserved for future use.  (Internal use only)  
	*/
    
	ExpansionData *reserved;
	
	IODMACommand *	fDMACommand;
	bool			fDMACommandPrepared;
	
public:
    virtual bool init( IOFWAddressSpace * primary );
	virtual	void free();

	void setDMACommand( IODMACommand * dma_command );
	IODMACommand * getDMACommand( void ); 
	UInt64 getPhysicalSegment( UInt64 offset, UInt64 * length );
	
	IOReturn prepare( void );
	IOReturn synchronize( IOOptionBits options );
	IOReturn complete( void );

	bool isPrepared( void );

	IOReturn getSegments( UInt64 * offset, FWSegment * fw_segments, UInt32 * num_segments );
	
private:
    OSMetaClassDeclareReservedUnused(IOFWPhysicalAddressSpaceAux, 0);
    OSMetaClassDeclareReservedUnused(IOFWPhysicalAddressSpaceAux, 1);
    OSMetaClassDeclareReservedUnused(IOFWPhysicalAddressSpaceAux, 2);
    OSMetaClassDeclareReservedUnused(IOFWPhysicalAddressSpaceAux, 3);
    OSMetaClassDeclareReservedUnused(IOFWPhysicalAddressSpaceAux, 4);
    OSMetaClassDeclareReservedUnused(IOFWPhysicalAddressSpaceAux, 5);
    OSMetaClassDeclareReservedUnused(IOFWPhysicalAddressSpaceAux, 6);
    OSMetaClassDeclareReservedUnused(IOFWPhysicalAddressSpaceAux, 7);
    OSMetaClassDeclareReservedUnused(IOFWPhysicalAddressSpaceAux, 8);
    OSMetaClassDeclareReservedUnused(IOFWPhysicalAddressSpaceAux, 9);
	
};

#pragma mark -

/*! 
	@class IOFWPhysicalAddressSpace
*/

class IOFWPhysicalAddressSpace : public IOFWAddressSpace
{
    OSDeclareDefaultStructors(IOFWPhysicalAddressSpace)

	friend class IOFWPhysicalAddressSpaceAux;

protected:
    
	IOMemoryDescriptor *	fMem;	// unused
    vm_size_t				fLen;	// unused
	
    virtual	void 					free();

public:

/*!	@function	init
	@abstract	Initialize physical address space.
	@param		bus	Points to IOFireWireBus object.
	@result		returns true if success, else false */
	virtual bool init( IOFireWireBus * bus );
	
/*!	@function	initWithDesc
	@abstract	Initialize physical address space with IOMemoryDescriptor.
	@param		bus	Points to IOFireWireBus object.
	@param		mem	Points to IOMemoryDescriptor.
	@result		returns true if success, else false */
    virtual bool initWithDesc(IOFireWireBus *bus,
                                        IOMemoryDescriptor *mem);

/*!	@function	doRead
	@abstract	A method for processing an address space read request
	@param		nodeID	FireWire Read from nodeID.
	@param		speed	at this 'speed'.
	@param		addr	with FireWire address 'addr'.
	@param		len		read 'len' bytes from nodeID.
	@param		buf		points to a memory descriptor containing the packet data.
	@param		offset	start from this 'offset' in 'buf'.
	@param		refcon  Can be queried for extra info about the request.
	@result		UIn32	returns kFWResponseComplete on success */
    virtual UInt32 doRead(UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len, 
							IOMemoryDescriptor **buf, IOByteCount * offset,
							IOFWRequestRefCon refcon);

/*!	@function	doWrite
	@abstract	A method for processing an address space write request
	@param		nodeID	FireWire Write to nodeID.
	@param		speed	at this 'speed'.
	@param		addr	with FireWire address 'addr'.
	@param		len		write 'len' bytes to nodeID.
	@param		buf		obtain bytes from location given by 'buf'.
	@param		reqrefcon  Can be queried for extra info about the request.
	@result		UIn32	returns kFWResponseComplete on success */
    virtual UInt32 doWrite(UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len,
                           const void *buf, IOFWRequestRefCon refcon);

/*!	@function	getMemoryDescriptor
	@abstract	Gets the memory descriptor, which is associated to this 
				PhysicalAddressSpace.
	@param		none.
	@result		returns the IOMemoryDescriptor */
	IOMemoryDescriptor * getMemoryDescriptor( void );

/*!	@function	setMemoryDescriptor
	@abstract	Sets the memory descriptor, which will be associated to this 
				PhysicalAddressSpace.
	@param		none.
	@result		returns the IOMemoryDescriptor */
	IOReturn setMemoryDescriptor( IOMemoryDescriptor * descriptor );

/*!	@function	getLength
	@abstract	Get the length of the memory backed by PhysicalAddressSpace.
	@param		none.
	@result		returns the length */
	UInt64 getLength( void );

/*!	@function	setDMACommand
	@abstract	Set the DMACommand for this PhysicalAddressSpace.
	@param		dma_command	Points to IODMACommand object.
	@result		none */
	inline void setDMACommand( IODMACommand * dma_command )
		{ ((IOFWPhysicalAddressSpaceAux*)fIOFWAddressSpaceExpansion->fAuxiliary)->setDMACommand( dma_command ); };
		
/*!	@function	getDMACommand
	@abstract	Get the DMACommand from this PhysicalAddressSpace.
	@param		none.
	@result		return previously assigned IODMACommand, null if not initialized */
	inline IODMACommand * getDMACommand( void )
		{ return ((IOFWPhysicalAddressSpaceAux*)fIOFWAddressSpaceExpansion->fAuxiliary)->getDMACommand(); };

/*!	@function	initWithDMACommand
	@abstract	Initialize physical address space with IODMACommand.
	@param		bus	Points to IOFireWireBus object.
	@param		command	Points to IODMACommand.
	@result		returns true if success, else false */
	virtual bool initWithDMACommand( IOFireWireBus * control, IODMACommand * command );
	
/*!	@function	prepare
	@abstract	Prepare the IODMACommand used by this PhysicalAddressSpace.
	@param		none.
	@result		returns kIOReturnSuccess on success */
	inline IOReturn prepare( void )
		{ return ((IOFWPhysicalAddressSpaceAux*)fIOFWAddressSpaceExpansion->fAuxiliary)->prepare(); };

/*!	@function	synchronize
	@abstract	synchronize the IODMACommand used by this PhysicalAddressSpace.
	@param		none.
	@result		returns kIOReturnSuccess on success */
	inline IOReturn synchronize( IOOptionBits options )
		{ return ((IOFWPhysicalAddressSpaceAux*)fIOFWAddressSpaceExpansion->fAuxiliary)->synchronize( options ); };
		 
/*!	@function	complete
	@abstract	complete the IODMACommand used by this PhysicalAddressSpace.
	@param		none.
	@result		returns kIOReturnSuccess on success */
	inline IOReturn complete( void )
		{ return ((IOFWPhysicalAddressSpaceAux*)fIOFWAddressSpaceExpansion->fAuxiliary)->complete(); };

/*!	@function	isPrepared
	@abstract	Inspects whether the IODMACommand was prepared in this PhysicalAddressSpace.
	@param		none.
	@result		returns true if prepared, else false */
	inline bool isPrepared( void )
		{ return ((IOFWPhysicalAddressSpaceAux*)fIOFWAddressSpaceExpansion->fAuxiliary)->isPrepared(); };

/*!	@function	getSegments
	@abstract	Returns the scatter gather list of memory segments from the IODMACommand
				used in this PhysicalAddressSpace.
	@param		offset		input/output parameter, defines the starting and ending offset in the memory 
							descriptor, relative to any offset passed to the prepare() method.
				FWSegment 	Points to an array of memory segments.
				num_segments Size of the FWSegment array.   
	@result		returns kIOReturnSuccess on success */
	inline IOReturn getSegments( UInt64 * offset, FWSegment * fw_segments, UInt32 * num_segments )
		{ return ((IOFWPhysicalAddressSpaceAux*)fIOFWAddressSpaceExpansion->fAuxiliary)->getSegments( offset, fw_segments, num_segments ); };

/*!	@function	checkMemoryInRange
	@abstract	Validates the IOMemoryDescriptor, which is used to initialize the PhysicalAddressSpace.
	@param		memory	Points to a valid IOMemoryDescriptor.
	@result		returns kIOReturnSuccess on success */
	IOReturn checkMemoryInRange( IOMemoryDescriptor * memory );
		
protected:

	UInt64 getPhysicalSegment( UInt64 offset, UInt64 * length )
		{ return ((IOFWPhysicalAddressSpaceAux*)fIOFWAddressSpaceExpansion->fAuxiliary)->getPhysicalSegment( offset, length); };
			
	virtual IOFWAddressSpaceAux * createAuxiliary( void );
    	
};

#endif
                                                                                                                                                                             IOFWPseudoAddressSpace.h                                                                            0100644 0001750 0001750 00000033516 12567451747 040240  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 
#ifndef _IOKIT_IOFWPSEUDOADDRESSSPACE_H
#define _IOKIT_IOFWPSEUDOADDRESSSPACE_H

#include <IOKit/firewire/IOFWAddressSpace.h>

/*
 * If installed, this callback is invoked for drivers which 
 * would like to coalesce incoming writes and do batch processing 
 * of incoming block write packets.
 * This callback can be installed by calling setARxReqIntCompleteHandler
 * method in IOFWPseudoAddressSpace object. 
 */
typedef void (*IOFWARxReqIntCompleteHandler)( void * refcon );

/*
 * Pseudo firewire addresses usually represent emulated registers of some kind.
 * Accesses to these addresses will result in the owner being notified.
 * 
 * Virtual addresses should not have zero as the top 16 bits of the 48 bit local address,
 * since that may look like a physical address to hardware (eg. OHCI).
 * if reader is NULL then reads will not be allowed.
 * if writer is NULL then writes will not be allowed.
 * if either is NULL then lock requests will not be allowed.
 * refcon is passed back as the first argument of read and write callbacks.
 */

class IOFWPseudoAddressSpace;

#pragma mark -

/*! 
	@class IOFWPseudoAddressSpaceAux
*/

class IOFWPseudoAddressSpaceAux : public IOFWAddressSpaceAux
{
    OSDeclareDefaultStructors(IOFWPseudoAddressSpaceAux)

	friend class IOFWAddressSpace;
	friend class IOFWPseudoAddressSpace;
	friend class IOFireWireController;
		
protected:
	
    struct MemberVariables 
	{ 		
		IOFWARxReqIntCompleteHandler		fARxReqIntCompleteHandler;
		void *	  							fARxReqIntCompleteHandlerRefcon;	
	};
	  
    MemberVariables * fMembers;

public:
     
	virtual bool init( IOFWAddressSpace * primary );
	virtual	void free();

protected:

	bool createMemberVariables( void );
	void destroyMemberVariables( void );
	
	virtual void handleARxReqIntComplete();
		
public:

/*!	@function setARxReqIntCompleteHandler
	@abstract Installs a callback to receive notification, when FWIM has completed
			  ARxReqInt processing and no incoming packets are left in the queue.
	@param refcon	Client's callback object.
	@param handler	Client callback to be invoked, at the end of interrupt processing.
	@result none.	*/	
	virtual void setARxReqIntCompleteHandler( void * refcon, IOFWARxReqIntCompleteHandler handler );

	virtual bool intersects( IOFWAddressSpace * space );
	
private:

    OSMetaClassDeclareReservedUsed(IOFWPseudoAddressSpaceAux, 0);
    OSMetaClassDeclareReservedUsed(IOFWPseudoAddressSpaceAux, 1);
    OSMetaClassDeclareReservedUnused(IOFWPseudoAddressSpaceAux, 2);
    OSMetaClassDeclareReservedUnused(IOFWPseudoAddressSpaceAux, 3);
    OSMetaClassDeclareReservedUnused(IOFWPseudoAddressSpaceAux, 4);
    OSMetaClassDeclareReservedUnused(IOFWPseudoAddressSpaceAux, 5);
    OSMetaClassDeclareReservedUnused(IOFWPseudoAddressSpaceAux, 6);
    OSMetaClassDeclareReservedUnused(IOFWPseudoAddressSpaceAux, 7);
    OSMetaClassDeclareReservedUnused(IOFWPseudoAddressSpaceAux, 8);
    OSMetaClassDeclareReservedUnused(IOFWPseudoAddressSpaceAux, 9);
	
};

/*! 
	@class IOFWPseudoAddressSpace
*/

class IOFWPseudoAddressSpace : public IOFWAddressSpace
{
    OSDeclareDefaultStructors(IOFWPseudoAddressSpace)

	friend class IOFWPseudoAddressSpaceAux;
	friend class IOFireWireController;
	
protected:

    IOMemoryDescriptor*	fDesc;
    void *				fRefCon;
    FWReadCallback		fReader;
    FWWriteCallback		fWriter;
    FWAddress			fBase;
    UInt32				fLen;

/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

    static	OSData *	allocatedAddresses; // unused
    
    virtual	void 					free();
	
public:

/*!	@function	simpleReader
	@abstract	A method for processing an address space read request
	@param		refcon		Client's callback object.
	@param		nodeID		FireWire Read from nodeID.
	@param		speed		at this 'speed'.
	@param		addr		with FireWire address 'addr'.
	@param		len			read 'len' bytes from nodeID.
	@param		buf			points to a memory descriptor containing the packet data.
	@param		offset		start from this 'offset' in 'buf'.
	@param		reqrefcon	Can be queried for extra info about the request.
	@result		UIn32		returns kFWResponseComplete on success */
    static 	UInt32 					simpleReader(
											void*					refcon,
											UInt16 					nodeID,
											IOFWSpeed &				speed,
											FWAddress 				addr,
											UInt32 					len,
											IOMemoryDescriptor**	buf,
											IOByteCount* 			offset,
                                            IOFWRequestRefCon		reqrefcon);

/*!	@function	simpleWriter
	@abstract	A method for processing an address space write request
	@param		refcon		Client's callback object.
	@param		nodeID		FireWire Write to nodeID.
	@param		speed		at this 'speed'.
	@param		addr		with FireWire address 'addr'.
	@param		len			write 'len' bytes to nodeID.
	@param		buf			obtain bytes from location given by 'buf'.
	@param		reqrefcon	Can be queried for extra info about the request.
	@result		UIn32		returns kFWResponseComplete on success */
    static 	UInt32 					simpleWriter(
											void*					refcon,
											UInt16 					nodeID,
											IOFWSpeed&				speed,
											FWAddress 				addr,
											UInt32 					len,
											const void*				buf,
                                            IOFWRequestRefCon		reqrefcon);
protected:

    // Get a unique address range
    IOReturn						allocateAddress(
											FWAddress*				addr,
											UInt32 					len);
    // free address
    void							freeAddress(
											FWAddress 				addr,
											UInt32 					len);

public:

    static IOFWPseudoAddressSpace*	readWrite(
											FWAddress 				addr,
											UInt32 					len, 
											FWReadCallback 			reader,
											FWWriteCallback 		writer,
											void*					refcon);

/*!	@function	simpleRead
	@abstract	Create an address space object to handle read-only memory (eg. the local ROM)
				handles everything itself
	@param		bus		Points to IOFireWireBus object.
	@param		addr	Points to starting address for the Pseudo Address Space.
	@param		len		Length of the Pseudo Address Space.
	@param		data	The virtual address of the first byte in the memory.
	@result		returns valid IOFWPseudoAddressSpace on success, null on failure */
    static IOFWPseudoAddressSpace*	simpleRead(
                                            IOFireWireBus*			bus,
			                                FWAddress*				addr,
											UInt32 					len,
											const void*				data);

/*!	@function	simpleReadFixed
	@abstract	Create an address space object to handle fixed read-only memory (eg. the local ROM)
				handles everything itself
	@param		bus		Points to IOFireWireBus object.
	@param		addr	Points to starting address for the Pseudo Address Space.
	@param		len		Length of the Pseudo Address Space.
	@param		data	The virtual address of the first byte in the memory.
	@result		returns valid IOFWPseudoAddressSpace on success, null on failure */
    static IOFWPseudoAddressSpace*	simpleReadFixed(
                                            IOFireWireBus*			bus,
			                                FWAddress 				addr,
											UInt32 					len,
											const void*				data);

/*!	@function	simpleRW
	@abstract	Create an address space object to handle r/w memory
				handles everything itself
	@param		bus		Points to IOFireWireBus object.
	@param		addr	Points to starting address for the Pseudo Address Space.
	@param		len		Length of the Pseudo Address Space.
	@param		data	The virtual address of the first byte in the memory.
	@result		returns valid IOFWPseudoAddressSpace on success, null on failure */
    static IOFWPseudoAddressSpace*	simpleRW(
                                            IOFireWireBus*			bus,
                                			FWAddress*				addr,
											UInt32 					len,
											void *					data);
											
/*!	@function	simpleRW
	@abstract	Create an address space object to handle r/w memory
				handles everything itself
	@param		bus		Points to IOFireWireBus object.
	@param		addr	Points to starting address for the Pseudo Address Space.
	@param		data	The virtual address of the first byte in the memory.
	@result		returns valid IOFWPseudoAddressSpace on success, null on failure */
    static IOFWPseudoAddressSpace*	simpleRW(
                                            IOFireWireBus*			bus,
                                			FWAddress*				addr,
											IOMemoryDescriptor *	data);
											
/*!	@function	initAll
	@abstract	Initialize an address space object to handle r/w memory
	@param		bus		Points to IOFireWireBus object.
	@param		addr	Points to starting address for the Pseudo Address Space.
	@param		len		Length of the Pseudo Address Space.
	@param		reader	Callback handler for incoming Read.
	@param		writer	Callback handler for incoming Write.
	@param		refcon	Client's callback object.
	@result		returns true on success, false on failure */
    virtual bool 					initAll(
                                            IOFireWireBus*			bus,
                							FWAddress*				addr,
											UInt32 					len, 
											FWReadCallback 			reader,
											FWWriteCallback 		writer,
											void*					refcon);
											
/*!	@function	initFixed
	@abstract	Initialize a fixed address space at top of kCSRRegisterSpaceBaseAddressHi
	@param		bus		Points to IOFireWireBus object.
	@param		addr	Points to starting address for the Pseudo Address Space.
	@param		reader	Callback handler for incoming Read.
	@param		writer	Callback handler for incoming Write.
	@param		refcon	Client's callback object.
	@result		returns true on success, false on failure */
    virtual bool 					initFixed(
                                            IOFireWireBus*			bus,
							                FWAddress 				addr,
											UInt32 					len,
                							FWReadCallback 			reader,
											FWWriteCallback 		writer,
											void*					refcon);

/*!	@function	doRead
	@abstract	A method for processing an address space read request
	@param		nodeID	FireWire Read from nodeID.
	@param		speed	at this 'speed'.
	@param		addr	with FireWire address 'addr'.
	@param		len		read 'len' bytes from nodeID.
	@param		buf		points to a memory descriptor containing the packet data.
	@param		offset	start from this 'offset' in 'buf'.
	@param		reqrefcon  Can be queried for extra info about the request.
	@result		UIn32	returns kFWResponseComplete on success */
    virtual UInt32 					doRead(
											UInt16 					nodeID, 
											IOFWSpeed &				speed, 
											FWAddress 				addr, 
											UInt32 					len,
                               				IOMemoryDescriptor **	buf, 
											IOByteCount * 			offset,
                                            IOFWRequestRefCon		reqrefcon);
/*!	@function	doWrite
	@abstract	A method for processing an address space write request
	@param		nodeID	FireWire Write to nodeID.
	@param		speed	at this 'speed'.
	@param		addr	with FireWire address 'addr'.
	@param		len		write 'len' bytes to nodeID.
	@param		buf		obtain bytes from location given by 'buf'.
	@param		reqrefcon  Can be queried for extra info about the request.
	@result		UIn32	returns kFWResponseComplete on success */
    virtual UInt32 					doWrite(
											UInt16 					nodeID,
											IOFWSpeed&				speed,
											FWAddress 				addr,
											UInt32 					len, 
											const void*				buf,
                                            IOFWRequestRefCon		reqrefcon);

/*!	@function	contains
	@abstract	returns number of bytes starting at addr in this space
	@result		0 if it doesn't contain the address
	*/
    virtual UInt32					contains(FWAddress addr);

/*!	@function	simpleRWFixed
	@abstract	Create a Read/Write fixed address space at top of kCSRRegisterSpaceBaseAddressHi.
	@param		control	Points to IOFireWireBus object.
	@param		addr	Points to starting address for the Pseudo Address Space.
	@param		len		Length of the address range.
	@param		data	The virtual address of the first byte in the memory.
	@result		returns valid IOFWPseudoAddressSpace on success, null on failure */
	static IOFWPseudoAddressSpace * simpleRWFixed( IOFireWireBus *control, FWAddress addr, UInt32 len, const void *data );

protected:
	
	virtual IOFWAddressSpaceAux * createAuxiliary( void );

protected:
	inline void handleARxReqIntComplete( void )
		{ ((IOFWPseudoAddressSpaceAux*)fIOFWAddressSpaceExpansion->fAuxiliary)->handleARxReqIntComplete(); }
	
public:
/*!	@function setARxReqIntCompleteHandler
	@abstract Installs a callback to receive notification, when FWIM has completed
			  ARxReqInt processing and no incoming packets are left in the queue.
	@param refcon	Client's callback object.
	@param handler	Client callback to be invoked, at the end of interrupt processing.
	@result none.	*/	
	inline void setARxReqIntCompleteHandler( void * refcon, IOFWARxReqIntCompleteHandler handler )
		{ ((IOFWPseudoAddressSpaceAux*)fIOFWAddressSpaceExpansion->fAuxiliary)->setARxReqIntCompleteHandler( refcon, handler ); }
			
private:

    OSMetaClassDeclareReservedUnused(IOFWPseudoAddressSpace, 0);
    OSMetaClassDeclareReservedUnused(IOFWPseudoAddressSpace, 1);
    
};

#endif
                                                                                                                                                                                  IOFWRegs.h                                                                                          0100644 0001750 0001750 00000005750 12567451747 035416  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
* Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
*
* @APPLE_LICENSE_HEADER_START@
* 
* The contents of this file constitute Original Code as defined in and
* are subject to the Apple Public Source License Version 1.1 (the
* "License").  You may not use this file except in compliance with the
* License.  Please obtain a copy of the License at
* http://www.apple.com/publicsource and read it before using this file.
* 
* This Original Code and all software distributed under the License are
* distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
* EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
* INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
* License for the specific language governing rights and limitations
* under the License.
* 
* @APPLE_LICENSE_HEADER_END@
*/
/*
	File:		IOFWRegs.h

	Copyright:	© 1996-1999 by Apple Computer, Inc., all rights reserved.

*/

#ifndef __IOFWREGS_H__
#define __IOFWREGS_H__

#include <IOKit/firewire/IOFireWireFamilyCommon.h>

#ifndef NEW_ERROR_CODES

//	 
// (!)	The following error codes are obsolete...
//		Please use the error codes defined in IOFireWireFamilyCommon.h
//

enum {
	inUseErr					= -4160,				// Item already in use
	notFoundErr					= -4161,				// Item not found
	timeoutErr					= -4162,				// Something timed out
	busReconfiguredErr			= -4163,				// Bus was reconfigured
	invalidIDTypeErr			= -4166,				// Given ID is of an invalid type for the requested operation.
	alreadyRegisteredErr		= -4168,				// Item has already been registered.
	disconnectedErr				= -4169,				// Target of request has been disconnected.
	retryExceededErr			= -4170,				// Retry limit was exceeded.
	addressRangeErr				= -4171,				// Address is not in range.
	addressAlignmentErr			= -4172,				// Address is not of proper alignment.

	multipleTalkerErr			= -4180,				// Tried to install multiple talkers
	channelActiveErr			= -4181,				// Operation not permitted when channel is active
	noListenerOrTalkerErr		= -4182,				// Every isochronous channel must have one talker and at least
														// one listener
	noChannelsAvailableErr		= -4183,				// No supported isochronous channels are available
	channelNotAvailableErr		= -4184,				// Required channel was not available.
	invalidIsochPortIDErr		= -4185,				// An isochronous port ID is invalid.
	invalidFWReferenceTypeErr	= -4186,				// Operation does not support type of given reference ID
	separateBusErr				= -4187,				// Two or more entities are on two or more busses and cannot be associated with eachother.
	badSelfIDsErr				= -4188,				// Received self IDs are bad.

//zzz Do we own these next ID numbers?
	cableVoltageTooLowErr		= -4190,				// Cable power below device's minimum voltage
	cablePowerInsufficientErr	= -4191					// Can't grant power request at this time
};


#endif //NEW_ERROR_CODES

#endif /* __IOFWREGS_H */

                        IOFWSimpleContiguousPhysicalAddressSpace.h                                                          0100644 0001750 0001750 00000004742 12567451747 044006  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 
#ifndef _IOFWSIMPLECONTIGUOUSPHYSICALADDRESSSPACE_H_
#define _IOFWSIMPLECONTIGUOUSPHYSICALADDRESSSPACE_H_

#include <IOKit/firewire/IOFWSimplePhysicalAddressSpace.h>

/*! @class IOFWSimpleContiguousPhysicalAddressSpace
*/

class IOFWSimpleContiguousPhysicalAddressSpace : public IOFWSimplePhysicalAddressSpace
{
	OSDeclareDefaultStructors( IOFWSimpleContiguousPhysicalAddressSpace )

private:

	void * fSimpleContigPhysSpaceMembers;
	
	IOReturn cachePhysicalAddress( void );

protected:	
	virtual bool createMemberVariables( void );
	virtual void destroyMemberVariables( void );

public:

	virtual bool init( IOFireWireBus * control, vm_size_t size, IODirection direction );
	virtual void free( void );

	FWAddress getFWAddress( void );

private:
    OSMetaClassDeclareReservedUnused(IOFWSimpleContiguousPhysicalAddressSpace, 0);
    OSMetaClassDeclareReservedUnused(IOFWSimpleContiguousPhysicalAddressSpace, 1);
    OSMetaClassDeclareReservedUnused(IOFWSimpleContiguousPhysicalAddressSpace, 2);
    OSMetaClassDeclareReservedUnused(IOFWSimpleContiguousPhysicalAddressSpace, 3);
    OSMetaClassDeclareReservedUnused(IOFWSimpleContiguousPhysicalAddressSpace, 4);
    OSMetaClassDeclareReservedUnused(IOFWSimpleContiguousPhysicalAddressSpace, 5);
    OSMetaClassDeclareReservedUnused(IOFWSimpleContiguousPhysicalAddressSpace, 6);
    OSMetaClassDeclareReservedUnused(IOFWSimpleContiguousPhysicalAddressSpace, 7);
    OSMetaClassDeclareReservedUnused(IOFWSimpleContiguousPhysicalAddressSpace, 8);
    OSMetaClassDeclareReservedUnused(IOFWSimpleContiguousPhysicalAddressSpace, 9);

};

#endif
                              IOFWSimplePhysicalAddressSpace.h                                                                    0100644 0001750 0001750 00000004753 12567451747 041730  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 
#ifndef _IOFWSIMPLEPHYSICALADDRESSSPACE_H_
#define _IOFWSIMPLEPHYSICALADDRESSSPACE_H_

#include <libkern/c++/OSObject.h>
#include <IOKit/IOBufferMemoryDescriptor.h>
#include <IOKit/IODMACommand.h>
#include <IOKit/firewire/IOFWPhysicalAddressSpace.h>

/*! @class IOFWSimplePhysicalAddressSpace
*/

class IOFWSimplePhysicalAddressSpace : public IOFWPhysicalAddressSpace
{
	OSDeclareDefaultStructors( IOFWSimplePhysicalAddressSpace )
	
private:

	void *	fSimplePhysSpaceMembers;
		
	IOReturn allocateMemory( void );	
	void deallocateMemory( void );

protected:	
	virtual bool createMemberVariables( void );
	virtual void destroyMemberVariables( void );

public:

	virtual bool init( IOFireWireBus * control, vm_size_t size, IODirection direction, bool contiguous = false );
	virtual void free( void );

	IOVirtualAddress getVirtualAddress( void );

private:
    OSMetaClassDeclareReservedUnused(IOFWSimplePhysicalAddressSpace, 0);
    OSMetaClassDeclareReservedUnused(IOFWSimplePhysicalAddressSpace, 1);
    OSMetaClassDeclareReservedUnused(IOFWSimplePhysicalAddressSpace, 2);
    OSMetaClassDeclareReservedUnused(IOFWSimplePhysicalAddressSpace, 3);
    OSMetaClassDeclareReservedUnused(IOFWSimplePhysicalAddressSpace, 4);
    OSMetaClassDeclareReservedUnused(IOFWSimplePhysicalAddressSpace, 5);
    OSMetaClassDeclareReservedUnused(IOFWSimplePhysicalAddressSpace, 6);
    OSMetaClassDeclareReservedUnused(IOFWSimplePhysicalAddressSpace, 7);
    OSMetaClassDeclareReservedUnused(IOFWSimplePhysicalAddressSpace, 8);
    OSMetaClassDeclareReservedUnused(IOFWSimplePhysicalAddressSpace, 9);
	
};

#endif
                     IOFWSyncer.h                                                                                        0100644 0001750 0001750 00000003230 12567451747 035750  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2007 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 
#ifndef _IOFWSYNCER_H
#define _IOFWSYNCER_H

#include <libkern/c++/OSObject.h>
#include <IOKit/IOTypes.h>
#include <IOKit/IOLocks.h>

class IOFWSyncer : public OSObject
{
    OSDeclareDefaultStructors(IOFWSyncer)

private:
    // The spin lock that is used to guard the 'threadMustStop' variable. 
    IOSimpleLock *guardLock;
    volatile bool threadMustStop;
    IOReturn fResult;
    virtual void free();
    virtual void privateSignal();

public:

    static IOFWSyncer * create(bool twoRetains = true);

    virtual bool init(bool twoRetains);
    virtual void reinit();
    virtual IOReturn wait(bool autoRelease = true);
    virtual void signal(IOReturn res = kIOReturnSuccess,
					bool autoRelease = true);
};

#endif /* !_IOFWSYNCER */

                                                                                                                                                                                                                                                                                                                                                                        IOFWUserObjectExporter.h                                                                            0100644 0001750 0001750 00000006452 12567451747 040314  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2008 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*! @class IOFWUserObjectExporter
	@discussion An IOFWUserObjectExporter is for internal use only. You should never subclass IOFWUserObjectExporter 
*/

	namespace IOFireWireLib
	{
		typedef UInt32      UserObjectHandle;
	}

#ifdef KERNEL

	class IOFWUserObjectExporter : public OSObject
	{
		OSDeclareDefaultStructors (IOFWUserObjectExporter )

		public :
		
			typedef void (*CleanupFunction)( const OSObject * obj );
			typedef void (*CleanupFunctionWithExporter)( const OSObject * obj, IOFWUserObjectExporter * );
			
		private :
		
			unsigned							fCapacity;
			unsigned							fObjectCount;
			const OSObject **					fObjects;
			CleanupFunctionWithExporter *		fCleanupFunctions;
			IOLock *							fLock;
			OSObject *							fOwner;
			
		public :
		
			static IOFWUserObjectExporter *		createWithOwner( OSObject * owner );
			bool								initWithOwner( OSObject * owner );

			virtual bool			init();
	
			virtual void			free ();
			virtual bool			serialize ( OSSerialize * s ) const;
			
			// me
			IOReturn				addObject ( OSObject * obj, CleanupFunction cleanup, IOFireWireLib::UserObjectHandle * outHandle );
			void					removeObject ( IOFireWireLib::UserObjectHandle handle );
			
			// the returned object is retained! This is for thread safety.. if someone else released
			// the object from the pool after you got it, you be in for Trouble
			// Release the returned value when you're done!!
			const OSObject *		lookupObject ( IOFireWireLib::UserObjectHandle handle ) const;
			const OSObject *		lookupObjectForType( IOFireWireLib::UserObjectHandle handle, const OSMetaClass * toType ) const;
			void					removeAllObjects ();

			void					lock () const;
			void					unlock () const;
			
			OSObject *				getOwner() const;
			
			const IOFireWireLib::UserObjectHandle	lookupHandle ( OSObject * object ) const;
		
			// don't subclass, but just in case someone does...
			
		private:
		
			OSMetaClassDeclareReservedUnused(IOFWUserObjectExporter, 0);
			OSMetaClassDeclareReservedUnused(IOFWUserObjectExporter, 1);
			OSMetaClassDeclareReservedUnused(IOFWUserObjectExporter, 2);
			OSMetaClassDeclareReservedUnused(IOFWUserObjectExporter, 3);
			OSMetaClassDeclareReservedUnused(IOFWUserObjectExporter, 4);
			OSMetaClassDeclareReservedUnused(IOFWUserObjectExporter, 5);
			OSMetaClassDeclareReservedUnused(IOFWUserObjectExporter, 6);
			OSMetaClassDeclareReservedUnused(IOFWUserObjectExporter, 7);
				
	};

#endif
                                                                                                                                                                                                                      IOFWUtils.h                                                                                         0100644 0001750 0001750 00000001277 12567451747 035616  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 *  IOFWUtils.h
 *  IOFireWireFamily
 *
 *  Created by Niels on Fri Aug 16 2002.
 *  Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 */

#import <IOKit/IOTypes.h>

////////////////////////////////////////////////////////////////////////////////
//
// Useful FireWire utility functions.
//

#ifdef __cplusplus
extern "C" {
#endif

UInt16 FWComputeCRC16(const UInt32 *pQuads, UInt32 numQuads);
UInt16 FWUpdateCRC16(UInt16 crc16, UInt32 quad);

UInt32 AddFWCycleTimeToFWCycleTime( UInt32 cycleTime1, UInt32 cycleTime2 );
UInt32 SubtractFWCycleTimeFromFWCycleTime( UInt32 cycleTime1, UInt32 cycleTime2);

void IOFWGetAbsoluteTime( AbsoluteTime * result );
	
#ifdef __cplusplus
}
#endif

                                                                                                                                                                                                                                                                                                                                 IOFireWireBus.h                                                                                     0100644 0001750 0001750 00000040146 12567451747 036445  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999-2002 Apple Computer, Inc.  All rights reserved.
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_IOFIREWIREBUS_H
#define _IOKIT_IOFIREWIREBUS_H

#include <IOKit/IOService.h>
#include <IOKit/firewire/IOFWIsochChannel.h>
#include <IOKit/firewire/IOFWAddressSpace.h>
#include <IOKit/firewire/IOFWCommand.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h>

extern const OSSymbol *gFireWireROM;
extern const OSSymbol *gFireWireNodeID;
extern const OSSymbol *gFireWireSelfIDs;
extern const OSSymbol *gFireWireSpeed;
extern const OSSymbol *gFireWireUnit_Spec_ID;
extern const OSSymbol *gFireWireUnit_SW_Version;
extern const OSSymbol *gFireWireVendor_ID;
extern const OSSymbol *gFireWire_GUID;
extern const OSSymbol *gFireWireVendor_Name;
extern const OSSymbol *gFireWireProduct_Name;
extern const OSSymbol *gFireWireModel_ID;
extern const OSSymbol *gFireWireTDM;

class IOFireWireDevice;
class IOLocalConfigDirectory;
class IOFWLocalIsochPort;
class IOFireWirePowerManager;
class IOFireWireBus;
class IOFWDCLPool;
class IOFWSimpleContiguousPhysicalAddressSpace;
class IOFWSimplePhysicalAddressSpace;
class IOFWUserObjectExporter;

#pragma mark -

/*! 
	@class IOFireWireBusAux
*/

class IOFireWireBusAux : public OSObject
{
    OSDeclareAbstractStructors(IOFireWireBusAux)

	friend class IOFireWireBus;
	
	protected:
			
		/*! 
			@struct ExpansionData
			@discussion This structure will be used to expand the capablilties of the class in the future.
		*/  
		
		struct ExpansionData { };
	
		/*! 
			@var reserved
			Reserved for future use.  (Internal use only)  
		*/
		
		ExpansionData * reserved;
	
	public :
	
		virtual IOFWDCLPool *							createDCLPool ( unsigned capacity ) const = 0 ;
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 32);
		virtual UInt8 getMaxRec( void ) = 0;

		virtual UInt64 getFireWirePhysicalAddressMask( void ) = 0;
		virtual UInt32 getFireWirePhysicalAddressBits( void ) = 0;
		virtual UInt64 getFireWirePhysicalBufferMask( void ) = 0;
		virtual UInt32 getFireWirePhysicalBufferBits( void ) = 0;

		virtual IOFWSimpleContiguousPhysicalAddressSpace * createSimpleContiguousPhysicalAddressSpace( vm_size_t size, IODirection direction ) = 0;
		virtual IOFWSimplePhysicalAddressSpace * createSimplePhysicalAddressSpace( vm_size_t size, IODirection direction ) = 0;

		virtual IOFWUserObjectExporter * getSessionRefExporter( void ) = 0;
	
	private:
		OSMetaClassDeclareReservedUsed(IOFireWireBusAux, 0);
		OSMetaClassDeclareReservedUsed(IOFireWireBusAux, 1);
		OSMetaClassDeclareReservedUsed(IOFireWireBusAux, 2);
		OSMetaClassDeclareReservedUsed(IOFireWireBusAux, 3);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 4);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 5);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 6);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 7);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 8);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 9);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 10);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 11);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 12);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 13);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 14);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 15);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 16);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 17);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 18);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 19);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 20);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 21);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 22);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 23);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 24);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 25);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 26);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 27);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 28);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 29);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 30);
		OSMetaClassDeclareReservedUnused(IOFireWireBusAux, 31);
		
};

#pragma mark -

/*! 
	@class IOFireWireBus
	@abstract IOFireWireBus is a public class the provides access to
		general FireWire functionality...
*/

class IOFireWireBus : public IOService
{
    OSDeclareAbstractStructors(IOFireWireBus)

public:

	struct DCLTaskInfoAux
	{
		unsigned version ;
		union	// u
		{
			struct	// v0
			{
				IOMemoryMap * bufferMemoryMap ;				// This field required to get physical addresses to program DMA.
															// If NULL, we try to make the map ourselves.
															// If you created a buffer memory descriptor
															// for your program's buffers, just call map() on it
															// and pass the returned object here...
			} v0 ;
			
			struct  // v1
			{
				IOMemoryMap * bufferMemoryMap ;				// same as 'bufferMemoryMap' from version 0, above.
				
				IOWorkLoop * workloop ;						// A workloop on which to run callbacks for this port..
															// Can be NULL to use FireWire isochronous workloop...
															// The workloop will be retained by the program object.
			} v1 ;
			
			struct
			{
				IOMemoryMap * bufferMemoryMap ;				// same as 'bufferMemoryMap' from version 0, above.
				
				IOWorkLoop * workloop ;						// A workloop on which to run callbacks for this port..
															// Can be NULL to use FireWire isochronous workloop...
															// The workloop will be retained by the program object.
				IOFWIsochPortOptions options ;				// extra options
			} v2 ;
		} u ;
	} ;
	
	// this struct has been redefined for our next generation isochronous architecture,
	// but is backwards compatible with the old definition.. This means we should
	// be safe when an old-style driver is loaded..
	// To use DCLTaskInfo (see createLocalIsochPort) make sure all 'unused' fields are set to 0 or NULL
	// and that auxInfo points to a valid DCLTaskInfoAux struct, defined above.
	
	struct DCLTaskInfo
	{
		task_t 				unused0 ;
		vm_address_t 		unused1 ;
		UInt32 				unused2 ;
		vm_address_t 		unused3 ;
		UInt32 				unused4 ;
		void				(*unused5)(void) ;
		DCLTaskInfoAux *	auxInfo ;	// Refcon for user call
	} ;

	static const IORegistryPlane * gIOFireWirePlane;

	IOFireWireBusAux * fAuxiliary;

    // Create an Isochronous Channel object
    virtual IOFWIsochChannel *createIsochChannel(
        bool doIRM, UInt32 bandwidth, IOFWSpeed prefSpeed,
        IOFWIsochChannel::ForceStopNotificationProc stopProc=NULL,
        void *stopRefCon=NULL) = 0;
 
	/*!	@function createLocalIsochPort
		@abstract Create a local isochronous port to run the given DCL program
		@param talking Pass true to create a talker port; pass false to create a listener port.
		@param opcodes A pointer to your DCL program (linked list of DCLCommand structs)
			To use an IOFWDCL/IOFWDCLPool program, pass the DCLCommand returned by
			IOFWDCLPool::getProgram().
		@param info (Optional) Pointer to DCLTaskInfo struct containing additional
			configuration information. If you have an IOMemoryMap for your DCL program data buffers,
			pass it here. You can also pass an IOWorkLoop if you want to use your own
			workloop to handle callbacks for the created port object.
		@param startEvent Specifies a bus condition on which the port should start receiving/sending packets
			Must be kFWDCLImmediateEvent, kFWDCLCycleEvent, or kFWDCLSyBitsEvent.
			Pass kFWDCLImmediateEvent to start without waiting when start() is called. Pass kFWDCLCycleEvent
			to start() transmitting at a specified bus cycle time. Pass kFWDCLSyBitsEvent (receive only)
			to start receiving packets once an isochronous packet with a specified sync field arrives.
		@param startState Pass the value for the desired start condition, as specified by 'startEvent'
			kFWDCLImmediateEvent: set to 0
			kFWDCLCycleEvent: the cycle timer value on which to start processing packets. For talker
				ports, This value will be masked by 'startMask' and packet processing will be begin on the 
				next cycle whose lowest bits match the masked value. For listener ports, pass a 15-bit value
				containg to the low order two bits of cycleSeconds and the 13-bit cycleCount on which to start
				processing packets.
			kFWDCLSyBitsEvent: The value of the sync field on which to start receive packets. The value will be masked
				by 'startMask'. For DCLCommand based isoch ports, processing will begin on the first received packet 
				that has an isochronous header sync field matching 'startState'. For IOFWDCL/IOFWDCLPool based
				ports, processing will pause on each IOFWDCL that has wait set to true until a packet that has
				an isochronous header sync field matching 'startState' is received.
		@result Returns an IOFWLocalIsochPort on success.*/
    virtual IOFWLocalIsochPort *createLocalIsochPort(bool talking,
        DCLCommand *opcodes, DCLTaskInfo *info = 0,
        UInt32 startEvent = 0, UInt32 startState = 0, UInt32 startMask = 0) = 0;

    virtual IOReturn getCycleTime(UInt32 &cycleTime) = 0;
    virtual IOReturn getBusCycleTime(UInt32 &busTime, UInt32 &cycleTime) = 0;

    // Methods to manipulate the local Config ROM
    virtual IOReturn AddUnitDirectory(IOLocalConfigDirectory *unitDir) = 0;
    virtual IOReturn RemoveUnitDirectory(IOLocalConfigDirectory *unitDir) = 0;

    // Cause a bus reset
    virtual IOReturn resetBus() = 0;

    // Convert a firewire nodeID into the IOFireWireDevice for it
    virtual IOFireWireDevice * nodeIDtoDevice(UInt32 generation, UInt16 nodeID) = 0;

    // Execute specified function on workloop after specified delay
    // Returned command is for delay, call it's cancel() function to cancel timeout.
    virtual IOFWDelayCommand * createDelayedCmd(UInt32 uSecDelay, FWBusCallback func, void *refcon) = 0;

    virtual IOFWPhysicalAddressSpace *createPhysicalAddressSpace(IOMemoryDescriptor *mem) = 0;
    virtual IOFWPseudoAddressSpace *createPseudoAddressSpace(FWAddress *addr, UInt32 len,
                                FWReadCallback reader, FWWriteCallback writer, void *refcon) = 0;


    // Extract info about the async request
    virtual bool isLockRequest(IOFWRequestRefCon refcon) = 0;
    virtual bool isQuadRequest(IOFWRequestRefCon refcon) = 0;
    virtual UInt32 getExtendedTCode(IOFWRequestRefCon refcon) = 0;

    // How big (as a power of two) can packets sent to/received from the node be?
    virtual int maxPackLog ( bool forSend, UInt16 nodeAddress) const = 0;

    // How big (as a power of two) can packets sent from A to B be?
    virtual int maxPackLog ( UInt16 nodeA, UInt16 nodeB) const = 0;

    // Force given node to be root (via root holdoff Phy packet)
    virtual IOReturn makeRoot ( UInt32 generation, UInt16 nodeID) = 0;

    // Create address space at fixed address in initial register space
    virtual IOFWPseudoAddressSpace * createInitialAddressSpace (	UInt32 addressLo, UInt32 len,
																	FWReadCallback reader, FWWriteCallback writer, void *refcon) = 0;

    // Get address space object for given address, if any
    virtual IOFWAddressSpace *						getAddressSpace(FWAddress address) = 0;

    // Extract info about the async request - was the request ack'ed complete already?
    virtual bool									isCompleteRequest(IOFWRequestRefCon refcon) = 0;
    
    virtual IOFWAsyncStreamCommand *				createAsyncStreamCommand( UInt32 generation,
															UInt32 channel, UInt32 sync, UInt32 tag, IOMemoryDescriptor *hostMem,
															UInt32 size, int speed,FWAsyncStreamCallback completion=NULL, void *refcon=NULL) = 0;
	virtual UInt32									hopCount(UInt16 nodeAAddress, UInt16 nodeBAddress ) = 0;
	virtual UInt32									hopCount(UInt16 nodeAAddress ) = 0;
	virtual IOFireWirePowerManager *				getBusPowerManager( void ) = 0;

protected:

	virtual IOFireWireBusAux *						createAuxiliary( void ) = 0;

	public :
	
		inline IOFWDCLPool *						createDCLPool ( UInt32 capacity = 0 )			{ return fAuxiliary->createDCLPool ( capacity ) ; }
		inline UInt8								getMaxRec( void )								{ return fAuxiliary->getMaxRec(); }

		// get the physical addressing limitations for this controller

		// returns the physical mask for memory addressable by the bus and this controller's DMA engine
		// intended for use with IOBufferMemoryDescriptor::inTaskWithPhysicalMask()
		// all current hardware is 32 bit --- currently returns 0x00000000FFFFFFFF
		// this API is intended for allocating physical buffers. 
		// it will not return more than 48 bits so that buffer addresses can be turned into FWAddresses
		inline UInt64 getFireWirePhysicalAddressMask( void )
			{ return fAuxiliary->getFireWirePhysicalAddressMask(); }
		
		// returns a count of the maximum addressing bits supported by the bus and this controller
		// intended for use with IODMACommand::withSpecification()
		// all current hardware is 32 bit --- currently returns 32
		// this API is intended for allocating physical buffers. 
		// it will not return more than 48 bits so that buffer addresses can be turned into FWAddresses
		inline UInt32 getFireWirePhysicalAddressBits( void )
			{ return fAuxiliary->getFireWirePhysicalAddressBits(); }

		// returns the physical mask for memory addressable by this controller's DMA engine
		// intended for use with IOBufferMemoryDescriptor::inTaskWithPhysicalMask()
		// all current hardware is 32 bit --- currently returns 0x00000000FFFFFFFF
		// this API is to allocate isoch and other buffers that don't need to be addressable by the bus 
		// it may someday return as high 64 bits
		inline UInt64 getFireWirePhysicalBufferMask( void )
			{ return fAuxiliary->getFireWirePhysicalBufferMask(); }
		
		// returns a count of the maximum addressing bits supported by this controller
		// intended for use with IODMACommand::withSpecification()
		// all current hardware is 32 bit --- currently returns 32
		// this API is to allocate isoch and other buffers that don't need to be addressable by the bus 
		// it may someday return as high 64 bits
		inline UInt32 getFireWirePhysicalBufferBits( void )
			{ return fAuxiliary->getFireWirePhysicalBufferBits(); }

		inline IOFWSimpleContiguousPhysicalAddressSpace * createSimpleContiguousPhysicalAddressSpace( vm_size_t size, IODirection direction )
			{ return fAuxiliary->createSimpleContiguousPhysicalAddressSpace( size, direction ); }
			
		inline IOFWSimplePhysicalAddressSpace * createSimplePhysicalAddressSpace( vm_size_t size, IODirection direction )
			{ return fAuxiliary->createSimplePhysicalAddressSpace( size, direction ); }

		virtual IOFWAsyncStreamCommand * createAsyncStreamCommand( UInt32 generation,
															UInt32 channel, UInt32 sync, UInt32 tag, IOMemoryDescriptor *hostMem,
															UInt32 size, int speed,FWAsyncStreamCallback completion, void *refcon, bool	failOnReset) = 0;
	
		inline IOFWUserObjectExporter * getSessionRefExporter( void )
			{ return fAuxiliary->getSessionRefExporter(); }
	
	private:
	
		OSMetaClassDeclareReservedUsed(IOFireWireBus, 0);
		OSMetaClassDeclareReservedUsed(IOFireWireBus, 1);
		OSMetaClassDeclareReservedUsed(IOFireWireBus, 2);
		OSMetaClassDeclareReservedUsed(IOFireWireBus, 3);
		OSMetaClassDeclareReservedUsed(IOFireWireBus, 4);
		OSMetaClassDeclareReservedUsed(IOFireWireBus, 5);
		OSMetaClassDeclareReservedUsed(IOFireWireBus, 6);
		OSMetaClassDeclareReservedUsed(IOFireWireBus, 7);

};

#endif /* ! _IOKIT_IOFIREWIREBUS_H */

                                                                                                                                                                                                                                                                                                                                                                                                                          IOFireWireController.h                                                                              0100644 0001750 0001750 00000110550 12567451747 040034  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999-2002 Apple Computer, Inc.  All rights reserved.
 *
 * HISTORY
 *
 */

#ifndef _IOKIT_IOFIREWIRECONTROLLER_H
#define _IOKIT_IOFIREWIRECONTROLLER_H

#ifndef FIREWIREPRIVATE
#warning Please do not include this file. Include IOFireWireBus.h instead.
#endif

#include <IOKit/IOEventSource.h>
#include <IOKit/firewire/IOFireWireBus.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h>
#include <IOKit/firewire/IOFireWireIRMAllocation.h>
#include <IOKit/firewire/IOFWPHYPacketListener.h>
#include <IOKit/firewire/IOFireWireMultiIsochReceive.h>

class OSData;
class IOWorkLoop;
class IOEventSource;
class IOFWQEventSource;
class IOTimerEventSource;
class IOMemoryDescriptor;
class IOFireWireController;
class IOFWAddressSpace;
class IOFWPseudoAddressSpace;
class IOFireWireNub;
class IOFireWireDevice;
class IOFireWireDeviceAux;
class IOFireWireUnit;
class IODCLProgram;
class IOLocalConfigDirectory;
class IOFireWireLink;
class IOFireWireSBP2ORB;
class IOFireWireSBP2Login;
class IOFireWireROMCache;
class IOFireWireLocalNode;
class IOFWWorkLoop;
class IOFireWireIRM;
class IOFireWirePowerManager;
class IOFWSimplePhysicalAddressSpace;
class IOFWSimpleContiguousPhysicalAddressSpace;
class IOFWAsyncStreamReceiver;
class IOFWAsyncStreamListener;
class IOFWUserVectorCommand;
class IOFWAsyncPHYCommand;
class IOFWPHYPacketListener;
class IOFWUserPHYPacketListener;

#if FIRELOGCORE
class IOFireLog;
class IOFireLogPublisher;
#endif

const UInt32 kMaxWaitForValidSelfID = 20; // Still invalid SelfID after 20 retries

// Phy packet defs.

enum
{
	kFWPhyPacketID					= FWBitRange (0, 1),
	kFWPhyPacketIDPhase				= FWBitRangePhase (0, 1),

	kFWPhyPacketPhyID				= FWBitRange (2, 7),
	kFWPhyPacketPhyIDPhase			= FWBitRangePhase (2, 7)
};

enum
{
	kSelfIDPacketSize				= 8,
	kMaxSelfIDs						= 4	// SelfID 0,1,3,8
};

enum
{
	kFWConfigurationPacketID		= 0,
	kFWLinkOnPacketID				= 1,
	kFWSelfIDPacketID				= 2
};

enum
{
	kFWPhyConfigurationR					= FW_BIT(8),
	kFWPhyConfigurationT					= FW_BIT(9),
	kFWPhyConfigurationGapCnt				= FWBitRange (10, 15),
	kFWPhyConfigurationGapCntPhase			= FWBitRangePhase (10, 15)
};

enum
{
	kFWSelfIDPortStatusChild				= 3,
	kFWSelfIDPortStatusParent				= 2,
	kFWSelfIDPortStatusNotConnected			= 1,
	kFWSelfIDPortStatusNotPresent			= 0,

	kFWSelfIDNoPower						= 0,
	kFWSelfIDSelfPowered15W					= 1,
	kFWSelfIDSelfPowered30W					= 2,
	kFWSelfIDSelfPowered45W					= 3,
	kFWSelfIDBusPowered1W					= 4,
	kFWSelfIDBusPowered3W					= 5,
	kFWSelfIDBusPowered6W					= 6,
	kFWSelfIDBusPowered10W					= 7,

	kFWSelfIDPhyID							= kFWPhyPacketPhyID,//zzz do we need or want this?
	kFWSelfIDPhyIDPhase						= kFWPhyPacketPhyIDPhase,
	kFWSelfIDM								= FW_BIT(31),

	kFWSelfID0L								= FW_BIT(9),
	kFWSelfID0GapCnt						= FWBitRange (10, 15),
	kFWSelfID0GapCntPhase					= FWBitRangePhase (10, 15),
	kFWSelfID0SP							= FWBitRange (16, 17),
	kFWSelfID0SPPhase						= FWBitRangePhase (16, 17),
	kFWSelfID0Del							= FWBitRange (18, 19),
	kFWSelfID0DelPhase						= FWBitRangePhase (18, 19),
	kFWSelfID0C								= FW_BIT(20),
	kFWSelfID0Pwr							= FWBitRange (21, 23),
	kFWSelfID0PwrPhase						= FWBitRangePhase (21, 23),
	kFWSelfID0P0							= FWBitRange (24, 25),
	kFWSelfID0P0Phase						= FWBitRangePhase (24, 25),
	kFWSelfID0P1							= FWBitRange (26, 27),
	kFWSelfID0P1Phase						= FWBitRangePhase (26, 27),
	kFWSelfID0P2							= FWBitRange (28, 29),
	kFWSelfID0P2Phase						= FWBitRangePhase (28, 29),
	kFWSelfID0I								= FW_BIT(30),

	kFWSelfIDPacketType						= FW_BIT(8),
	kFWSelfIDNN								= FWBitRange (9, 11),
	kFWSelfIDNNPhase						= FWBitRangePhase (9, 11),
	kFWSelfIDNPa							= FWBitRange (14, 15),
	kFWSelfIDNPaPhase						= FWBitRangePhase (14, 15),
	kFWSelfIDNPb							= FWBitRange (16, 17),
	kFWSelfIDNPbPhase						= FWBitRangePhase (16, 17),
	kFWSelfIDNPc							= FWBitRange (18, 19),
	kFWSelfIDNPcPhase						= FWBitRangePhase (18, 19),
	kFWSelfIDNPd							= FWBitRange (20, 21),
	kFWSelfIDNPdPhase						= FWBitRangePhase (20, 21),
	kFWSelfIDNPe							= FWBitRange (22, 23),
	kFWSelfIDNPePhase						= FWBitRangePhase (22, 23),
	kFWSelfIDNPf							= FWBitRange (24, 25),
	kFWSelfIDNPfPhase						= FWBitRangePhase (24, 25),
	kFWSelfIDNPg							= FWBitRange (26, 27),
	kFWSelfIDNPgPhase						= FWBitRangePhase (26, 27),
	kFWSelfIDNPh							= FWBitRange (28, 29),
	kFWSelfIDNPhPhase						= FWBitRangePhase (28, 29),
	kFWSelfIDMore							= FW_BIT(31)
};

// Primary packet defs.
enum
{
	kFWPacketTCode							= FWBitRange (24, 27),
	kFWPacketTCodePhase						= FWBitRangePhase (24, 27)
};


enum
{
	kFWAsynchSpd							= FWBitRange (14, 15),
	kFWAsynchSpdPhase						= FWBitRangePhase (14, 15),

	kFWAsynchTLabel							= FWBitRange (16, 21),
	kFWAsynchTLabelPhase					= FWBitRangePhase (16, 21),
	kFWAsynchTTotal 						= ((0xffffffff & kFWAsynchTLabel) >> kFWAsynchTLabelPhase)+1,
	kFWAsynchRt								= FWBitRange (22, 23),
	kFWAsynchRtPhase						= FWBitRangePhase (22, 23),
	kFWAsynchNew							= 0,
	kFWAsynchRetryA							= 2,
	kTIAsycnhRetryB							= 3,

	kFWAsynchPriority						= FWBitRange (28, 31),
	kFWAsynchPriorityPhase					= FWBitRangePhase (28, 31),

	kFWAsynchDestinationID					= FWBitRange (0, 15),
	kFWAsynchDestinationIDPhase				= FWBitRangePhase (0, 15),

	kFWAsynchSourceID						= FWBitRange (0, 15),
	kFWAsynchSourceIDPhase					= FWBitRangePhase (0, 15),

	kFWAsynchDestinationOffsetHigh			= FWBitRange (16, 31),
	kFWAsynchDestinationOffsetHighPhase		= FWBitRangePhase (16, 31),

	kFWAsynchDestinationOffsetLow			= FWBitRange (0, 31),
	kFWAsynchDestinationOffsetLowPhase		= FWBitRangePhase (0, 31),

	kFWAsynchDataLength						= FWBitRange (0, 15),
	kFWAsynchDataLengthPhase				= FWBitRangePhase (0, 15),

	kFWAsynchExtendedTCode					= FWBitRange (16, 31),
	kFWAsynchExtendedTCodePhase				= FWBitRangePhase (16, 31),

	kFWAsynchAckSent						= FWBitRange (28, 31),
	kFWAsynchAckSentPhase					= FWBitRangePhase (28, 31),

	kFWAsynchRCode							= FWBitRange (16, 19),
	kFWAsynchRCodePhase						= FWBitRangePhase (16, 19)
};

enum
{
	kFWTCodeWriteQuadlet					= 0,
	kFWTCodeWriteBlock						= 1,
	kFWTCodeWriteResponse					= 2,
	kFWTCodeReadQuadlet						= 4,
	kFWTCodeReadBlock						= 5,
	kFWTCodeReadQuadletResponse				= 6,
	kFWTCodeReadBlockResponse				= 7,
	kFWTCodeCycleStart						= 8,
	kFWTCodeLock							= 9,
	kFWTCodeIsochronousBlock				= 10,
	kFWTCodeLockResponse					= 11,
	kFWTCodePHYPacket						= 14
};

enum
{
	kFWExtendedTCodeMaskSwap				= 1,
	kFWExtendedTCodeCompareSwap				= 2,
	kFWExtendedTCodeFetchAdd				= 3,
	kFWExtendedTCodeLittleAdd				= 4,
	kFWExtendedTCodeBoundedAdd				= 5,
	kFWExtendedTCodeWrapAdd					= 6,
	kFWExtendedTCodeVendorDependent			= 7
};

// debug boot-arg constants
enum
{
	kFWDebugIgnoreNodeNone					= 0xFFFFFFFF
};

struct AsyncPendingTrans {
    IOFWAsyncCommand *	fHandler;
    IOFWCommand *		fAltHandler;
    int			fTCode;
    bool		fInUse;
};

struct IOFWNodeScan {
    IOFireWireController 	*	fControl;
    FWAddress					fAddr;
    UInt32						fBuf[5];	// Enough for bus info block
    UInt32 					*	fSelfIDs;
    int							fNumSelfIDs;
    int							fROMSize;
    int							fRead;
    IOFWReadQuadCommand 	* 	fCmd;
	IOFWCompareAndSwapCommand * fLockCmd;
	UInt32						generation;
    UInt32						fIRMBitBucketOld;
    UInt32						fIRMBitBucketNew;
    bool						fIRMisBad;
    bool						speedChecking;
    bool						fContenderNeedsChecking;
    bool						fIRMCheckingRead;
    bool						fIRMCheckingLock;
	int							fRetriesBumped;
	bool						fMustNotBeRoot;
};


typedef struct IOFWDuplicateGUIDStruct IOFWDuplicateGUIDRec;
struct IOFWDuplicateGUIDStruct
 {
	IOFWDuplicateGUIDRec		* 	fNextGUID;
	CSRNodeUniqueID				fGUID;
	UInt32						fLastGenSeen;
};
	

// IOFireWireDuplicateGUIDList
//
// A little class for keeping track of GUIDs which where we have observed 2 nodes with
// the same GUID

class IOFireWireDuplicateGUIDList : public OSObject
{
    OSDeclareDefaultStructors(IOFireWireDuplicateGUIDList);

private:
    IOFWDuplicateGUIDRec		* 	fFirstGUID;
    
protected:
    virtual void free();
    
public:

	static IOFireWireDuplicateGUIDList * create( void );

	void addDuplicateGUID( CSRNodeUniqueID guid, UInt32 gen );
	void removeDuplicateGUID( CSRNodeUniqueID guid );
	
	bool findDuplicateGUID( CSRNodeUniqueID guid, UInt32 gen );
	
};

#define kMaxPendingTransfers kFWAsynchTTotal

class IOFireWireController;

#pragma mark -

/*! 
	@class IOFireWireControllerAux
*/

class IOFireWireControllerAux : public IOFireWireBusAux
{
    OSDeclareDefaultStructors(IOFireWireControllerAux)

	friend class IOFireWireController;
	
protected:
	
	IOFireWireController * 		fPrimary;
	
	UInt8						fMaxRec;
	
	UInt8						fPadding;
	UInt16						fPadding2;
	
	IOFWUserObjectExporter *	fSessionRefExporter;
	
	/*! 
		@struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
    */  
	  
    struct ExpansionData { };

	/*! 
		@var reserved
		Reserved for future use.  (Internal use only)  
	*/
    
	ExpansionData * reserved;

    virtual bool 									init ( 
																IOFireWireController * 	primary );
	virtual	void 									free ();
	virtual IOFWDCLPool *							createDCLPool ( unsigned capacity ) const ;	
	virtual UInt8									getMaxRec( void );
	
	virtual UInt64 getFireWirePhysicalAddressMask( void );
	virtual UInt32 getFireWirePhysicalAddressBits( void );
	virtual UInt64 getFireWirePhysicalBufferMask( void );
	virtual UInt32 getFireWirePhysicalBufferBits( void );
	
	virtual IOFWSimpleContiguousPhysicalAddressSpace * createSimpleContiguousPhysicalAddressSpace( vm_size_t size, IODirection direction );
	virtual IOFWSimplePhysicalAddressSpace * createSimplePhysicalAddressSpace( vm_size_t size, IODirection direction );
	
	virtual IOFWUserObjectExporter * getSessionRefExporter( void );
	
private:
    OSMetaClassDeclareReservedUnused(IOFireWireControllerAux, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireControllerAux, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireControllerAux, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireControllerAux, 3);
    OSMetaClassDeclareReservedUnused(IOFireWireControllerAux, 4);
    OSMetaClassDeclareReservedUnused(IOFireWireControllerAux, 5);
    OSMetaClassDeclareReservedUnused(IOFireWireControllerAux, 6);
    OSMetaClassDeclareReservedUnused(IOFireWireControllerAux, 7);

};


#pragma mark -

/*! @class IOFireWireController
*/
class IOFireWireController : public IOFireWireBus
{
    OSDeclareAbstractStructors(IOFireWireController)

protected:
    enum busState {
        kStarting = 0,		
		kAsleep,			// Link off, zzzzzz
		kWaitingBusReset,
        kWaitingSelfIDs,	// Bus has been reset, no selfIDs yet
        kWaitingScan,		// Got selfIDs, waiting a bit before hitting lame devices
        kScanning,			// Reading node ROMs
        kWaitingPrune,		// Read all ROMs, pausing before pruning missing devices
        kRunning,			// Normal happy state,
		kWaitingBusResetStart	// bus reset is desired, but not yet sent to the fwim
    };
    
	enum ResetState
	{
		kResetStateResetting,
		kResetStateDisabled,
		kResetStateArbitrated
	};

	enum
	{
		kDisablePhysicalAccess 	= (1 << 0)
	};
		
    struct timeoutQ: public IOFWCmdQ
    {
        IOTimerEventSource *fTimer;
        virtual void headChanged(IOFWCommand *oldHead);
        void busReset();
    };
	
    struct pendingQ: public IOFWCmdQ
    {
        IOFWQEventSource *fSource;
        virtual void headChanged(IOFWCommand *oldHead);
    };

    friend class IOFireWireLink;
	friend class IOFireWireDevice;
	friend class IOFireWireDeviceAux;
	friend class IOFWAddressSpace;
	friend class IOFWAddressSpaceAux;
    friend class IOFWPseudoAddressSpace;
    friend class IOFireWireSBP2ORB;
	friend class IOFireWireSBP2Login;
	friend class IOFWLocalIsochPort;
	friend class IOFWCommand;
    friend class IOFireWireUnit;
	friend class IOFireWirePCRSpace;
    friend class IOFireWireROMCache;
    friend class IOFWAsyncStreamCommand;
	friend class IOFireWireAVCLocalUnit;
	friend class IOFireWireAVCUnit;
    friend class IOFireWireAVCCommand;
	friend class IOFireWirePowerManager;
	friend class IOFWWriteQuadCommand;
	friend class IOFWWriteCommand;
	friend class IOFWCompareAndSwapCommand;
	friend class IOFWAsyncCommand;
	friend class IOFireWireAVCTargetSpace;
	friend class AppleFWOHCI;
	friend class IOFireWireNub;
	friend class IOFWAsyncStreamListener;
	friend class IOFireWireLocalNode;
	friend class IOFireWireIRMAllocation;
	friend class IOFWUserVectorCommand;
	friend class IOFWAsyncPHYCommand;
	friend class IOFWUserPHYPacketListener;
	friend class IOFWAsyncStreamReceiver;	
	
#if FIRELOGCORE
	friend class IOFireLog;
#endif

    IOFireWireLink *			fFWIM;
    IOFWWorkLoop *				fWorkLoop;
    IOTimerEventSource *		fTimer;
    OSSet *						fLocalAddresses;	// Collection of local adress spaces
    OSIterator *				fSpaceIterator;		// Iterator over local addr spaces

    OSSet *						fAllocatedChannels;	// Need to be informed of bus resets
    OSIterator *				fAllocChannelIterator;	// Iterator over channels

	OSSet *						fIRMAllocations;	// Need to be informed of bus resets
    OSIterator *				fIRMAllocationsIterator;	// Iterator over channels
	OSSet *						fIRMAllocationsAllocated;	// Need to be informed of bus resets

    // Bus management variables (although we aren't a FireWire Bus Manager...)
    AbsoluteTime				fResetTime;		// Time of last reset
    UInt32						fBusGeneration;		// ID of current bus topology.
    UInt16						fLocalNodeID;		// ID of local node, ie. this computer
    UInt16						fRootNodeID;		// ID of root, ie. highest node id in use.
    UInt16						fIRMNodeID;		// ID of Isochronous resource manager, or kFWBadNodeID
    bool						fBusMgr;		// true if at least one node is bus manager capable
    IORegistryEntry *			fNodes[kFWMaxNodesPerBus];	// FireWire nodes on this bus
    UInt32 *					fNodeIDs[kFWMaxNodesPerBus+1];	// Pointer to SelfID list for each node
							// +1 so we know how many selfIDs the last node has
							
    UInt32						fGapCount;		// What we think the gap count should be
    //UInt8						fSpeedCodes[(kFWMaxNodesPerBus+1)*kFWMaxNodesPerBus];
    UInt8						fSpeedVector[((kFWMaxNodesPerBus+1)*kFWMaxNodesPerBus)/2];
						// Max speed between two nodes
    busState					fBusState;		// Which state are we in?
    int							fNumROMReads;		// Number of device ROMs we are still reading
    // SelfIDs
    int							fNumSelfIDs;		// Total number of SelfID packets
    UInt32						fSelfIDs[kMaxSelfIDs*kFWMaxNodesPerBus];

    // The local device's Config ROM
    UInt32						fROMHeader[5];		// More or less fixed header and bus info block
    IOLocalConfigDirectory *	fRootDir;		// Local Config ROM root directory.

    // log base 2 of maximum packet size the FWIM can send/receive
    // Normally calculated from bus info block.
    int	fMaxSendLog;
    int fMaxRecvLog;
    
    IOFWAddressSpace *			fROMAddrSpace;
    IOMemoryDescriptor *		fBadReadResponse;	// Send back easily identified bad data to out of range addrs. 

    // Array for outstanding requests (up to 64)
    AsyncPendingTrans			fTrans[kMaxPendingTransfers];
    int							fLastTrans;

    // queue for executing commands that may timeout
    timeoutQ					fTimeoutQ;

    // queue for commands that can't execute yet
    pendingQ					fPendingQ;

    // queue for async commands interrupted by bus reset
    IOFWCmdQ					fAfterResetHandledQ;
    
    // Command to change bus state after a delay.
    IOFWDelayCommand *			fDelayedStateChangeCmd;
    bool						fDelayedStateChangeCmdNeedAbort;
    
	UInt32						fDelayedPhyPacket;
	bool						fBusResetScheduled;
	ResetState					fBusResetState;
	IOFWDelayCommand *			fBusResetStateChangeCmd;
	UInt32						fBusResetDisabledCount;

#if FIRELOGCORE
    IOFireLogPublisher *		fFireLogPublisher;
#else
    void *						fFireLogPublisher;
#endif

    OSData *					fAllocatedAddresses;

	UInt32						fDevicePruneDelay;
	
	IOFWPhysicalAccessMode		fPhysicalAccessMode;
	IOFWSecurityMode			fSecurityMode;
	IONotifier *				fKeyswitchNotifier;
	
	IOFireWireIRM *				fIRM;
	IOFireWirePowerManager *	fBusPowerManager;
	
	bool						fGapCountMismatch;

	bool						fUseHalfSizePackets;
	bool						fRequestedHalfSizePackets;

	IOFWNodeScan *					fScans[kFWMaxNodesPerBus];
	IOFireWireDuplicateGUIDList	*	fGUIDDups;
	
	bool						fDelegateCycleMaster;
	bool						fBadIRMsKnown;
	
	UInt32						fPreviousGap;
	
	UInt32						fOutOfTLabels;
	UInt32						fOutOfTLabels10S;
	UInt32						fOutOfTLabelsThreshold;

#ifdef LEGACY_SHUTDOWN
	IONotifier *				fPowerEventNotifier;
#endif

	bool						fStarted;

	UInt32						fIOCriticalSectionCount;
	UInt32						fHubPort;
	UInt32						fDebugIgnoreNode;

	OSSet *						fLocalAsyncStreamReceivers; 
    OSIterator *				fAsyncStreamReceiverIterator;

	bool						fInstantiated;

	IOReturn					fStartStatus;
	UInt32						fWaitingForSelfID;

	UInt32						fForcedRootNodeID;
	bool						fNodeMustBeRootFlag;
	bool						fNodeMustNotBeRootFlag;
	
	UInt32						fForcedGapCount;
	bool						fForcedGapFlag;

	OSSet *						fPHYPacketListeners;
 	OSIterator *				fPHYPacketListenersIterator;

	bool						fDSLimited;

	IONotifier *				fConsoleLockNotifier;
	IOFireWireLocalNode *       fLocalNode;
    
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;
	
    static void clockTick(OSObject *, IOTimerEventSource *);
    static void readROMGlue(void *refcon, IOReturn status,
			IOFireWireNub *device, IOFWCommand *fwCmd);
    static void delayedStateChange(void *refcon, IOReturn status,
                                    IOFireWireBus *bus, IOFWBusCommand *fwCmd);

    virtual void processBusReset();
    virtual void processSelfIDs(UInt32 *IDs, int numIDs, UInt32 *ownIDs, int numOwnIDs);
    virtual void processTimeout(IOTimerEventSource *src);
    virtual void processRcvPacket( UInt32 *data, int numQuads, IOFWSpeed speed );
    virtual void processWriteRequest(UInt16 sourceID, UInt32 tlabel,
				UInt32 *hdr, void *buf, int len, IOFWSpeed speed);
    virtual void processLockRequest(UInt16 sourceID, UInt32 tlabel,
				UInt32 *hdr, void *buf, int len, IOFWSpeed speed);

    // Process read from a local address, return rcode
    virtual UInt32 doReadSpace(UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len,
                                      IOMemoryDescriptor **buf, IOByteCount * offset, IODMACommand **dma_command,
                                      IOFWRequestRefCon refcon);

    // Process write to a local address, return rcode
    virtual UInt32 doWriteSpace(UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len,
                                const void *buf, IOFWRequestRefCon refcon);

    // Process lock to a local address, return rcode
    UInt32 doLockSpace(UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 inlen,
                                             const UInt32 *newVal, UInt32 &outLen, UInt32 *oldVal,
                                             UInt32 extType, IOFWRequestRefCon refcon);
    
    virtual void updatePlane();
    virtual void startBusScan();

    // Called when all devices on bus have been examined
    virtual void finishedBusScan();
    
    virtual void buildTopology(bool doFWPlane);

    virtual void readDeviceROM(IOFWNodeScan *refCon, IOReturn status);
    
    virtual IOReturn UpdateROM();
    virtual IOReturn allocAddress(IOFWAddressSpace *space);
    virtual void freeAddress(IOFWAddressSpace *space);

	IOFireWireBusAux * createAuxiliary( void );
	
public:

    // Initialization
    virtual bool init(IOFireWireLink *fwim);
    virtual void free();
    virtual bool start(IOService *provider);
    virtual void stop( IOService * provider );
    virtual bool finalize( IOOptionBits options );
    virtual bool requestTerminate( IOService * provider, IOOptionBits options );

	// Power management
    virtual IOReturn setPowerState ( unsigned long powerStateOrdinal, IOService* whatDevice );

    // Implement IOService::getWorkLoop
    virtual IOWorkLoop *getWorkLoop() const;

    // Allocate struct for tracking a transaction
    virtual AsyncPendingTrans *allocTrans(IOFWAsyncCommand *cmd=NULL);
    virtual void freeTrans(AsyncPendingTrans *trans);

    // Really public methods

    virtual IOReturn getCycleTime(UInt32 &cycleTime);
    virtual IOReturn getBusCycleTime(UInt32 &busTime, UInt32 &cycleTime);
    
    // Methods to manipulate the local Config ROM
    virtual IOReturn AddUnitDirectory(IOLocalConfigDirectory *unitDir);
    virtual IOReturn RemoveUnitDirectory(IOLocalConfigDirectory *unitDir);

    // Cause a bus reset
    virtual IOReturn resetBus();

    // Send async request packets
    virtual IOReturn asyncRead(	UInt32 				generation, 
								UInt16 				nodeID, 
								UInt16 				addrHi, 
								UInt32 				addrLo,
                                int 				speed, 
								int 				label, 
								int 				size, 
								IOFWAsyncCommand *	cmd );

    virtual IOReturn asyncWrite(	UInt32 					generation, 
									UInt16 					nodeID, 
									UInt16 					addrHi, 
									UInt32 					addrLo,
									int 					speed, 
									int 					label, 
									IOMemoryDescriptor *	buf, 
									IOByteCount 			offset,
									int 					size, 
									IOFWAsyncCommand *		cmd );
				
    /* DEPRECATED */ virtual IOReturn asyncWrite(	UInt32 				generation, 
	/* DEPRECATED */								UInt16 				nodeID, 
	/* DEPRECATED */								UInt16 				addrHi, 
	/* DEPRECATED */								UInt32 				addrLo,
	/* DEPRECATED */								int 				speed, 
	/* DEPRECATED */								int 				label, 
	/* DEPRECATED */								void *				data, 
	/* DEPRECATED */								int 				size, 
	/* DEPRECATED */								IOFWAsyncCommand *	cmd );

    /* DEPRECATED */ virtual IOReturn asyncLock(	UInt32 				generation, 
	/* DEPRECATED */								UInt16 				nodeID, 
	/* DEPRECATED */								UInt16 				addrHi, 
	/* DEPRECATED */								UInt32 				addrLo,
	/* DEPRECATED */								int 				speed, 
	/* DEPRECATED */								int 				label, 
	/* DEPRECATED */								int 				type, 
	/* DEPRECATED */								void *				data, 
	/* DEPRECATED */								int 				size, 
	/* DEPRECATED */								IOFWAsyncCommand *	cmd);


    // Send async read response packets
    // useful for pseudo address spaces that require servicing outside the FireWire work loop.
    virtual IOReturn asyncReadResponse(	UInt32 					generation, 
										UInt16 					nodeID, 
										int 					speed,
										IOMemoryDescriptor *	buf, 
										IOByteCount 			offset, 
										int 					len,
										IOFWRequestRefCon 		refcon );

    virtual IOReturn asyncLockResponse( UInt32 					generation, 
										UInt16 					nodeID, 
										int 					speed,
                                        IOMemoryDescriptor *	buf, 
										IOByteCount 			offset, 
										int 					len,
                                        IOFWRequestRefCon 		refcon );
                                       
    // Try to fix whatever might have caused the other device to not respond
    virtual IOReturn handleAsyncTimeout(IOFWAsyncCommand *cmd);

    // Convert a firewire nodeID into the IOFireWireDevice for it
    virtual IOFireWireDevice * nodeIDtoDevice(UInt32 generation, UInt16 nodeID);

    // Add/remove a channel from the list informed of bus resets
    virtual void addAllocatedChannel(IOFWIsochChannel *channel);
    virtual void removeAllocatedChannel(IOFWIsochChannel *channel);

	// Add/remove a IRM allocation from the list informed of bus resets
    virtual void addIRMAllocation(IOFireWireIRMAllocation *irmAllocation);
    virtual void removeIRMAllocation(IOFireWireIRMAllocation *irmAllocation);
	
    // Create an Isochronous Channel object
    // doIRM = true => allocate channel and bandwith in Isochronous Resource Manager
    // packetSize packet size (in bytes), used to calculate bandwidth needed.
    virtual IOFWIsochChannel *createIsochChannel(
	bool doIRM, UInt32 packetSize, IOFWSpeed prefSpeed,
	FWIsochChannelForceStopNotificationProc stopProc=NULL,
	void *stopRefCon=NULL);

    // Create a local isochronous port to run the given DCL program
    // if task is 0, the DCL program is for the kernel task,
    // otherwise all DCL pointers are valid in the specified task.
    // opcodes is also pointer valid in the specified task.
    virtual IOFWLocalIsochPort *createLocalIsochPort(bool talking,
        DCLCommand* opcodes, DCLTaskInfo *info = 0,
	UInt32 startEvent = 0, UInt32 startState = 0, UInt32 startMask = 0);

    // Execute specified function on workloop after specified delay
    // Returned command is for delay, call it's cancel() function to cancel timeout.
    virtual IOFWDelayCommand * createDelayedCmd(UInt32 uSecDelay, FWBusCallback func, void *refcon);

    virtual IOFWPhysicalAddressSpace *createPhysicalAddressSpace(IOMemoryDescriptor *mem);
    virtual IOFWPseudoAddressSpace *createPseudoAddressSpace(FWAddress *addr, UInt32 len,
                                FWReadCallback reader, FWWriteCallback writer, void *refcon);

    // Extract info about the async request 
    virtual bool isLockRequest(IOFWRequestRefCon refcon);
    virtual bool isQuadRequest(IOFWRequestRefCon refcon);
    virtual UInt32 getExtendedTCode(IOFWRequestRefCon refcon);
    
    // Inline accessors for protected member variables
    IOFWCmdQ &getTimeoutQ();
	IOFWCmdQ &getPendingQ();
    IOFWCmdQ &getAfterResetHandledQ();
    IOFireWireLink * getLink() const;

    IOLocalConfigDirectory *getRootDir() const;
    bool checkGeneration(UInt32 gen) const;
    UInt32 getGeneration() const;
    UInt16 getLocalNodeID() const;
    IOReturn getIRMNodeID(UInt32 &generation, UInt16 &id);
    
    const AbsoluteTime * getResetTime() const;

    IOFWSpeed FWSpeed(UInt16 nodeAddress) const;
    IOFWSpeed FWSpeed(UInt16 nodeA, UInt16 nodeB) const;

    // How big (as a power of two) can packets sent to/received from the node be?
    virtual int maxPackLog(bool forSend, UInt16 nodeAddress) const;

    // How big (as a power of two) can packets sent from A to B be?
    virtual int maxPackLog(UInt16 nodeA, UInt16 nodeB) const;

   // Force given node to be root (via root holdoff Phy packet)
    virtual IOReturn makeRoot(UInt32 generation, UInt16 nodeID) ;

    virtual IOFWPseudoAddressSpace *createInitialAddressSpace(UInt32 addressLo, UInt32 len,
                                FWReadCallback reader, FWWriteCallback writer, void *refcon);
    
    virtual IOFWAddressSpace *getAddressSpace(FWAddress address);
    
    // Extract info about the async request - was the request ack'ed complete already?
    virtual bool isCompleteRequest(IOFWRequestRefCon refcon);

    // Are we currently scanning the bus?
    bool scanningBus() const;

protected:

    void openGate();
    void closeGate();
		
protected:    
	virtual void doBusReset( void );
	static void resetStateChange( void *refcon, IOReturn status,
								   IOFireWireBus *bus, IOFWBusCommand *fwCmd);

public:
	virtual IOReturn disableSoftwareBusResets( void );
	virtual void enableSoftwareBusResets( void );

    virtual IOFWAsyncStreamCommand * createAsyncStreamCommand( UInt32 generation,
    			UInt32 channel, UInt32 sync, UInt32 tag, IOMemoryDescriptor *hostMem,
				UInt32 size, int speed,FWAsyncStreamCallback completion, void *refcon);
    
	virtual	IOReturn asyncStreamWrite(UInt32 generation,
                    int speed, int tag, int sync, int channel,
                    IOMemoryDescriptor *buf, IOByteCount offset,
                	int size, IOFWAsyncStreamCommand *cmd);
					
protected:
	bool inGate();

    virtual IOReturn allocatePseudoAddress(FWAddress *addr, UInt32 lenDummy);
    virtual void freePseudoAddress(FWAddress addr, UInt32 lenDummy);
	
	virtual IORegistryEntry * createDummyRegistryEntry( IOFWNodeScan *scan );

	static IOFireWireLocalNode * getLocalNode(IOFireWireController *control);
	
	virtual void setPhysicalAccessMode( IOFWPhysicalAccessMode mode );
	virtual IOFWPhysicalAccessMode getPhysicalAccessMode( void );
	virtual void physicalAccessProcessBusReset( void );
	virtual void setNodeIDPhysicalFilter( UInt16 nodeID, bool state );
	
	virtual void initSecurity( void );
	virtual void freeSecurity( void );
	static bool serverKeyswitchCallback( void * target, void * refCon, IOService * service, IONotifier * notifier );
	virtual void setSecurityMode( IOFWSecurityMode mode );
	virtual IOFWSecurityMode getSecurityMode( void );

	virtual IOReturn createTimeoutQ( void );
	virtual void destroyTimeoutQ( void );
	virtual IOReturn createPendingQ( void );
	virtual void destroyPendingQ( void );

	virtual UInt32 countNodeIDChildren( UInt16 nodeID, int hub_port = 0, int * hubChildRemainder = NULL, bool * hubParentFlag = NULL );

public:
	virtual UInt32 hopCount(UInt16 nodeAAddress, UInt16 nodeBAddress );
	virtual UInt32 hopCount(UInt16 nodeAAddress );
	
	virtual IOFireWirePowerManager * getBusPowerManager( void );

protected:
	virtual void handleARxReqIntComplete();

    virtual IOReturn asyncLock(	UInt32 					generation, 
								UInt16 					nodeID, 
								UInt16 					addrHi, 
								UInt32 					addrLo,
								int 					speed, 
								int 					label, 
								int 					type, 
								IOMemoryDescriptor *	buf, 
								IOByteCount 			offset,
								int 					size, 
								IOFWAsyncCommand *		cmd );

    virtual IOReturn asyncWrite(	UInt32 					generation, 
									UInt16 					nodeID, 
									UInt16 					addrHi, 
									UInt32 					addrLo,
									int 					speed, 
									int 					label, 
									IOMemoryDescriptor *	buf, 
									IOByteCount 			offset,
									int 					size, 
									IOFWAsyncCommand *		cmd,
									IOFWWriteFlags 			flags );

protected:
	bool delayedStateCommandInUse() const;
	void enterBusResetDisabledState( );
	
	virtual UInt32 getPortNumberFromIndex( UInt16 index );
												
    virtual bool checkForDuplicateGUID(IOFWNodeScan *scan, CSRNodeUniqueID *currentGUIDs );
    virtual void updateDevice(IOFWNodeScan *scan );
    virtual bool AssignCycleMaster();

public:

 	IOReturn clipMaxRec2K(Boolean clipMaxRec );
	void setNodeSpeed( UInt16 nodeAddress, IOFWSpeed speed );
	void useHalfSizePackets( void );
	void disablePhyPortOnSleepForNodeID( UInt32 nodeID );

	IOReturn handleAsyncCompletion( IOFWCommand *cmd, IOReturn status );
	void processCycle64Int();

#ifdef LEGACY_SHUTDOWN
	static IOReturn systemShutDownHandler( void * target, void * refCon,
                                    UInt32 messageType, IOService * service,
                                    void * messageArgument, vm_size_t argSize );
#else
    virtual void systemWillShutdown( IOOptionBits specifier );
#endif

	IOReturn beginIOCriticalSection( void );
	void endIOCriticalSection( void );

protected:	
	IOReturn poweredStart( void );
	void setNodeSpeed( UInt16 nodeA, UInt16 nodeB, UInt8 speed );
	void setNodeSpeed( UInt16 nodeAddress, UInt8 speed );

public:
	bool isPhysicalAccessEnabledForNodeID( UInt16 nodeID );
	
	// Allocate IRM bandwidth if the specified generation is the current FireWire generation.
	IOReturn allocateIRMBandwidthInGeneration(UInt32 bandwidthUnits, UInt32 generation) ;
	
	// Release IRM bandwidth if the specified generation is the current FireWire generation.
	IOReturn releaseIRMBandwidthInGeneration(UInt32 bandwidthUnits, UInt32 generation) ;
	
	// Allocate IRM channel if the specified generation is the current FireWire generation.
	IOReturn allocateIRMChannelInGeneration(UInt8 isochChannel, UInt32 generation) ;
	
	// Release IRM channel if the specified generation is the current FireWire generation.
	IOReturn releaseIRMChannelInGeneration(UInt8 isochChannel, UInt32 generation) ;
	
	// Create an IOFireWireIRMAllocation object which can be used to allocate isoch resources that are automatically reallocated after bus-resets!
	IOFireWireIRMAllocation *createIRMAllocation(Boolean releaseIRMResourcesOnFree = true, 
												IOFireWireIRMAllocation::AllocationLostNotificationProc allocationLostProc = NULL,
												void *pLostNotificationProcRefCon = NULL);

	IOFWAsyncStreamListener *createAsyncStreamListener( UInt32	channel, FWAsyncStreamReceiveCallback proc, void *refcon );

	void removeAsyncStreamListener( IOFWAsyncStreamListener *listener );

	IOFWSpeed getBroadcastSpeed(){ return FWSpeed( fLocalNodeID ); };

private:

	IOFWAsyncStreamReceiver *allocAsyncStreamReceiver( UInt32 channel, FWAsyncStreamReceiveCallback proc, void *refcon );

	IOFWAsyncStreamReceiver *getAsyncStreamReceiver( UInt32 channel );

	void freeAllAsyncStreamReceiver();

	void activateAsyncStreamReceivers();

	void deactivateAsyncStreamReceivers();

protected:
	IOService *findKeyswitchDevice( void );
	void suspendBus( void );

public:
	virtual IOReturn			asyncRead(	UInt32 				generation, 
											UInt16 				nodeID, 
											UInt16 				addrHi, 
											UInt32 				addrLo,
											int 				speed, 
											int 				label, 
											int 				size, 
											IOFWAsyncCommand *	cmd,
											IOFWReadFlags		flags );

	void checkProgress( void );

	void terminateDevice( IOFireWireDevice * device );

	void nodeMustBeRoot( UInt32 nodeID );

	void nodeMustNotBeRoot( UInt32 nodeID );	

	void setGapCount( UInt32	gapCount );	
	
	IOReturn asyncPHYPacket(	UInt32					generation, 
								UInt32					data, 
								UInt32					data2, 
								IOFWAsyncPHYCommand *	cmd );

    IOFWAsyncPHYCommand * createAsyncPHYCommand(	UInt32				generation,
													UInt32				data1, 
													UInt32				data2,			
													FWAsyncPHYCallback	completion, 
													void *				refcon, 
													bool				failOnReset );
	
private:
	AsyncPendingTrans * allocTrans( IOFWAsyncCommand * cmd, IOFWCommand * altcmd );

public:

	IOReturn activatePHYPacketListener( IOFWPHYPacketListener * listener );
	void deactivatePHYPacketListener( IOFWPHYPacketListener * listener );

	IOFWPHYPacketListener * createPHYPacketListener( FWPHYPacketCallback proc, void * refcon );

private:
	void processPHYPacket( UInt32 data1, UInt32 data2 );
	void enterLoggingMode( void );

public:
	IOReturn getCycleTimeAndUpTime( UInt32 &cycleTime, UInt64 &uptime );

protected:
	void removeAsyncStreamReceiver( IOFWAsyncStreamReceiver *receiver );
	
public:

	// Create a multi-isoch-receive listener
	IOFireWireMultiIsochReceiveListener * createMultiIsochReceiveListener(UInt32 channel,
																		  FWMultiIsochReceiveListenerCallback callback,
																		  void *pCallbackRefCon,
																		  FWMultiIsochReceiveListenerParams *pListenerParams = NULL);
	
	// Activate a multi-isoch-receive listener
	IOReturn activateMultiIsochReceiveListener(IOFireWireMultiIsochReceiveListener *pListener);
	
	// Deactivate a multi-isoch-receive listener
	IOReturn deactivateMultiIsochReceiveListener(IOFireWireMultiIsochReceiveListener *pListener);

	// Call for client to specify he is done with a multi-isoch receiver isoch packet
	void clientDoneWithMultiIsochReceivePacket(IOFireWireMultiIsochReceivePacket *pPacket);

public:
    virtual IOFWAsyncStreamCommand * createAsyncStreamCommand( UInt32 generation,
    			UInt32 channel, UInt32 sync, UInt32 tag, IOMemoryDescriptor *hostMem,
				UInt32 size, int speed,FWAsyncStreamCallback completion, void *refcon, bool	failOnReset);

private:
	void addToIRMAllocationSet(IOFireWireIRMAllocation *anObject);
	void removeFromIRMAllocationSet(IOFireWireIRMAllocation *anObject);

	static IOReturn consoleLockInterestHandler( void * target, void * refCon,
									 UInt32 messageType, IOService * provider,
									 void * messageArgument, vm_size_t argSize );
	
protected:	
	OSMetaClassDeclareReservedUnused(IOFireWireController, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireController, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireController, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireController, 3);
    OSMetaClassDeclareReservedUnused(IOFireWireController, 4);
    OSMetaClassDeclareReservedUnused(IOFireWireController, 5);
    OSMetaClassDeclareReservedUnused(IOFireWireController, 6);
    OSMetaClassDeclareReservedUnused(IOFireWireController, 7);
    OSMetaClassDeclareReservedUnused(IOFireWireController, 8);

};

#endif /* ! _IOKIT_IOFIREWIRECONTROLLER_H */
                                                                                                                                                        IOFireWireDevice.h                                                                                  0100644 0001750 0001750 00000023243 12567451747 037112  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 /*! @header
	This header contains the definition of the <code>IOFireWireDevice</code> and <code>IOFireWireDeviceAux</code> classes. 
	An <code>IOFireWireDevice</code> object represents a FireWire device in the I/O Registry.
	It is strongly recommended that you write applications that access FireWire devices rather than in-kernel device drivers. 
	For more information on how to do this, see {@linkdoc //apple_ref/doc/uid/TP40000969 FireWire Device Interface Guide}.
	@indexgroup FireWire
 */
#ifndef _IOKIT_IOFIREWIREDEVICE_H
#define _IOKIT_IOFIREWIREDEVICE_H

#include <IOKit/firewire/IOFireWireNub.h>

class IOFireWireROMCache;

struct IOFWNodeScan;
struct RomScan;

class IOFireWireDevice;

#pragma mark -

/*! @class IOFireWireDeviceAux
	@discussion An IOFireWireDeviceAux is for internal use only. You should never subclass IOFireWireDeviceAux 
*/

class IOFireWireDeviceAux : public IOFireWireNubAux
{
    OSDeclareDefaultStructors(IOFireWireDeviceAux)

	friend class IOFireWireDevice;
	
protected:
	
	UInt32			fUnitCount;
	IOFWSpeed		fMaxSpeed;
	OSSet *			fOpenUnitSet;
	AbsoluteTime	fResumeTime;
	
	/*! 
		@struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
    */  
	  
    struct ExpansionData { };

	/*! 
		@var reserved
		Reserved for future use.  (Internal use only)  
	*/
    
	ExpansionData * reserved;

    virtual bool init( IOFireWireDevice * primary );
	
	virtual	void free();

	virtual bool isTerminated( void );
	
	virtual void setTerminationState( TerminationState state );
	
	void setMaxSpeed( IOFWSpeed speed );
	
	void setUnitCount( UInt32 count );
	
	UInt32 getUnitCount( void );

	bool isPhysicalAccessEnabled( void );

	virtual IOFWSimpleContiguousPhysicalAddressSpace * createSimpleContiguousPhysicalAddressSpace( vm_size_t size, IODirection direction );
		
    virtual IOFWSimplePhysicalAddressSpace * createSimplePhysicalAddressSpace( vm_size_t size, IODirection direction );
	
	OSSet * getOpenUnitSet() const;
	
	void  latchResumeTime( void );
	
	AbsoluteTime getResumeTime( void );
	
private:
    OSMetaClassDeclareReservedUnused(IOFireWireDeviceAux, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireDeviceAux, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireDeviceAux, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireDeviceAux, 3);	
};

#pragma mark -
/*! @class IOFireWireDevice
	@abstract Represents a FireWire device.
	@discussion The FireWire family tries to read the configuration ROM of each device on the FireWire bus. For each device that responds with 
				its bus information block, the FireWire family publishes an <code>IOFireWireDevice</code> object in the I/O Registry. An 
				<code>IOFireWireDevice</code> object keeps track of the device's node ID, copies config ROM properties into the object's property 
				list, and scans the config ROM for unit directories, publishing an <code>IOFireWireUnit</code> object for each unit directory it finds.
*/

class IOFireWireDevice : public IOFireWireNub
{
    OSDeclareDefaultStructors(IOFireWireDevice)

    friend class IOFireWireController;
	friend class IOFireWireDeviceAux;

protected:

	enum RegistrationState
	{
		kDeviceRegistered,
		kDeviceNeedsRegisterService,
		kDeviceNotRegistered
	};
	
    IOFireWireROMCache	*fDeviceROM;
    bool				fOpenFromDevice;
    UInt32				fOpenFromUnitCount;
    UInt32				fROMGeneration;
    IORecursiveLock		*fROMLock;
    RegistrationState	fRegistrationState;
	UInt32				fROMReadRetry;
	
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

    static	void readROMDirGlue(void *refcon, IOReturn status,
                               IOFireWireNub *device, IOFWCommand *fwCmd);
    static	void readROMThreadFunc(void *arg);

    static	void terminateDevice(void *arg);
    
    void	processROM(RomScan *romScan);
    
    virtual void free();
    
public:
    virtual IOReturn message( UInt32 type, IOService * provider, void * argument );

    virtual bool handleOpen( IOService * forClient, IOOptionBits options, void * arg );

    virtual void handleClose( IOService * forClient, IOOptionBits options );

    virtual bool handleIsOpen( const IOService * forClient ) const;

protected:    
    virtual IOReturn cacheROM(OSData *rom, UInt32 offset, const UInt32 *&romBase);

    virtual const UInt32 * getROMBase();
    
    virtual void setNodeROM(UInt32 generation, UInt16 localNodeID, const IOFWNodeScan *info);

public:
    virtual bool matchPropertyTable(OSDictionary * table);

	/*!	@function	init
		@abstract	Initializes the nub.
		@param		propTable	Property table passed to the standard nub initialization.
		@param		scan		Pointer to the node scan structure.
		@result		Returns <code>true</code> if initialization was successful; <code>false</code> otherwise.
	*/
    virtual bool init(OSDictionary * propTable, const IOFWNodeScan *scan);

    virtual bool attach(IOService * provider );

    virtual bool finalize( IOOptionBits options );

	/*!	@function	setNodeFlags
		@abstract	Sets the node's characteristics.
		@param		flags Refer to "node flags" in IOFireWireFamilyCommon.h.
	*/
    virtual void setNodeFlags( UInt32 flags );

	/*!	@function	clearNodeFlags
		@abstract	Resets the node's characteristics.
		@param		flags Refer to "node flags" in IOFireWireFamilyCommon.h.
	*/
	virtual void clearNodeFlags( UInt32 flags );

	/*!	@function	getNodeFlags
		@abstract	Retrieves the node's characteristics.
		@param		flags	Refer to "node flags" in IOFireWireFamilyCommon.h.
		@result		UInt32	The flags set for a particular node. 
	*/
    virtual UInt32 getNodeFlags( void );

protected:
	virtual IOReturn configureNode( void );

public:
	/*!	@function	createPhysicalAddressSpace
		@abstract	Creates local physical FireWire address spaces for the device to access.
		@param		mem  Memory area allocated to back the physical access by Link hardware.
		@result		A valid <code>IOFWPhysicalAddressSpace</code> object on success; NULL on failure.
	*/
    virtual IOFWPhysicalAddressSpace *createPhysicalAddressSpace(IOMemoryDescriptor *mem);

	/*!	@function	createPseudoAddressSpace
		@abstract	Creates local pseudo FireWire address spaces for the device to access.
		@param		addr	The FireWire address that is mapped to the pseudo address access.
		@param		len		Size of the address space to allocate.
		@param		reader  Read callback, when the device reads from this address space.
		@param		writer  Write callback, when the device writes to this address space.
		@param		refcon  Client's callback object returned during reader/writer callbacks.
		@result		A valid <code>IOFWPseudoAddressSpace</code> object on success; NULL on failure.
	*/
    virtual IOFWPseudoAddressSpace *createPseudoAddressSpace(FWAddress *addr, UInt32 len,
                    FWReadCallback reader, FWWriteCallback writer, void *refcon);

protected:
	virtual IOReturn readRootDirectory( IOConfigDirectory * directory, OSDictionary * propTable );

	virtual IOReturn processRootDirectory( OSDictionary * propTable );

	virtual IOReturn readUnitDirectories( IOConfigDirectory * directory, OSSet * unitInfo );

	virtual IOReturn processUnitDirectories( OSSet * unitSet );
    
	virtual void setRegistrationState( RegistrationState fRegistrationState );
	
	virtual void preprocessDirectories( OSDictionary * rootPropTable, OSSet * unitSet );
	
	virtual void configurePhysicalFilter( void );

protected:
	virtual IOFireWireNubAux * createAuxiliary( void );

public:
	inline bool isTerminated( void )
		{ return ((IOFireWireDeviceAux*)fAuxiliary)->isTerminated(); }
		
	/*!	@function	setMaxSpeed
		@abstract	Sets the maximum speed for this node.
		@param		speed Maximum speed. Refer to "bus speed numbers" in IOFireWireFamilyCommon.h.
	*/
	inline void setMaxSpeed( IOFWSpeed speed )
		{ ((IOFireWireDeviceAux*)fAuxiliary)->setMaxSpeed( speed ); }		

protected:
	inline void setUnitCount( UInt32 count )
		{ ((IOFireWireDeviceAux*)fAuxiliary)->setUnitCount( count ); }		

	inline OSSet * getOpenUnitSet( void ) const
		{ return ((IOFireWireDeviceAux*)fAuxiliary)->getOpenUnitSet(); }
			
public:
	/*!	@function	getUnitCount
		@abstract	Returns number of units attached to this device.
		@result		UInt32 The number of units attached to this device.
	*/
	inline UInt32 getUnitCount( void )
		{ return ((IOFireWireDeviceAux*)fAuxiliary)->getUnitCount(); }		

protected:
	inline AbsoluteTime getResumeTime( void )
		{ return ((IOFireWireDeviceAux*)fAuxiliary)->getResumeTime(); }		

	inline void latchResumeTime( void )
		{ ((IOFireWireDeviceAux*)fAuxiliary)->latchResumeTime(); }		
		
private:
    OSMetaClassDeclareReservedUnused(IOFireWireDevice, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireDevice, 1);

};

#endif /* ! _IOKIT_IOFIREWIREDEVICE_H */
                                                                                                                                                                                                                                                                                                                                                             IOFireWireFamilyCommon.h                                                                            0100644 0001750 0001750 00000111704 12567451747 040305  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *  IOFireWireFamilyCommon.h
 *  IOFireWireUserClient/IOFireWireFamily
 *
 *  Created by NWG on Fri Apr 28 2000.
 *  Copyright (c) 2000-2001 Apple Computer, Inc. All rights reserved.
 *
 */
/*
	$Log: not supported by cvs2svn $
	Revision 1.78  2008/05/08 02:33:22  collin
	more K64
	
	Revision 1.77  2008/04/24 00:01:39  collin
	more K640
	
	Revision 1.76  2007/12/05 04:52:08  collin
	integrate chex workaround
	
	Revision 1.75  2007/08/31 20:29:06  collin
	fixed 5437835
	
	Revision 1.74  2007/04/24 21:40:23  arulchan
	headerdoc changes
	
	Revision 1.73  2007/04/24 21:28:24  arulchan
	changes for headerdoc
	
	Revision 1.72  2007/04/13 19:37:01  calderon
	Integrated FireWireKPrintf implemented
	
	Revision 1.71  2007/03/14 18:41:43  collin
	*** empty log message ***
	
	Revision 1.70  2007/02/28 23:10:13  ayanowit
	Another IRMAllocation fix.
	
	Revision 1.69  2007/02/20 01:25:28  collin
	*** empty log message ***
	
	Revision 1.68  2007/02/17 00:26:51  collin
	*** empty log message ***
	
	Revision 1.67  2007/02/15 19:42:07  ayanowit
	For 4369537, eliminated support for legacy DCL SendPacketWithHeader, since it didn't work anyway, and NuDCL does support it.
	
	Revision 1.66  2007/02/15 01:23:39  arulchan
	changes in AssignCycleMaster
	
	Revision 1.65  2007/02/09 04:44:06  collin
	*** empty log message ***
	
	Revision 1.64  2007/01/26 20:52:31  ayanowit
	changes to user-space isoch stuff to support 64-bit apps.
	
	Revision 1.63  2007/01/16 01:41:02  gecko1
	4159728 Add improved async lock based check for bad IRMs
	
	Revision 1.62  2007/01/15 23:29:05  arulchan
	Fixed Skipped Packet Handler Notifications
	
	Revision 1.61  2007/01/12 22:15:14  arulchan
	Added flag kIOFWEnableBeingRoot
	
	Revision 1.60  2007/01/10 22:14:44  calderon
	Fixed 4046607 Propagate vendor/model from IIDC UnitDepedantInfoDir
	Fixed some null termination shinanigans in getIndexValue(string)
	
	Revision 1.59  2007/01/08 18:47:19  ayanowit
	More 64-bit changes for isoch.
	
	Revision 1.58  2006/07/07 20:18:25  calderon
	4227201: SpeedMap and HopCount table reductions.
	
	Revision 1.57  2006/04/03 21:29:48  collin
	*** empty log message ***
	
	Revision 1.56  2006/02/09 00:21:51  niels
	merge chardonnay branch to tot
	
	Revision 1.55.4.1  2005/08/06 01:31:31  collin
	*** empty log message ***
	
	Revision 1.55  2005/03/12 03:27:51  collin
	*** empty log message ***
	
	Revision 1.54  2005/01/12 06:34:53  collin
	*** empty log message ***
	
	Revision 1.53  2004/05/04 22:52:19  niels
	*** empty log message ***
	
	Revision 1.52  2004/03/26 01:42:53  gecko1
	Add code to disable any port directly connected to an iPod when we go to sleep.
	
	Revision 1.51  2004/03/05 00:33:59  calderon
	Fixed 3570909 - FireWire - iokit_fw_errs should be defined in hex
	All decimal #define errors in header changed to hex
	
	Revision 1.50  2003/11/07 21:01:18  niels
	Revision 1.49  2003/10/21 01:16:41  collin
	Revision 1.48  2003/10/17 00:25:24  collin
	Revision 1.47  2003/10/15 02:19:45  collin
	Revision 1.46  2003/07/22 10:49:47  niels
	Revision 1.45  2003/07/21 06:52:59  niels
	merge isoch to TOT
	
	Revision 1.44.4.5  2003/07/21 06:44:44  niels
	Revision 1.44.4.4  2003/07/18 00:17:42  niels
	Revision 1.44.4.3  2003/07/14 22:08:53  niels
	Revision 1.44.4.2  2003/07/09 21:24:01  niels
	Revision 1.44.4.1  2003/07/01 20:54:07  niels
	isoch merge
	
	Revision 1.44  2003/03/17 01:05:22  collin
	Revision 1.43  2003/03/07 01:26:06  collin
	Revision 1.42  2003/02/19 22:33:17  niels
	add skip cycle DCL
	
	Revision 1.41  2003/02/18 00:14:01  collin
	Revision 1.40  2003/02/17 21:47:52  collin
	Revision 1.39  2002/12/05 19:08:37  niels
	remove trailing commas from enums in IOFireWireFamilyCommon.h
	
	Revision 1.38  2002/11/01 20:45:57  collin
	add enhanced IRM with support for the BROADCAST_CHANNEL register
	
	Revision 1.37  2002/10/01 02:40:27  collin
	security mode support
	
	Revision 1.36  2002/09/25 21:17:14  collin
	fix headers again.
	
	Revision 1.35  2002/09/25 00:27:23  niels
	flip your world upside-down
	
	Revision 1.34  2002/09/12 22:41:53  niels
	add GetIRMNodeID() to user client
	
*/

/*! @header IOFireWireFamilyCommon.h
This file contains useful definitions for working with FireWire
in the kernel and in user space
*/

#ifndef __IOFireWireFamilyCommon_H__
#define __IOFireWireFamilyCommon_H__

#ifdef KERNEL
#ifndef __IOKIT_IOTYPES_H
	#include <IOKit/IOTypes.h>
#endif
#else
#include <IOKit/IOKitLib.h>
#endif

//#define LEGACY_SHUTDOWN

#define FW_OLD_DCL_DEFS
#define FW_OLD_BIT_DEFS

// =================================================================
// bit ranges and fields
// =================================================================
#pragma mark -
#pragma mark BITS

// FireWire bit defs.

#define BIT(x)		( 1 << (x) )
#define FW_BIT(x)	( 1 << (31 - (x) ) )

#define FWBitRange(start, end)						\
(													\
	((((UInt32) 0xFFFFFFFF) << (start)) >>			\
	 ((start) + (31 - (end)))) <<					\
	(31 - (end))									\
)

#define FWBitRangePhase(start, end)					\
	(31 - (end))

#define BitRange(start, end)						\
(													\
	((((UInt32) 0xFFFFFFFF) << (31 - (end))) >>		\
	 ((31 - (end)) + (start))) <<					\
	(start)											\
)
 

#define BitRangePhase(start, end)					\
	(start)

// =================================================================
// FireWire messages & errors
// =================================================================
#pragma mark -
#pragma mark MESSAGES AND ERRORS

#define	iokit_fw_err(return) (sys_iokit|sub_iokit_firewire|return)

// e0008010 -> 0xe000801f Response codes from response packets

// Base of Response error codes
#define kIOFireWireResponseBase							iokit_fw_err(0x10)

// e0008020 -- Bus reset during command execution (current bus generation does
//             not match that specified in command.)
#define kIOFireWireBusReset								(kIOFireWireResponseBase+kFWResponseBusResetError)

// e0008001 -- Can't find requested entry in ROM
#define kIOConfigNoEntry								iokit_fw_err(0x1)

// e0008002 -- In pending queue waiting to execute
#define kIOFireWirePending								iokit_fw_err(0x2)

// e0008003 -- Last DCL callback of program (internal use)
#define kIOFireWireLastDCLToken							iokit_fw_err(0x3)

// e0008004
#define kIOFireWireConfigROMInvalid						iokit_fw_err(0x4)

// e0008005
#define kIOFireWireAlreadyRegistered					iokit_fw_err(0x5)

// e0008006
#define kIOFireWireMultipleTalkers						iokit_fw_err(0x6)

// e0008007
#define kIOFireWireChannelActive						iokit_fw_err(0x7)

// e0008008
#define kIOFireWireNoListenerOrTalker					iokit_fw_err(0x8)

// e0008009
#define kIOFireWireNoChannels							iokit_fw_err(0x9)

// e000800A
#define kIOFireWireChannelNotAvailable					iokit_fw_err(0xA)

// e000800B
#define kIOFireWireSeparateBus							iokit_fw_err(0xB)

// e000800C
#define kIOFireWireBadSelfIDs							iokit_fw_err(0xC)

// e000800D
#define kIOFireWireLowCableVoltage						iokit_fw_err(0xD)

// e000800E
#define kIOFireWireInsufficientPower					iokit_fw_err(0xE)

// e000800f
#define kIOFireWireOutOfTLabels							iokit_fw_err(0xF)

// NOTE: errors 16—31 used for address space response codes.. (see above)

// e0008101
#define kIOFireWireBogusDCLProgram						iokit_fw_err(0x101)

// e0008102
#define kIOFireWireTalkingAndListening					iokit_fw_err(0x102)

// e0008103
#define kIOFireWireHardwareSlept						iokit_fw_err(0x103)

// e0008104		// let's resume here...

// e0008104 -- In the middle of completing
#define kIOFireWireCompleting							iokit_fw_err(0x104)

// e0008105 -- Invalid Response Length
#define kIOFireWireInvalidResponseLength				iokit_fw_err(0x105)

// e0008106 -- Isoch Bandwidth Not Available
#define kIOFireWireIsochBandwidthNotAvailable			iokit_fw_err(0x106)


// e00087d0
#define kIOFWMessageServiceIsRequestingClose 			(UInt32)iokit_fw_err(0x7D0)
#define kIOFWMessagePowerStateChanged 					(UInt32)iokit_fw_err(0x7D1)
#define kIOFWMessageTopologyChanged						(UInt32)iokit_fw_err(0x7D2)
// =================================================================
// Pseudo address space response codes
// =================================================================
#pragma mark -
#pragma mark PSEDUO ADDRESS SPACE RESPONSE CODES
enum
{
	kFWResponseComplete			= 0,	// OK!
	kFWResponseConflictError	= 4,	// Resource conflict, may retry
	kFWResponseDataError		= 5,	// Data not available
	kFWResponseTypeError		= 6,	// Operation not supported
	kFWResponseAddressError		= 7,	// Address not valid in target device
	kFWResponseBusResetError	= 16,	// Pseudo response generated locally
	kFWResponsePending			= 17	// Pseudo response, real response sent later.
};

//
// Pseudo address space response codes
//
enum
{
	kFWAckTimeout				= -1,	// Pseudo ack generated locally
	kFWAckComplete				= 1,
	kFWAckPending				= 2,
	kFWAckBusyX					= 4,
	kFWAckBusyA					= 5,
	kFWAckBusyB					= 6,
	kFWAckDataError				= 13,
	kFWAckTypeError				= 14
};

// =================================================================
// FireWire bus speed numbers
// =================================================================
#pragma mark -
#pragma mark BUS SPEED NUMBERS

typedef enum
{
	kFWSpeed100MBit			= 0,
	kFWSpeed200MBit			= 1,
	kFWSpeed400MBit			= 2,
	kFWSpeed800MBit			= 3,
	kFWSpeedReserved		= 3,	// In all cases, 1394B Devices report this speed, 
									// each port of the PHY could be different
	
	kFWSpeedUnknownMask		= 0x80,	// If speed was reserved and we haven't probed it further
	
	kFWSpeedMaximum			= 0x7FFFFFFF,	
	kFWSpeedInvalid			= 0x80000000
} IOFWSpeed;

// =================================================================
// FWAddress
// =================================================================
#pragma mark -
#pragma mark FWADDRESS
//
// The venerable FWAddress structure. This is the standard
// struct to use for passing FireWire addresses.
//

typedef struct FWAddressStruct
{
    UInt16	nodeID;		// bus/node
    UInt16	addressHi;	// Top 16 bits of node address.
    UInt32	addressLo;	// Bottom 32 bits of node address
	
	//
	// Useful C++ only constructors
	//
	#ifdef __cplusplus
	FWAddressStruct(const FWAddressStruct & a): 
			nodeID(a.nodeID), addressHi(a.addressHi), addressLo(a.addressLo) {};
    FWAddressStruct(UInt16 h=0xdead, UInt32 l=0xcafebabe) : 
			nodeID(0), addressHi(h), addressLo(l) {};
	FWAddressStruct(UInt16 h, UInt32 l, UInt16 n) :
			nodeID(n), addressHi(h), addressLo(l) {};
	#endif
} FWAddress, *FWAddressPtr ;

// =================================================================
// Config ROM
// =================================================================
#pragma mark -
#pragma mark CONFIG ROM

//
// CSR bit defs.
//

#define CSR_BIT(x) FW_BIT(x)

#define CSRBitRange(start, end)						\
(													\
	((((UInt32) 0xFFFFFFFF) << (start)) >>			\
	((start) + (31 - (end)))) <<					\
	(31 - (end))									\
)

#define CSRBitRangePhase(start, end)				\
	(31 - end)

//
// Key types.
//

typedef enum
{
	kConfigImmediateKeyType		= 0,
	kConfigOffsetKeyType		= 1,
	kConfigLeafKeyType		= 2,
	kConfigDirectoryKeyType		= 3,
	kInvalidConfigROMEntryType	= 0xff
} IOConfigKeyType;

//
// Key values.
//

enum
{
	kConfigTextualDescriptorKey		= 0x01,
	kConfigBusDependentInfoKey		= 0x02,
	kConfigModuleVendorIdKey		= 0x03,
	kConfigModuleHwVersionKey		= 0x04,
	kConfigModuleSpecIdKey			= 0x05,
	kConfigModuleSwVersionKey		= 0x06,
	kConfigModuleDependentInfoKey	= 0x07,
	kConfigNodeVendorIdKey			= 0x08,
	kConfigNodeHwVersionKey			= 0x09,
	kConfigNodeSpecIdKey			= 0x0A,
	kConfigNodeSwVersionKey			= 0x0B,
	kConfigNodeCapabilitiesKey		= 0x0C,
	kConfigNodeUniqueIdKey			= 0x0D,
	kConfigNodeUnitsExtentKey		= 0x0E,
	kConfigNodeMemoryExtentKey		= 0x0F,
	kConfigNodeDependentInfoKey		= 0x10,
	kConfigUnitDirectoryKey			= 0x11,
	kConfigUnitSpecIdKey			= 0x12,
	kConfigUnitSwVersionKey			= 0x13,
	kConfigUnitDependentInfoKey		= 0x14,
	kConfigUnitLocationKey			= 0x15,
	kConfigUnitPollMaskKey			= 0x16,
	kConfigModelIdKey				= 0x17,
	kConfigGenerationKey			= 0x38,		// Apple-specific

	kConfigRootDirectoryKey			= 0xffff	// Not a real key
};

enum
{
	kConfigSBP2LUN					= 0x14,
	kConfigSBP2Revision				= 0x21,
	kConfigSBP2MAO					= 0x54	
};

// Core CSR registers.
enum
{
	kCSRStateUnitDepend			= CSRBitRange(0, 15),
	kCSRStateUnitDependPhase	= CSRBitRangePhase(0, 15),

	kCSRStateBusDepend			= CSRBitRange(16, 23),
	kCSRStateBusDependPhase		= CSRBitRangePhase(16, 23),

	kCSRStateLost				= CSR_BIT(24),
	kCSRStateDReq				= CSR_BIT(25),
	kCSRStateELog				= CSR_BIT(27),
	kCSRStateAtn				= CSR_BIT(28),
	kCSRStateOff				= CSR_BIT(29),

	kCSRStateState				= CSRBitRange(30, 31),
	kCSRStateStatePhase			= CSRBitRangePhase(30, 31),
	kCSRStateStateRunning		= 0,
	kCSRStateStateInitializing	= 1,
	kCSRStateStateTesting		= 2,
	kCSRStateStateDead			= 3
};

// Config ROM entry bit locations.

enum
{
	kConfigBusInfoBlockLength		= CSRBitRange (0, 7),
	kConfigBusInfoBlockLengthPhase	= CSRBitRangePhase (0, 7),

	kConfigROMCRCLength				= CSRBitRange (8, 15),
	kConfigROMCRCLengthPhase		= CSRBitRangePhase (8, 15),

	kConfigROMCRCValue				= CSRBitRange (16, 31),
	kConfigROMCRCValuePhase			= CSRBitRangePhase (16, 31),

	kConfigEntryKeyType				= CSRBitRange (0, 1),
	kConfigEntryKeyTypePhase		= CSRBitRangePhase (0, 1),

	kConfigEntryKeyValue			= CSRBitRange (2, 7),
	kConfigEntryKeyValuePhase		= CSRBitRangePhase (2, 7),

	kConfigEntryValue				= CSRBitRange (8, 31),
	kConfigEntryValuePhase			= CSRBitRangePhase (8, 31),

	kConfigLeafDirLength			= CSRBitRange (0, 15),
	kConfigLeafDirLengthPhase		= CSRBitRangePhase (0, 15),

	kConfigLeafDirCRC				= CSRBitRange (16, 31),
	kConfigLeafDirCRCPhase			= CSRBitRangePhase (16, 31)
};

//
// Key types.
//
typedef enum
{
	kCSRImmediateKeyType		= 0,
	kCSROffsetKeyType			= 1,
	kCSRLeafKeyType				= 2,
	kCSRDirectoryKeyType		= 3,
    kInvalidCSRROMEntryType		= 0xff
} IOCSRKeyType;

// CSR 64-bit fixed address defs.

enum
{
	kCSRNodeID								= CSRBitRange (0, 15),
	kCSRNodeIDPhase							= CSRBitRangePhase (0, 15),

	kCSRInitialMemorySpaceBaseAddressHi		= 0x00000000,
	kCSRInitialMemorySpaceBaseAddressLo		= 0x00000000,

	kCSRPrivateSpaceBaseAddressHi			= 0x0000FFFF,
	kCSRPrivateSpaceBaseAddressLo			= 0xE0000000,

	kCSRRegisterSpaceBaseAddressHi			= 0x0000FFFF,
	kCSRRegisterSpaceBaseAddressLo			= 0xF0000000,

	kCSRCoreRegistersBaseAddress			= kCSRRegisterSpaceBaseAddressLo,
	kCSRStateClearAddress					= kCSRCoreRegistersBaseAddress + 0x0000,
	kCSRStateSetAddress						= kCSRCoreRegistersBaseAddress + 0x0004,
	kCSRNodeIDsAddress						= kCSRCoreRegistersBaseAddress + 0x0008,
	kCSRResetStartAddress					= kCSRCoreRegistersBaseAddress + 0x000C,
	kCSRIndirectAddressAddress				= kCSRCoreRegistersBaseAddress + 0x0010,
	kCSRIndirectDataAddress					= kCSRCoreRegistersBaseAddress + 0x0014,
	kCSRSplitTimeoutHiAddress				= kCSRCoreRegistersBaseAddress + 0x0018,
	kCSRSplitTimeoutLoAddress				= kCSRCoreRegistersBaseAddress + 0x001C,
	kCSRArgumentHiAddress					= kCSRCoreRegistersBaseAddress + 0x0020,
	kCSRArgumentLoAddress					= kCSRCoreRegistersBaseAddress + 0x0024,
	kCSRTestStartAddress					= kCSRCoreRegistersBaseAddress + 0x0028,
	kCSRTestStatusAddress					= kCSRCoreRegistersBaseAddress + 0x002C,
	kCSRUnitsBaseHiAddress					= kCSRCoreRegistersBaseAddress + 0x0030,
	kCSRUnitsBaseLoAddress					= kCSRCoreRegistersBaseAddress + 0x0034,
	kCSRUnitsBoundHiAddress					= kCSRCoreRegistersBaseAddress + 0x0038,
	kCSRUnitsBoundLoAddress					= kCSRCoreRegistersBaseAddress + 0x003C,
	kCSRMemoryBaseHiAddress					= kCSRCoreRegistersBaseAddress + 0x0040,
	kCSRMemoryBaseLoAddress					= kCSRCoreRegistersBaseAddress + 0x0044,
	kCSRMemoryBoundHiAddress				= kCSRCoreRegistersBaseAddress + 0x0048,
	kCSRMemoryBoundLoAddress				= kCSRCoreRegistersBaseAddress + 0x004C,
	kCSRInterruptTargetAddress				= kCSRCoreRegistersBaseAddress + 0x0050,
	kCSRInterruptMaskAddress				= kCSRCoreRegistersBaseAddress + 0x0054,
	kCSRClockValueHiAddress					= kCSRCoreRegistersBaseAddress + 0x0058,
	kCSRClockValueMidAddress				= kCSRCoreRegistersBaseAddress + 0x005C,
	kCSRClockTickPeriodMidAddress			= kCSRCoreRegistersBaseAddress + 0x0060,
	kCSRClockTickPeriodLoAddress			= kCSRCoreRegistersBaseAddress + 0x0064,
	kCSRClockStrobeArrivedHiAddress			= kCSRCoreRegistersBaseAddress + 0x0068,
	kCSRClockStrobeArrivedMidAddress		= kCSRCoreRegistersBaseAddress + 0x006C,
	kCSRClockInfo0Address					= kCSRCoreRegistersBaseAddress + 0x0070,
	kCSRClockInfo1Address					= kCSRCoreRegistersBaseAddress + 0x0074,
	kCSRClockInfo2Address					= kCSRCoreRegistersBaseAddress + 0x0078,
	kCSRClockInfo3Address					= kCSRCoreRegistersBaseAddress + 0x007C,
	kCSRMessageRequestAddress				= kCSRCoreRegistersBaseAddress + 0x0080,
	kCSRMessageResponseAddress				= kCSRCoreRegistersBaseAddress + 0x00C0,
	kCSRErrorLogBufferAddress				= kCSRCoreRegistersBaseAddress + 0x0180,

	kCSRBusDependentRegistersBaseAddress	= kCSRRegisterSpaceBaseAddressLo + 0x0200,
	kCSRBusyTimeout							= kCSRRegisterSpaceBaseAddressLo + 0x0210,
	kCSRBusManagerID						= kCSRRegisterSpaceBaseAddressLo + 0x021C,
	kCSRBandwidthAvailable					= kCSRRegisterSpaceBaseAddressLo + 0x0220,
	kCSRChannelsAvailable31_0				= kCSRRegisterSpaceBaseAddressLo + 0x0224,
	kCSRChannelsAvailable63_32				= kCSRRegisterSpaceBaseAddressLo + 0x0228,
	kCSRBroadcastChannel					= kCSRRegisterSpaceBaseAddressLo + 0x0234,
	
	kConfigROMBaseAddress					= kCSRRegisterSpaceBaseAddressLo + 0x0400,
	kConfigBIBHeaderAddress					= kConfigROMBaseAddress,
	kConfigBIBBusNameAddress				= kConfigROMBaseAddress + 4,
	
	kPCRBaseAddress							= kCSRRegisterSpaceBaseAddressLo + 0x900,
	kFCPCommandAddress						= kCSRRegisterSpaceBaseAddressLo + 0xb00,
	kFCPResponseAddress						= kCSRRegisterSpaceBaseAddressLo + 0xd00
};

// from figure 10-7 of 1394a
#define kBroadcastChannelInitialValues 	0x8000001f
#define kBroadcastChannelValidMask 		0x40000000

// CSR defined 64 bit unique ID.

typedef UInt64 CSRNodeUniqueID;

// FireWire core CSR registers.

enum
{
	kFWCSRStateGone				= FW_BIT(16),
	kFWCSRStateLinkOff			= FW_BIT(22),
	kFWCSRStateCMstr			= FW_BIT(23)
};

// FireWire bus/nodeID address defs.

enum
{
	kFWAddressBusID				= FWBitRange (16, 25) << kCSRNodeIDPhase,
	kFWAddressBusIDPhase		= FWBitRangePhase (16, 25) + kCSRNodeIDPhase,

	kFWAddressNodeID			= FWBitRange (26, 31) << kCSRNodeIDPhase,
	kFWAddressNodeIDPhase		= FWBitRangePhase (26, 31) + kCSRNodeIDPhase,

	kFWLocalBusID				= 1023,
	kFWBroadcastNodeID			= 63,
	kFWBadNodeID				= 0xffff,

	kFWLocalBusAddress			= kFWLocalBusID << kFWAddressBusIDPhase,
	kFWBroadcastAddress			= kFWBroadcastNodeID << kFWAddressNodeIDPhase
};

#define FWNodeBaseAddress(busID, nodeID)												\
(																						\
	(busID << kFWAddressBusIDPhase) |													\
	(nodeID << kFWAddressNodeIDPhase)													\
)

#define FWNodeRegisterSpaceBaseAddressHi(busID, nodeID)									\
(																						\
	FWNodeBaseAddress (busID, nodeID) |													\
	kCSRRegisterSpaceBaseAddressHi														\
)

// FireWire CSR bus info block defs.

enum
{
	kFWBIBHeaderAddress					= kConfigBIBHeaderAddress,
	kFWBIBBusNameAddress				= kConfigBIBBusNameAddress,
	kFWBIBNodeCapabilitiesAddress		= kConfigROMBaseAddress + 8,
	kFWBIBNodeUniqueIDHiAddress			= kConfigROMBaseAddress + 12,
	kFWBIBNodeUniqueIDLoAddress			= kConfigROMBaseAddress + 16,

	kFWBIBBusName						= 0x31333934, //'1394'

	kFWBIBIrmc							= FW_BIT(0),
	kFWBIBCmc							= FW_BIT(1),
	kFWBIBIsc							= FW_BIT(2),
	kFWBIBBmc							= FW_BIT(3),
	kFWBIBCycClkAcc						= FWBitRange (8, 15),
	kFWBIBCycClkAccPhase				= FWBitRangePhase (8, 15),
	kFWBIBMaxRec						= FWBitRange (16, 19),
	kFWBIBMaxRecPhase					= FWBitRangePhase (16, 19),
	kFWBIBMaxROM						= FWBitRange (20, 21),
	kFWBIBMaxROMPhase					= FWBitRangePhase (20, 21),
	kFWBIBGeneration					= FWBitRange (24, 27),
	kFWBIBGenerationPhase				= FWBitRangePhase (24, 27),
	kFWBIBLinkSpeed						= FWBitRange (29, 31),
	kFWBIBLinkSpeedPhase				= FWBitRangePhase (29, 31)
};

enum
{
	kConfigUnitSpecAppleA27				= 0x000a27,
	kConfigUnitSpec1394TA1				= 0x00a02d,
	
	kConfigUnitSWVersMacintosh10		= 10,
	kConfigUnitSWVersIIDC100			= 0x000100,
	kConfigUnitSWVersIIDC101			= 0x000101,
	kConfigUnitSWVersIIDC102			= 0x000102
};


// =================================================================
// Isoch defines
// =================================================================
#pragma mark -
#pragma mark ISOCH

enum
{
	kFWIsochDataLength		= FWBitRange (0, 15),
	kFWIsochDataLengthPhase	= FWBitRangePhase (0, 15),
	
	kFWIsochTag				= FWBitRange (16, 17),
	kFWIsochTagPhase		= FWBitRangePhase (16, 17),

	kFWIsochChanNum			= FWBitRange (18, 23),
	kFWIsochChanNumPhase	= FWBitRangePhase (18, 23),

	kFWIsochTCode			= FWBitRange (24, 27),
	kFWIsochTCodePhase		= FWBitRangePhase (24, 27),

	kFWIsochSy				= FWBitRange (28, 31),
	kFWIsochSyPhase			= FWBitRangePhase (28, 31)
};

#define CHAN_BIT(x) 		(((UInt64)1) << (63 - (x))
#define CHAN_MASK(x) 		(~CHAN_BIT(X))

typedef enum
{
	kFWNeverMultiMode = 0,
	kFWAllowMultiMode,
	kFWSuggestMultiMode,
	kFWAlwaysMultiMode,
	
	kFWDefaultIsochResourceFlags = kFWNeverMultiMode
} IOFWIsochResourceFlags ;

enum
{
	kFWIsochChannelDefaultFlags = 0,
	kFWIsochChannelDoNotResumeOnWake = BIT(1)
} ;

typedef enum
{
	kFWIsochPortDefaultOptions = 0,
	kFWIsochPortUseSeparateKernelThread		= BIT(1),
	kFWIsochEnableRobustness			= BIT(2),
	kFWIsochBigEndianUpdates			= BIT(3),	// private
	kFWIsochRequireLastContext			= BIT(4),	// private
} IOFWIsochPortOptions ;

// =================================================================
// DCL opcode defs.
// =================================================================
#pragma mark -
#pragma mark DCL OPCODES

enum
{
	kFWDCLImmediateEvent				= 0,
	kFWDCLCycleEvent					= 1,
	kFWDCLSyBitsEvent					= 2
};

typedef enum
{
	kFWDCLInvalidNotification				= 0
	, kFWDCLUpdateNotification				= 1
	, kFWDCLModifyNotification				= 2
	, kFWNuDCLModifyNotification			= 3
	, kFWNuDCLModifyJumpNotification		= 4
	, kFWNuDCLUpdateNotification			= 5
} IOFWDCLNotificationType ;

enum
{
	kFWDCLOpDynamicFlag					= BIT(16),
	kFWDCLOpVendorDefinedFlag			= BIT(17),
	kFWDCLOpFlagMask					= BitRange (16, 31),
	kFWDCLOpFlagPhase					= BitRangePhase (16, 31)
};

enum
{
	kDCLInvalidOp						= 0,
	kDCLSendPacketStartOp				= 1,
	//kDCLSendPacketWithHeaderStartOp		= 2, // Deprecated legacy DCL opcode! Use NuDCL instead!
	kDCLSendPacketOp					= 3,
	kDCLSendBufferOp					= 4,	// obsolete - do not use
	kDCLReceivePacketStartOp			= 5,
	kDCLReceivePacketOp					= 6,
	kDCLReceiveBufferOp					= 7,	// obsolete - do not use
	kDCLCallProcOp						= 8,
	kDCLLabelOp							= 9,
	kDCLJumpOp							= 10,
	kDCLSetTagSyncBitsOp				= 11,
	kDCLUpdateDCLListOp					= 12,
	kDCLTimeStampOp						= 13,
	kDCLPtrTimeStampOp					= 14,
	kDCLSkipCycleOp						= 15,

	kDCLNuDCLLeaderOp					= 20	// compilerData field contains NuDCLRef to start of NuDCL
												// program.
												// Should not need to use this directly.
};

#ifdef FW_OLD_DCL_DEFS

//typedef struct DCLCommandStruct ;
//typedef void (DCLCallCommandProc)(DCLCommandStruct* command);

#else

//typedef struct DCLCommand ;
//typedef void (DCLCallCommandProc)(DCLCommand* command);

#endif

// =================================================================
// DCL structs
// =================================================================
#pragma mark -
#pragma mark DCL

#ifdef __LP64__		
typedef void* DCLCallProcDataType;
#else
typedef UInt32 DCLCallProcDataType;
#endif

#ifdef KERNEL
	#ifdef __LP64__		
		typedef void* DCLCompilerDataType;
	#else
		typedef UInt32 DCLCompilerDataType;
	#endif
#else
		typedef UInt32 DCLCompilerDataType;
#endif

typedef struct DCLCommandStruct
{
	struct DCLCommandStruct *	pNextDCLCommand;		// Next DCL command.
	DCLCompilerDataType			compilerData;			// Data for use by DCL compiler.
	UInt32						opcode;					// DCL opcode.
	UInt32						operands[1];			// DCL operands (size varies)
} DCLCommand;

typedef void (DCLCallCommandProc)(DCLCommand * command);

typedef struct DCLTransferPacketStruct
{
	DCLCommand *			pNextDCLCommand;		// Next DCL command.
	DCLCompilerDataType		compilerData;			// Data for use by DCL compiler.
	UInt32					opcode;					// DCL opcode.
	void *					buffer;					// Packet buffer.
	UInt32					size;					// Buffer size.
} DCLTransferPacket ;

typedef struct DCLTransferBufferStruct
{
	DCLCommand *			pNextDCLCommand;		// Next DCL command.
	DCLCompilerDataType		compilerData;			// Data for use by DCL compiler.
	UInt32					opcode;					// DCL opcode.
	void *					buffer;					// Buffer.
	UInt32					size;					// Buffer size.
	UInt16					packetSize;				// Size of packets to send.
	UInt16					reserved;
	UInt32					bufferOffset;			// Current offset into buffer.
} DCLTransferBuffer ;

typedef struct DCLCallProcStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	DCLCallCommandProc *	proc;				// Procedure to call.
	DCLCallProcDataType		procData;			// Data for use by called procedure.
} DCLCallProc;

typedef struct DCLLabelStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
} DCLLabel;

typedef struct DCLJumpStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	DCLLabel *				pJumpDCLLabel;		// DCL label to jump to.
} DCLJump;

typedef struct DCLSetTagSyncBitsStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	UInt16					tagBits;			// Tag bits for following packets.
	UInt16					syncBits;			// Sync bits for following packets.
} DCLSetTagSyncBits;

typedef struct DCLUpdateDCLListStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	DCLCommand **			dclCommandList;		// List of DCL commands to update.
	UInt32					numDCLCommands;		// Number of DCL commands in list.
} DCLUpdateDCLList;

typedef struct DCLTimeStampStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	UInt32					timeStamp;			// Time stamp.
} DCLTimeStamp;

typedef struct DCLPtrTimeStampStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	UInt32 *				timeStampPtr;		// Where to store the time stamp.
} DCLPtrTimeStamp ;

typedef struct 
{
	DCLCommand *			pNextDCLCommand ;	// unused - always NULL
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode ;			// must be kDCLNuDCLLeaderOp
	void*				 	program ;			// NuDCL program here...
} DCLNuDCLLeader ;

#ifdef FW_OLD_DCL_DEFS

//  should not use these...

typedef DCLCommand*				DCLCommandPtr ;
typedef DCLTransferBuffer*		DCLTransferBufferPtr ;
typedef DCLTransferPacket*		DCLTransferPacketPtr ;
typedef DCLCallProc*			DCLCallProcPtr ;
typedef DCLLabel*				DCLLabelPtr ;
typedef DCLJump*				DCLJumpPtr ;
typedef DCLSetTagSyncBits*		DCLSetTagSyncBitsPtr ;
typedef DCLUpdateDCLList*		DCLUpdateDCLListPtr ;
typedef DCLTimeStamp*			DCLTimeStampPtr ;
typedef DCLPtrTimeStamp*		DCLPtrTimeStampPtr ;
typedef DCLCallCommandProc* 	DCLCallCommandProcPtr ;

#endif


// =================================================================
// User-Lib Export DCL structs - Thses structus are used to pass
// a user-created legacy DCL program down into kernel space. These
// structs allow support for both 32-bit and 64-bit user-space clients.
// These structs should only be used internally. They are not for
// clients to create DCL programs with.
// =================================================================

typedef struct UserExportDCLCommandStruct
{
	mach_vm_address_t					pClientDCLStruct;		// A pointer to the client's DCL struct
	mach_vm_address_t					pNextDCLCommand;		// Next DCL command.
	uint64_t							compilerData;			// Data for use by DCL compiler.
	UInt32								opcode;					// DCL opcode.
	UInt32								operands[1];			// DCL operands (size varies)
} __attribute__ ((packed)) UserExportDCLCommand;

typedef void (UserExportDCLCallCommandProc)(UserExportDCLCommand * command);

typedef struct UserExportDCLTransferPacketStruct
{
	mach_vm_address_t		pClientDCLStruct;		// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;		// Next DCL command.
	uint64_t				compilerData;			// Data for use by DCL compiler.
	UInt32					opcode;					// DCL opcode.
	mach_vm_address_t		buffer;					// Packet buffer.
	UInt32					size;					// Buffer size.
} __attribute__ ((packed)) UserExportDCLTransferPacket ;

typedef struct UserExportDCLTransferBufferStruct
{
	mach_vm_address_t		pClientDCLStruct;		// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;		// Next DCL command.
	uint64_t				compilerData;			// Data for use by DCL compiler.
	UInt32					opcode;					// DCL opcode.
	mach_vm_address_t		buffer;					// Buffer.
	UInt32					size;					// Buffer size.
	UInt16					packetSize;				// Size of packets to send.
	UInt16					reserved;
	UInt32					bufferOffset;			// Current offset into buffer.
} __attribute__ ((packed)) UserExportDCLTransferBuffer ;

typedef struct UserExportDCLCallProcStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	mach_vm_address_t		proc;				// Procedure to call.
	uint64_t				procData;			// Data for use by called procedure.
} __attribute__ ((packed)) UserExportDCLCallProc;

typedef struct UserExportDCLLabelStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
} __attribute__ ((packed)) UserExportDCLLabel;

typedef struct UserExportDCLJumpStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	mach_vm_address_t		pJumpDCLLabel;		// DCL label to jump to.
} __attribute__ ((packed)) UserExportDCLJump;

typedef struct UserExportDCLSetTagSyncBitsStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	UInt16					tagBits;			// Tag bits for following packets.
	UInt16					syncBits;			// Sync bits for following packets.
} __attribute__ ((packed)) UserExportDCLSetTagSyncBits;

typedef struct UserExportDCLUpdateDCLListStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	mach_vm_address_t		dclCommandList;		// List of DCL commands to update.
	UInt32					numDCLCommands;		// Number of DCL commands in list.
} __attribute__ ((packed)) UserExportDCLUpdateDCLList;

typedef struct UserExportDCLTimeStampStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	UInt32					timeStamp;			// Time stamp.
} __attribute__ ((packed)) UserExportDCLTimeStamp;

typedef struct UserExportDCLPtrTimeStampStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	mach_vm_address_t		timeStampPtr;		// Where to store the time stamp.
} __attribute__ ((packed)) UserExportDCLPtrTimeStamp ;

typedef struct 
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand ;	// unused - always NULL
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode ;			// must be kDCLNuDCLLeaderOp
	mach_vm_address_t	 	program ;			// NuDCL program here...
} __attribute__ ((packed)) UserExportDCLNuDCLLeader ;


// =================================================================
// NuDCL
// =================================================================
#pragma mark -
#pragma mark NUDCL

typedef struct __NuDCL *	NuDCLRef ;
typedef NuDCLRef			NuDCLSendPacketRef ;
typedef NuDCLRef			NuDCLSkipCycleRef ;
typedef NuDCLRef			NuDCLReceivePacketRef ;

typedef void (*NuDCLCallback)( void* refcon, NuDCLRef dcl );

typedef enum
{
	kNuDCLDynamic = BIT( 1 ),
	kNuDCLUpdateBeforeCallback = BIT( 2 )

} NuDCLFlags ;

// =================================================================
// Miscellaneous
// =================================================================
#pragma mark -
#pragma mark MISCELLANEOUS

typedef void* FWClientCommandID ;

typedef struct IOFireWireSessionRefOpaqueStuct* IOFireWireSessionRef ;

//
// bus management constants.
//

enum
{
	kFWBusManagerArbitrationTimeoutDuration	= 625 // durationMillisecond
};

//
// bus characteristics.
//

enum
{
	kFWMaxBusses				= 1023,
	kFWMaxNodesPerBus			= 63,
	kFWMaxNodeHops				= 16
};

/*! @enum		NodeFlags

	@abstract	Flags that specify characteristics of the FireWire device node.
	
	@constant	kIOFWDisablePhysicalAccess 		Disable physical memory access
	
	@constant	kIOFWDisableAllPhysicalAccess	Disable all physical memory access
	
	@constant	kIOFWEnableRetryOnAckD			Enable retry on Ack D
	
	@constant	kIOFWLimitAsyncPacketSize		Limit async packet size
	
	@constant	kIOFWDisablePhyOnSleep			Disable Phy, when machine is in Sleep mode
	
	@constant	kIOFWMustBeRoot					Attempt to make this device root, There is no guarentee Mac OS will succeed in making the device 
	                                            root.
												
	@constant	kIOFWMustNotBeRoot				Attempt to prevent this device from being root, There is no guarentee Mac OS will succeed in preventing the device 
	                                            from being root.
												
	@constant	kIOFWMustHaveGap63				Attempt to ensure the gap count is 63, when this device is on the bus. Gap 63 reduces bus performance significantly,
												so this flag should be used only when absolutely necessary. There is no guarentee Mac OS will succeed in forcing
												the gap count to 63.
*/
enum
{
    kIOFWDisablePhysicalAccess 		= (1 << 0),
	kIOFWDisableAllPhysicalAccess 	= (1 << 1),
	kIOFWEnableRetryOnAckD			= (1 << 2),
	kIOFWLimitAsyncPacketSize		= (1 << 3),
	kIOFWDisablePhyOnSleep			= (1 << 4),
	kIOFWMustBeRoot					= (1 << 5),
	kIOFWMustNotBeRoot				= (1 << 6),
	kIOFWMustHaveGap63				= (1 << 7)
};

//
// write flags
//

enum IOFWWriteFlags
{
	kIOFWWriteFlagsNone				= 0x00000000,
	kIOFWWriteFlagsDeferredNotify 	= 0x00000001,
	kIOFWWriteFastRetryOnBusy		= 0x00000002,
	kIOFWWriteBlockRequest			= 0x00000004,		// force a block request
};

//
// read flags
//

enum IOFWReadFlags
{
	kIOFWReadFlagsNone				= 0x00000000,
	kIOFWReadBlockRequest			= 0x00000004,		// force a block request
	kIOFWReadPingTime				= 0x00000008		// ping time
};

//
// security modes
//

enum IOFWSecurityMode
{
	kIOFWSecurityModeNormal = 0,
	kIOFWSecurityModeSecure = 1,
	kIOFWSecurityModeSecurePermanent = 2
};

//
// physical access settings
//

enum IOFWPhysicalAccessMode
{
	kIOFWPhysicalAccessEnabled = 0,
	kIOFWPhysicalAccessDisabled = 1,
	kIOFWPhysicalAccessDisabledForGeneration = 2
};

enum
{
	kIOFWSpecID_AAPL = 0xa27,
	kIOFWSWVers_KPF = 0x40
};

// old style bit defs
#ifdef FW_OLD_BIT_DEFS

	#define kBit0	BIT(0)
	#define kBit1	BIT(1)
	#define kBit2	BIT(2)
	#define kBit3	BIT(3)
	#define kBit4	BIT(4)
	#define kBit5	BIT(5)
	#define kBit6	BIT(6)
	#define kBit7	BIT(7)
	#define kBit8	BIT(8)
	#define kBit9	BIT(9)
	#define kBit10	BIT(10)
	#define kBit11	BIT(11)
	#define kBit12	BIT(12)
	#define kBit13	BIT(13)
	#define kBit14	BIT(14)
	#define kBit15	BIT(15)
	#define kBit16	BIT(16)
	#define kBit17	BIT(17)
	#define kBit18	BIT(18)
	#define kBit19	BIT(19)
	#define kBit20	BIT(20)
	#define kBit21	BIT(21)
	#define kBit22	BIT(22)
	#define kBit23	BIT(23)
	#define kBit24	BIT(24)
	#define kBit25	BIT(25)
	#define kBit26	BIT(26)
	#define kBit27	BIT(27)
	#define kBit28	BIT(28)
	#define kBit29	BIT(29)
	#define kBit30	BIT(30)
	#define kBit31	BIT(31)

#endif

#endif //__IOFireWireFamilyCommon_H__
                                                            IOFireWireIRMAllocation.h                                                                           0100644 0001750 0001750 00000010150 12567451747 040341  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFIREWIREIRMALLOCATION_H
#define _IOKIT_IOFIREWIREIRMALLOCATION_H

#include <libkern/c++/OSObject.h>

class IOFireWireController;

//#include <IOKit/firewire/IOFireWireController.h>
//#include <IOKit/firewire/IOFireWireFamilyCommon.h>

/*! @class IOFireWireIRMAllocation
*/

class IOFireWireIRMAllocation : public OSObject
{
	friend class IOFireWireController;

    OSDeclareDefaultStructors(IOFireWireIRMAllocation)
	
public:
		
		// Prototype for the callback if reallocation after bus-reset is unsuccessful.
		typedef IOReturn (*AllocationLostNotificationProc)(void* refCon, class IOFireWireIRMAllocation* allocation);

	// Initialize the IRM allocation object. 
    virtual bool init( IOFireWireController * control,
					   Boolean releaseIRMResourcesOnFree = true, 
					   AllocationLostNotificationProc allocationLostProc = NULL,
					   void *pLostProcRefCon = NULL);
    	
	// Specify whether of not the IRM resources should automatically
	// be released when freeing this allocation object.
	virtual void setReleaseIRMResourcesOnFree(Boolean doRelease);
	
	// Use the IRMAllocation object to allocate isoch resources
	virtual IOReturn allocateIsochResources(UInt8 isochChannel, UInt32 bandwidthUnits);

	// Free isoch resources previously allocated with a call to allocateIsochResources
	virtual IOReturn deallocateIsochResources(void);
	
	// Returns true if isoch resources are currently allocated, and if true, the allocated channel, and amount of isoch bandwidth.
	virtual Boolean areIsochResourcesAllocated(UInt8 *pAllocatedIsochChannel, UInt32 *pAllocatedBandwidthUnits);
	
	// Get the refcon
	virtual void * GetRefCon(void);
	virtual void SetRefCon(void* refCon); 

	// Override the base-class release function for special processing
	virtual void release() const;
	
protected:

		/*! @struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
		*/    
		struct ExpansionData { };
	
		/*! @var reserved
		Reserved for future use.  (Internal use only)  */
		ExpansionData *reserved;

		// Free the allocation object (and release IRM resources if needed)
		virtual void free( void );

		// Controller will call this to notify about bus-reset complete.
		virtual void handleBusReset(UInt32 generation);
	
		virtual void failedToRealloc(void);
		virtual UInt32 getAllocationGeneration(void);
		static void threadFunc( void * arg );

private:
	
	AllocationLostNotificationProc fAllocationLostProc;
	void *fLostProcRefCon;
	Boolean fReleaseIRMResourcesOnFree;
	UInt8 fIsochChannel; 
	UInt32 fBandwidthUnits;
	UInt32 fAllocationGeneration;
	IORecursiveLock *fLock ;
	IOFireWireController *fControl;
	Boolean isAllocated;
	
	OSMetaClassDeclareReservedUnused(IOFireWireIRMAllocation, 0);
	OSMetaClassDeclareReservedUnused(IOFireWireIRMAllocation, 1);
	OSMetaClassDeclareReservedUnused(IOFireWireIRMAllocation, 2);
	OSMetaClassDeclareReservedUnused(IOFireWireIRMAllocation, 3);
	OSMetaClassDeclareReservedUnused(IOFireWireIRMAllocation, 4);
	OSMetaClassDeclareReservedUnused(IOFireWireIRMAllocation, 5);
	OSMetaClassDeclareReservedUnused(IOFireWireIRMAllocation, 6);
	OSMetaClassDeclareReservedUnused(IOFireWireIRMAllocation, 7);
};

#endif // _IOKIT_IOFIREWIREIRMALLOCATION_H
                                                                                                                                                                                                                                                                                                                                                                                                                        IOFireWireLocalNode.h                                                                               0100644 0001750 0001750 00000007312 12567451747 037552  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 *  IOFireWireLocalNode.h
 *  IOFireWireFamily
 *
 *  Created by Niels on Fri Aug 16 2002.
 *  Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
	$Log: not supported by cvs2svn $
	Revision 1.7  2008/11/14 00:17:12  arulchan
	fix for rdar://5939334
	
	Revision 1.6  2005/02/18 22:56:53  gecko1
	3958781 Q45C EVT: FireWire ASP reporter says port speed is 800 Mb/sec
	
	Revision 1.5  2003/02/20 02:00:12  collin
	*** empty log message ***
	
	Revision 1.4  2003/02/17 21:47:53  collin
	*** empty log message ***
	
	Revision 1.3  2002/10/18 23:29:44  collin
	fix includes, fix cast which fails on new compiler
	
	Revision 1.2  2002/09/25 00:27:24  niels
	flip your world upside-down
	
*/

// public
#import <IOKit/firewire/IOFireWireNub.h>

class IOFireWireLocalNode;

#pragma mark -

/*! 
	@class IOFireWireLocalNodeAux
*/

class IOFireWireLocalNodeAux : public IOFireWireNubAux
{
    OSDeclareDefaultStructors(IOFireWireLocalNodeAux)

	friend class IOFireWireLocalNode;
	
protected:
	
	/*! 
		@struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
    */  
	  
    struct ExpansionData { };

	/*! 
		@var reserved
		Reserved for future use.  (Internal use only)  
	*/
    
	ExpansionData * reserved;

    virtual bool init( IOFireWireLocalNode * primary );
	virtual	void free();
	
private:
    OSMetaClassDeclareReservedUnused(IOFireWireLocalNodeAux, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireLocalNodeAux, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireLocalNodeAux, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireLocalNodeAux, 3);
	
};

#pragma mark -

/*! @class IOFireWireLocalNode
*/

class IOFireWireLocalNode : public IOFireWireNub
{
    OSDeclareDefaultStructors(IOFireWireLocalNode)

	friend class IOFireWireLocalNodeAux;

	/*------------------Useful info about device (also available in the registry)--------*/
protected:

	/*-----------Methods provided to FireWire device clients-------------*/
public:
	
		// Set up properties affected by bus reset
		virtual void setNodeProperties(UInt32 generation, UInt16 nodeID, UInt32 *selfIDs, int numIDs, IOFWSpeed maxSpeed );
		
		/*
		* Standard nub initialization
		*/
		virtual bool init(OSDictionary * propTable);
		virtual bool attach(IOService * provider );
	
		virtual void handleClose(   IOService *	  forClient,
								IOOptionBits	  options ) ;
		virtual bool handleOpen( 	IOService *	  forClient,
								IOOptionBits	  options,
								void *		  arg ) ;
		virtual bool handleIsOpen(  const IOService * forClient ) const;
	
		/*
		* Trick method to create protocol user clients
		*/
		virtual IOReturn setProperties( OSObject * properties );

protected:
	
	virtual IOFireWireNubAux * createAuxiliary( void );

public:
	virtual IOReturn message( UInt32 type, IOService * provider, void * argument );
	virtual void free();

protected:
	OSSet * fOpenClients;
};
                                                                                                                                                                                                                                                                                                                      IOFireWireMultiIsochReceive.h                                                                       0100644 0001750 0001750 00000011757 12567451747 041305  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 2008 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@ 
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFIREWIREMULTIISOCHRECEIVE_H_
#define _IOKIT_IOFIREWIREMULTIISOCHRECEIVE_H_

class IOFireWireMultiIsochReceiveListener;
class IOFireWireMultiIsochReceivePacket;
class IOFireWireController;

typedef IOReturn (*FWMultiIsochReceiveListenerCallback)(void *refcon, IOFireWireMultiIsochReceivePacket *pPacket);

// These are the parameters clients can set which help us to optimize the mult-isoch-receiver 
// polling interval, and memory resources 
typedef struct FWMultiIsochReceiveListenerParamsStruct
	{
		// How much latency, from when the packet arrives to when the client is notified, can the client tolerate. 
		UInt32 maxLatencyInFireWireCycles;
		
		// In bits per second, the expected bit-rate of the incoming stream
		UInt32 expectedStreamBitRate;
		
		// How long does the client expect to hold onto packets objects before returning them back to the receiver
		UInt32 clientPacketReturnLatencyInFireWireCycles;
	}FWMultiIsochReceiveListenerParams;

/*! @class IOFireWireMultiIsochReceiveListener
*/

class IOFireWireMultiIsochReceiveListener : public OSObject
	{
		friend class IOFireWireLink;
		
	protected:
		OSDeclareDefaultStructors(IOFireWireMultiIsochReceiveListener)
		bool init(IOFireWireController *fwController,
				  UInt32 receiveChannel,
				  FWMultiIsochReceiveListenerCallback callback,
				  void *pCallbackRefCon,
				  FWMultiIsochReceiveListenerParams *pListenerParams);
		void free();
	public:
		static IOFireWireMultiIsochReceiveListener *create(IOFireWireController *fwController,
														   UInt32 channel,
														   FWMultiIsochReceiveListenerCallback callback,
														   void *pCallbackRefCon,
														   FWMultiIsochReceiveListenerParams *pListenerParams);
		
		// Call this to activate the listener
		IOReturn Activate();
		
		// Call this to deactivate the listener
		IOReturn Deactivate();
		
		// Call this to modify the callback/refcon pointers. Only call this when not activated!
		IOReturn SetCallback(FWMultiIsochReceiveListenerCallback callback,
							 void *pCallbackRefCon);
		
		// Accessors
		inline UInt32 getReceiveChannel(void) {return fChannel;};
		inline FWMultiIsochReceiveListenerCallback getCallback(void){return fClientCallback;}; 
		inline void * getRefCon(void){return fClientCallbackRefCon;};
		inline bool getActivatedState(void) {return fActivated;};
		
	protected:
		IOFireWireController *fControl;
		UInt32 fChannel;
		FWMultiIsochReceiveListenerCallback fClientCallback;
		void *fClientCallbackRefCon;
		bool fActivated;
		FWMultiIsochReceiveListenerParams *fListenerParams;
	};

#define kMaxRangesPerMultiIsochReceivePacket 6

/*! @class IOFireWireMultiIsochReceivePacket
*/

class IOFireWireMultiIsochReceivePacket : public OSObject
	{
		OSDeclareDefaultStructors(IOFireWireMultiIsochReceivePacket)
		bool init(IOFireWireController *fwController);
		void free();
	public:
		static IOFireWireMultiIsochReceivePacket *create(IOFireWireController *fwController);
		
		// The clients who are passed this packet by the 
		// multi-isoch receiver calling their callback
		// MUST call clientDone() on this packet to
		// return it back for reuse!
		void clientDone(void);
		
		UInt32 isochChannel(void);
		UInt32 packetReceiveTime(void);
		
		UInt32 isochPayloadSize(void);	// The size of just the isoch payload, not including header/trailer quads.
		inline UInt32 isochPacketSize(void) {return isochPayloadSize()+8; };	// The size of the packet, including header/trailer quads.
		
		// This returns a memory descriptor to the client. The client must call complete(), and release() on the
		// memory descriptor when done.
		IOMemoryDescriptor *createMemoryDescriptorForRanges(void);
		
		// These should be treated as read-only by clients,
		// as should the data contained in these buffers!
		IOAddressRange ranges[kMaxRangesPerMultiIsochReceivePacket] ;
		UInt32 numRanges;
		
		// These should be treated private for clients!
		// Messing with them will screw up the bookkeepping
		// in the Multi-Isoch Receiver!
		UInt32 numClientReferences;
		void* elements[kMaxRangesPerMultiIsochReceivePacket];
		
	protected:
		IOFireWireController *fControl;
	};

#endif                 IOFireWireNub.h                                                                                     0100644 0001750 0001750 00000023460 12567451747 036440  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *
 *	IOFireWireNub.h
 *
 *
 * 	Note: IOFWCommand(s) are allocated by methods in this class. 
 *            The remaining methods to setup and submit IOFWCommands are defined in
 *            IOFWCommand.h
 */
#ifndef _IOKIT_IOFIREWIRENUB_H
#define _IOKIT_IOFIREWIRENUB_H

// public
#include <IOKit/IOService.h>
#include <IOKit/firewire/IOFWCommand.h>
#include <IOKit/firewire/IOFWAddressSpace.h>

class IOFireWireController;
class IOFireWireBus;
class IOConfigDirectory;
class IOFireWireNub;
class IOFireWireDevice;
class IOFireWireUnit;
class IOFWSimplePhysicalAddressSpace;
class IOFWSimpleContiguousPhysicalAddressSpace;

enum TerminationState
{
	kNotTerminated = 0,
	kNeedsTermination,
	kTerminated
};

#pragma mark -

/*! 
	@class IOFireWireNubAux
*/

class IOFireWireNubAux : public OSObject
{
    OSDeclareDefaultStructors(IOFireWireNubAux)

	friend class IOFireWireNub;
	
protected:
	
	IOFireWireNub * 		fPrimary;
	TerminationState		fTerminationState;
	
	/*! 
		@struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
    */  
	  
    struct ExpansionData { };

	/*! 
		@var reserved
		Reserved for future use.  (Internal use only)  
	*/
    
	ExpansionData * reserved;

    virtual bool init( IOFireWireNub * primary );
	virtual	void free();

	virtual UInt32 hopCount( IOFireWireNub * nub );
	virtual UInt32 hopCount( void );
	
	virtual TerminationState getTerminationState( void );
	virtual void setTerminationState( TerminationState state );

	virtual bool isPhysicalAccessEnabled( void );

	virtual IOFWSimpleContiguousPhysicalAddressSpace * createSimpleContiguousPhysicalAddressSpace( vm_size_t size, IODirection direction );
		
    virtual IOFWSimplePhysicalAddressSpace * createSimplePhysicalAddressSpace( vm_size_t size, IODirection direction );
	
private:
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 3);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 4);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 5);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 6);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 7);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 8);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 9);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 10);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 11);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 12);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 13);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 14);
    OSMetaClassDeclareReservedUnused(IOFireWireNubAux, 15);
	
};

#pragma mark -

/*! @class IOFireWireNub
*/
class IOFireWireNub : public IOService
{
    OSDeclareAbstractStructors(IOFireWireNub)

    friend class IOFireWireController;
    friend class IOFireWireNubAux;
	friend class IOFireWireDeviceAux;
	friend class IOFireWireUnitAux;
	friend class IOFireWireDevice;
	friend class IOFireWireUnit;
   
/*------------------Useful info about device (also available in the registry)--------*/
protected:
    int			fDeviceSpeed;	// Max supported by device
    int			fCommsSpeed;	// Max speed this node can communicate with device
    UInt16		fNodeID;	// Current node ID (could change after bus reset!)
    UInt16		fLocalNodeID;	// ID of the local node (could change after bus reset!)
    UInt32		fGeneration;	// ID Of bus topology that fNodeID is valid for.
    CSRNodeUniqueID	fUniqueID;	// Device's globally unique ID (never changes)
    mach_timespec_t	fAsyncTimeout;	// Guesstimate of how long to wait for response
					// from device when making async requests
					// Different values for quad/block transfers?
					// OS8 FW has 40/100 mSec.

    int			fMaxReadPackLog;
    int			fMaxWritePackLog;
    int			fMaxReadROMPackLog;

    IOFireWireController *fControl;        
    IOConfigDirectory	*fDirectory;

    UInt32		fNodeFlags;
    
	OSSet *	 fConfigDirectorySet;

	IOFireWireNubAux * fAuxiliary;
		
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

    virtual void free();

/*------------------Methods provided to FireWire device clients-----------------------*/
public:

    // Get nodeID and bus generation info
    IOReturn getNodeIDGeneration(UInt32 &generation, UInt16 &nodeID, UInt16 &localID) const;
    IOReturn getNodeIDGeneration(UInt32 &generation, UInt16 &nodeID) const;
    
    // How fast can this system talk to the node?
    virtual IOFWSpeed FWSpeed() const;

    // How fast can this node talk to another node?
    virtual IOFWSpeed FWSpeed(const IOFireWireNub *dst) const;

    // How big (as a power of two) can packets sent to/received from the node be?
    virtual int maxPackLog(bool forSend) const;

    // How big (as a power of two) can packets sent to/received from a specified address in the node be?
    virtual int maxPackLog(bool forSend, FWAddress address) const;
   
    // How big (as a power of two) can packets sent from this node to dst node/received from dst be?
    virtual int maxPackLog(bool forSend, const IOFireWireNub *dst) const;

    // Set maximum packet size nub can handle
    virtual void setMaxPackLog(bool forSend, bool forROM, int maxPackLog);
    
    /*
     * Create various FireWire commands to send to the device
     */
    virtual IOFWReadCommand 	*createReadCommand(FWAddress devAddress, IOMemoryDescriptor *hostMem,
				FWDeviceCallback completion=NULL, void *refcon=NULL,
 				bool failOnReset=false);
    virtual IOFWReadQuadCommand *createReadQuadCommand(FWAddress devAddress, UInt32 *quads, int numQuads,
				FWDeviceCallback completion=NULL, void *refcon=NULL,
 				bool failOnReset=false);

    virtual IOFWWriteCommand 	*createWriteCommand(FWAddress devAddress, IOMemoryDescriptor *hostMem,
				FWDeviceCallback completion=NULL, void *refcon=NULL,
 				bool failOnReset=false);
    virtual IOFWWriteQuadCommand *createWriteQuadCommand(FWAddress devAddress, UInt32 *quads, int numQuads,
				FWDeviceCallback completion=NULL, void *refcon=NULL,
 				bool failOnReset=false);

    // size is 1 for 32 bit compare, 2 for 64 bit.
    virtual IOFWCompareAndSwapCommand 	*createCompareAndSwapCommand(FWAddress devAddress,
				const UInt32 *cmpVal, const UInt32 *newVal, int size,
				FWDeviceCallback completion=NULL, void *refcon=NULL,
 				bool failOnReset=false);
    /*
     * Create local FireWire address spaces for the device to access
     */
    virtual IOFWPhysicalAddressSpace *createPhysicalAddressSpace(IOMemoryDescriptor *mem);
    virtual IOFWPseudoAddressSpace *createPseudoAddressSpace(FWAddress *addr, UInt32 len,
                    FWReadCallback reader, FWWriteCallback writer, void *refcon);

    /*
     * Get Config directory for nub
     * Device nub directory is root directory, Unit nub directory is Unit directory.
	 *
	 * Depricated use getConfigDirectoryRef
     *
	 */
    
	virtual IOReturn getConfigDirectory(IOConfigDirectory *&dir);

    /*
     * Get bus for nub
     */
    IOFireWireBus * getBus() const;

    IOFireWireController * getController() const;

    const CSRNodeUniqueID &getUniqueID() const;

    /*
     * Standard nub initialization
     */
    virtual bool init(OSDictionary * propTable);

    virtual void setNodeFlags( UInt32 flags );
    virtual UInt32 getNodeFlags( void );
	virtual void clearNodeFlags( UInt32 flags );
	
	virtual IOReturn setConfigDirectory( IOConfigDirectory *directory );

    virtual IOReturn getConfigDirectoryRef( IOConfigDirectory *&dir );

	inline UInt32 hopCount( IOFireWireNub * nub )
		{ return fAuxiliary->hopCount( nub ); }
		
	inline UInt32 hopCount( void )
		{ return fAuxiliary->hopCount(); }

	inline TerminationState getTerminationState( void )
		{ return fAuxiliary->getTerminationState(); }
				
protected:
	inline void setTerminationState( TerminationState state )
		{ fAuxiliary->setTerminationState( state ); }

	virtual IOFireWireNubAux * createAuxiliary( void );

public:

	inline bool isPhysicalAccessEnabled( void )
		{ return fAuxiliary->isPhysicalAccessEnabled(); }

	inline IOFWSimpleContiguousPhysicalAddressSpace * createSimpleContiguousPhysicalAddressSpace( vm_size_t size, IODirection direction )
		{ return fAuxiliary->createSimpleContiguousPhysicalAddressSpace( size, direction ); }
		
    inline IOFWSimplePhysicalAddressSpace * createSimplePhysicalAddressSpace( vm_size_t size, IODirection direction )
		{ return fAuxiliary->createSimplePhysicalAddressSpace( size, direction ); }
    
private:
    OSMetaClassDeclareReservedUsed(IOFireWireNub, 0);
	OSMetaClassDeclareReservedUsed(IOFireWireNub, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireNub, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireNub, 3);

};

#endif /* ! _IOKIT_IOFIREWIRENUB_H */
                                                                                                                                                                                                                IOFireWirePowerManager.h                                                                            0100644 0001750 0001750 00000005217 12567451747 040303  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 
#ifndef _IOKIT_IOFIREWIREPOWERMANAGER_H
#define _IOKIT_IOFIREWIREPOWERMANAGER_H

#include <IOKit/firewire/IOFireWireFamilyCommon.h>

#include <libkern/c++/OSObject.h>
#include <IOKit/IOReturn.h>

class IOFireWireController;

/*! @class IOFireWirePowerManager
*/

class IOFireWirePowerManager : public OSObject
{
    OSDeclareAbstractStructors(IOFireWirePowerManager);

protected:
    
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

	IOFireWireController *	fControl;
	
	UInt32		fMaximumDeciwatts;
	UInt32		fAllocatedDeciwatts;

public:	
	static IOFireWirePowerManager * createWithController( IOFireWireController * controller );
	
	virtual bool initWithController( IOFireWireController * controller );

	virtual void setMaximumDeciwatts( UInt32 deciwatts );
	virtual IOReturn allocateDeciwatts( UInt32 deciwatts );
	virtual void deallocateDeciwatts( UInt32 deciwatts );
	
private:
    OSMetaClassDeclareReservedUnused(IOFireWirePowerManager, 0);
    OSMetaClassDeclareReservedUnused(IOFireWirePowerManager, 1);
    OSMetaClassDeclareReservedUnused(IOFireWirePowerManager, 2);
    OSMetaClassDeclareReservedUnused(IOFireWirePowerManager, 3);
    OSMetaClassDeclareReservedUnused(IOFireWirePowerManager, 4);
    OSMetaClassDeclareReservedUnused(IOFireWirePowerManager, 5);
    OSMetaClassDeclareReservedUnused(IOFireWirePowerManager, 6);
    OSMetaClassDeclareReservedUnused(IOFireWirePowerManager, 7);
    OSMetaClassDeclareReservedUnused(IOFireWirePowerManager, 8);
    OSMetaClassDeclareReservedUnused(IOFireWirePowerManager, 9);
};

#endif                                                                                                                                                                                                                                                                                                                                                                                 IOFireWireUnit.h                                                                                    0100644 0001750 0001750 00000011150 12567451747 036624  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *
 *	IOFireWireUnit.h
 *
 *
 */
#ifndef _IOKIT_IOFIREWIREUNIT_H
#define _IOKIT_IOFIREWIREUNIT_H

// public
#include <IOKit/firewire/IOFireWireNub.h>

class IOFireWireDevice;
class IOFireWireUnit;

#pragma mark -

/*! 
	@class IOFireWireUnitAux
*/

class IOFireWireUnitAux : public IOFireWireNubAux
{
    OSDeclareDefaultStructors(IOFireWireUnitAux)

	friend class IOFireWireUnit;
	
protected:
	
	/*! 
		@struct ExpansionData
		@discussion This structure will be used to expand the capablilties of the class in the future.
    */  
	  
    struct ExpansionData { };

	/*! 
		@var reserved
		Reserved for future use.  (Internal use only)  
	*/
    
	ExpansionData * reserved;

    virtual bool init( IOFireWireUnit * primary );
	virtual	void free();

	virtual bool isPhysicalAccessEnabled( void );

	virtual IOFWSimpleContiguousPhysicalAddressSpace * createSimpleContiguousPhysicalAddressSpace( vm_size_t size, IODirection direction );
		
    virtual IOFWSimplePhysicalAddressSpace * createSimplePhysicalAddressSpace( vm_size_t size, IODirection direction );
	
private:
    OSMetaClassDeclareReservedUnused(IOFireWireUnitAux, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireUnitAux, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireUnitAux, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireUnitAux, 3);
	
};

#pragma mark -

/*! @class IOFireWireUnit
*/
class IOFireWireUnit : public IOFireWireNub
{
    OSDeclareDefaultStructors(IOFireWireUnit)

	friend class IOFireWireUnitAux;
	friend class IOFireWireDevice;

protected:
    IOFireWireDevice *fDevice;	// The device unit is part of

/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

/*------------------Methods provided to FireWire device clients-----------------------*/
public:

    virtual bool init(OSDictionary *propTable, IOConfigDirectory *directory);
    
    /*
     * Standard nub initialization
     */
    virtual bool attach(IOService * provider );
	virtual void free();

    /*
     * Matching language support
     * Match on the following properties of the unit:
     * Vendor_ID
     * GUID
     * Unit_Spec_ID
     * Unit_SW_Version
     */
    virtual bool matchPropertyTable(OSDictionary * table);


    virtual IOReturn message( UInt32 type, IOService * provider, void * argument );

    // Override handleOpen() and handleClose() to pass on to device
    virtual bool handleOpen( 	IOService *	  forClient,
                                IOOptionBits	  options,
                                void *		  arg );

    virtual void handleClose(   IOService *	  forClient,
                                IOOptionBits	  options );
    
    virtual void setNodeFlags( UInt32 flags );
	virtual void clearNodeFlags( UInt32 flags );
    virtual UInt32 getNodeFlags( void );

	virtual IOReturn setConfigDirectory( IOConfigDirectory *directory );

    /*
     * Create local FireWire address spaces for the device to access
     */
    virtual IOFWPhysicalAddressSpace *createPhysicalAddressSpace(IOMemoryDescriptor *mem);
    virtual IOFWPseudoAddressSpace *createPseudoAddressSpace(FWAddress *addr, UInt32 len,
                    FWReadCallback reader, FWWriteCallback writer, void *refcon);

protected:
	
	virtual IOFireWireNubAux * createAuxiliary( void );

public:
	void setMaxSpeed( IOFWSpeed speed );

protected:
	void terminateUnit( void );
	static void terminateUnitThreadFunc( void * refcon );
	    
private:
    OSMetaClassDeclareReservedUnused(IOFireWireUnit, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireUnit, 1);

};

#endif /* ! _IOKIT_IOFIREWIREDEVICE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                        IOLocalConfigDirectory.h                                                                            0100644 0001750 0001750 00000007062 12567451747 040324  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
* Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
*
* @APPLE_LICENSE_HEADER_START@
*
* The contents of this file constitute Original Code as defined in and
* are subject to the Apple Public Source License Version 1.1 (the
* "License").  You may not use this file except in compliance with the
* License.  Please obtain a copy of the License at
* http://www.apple.com/publicsource and read it before using this file.
*
* This Original Code and all software distributed under the License are
* distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
* EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
* INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
* License for the specific language governing rights and limitations
* under the License.
*
* @APPLE_LICENSE_HEADER_END@
*/

#ifndef __IOLOCALCONFIGDIRECTORY_H__
#define __IOLOCALCONFIGDIRECTORY_H__

#include <libkern/c++/OSObject.h>
#include <IOKit/IOReturn.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h>
#include <IOKit/firewire/IOConfigDirectory.h>

class OSArray;
class OSData;
class IOFireWireController;
class IOFWUserObjectExporter ;

/*! @class IOLocalConfigDirectory
*/
class IOLocalConfigDirectory : public IOConfigDirectory
{
	friend class IOFireWireController;
	friend class IOFireWireUserClient ;

	OSDeclareDefaultStructors(IOLocalConfigDirectory);

protected:
	OSArray *fEntries;	// Entries for this directory.
	OSData *fROM;	// Local ROM, if compiled.
	UInt32 fHeader;	// Num entries and CRC.
	
/*! @struct ExpansionData
	@discussion This structure will be used to expand the capablilties of the class in the future.
	*/    
	struct ExpansionData { };

/*! @var reserved
	Reserved for future use.  (Internal use only)  */
	ExpansionData *reserved;

	virtual bool init();
	virtual void free();

	virtual const UInt32 *getBase();
	virtual IOConfigDirectory *getSubDir(int start, int type);

public:
	static IOLocalConfigDirectory *create();

	/*!
		@function update
		makes sure that the ROM has at least the specified capacity,
		and that the ROM is uptodate from its start to at least the
		specified quadlet offset.
		@result kIOReturnSuccess if the specified offset is now
		accessable at romBase[offset].
	*/
	virtual IOReturn update(UInt32 offset, const UInt32 *&romBase);

	virtual IOReturn compile(OSData *rom);
	
	// All flavours of addEntry eat a retain of the desc string
	virtual IOReturn addEntry(int key, UInt32 value, OSString *desc = NULL);
	virtual IOReturn addEntry(int key, IOLocalConfigDirectory *value,
							OSString *desc = NULL);
	virtual IOReturn addEntry(int key, OSData *value, OSString *desc = NULL);
	virtual IOReturn addEntry(int key, FWAddress value, OSString *desc = NULL);
	virtual IOReturn removeSubDir(IOLocalConfigDirectory *value);
	const OSArray *getEntries() const;

	virtual IOReturn getIndexValue(int index, IOConfigDirectory *&value);

protected:

	virtual const UInt32 * lockData( void );
	virtual void unlockData( void );
	virtual IOReturn updateROMCache( UInt32 offset, UInt32 length );
	virtual IOReturn checkROMState( void );

	// call eats a retain count
	virtual IOReturn addEntry(OSString *desc);

	IOReturn	incrementGeneration( void );
	static void	exporterCleanup( const OSObject * self, IOFWUserObjectExporter * exporter ) ;
		
private:
	OSMetaClassDeclareReservedUsed(IOLocalConfigDirectory, 0);
	OSMetaClassDeclareReservedUnused(IOLocalConfigDirectory, 1);
	OSMetaClassDeclareReservedUnused(IOLocalConfigDirectory, 2);
};

#endif /* __IOLOCALCONFIGDIRECTORY_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              IORemoteConfigDirectory.h                                                                           0100644 0001750 0001750 00000005651 12567451747 040527  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/firewire                                                       /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __IOREMOTECONFIGDIRECTORY_H__
#define __IOREMOTECONFIGDIRECTORY_H__

#include <libkern/c++/OSObject.h>
#include <IOKit/IOReturn.h>

#include <IOKit/firewire/IOFireWireFamilyCommon.h>
#include <IOKit/firewire/IOConfigDirectory.h>

#include "IOFireWireROMCache.h"

class OSString;
class OSIterator;
class IOFireWireDevice;

/*! @class IORemoteConfigDirectory
*/
class IORemoteConfigDirectory : public IOConfigDirectory
{
    OSDeclareDefaultStructors(IORemoteConfigDirectory);

protected:
    IOFireWireROMCache *fROM;				// Our cache of the ROM
    
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData *reserved;

    virtual bool initWithOwnerOffset(IOFireWireROMCache *rom,
                             int start, int type);
    virtual void free();

    virtual const UInt32 *getBase();
    virtual IOConfigDirectory *getSubDir(int start, int type);

public:
    static IOConfigDirectory *withOwnerOffset(IOFireWireROMCache *rom,
                                           int start, int type);


    /*!
        @function update
        makes sure that the ROM has at least the specified capacity,
        and that the ROM is uptodate from its start to at least the
        specified quadlet offset.
        @result kIOReturnSuccess if the specified offset is now
        accessable at romBase[offset].
    */
    virtual IOReturn update(UInt32 offset, const UInt32 *&romBase);

protected:
	
	virtual const UInt32 * lockData( void );
	virtual void unlockData( void );
	virtual IOReturn updateROMCache( UInt32 offset, UInt32 length );
	virtual IOReturn checkROMState( void );
	
private:
    OSMetaClassDeclareReservedUnused(IORemoteConfigDirectory, 0);
    OSMetaClassDeclareReservedUnused(IORemoteConfigDirectory, 1);
    OSMetaClassDeclareReservedUnused(IORemoteConfigDirectory, 2);
};


#endif /* __IOREMOTECONFIGDIRECTORY_H__ */
                                                                                       graphics/                                                                                           0040755 0001750 0001750 00000000000 12612224742 033620  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOAccelClientConnect.h                                                                              0100644 0001750 0001750 00000002477 12567452457 037727  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOACCEL_CLIENT_CONNECT_H
#define _IOACCEL_CLIENT_CONNECT_H


/*
** The IOAccelerator service name
*/
#define kIOAcceleratorClassName "IOAccelerator"


/*
** IOAccelerator public client types.  Private client types start with
** kIOAccelNumClientTypes.
*/
enum eIOAcceleratorClientTypes {
        kIOAccelSurfaceClientType,
        kIOAccelNumClientTypes
};


#endif /* _IOACCEL_CLIENT_CONNECT_H */

                                                                                                                                                                                                 IOAccelSurfaceConnect.h                                                                             0100644 0001750 0001750 00000013722 12567452457 040074  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOACCEL_SURFACE_CONNECT_H
#define _IOACCEL_SURFACE_CONNECT_H

#include <IOKit/graphics/IOAccelTypes.h>
#include <IOKit/graphics/IOAccelClientConnect.h>

/*
** Surface visible region in device coordinates.
**
** num_rects:   The number of rectangles in the rect array.  If num_rects
**              is zero the bounds rectangle is used for the visible rectangle.
**              If num_rects is zero the surface must be completely contained
**              by the device.
**
** bounds:      The unclipped surface rectangle in device coords.  Extends
**              beyond the device bounds if the surface is not totally on
**              the device.
**
** rect[]:      An array of visible rectangles in device coords.  If num_rects
**              is non-zero only the region described by these rectangles is
**              copied to the frame buffer during a flush operation.
*/
typedef struct
{
        UInt32        num_rects;
        IOAccelBounds bounds;
        IOAccelBounds rect[0];
} IOAccelDeviceRegion;


/*
** Determine the size of a region.
*/
#define IOACCEL_SIZEOF_DEVICE_REGION(_rgn_) (sizeof(IOAccelDeviceRegion) + (_rgn_)->num_rects * sizeof(IOAccelBounds))


/*
** Surface client public memory types.  Private memory types start with
** kIOAccelNumSurfaceMemoryTypes.
*/
enum eIOAccelSurfaceMemoryTypes {
        kIOAccelNumSurfaceMemoryTypes
};


/*
** Surface client public methods.  Private methods start with
** kIOAccelNumSurfaceMethods.
*/
enum eIOAccelSurfaceMethods {
        kIOAccelSurfaceReadLockOptions,
        kIOAccelSurfaceReadUnlockOptions,
        kIOAccelSurfaceGetState,
        kIOAccelSurfaceWriteLockOptions,
        kIOAccelSurfaceWriteUnlockOptions,
        kIOAccelSurfaceRead,
        kIOAccelSurfaceSetShapeBacking,

        kIOAccelSurfaceSetIDMode,
        kIOAccelSurfaceSetScale,

        kIOAccelSurfaceSetShape,
        kIOAccelSurfaceFlush,

        kIOAccelSurfaceQueryLock,

        kIOAccelSurfaceReadLock,
        kIOAccelSurfaceReadUnlock,
        kIOAccelSurfaceWriteLock,
        kIOAccelSurfaceWriteUnlock,

        kIOAccelSurfaceControl,
        kIOAccelSurfaceSetShapeBackingAndLength,

        kIOAccelNumSurfaceMethods
};


/*
** Option bits for IOAccelCreateSurface and the kIOAccelSurfaceSetIDMode method.
** The color depth field can take any value of the _CGSDepth enumeration.
*/
typedef enum {
        kIOAccelSurfaceModeColorDepth1555  = 0x00000003,  
        kIOAccelSurfaceModeColorDepth8888  = 0x00000004,  
//      kIOAccelSurfaceModeColorDepthRGB565 = 0x00000005,  
        kIOAccelSurfaceModeColorDepthYUV   = 0x00000006,
        kIOAccelSurfaceModeColorDepthYUV9  = 0x00000007,
        kIOAccelSurfaceModeColorDepthYUV12 = 0x00000008,
        kIOAccelSurfaceModeColorDepthYUV2  = 0x00000009,
        kIOAccelSurfaceModeColorDepthBGRA32 = 0x0000000A,

//      kIOAccelSurfaceModeColorDepthRGBA64       = 0x0000000B,
//      kIOAccelSurfaceModeColorDepthRGBAFloat64  = 0x0000000C,
//      kIOAccelSurfaceModeColorDepthRGBAFloat128 = 0x0000000D,
        
//      kIOAccelSurfaceModeColorDepthYUV420  = 0x0000000E,
        kIOAccelSurfaceModeColorDepth2101010 = 0x0000000F,
        
        kIOAccelSurfaceModeColorDepthBits  = 0x0000000F,

        kIOAccelSurfaceModeStereoBit       = 0x00000010,
        kIOAccelSurfaceModeWindowedBit     = 0x00000020,

        kIOAccelSurfaceModeBeamSync        = 0x00008000
} eIOAccelSurfaceModeBits;


/*
** Options bits for IOAccelSetSurfaceShape and the kIOAccelSurfaceSetShape method.
*/
typedef enum {
        kIOAccelSurfaceShapeNone             = 0x00000000,
        kIOAccelSurfaceShapeNonBlockingBit   = 0x00000001,
        kIOAccelSurfaceShapeNonSimpleBit     = 0x00000002,
        kIOAccelSurfaceShapeIdentityScaleBit = 0x00000004,
        kIOAccelSurfaceShapeFrameSyncBit     = 0x00000008,
        kIOAccelSurfaceShapeBeamSyncBit      = 0x00000010,
        kIOAccelSurfaceShapeStaleBackingBit  = 0x00000020,
        kIOAccelSurfaceShapeAssemblyBit      = 0x00000040,
        kIOAccelSurfaceShapeWaitEnabledBit   = 0x00000080,

        /* wrong name, use kIOAccelSurfaceShapeNonBlockingBit */
        kIOAccelSurfaceShapeBlockingBit      = kIOAccelSurfaceShapeNonBlockingBit
} eIOAccelSurfaceShapeBits;

/*
** Return bits for the kIOAccelSurfaceGetState method.
*/
typedef enum {
        kIOAccelSurfaceStateNone    = 0x00000000,
        kIOAccelSurfaceStateIdleBit = 0x00000001
} eIOAccelSurfaceStateBits;

/*
** Option bits for the kIOAccelSurfaceSetScale method.
*/
typedef enum {
        kIOAccelSurfaceBeamSyncSwaps = 0x00000001,
        kIOAccelSurfaceFixedSource   = 0x00000002,

        kIOAccelSurfaceFiltering     = 0x000000f0,
        kIOAccelSurfaceFilterDefault = 0x00000000,
        kIOAccelSurfaceFilterNone    = 0x00000010,
        kIOAccelSurfaceFilterLinear  = 0x00000020

} eIOAccelSurfaceScaleBits;

/*
** Option bits for the kIOAccelSurfaceLock methods.
*/
typedef enum {
    kIOAccelSurfaceLockInBacking  = 0,
    kIOAccelSurfaceLockInAccel    = 1,
    kIOAccelSurfaceLockInDontCare = 2,
    kIOAccelSurfaceLockInMask     = 0x00000003
} eIOAccelSurfaceLockBits;

#endif /* _IOACCEL_SURFACE_CONNECT_H */

                                              IOAccelTypes.h                                                                                      0100644 0001750 0001750 00000004717 12567452457 036302  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOACCEL_TYPES_H
#define _IOACCEL_TYPES_H

#include <IOKit/IOTypes.h>
#include <IOKit/IOKitKeys.h>

#define IOACCEL_TYPES_REV       12

#if !defined(OSTYPES_K64_REV) && !defined(MAC_OS_X_VERSION_10_6)
#define IOACCELTYPES_10_5       1
#endif

/* Integer rectangle in device coordinates */
typedef struct
{
    SInt16      x;
    SInt16      y;
    SInt16      w;
    SInt16      h;
} IOAccelBounds;

typedef struct
{
    SInt16      w;
    SInt16      h;
} IOAccelSize;

/* Surface information */

enum {
    kIOAccelVolatileSurface     = 0x00000001
};

typedef struct
{
#if IOACCELTYPES_10_5
    vm_address_t        address[4];
#else
    mach_vm_address_t   address[4];
#endif /* IOACCELTYPES_10_5 */
    UInt32              rowBytes;
    UInt32              width;
    UInt32              height;
    UInt32              pixelFormat;
    IOOptionBits        flags;
    IOFixed             colorTemperature[4];
    UInt32              typeDependent[4];
} IOAccelSurfaceInformation;

typedef struct
{
#if IOACCELTYPES_10_5
        long x, y, w, h;
        void *client_addr;
        unsigned long client_row_bytes;
#else
        SInt32                    x, y, w, h;
        mach_vm_address_t client_addr;
        UInt32            client_row_bytes;
#endif /* IOACCELTYPES_10_5 */
} IOAccelSurfaceReadData;

typedef struct {
        IOAccelBounds   buffer;
        IOAccelSize     source;
        UInt32          reserved[8];
} IOAccelSurfaceScaling;


typedef SInt32 IOAccelID;

enum {
    kIOAccelPrivateID           = 0x00000001
};


#endif /* _IOACCEL_TYPES_H */

                                                 IOAccelerator.h                                                                                     0100644 0001750 0001750 00000002635 12567452457 036467  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IO_ACCELERATOR_H
#define _IO_ACCELERATOR_H

#include <IOKit/IOService.h>
#include <IOKit/graphics/IOAccelTypes.h>

class IOAccelerator : public IOService
{
    OSDeclareDefaultStructors(IOAccelerator)

public:
    static IOReturn createAccelID(IOOptionBits options, IOAccelID * identifier);
    static IOReturn retainAccelID(IOOptionBits options, IOAccelID identifier);
    static IOReturn releaseAccelID(IOOptionBits options, IOAccelID identifier);

};


#endif /* _IO_ACCELERATOR_H */

                                                                                                   IODisplay.h                                                                                         0100644 0001750 0001750 00000025543 12567452457 035653  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IODISPLAY_H
#define _IOKIT_IODISPLAY_H

#include <IOKit/IOService.h>
#include <IOKit/graphics/IOFramebuffer.h>

extern const OSSymbol * gIODisplayParametersKey;
extern const OSSymbol * gIODisplayGUIDKey;

extern const OSSymbol * gIODisplayValueKey;
extern const OSSymbol * gIODisplayMinValueKey;
extern const OSSymbol * gIODisplayMaxValueKey;

extern const OSSymbol * gIODisplayContrastKey;
extern const OSSymbol * gIODisplayBrightnessKey;
extern const OSSymbol * gIODisplayLinearBrightnessKey;
extern const OSSymbol * gIODisplayUsableLinearBrightnessKey;
extern const OSSymbol * gIODisplayBrightnessFadeKey;
extern const OSSymbol * gIODisplayHorizontalPositionKey;
extern const OSSymbol * gIODisplayHorizontalSizeKey;
extern const OSSymbol * gIODisplayVerticalPositionKey;
extern const OSSymbol * gIODisplayVerticalSizeKey;
extern const OSSymbol * gIODisplayTrapezoidKey;
extern const OSSymbol * gIODisplayPincushionKey;
extern const OSSymbol * gIODisplayParallelogramKey;
extern const OSSymbol * gIODisplayRotationKey;
extern const OSSymbol * gIODisplayOverscanKey;
extern const OSSymbol * gIODisplayVideoBestKey;
extern const OSSymbol * gIODisplaySelectedColorModeKey;

extern const OSSymbol * gIODisplayRedGammaScaleKey;
extern const OSSymbol * gIODisplayGreenGammaScaleKey;
extern const OSSymbol * gIODisplayBlueGammaScaleKey;
extern const OSSymbol * gIODisplayGammaScaleKey;

extern const OSSymbol * gIODisplayParametersTheatreModeKey;
extern const OSSymbol * gIODisplayParametersTheatreModeWindowKey;

extern const OSSymbol * gIODisplayMCCSVersionKey;
extern const OSSymbol * gIODisplayTechnologyTypeKey;
extern const OSSymbol * gIODisplayUsageTimeKey;
extern const OSSymbol * gIODisplayFirmwareLevelKey;

extern const OSSymbol * gIODisplaySpeakerVolumeKey;
extern const OSSymbol * gIODisplaySpeakerSelectKey;
extern const OSSymbol * gIODisplayMicrophoneVolumeKey;
extern const OSSymbol * gIODisplayAmbientLightSensorKey;
extern const OSSymbol * gIODisplayAudioMuteAndScreenBlankKey;
extern const OSSymbol * gIODisplayAudioTrebleKey;
extern const OSSymbol * gIODisplayAudioBassKey;
extern const OSSymbol * gIODisplayAudioBalanceLRKey;
extern const OSSymbol * gIODisplayAudioProcessorModeKey;
extern const OSSymbol * gIODisplayPowerModeKey;
extern const OSSymbol * gIODisplayManufacturerSpecificKey;

extern const OSSymbol * gIODisplayPowerStateKey;
extern const OSSymbol * gIODisplayControllerIDKey;
extern const OSSymbol * gIODisplayCapabilityStringKey;

extern const OSSymbol * gIODisplayParametersCommitKey;
extern const OSSymbol * gIODisplayParametersDefaultKey;
extern const OSSymbol * gIODisplayParametersFlushKey;

extern const OSSymbol * gIODisplayFadeTime1Key;
extern const OSSymbol * gIODisplayFadeTime2Key;
extern const OSSymbol * gIODisplayFadeTime3Key;
extern const OSSymbol * gIODisplayFadeStyleKey;

extern UInt32 gIODisplayFadeTime1;
extern UInt32 gIODisplayFadeTime2;
extern UInt32 gIODisplayFadeTime3;
extern UInt32 gIODisplayFadeStyle;

enum {
    kIODisplayNumPowerStates = 4,
    kIODisplayMaxPowerState  = kIODisplayNumPowerStates - 1
};

class IODisplayConnect : public IOService
{
    OSDeclareDefaultStructors(IODisplayConnect)

private:
    IOIndex     connection;

protected:
/*  Reserved for future use.  (Internal use only)  */
    struct ExpansionData { };

/*  Reserved for future use.  (Internal use only)  */
    ExpansionData * reserved;

public:
    virtual bool initWithConnection( IOIndex connection );
    virtual IOFramebuffer * getFramebuffer( void );
    virtual IOIndex getConnection( void );
    virtual IOReturn getAttributeForConnection( IOSelect selector, uintptr_t * value );
    virtual IOReturn setAttributeForConnection( IOSelect selector, uintptr_t value );
    virtual void joinPMtree ( IOService * driver );
};

class IODisplay : public IOService
{
    OSDeclareAbstractStructors(IODisplay)

public:
    static void initialize( void );

protected:
    // used to query the framebuffer controller
    IODisplayConnect *                  fConnection;
    class IODisplayParameterHandler *   fParameterHandler;
    void *                      __resv;
    IONotifier *                        fNotifier;

    // pointer to protected instance variables for power management
    struct IODisplayPMVars *              fDisplayPMVars;

    // reserved for future expansion
    void *                              _IODisplay_reserved[32];

public:
    virtual IOService * probe(  IOService *     provider,
                                SInt32 *        score );

    virtual bool start( IOService * provider );
    virtual void stop( IOService * provider );
    virtual void free();

    virtual IODisplayConnect * getConnection( void );

    virtual IOReturn getConnectFlagsForDisplayMode(
                IODisplayModeID mode, UInt32 * flags );

    virtual IOReturn getGammaTableByIndex(
        UInt32 * channelCount, UInt32 * dataCount,
        UInt32 * dataWidth, void ** data );

    virtual IOReturn readFramebufferEDID( void );

    // 
    virtual IOReturn framebufferEvent( IOFramebuffer * framebuffer, 
                                        IOIndex event, void * info );

    // parameter setting
    virtual IOReturn setProperties( OSObject * properties );
    virtual bool setForKey( OSDictionary * params, const OSSymbol * key,
                            SInt32 value, SInt32 min, SInt32 max );

    static bool addParameter( OSDictionary * params, const OSSymbol * paramName, SInt32 min, SInt32 max );
    static bool setParameter( OSDictionary * params, const OSSymbol * paramName, SInt32 value );
    static OSDictionary * getIntegerRange( OSDictionary * params, const OSSymbol * sym,
                                      SInt32 * value, SInt32 * min, SInt32 * max );

    // low level set/get
    virtual bool doIntegerSet( OSDictionary * params,
                               const OSSymbol * paramName, UInt32 value );
    virtual bool doDataSet( const OSSymbol * paramName, OSData * value );
    virtual bool doUpdate( void );

    // power management methods
    virtual IOReturn setPowerState( unsigned long, IOService * );
    virtual unsigned long maxCapabilityForDomainState( IOPMPowerFlags );
    virtual unsigned long initialPowerStateForDomainState( IOPMPowerFlags );
    virtual unsigned long powerStateForDomainState( IOPMPowerFlags );

    // 
    virtual void initPowerManagement( IOService * provider);
    virtual void dropOneLevel( void );
    virtual void makeDisplayUsable( void );
    void setDisplayPowerState(unsigned long state);

private:
    OSMetaClassDeclareReservedUnused(IODisplay, 0);
    OSMetaClassDeclareReservedUnused(IODisplay, 1);
    OSMetaClassDeclareReservedUnused(IODisplay, 2);
    OSMetaClassDeclareReservedUnused(IODisplay, 3);
    OSMetaClassDeclareReservedUnused(IODisplay, 4);
    OSMetaClassDeclareReservedUnused(IODisplay, 5);
    OSMetaClassDeclareReservedUnused(IODisplay, 6);
    OSMetaClassDeclareReservedUnused(IODisplay, 7);
    OSMetaClassDeclareReservedUnused(IODisplay, 8);
    OSMetaClassDeclareReservedUnused(IODisplay, 9);
    OSMetaClassDeclareReservedUnused(IODisplay, 10);
    OSMetaClassDeclareReservedUnused(IODisplay, 11);
    OSMetaClassDeclareReservedUnused(IODisplay, 12);
    OSMetaClassDeclareReservedUnused(IODisplay, 13);
    OSMetaClassDeclareReservedUnused(IODisplay, 14);
    OSMetaClassDeclareReservedUnused(IODisplay, 15);
    OSMetaClassDeclareReservedUnused(IODisplay, 16);
    OSMetaClassDeclareReservedUnused(IODisplay, 17);
    OSMetaClassDeclareReservedUnused(IODisplay, 18);
    OSMetaClassDeclareReservedUnused(IODisplay, 19);

private:
    static IOReturn _framebufferEvent( OSObject * self, void * ref,
                    IOFramebuffer *framebuffer, IOIndex event, void * info );

	void searchParameterHandlers(IORegistryEntry * entry);
    bool addParameterHandler( IODisplayParameterHandler * parameterHandler );
    bool removeParameterHandler( IODisplayParameterHandler * parameterHandler );
    static bool updateNumber( OSDictionary * params, const OSSymbol * key, SInt32 value );
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

class IOBacklightDisplay : public IODisplay
{
    OSDeclareDefaultStructors(IOBacklightDisplay)

    OSMetaClassDeclareReservedUnused(IOBacklightDisplay, 0);
    OSMetaClassDeclareReservedUnused(IOBacklightDisplay, 1);
    OSMetaClassDeclareReservedUnused(IOBacklightDisplay, 2);
    OSMetaClassDeclareReservedUnused(IOBacklightDisplay, 3);
    OSMetaClassDeclareReservedUnused(IOBacklightDisplay, 4);
    OSMetaClassDeclareReservedUnused(IOBacklightDisplay, 5);
    OSMetaClassDeclareReservedUnused(IOBacklightDisplay, 6);
    OSMetaClassDeclareReservedUnused(IOBacklightDisplay, 7);
    OSMetaClassDeclareReservedUnused(IOBacklightDisplay, 8);
    OSMetaClassDeclareReservedUnused(IOBacklightDisplay, 9);
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

class IODisplayParameterHandler : public IOService
{
    OSDeclareDefaultStructors(IODisplayParameterHandler)

public:
    virtual bool setDisplay( IODisplay * display ) = 0;
    virtual bool doIntegerSet( OSDictionary * params,
                               const OSSymbol * paramName, UInt32 value ) = 0;
    virtual bool doDataSet( const OSSymbol * paramName, OSData * value ) = 0;
    virtual bool doUpdate( void ) = 0;

private:
    OSMetaClassDeclareReservedUnused(IODisplayParameterHandler, 0);
    OSMetaClassDeclareReservedUnused(IODisplayParameterHandler, 1);
    OSMetaClassDeclareReservedUnused(IODisplayParameterHandler, 2);
    OSMetaClassDeclareReservedUnused(IODisplayParameterHandler, 3);
    OSMetaClassDeclareReservedUnused(IODisplayParameterHandler, 4);
    OSMetaClassDeclareReservedUnused(IODisplayParameterHandler, 5);
    OSMetaClassDeclareReservedUnused(IODisplayParameterHandler, 6);
    OSMetaClassDeclareReservedUnused(IODisplayParameterHandler, 7);
    OSMetaClassDeclareReservedUnused(IODisplayParameterHandler, 8);
    OSMetaClassDeclareReservedUnused(IODisplayParameterHandler, 9);
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#endif /* ! _IOKIT_IODISPLAY_H */

                                                                                                                                                             IOFramebuffer.h                                                                                     0100644 0001750 0001750 00000133312 12567452457 036464  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFRAMEBUFFER_H
#define _IOKIT_IOFRAMEBUFFER_H

#include <IOKit/IOService.h>
#include <IOKit/IOInterruptEventSource.h>
#include <IOKit/graphics/IOGraphicsDevice.h>
#include <IOKit/graphics/IOFramebufferShared.h>
#include <IOKit/IOLib.h>

class IOFramebuffer;
class IOBufferMemoryDescriptor;

typedef void (*CursorBlitProc)(
                    IOFramebuffer * inst,
                    void * shmem,
                    volatile unsigned char *vramPtr,
                    unsigned int cursStart,
                    unsigned int vramRow,
                    unsigned int cursRow,
                    int width,
                    int height );

typedef void (*CursorRemoveProc)(
                    IOFramebuffer * inst,
                    void * shmem,
                    volatile unsigned char *vramPtr,
                    unsigned int vramRow,
                    int width,
                    int height );


typedef void * IOFBCursorRef;

struct IOFBCursorControlCallouts {
    IOReturn    (*setCursorImage) (void * self, void * ref,
                                    IOHardwareCursorDescriptor * description, IOFBCursorRef cursorImage);
    IOReturn    (*setCursorState) (void * self, void * ref,
                                    SInt32 x, SInt32 y, bool visible);
    UInt32      reserved[30];
};
typedef struct IOFBCursorControlCallouts IOFBCursorControlCallouts;

struct IOFBCursorControlAttribute {
    void *                              self;
    void *                              ref;
    const IOFBCursorControlCallouts *   callouts;
    UInt32                              reserved[29];
};
typedef struct IOFBCursorControlAttribute IOFBCursorControlAttribute;

// clock & data values
enum {
    kIODDCLow                           = 0,
    kIODDCHigh                          = 1,
    kIODDCTristate                      = 2
};
// ddcBlockType constants
enum {
    // EDID block type.
    kIODDCBlockTypeEDID                 = 0
};

// ddcFlags constants
enum {
    // Force a new read of the EDID.
    kIODDCForceRead                     = 0x00000001
};

enum {
    kDisabledInterruptState             = 0,
    kEnabledInterruptState              = 1
};

typedef void (*IOFBInterruptProc)( OSObject * target, void * ref );


typedef IOReturn (*IOFramebufferNotificationHandler)
        (OSObject * self, void * ref,
        IOFramebuffer * framebuffer, IOIndex event,
        void * info);

// IOFramebufferNotificationHandler events
enum {
    kIOFBNotifyDisplayModeWillChange    = 1,
    kIOFBNotifyDisplayModeDidChange     = 2,

    kIOFBNotifyWillSleep        = 3,
    kIOFBNotifyDidWake          = 4,

    kIOFBNotifyDidPowerOff      = 5,
    kIOFBNotifyWillPowerOn      = 6,

    kIOFBNotifyDidSleep         = kIOFBNotifyDidPowerOff,
    kIOFBNotifyWillWake         = kIOFBNotifyWillPowerOn,

    kIOFBNotifyWillPowerOff     = 7,
    kIOFBNotifyDidPowerOn       = 8,

    kIOFBNotifyWillChangeSpeed  = 9,
    kIOFBNotifyDidChangeSpeed   = 10,

    kIOFBNotifyClamshellChange  = 20,

    kIOFBNotifyCaptureChange    = 30,

    kIOFBNotifyOnlineChange     = 40,

    kIOFBNotifyDisplayDimsChange = 50,

    kIOFBNotifyProbed           = 60,

    kIOFBNotifyVRAMReady        = 70,

    kIOFBNotifyWillNotify       = 80,
    kIOFBNotifyDidNotify        = 81,
};

struct IOFramebufferNotificationNotify
{
	IOIndex event;
	void *  info;
};

enum {
    kFBDisplayUsablePowerState          = 0x80000000,
    kFBDisplayPowerStateMask            = 0x0000ffff
};

#define kIOFBDependentIDKey     "IOFBDependentID"
#define kIOFBDependentIndexKey  "IOFBDependentIndex"

struct StdFBShmem_t;
class IOFramebufferUserClient;
class IODisplay;

/*! @class IOFramebuffer : public IOGraphicsDevice
    @abstract The base class for graphics devices to be made available as part of the desktop.
    @discussion The IOFramebuffer base class defines APIs used to publish a linear framebuffer device. Device driver writers should subclass this class to provide a X native driver. Mac OS X will also utilize 'ndrv' drivers via a subclass of IOFramebuffer IONDRVFramebuffer that does not require device driver writers to provide a X native driver.
    
    There are no in kernel clients of IOFramebuffer aside from rudimentary console and panic UI supported by the IOFramebuffer class. The IOFramebuffer class provides the IOUserClient implementation to allow the CoreGraphics server to provide the user accessible interface to all displays on a Mac OS X system, and this is further layered underneath application frameworks. Device driver writers should not need any knowledge of this part of the interfaces. Similarly the instance variables of IOFramebuffer are mostly used for cursor rendering which is handled by the IOFramebuffer class, and should be avoided by subclass implementors. Only IOFramebuffer methods with header documentation in this header are designed for subclasses to implement.

    IOFramebuffer provides simple dumb framebuffer operation - accceleration for 2D, 3D and video may be provided by a separate implementation of the IOAccelerator class.
*/

class IOFramebuffer : public IOGraphicsDevice
{
    friend class IOFramebufferUserClient;
    friend class IOFramebufferSharedUserClient;
    friend class IOFramebufferParameterHandler;
    friend class IODisplay;

    OSDeclareDefaultStructors(IOFramebuffer)

protected:
/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of this class in the future.
    */    
    struct ExpansionData { };

/*! @var reserved
    Reserved for future use.  (Internal use only)  */
    ExpansionData * reserved;

private:

protected:
    StdFBShmem_t *                      priv;
    int                                 shmemClientVersion;
    IOBufferMemoryDescriptor *          sharedCursor;

    union {
        struct {
            /* Mapping tables used in cursor drawing to 5-5-5 displays. */
            unsigned char *     _bm34To35SampleTable;
            unsigned char *     _bm35To34SampleTable;
            /* Mapping tables used in cursor drawing to 8-bit RGB displays. */
            unsigned int *      _bm256To38SampleTable;
            unsigned char *     _bm38To256SampleTable;
        }                               t;
        UInt8 *                         tables[ 4 ];
    }                                   colorConvert;
    
    /* cursor blitting vars */
    CursorBlitProc                      cursorBlitProc;
    CursorRemoveProc                    cursorRemoveProc;

    IOGSize                             maxCursorSize;
    void *                              _IOFramebuffer_reservedE[7];
    const char *                        thisName;
    volatile unsigned char *            cursorSave;
    unsigned int                        white;

    IOGPoint                            nextCursorLoc;
    int                                 nextCursorFrame;
    SInt32                              connectChange;
    semaphore_t                         vblSemaphore;

    /* memory ranges */
    volatile unsigned char *            frameBuffer;
    unsigned int                        totalWidth;
    unsigned int                        rowBytes;
    unsigned int                        bytesPerPixel;

    IOMemoryMap *                       vramMap;
    IOByteCount                         vramMapOffset;
    OSArray *                           userAccessRanges;
    unsigned int                        suspended:1;
    unsigned int                        captured:1;
    unsigned int                        sleepConnectCheck:1;
    unsigned int                        messaged:1;
    unsigned int                        cursorEnable:1;
    unsigned int                        _IOFramebuffer_reservedC:27;
    IOFramebuffer *                     nextDependent;
    OSSet *                             fbNotifications;

    class IOFramebufferUserClient *       serverConnect;
    class IOFramebufferSharedUserClient * sharedConnect;

    unsigned int                        opened:1;
    unsigned int                        dead:1;
    unsigned int                        configPending:1;
    unsigned int                        serverNotified:1;
    unsigned int                        serverState:1;
    unsigned int                        serverPendingAck:1;
    unsigned int                        isUsable:1;
    unsigned int                        mirrored:1;
    unsigned int                        pendingPowerState:4;
    unsigned int                        pendingPowerChange:1;
    unsigned int                        pagingState:1;
    unsigned int                        mirrorPrimary:1;
    unsigned int                        mirrorSWCursor:1;

    bool                                clutValid;
    bool                                currentMono;
    bool                                needCursorService;
    bool                                haveVBLService;
    bool                                haveHWCursor;
    bool                                hwCursorLoaded;

    void *                              serverMsg;
    IOInterruptEventSource *            deferredEvents;

    /* Reserved for future expansion. */
    int                                 _IOFramebuffer_reserved[5];

private:
    struct IOFramebufferPrivate *       __private;

public:
/*! @function doI2CRequest
    @abstract Carry out an I2C request.
    @discussion IOFramebuffer subclasses may optionally implement this method to perform I2C bus requests on one of the buses they support. Alternatively they may implement the setDDCClock(), setDDCData(), readDDCClock(), readDDCData() methods and respond from getAttributeForConnection() to the kConnectionSupportsLLDDCSense attribute with success, in which case IOFramebuffer::doI2CRequest() will carry out a software implementation of I2C using the low level routines and conforming to the timing constraints passed in the timing parameter. Subclasses may pass timing parameters tuned for the specific bus, otherwise VESA DDC defaults will apply.
    @timing event Subclasses may pass timing parameters tuned for the specific bus, otherwise if NULL, VESA DDC defaults will apply.
    @param request An IOI2CRequest structure. The request should be carried out synchronously if the completion routine is NULL, otherwise it may optionally be carried out asynchronously. The completion routine should be called if supplied.
    @result an IOReturn code. If kIOReturnSuccces, the result of the transaction is returned in the requests result field.
*/
    virtual IOReturn doI2CRequest( UInt32 bus, struct IOI2CBusTiming * timing, struct IOI2CRequest * request );

private:
    OSMetaClassDeclareReservedUsed(IOFramebuffer, 0);

    OSMetaClassDeclareReservedUnused(IOFramebuffer, 1);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 2);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 3);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 4);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 5);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 6);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 7);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 8);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 9);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 10);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 11);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 12);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 13);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 14);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 15);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 16);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 17);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 18);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 19);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 20);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 21);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 22);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 23);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 24);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 25);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 26);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 27);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 28);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 29);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 30);
    OSMetaClassDeclareReservedUnused(IOFramebuffer, 31);


public:
    static void initialize();

    virtual bool requestTerminate( IOService * provider, IOOptionBits options );
    virtual IOService * probe( IOService * provider, SInt32 * score );
    virtual bool start( IOService * provider );
    virtual void stop( IOService * provider );
    virtual void free();
    virtual IOWorkLoop * getWorkLoop() const;

    IOWorkLoop * getGraphicsSystemWorkLoop() const;
    IOWorkLoop * getControllerWorkLoop() const;

    virtual IOReturn requestProbe( IOOptionBits options );

    virtual IOReturn powerStateWillChangeTo ( IOPMPowerFlags, unsigned long, IOService* );
    virtual IOReturn powerStateDidChangeTo ( IOPMPowerFlags, unsigned long, IOService* );
    virtual IOReturn setPowerState( unsigned long powerStateOrdinal, IOService * device);
    virtual IOReturn setAggressiveness( unsigned long type, unsigned long newLevel );
    virtual IOReturn getAggressiveness( unsigned long type, unsigned long * currentLevel );
    virtual IOReturn newUserClient( task_t              owningTask,
                                    void *              security_id,
                                    UInt32              type,
                                    IOUserClient **     handler );
    virtual IOReturn callPlatformFunction( const OSSymbol * functionName,
                                    bool waitForFunction,
                                    void *p1, void *p2,
                                    void *p3, void *p4 );

    virtual void hideCursor( void );
    virtual void showCursor( IOGPoint * cursorLoc, int frame );
    virtual void moveCursor( IOGPoint * cursorLoc, int frame );
    // virtual
    void resetCursor( void );

    virtual void getVBLTime( AbsoluteTime * time, AbsoluteTime * delta );

    virtual void getBoundingRect ( IOGBounds ** bounds );

    virtual IOReturn open( void );
    
    virtual void close( void );

    virtual bool isConsoleDevice( void );

    virtual IOReturn setupForCurrentConfig( void );

    virtual bool serializeInfo( OSSerialize * s );
    virtual bool setNumber( OSDictionary * dict, const char * key,
                                UInt32 number );

    IONotifier * addFramebufferNotification(
            IOFramebufferNotificationHandler handler,
            OSObject * self, void * ref);

/*! @function getApertureRange
    @abstract Return reference to IODeviceMemory object representing memory range of framebuffer.
    @discussion IOFramebuffer subclasses must implement this method to describe the memory used by the framebuffer in the current mode. The OS will map this memory range into user space for client access - the range should only include vram memory not hardware registers.
    @param aperture The system will only access the aperture kIOFBSystemAperture.
    @result an IODeviceMemory instance. A reference will be consumed by the caller for each call of this method - the implementatation should create a new instance of IODeviceMemory for each call, or return one instance with a retain for each call.
*/

    virtual IODeviceMemory * getApertureRange( IOPixelAperture aperture ) = 0;

/*! @function getVRAMRange
    @abstract Return reference to IODeviceMemory object representing memory range of all the cards vram.
    @discussion IOFramebuffer subclasses should implement this method to describe all the vram memory available on the card. The OS will map this memory range into user space for client access - the range should only include vram memory not hardware registers.
    @result an IODeviceMemory instance. A reference will be consumed by the caller for each call of this method - the implementatation should create a new instance of IODeviceMemory for each call, or return one instance with a retain for each call.
*/

    virtual IODeviceMemory * getVRAMRange( void );

protected:

/*! @function handleEvent
    @abstract Notify IOFramebuffer superclass code of events.
    @discussion IOFramebuffer subclasses should call this IOFramebuffer method on certain power state changes.
    @param event The event that has occurred:<br>
    kIOFBNotifyWillPowerOff call before entering a state other than the maximum.<br>
    kIOFBNotifyDidPowerOn call after entering the maximum power state.<br>
    kIOFBNotifyWillPowerOff call before entering a state other than the maximum.<br>
    kIOFBNotifyDidPowerOn call after entering a state other than the maximum.<br>
    @param info None of the above events require additional info, pass zero.
    @result an IOReturn code, safely ignored.
*/

    IOReturn handleEvent( IOIndex event, void * info = 0 );


    IOReturn deliverFramebufferNotification(
                    IOIndex event, void * info = 0 );

#ifdef IOFRAMEBUFFER_PRIVATE
#include <IOKit/graphics/IOFramebufferPrivate.h>
#endif

public:
/*! @function enableController
    @abstract Perform first time setup of the framebuffer.
    @discussion IOFramebuffer subclasses should perform their initialization of the hardware here. The IOService start() method is not called at a time appropriate for this initialization.
    @result an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.
*/

    virtual IOReturn enableController( void );

/*! @function getPixelFormats
    @abstract List the pixel formats the framebuffer supports.
    @discussion IOFramebuffer subclasses must implement this method to return an array of strings representing the possible pixel formats available in the framebuffer.
    @result A const char * pointer. The string consists of a concatenation of each pixel format string separated by the NULL character. The commonly supported pixel formats for Mac OS X are defined as IO8BitIndexedPixels, IO16BitDirectPixels, IO32BitDirectPixels.
*/

    virtual const char * getPixelFormats( void ) = 0;

/*! @function getDisplayModeCount
    @abstract Return the number of display modes the framebuffer supports.
    @discussion IOFramebuffer subclasses must implement this method to return a count of the display modes available. This count should change unless a connection change is posted for the device indicated the framebuffer and/or display configuration has changed.
    @result A count of the display modes available.
*/

    virtual IOItemCount getDisplayModeCount( void ) = 0;

/*! @function getDisplayModes
    @abstract Return the number of display modes the framebuffer supports.
    @discussion IOFramebuffer subclasses must implement this method to return an array of display mode IDs available for the framebuffer. The IDs are defined by the driver in the range 0x00000001 - 0x7fffffff, and should be constant for a given display mode. 
    @param allDisplayModes A caller allocated buffer with the size given by the result of getDisplayModeCount().
    @result an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.
*/
 
    virtual IOReturn getDisplayModes( IODisplayModeID * allDisplayModes ) = 0;

/*! @function getInformationForDisplayMode
    @abstract Return information about a given display mode.
    @discussion IOFramebuffer subclasses must implement this method to return information in the IODisplayModeInformation structure for the display mode with the passed ID. 
    @param displayMode A display mode ID previously returned by getDisplayModes().
    @param info Pointer to a structure of type IODisplayModeInformation to be filled out by the driver. IODisplayModeInformation is documented in IOGraphicsTypes.h.
    @result an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.
*/

    virtual IOReturn getInformationForDisplayMode( IODisplayModeID displayMode,
                    IODisplayModeInformation * info ) = 0;

/*! @function getPixelFormatsForDisplayMode
    @abstract Obsolete.
    @discussion IOFramebuffer subclasses must implement this method to return zero. 
    @param displayMode Ignored.
    @param depth Ignored.
    @result Return zero.
*/

    virtual UInt64  getPixelFormatsForDisplayMode( IODisplayModeID displayMode,
                    IOIndex depth ) = 0;

/*! @function getPixelInformation
    @abstract Return information about the framebuffer format for a given display mode and depth.
    @discussion IOFramebuffer subclasses must implement this method to return information in the IOPixelInformation structure for the display mode with the passed ID, depth index and aperture. The aperture utilized by the system is always kIOFBSystemAperture. Drivers may define alternative apertures, being a view of the framebuffer in a different pixel format from the default.
    @param displayMode A display mode ID previously returned by getDisplayModes().
    @param depth An index from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure (inclusive).
    @param info Pointer to a structure of type IOPixelInformation to be filled out by the driver. IOPixelInformation is documented in IOGraphicsTypes.h.
    @result an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.
*/

    virtual IOReturn getPixelInformation(
        IODisplayModeID displayMode, IOIndex depth,
        IOPixelAperture aperture, IOPixelInformation * pixelInfo ) = 0;

/*! @function getCurrentDisplayMode
    @abstract Return the framebuffers current display mode and depth.
    @discussion IOFramebuffer subclasses must implement this method to return the current mode and depth.
    @param displayMode A display mode ID representing the current mode.
    @param depth An index indicating the depth configuration of the framebuffer. The index should range from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure for the display mode.
    @result an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.
*/

    virtual IOReturn getCurrentDisplayMode( IODisplayModeID * displayMode,
                            IOIndex * depth ) = 0;

/*! @function setCurrentDisplayMode
    @abstract Set the framebuffers current display mode and depth.
    @discussion IOFramebuffer subclasses should implement this method to set the current mode and depth. Other than at enableController() time, this is the only method that should change the framebuffer format and is synchronized with clients and attached accelerators to make sure access to the device is disallowed during the change.
    @param displayMode A display mode ID representing the new mode.
    @param depth An index indicating the new depth configuration of the framebuffer. The index should range from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure for the display mode.
    @result an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.
*/

    virtual IOReturn setDisplayMode( IODisplayModeID displayMode,
                            IOIndex depth );

/*! @function setApertureEnable
    @abstract Enable an aperture on the framebuffer (usually unimplemented, no OS usage).
    @discussion IOFramebuffer subclasses may implement this method to set enable a non standard aperture. The system does not call this method.
    @param aperture A device specific aperture index.
    @param enable Device specific mask of options.
    @result an IOReturn code.
*/

    virtual IOReturn setApertureEnable( IOPixelAperture aperture,
                    IOOptionBits enable );

/*! @function setStartupDisplayMode
    @abstract Set the framebuffers display mode and depth to be used during boot and at startup.
    @discussion IOFramebuffer subclasses should implement this method to set the mode and depth to be used during boot and at startup, to reduce needed mode changes during boot when the display connection type is the same. If possible this mode should also be used by the OpenFirmware driver for the card.
    @param displayMode A display mode ID representing the new startup mode.
    @param depth An index indicating the new startup depth configuration of the framebuffer. The index should range from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure for the display mode.
    @result an IOReturn code.
*/

    virtual IOReturn setStartupDisplayMode( IODisplayModeID displayMode,
                            IOIndex depth );

/*! @function getCurrentDisplayMode
    @abstract Return the framebuffers display mode and depth to be used during boot and at startup.
    @discussion IOFramebuffer subclasses should implement this method to return the current mode and depth.
    @param displayMode A display mode ID representing the mode used during startup.
    @param depth An index indicating the depth configuration of the framebuffer used during startup. The index should range from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure for the display mode.
    @result an IOReturn code.
*/

    virtual IOReturn getStartupDisplayMode( IODisplayModeID * displayMode,
                            IOIndex * depth );

/*! @function setCLUTWithEntries
    @abstract Set the color lookup table to be used by the framebuffer in indexed modes.
    @discussion IOFramebuffer subclasses may implement this method to allow a palette to be set for indexed display modes. It will not be called on framebuffers in direct display modes.
    @param colors A pointer to an array of numEntries RGB color entries.
    @param index The index of the first entry to set.
    @param numEntries The number of entries in the table.
    @param options Options controlling the operation. <br>
    kSetCLUTByValue is set if the index field of each entry should be used to set the table sparsely, otherwise consecutive entries from the index parameter should be set.<br>
    kSetCLUTImmediately is set if the CLUT set should not be synchronized with the vertical blank, otherwise it should.<br>
    kSetCLUTWithLuminance is set if the CLUT should be set to a gray value equivalent in luminance to the passed color entry.<br>
    @result an IOReturn code.
*/

    virtual IOReturn setCLUTWithEntries( IOColorEntry * colors, UInt32 index,
                UInt32 numEntries, IOOptionBits options );

/*! @function setGammaTable
    @abstract Set the gamma table to be used by the framebuffer.
    @discussion IOFramebuffer subclasses should implement this method to allow a gamma table to be set. 
    @param channelCount Defines the number of channels in the supplied data. OS X will pass three for separate R, G, B data, or one if the same data should apply to all channels.
    @param dataCount The number of data entries per channel.
    @param dataWidth The number of bits in each entry. 8 for Mac OS X 10.1 and earlier, 16 for later releases.
    @param data The packed array of correction data. Data is passed for the R (or single) channel followed by the G & B channels. Each entry is one or two bytes (if dataWidth > 8).
    @result an IOReturn code.
*/

    virtual IOReturn setGammaTable( UInt32 channelCount, UInt32 dataCount,
                    UInt32 dataWidth, void * data );

/*! @function setAttribute
    @abstract Generic method to set some attribute of the framebuffer device.
    @discussion IOFramebuffer subclasses may implement this method to allow arbitrary attribute/value pairs to be set. 
    @param attribute Defines the attribute to be set. Some defined attributes are:<br> 
    kIOPowerAttribute The IOFramebuffer class implements most power management (IOService) methods. It calls the subclass to carry out the power management state change with this attribute. When carrying out power state changes, the subclass should call IOFramebuffer::handleEvent for certain changes - set that method for more information.
    @param value The new value for the attribute.
    @result an IOReturn code.
*/

    virtual IOReturn setAttribute( IOSelect attribute, uintptr_t value );

/*! @function getAttribute
    @abstract Generic method to retrieve some attribute of the framebuffer device.
    @discussion IOFramebuffer subclasses may implement this method to allow arbitrary attribute/value pairs to be returned. 
    @param attribute Defines the attribute to be set. Some defined attributes are:<br> 
    kIOHardwareCursorAttribute If the device supports a hardware cursor and implements the setCursorImage() and setCursorState() calls it should return true for this attribute.
    @param value Returns the value for the attribute.
    @result an IOReturn code.
*/

    virtual IOReturn getAttribute( IOSelect attribute, uintptr_t * value );

/*! @function getTimingInfoForDisplayMode
    @abstract Returns a timing description for a display mode.
    @discussion IOFramebuffer subclasses should implement this method to return timing information for a display mode. This allows the OS to enable display modes based on its knowledge of the connected display type. Two types of timing information are defined, by Apple defined constant, or by a detailed description of the timing parameters of the mode. 
    @param displayMode A display mode ID representing the mode to examine.
    @param info The driver returns the information for the display mode in this structure.<br>
    If the mode has an Apple defined constant, such as timingVESA_1024x768_75hz, it should be returned in the appleTimingID field. Otherwise the field should be set to timingInvalid.<br>
    If the driver is able to supply detailed timing information, it should return it in the detailedInfo.v2 field of the structure, otherwise the driver should clear the kIODetailedTimingValid flag from the flags field.<br>
    The IODetailedTimingInformationV2 structure is documented in IOGraphicsTypes.h
    @result an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.
*/

    virtual IOReturn getTimingInfoForDisplayMode(
                IODisplayModeID displayMode, IOTimingInformation * info );

/*! @function validateDetailedTiming
    @abstract Reports whether a detailed timing is able to be programmed with the device.
    @discussion IOFramebuffer subclasses may implement programmable mode functionality where the OS is able to install modes described by a detailed timing into the driver. 
    @param description A pointer to a IODetailedTimingInformationV2 structure. The driver should examine this description and change any fields that it cannot implement to reflect its closest possible implementation.
    @param descripSize sizeof(IODetailedTimingInformationV2)
    @result an IOReturn code. A return other than kIOReturnSuccess will prevent the system from installing the programmable mode.
*/

    virtual IOReturn validateDetailedTiming(
                    void * description, IOByteCount descripSize );

/*! @function setDetailedTimings
    @abstract Installs an array of OS programmed detailed timings to be made available by the driver.
    @discussion IOFramebuffer subclasses may implement programmable mode functionality where the OS is able to install modes described by a detailed timing into the driver. The driver needs to add these modes to its internal mode list if it provides this functionality.
    @param array An OSArray of OSData objects. Each OSData contains one IODetailedTimingInformationV2 structure. All the data described by the array should be copied or retained by this call until the next invocation of this method.
    @result an IOReturn code. A return other than kIOReturnSuccess will prevent the system from installing the programmable modes.
*/

    virtual IOReturn setDetailedTimings( OSArray * array );

/*! @function getConnectionCount
    @abstract Reports the number of display connections the device supports, driven from one framebuffer.
    @discussion IOFramebuffer subclasses may implement functionality where a single framebuffer drives multiple displays. This is not recommended or fully supported and instead multihead cards should implement multiple instances of IOFramebuffer objects to provide full functionality.
    @result A count of the number of display connections reported by the framebuffer. Current versions of OS X only support one connection completely.
*/

    virtual IOItemCount getConnectionCount( void );


/*! @function setAttributeForConnection
    @abstract Generic method to set some attribute of the framebuffer device, specific to one display connection.
    @discussion IOFramebuffer subclasses may implement this method to allow arbitrary attribute/value pairs to be set, specific to one display connection. 
    @param attribute Defines the attribute to be set. Some defined attributes are:<br> 
    kIOCapturedAttribute If the device supports hotplugging displays, it should disable the generation of hot plug interrupts when the attribute kIOCapturedAttribute is set to true.
    @param value The new value for the attribute.
    @result an IOReturn code.
*/

    virtual IOReturn setAttributeForConnection( IOIndex connectIndex,
                    IOSelect attribute, uintptr_t value );

/*! @function getAttributeForConnection
    @abstract Generic method to retrieve some attribute of the framebuffer device, specific to one display connection.
    @discussion IOFramebuffer subclasses may implement this method to allow arbitrary attribute/value pairs to be returned, specific to one display connection. 
    @param attribute Defines the attribute to be returned. Some defined attributes are:<br> 
    kConnectionSupportsHLDDCSense If the framebuffer supports the DDC methods hasDDCConnect() and getDDCBlock() it should return success (and no value) for this attribute.<br>
    kConnectionSupportsLLDDCSense If the framebuffer wishes to make use of IOFramebuffer::doI2CRequest software implementation of I2C it should implement the I2C methods setDDCClock(), setDDCData(), readDDCClock(), readDDCData(), and it should return success (and no value) for this attribute.<br>
    @param value Returns the value for the attribute.
    @result an IOReturn code.
*/

    virtual IOReturn getAttributeForConnection( IOIndex connectIndex,
                    IOSelect attribute, uintptr_t * value );

/*! @function convertCursorImage
    @abstract Utility method of IOFramebuffer to convert cursor image to a hardware cursor format.
    @discussion IOFramebuffer subclasses may implement hardware cursor functionality, if so they should pass the cursor image given by the  setCursorImage() method, with a description of their hardware cursor format, to this helper function to this routine to convert the image to one suitable for the hardware.
    @param cursorImage Opaque cursor parameter from the setCursorImage() call.
    @param description Describes the cursor format supported by the driver.
    @param cursor Structure describing the drivers allocated buffer to receive the converted image.
    @result a bool indicating the conversion was successful.
*/

    virtual bool convertCursorImage( void * cursorImage,
                IOHardwareCursorDescriptor * description,
                IOHardwareCursorInfo * cursor );

/*! @function setCursorImage
    @abstract Set a new image for the hardware cursor.
    @discussion IOFramebuffer subclasses may implement hardware cursor functionality, if so they should implement this method to change the hardware cursor image. The image should be passed to the convertCursorImage() method with each type of cursor format the hardware supports until success, if all fail the hardware cursor should be hidden and kIOReturnUnsupported returned.
    @param cursorImage Opaque cursor description. This should be passed to the convertCursorImage() method to convert to a format specific to the hardware.
    @result An IOReturn code.
*/

    virtual IOReturn setCursorImage( void * cursorImage );

/*! @function setCursorState
    @abstract Set a new position and visibility for the hardware cursor.
    @discussion IOFramebuffer subclasses may implement hardware cursor functionality, if so they should implement this method to change the position and visibility of the cursor.
    @param x Left coordinate of the cursor image. A signed value, will be negative if the cursor's hot spot and position place it partly offscreen.
    @param y Top coordinate of the cursor image. A signed value, will be negative if the cursor's hot spot and position place it partly offscreen.
    @param visible Visible state of the cursor.
    @result An IOReturn code.
*/

    virtual IOReturn setCursorState( SInt32 x, SInt32 y, bool visible );

/*! @function flushCursor
    @abstract Perform any needed cache flushing after software cursor rendering.
    @discussion IOFramebuffer implements software cursor functionality when a hardware cursor is unavailable. Some hardware may need to flush a cache after the processor has finished lifting and dropping the software cursor.
*/

    virtual void flushCursor( void );

/*! @function getAppleSense
    @abstract Return display sense information for legacy Apple sensing.
    @discussion Hardware that supports simple display sensing, or the classic 3 pin Apple sensing described in Designing Cards and Drivers, should implement this method to return sense information.
    @param connectIndex Index of the display connection, from zero to the value of getConnectionCount().
    @param senseType Return zero to indicate legacy Apple sensing.
    @param primary Return the value of the primary Apple sense code.
    @param extended Return the value of the secondary Apple sense code.
    @param displayType Return an Apple defined constant for the type of display sensed. For example, kVGAConnect, kNTSCConnect, kPALConnect etc.
    @result An IOReturn code.
*/

    virtual IOReturn getAppleSense( IOIndex connectIndex,
            UInt32 * senseType,
            UInt32 * primary,
            UInt32 * extended,
            UInt32 * displayType );

/*! @function connectFlags
    @abstract Return display sense information for legacy Apple sensing.
    @discussion Hardware that supports simple display sensing, or the classic 3 pin Apple sensing described in Designing Cards and Drivers, should implement this method to return mode flags relative to the sensed display. If this method is unimplemented, all modes have are given the flags kDisplayModeValidFlag | kDisplayModeSafeFlag.
    @param connectIndex Index of the display connection, from zero to the value of getConnectionCount().
    @param displayMode A display mode ID.
    @param flags Return the flags value for the given mode with the connected display. Flags are:<br>
    kDisplayModeValidFlag - mode is considered valid for the connected display by the driver.
    kDisplayModeSafeFlag - mode is considered safe (not requiring mode change confirmation) for the connected display by the driver.
    kDisplayModeDefaultFlag - mode is considered default for the connected display by the driver.
    @result An IOReturn code.
*/

    virtual IOReturn connectFlags( IOIndex connectIndex,
                    IODisplayModeID displayMode, IOOptionBits * flags );

    //// IOLowLevelDDCSense

/*! @function setDDCClock
    @abstract Sets the state of the I2C clock line on a bus.
    @discussion Framebuffers making use of the IOFramebuffer::doI2CRequest() software implementation of I2C should implement this method to set the state of the I2C clock line on the given bus. Otherwise may be unimplemented.
    @param bus Index of the bus.
    @param value One of kIODDCLow, kIODDCHigh, kIODDCTristate.
*/

    virtual void setDDCClock( IOIndex bus, UInt32 value );

/*! @function setDDCData
    @abstract Sets the state of the I2C data line on a bus.
    @discussion Framebuffers making use of the IOFramebuffer::doI2CRequest() software implementation of I2C should implement this method to set the state of the I2C data line on the given bus. Otherwise may be unimplemented.
    @param bus Index of the bus.
    @param value One of kIODDCLow, kIODDCHigh, kIODDCTristate.
*/
    virtual void setDDCData( IOIndex bus, UInt32 value );

/*! @function readDDCClock
    @abstract Reads the input state of the I2C clock line on a bus.
    @discussion Framebuffers making use of the IOFramebuffer::doI2CRequest() software implementation of I2C should implement this method to return the input state of the I2C clock line on the given bus. Otherwise may be unimplemented.
    @param bus Index of the bus.
    @result A boolean reflecting the current state of the clock line on the given bus.
*/
    virtual bool readDDCClock( IOIndex bus );

/*! @function readDDCData
    @abstract Reads the input state of the I2C data line on a bus.
    @discussion Framebuffers making use of the IOFramebuffer::doI2CRequest() software implementation of I2C should implement this method to return the input state of the I2C data line on the given bus. Otherwise may be unimplemented.
    @param bus Index of the bus.
    @result A boolean reflecting the current state of the data line on the given bus.
*/
    virtual bool readDDCData( IOIndex bus );

    virtual IOReturn enableDDCRaster( bool enable );

/*! @function hasDDCConnect
    @abstract Return display DDC connect state.
    @discussion Hardware that supports DDC/EDID display sensing should implement this method to return true if a DDC display is detected. They should also return success for the connection attribute kConnectionSupportsHLDDCSense (from getAttributeForConnection()).
    @param connectIndex Index of the display connection, from zero to the value of getConnectionCount().
    @result True if a DDC display is detected.
*/

    virtual bool hasDDCConnect( IOIndex connectIndex );

/*! @function getDDCBlock
    @abstract Return display EDID data.
    @discussion Hardware that supports DDC/EDID display sensing should implement this method to return EDID data in 128 byte blocks.
    @param connectIndex Index of the display connection, from zero to the value of getConnectionCount().
    @param blockNumber Block number, ranging from one to the number of blocks return by the display.
    @param blockType kIODDCBlockTypeEDID will be passed. 
    @param options No options are currently defined.
    @param data Caller allocated buffer to receive the blocks data.
    @param length In/out parameter - callers allocated buffer size, driver returns actual size.
    @result An IOReturn code.
*/

    virtual IOReturn getDDCBlock( IOIndex connectIndex, UInt32 blockNumber,
                    IOSelect blockType, IOOptionBits options,
                    UInt8 * data, IOByteCount * length );

/*! @function registerForInterruptType
    @abstract Set callbacks for driver to call on interrupt events.
    @discussion The IOFramebuffer class will call its subclasses to set callbacks to be called on interrupt events generated by hardware events. Only two are currently in use - vertical blank interrupts and connection changed interrupts.
    @param interruptType One of these constants:<br>
    kIOFBVBLInterruptType Specifying a vertical blanking interrupt.
    kIOFBConnectInterruptType Specify the display connection should be resensed.
    @param proc C callback to be called by the driver when the specified event occurs.
    @param target Target parameter for the callback proc.
    @param ref Ref parameter for the callback proc.
    @param interruptRef The subclass should return an opaque reference to the installed interrupt handler, for use with unregisterInterrupt() and setInterruptState().
    @result An IOReturn code.
*/

    virtual IOReturn registerForInterruptType( IOSelect interruptType,
                    IOFBInterruptProc proc, OSObject * target, void * ref,
                    void ** interruptRef );

/*! @function unregisterInterrupt
    @abstract Remove a callback previously installed by registerForInterruptType().
    @discussion Remove a callback previously installed by registerForInterruptType().
    @param interruptRef The interruptRef returned from the registerForInterruptType call that installed the interrupt.
    @result An IOReturn code.
*/

    virtual IOReturn unregisterInterrupt( void * interruptRef );

/*! @function unregisterInterrupt
    @abstract Enable or disable a callback previously installed by registerForInterruptType().
    @discussion Enable or disable a callback previously installed by registerForInterruptType().
    @param state True or false to enable the callback.
    @result An IOReturn code.
*/

    virtual IOReturn setInterruptState( void * interruptRef, UInt32 state );

    virtual IOReturn getNotificationSemaphore( IOSelect interruptType,
                                               semaphore_t * semaphore );

	IOReturn setBackingFramebuffer(const IOPixelInformation * info,
									uint32_t bufferCount,
									void * mappedAddress[]);
	IOReturn switchBackingFramebuffer(uint32_t bufferIndex);

/*  non WL clients apis
*/
    IOReturn setAttributeExt( IOSelect attribute, uintptr_t value );
    
    IOReturn getAttributeExt( IOSelect attribute, uintptr_t * value );
    
    IOReturn setAttributeForConnectionExt( IOIndex connectIndex,
               IOSelect attribute, uintptr_t value );
    
    IOReturn getAttributeForConnectionExt( IOIndex connectIndex,
            IOSelect attribute, uintptr_t * value );
};

#endif /* ! _IOKIT_IOFRAMEBUFFER_H */
                                                                                                                                                                                                                                                                                                                      IOFramebufferShared.h                                                                               0100644 0001750 0001750 00000031743 12567452457 037620  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFRAMEBUFFERSHARED_H
#define _IOKIT_IOFRAMEBUFFERSHARED_H

#include <IOKit/hidsystem/IOHIDTypes.h>
#include <IOKit/graphics/IOGraphicsTypes.h>
#include <libkern/OSAtomic.h>

#ifdef __cplusplus
extern "C" {
#endif

/*! @header IOFramebufferShared
The IOFramebufferShared.h header contains definitions of objects and types shared between a kernel level IOFrameBuffer service and a non-kernel window server. In Mac OS X this structure is used by the CoreGraphics server and IOGraphics Family, and is not available to other clients. IOFramebuffer subclasses and IOFramebuffer clients within the kernel should also not rely on this structure definition and constants. It is public only for use on Darwin based window servers. Cursor and window server state data is exchanged by kernel and non-kernel tasks through a slice of shared memory containing a StdFBShmem_t structure.<br>
For a non-kernel task to get access to this slice of shared memory, a connection to an IOFramebuffer service must be made. A connection is made with the IOServiceOpen() function described in IOKitLib.h. A connection type of kIOFBServerConnectType or kIOFBSharedConnectType (for read-only access) should be specified. An io_connect_t handle is returned by IOServiceOpen(). This handle must be passed to IOFBCreateSharedCursor() to create the slice of shared memory. Then IOConnectMapMemory() may be called with a memory type of kIOFBCursorMemory to map the shared memory into the non-kernel task.
*/

#ifdef KERNEL
// CGS use optional
/*! @defined IOFB_ARBITRARY_SIZE_CURSOR
    @discussion When IOFB_ARBITRARY_SIZE_CURSOR is not defined, the maximum cursor size is assumed to be CURSORWIDTH x CURSORHEIGHT and this header file will define a number of structures for storing cursor images accordingly. A non-kernel task may define IOFB_ARBITRARY_SIZE_CURSOR and use cursors up to the size specified when IOFBCreateSharedCursor() was called. In this case appropriate structures for storing cursor images must be defined elsewhere. In the kernel, IOFB_ARBITRARY_SIZE_CURSOR is always defined.
*/
#define IOFB_ARBITRARY_SIZE_CURSOR
#define IOFB_ARBITRARY_FRAMES_CURSOR    1
#endif

#define IOFB_SUPPORTS_XOR_CURSOR
#define IOFB_SUPPORTS_HW_SHIELD
#define IOFB_SUPPORTS_ARBITRARY_FRAMES_CURSOR

//
// Cursor and Window Server state data, occupying a slice of shared memory
// between the kernel and WindowServer.
//
/*! @enum CursorParameters
    @constant kIOFBNumCursorFrames The number of cursor images stored in the StdFBShmem_t structure.
    @constant kIOFBNumCursorFramesShift Used with waiting cursors.
    @constant kIOFBMaxCursorDepth The maximum cursor pixel depth.
*/
enum {
#if IOFB_ARBITRARY_FRAMES_CURSOR
    kIOFBMainCursorIndex        = 0,
    kIOFBWaitCursorIndex        = 1,
    kIOFBNumCursorIndex         = 4,
#else
    kIOFBNumCursorFrames        = 4,
    kIOFBNumCursorFramesShift   = 2,
#endif
    kIOFBMaxCursorDepth         = 32
};

#ifndef IOFB_ARBITRARY_SIZE_CURSOR

/*! @defined CURSORWIDTH
    @discussion The maximum width of the cursor image in pixels. This is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
*/
#define CURSORWIDTH  16         /* width in pixels */

/*! @defined CURSORHEIGHT
    @discussion The maximum height of the cursor image in pixels. This is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
*/
#define CURSORHEIGHT 16         /* height in pixels */

/*! @struct bm12Cursor
    @abstract Cursor image for 1-bit cursor.
    @discussion This structure stores 16 pixel x 16 pixel cursors to be used with 1-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
    @field image This array contains the cursor images.
    @field mask This array contains the cursor mask.
    @field save This array stores the pixel values of the region underneath the cursor in its last drawn position.
*/
struct bm12Cursor {
    unsigned int image[4][16];
    unsigned int mask[4][16];
    unsigned int save[16];
};

/*! @struct bm18Cursor
    @abstract Cursor image for 8-bit cursor.
    @discussion This structure stores 16 pixel x 16 pixel cursors to be used with 8-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
    @field image This array contains cursor color values, which are converted to displayed colors through the color table. The array is two dimensional and its first index is the cursor frame and the second index is the cursor pixel.
    @field mask This array contains the cursor alpha mask. The array is two dimensional with the same indexing as the image. If an alpha mask pixel is 0 and the corresponding image pixel is set to white for the display, then this cursor pixel will invert pixels on the display.
    @field save This array stores the color values of the region underneath the cursor in its last drawn position.
*/
struct bm18Cursor {
    unsigned char image[4][256];
    unsigned char mask[4][256];
    unsigned char save[256];
};

/*! @struct bm34Cursor
    @abstract Cursor image for 15-bit cursor.
    @discussion This structure stores 16 pixel x 16 pixel cursors to be used with 15-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
    @field image This array defines the cursor color values and transparency. The array is two dimensional and its first index is the cursor frame and the second index is the cursor pixel. A value of 0 means the pixel is transparent. Non-zero values are stored with the red, green, blue, and alpha values encoded with the following masks:<BR>
    red mask = 0xF000<br>
    blue mask 0x0F00<br>
    green mask 0x00F0<br>
    alpha mask = 0x000F<br>
Note, only 4 bits are allocated for each color component.
    @field save This array stores the color values of the region underneath the cursor in its last drawn position.
*/
struct bm34Cursor {
    unsigned short image[4][256];
    unsigned short save[256];
};

/*! @struct bm38Cursor
    @abstract Cursor image for 24-bit cursor.
    @discussion This structure stores 16 pixel x 16 pixel cursors to be used with 24-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
    @field image This array defines the cursor color values and transparency. The array is two dimensional and its first index is the cursor frame and the second index is the cursor pixel. The lower 24 bits of a pixel's value contain the RGB color, while the upper 8 bits contain the alpha value.
    @field save This array stores the color values of the region underneath the cursor in its last drawn position.
*/
struct bm38Cursor {
    unsigned int image[4][256];
    unsigned int save[256];
};

#endif /* IOFB_ARBITRARY_SIZE_CURSOR */

enum {
    kIOFBCursorImageNew         = 0x01,
    kIOFBCursorHWCapable        = 0x02
};
enum {
    kIOFBHardwareCursorActive   = 0x01,
    kIOFBHardwareCursorInVRAM   = 0x02
};

/*! @struct StdFBShmem_t
    @discussion This structure contains cursor and window server state data and occupies a slice of shared memory between the kernel and window server. Several elements of this structure are only used in software cursor mode. Unless otherwise indicated, the coordinates in this structure are given in display space. Display space is the coordinate space that encompasses all the screens. The positions of the screens within display space indicate their location relative to each other as the cursor moves between them. If there is only one screen, the screen coordinates and display space coordinates will be the same.
    @field cursorSema Semaphore lock for write access to the shared data in this structure.
    @field frame The current cursor frame index.
    @field cursorShow The cursor is displayed when cursorShow is 0.
    @field cursorObscured If this is true, the cursor has been obscured and cursorShow should not be 0. The cursor will be shown again the next time it is moved.
    @field shieldFlag When this is set to true the cursor will not be displayed in the region specified by shieldRect.
    @field shielded True if the cursor has been hidden because it entered the shielded region.
    @field saveRect The region that is saved underneath the cursor in software cursor mode.
    @field shieldRect The region that the cursor will not be displayed in if shieldFlag is true.
    @field cursorLoc The location of the cursor hot spot.
    @field cursorRect The region that the cursor image currently occupies in software cursor mode.
    @field oldCursorRect The region that the cursor image occupied the last time the cursor was drawn in software cursor mode.
    @field screenBounds The region that the current screen occupies.
    @field version Contains kIOFBCurrentShmemVersion so that a user client can ensure it is using the same version of this structure as the kernel.
    @field structSize Contains the size of this structure.
    @field vblTime The time of the most recent vertical blanking.
    @field vblDelta The interval between the two most recent vertical blankings.
    @field vblCount A running count of vertical blank interrupts.
    @field reservedC Reserved for future use.
    @field hardwareCursorCapable True if the hardware is capable of using hardware cursor mode.
    @field hardwareCursorActive True if currently using the hardware cursor mode.
    @field reservedB Reserved for future use.
    @field cursorSize This array contains the cursor sizes indexed by frame.
    @field hotSpot This array contains the location of the cursor hot spots indexed by frame. The hot spots coordinates are given relative to the top left corner of the cursor image.
    @field cursor A union of structures that define the cursor images. The structure used depends on the framebuffer's bit depth. These structures are defined above.
*/

struct StdFBShmem_t {
    OSSpinLock cursorSema;  
    int frame;
    char cursorShow;
    char cursorObscured;
    char shieldFlag;
    char shielded;
    IOGBounds saveRect;
    IOGBounds shieldRect;
    IOGPoint cursorLoc;
    IOGBounds cursorRect;
    IOGBounds oldCursorRect;
    IOGBounds screenBounds;
    int version;
    int structSize;
    AbsoluteTime vblTime;
    AbsoluteTime vblDelta;
    unsigned long long int vblCount;
#if IOFB_ARBITRARY_FRAMES_CURSOR
    unsigned long long int vblDrift;
    unsigned long long int vblDeltaMeasured;
    AbsoluteTime vblDeltaReal;
    unsigned int reservedC[22];
#else
    unsigned int reservedC[27];
    unsigned char hardwareCursorFlags[kIOFBNumCursorFrames];
#endif
    unsigned char hardwareCursorCapable;
    unsigned char hardwareCursorActive;
    unsigned char hardwareCursorShields;
    unsigned char reservedB[1];
#if IOFB_ARBITRARY_FRAMES_CURSOR
    IOGSize cursorSize[kIOFBNumCursorIndex];
    IOGPoint hotSpot[kIOFBNumCursorIndex];
#else
    IOGSize cursorSize[kIOFBNumCursorFrames];
    IOGPoint hotSpot[kIOFBNumCursorFrames];
#endif
#ifndef IOFB_ARBITRARY_SIZE_CURSOR
    union {
        struct bm12Cursor bw;
        struct bm18Cursor bw8;
        struct bm34Cursor rgb;
        struct bm38Cursor rgb24;
    } cursor;
#else  /* IOFB_ARBITRARY_SIZE_CURSOR */
    unsigned char cursor[0];
#endif /* IOFB_ARBITRARY_SIZE_CURSOR */
};
#ifndef __cplusplus
typedef volatile struct StdFBShmem_t StdFBShmem_t;
#endif


/*! @enum FramebufferConstants
    @constant kIOFBCurrentShmemVersion The current version of the slice of shared memory that contains the cursor and window server state data in the StdFBShmem_t structure.
    @constant kIOFBCursorMemory The memory type for IOConnectMapMemory() to get a slice of shared memory that contains the StdFBShmem_t structure.
*/
enum {
    // version for IOFBCreateSharedCursor
    kIOFBShmemVersionMask       = 0x000000ff,
    kIOFBTenPtOneShmemVersion   = 2,
    kIOFBTenPtTwoShmemVersion   = 3,
    kIOFBCurrentShmemVersion    = 2,

    // number of frames in animating cursor (if > kIOFBTenPtTwoShmemVersion)
    kIOFBShmemCursorNumFramesMask       = 0x00ff0000,
    kIOFBShmemCursorNumFramesShift      = 16,

    // memory types for IOConnectMapMemory.
    kIOFBCursorMemory           = 100
};

/*! @defined IOFRAMEBUFFER_CONFORMSTO
    @discussion The class name of the framebuffer service.
*/
#define IOFRAMEBUFFER_CONFORMSTO        "IOFramebuffer"

#ifdef __cplusplus
}
#endif

#endif /* ! _IOKIT_IOFRAMEBUFFERSHARED_H */
                             IOGraphicsDevice.h                                                                                  0100644 0001750 0001750 00000003021 12567452457 037111  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IOGRAPHICSDEVICE_H
#define _IOKIT_IOGRAPHICSDEVICE_H

#include <IOKit/IOService.h>
#include <IOKit/graphics/IOGraphicsTypes.h>


class IOGraphicsDevice : public IOService
{
    OSDeclareAbstractStructors(IOGraphicsDevice)

public:

    virtual void hideCursor( void ) = 0;
    virtual void showCursor( IOGPoint * cursorLoc, int frame ) = 0;
    virtual void moveCursor( IOGPoint * cursorLoc, int frame ) = 0;

    virtual void getVBLTime( AbsoluteTime * time, AbsoluteTime * delta ) = 0;

    virtual void getBoundingRect ( IOGBounds ** bounds ) = 0;
};

#endif /* ! _IOKIT_IOGRAPHICSDEVICE_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               IOGraphicsEngine.h                                                                                  0100644 0001750 0001750 00000003037 12567452457 037126  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1998 Apple Computer, Inc.  All rights reserved. 
 *
 * HISTORY
 *
 * 10 Mar 99 sdouglas created.
 */


struct IOGraphicsEngineContext {
    OSSpinLock          contextLock;
    IOOptionBits        state;
    void *              owner;
    UInt32              version;
    IOByteCount         structSize;
    UInt32              reserved[ 8 ];
};
#ifndef __cplusplus
typedef volatile struct IOGraphicsEngineContext IOGraphicsEngineContext;
#endif

enum {
    // memory type for IOMapMemory
    kIOGraphicsEngineContext            = 100
};

enum {
    // version
    kIOGraphicsEngineContextVersion     = 1
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IOGraphicsInterfaceTypes.h                                                                          0100644 0001750 0001750 00000024765 12567452457 040661  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 1999-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOGRAPHICSINTERFACETYPES_H
#define _IOKIT_IOGRAPHICSINTERFACETYPES_H

#include <IOKit/graphics/IOAccelSurfaceConnect.h>

#define IO_FOUR_CHAR_CODE(x)    (x)

typedef UInt32 IOFourCharCode;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define kCurrentGraphicsInterfaceVersion        1
#define kCurrentGraphicsInterfaceRevision       2


#ifdef IOGA_COMPAT
typedef SInt32          IOBlitCompletionToken;
#endif

typedef UInt32          IOBlitType;
enum {
    kIOBlitTypeVerbMask                 = 0x000000ff,
    kIOBlitTypeRects                    = 0,
    kIOBlitTypeCopyRects,
    kIOBlitTypeLines,
    kIOBlitTypeScanlines,
    kIOBlitTypeCopyRegion,

    kIOBlitTypeMoveCursor,
    kIOBlitTypeShowCursor,
    kIOBlitTypeHideCursor,

    kIOBlitTypeMonoExpand               = 0x00000100,
    kIOBlitTypeColorSpaceConvert        = 0x00000200,
    kIOBlitTypeScale                    = 0x00000400,

    kIOBlitTypeSourceKeyColorModeMask   = 0x00003000,
    kIOBlitTypeDestKeyColorModeMask     = 0x0000c000,
    kIOBlitTypeSourceKeyColorEqual      = 0x00001000,
    kIOBlitTypeSourceKeyColorNotEqual   = 0x00002000,
    kIOBlitTypeDestKeyColorEqual        = 0x00004000,
    kIOBlitTypeDestKeyColorNotEqual     = 0x00008000,

    kIOBlitTypeOperationMask            = 0x0fff0000,
    kIOBlitTypeOperationShift           = 16,
    kIOBlitTypeOperationTypeMask        = 0x0f000000,

    kIOBlitTypeOperationType0           = 0x00000000,
    kIOBlitCopyOperation                = 0x00000000 | kIOBlitTypeOperationType0,
    kIOBlitOrOperation                  = 0x00010000 | kIOBlitTypeOperationType0,
    kIOBlitXorOperation                 = 0x00020000 | kIOBlitTypeOperationType0,
    kIOBlitBlendOperation               = 0x00030000 | kIOBlitTypeOperationType0,
    kIOBlitHighlightOperation           = 0x00040000 | kIOBlitTypeOperationType0
};

typedef UInt32          IOBlitSourceType;
enum {
    kIOBlitSourceDefault                = 0x00000000,
    kIOBlitSourceFramebuffer            = 0x00001000,
    kIOBlitSourceMemory                 = 0x00002000,
    kIOBlitSourceOOLMemory              = 0x00003000,
    kIOBlitSourcePattern                = 0x00004000,
    kIOBlitSourceOOLPattern             = 0x00005000,
    kIOBlitSourceSolid                  = 0x00006000,
    kIOBlitSourceCGSSurface             = 0x00007000,
    kIOBlitSourceIsSame                 = 0x80000000
};

#ifdef IOGA_COMPAT
typedef IOBlitSourceType        IOBlitSourceDestType;
enum {
    kIOBlitDestFramebuffer              = 0x00000001
};
#endif

typedef struct IOBlitOperationStruct {
    UInt32              color0;
    UInt32              color1;
    SInt32              offsetX;
    SInt32              offsetY;
    UInt32              sourceKeyColor;
    UInt32              destKeyColor;
    UInt32              specific[16];
} IOBlitOperation;

typedef struct IOBlitRectangleStruct {
    SInt32              x;
    SInt32              y;
    SInt32              width;
    SInt32              height;
} IOBlitRectangle;

typedef struct IOBlitRectanglesStruct {
    IOBlitOperation     operation;
    IOItemCount         count;
    IOBlitRectangle     rects[1];
} IOBlitRectangles;

typedef struct IOBlitCopyRectangleStruct {
    SInt32              sourceX;
    SInt32              sourceY;
    SInt32              x;
    SInt32              y;
    SInt32              width;
    SInt32              height;
} IOBlitCopyRectangle;

typedef struct IOBlitCopyRectanglesStruct {
    IOBlitOperation     operation;
    IOItemCount         count;
    IOBlitCopyRectangle rects[1];
} IOBlitCopyRectangles;


typedef struct IOBlitCopyRegionStruct {
    IOBlitOperation       operation;
    SInt32                deltaX;
    SInt32                deltaY;
    IOAccelDeviceRegion * region;
} IOBlitCopyRegion;


typedef struct IOBlitVertexStruct {
    SInt32              x;
    SInt32              y;
} IOBlitVertex;

typedef struct IOBlitVerticesStruct {
    IOBlitOperation     operation;
    IOItemCount         count;
    IOBlitVertex        vertices[2];
} IOBlitVertices;

typedef struct IOBlitScanlinesStruct {
    IOBlitOperation     operation;
    IOItemCount         count;
    SInt32              y;
    SInt32              height;
    SInt32              x[2];
} IOBlitScanlines;


typedef struct IOBlitCursorStruct {
    IOBlitOperation     operation;
    IOBlitRectangle     rect;
} IOBlitCursor;

typedef struct _IOBlitMemory * IOBlitMemoryRef;


/* Quickdraw.h pixel formats*/

enum {
        kIO1MonochromePixelFormat       = 0x00000001,           /* 1 bit indexed*/
        kIO2IndexedPixelFormat          = 0x00000002,           /* 2 bit indexed*/
        kIO4IndexedPixelFormat          = 0x00000004,           /* 4 bit indexed*/
        kIO8IndexedPixelFormat          = 0x00000008,           /* 8 bit indexed*/
        kIO16BE555PixelFormat           = 0x00000010,           /* 16 bit BE rgb 555 (Mac)*/
        kIO24RGBPixelFormat             = 0x00000018,           /* 24 bit rgb */
        kIO32ARGBPixelFormat            = 0x00000020,           /* 32 bit argb  (Mac)*/
        kIO1IndexedGrayPixelFormat      = 0x00000021,           /* 1 bit indexed gray*/
        kIO2IndexedGrayPixelFormat      = 0x00000022,           /* 2 bit indexed gray*/
        kIO4IndexedGrayPixelFormat      = 0x00000024,           /* 4 bit indexed gray*/
        kIO8IndexedGrayPixelFormat      = 0x00000028            /* 8 bit indexed gray*/
};

enum {
        kIO16LE555PixelFormat   = IO_FOUR_CHAR_CODE('L555'),    /* 16 bit LE rgb 555 (PC)*/
        kIO16LE5551PixelFormat  = IO_FOUR_CHAR_CODE('5551'),    /* 16 bit LE rgb 5551*/
        kIO16BE565PixelFormat   = IO_FOUR_CHAR_CODE('B565'),    /* 16 bit BE rgb 565*/
        kIO16LE565PixelFormat   = IO_FOUR_CHAR_CODE('L565'),    /* 16 bit LE rgb 565*/
        kIO24BGRPixelFormat     = IO_FOUR_CHAR_CODE('24BG'),    /* 24 bit bgr */
        kIO32BGRAPixelFormat    = IO_FOUR_CHAR_CODE('BGRA'),    /* 32 bit bgra  (Matrox)*/
        kIO32ABGRPixelFormat    = IO_FOUR_CHAR_CODE('ABGR'),    /* 32 bit abgr  */
        kIO32RGBAPixelFormat    = IO_FOUR_CHAR_CODE('RGBA'),    /* 32 bit rgba  */
        kIOYUVSPixelFormat      = IO_FOUR_CHAR_CODE('yuvs'),    /* YUV 4:2:2 byte ordering 16-unsigned = 'YUY2'*/
        kIOYUVUPixelFormat      = IO_FOUR_CHAR_CODE('yuvu'),    /* YUV 4:2:2 byte ordering 16-signed*/
        kIOYVU9PixelFormat      = IO_FOUR_CHAR_CODE('YVU9'),    /* YVU9 Planar  9*/
        kIOYUV411PixelFormat    = IO_FOUR_CHAR_CODE('Y411'),    /* YUV 4:1:1 Interleaved 16*/
        kIOYVYU422PixelFormat   = IO_FOUR_CHAR_CODE('YVYU'),    /* YVYU 4:2:2 byte ordering 16*/
        kIOUYVY422PixelFormat   = IO_FOUR_CHAR_CODE('UYVY'),    /* UYVY 4:2:2 byte ordering 16*/
        kIOYUV211PixelFormat    = IO_FOUR_CHAR_CODE('Y211'),    /* YUV 2:1:1 Packed     8*/
        kIO2vuyPixelFormat      = IO_FOUR_CHAR_CODE('2vuy') /* UYVY 4:2:2 byte ordering   16*/
};

/* Non Quickdraw.h pixel formats*/
enum {
        kIO16LE4444PixelFormat     = IO_FOUR_CHAR_CODE('L444'), /* 16 bit LE argb 4444*/
        kIO16BE4444PixelFormat     = IO_FOUR_CHAR_CODE('B444'), /* 16 bit BE argb 4444*/
        kIO64BGRAPixelFormat       = IO_FOUR_CHAR_CODE('B16I'), /* 64 bit bgra  */
        kIO64RGBAFloatPixelFormat  = IO_FOUR_CHAR_CODE('B16F'), /* 64 bit rgba  */
        kIO128RGBAFloatPixelFormat = IO_FOUR_CHAR_CODE('B32F')  /* 128 bit rgba float */
};

enum {
    kIOBlitMemoryRequiresHostFlush      = 0x00000001
};

typedef struct IOBlitSurfaceStruct {
    union {
        UInt8 *         bytes;
        IOBlitMemoryRef ref;
    }                   memory;
    IOFourCharCode      pixelFormat;
    IOBlitRectangle     size;
    UInt32              rowBytes;
    UInt32              byteOffset;
    UInt32 *            palette;
    IOOptionBits        accessFlags;
    IOBlitMemoryRef     interfaceRef;
    UInt32              more[14];
} IOBlitSurface;

typedef IOBlitSurface IOBlitMemory;


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

enum {
    // options for Synchronize
    kIOBlitSynchronizeWaitBeamExit      = 0x00000001,
    kIOBlitSynchronizeFlushHostWrites   = 0x00000002
};

enum {
    // options for WaitComplete & Flush
    kIOBlitWaitContext                  = 0x00000000,
    kIOBlitWaitAll2D                    = 0x00000001,
    kIOBlitWaitGlobal                   = 0x00000001,
    kIOBlitWaitAll                      = 0x00000002,
    kIOBlitWaitCheck                    = 0x00000080,
    kIOBlitFlushWithSwap                = 0x00010000
};

enum {
    // options for AllocateSurface
    kIOBlitHasCGSSurface                = 0x00000001,
    kIOBlitFixedSource                  = 0x00000002,
    kIOBlitBeamSyncSwaps                = 0x00000004,
    kIOBlitReferenceSource              = 0x00000008
};

enum {
    // options for UnlockSurface
    kIOBlitUnlockWithSwap               = 0x80000000
};

enum {
    // options for SetDestination
    kIOBlitFramebufferDestination       = 0x00000000,
    kIOBlitSurfaceDestination           = 0x00000001
};



enum {
    // options for blit procs
    kIOBlitBeamSync                     = 0x00000001,
    kIOBlitBeamSyncAlways               = 0x00000002,
    kIOBlitBeamSyncSpin                 = 0x00000004,

    kIOBlitAllOptions                   = 0xffffffff
};

enum {
    // capabilities
    kIOBlitColorSpaceTypes              = IO_FOUR_CHAR_CODE('cspc')
};


// keys for IOAccelFindAccelerator()
#define kIOAccelTypesKey                        "IOAccelTypes"
#define kIOAccelIndexKey                        "IOAccelIndex"

#define kIOAccelRevisionKey                     "IOAccelRevision"

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#endif /* !_IOKIT_IOGRAPHICSINTERFACETYPES_H */
           IOGraphicsTypes.h                                                                                   0100644 0001750 0001750 00000166236 12567452457 037040  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/graphics                                                       /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOGRAPHICSTYPES_H
#define _IOKIT_IOGRAPHICSTYPES_H


#include <IOKit/IOTypes.h>
#include <IOKit/IOKitKeys.h>

#ifdef __cplusplus
extern "C" {
#endif

#define IOGRAPHICSTYPES_REV     42

typedef SInt32  IOIndex;
typedef UInt32  IOSelect;
typedef UInt32  IOFixed1616;
typedef UInt32  IODisplayVendorID;
typedef UInt32  IODisplayProductID;

typedef SInt32  IODisplayModeID;
enum {
    // This is the ID given to a programmable timing used at boot time
    kIODisplayModeIDBootProgrammable = (IODisplayModeID)0xFFFFFFFB,
    // Lowest (unsigned) DisplayModeID reserved by Apple
    kIODisplayModeIDReservedBase     = (IODisplayModeID)0x80000000
};

enum {
    kIOMaxPixelBits     = 64
};
typedef char IOPixelEncoding[ kIOMaxPixelBits ];

// Common Apple pixel formats

#define IO1BitIndexedPixels     "P"
#define IO2BitIndexedPixels     "PP"
#define IO4BitIndexedPixels     "PPPP"
#define IO8BitIndexedPixels     "PPPPPPPP"
#define IO16BitDirectPixels     "-RRRRRGGGGGBBBBB"
#define IO32BitDirectPixels     "--------RRRRRRRRGGGGGGGGBBBBBBBB"

#define kIO30BitDirectPixels    "--RRRRRRRRRRGGGGGGGGGGBBBBBBBBBB"
#define kIO64BitDirectPixels    "-16R16G16B16"

#define kIO16BitFloatPixels     "-16FR16FG16FB16"
#define kIO32BitFloatPixels     "-32FR32FG32FB32"

// other possible pixel formats

#define IOYUV422Pixels          "Y4U2V2"
#define IO8BitOverlayPixels     "O8"
// page flipping
#define IOPagedPixels           "Page1"

#define IO_SampleTypeAlpha      'A'
#define IO_SampleTypeSkip       '-'

// Info about a pixel format
enum {
    kIOCLUTPixels                   = 0,
    kIOFixedCLUTPixels              = 1,
    kIORGBDirectPixels              = 2,
    kIOMonoDirectPixels             = 3,
    kIOMonoInverseDirectPixels      = 4,
    kIORGBSignedDirectPixels        = 5,
    kIORGBSignedFloatingPointPixels = 6
};

/*!
 * @struct IOPixelInformation
 * @abstract A structure defining the format of a framebuffer.
 * @discussion This structure is used by IOFramebuffer to define the format of the pixels.
 * @field bytesPerRow The number of bytes per row.
 * @field bytesPerPlane Not used.
 * @field bitsPerPixel The number of bits per pixel, including unused bits and alpha.
 * @field pixelType One of kIOCLUTPixels (indexed pixels with changeable CLUT), kIORGBDirectPixels (direct pixels).
 * @field componentCount One for indexed pixels, three for direct pixel formats.
 * @field bitsPerComponent Number of bits per component in each pixel.
 * @field componentMasks Mask of the bits valid for each component of the pixel - in R, G, B order for direct pixels.
 * @field pixelFormat String description of the pixel format - IO32BitDirectPixels, IO16BitDirectPixels etc.
 * @field flags None defined - set to zero.
 * @field activeWidth Number of pixels visible per row.
 * @field activeHeight Number of visible pixel rows.
 * @field reserved Set to zero.
 */

struct IOPixelInformation {
    UInt32                      bytesPerRow;
    UInt32                      bytesPerPlane;
    UInt32                      bitsPerPixel;
    UInt32                      pixelType;
    UInt32                      componentCount;
    UInt32                      bitsPerComponent;
    UInt32                      componentMasks[ 8 * 2 ];
    IOPixelEncoding             pixelFormat;
    UInt32                      flags;
    UInt32                      activeWidth;
    UInt32                      activeHeight;
    UInt32                      reserved[ 2 ];
};
typedef struct IOPixelInformation IOPixelInformation;

// ID for industry standard display timings
typedef UInt32  IOAppleTimingID;

/*!
 * @struct IODisplayModeInformation
 * @abstract A structure defining the format of a framebuffer.
 * @discussion This structure is used by IOFramebuffer to define the format of the pixels.
 * @field nominalWidth Number of pixels visible per row.
 * @field nominalHeight Number of visible pixel rows.
 * @field refreshRate Refresh rate in fixed point 16.16.
 * @field maxDepthIndex Highest depth index available in this display mode.
 * @field flags Flags for the mode, including: <br>
 *   kDisplayModeInterlacedFlag mode is interlaced. <br>
 *   kDisplayModeSimulscanFlag mode is available on multiple display connections. <br>
 *   kDisplayModeNotPresetFlag mode is not a factory preset for the display (geometry may need correction). <br>
 *   kDisplayModeStretchedFlag mode is stretched/distorted to match the display aspect ratio. <br>
 * @field imageWidth Physical width of active image if known, in millimeters, otherwise zero. <br>
 * @field imageHeight Physical height of active image if known, in millimeters, otherwise zero. <br>
 * @field reserved Set to zero.
 */

struct IODisplayModeInformation {
    UInt32                      nominalWidth;
    UInt32                      nominalHeight;
    IOFixed1616                 refreshRate;
    IOIndex                     maxDepthIndex;
    UInt32                      flags;
    UInt16						imageWidth;
    UInt16						imageHeight;
    UInt32                      reserved[ 3 ];
};
typedef struct IODisplayModeInformation IODisplayModeInformation;

// flags
enum {
    kDisplayModeSafetyFlags             = 0x00000007,

    kDisplayModeAlwaysShowFlag          = 0x00000008,
    kDisplayModeNeverShowFlag           = 0x00000080,
    kDisplayModeNotResizeFlag           = 0x00000010,
    kDisplayModeRequiresPanFlag         = 0x00000020,

    kDisplayModeInterlacedFlag          = 0x00000040,

    kDisplayModeSimulscanFlag           = 0x00000100,
    kDisplayModeBuiltInFlag             = 0x00000400,
    kDisplayModeNotPresetFlag           = 0x00000200,
    kDisplayModeStretchedFlag           = 0x00000800,
    kDisplayModeNotGraphicsQualityFlag  = 0x00001000,
    kDisplayModeValidateAgainstDisplay  = 0x00002000,
    kDisplayModeTelevisionFlag          = 0x00100000,
    kDisplayModeValidForMirroringFlag   = 0x00200000,
    kDisplayModeAcceleratorBackedFlag   = 0x00400000,
    kDisplayModeValidForHiResFlag       = 0x00800000,
    kDisplayModeValidForAirPlayFlag     = 0x01000000,
    kDisplayModeNativeFlag              = 0x02000000
};
enum {
    kDisplayModeValidFlag               = 0x00000001,
    kDisplayModeSafeFlag                = 0x00000002,
    kDisplayModeDefaultFlag             = 0x00000004
};

#ifndef KERNEL
// Framebuffer info - obsolete

struct IOFramebufferInformation {
    IOPhysicalAddress           baseAddress;
    UInt32                      activeWidth;
    UInt32                      activeHeight;
    IOByteCount                 bytesPerRow;
    IOByteCount                 bytesPerPlane;
    UInt32                      bitsPerPixel;
    UInt32                      pixelType;
    UInt32                      flags;
    UInt32                      reserved[ 4 ];
};
typedef struct IOFramebufferInformation IOFramebufferInformation;
#endif

// flags
enum {
    kFramebufferSupportsCopybackCache   = 0x00010000,
    kFramebufferSupportsWritethruCache  = 0x00020000,
    kFramebufferSupportsGammaCorrection = 0x00040000,
    kFramebufferDisableAltivecAccess    = 0x00080000
};

// Aperture is an index into supported pixel formats for a mode & depth
typedef IOIndex IOPixelAperture;
enum {
    kIOFBSystemAperture = 0
};

//// CLUTs

typedef UInt16 IOColorComponent;

/*!
 * @struct IOColorEntry
 * @abstract A structure defining one entry of a color lookup table.
 * @discussion This structure is used by IOFramebuffer to define an entry of a color lookup table.
 * @field index Number of pixels visible per row.
 * @field red Value of red component 0-65535.
 * @field green Value of green component 0-65535.
 * @field blue Value of blue component 0-65535.
 */

struct IOColorEntry {
    UInt16                      index;
    IOColorComponent            red;
    IOColorComponent            green;
    IOColorComponent            blue;
};
typedef struct IOColorEntry IOColorEntry;

// options (masks)
enum {
    kSetCLUTByValue             = 0x00000001,           // else at index
    kSetCLUTImmediately         = 0x00000002,           // else at VBL
    kSetCLUTWithLuminance       = 0x00000004            // else RGB
};

//// Controller attributes

enum {
    kIOPowerStateAttribute              = 'pwrs',
    kIOPowerAttribute                   = 'powr',
    kIODriverPowerAttribute             = 'dpow',
    kIOHardwareCursorAttribute          = 'crsr',

    kIOMirrorAttribute                  = 'mirr',
    kIOMirrorDefaultAttribute           = 'mrdf',

    kIOCapturedAttribute                = 'capd',

    kIOCursorControlAttribute           = 'crsc',

    kIOSystemPowerAttribute             = 'spwr',
    kIOWindowServerActiveAttribute      = 'wsrv',
    kIOVRAMSaveAttribute                = 'vrsv',
    kIODeferCLUTSetAttribute            = 'vclt',

    kIOClamshellStateAttribute          = 'clam',

	kIOFBDisplayPortTrainingAttribute   = 'dpta',
};

// values for kIOMirrorAttribute
enum {
    kIOMirrorIsPrimary                  = 0x80000000,
    kIOMirrorHWClipped                  = 0x40000000,
    kIOMirrorIsMirrored                 = 0x20000000
};

// values for kIOMirrorDefaultAttribute
enum {
    kIOMirrorDefault                    = 0x00000001,
    kIOMirrorForced                     = 0x00000002
};

//// Display mode timing information

struct IODetailedTimingInformationV1 {
    // from EDID defn
    UInt32                      pixelClock;             // Hertz
    UInt32                      horizontalActive;       // pixels
    UInt32                      horizontalBlanking;     // pixels
    UInt32                      horizontalBorder;       // pixels
    UInt32                      horizontalSyncOffset;   // pixels
    UInt32                      horizontalSyncWidth;    // pixels
    UInt32                      verticalActive;         // lines
    UInt32                      verticalBlanking;       // lines
    UInt32                      verticalBorder;         // lines
    UInt32                      verticalSyncOffset;     // lines
    UInt32                      verticalSyncWidth;      // lines
};
typedef struct IODetailedTimingInformationV1 IODetailedTimingInformationV1;

/*!
 * @struct IODetailedTimingInformationV2
 * @abstract A structure defining the detailed timing information of a display mode.
 * @discussion This structure is used by IOFramebuffer to define detailed timing information for a display mode. The VESA EDID document has more information.
 * @field __reservedA Set to zero.
 * @field horizontalScaledInset If the mode is scaled, sets the number of active pixels to remove the left and right edges in order to display an underscanned image.
 * @field verticalScaledInset If the mode is scaled, sets the number of active lines to remove the top and bottom edges in order to display an underscanned image.
 * @field scalerFlags If the mode is scaled,
 *    kIOScaleStretchToFit may be set to allow stretching.
 *    kIOScaleRotateFlags is mask which may have the value given by kIOScaleRotate90, kIOScaleRotate180, kIOScaleRotate270 to display a rotated framebuffer.
 * @field horizontalScaled If the mode is scaled, sets the size of the image before scaling or rotation.
 * @field verticalScaled If the mode is scaled, sets the size of the image before scaling or rotation.
 * @field signalConfig 
 *    kIOAnalogSetupExpected set if display expects a blank-to-black setup or pedestal.  See VESA signal standards. <br>
 *    kIOInterlacedCEATiming set for a CEA style interlaced timing:<br>
 *      Field 1 vertical blanking = half specified vertical blanking lines. <br>
 *      Field 2 vertical blanking = (half vertical blanking lines) + 1 line. <br>
 *      Field 1 vertical offset = half specified vertical sync offset. <br>
 *      Field 2 vertical offset = (half specified vertical sync offset) + 0.5 lines. <br>
 * @field signalLevels One of:<br>
 *   kIOAnalogSignalLevel_0700_0300 0.700 - 0.300 V p-p.<br>
 *   kIOAnalogSignalLevel_0714_0286 0.714 - 0.286 V p-p.<br>
 *   kIOAnalogSignalLevel_1000_0400 1.000 - 0.400 V p-p.<br>
 *   kIOAnalogSignalLevel_0700_0000 0.700 - 0.000 V p-p.<br>
 * @field pixelClock Pixel clock frequency in Hz.
 * @field minPixelClock Minimum pixel clock frequency in Hz, with error.
 * @field maxPixelClock Maximum pixel clock frequency in Hz, with error.
 * @field horizontalActive Pixel clocks per line.
 * @field horizontalBlanking Blanking clocks per line.
 * @field horizontalSyncOffset First clock of horizontal sync.
 * @field horizontalSyncPulseWidth Width of horizontal sync.
 * @field verticalActive Number of lines per frame.
 * @field verticalBlanking Blanking lines per frame.
 * @field verticalSyncOffset First line of vertical sync.
 * @field verticalSyncPulseWidth Height of vertical sync.
 * @field horizontalBorderLeft Number of pixels in left horizontal border.
 * @field horizontalBorderRight Number of pixels in right horizontal border.
 * @field verticalBorderTop Number of lines in top vertical border.
 * @field verticalBorderBottom Number of lines in bottom vertical border.
 * @field horizontalSyncConfig kIOSyncPositivePolarity for positive polarity horizontal sync (0 for negative).
 * @field horizontalSyncLevel Zero.
 * @field verticalSyncConfig kIOSyncPositivePolarity for positive polarity vertical sync (0 for negative).
 * @field verticalSyncLevel Zero.
 * @field numLinks number of links to be used by a dual link timing, if zero, assume one link.
 * @field __reservedB Reserved set to zero.
 */

struct IODetailedTimingInformationV2 {

    UInt32      __reservedA[3];                 // Init to 0
    UInt32      horizontalScaledInset;          // pixels
    UInt32      verticalScaledInset;            // lines

    UInt32      scalerFlags;
    UInt32      horizontalScaled;
    UInt32      verticalScaled;

    UInt32      signalConfig;
    UInt32      signalLevels;

    UInt64      pixelClock;                     // Hz

    UInt64      minPixelClock;                  // Hz - With error what is slowest actual clock
    UInt64      maxPixelClock;                  // Hz - With error what is fasted actual clock

    UInt32      horizontalActive;               // pixels
    UInt32      horizontalBlanking;             // pixels
    UInt32      horizontalSyncOffset;           // pixels
    UInt32      horizontalSyncPulseWidth;       // pixels

    UInt32      verticalActive;                 // lines
    UInt32      verticalBlanking;               // lines
    UInt32      verticalSyncOffset;             // lines
    UInt32      verticalSyncPulseWidth;         // lines

    UInt32      horizontalBorderLeft;           // pixels
    UInt32      horizontalBorderRight;          // pixels
    UInt32      verticalBorderTop;              // lines
    UInt32      verticalBorderBottom;           // lines

    UInt32      horizontalSyncConfig;
    UInt32      horizontalSyncLevel;            // Future use (init to 0)
    UInt32      verticalSyncConfig;
    UInt32      verticalSyncLevel;              // Future use (init to 0)
    UInt32      numLinks;

    UInt32      __reservedB[7];                 // Init to 0
};
typedef struct IODetailedTimingInformationV2 IODetailedTimingInformationV2;
typedef struct IODetailedTimingInformationV2 IODetailedTimingInformation;

struct IOTimingInformation {
    IOAppleTimingID             appleTimingID;  // kIOTimingIDXXX const
    UInt32                      flags;
    union {
      IODetailedTimingInformationV1     v1;
      IODetailedTimingInformationV2     v2;
    }                           detailedInfo;
};
typedef struct IOTimingInformation IOTimingInformation;

enum {
    // IOTimingInformation flags
    kIODetailedTimingValid      = 0x80000000,
    kIOScalingInfoValid         = 0x40000000
};

enum {
    // scalerFlags
    kIOScaleStretchToFit        = 0x00000001,

    kIOScaleRotateFlags         = 0x000000f0,

    kIOScaleSwapAxes            = 0x00000010,
    kIOScaleInvertX             = 0x00000020,
    kIOScaleInvertY             = 0x00000040,

    kIOScaleRotate0             = 0x00000000,
    kIOScaleRotate90            = kIOScaleSwapAxes | kIOScaleInvertX,
    kIOScaleRotate180           = kIOScaleInvertX  | kIOScaleInvertY,
    kIOScaleRotate270           = kIOScaleSwapAxes | kIOScaleInvertY
};


#pragma pack(push, 4)
struct IOFBDisplayModeDescription {
    IODisplayModeInformation    info;
    IOTimingInformation         timingInfo;
};
typedef struct IOFBDisplayModeDescription IOFBDisplayModeDescription;
#pragma pack(pop)

/*!
 * @struct IODisplayTimingRange
 * @abstract A structure defining the limits and attributes of a display or framebuffer.
 * @discussion This structure is used to define the limits for modes programmed as detailed timings by the OS. The VESA EDID is useful background information for many of these fields. A data property with this structure under the key kIOFBTimingRangeKey in a framebuffer will allow the OS to program detailed timings that fall within its range.
 * @field __reservedA Set to zero.
 * @field version Set to zero.
 * @field __reservedB Set to zero.
 * @field minPixelClock minimum pixel clock frequency in range, in Hz.
 * @field minPixelClock maximum pixel clock frequency in range, in Hz.
 * @field maxPixelError largest variation between specified and actual pixel clock frequency, in Hz.
 * @field supportedSyncFlags mask of supported sync attributes. The following are defined:<br>
 *    kIORangeSupportsSeparateSyncs - digital separate syncs.<br>
 *    kIORangeSupportsSyncOnGreen - sync on green.<br>
 *    kIORangeSupportsCompositeSync - composite sync.<br>
 *    kIORangeSupportsVSyncSerration - vertical sync has serration and equalization pulses.<br>
 * @field supportedSignalLevels mask of possible signal levels. The following are defined:<br>
 *    kIORangeSupportsSignal_0700_0300 0.700 - 0.300 V p-p.<br>
 *    kIORangeSupportsSignal_0714_0286 0.714 - 0.286 V p-p.<br>
 *    kIORangeSupportsSignal_1000_0400 1.000 - 0.400 V p-p.<br>
 *    kIORangeSupportsSignal_0700_0000 0.700 - 0.000 V p-p.<br>
 * @field supportedSignalConfigs mask of possible signal configurations. The following are defined:<br>
 *    kIORangeSupportsInterlacedCEATiming Supports CEA style interlaced timing:<br>
 *      Field 1 vertical blanking = specified vertical blanking lines. <br>
 *      Field 2 vertical blanking = vertical blanking lines + 1 line. <br> 
 *      Field 1 vertical offset = specified vertical sync offset. <br>
 *      Field 2 vertical offset = specified vertical sync offset + 0.5 lines. <br>
 *    kIORangeSupportsInterlacedCEATimingWithConfirm Supports CEA style interlaced timing, but require a confirm.
 * @field minFrameRate minimum frame rate (vertical refresh frequency) in range, in Hz.
 * @field maxFrameRate maximum frame rate (vertical refresh frequency) in range, in Hz.
 * @field minLineRate minimum line rate (horizontal refresh frequency) in range, in Hz.
 * @field maxLineRate maximum line rate (horizontal refresh frequency) in range, in Hz.
 * @field maxHorizontalTotal maximum clocks in horizontal line (active + blanking).
 * @field maxVerticalTotal maximum lines in vertical frame (active + blanking).
 * @field __reservedD Set to zero.
 * @field charSizeHorizontalActive horizontalActive must be a multiple of charSizeHorizontalActive.
 * @field charSizeHorizontalBlanking horizontalBlanking must be a multiple of charSizeHorizontalBlanking.
 * @field charSizeHorizontalSyncOffset horizontalSyncOffset must be a multiple of charSizeHorizontalSyncOffset.
 * @field charSizeHorizontalSyncPulse horizontalSyncPulse must be a multiple of charSizeHorizontalSyncPulse.
 * @field charSizeVerticalActive verticalActive must be a multiple of charSizeVerticalActive.
 * @field charSizeVerticalBlanking verticalBlanking must be a multiple of charSizeVerticalBlanking.
 * @field charSizeVerticalSyncOffset verticalSyncOffset must be a multiple of charSizeVerticalSyncOffset.
 * @field charSizeVerticalSyncPulse verticalSyncPulse must be a multiple of charSizeVerticalSyncPulse.
 * @field charSizeHorizontalBorderLeft horizontalBorderLeft must be a multiple of charSizeHorizontalBorderLeft.
 * @field charSizeHorizontalBorderRight horizontalBorderRight must be a multiple of charSizeHorizontalBorderRight.
 * @field charSizeVerticalBorderTop verticalBorderTop must be a multiple of charSizeVerticalBorderTop.
 * @field charSizeVerticalBorderBottom verticalBorderBottom must be a multiple of charSizeVerticalBorderBottom.
 * @field charSizeHorizontalTotal (horizontalActive + horizontalBlanking) must be a multiple of charSizeHorizontalTotal.
 * @field charSizeVerticalTotal (verticalActive + verticalBlanking) must be a multiple of charSizeVerticalTotal.
 * @field __reservedE Set to zero.
 * @field minHorizontalActiveClocks minimum value of horizontalActive.
 * @field maxHorizontalActiveClocks maximum value of horizontalActive.
 * @field minHorizontalBlankingClocks minimum value of horizontalBlanking.
 * @field maxHorizontalBlankingClocks maximum value of horizontalBlanking.
 * @field minHorizontalSyncOffsetClocks minimum value of horizontalSyncOffset.
 * @field maxHorizontalSyncOffsetClocks maximum value of horizontalSyncOffset.
 * @field minHorizontalPulseWidthClocks minimum value of horizontalPulseWidth.
 * @field maxHorizontalPulseWidthClocks maximum value of horizontalPulseWidth.
 * @field minVerticalActiveClocks minimum value of verticalActive.
 * @field maxVerticalActiveClocks maximum value of verticalActive.
 * @field minVerticalBlankingClocks minimum value of verticalBlanking.
 * @field maxVerticalBlankingClocks maximum value of verticalBlanking.
 * @field minVerticalSyncOffsetClocks minimum value of verticalSyncOffset.
 * @field maxVerticalSyncOffsetClocks maximum value of verticalSyncOffset.
 * @field minVerticalPulseWidthClocks minimum value of verticalPulseWidth.
 * @field maxVerticalPulseWidthClocks maximum value of verticalPulseWidth.
 * @field minHorizontalBorderLeft minimum value of horizontalBorderLeft.
 * @field maxHorizontalBorderLeft maximum value of horizontalBorderLeft.
 * @field minHorizontalBorderRight minimum value of horizontalBorderRight.
 * @field maxHorizontalBorderRight maximum value of horizontalBorderRight.
 * @field minVerticalBorderTop minimum value of verticalBorderTop.
 * @field maxVerticalBorderTop maximum value of verticalBorderTop.
 * @field minVerticalBorderBottom minimum value of verticalBorderBottom.
 * @field maxVerticalBorderBottom maximum value of verticalBorderBottom.
 * @field maxNumLinks number of links supported, if zero, 1 link is assumed.
 * @field minLink0PixelClock minimum pixel clock for link 0 (kHz).
 * @field maxLink0PixelClock maximum pixel clock for link 0 (kHz).
 * @field minLink1PixelClock minimum pixel clock for link 1 (kHz).
 * @field maxLink1PixelClock maximum pixel clock for link 1 (kHz).
 * @field __reservedF Set to zero.
 */

struct IODisplayTimingRange
{
    UInt32      __reservedA[2];                 // Init to 0
    UInt32      version;                        // Init to 0
    UInt32      __reservedB[5];                 // Init to 0

    UInt64      minPixelClock;                  // Min dot clock in Hz
    UInt64      maxPixelClock;                  // Max dot clock in Hz

    UInt32      maxPixelError;                  // Max dot clock error
    UInt32      supportedSyncFlags;
    UInt32      supportedSignalLevels;
    UInt32      supportedSignalConfigs;

    UInt32      minFrameRate;                   // Hz
    UInt32      maxFrameRate;                   // Hz
    UInt32      minLineRate;                    // Hz
    UInt32      maxLineRate;                    // Hz

    UInt32      maxHorizontalTotal;             // Clocks - Maximum total (active + blanking)
    UInt32      maxVerticalTotal;               // Clocks - Maximum total (active + blanking)
    UInt32      __reservedD[2];                 // Init to 0

    UInt8       charSizeHorizontalActive;
    UInt8       charSizeHorizontalBlanking;     
    UInt8       charSizeHorizontalSyncOffset; 
    UInt8       charSizeHorizontalSyncPulse; 

    UInt8       charSizeVerticalActive;         
    UInt8       charSizeVerticalBlanking;       
    UInt8       charSizeVerticalSyncOffset;     
    UInt8       charSizeVerticalSyncPulse;      

    UInt8       charSizeHorizontalBorderLeft; 
    UInt8       charSizeHorizontalBorderRight; 
    UInt8       charSizeVerticalBorderTop;      
    UInt8       charSizeVerticalBorderBottom; 

    UInt8       charSizeHorizontalTotal;                // Character size for active + blanking
    UInt8       charSizeVerticalTotal;                  // Character size for active + blanking
    UInt16      __reservedE;                            // Reserved (Init to 0)

    UInt32      minHorizontalActiveClocks;
    UInt32      maxHorizontalActiveClocks;
    UInt32      minHorizontalBlankingClocks;
    UInt32      maxHorizontalBlankingClocks;

    UInt32      minHorizontalSyncOffsetClocks;
    UInt32      maxHorizontalSyncOffsetClocks;
    UInt32      minHorizontalPulseWidthClocks;
    UInt32      maxHorizontalPulseWidthClocks;

    UInt32      minVerticalActiveClocks;
    UInt32      maxVerticalActiveClocks;
    UInt32      minVerticalBlankingClocks;
    UInt32      maxVerticalBlankingClocks;

    UInt32      minVerticalSyncOffsetClocks;
    UInt32      maxVerticalSyncOffsetClocks;
    UInt32      minVerticalPulseWidthClocks;
    UInt32      maxVerticalPulseWidthClocks;

    UInt32      minHorizontalBorderLeft;
    UInt32      maxHorizontalBorderLeft;
    UInt32      minHorizontalBorderRight;
    UInt32      maxHorizontalBorderRight;

    UInt32      minVerticalBorderTop;
    UInt32      maxVerticalBorderTop;
    UInt32      minVerticalBorderBottom;
    UInt32      maxVerticalBorderBottom;
    UInt32      maxNumLinks;                       // number of links, if zero, assume link 1
    UInt32      minLink0PixelClock;                // min pixel clock for link 0 (kHz)
    UInt32      maxLink0PixelClock;                // max pixel clock for link 0 (kHz)
    UInt32      minLink1PixelClock;                // min pixel clock for link 1 (kHz)
    UInt32      maxLink1PixelClock;                // max pixel clock for link 1 (kHz)

    UInt32      __reservedF[3];                 // Init to 0
};
typedef struct IODisplayTimingRange  IODisplayTimingRange;

enum {
    // supportedSignalLevels
    kIORangeSupportsSignal_0700_0300    = 0x00000001,
    kIORangeSupportsSignal_0714_0286    = 0x00000002,
    kIORangeSupportsSignal_1000_0400    = 0x00000004,
    kIORangeSupportsSignal_0700_0000    = 0x00000008
};
enum {
    // supportedSyncFlags
    kIORangeSupportsSeparateSyncs        = 0x00000001,
    kIORangeSupportsSyncOnGreen          = 0x00000002,
    kIORangeSupportsCompositeSync        = 0x00000004,
    kIORangeSupportsVSyncSerration       = 0x00000008
};
enum {
    // supportedSignalConfigs
    kIORangeSupportsInterlacedCEATiming            = 0x00000004,
    kIORangeSupportsInterlacedCEATimingWithConfirm = 0x00000008
};

enum {
    // signalConfig
    kIODigitalSignal          = 0x00000001,
    kIOAnalogSetupExpected    = 0x00000002,
    kIOInterlacedCEATiming    = 0x00000004,
    kIONTSCTiming             = 0x00000008,
    kIOPALTiming              = 0x00000010
};

enum {
    // signalLevels for analog
    kIOAnalogSignalLevel_0700_0300 = 0,
    kIOAnalogSignalLevel_0714_0286 = 1,
    kIOAnalogSignalLevel_1000_0400 = 2,
    kIOAnalogSignalLevel_0700_0000 = 3
};

enum {
    // horizontalSyncConfig and verticalSyncConfig
    kIOSyncPositivePolarity     = 0x00000001
};

/*!
 * @struct IODisplayScalerInformation
 * @abstract A structure defining the scaling capabilities of a framebuffer.
 * @discussion This structure is used to define the limits for modes programmed as detailed timings by the OS. A data property with this structure under the key kIOFBScalerInfoKey in a framebuffer will allow the OS to program detailed timings that are scaled to a displays native resolution.
 * @field __reservedA Set to zero.
 * @field version Set to zero.
 * @field __reservedB Set to zero.
 * @field scalerFeatures Mask of scaling features. The following are defined:<br>
 *   kIOScaleStretchOnly If set the framebuffer can only provide stretched scaling with non-square pixels, without borders.<br>
 *   kIOScaleCanUpSamplePixels If set framebuffer can scale up from a smaller number of source pixels to a larger native timing (eg. 640x480 pixels on a 1600x1200 timing).<br>
 *   kIOScaleCanDownSamplePixels If set framebuffer can scale down from a larger number of source pixels to a smaller native timing (eg. 1600x1200 pixels on a 640x480 timing).<br>
 *   kIOScaleCanScaleInterlaced If set framebuffer can scale an interlaced detailed timing.<br>
 *   kIOScaleCanSupportInset If set framebuffer can support scaled modes with non-zero horizontalScaledInset, verticalScaledInset fields.<br>
 *   kIOScaleCanRotate If set framebuffer can support some of the flags in the kIOScaleRotateFlags mask.<br>
 *   kIOScaleCanBorderInsetOnly If set framebuffer can support scaled modes with non-zero horizontalScaledInset, verticalScaledInset fields, but requires the active pixels to be equal in size to the inset area, ie. can do insets with a border versus scaling an image.<br>
 * @field maxHorizontalPixels Maximum number of horizontal source pixels (horizontalScaled).<br>
 * @field maxVerticalPixels Maximum number of vertical source pixels (verticalScaled).<br>
 * @field __reservedC Set to zero.
 */

struct IODisplayScalerInformation {
    UInt32              __reservedA[1];         // Init to 0
    UInt32              version;                // Init to 0
    UInt32              __reservedB[2];         // Init to 0
    
    IOOptionBits        scalerFeatures;
    UInt32              maxHorizontalPixels;
    UInt32              maxVerticalPixels;
    UInt32              __reservedC[5];         // Init to 0
};
typedef struct IODisplayScalerInformation IODisplayScalerInformation;

enum {
    /* scalerFeatures */
    kIOScaleStretchOnly           = 0x00000001,
    kIOScaleCanUpSamplePixels     = 0x00000002,
    kIOScaleCanDownSamplePixels   = 0x00000004,
    kIOScaleCanScaleInterlaced    = 0x00000008,
    kIOScaleCanSupportInset       = 0x00000010,
    kIOScaleCanRotate             = 0x00000020,
    kIOScaleCanBorderInsetOnly    = 0x00000040
};

//// Connections

enum {
    kOrConnections                      = 0xffffffe,
    kAndConnections                     = 0xffffffd
};

enum {
    kConnectionFlags                    = 'flgs',
    kConnectionSyncEnable               = 'sync',
    kConnectionSyncFlags                = 'sycf',
    kConnectionSupportsAppleSense       = 'asns',
    kConnectionSupportsLLDDCSense       = 'lddc',
    kConnectionSupportsHLDDCSense       = 'hddc',
    kConnectionEnable                   = 'enab',
    kConnectionCheckEnable              = 'cena',
    kConnectionProbe                    = 'prob',
    kConnectionChanged                  = 'chng',
    kConnectionPower                    = 'powr',
    kConnectionPostWake                 = 'pwak',
    kConnectionDisplayParameterCount    = 'pcnt',
    kConnectionDisplayParameters        = 'parm',
    kConnectionOverscan                 = 'oscn',
    kConnectionVideoBest                = 'vbst',

    kConnectionRedGammaScale            = 'rgsc',
    kConnectionGreenGammaScale          = 'ggsc',
    kConnectionBlueGammaScale           = 'bgsc',
    kConnectionGammaScale               = 'gsc ',
    kConnectionFlushParameters          = 'flus',

    kConnectionVBLMultiplier            = 'vblm',

    kConnectionHandleDisplayPortEvent   = 'dpir',

    kConnectionPanelTimingDisable       = 'pnlt',

    kConnectionColorMode                = 'cyuv',
    kConnectionColorModesSupported      = 'colr',
    kConnectionColorDepthsSupported     = ' bpc',

    kConnectionControllerDepthsSupported = '\0grd',
    kConnectionControllerColorDepth      = '\0dpd',
    kConnectionControllerDitherControl   = '\0gdc',

    kConnectionDisplayFlags              = 'dflg',

    kConnectionEnableAudio               = 'aud ',
    kConnectionAudioStreaming            = 'auds',
};

// kConnectionFlags values
enum {
    kIOConnectionBuiltIn                = 0x00000800,
    kIOConnectionStereoSync             = 0x00008000
};

// kConnectionSyncControl values
enum {
    kIOHSyncDisable                     = 0x00000001,
    kIOVSyncDisable                     = 0x00000002,
    kIOCSyncDisable                     = 0x00000004,
    kIONoSeparateSyncControl            = 0x00000040,
    kIOTriStateSyncs                    = 0x00000080,
    kIOSyncOnBlue                       = 0x00000008,
    kIOSyncOnGreen                      = 0x00000010,
    kIOSyncOnRed                        = 0x00000020
};

// kConnectionHandleDisplayPortEvent values
enum {
    kIODPEventStart                             = 1,
    kIODPEventIdle                              = 2,

    kIODPEventForceRetrain                      = 3,

    kIODPEventRemoteControlCommandPending       = 256,
    kIODPEventAutomatedTestRequest              = 257,
    kIODPEventContentProtection                 = 258,
    kIODPEventMCCS                              = 259,
    kIODPEventSinkSpecific                      = 260
};

#define kIODisplayAttributesKey         "IODisplayAttributes"

#define kIODisplaySupportsUnderscanKey  "IODisplaySupportsUnderscan"
#define kIODisplaySupportsBasicAudioKey "IODisplaySupportsBasicAudio"
#define kIODisplaySupportsYCbCr444Key   "IODisplaySupportsYCbCr444"
#define kIODisplaySupportsYCbCr422Key   "IODisplaySupportsYCbCr422"
#define kIODisplaySelectedColorModeKey  "cmod"

enum
{ 
    kIODisplayColorMode         = kConnectionColorMode,
};

#if 0
enum
{
    // kConnectionColorMode attribute
    kIODisplayColorModeReserved   = 0x00000000,
    kIODisplayColorModeRGB        = 0x00000001,
    kIODisplayColorModeYCbCr422   = 0x00000010,
    kIODisplayColorModeYCbCr444   = 0x00000100,
    kIODisplayColorModeRGBLimited = 0x00001000,
    kIODisplayColorModeAuto       = 0x10000000,
};
#endif

enum
{ 
    // kConnectionColorDepthsSupported attribute
    kIODisplayRGBColorComponentBitsUnknown       = 0x00000000,
    kIODisplayRGBColorComponentBits6             = 0x00000001,
    kIODisplayRGBColorComponentBits8             = 0x00000002,
    kIODisplayRGBColorComponentBits10            = 0x00000004,
    kIODisplayRGBColorComponentBits12            = 0x00000008,
    kIODisplayRGBColorComponentBits14            = 0x00000010,
    kIODisplayRGBColorComponentBits16            = 0x00000020,

    kIODisplayYCbCr444ColorComponentBitsUnknown  = 0x00000000,
    kIODisplayYCbCr444ColorComponentBits6        = 0x00000100,
    kIODisplayYCbCr444ColorComponentBits8        = 0x00000200,
    kIODisplayYCbCr444ColorComponentBits10       = 0x00000400,
    kIODisplayYCbCr444ColorComponentBits12       = 0x00000800,
    kIODisplayYCbCr444ColorComponentBits14       = 0x00001000,
    kIODisplayYCbCr444ColorComponentBits16       = 0x00002000,

    kIODisplayYCbCr422ColorComponentBitsUnknown  = 0x00000000,
    kIODisplayYCbCr422ColorComponentBits6        = 0x00010000,
    kIODisplayYCbCr422ColorComponentBits8        = 0x00020000,
    kIODisplayYCbCr422ColorComponentBits10       = 0x00040000,
    kIODisplayYCbCr422ColorComponentBits12       = 0x00080000,
    kIODisplayYCbCr422ColorComponentBits14       = 0x00100000,
    kIODisplayYCbCr422ColorComponentBits16       = 0x00200000,
};

enum
{ 
    // kConnectionDitherControl attribute
    kIODisplayDitherDisable          = 0x00000000,
    kIODisplayDitherSpatial          = 0x00000001,
    kIODisplayDitherTemporal         = 0x00000002,
    kIODisplayDitherFrameRateControl = 0x00000004,
    kIODisplayDitherDefault          = 0x00000080,
    kIODisplayDitherAll              = 0x000000FF,
    kIODisplayDitherRGBShift         = 0,
    kIODisplayDitherYCbCr444Shift    = 8,
    kIODisplayDitherYCbCr422Shift    = 16,
};

enum
{ 
    // kConnectionDisplayFlags attribute
    kIODisplayNeedsCEAUnderscan      = 0x00000001,
};

enum
{
	kIODisplayPowerStateOff       =	0,
	kIODisplayPowerStateMinUsable =	1,
	kIODisplayPowerStateOn        = 2,
};

#define IO_DISPLAY_CAN_FILL             0x00000040
#define IO_DISPLAY_CAN_BLIT             0x00000020

#define IO_24BPP_TRANSFER_TABLE_SIZE    256
#define IO_15BPP_TRANSFER_TABLE_SIZE    256
#define IO_8BPP_TRANSFER_TABLE_SIZE     256
#define IO_12BPP_TRANSFER_TABLE_SIZE    256
#define IO_2BPP_TRANSFER_TABLE_SIZE     256

#define STDFB_BM256_TO_BM38_MAP_SIZE    256
#define STDFB_BM38_TO_BM256_MAP_SIZE    256
#define STDFB_BM38_TO_256_WITH_LOGICAL_SIZE     \
        (STDFB_BM38_TO_BM256_MAP_SIZE + (256/sizeof(int)))

#define STDFB_4BPS_TO_5BPS_MAP_SIZE     16
#define STDFB_5BPS_TO_4BPS_MAP_SIZE     32

enum {
    // connection types for IOServiceOpen
    kIOFBServerConnectType              = 0,
    kIOFBSharedConnectType              = 1
};

enum {
    // options for IOServiceRequestProbe()
    kIOFBUserRequestProbe               = 0x00000001
};

struct IOGPoint {
    SInt16      x;
    SInt16      y;
};
typedef struct IOGPoint IOGPoint;

struct IOGSize {
    SInt16      width;
    SInt16      height;
};
typedef struct IOGSize IOGSize;

struct IOGBounds {
    SInt16      minx;
    SInt16      maxx;
    SInt16      miny;
    SInt16      maxy;
};
typedef struct IOGBounds IOGBounds;

#ifndef kIODescriptionKey

#if !defined(__Point__) && !defined(BINTREE_H) && !defined(__MACTYPES__)
#define __Point__
typedef IOGPoint Point;
#endif

#if !defined(__Bounds__) && !defined(BINTREE_H) && !defined(__MACTYPES__)
#define __Bounds__
typedef IOGBounds Bounds;
#endif

#endif /* !kIODescriptionKey */

// cursor description

enum {
   kTransparentEncoding         = 0,
   kInvertingEncoding
};

enum {
   kTransparentEncodingShift    = (kTransparentEncoding << 1),
   kTransparentEncodedPixel     = (0x01 << kTransparentEncodingShift),

   kInvertingEncodingShift      = (kInvertingEncoding << 1),
   kInvertingEncodedPixel       = (0x01 << kInvertingEncodingShift)
};

enum {
   kHardwareCursorDescriptorMajorVersion        = 0x0001,
   kHardwareCursorDescriptorMinorVersion        = 0x0000
};

/*!
 * @struct IOHardwareCursorDescriptor
 * @abstract A structure defining the format of a hardware cursor.
 * @discussion This structure is used by IOFramebuffer to define the format of a hardware cursor.
 * @field majorVersion Set to kHardwareCursorDescriptorMajorVersion.
 * @field minorVersion Set to kHardwareCursorDescriptorMinorVersion.
 * @field height Maximum size of the cursor.
 * @field width Maximum size of the cursor.
 * @field bitDepth Number bits per pixel, or a QD/QT pixel type, for example kIO8IndexedPixelFormat, kIO32ARGBPixelFormat.
 * @field maskBitDepth Unused.
 * @field numColors Number of colors for indexed pixel types.
 * @field colorEncodings An array pointer specifying the pixel values corresponding to the indices into the color table, for indexed pixel types.
 * @field flags None defined, set to zero.
 * @field supportedSpecialEncodings Mask of supported special pixel values, eg. kTransparentEncodedPixel, kInvertingEncodedPixel.
 * @field specialEncodings Array of pixel values for each supported special encoding.
 */

struct IOHardwareCursorDescriptor {
   UInt16               majorVersion;
   UInt16               minorVersion;
   UInt32               height;
   UInt32               width;
   UInt32               bitDepth;                       // bits per pixel, or a QD/QT pixel type
   UInt32               maskBitDepth;                   // unused
   UInt32               numColors;                      // number of colors in the colorMap. ie. 
   UInt32 *             colorEncodings;
   UInt32               flags;
   UInt32               supportedSpecialEncodings;
   UInt32               specialEncodings[16];
};
typedef struct IOHardwareCursorDescriptor IOHardwareCursorDescriptor;

enum {
   kHardwareCursorInfoMajorVersion              = 0x0001,
   kHardwareCursorInfoMinorVersion              = 0x0000
};

/*!
 * @struct IOHardwareCursorInfo
 * @abstract A structure defining the converted data of a hardware cursor.
 * @discussion This structure is used by IOFramebuffer to return the data of a hardware cursor by convertCursorImage() after conversion based on the IOHardwareCursorDescriptor passed to that routine.
 * @field majorVersion Set to kHardwareCursorInfoMajorVersion.
 * @field minorVersion Set to kHardwareCursorInfoMinorVersion.
 * @field cursorHeight The actual size of the cursor is returned.
 * @field cursorWidth The actual size of the cursor is returned.
 * @field colorMap Pointer to array of IOColorEntry structures, with the number of elements set by the numColors field of the IOHardwareCursorDescriptor. Zero should be passed for direct pixel formats.
 * @field hardwareCursorData Buffer to receive the converted cursor data.
 * @field cursorHotSpotX Cursor's hotspot.
 * @field cursorHotSpotY Cursor's hotspot.
 * @field reserved Reserved, set to zero.
 */

struct IOHardwareCursorInfo {
   UInt16               majorVersion;
   UInt16               minorVersion;
   UInt32               cursorHeight;
   UInt32               cursorWidth;
   // nil or big enough for hardware's max colors
   IOColorEntry *       colorMap;
   UInt8 *              hardwareCursorData;
   UInt16               cursorHotSpotX;
   UInt16               cursorHotSpotY;
   UInt32               reserved[5];
};
typedef struct IOHardwareCursorInfo IOHardwareCursorInfo;

// interrupt types

enum {
    kIOFBVBLInterruptType               = 'vbl ',
    kIOFBHBLInterruptType               = 'hbl ',
    kIOFBFrameInterruptType             = 'fram',
    // Demand to check configuration (Hardware unchanged)
    kIOFBConnectInterruptType           = 'dci ',
    // Demand to rebuild (Hardware has reinitialized on dependent change)
    kIOFBChangedInterruptType           = 'chng',
    // Demand to remove framebuffer (Hardware not available on dependent change -- but must not buserror)
    kIOFBOfflineInterruptType           = 'remv',
    // Notice that hardware is available (after being removed)
    kIOFBOnlineInterruptType            = 'add ',
    // DisplayPort short pulse
    kIOFBDisplayPortInterruptType           = 'dpir',
    // DisplayPort link event
    kIOFBDisplayPortLinkChangeInterruptType = 'dplk',
    // MCCS
    kIOFBMCCSInterruptType                  = 'mccs',
    // early vram notification
    kIOFBWakeInterruptType                  = 'vwak'
};

// IOAppleTimingID's
enum {
    kIOTimingIDInvalid               = 0,       /*  Not a standard timing */
    kIOTimingIDApple_FixedRateLCD    = 42,      /*  Lump all fixed-rate LCDs into one category.*/
    kIOTimingIDApple_512x384_60hz    = 130,     /*  512x384  (60 Hz) Rubik timing. */
    kIOTimingIDApple_560x384_60hz    = 135,     /*  560x384  (60 Hz) Rubik-560 timing. */
    kIOTimingIDApple_640x480_67hz    = 140,     /*  640x480  (67 Hz) HR timing. */
    kIOTimingIDApple_640x400_67hz    = 145,     /*  640x400  (67 Hz) HR-400 timing. */
    kIOTimingIDVESA_640x480_60hz     = 150,     /*  640x480  (60 Hz) VGA timing. */
    kIOTimingIDVESA_640x480_72hz     = 152,     /*  640x480  (72 Hz) VGA timing. */
    kIOTimingIDVESA_640x480_75hz     = 154,     /*  640x480  (75 Hz) VGA timing. */
    kIOTimingIDVESA_640x480_85hz     = 158,     /*  640x480  (85 Hz) VGA timing. */
    kIOTimingIDGTF_640x480_120hz     = 159,     /*  640x480  (120 Hz) VESA Generalized Timing Formula */
    kIOTimingIDApple_640x870_75hz    = 160,     /*  640x870  (75 Hz) FPD timing.*/
    kIOTimingIDApple_640x818_75hz    = 165,     /*  640x818  (75 Hz) FPD-818 timing.*/
    kIOTimingIDApple_832x624_75hz    = 170,     /*  832x624  (75 Hz) GoldFish timing.*/
    kIOTimingIDVESA_800x600_56hz     = 180,     /*  800x600  (56 Hz) SVGA timing. */
    kIOTimingIDVESA_800x600_60hz     = 182,     /*  800x600  (60 Hz) SVGA timing. */
    kIOTimingIDVESA_800x600_72hz     = 184,     /*  800x600  (72 Hz) SVGA timing. */
    kIOTimingIDVESA_800x600_75hz     = 186,     /*  800x600  (75 Hz) SVGA timing. */
    kIOTimingIDVESA_800x600_85hz     = 188,     /*  800x600  (85 Hz) SVGA timing. */
    kIOTimingIDVESA_1024x768_60hz    = 190,     /* 1024x768  (60 Hz) VESA 1K-60Hz timing. */
    kIOTimingIDVESA_1024x768_70hz    = 200,     /* 1024x768  (70 Hz) VESA 1K-70Hz timing. */
    kIOTimingIDVESA_1024x768_75hz    = 204,     /* 1024x768  (75 Hz) VESA 1K-75Hz timing (very similar to kIOTimingIDApple_1024x768_75hz). */
    kIOTimingIDVESA_1024x768_85hz    = 208,     /* 1024x768  (85 Hz) VESA timing. */
    kIOTimingIDApple_1024x768_75hz   = 210,     /* 1024x768  (75 Hz) Apple 19" RGB. */
    kIOTimingIDVESA_1152x864_75hz    = 215,     /* 1152x864  (75 Hz) VESA timing. */
    kIOTimingIDApple_1152x870_75hz   = 220,     /* 1152x870  (75 Hz) Apple 21" RGB. */
    kIOTimingIDAppleNTSC_ST          = 230,     /*  512x384  (60 Hz, interlaced, non-convolved). */
    kIOTimingIDAppleNTSC_FF          = 232,     /*  640x480  (60 Hz, interlaced, non-convolved). */
    kIOTimingIDAppleNTSC_STconv      = 234,     /*  512x384  (60 Hz, interlaced, convolved). */
    kIOTimingIDAppleNTSC_FFconv      = 236,     /*  640x480  (60 Hz, interlaced, convolved). */
    kIOTimingIDApplePAL_ST           = 238,     /*  640x480  (50 Hz, interlaced, non-convolved). */
    kIOTimingIDApplePAL_FF           = 240,     /*  768x576  (50 Hz, interlaced, non-convolved). */
    kIOTimingIDApplePAL_STconv       = 242,     /*  640x480  (50 Hz, interlaced, convolved). */
    kIOTimingIDApplePAL_FFconv       = 244,     /*  768x576  (50 Hz, interlaced, convolved). */
    kIOTimingIDVESA_1280x960_75hz    = 250,     /* 1280x960  (75 Hz) */
    kIOTimingIDVESA_1280x960_60hz    = 252,     /* 1280x960  (60 Hz) */
    kIOTimingIDVESA_1280x960_85hz    = 254,     /* 1280x960  (85 Hz) */
    kIOTimingIDVESA_1280x1024_60hz   = 260,     /* 1280x1024 (60 Hz) */
    kIOTimingIDVESA_1280x1024_75hz   = 262,     /* 1280x1024 (75 Hz) */
    kIOTimingIDVESA_1280x1024_85hz   = 268,     /* 1280x1024 (85 Hz) */
    kIOTimingIDVESA_1600x1200_60hz   = 280,     /* 1600x1200 (60 Hz) VESA timing. */
    kIOTimingIDVESA_1600x1200_65hz   = 282,     /* 1600x1200 (65 Hz) VESA timing. */
    kIOTimingIDVESA_1600x1200_70hz   = 284,     /* 1600x1200 (70 Hz) VESA timing. */
    kIOTimingIDVESA_1600x1200_75hz   = 286,     /* 1600x1200 (75 Hz) VESA timing (pixel clock is 189.2 Mhz dot clock). */
    kIOTimingIDVESA_1600x1200_80hz   = 288,     /* 1600x1200 (80 Hz) VESA timing (pixel clock is 216>? Mhz dot clock) - proposed only. */
    kIOTimingIDVESA_1600x1200_85hz   = 289,     /* 1600x1200 (85 Hz) VESA timing (pixel clock is 229.5 Mhz dot clock). */
    kIOTimingIDVESA_1792x1344_60hz   = 296,     /* 1792x1344 (60 Hz) VESA timing (204.75 Mhz dot clock). */
    kIOTimingIDVESA_1792x1344_75hz   = 298,     /* 1792x1344 (75 Hz) VESA timing (261.75 Mhz dot clock). */
    kIOTimingIDVESA_1856x1392_60hz   = 300,     /* 1856x1392 (60 Hz) VESA timing (218.25 Mhz dot clock). */
    kIOTimingIDVESA_1856x1392_75hz   = 302,     /* 1856x1392 (75 Hz) VESA timing (288 Mhz dot clock). */
    kIOTimingIDVESA_1920x1440_60hz   = 304,     /* 1920x1440 (60 Hz) VESA timing (234 Mhz dot clock). */
    kIOTimingIDVESA_1920x1440_75hz   = 306,     /* 1920x1440 (75 Hz) VESA timing (297 Mhz dot clock). */
    kIOTimingIDSMPTE240M_60hz        = 400,     /* 60Hz V, 33.75KHz H, interlaced timing, 16:9 aspect, typical resolution of 1920x1035. */
    kIOTimingIDFilmRate_48hz         = 410,     /* 48Hz V, 25.20KHz H, non-interlaced timing, typical resolution of 640x480. */
    kIOTimingIDSony_1600x1024_76hz   = 500,     /* 1600x1024 (76 Hz) Sony timing (pixel clock is 170.447 Mhz dot clock). */
    kIOTimingIDSony_1920x1080_60hz   = 510,     /* 1920x1080 (60 Hz) Sony timing (pixel clock is 159.84 Mhz dot clock). */
    kIOTimingIDSony_1920x1080_72hz   = 520,     /* 1920x1080 (72 Hz) Sony timing (pixel clock is 216.023 Mhz dot clock). */
    kIOTimingIDSony_1920x1200_76hz   = 540,     /* 1900x1200 (76 Hz) Sony timing (pixel clock is 243.20 Mhz dot clock). */
    kIOTimingIDApple_0x0_0hz_Offline = 550,     /* Indicates that this timing will take the display off-line and remove it from the system. */
    kIOTimingIDVESA_848x480_60hz     = 570,     /*  848x480 (60 Hz)  VESA timing. */
    kIOTimingIDVESA_1360x768_60hz    = 590      /* 1360x768 (60 Hz)  VESA timing. */
};

// framebuffer property keys

#define kIOFramebufferInfoKey           "IOFramebufferInformation"

#define kIOFBWidthKey                   "IOFBWidth"
#define kIOFBHeightKey                  "IOFBHeight"
#define kIOFBRefreshRateKey             "IOFBRefreshRate"
#define kIOFBFlagsKey                   "IOFBFlags"
#define kIOFBBytesPerRowKey             "IOFBBytesPerRow"
#define kIOFBBytesPerPlaneKey           "IOFBBytesPerPlane"
#define kIOFBBitsPerPixelKey            "IOFBBitsPerPixel"
#define kIOFBComponentCountKey          "IOFBComponentCount"
#define kIOFBBitsPerComponentKey        "IOFBBitsPerComponent"

#define kIOFBDetailedTimingsKey         "IOFBDetailedTimings"
#define kIOFBTimingRangeKey             "IOFBTimingRange"
#define kIOFBScalerInfoKey              "IOFBScalerInfo"
#define kIOFBCursorInfoKey              "IOFBCursorInfo"
#define kIOFBHDMIDongleROMKey           "IOFBHDMIDongleROM"

#define kIOFBHostAccessFlagsKey         "IOFBHostAccessFlags"

#define kIOFBMemorySizeKey              "IOFBMemorySize"

#define kIOFBNeedsRefreshKey            "IOFBNeedsRefresh"

#define kIOFBProbeOptionsKey            "IOFBProbeOptions"

#define kIOFBGammaWidthKey              "IOFBGammaWidth"
#define kIOFBGammaCountKey              "IOFBGammaCount"
#define kIOFBCLUTDeferKey               "IOFBCLUTDefer"

#define kIOFBDisplayPortConfigurationDataKey    "dpcd-registers"
        
// exists on the hibernate progress display device
#ifndef kIOHibernatePreviewActiveKey
#define kIOHibernatePreviewActiveKey    "IOHibernatePreviewActive"
// values for kIOHibernatePreviewActiveKey set by driver
enum {
    kIOHibernatePreviewActive  = 0x00000001,
    kIOHibernatePreviewUpdates = 0x00000002
};
#endif

#define kIOHibernateEFIGfxStatusKey    "IOHibernateEFIGfxStatus"

// CFNumber/CFData
#define kIOFBAVSignalTypeKey            "av-signal-type"
enum {
    kIOFBAVSignalTypeUnknown = 0x00000000,
    kIOFBAVSignalTypeVGA     = 0x00000001,
    kIOFBAVSignalTypeDVI     = 0x00000002,
    kIOFBAVSignalTypeHDMI    = 0x00000008,
    kIOFBAVSignalTypeDP      = 0x00000010,
};

// kIOFBDisplayPortTrainingAttribute data

struct IOFBDPLinkConfig
{
    uint16_t version;		 // 8 bit high (major); 8 bit low (minor)
    uint8_t  bitRate;		 // same encoding as the spec
    uint8_t  __reservedA[1]; // reserved set to zero
	uint16_t t1Time;		 // minimum duration of the t1 pattern (microseconds)
	uint16_t t2Time;		 // minimum duration of the t2 pattern
	uint16_t t3Time;		 // minimum duration of the t3 pattern
	uint8_t  idlePatterns;   // minimum number of idle patterns
	uint8_t  laneCount;		 // number of lanes in the link
	uint8_t  voltage;
	uint8_t  preEmphasis;
	uint8_t  downspread;
	uint8_t  scrambler;
	uint8_t  maxBitRate;	 // same encoding as the bitRate field
	uint8_t  maxLaneCount;	 // an integer
	uint8_t  maxDownspread;	 // 0 = Off. 1 = 0.5
	uint8_t  __reservedB[9];	// reserved set to zero - fix align and provide 8 bytes of padding.
};
typedef struct IOFBDPLinkConfig IOFBDPLinkConfig;

enum
{
    kIOFBBitRateRBR		= 0x06,		// 1.62 Gbps per lane
    kIOFBBitRateHBR		= 0x0A,		// 2.70 Gbps per lane
    kIOFBBitRateHBR2	= 0x14,		// 5.40 Gbps per lane
};

enum {
    kIOFBLinkVoltageLevel0	= 0x00,
    kIOFBLinkVoltageLevel1	= 0x01,
    kIOFBLinkVoltageLevel2	= 0x02,
    kIOFBLinkVoltageLevel3	= 0x03
};

enum
{
    kIOFBLinkPreEmphasisLevel0 = 0x00,
    kIOFBLinkPreEmphasisLevel1 = 0x01,
    kIOFBLinkPreEmphasisLevel2 = 0x02,
    kIOFBLinkPreEmphasisLevel3 = 0x03
};

enum
{
    kIOFBLinkDownspreadNone  = 0x0,
    kIOFBLinkDownspreadMax   = 0x1
};

enum
{
    kIOFBLinkScramblerNormal    = 0x0, // for external displays
    kIOFBLinkScramblerAlternate = 0x1  // used for eDP
};

// diagnostic keys

#define kIOFBConfigKey                  "IOFBConfig"
#define kIOFBModesKey                   "IOFBModes"
#define kIOFBModeIDKey                  "ID"
#define kIOFBModeDMKey                  "DM"
#define kIOFBModeTMKey                  "TM"
#define kIOFBModeAIDKey                 "AID"
#define kIOFBModeDFKey                  "DF"
#define kIOFBModePIKey                  "PI"

// display property keys

#define kIODisplayEDIDKey               "IODisplayEDID"
#define kIODisplayEDIDOriginalKey       "IODisplayEDIDOriginal"
#define kIODisplayLocationKey           "IODisplayLocation"             // CFString
#define kIODisplayConnectFlagsKey       "IODisplayConnectFlags"         // CFNumber
#define kIODisplayHasBacklightKey       "IODisplayHasBacklight"         // CFBoolean
#define kIODisplayIsDigitalKey          "IODisplayIsDigital"            // CFBoolean
#define kDisplayBundleKey               "DisplayBundle"

#define kAppleDisplayTypeKey            "AppleDisplayType"
#define kAppleSenseKey                  "AppleSense"

#define kIODisplayMCCSVersionKey                "IODisplayMCCSVersion"
#define kIODisplayTechnologyTypeKey             "IODisplayTechnologyType"
#define kIODisplayUsageTimeKey                  "IODisplayUsageTime"
#define kIODisplayFirmwareLevelKey              "IODisplayFirmwareLevel"

enum {
    kDisplayVendorIDUnknown     = 'unkn',
    kDisplayProductIDGeneric    = 0x717
};

#define kDisplayVendorID                "DisplayVendorID"        // CFNumber
#define kDisplayProductID               "DisplayProductID"       // CFNumber
#define kDisplaySerialNumber            "DisplaySerialNumber"    // CFNumber
#define kDisplaySerialString            "DisplaySerialString"    // CFString
#define kDisplayWeekOfManufacture       "DisplayWeekManufacture" // CFNumber
#define kDisplayYearOfManufacture       "DisplayYearManufacture" // CFNumber

// CFDictionary of language-locale keys, name values
// eg. "en"="Color LCD", "en-GB"="Colour LCD"
#define kDisplayProductName             "DisplayProductName"

// all CFNumber or CFArray of CFNumber (floats)
#define kDisplayWhitePointX             "DisplayWhitePointX"
#define kDisplayWhitePointY             "DisplayWhitePointY"
#define kDisplayRedPointX               "DisplayRedPointX"
#define kDisplayRedPointY               "DisplayRedPointY"
#define kDisplayGreenPointX             "DisplayGreenPointX"
#define kDisplayGreenPointY             "DisplayGreenPointY"
#define kDisplayBluePointX              "DisplayBluePointX"
#define kDisplayBluePointY              "DisplayBluePointY"
#define kDisplayWhiteGamma              "DisplayWhiteGamma"
#define kDisplayRedGamma                "DisplayRedGamma"
#define kDisplayGreenGamma              "DisplayGreenGamma"
#define kDisplayBlueGamma               "DisplayBlueGamma"

// Display gamma
#define kDisplayGammaChannels           "DisplayGammaChannels"    // CFNumber 1 or 3 channel count
#define kDisplayGammaEntryCount         "DisplayGammaEntryCount"  // CFNumber 1-based count of entries per channel
#define kDisplayGammaEntrySize          "DisplayGammaEntrySize"   // CFNumber size in bytes of each table entry
#define kDisplayGammaTable              "DisplayGammaTable"       // CFData

// CFBoolean
#define kDisplayBrightnessAffectsGamma  "DisplayBrightnessAffectsGamma"
#define kDisplayViewAngleAffectsGamma   "DisplayViewAngleAffectsGamma"

// CFData
#define kDisplayCSProfile               "DisplayCSProfile"

// CFNumber
#define kDisplayHorizontalImageSize     "DisplayHorizontalImageSize"
#define kDisplayVerticalImageSize       "DisplayVerticalImageSize"

// Pixel description

// CFBoolean
#define kDisplayFixedPixelFormat        "DisplayFixedPixelFormat"

enum {
    kDisplaySubPixelLayoutUndefined     = 0x00000000,
    kDisplaySubPixelLayoutRGB           = 0x00000001,
    kDisplaySubPixelLayoutBGR           = 0x00000002,
    kDisplaySubPixelLayoutQuadGBL       = 0x00000003,
    kDisplaySubPixelLayoutQuadGBR       = 0x00000004,

    kDisplaySubPixelConfigurationUndefined    = 0x00000000,
    kDisplaySubPixelConfigurationDelta        = 0x00000001,
    kDisplaySubPixelConfigurationStripe       = 0x00000002,
    kDisplaySubPixelConfigurationStripeOffset = 0x00000003,
    kDisplaySubPixelConfigurationQuad         = 0x00000004,

    kDisplaySubPixelShapeUndefined      = 0x00000000,
    kDisplaySubPixelShapeRound          = 0x00000001,
    kDisplaySubPixelShapeSquare         = 0x00000002,
    kDisplaySubPixelShapeRectangular    = 0x00000003,
    kDisplaySubPixelShapeOval           = 0x00000004,
    kDisplaySubPixelShapeElliptical     = 0x00000005
};

// CFNumbers
#define kDisplaySubPixelLayout          "DisplaySubPixelLayout"
#define kDisplaySubPixelConfiguration   "DisplaySubPixelConfiguration"
#define kDisplaySubPixelShape           "DisplaySubPixelShape"

#define kIODisplayOverrideMatchingKey   "IODisplayOverrideMatching"

// Display parameters

#define kIODisplayParametersKey         "IODisplayParameters"
#define kIODisplayGUIDKey               "IODisplayGUID"

#define kIODisplayValueKey              "value"
#define kIODisplayMinValueKey           "min"
#define kIODisplayMaxValueKey           "max"

#define kIODisplayBrightnessKey             "brightness"
#define kIODisplayLinearBrightnessKey       "linear-brightness"
#define kIODisplayUsableLinearBrightnessKey "usable-linear-brightness"
#define kIODisplayBrightnessFadeKey         "brightness-fade"
#define kIODisplayContrastKey               "contrast"
#define kIODisplayHorizontalPositionKey     "horizontal-position"
#define kIODisplayHorizontalSizeKey     	"horizontal-size"
#define kIODisplayVerticalPositionKey   	"vertical-position"
#define kIODisplayVerticalSizeKey           "vertical-size"
#define kIODisplayTrapezoidKey              "trapezoid"
#define kIODisplayPincushionKey             "pincushion"
#define kIODisplayParallelogramKey          "parallelogram"
#define kIODisplayRotationKey               "rotation"
#define kIODisplayTheatreModeKey            "theatre-mode"
#define kIODisplayTheatreModeWindowKey      "theatre-mode-window"
#define kIODisplayOverscanKey               "oscn"
#define kIODisplayVideoBestKey              "vbst"

#define kIODisplaySpeakerVolumeKey              "speaker-volume"
#define kIODisplaySpeakerSelectKey              "speaker-select"
#define kIODisplayMicrophoneVolumeKey           "microphone-volume"
#define kIODisplayAmbientLightSensorKey         "ambient-light-sensor"
#define kIODisplayAudioMuteAndScreenBlankKey    "audio-mute-and-screen-blank"
#define kIODisplayAudioTrebleKey                "audio-treble"
#define kIODisplayAudioBassKey                  "audio-bass"
#define kIODisplayAudioBalanceLRKey             "audio-balance-LR"
#define kIODisplayAudioProcessorModeKey         "audio-processor-mode"
#define kIODisplayPowerModeKey                  "power-mode"
#define kIODisplayManufacturerSpecificKey       "manufacturer-specific"

#define kIODisplayPowerStateKey       			"dsyp"

#define kIODisplayControllerIDKey				"IODisplayControllerID"
#define kIODisplayCapabilityStringKey       	"IODisplayCapabilityString"

#define kIODisplayRedGammaScaleKey      "rgsc"
#define kIODisplayGreenGammaScaleKey    "ggsc"
#define kIODisplayBlueGammaScaleKey     "bgsc"
#define kIODisplayGammaScaleKey         "gsc "

#define kIODisplayParametersCommitKey   "commit"
#define kIODisplayParametersDefaultKey  "defaults"
#define kIODisplayParametersFlushKey    "flush"

#ifdef __cplusplus
}
#endif

#endif /* ! _IOKIT_IOGRAPHICSTYPES_H */
                                                                                                                                                                                                                                                                                                                                                                  hid/                                                                                                0040755 0001750 0001750 00000000000 12612224742 032564  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOHIDDevice.h                                                                                       0100644 0001750 0001750 00000102330 12567452123 034712  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hid                                                            /*
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDDEVICE_H
#define _IOKIT_HID_IOHIDDEVICE_H

#include <IOKit/IOService.h>
#include <IOKit/IOMessage.h>
#include <IOKit/IOBufferMemoryDescriptor.h>
#include <IOKit/hidsystem/IOHIDDescriptorParser.h>
#include <IOKit/hid/IOHIDKeys.h>
#include <IOKit/IOEventSource.h>

class   IOHIDSystem;
class   IOHIDPointing;
class   IOHIDKeyboard;
class   IOHIDConsumer;
class   IOHIDElementPrivate;
class   IOHIDEventQueue;
class   IOHIDInterface;
class   IOHIDDeviceShim;
struct  IOHIDReportHandler;
class   IOHIDAsyncReportQueue;

/*!
    @typedef IOHIDCompletionAction
    @abstract Function called when set/get report completes
    @param target The target specified in the IOHIDCompletion struct.
    @param parameter The parameter specified in the IOHIDCompletion struct.
    @param status Completion status
*/
typedef void (*IOHIDCompletionAction)(
                void *			target,
                void *			parameter,
                IOReturn		status,
                UInt32			bufferSizeRemaining);

/*!
    @typedef IOHIDCompletion
    @abstract Struct spefifying action to perform when set/get report completes.
    @param target The target to pass to the action function.
    @param action The function to call.
    @param parameter The parameter to pass to the action function.
*/
typedef struct IOHIDCompletion {
    void * 			target;
    IOHIDCompletionAction	action;
    void *			parameter;
} IOHIDCompletion;

/*!
    @enum IOHIDReportOption
    @abstract Option bits for IOHIDDevice::handleReport,
    IOHIDDevice::getReport, and IOHIDDevice::setReport
    @constant kIOHIDReportOptionNotInterrupt Tells method that the report
    passed was not interrupt driven.
*/
enum
{
    kIOHIDReportOptionNotInterrupt	= 0x100
};


/*! @class IOHIDDevice : public IOService
    @abstract IOHIDDevice defines a Human Interface Device (HID) object,
    which will interact with the HID Manager by publishing static properties
    in the registry, and also by reporting HID events through shared memory.
    IOHIDDevice is an abstract class that must be subclassed to support a
    specific type of HID devices, such as USB HID class devices.
    <br>
    Since most HID devices are expected to be USB devices, IOHIDDevice
    uses the USB HID specification to define the format of the report
    descriptor, and also reports that are used to communicate with the
    hardware via some intervening transport layer. However, there is no
    mandate that the transport layer must be restricted to USB. A subclass
    may be created to support legacy ADB joysticks, and issue packets on
    the ADB bus and translate those packets to USB reports, and vice versa.
    IOHIDDevice does not care how those reports are generated or consumed
    by the physical device, as long as the reports abide to the USB
    specification. */

class IOHIDDevice : public IOService
{
    OSDeclareDefaultStructors( IOHIDDevice )

    friend class IOHIDLibUserClient;
    friend class IOHIDDeviceShim;

private:
    OSArray *                   _elementArray;
    UInt32                      _dataElementIndex;
    IORecursiveLock *           _elementLock;
    IOHIDReportHandler *        _reportHandlers;
    IOBufferMemoryDescriptor *  _elementValuesDescriptor;
    bool                        _readyForInputReports;
    UInt32                      _reportCount;
    UInt32                      _maxInputReportSize;
    UInt32                      _maxOutputReportSize;
    UInt32                      _maxFeatureReportSize;

    struct ExpansionData {
        OSSet *                 clientSet;
        IOService *             seizedClient;
        AbsoluteTime            eventDeadline;
        OSArray *               inputInterruptElementArray;
        bool                    performTickle;
        bool                    performWakeTickle;
        IOHIDInterface *        interfaceNub;
        IOHIDElementPrivate *   rollOverElement;
        OSArray *               hierarchElements;
        IOHIDAsyncReportQueue * asyncReportQueue;
        IOWorkLoop *            workLoop;
        IOEventSource *         eventSource;
    };
    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData * _reserved;

    // HID report descriptor parsing support.

    bool linkToParent( const OSArray * array,
                       UInt32          parentIndex,
                       UInt32          childIndex );

    bool createCollectionElements( HIDPreparsedDataRef parseData,
                                   OSArray *           array,
                                   UInt32              maxCount );

    bool createValueElements( HIDPreparsedDataRef parseData,
                              OSArray *           array,
                              UInt32              hidReportType,
                              IOHIDElementType    elementType,
                              UInt32              maxCount );

    bool createButtonElements( HIDPreparsedDataRef parseData,
                               OSArray *           array,
                               UInt32              hidReportType,
                               IOHIDElementType    elementType,
                               UInt32              maxCount );

    bool createReportHandlerElements( HIDPreparsedDataRef parseData);

    bool getReportCountAndSizes( HIDPreparsedDataRef parseData );

    bool setReportSize( UInt8           reportID,
                        IOHIDReportType reportType,
                        UInt32          bits );

    IOReturn createElementHierarchy( HIDPreparsedDataRef parseData );

    IOReturn parseReportDescriptor( IOMemoryDescriptor * report,
                                    IOOptionBits         options = 0 );

    IOBufferMemoryDescriptor * createMemoryForElementValues();


    static bool _publishDisplayNotificationHandler(void * target,
                                                   void * ref,
                                                   IOService * newService,
                                                   IONotifier * notifier );
    static bool _publishDeviceNotificationHandler(void * target,
                                                  void * refCon,
                                                  IOService * newService,
                                                  IONotifier * notifier );

protected:

/*! @function free
    @abstract Free the IOHIDDevice object.
    @discussion Release all resources that were previously allocated,
    then call super::free() to propagate the call to our superclass. */

    virtual void free();

/*! @function handleOpen
    @abstract Handle a client open on the interface.
    @discussion This method is called by IOService::open() with the
    arbitration lock held, and must return true to accept the client open.
    This method will in turn call handleClientOpen() to qualify the client
    requesting the open.
    @param client The client object that requested the open.
    @param options Options passed to IOService::open().
    @param argument Argument passed to IOService::open().
    @result true to accept the client open, false otherwise. */

    virtual bool handleOpen(IOService *  client,
                            IOOptionBits options,
                            void *       argument);

/*! @function handleClose
    @abstract Handle a client close on the interface.
    @discussion This method is called by IOService::close() with the
    arbitration lock held. This method will in turn call handleClientClose()
    to notify interested subclasses about the client close. If this represents
    the last close, then the interface will also close the controller before
    this method returns. The controllerWillClose() method will be called before
    closing the controller. Subclasses should not override this method.
    @param client The client object that requested the close.
    @param options Options passed to IOService::close(). */

    virtual void handleClose(IOService * client, IOOptionBits options);

/*! @function handleIsOpen
    @abstract Query whether a client has an open on the interface.
    @discussion This method is always called by IOService with the
    arbitration lock held. Subclasses should not override this method.
    @result true if the specified client, or any client if none (0) is
    specified, presently has an open on this object. */

    virtual bool handleIsOpen(const IOService * client) const;

/*! @function handleStart
    @abstract Prepare the hardware and driver to support I/O operations.
    @discussion IOHIDDevice will call this method from start() before
    any I/O operations are issued to the concrete subclass. Methods
    such as newReportDescriptor() are only called after handleStart()
    has returned true. A subclass that overrides this method should
    begin its implementation by calling the version in super, and
    then check the return value.
    @param provider The provider argument passed to start().
    @result True on success, or false otherwise. Returning false will
    cause start() to fail and return false. */

    virtual bool handleStart( IOService * provider );

/*! @function handleStop
    @abstract Quiesce the hardware and stop the driver.
    @discussion IOHIDDevice will call this method from stop() to
    signal that the hardware should be quiesced and the driver stopped.
    A subclass that overrides this method should end its implementation
    by calling the version in super.
    @param provider The provider argument passed to stop(). */

    virtual void handleStop(  IOService * provider );

/*! @function newUserClient
    @abstract Handle a request to create a connection for a non kernel
    client.
    @discussion Create a new IOUserClient, or a subclass of IOUserClient,
    to service a connection to a non kernel client. This implementation
    will simply call the implementation in IOService to handle the call.
    @param owningTask The mach task requesting the connection.
    @param security_id A token representing the access level for the task.
    @param type A constant specifying the type of connection to be created.
    @param properties A dictionary of additional properties for the connection.
    @param handler The IOUserClient object returned.
    @result The return from IOService::newUserClient() is returned. */

    virtual IOReturn newUserClient( task_t          owningTask,
                                   void *          security_id,
                                   UInt32          type,
                                   OSDictionary *  properties,
                                   IOUserClient ** handler );
    IOReturn newUserClientGated(task_t          owningTask,
                                void *          security_id,
                                OSDictionary *  properties,
                                IOUserClient ** handler );

/*! @function publishProperties
    @abstract Publish HID properties to the I/O Kit registry.
    @discussion Called by the start() method to fetch and publish all
    HID properties to the I/O Kit registry. These properties will allow
    the HID Manager to identify all HID device(s) in the system, by
    iterating through objects that are subclasses of IOHIDDevice, and
    then fetch their published property values. The implementation in
    IOHIDDevice will call methods to get each individual HID property,
    and subclasses will not normally need to override this method.
    @param provider The provider argument passed to start().
    @result True to indicate that all properties were discovered and
    published to the registry, false otherwise. Returning false will
    cause start() to fail and return false. */

    virtual bool publishProperties( IOService * provider );

public:

/*! @function init
    @abstract Initialize an IOHIDDevice object.
    @discussion Prime the IOHIDDevice object and prepare it to support
    a probe() or a start() call. This implementation will simply call
    super::init().
    @param A dictionary A property table associated with this IOHIDDevice
    instance.
    @result True on sucess, or false otherwise. */

    virtual bool init( OSDictionary * dictionary = 0 );

/*! @function start
    @abstract Start up the driver using the given provider.
    @discussion IOHIDDevice will allocate resources, then call handleStart()
    before fetching the report descriptor through newReportDescriptor(), and
    publishing HID properties to the registry. Before returning true to
    indicate success, registerService() is called to trigger client matching.
    Subclasses are recommended to override handleStart().
    @param provider The provider that the driver was matched to, and selected
    to run with.
    @result True on success, or false otherwise. */

    virtual bool start( IOService * provider );

/*! @function stop
    @abstract Called by a provider (during its termination) before detaching
    all its clients.
    @discussion IOHIDDevice will call handleStop(), then release allocated
    resources. Subclasses are recommended to override handleStop().
    @param provider The provider that the driver was started on. */

    virtual void stop( IOService * provider );

/*! @function matchPropertyTable
    @abstract Called by the provider during a match
    @discussion Compare the properties in the supplied table to this
    object's properties.
    @param table The property table that this device will match against
*/

    virtual bool matchPropertyTable(OSDictionary * table, SInt32 * score);

/*! @function message
    @abstract Receives messages delivered from an attached provider.
    @discussion Handles the <code>kIOMessageDeviceSignaledWakeup</code> message
    from a provider identifying the IOHIDDevice as the wakeup source.
    @param type A type defined in <code>IOMessage.h</code>.
    @param provider The provider from which the message originates.
    @param argument An argument defined by the message type.
    @result An IOReturn code defined by the message type.
*/

    virtual IOReturn message( UInt32 type, IOService * provider,  void * argument = 0 );

/*! @function newTransportString
    @abstract Returns a string object that describes the transport
    layer used by the HID device.
    @result A string object. The caller must decrement the retain count
    on the object returned. */

    virtual OSString * newTransportString() const;

/*! @function newManufacturerString
    @abstract Returns a string object that describes the manufacturer
    of the HID device.
    @result A string object. The caller must decrement the retain count
    on the object returned. */

    virtual OSString * newManufacturerString() const;

/*! @function newProductString
    @abstract Returns a string object that describes the product
    of the HID device.
    @result A string object. The caller must decrement the retain count
    on the object returned. */

    virtual OSString * newProductString() const;

/*! @function newVendorIDNumber
    @abstract Returns a number object that describes the vendor ID
    of the HID device.
    @result A number object. The caller must decrement the retain count
    on the object returned. */

    virtual OSNumber * newVendorIDNumber() const;

/*! @function newProductIDNumber
    @abstract Returns a number object that describes the product ID
    of the HID device.
    @result A number object. The caller must decrement the retain count
    on the object returned. */

    virtual OSNumber * newProductIDNumber() const;

/*! @function newVersionNumber
    @abstract Returns a number object that describes the version number
    of the HID device.
    @result A number object. The caller must decrement the retain count
    on the object returned. */

    virtual OSNumber * newVersionNumber() const;

//  *** THIS HAS BEEN DEPRECATED.  PLEASE USE newSerialNumberString ***
/*! @function newSerialNumber
    @abstract THIS HAS BEEN DEPRECATED.  PLEASE USE newSerialNumberString.
    @result A number object. The caller must decrement the retain count
    on the object returned. */

    virtual OSNumber * newSerialNumber() const;

/*! @function newPrimaryUsageNumber
    @abstract Returns a number object that describes the primary usage
    of the HID device.
    @result A number object. The caller must decrement the retain count
    on the object returned. */

    virtual OSNumber * newPrimaryUsageNumber() const;

/*! @function newPrimaryUsagePageNumber
    @abstract Returns a number object that describes the primary usage
    page of the HID device.
    @result A number object. The caller must decrement the retain count
    on the object returned. */

    virtual OSNumber * newPrimaryUsagePageNumber() const;

/*! @function newReportDescriptor
    @abstract Create and return a new memory descriptor that describes the
    report descriptor for the HID device.
    @discussion A subclass must override this pure virtual function, and
    return a memory descriptor that describes the HID report descriptor as
    defined by the USB Device Class Definition for Human Interface Devices
    Version 1.1 specification.
    @param descriptor Pointer to the memory descriptor returned. This
    memory descriptor will be released by the caller.
    @result kIOReturnSuccess on success, or an error return otherwise. */

    virtual IOReturn newReportDescriptor(
                        IOMemoryDescriptor ** descriptor ) const = 0;

/*! @function handleReport
    @abstract Handle an asynchronous report received from the HID device.
    @param report A memory descriptor that describes the report.
    @param reportType The type of report.
    @param options Options to specify the request. No options are
    currently defined, and the default value is 0.
    @result kIOReturnSuccess on success, or an error return otherwise. */

	virtual IOReturn handleReport(
                     IOMemoryDescriptor * report,
	                 IOHIDReportType      reportType = kIOHIDReportTypeInput,
	                 IOOptionBits         options    = 0 );

/*! @function getReport
    @abstract Get a report from the HID device.
    @discussion A completion parameter may be added in the future.
    @param report A memory descriptor that describes the memory to store
    the report read from the HID device.
    @param reportType The report type.
    @param options The lower 8 bits will represent the Report ID.  The
    other 24 bits are options to specify the request.
    @result kIOReturnSuccess on success, or an error return otherwise. */

    virtual IOReturn getReport( IOMemoryDescriptor * report,
                                IOHIDReportType      reportType,
                                IOOptionBits         options );

/*! @function setReport
    @abstract Send a report to the HID device.
    @discussion A completion parameter may be added in the future.
    @param report A memory descriptor that describes the report to send
    to the HID device.
    @param reportType The report type.
    @param options The lower 8 bits will represent the Report ID.  The
    other 24 bits are options to specify the request.
    @result kIOReturnSuccess on success, or an error return otherwise. */

    virtual IOReturn setReport( IOMemoryDescriptor * report,
                                IOHIDReportType      reportType,
                                IOOptionBits         options = 0 );

/*! @function getMemoryWithCurrentElementValues
    @abstract Get a reference to a memory descriptor that describes the
    memory block containing the current HID element values.
    @discussion Each HID element that can contribute to an input, output,
    or feature report, is assigned an area of memory from a common memory
    block allocated by IOHIDDevice. Each element will use its assigned
    memory area to store its current value, defined by an IOHIDElementValue
    structure. The memory described by the memory descriptor may be mapped
    to user space to allow the HID Manager to poll the current element
    value without the cost of a user-kernel transition. Subclasses should
    not override this method.
    @result A reference to a memory descriptor that describes the current
    element values, or 0 to indicate a resource shortage. */

    virtual IOMemoryDescriptor * getMemoryWithCurrentElementValues() const;

/*! @function registerElement
    @abstract A registration function called by a HID element to register
    itself, and also to obtain an unique cookie identifier
    (unique per device, not unique system-wide).
    @discussion An internal data type, an IOHIDElementPrivate, is created to
    represent each HID element discovered by parsing the HID report
    descriptor. Each element created will call this method to register
    itself with its owner (IOHIDDevice), and also to obtain an element
    cookie that is used by HID Manager to specify and identify the element.
    Subclasses should not override this method.
    @param element The element that is requesting registration with its
    owner.
    @param cookie Pointer to the returned cookie assigned to this element.
    @result True on success, or false otherwise. */

    virtual bool registerElement( IOHIDElementPrivate * element,
                                  IOHIDElementCookie * cookie );

/*! @function startEventDelivery
    @abstract Start delivering events from a HID element to the event
    queue specified.
    @discussion Clients of IOHIDDevice may create an IOHIDEventQueue, and
    then call this method to register for delivery of events generated by
    one or more HID elements to that event queue. Subclasses should not
    override this method.
    @param queue The event queue that is interested in receiving events
    generated by the HID element specified. The retain count on the queue
    will be incremented by one.
    @param cookie The cookie for a HID element published by the HID device.
    @param options Options to specify the request. No options are currently
    defined, and the default value is zero.
    @result kIOReturnSuccess on success, or kIOReturnBadArgument if the
    queue or the cookie argument specified is invalid, or kIOReturnNoMemory
    if a resource shortage was encountered. */

    virtual IOReturn startEventDelivery( IOHIDEventQueue *  queue,
                                         IOHIDElementCookie cookie,
                                         IOOptionBits       options = 0 );

/*! @function stopEventDelivery
    @abstract Stop delivering events from one or more HID elements to the
    event queue specified.
    @discussion Clients that called startEventDelivery() must eventually
    call this method to stop event delivery to its queue from one or more
    HID elements.
    @param queue The event queue that no longer wishes to receive events
    generated by the HID element specified.
    @param cookie The cookie for a HID element published by the HID device.
    The default value of zero indicates that the queue should be removed from
    the event dispatch list of all HID elements published by the HID device.
    Subclasses should not override this method.
    @result kIOReturnSuccess if the queue was removed from the event dispatch
    list for one or more HID elements, or kIOReturnBadArgument if the queue
    or the cookie argument specified is invalid, or kIOReturnNotFound if the
    queue was not found. */

    virtual IOReturn stopEventDelivery( IOHIDEventQueue *  queue,
                                        IOHIDElementCookie cookie = 0 );

/*! @function checkEventDelivery
    @abstract Check whether events from a HID element will be delivered to
    the event queue specified.
    @param queue The event queue.
    @param cookie The cookie for a HID element published by the HID device.
    @param isActive Pointer to the return value that is set to true if events
    generated by the HID element will be delivered to the queue, or false
    otherwise. This return value is set only if kIOReturnSuccess is
    returned.
    @result kIOReturnSuccess on success, or kIOReturnBadArgument if one or
    more of the arguments provided are invalid. */

    virtual IOReturn checkEventDelivery( IOHIDEventQueue *  queue,
                                         IOHIDElementCookie cookie,
                                         bool *             isActive );

/*! @function updateElementValues
    @abstract Updates element values from a HID device via getReport.
    @discussion A completion parameter may be added in the future.
    @param cookies A list of element cookies who's values need to be
    set on the device.
    @param cookieCount The number of element cookies.
    @result kIOReturnSuccess on success, or an error return otherwise. */
    OSMetaClassDeclareReservedUsed(IOHIDDevice,  0);
    virtual IOReturn updateElementValues(IOHIDElementCookie * cookies, UInt32 cookieCount = 1);

/*! @function postElementValues
    @abstract Posts element values to a HID device via setReport.
    @discussion A completion parameter may be added in the future.
    @param cookies A list of element cookies who's values need to be
    set on the device.
    @param cookieCount The number of element cookies.
    @result kIOReturnSuccess on success, or an error return otherwise. */
    OSMetaClassDeclareReservedUsed(IOHIDDevice,  1);
    virtual IOReturn postElementValues(IOHIDElementCookie * cookies, UInt32 cookieCount = 1);

/*! @function newSerialNumberString
    @abstract Returns a string object that describes the serial number
    of the HID device.
    @result A number object. The caller must decrement the retain count
    on the object returned. */
    OSMetaClassDeclareReservedUsed(IOHIDDevice,  2);
    virtual OSString * newSerialNumberString() const;

/*! @function newLocationIDNumber
    @abstract Returns a number object that describes the location ID
    of the HID device.
    @result A number object. The caller must decrement the retain count
    on the object returned. */
    OSMetaClassDeclareReservedUsed(IOHIDDevice,  3);
    virtual OSNumber * newLocationIDNumber() const;

/*! @function getReport
    @abstract Get a report from the HID device.
    @discussion A completion parameter may be added in the future.
    @param report A memory descriptor that describes the memory to store
    the report read from the HID device.
    @param reportType The report type.
    @param options The lower 8 bits will represent the Report ID.  The
    other 24 bits are options to specify the request.
    @param completionTimeout Specifies an amount of time (in ms) after which
    the command will be aborted if the entire command has not been completed.
    @param completion Function to call when request completes. If omitted then
    getReport() executes synchronously, blocking until the request is complete.
    @result kIOReturnSuccess on success, or an error return otherwise. */

    OSMetaClassDeclareReservedUsed(IOHIDDevice,  4);
    virtual IOReturn getReport( IOMemoryDescriptor * report,
                                IOHIDReportType      reportType,
                                IOOptionBits         options,
                                UInt32               completionTimeout,
                                IOHIDCompletion	*    completion = 0);

/*! @function setReport
    @abstract Send a report to the HID device.
    @discussion A completion parameter may be added in the future.
    @param report A memory descriptor that describes the report to send
    to the HID device.
    @param reportType The report type.
    @param options The lower 8 bits will represent the Report ID.  The
    other 24 bits are options to specify the request.
    @param completionTimeout Specifies an amount of time (in ms) after which
    the command will be aborted if the entire command has not been completed.
    @param completion Function to call when request completes. If omitted then
    setReport() executes synchronously, blocking until the request is complete.
    @result kIOReturnSuccess on success, or an error return otherwise. */

    OSMetaClassDeclareReservedUsed(IOHIDDevice,  5);
    virtual IOReturn setReport( IOMemoryDescriptor * report,
                                IOHIDReportType      reportType,
                                IOOptionBits         options,
                                UInt32               completionTimeout,
                                IOHIDCompletion	*    completion = 0);

/*! @function newVendorIDSourceNumber
    @abstract Returns a number object that describes the vendor ID
    source of the HID device.
    @result A number object. The caller must decrement the retain count
    on the object returned. */
    OSMetaClassDeclareReservedUsed(IOHIDDevice,  6);
    virtual OSNumber * newVendorIDSourceNumber() const;

/*! @function newCountryCodeNumber
    @abstract Returns a number object that describes the country code
    of the HID device.
    @result A number object. The caller must decrement the retain count
    on the object returned. */
    OSMetaClassDeclareReservedUsed(IOHIDDevice,  7);
    virtual OSNumber * newCountryCodeNumber() const;


/*! @function handleReportWithTime
    @abstract Handle an asynchronous report received from the HID device.
	@param timeStamp The timestamp of report.
    @param report A memory descriptor that describes the report.
    @param reportType The type of report. Currently, only
    kIOHIDReportTypeInput report type is handled.
    @param options Options to specify the request. No options are
    currently defined, and the default value is 0.
    @result kIOReturnSuccess on success, or an error return otherwise. */

    OSMetaClassDeclareReservedUsed(IOHIDDevice,  8);
	virtual IOReturn handleReportWithTime(
                     AbsoluteTime         timeStamp,
                     IOMemoryDescriptor * report,
	                 IOHIDReportType      reportType = kIOHIDReportTypeInput,
	                 IOOptionBits         options    = 0);

/*! @function newReportInterval
    @abstract Returns a number object that describes the actual polling
    interval of the HID device in microseconds.
    @result A number object. The caller must decrement the retain count
    on the object returned. */
    OSMetaClassDeclareReservedUsed(IOHIDDevice,  9);
    virtual OSNumber * newReportIntervalNumber() const;

    OSMetaClassDeclareReservedUsed(IOHIDDevice, 10);
    virtual IOReturn handleReportWithTimeAsync(
                                  AbsoluteTime         timeStamp,
                                  IOMemoryDescriptor * report,
                                  IOHIDReportType      reportType,
                                  IOOptionBits         options,
                                  UInt32               completionTimeout,
                                  IOHIDCompletion *    completion);

/*! @function newDeviceUsagePairs
    @abstract Returns an array of usage dictionaries. IOHIDDevice creates
    create this from the actual report descriptor, and that should be the base
    for any subclass override.
    @result A number object. The caller must decrement the retain count
    on the object returned. */
    OSMetaClassDeclareReservedUsed(IOHIDDevice, 11);
    virtual OSArray * newDeviceUsagePairs();

    OSMetaClassDeclareReservedUnused(IOHIDDevice, 12);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 13);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 14);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 15);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 16);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 17);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 18);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 19);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 20);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 21);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 22);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 23);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 24);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 25);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 26);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 27);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 28);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 29);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 30);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 31);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 32);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 33);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 34);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 35);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 36);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 37);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 38);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 39);
    OSMetaClassDeclareReservedUnused(IOHIDDevice, 40);

};

#endif /* !_IOKIT_HID_IOHIDDEVICE_H */
                                                                                                                                                                                                                                                                                                        IOHIDElement.h                                                                                      0100644 0001750 0001750 00000012677 12567452123 035122  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hid                                                            /*
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDELEMENT_H
#define _IOKIT_HID_IOHIDELEMENT_H

#include <libkern/c++/OSArray.h>
#include <libkern/c++/OSData.h>
#include <IOKit/hid/IOHIDKeys.h>

//===========================================================================
// An object that describes a single HID element.
    
class IOHIDElement: public OSCollection
{
    OSDeclareAbstractStructors( IOHIDElement )
    
    /* Internal use only  */
    struct ExpansionData { 
    };
    ExpansionData *             _reserved;


public:

    virtual IOHIDElementCookie              getCookie()            = 0;
    virtual IOHIDElement *                  getParentElement()     = 0;
    virtual OSArray *                       getChildElements()     = 0;
    virtual IOHIDElementType                getType()              = 0;
    virtual IOHIDElementCollectionType      getCollectionType()    = 0;
    virtual UInt32                          getUsagePage()         = 0;
    virtual UInt32                          getUsage()             = 0;
    virtual UInt32                          getLogicalMin()        = 0;
    virtual UInt32                          getLogicalMax()        = 0;
    virtual UInt32                          getPhysicalMin()       = 0;
    virtual UInt32                          getPhysicalMax()       = 0;
    virtual UInt32                          getUnitExponent()      = 0;
    virtual UInt32                          getUnit()              = 0;
    virtual UInt32                          getReportSize()        = 0;
    virtual UInt32                          getReportCount()       = 0;
    virtual UInt32                          getReportID()          = 0;
    virtual UInt32                          getFlags()             = 0;
    virtual AbsoluteTime                    getTimeStamp()         = 0;
    virtual UInt32                          getValue()             = 0;
    virtual OSData *                        getDataValue()         = 0;
    virtual void                            setValue(UInt32 value)  = 0;
    virtual void                            setDataValue(OSData * value) = 0;
    
    OSMetaClassDeclareReservedUsed(IOHIDElement,  0);
    virtual bool                            conformsTo(UInt32 usagePage, UInt32 usage=0) = 0;
    
    OSMetaClassDeclareReservedUsed(IOHIDElement,  1);
    virtual void                            setCalibration(UInt32 min=0, UInt32 max=0, UInt32 saturationMin=0, UInt32 saturationMax=0, UInt32 deadZoneMin=0, UInt32 deadZoneMax=0, IOFixed granularity=0) = 0;
    
    OSMetaClassDeclareReservedUsed(IOHIDElement,  2);
    virtual UInt32                          getScaledValue(IOHIDValueScaleType type=kIOHIDValueScaleTypePhysical) = 0;
    
    OSMetaClassDeclareReservedUsed(IOHIDElement,  3);
    virtual IOFixed                         getScaledFixedValue(IOHIDValueScaleType type=kIOHIDValueScaleTypePhysical) = 0;

    OSMetaClassDeclareReservedUsed(IOHIDElement,  4);
    virtual UInt32                          getValue(IOOptionBits options) = 0;

    OSMetaClassDeclareReservedUnused(IOHIDElement,  5);
    OSMetaClassDeclareReservedUnused(IOHIDElement,  6);
    OSMetaClassDeclareReservedUnused(IOHIDElement,  7);
    OSMetaClassDeclareReservedUnused(IOHIDElement,  8);
    OSMetaClassDeclareReservedUnused(IOHIDElement,  9);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 10);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 11);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 12);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 13);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 14);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 15);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 16);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 17);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 18);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 19);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 20);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 21);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 22);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 23);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 24);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 25);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 26);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 27);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 28);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 29);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 30);
    OSMetaClassDeclareReservedUnused(IOHIDElement, 31);

};

#endif /* !_IOKIT_HID_IOHIDELEMENT_H */
                                                                 IOHIDInterface.h                                                                                    0100644 0001750 0001750 00000026101 12567452123 035414  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hid                                                            /*
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDINTERFACE_H
#define _IOKIT_HID_IOHIDINTERFACE_H

#include <IOKit/IOService.h>
#include <IOKit/hid/IOHIDKeys.h>

class IOHIDDevice;

/*! @class IOHIDInterface : public IOService
    @abstract In kernel interface to a HID device.
    @discussion
*/

class IOHIDInterface: public IOService
{
    OSDeclareDefaultStructors( IOHIDInterface )
    
public:

    /*! @typedef IOHIDInterface::InterruptReportAction
        @abstract Callback to handle an asynchronous report received from 
        the HID device.
        @discussion This callback is set when calling IOHIDInterface::open.  
        @param target Pointer to your data object.
        @param timestamp Time when the report was delivered.
        @param report A memory descriptor that describes the report. 
        @param reportType The type of report.
        @param reportID The ID of the report.
        @param refcon void * pointer to more data.
    */  
    typedef void (*InterruptReportAction)(
                                OSObject *                  target,
                                AbsoluteTime                timestamp,
                                IOMemoryDescriptor *        report,
                                IOHIDReportType             type,
                                UInt32                      reportID,
                                void *                      refcon);

    /*!
        @typedef IOHIDInterface::CompletionAction
        @discussion Function called when HID I/O completes.
        @param target
        @param refcon
        @param status Completion status.
        @param bufferSizeRemaining Bytes left to be transferred.
    */
        
    typedef void (*CompletionAction)(
                                OSObject *                  target,
                                void *                      refcon,
                                IOReturn                    status,
                                UInt32                      bufferSizeRemaining);

private:
    IOHIDDevice *               _owner;
    OSArray *                   _elementArray;
    InterruptReportAction       _interruptAction;
    void *                      _interruptRefCon;
    OSObject *                  _interruptTarget;
    OSString *                  _transportString;
    OSString *                  _manufacturerString;
    OSString *                  _productString;
    OSString *                  _serialNumberString;
    UInt32                      _locationID;
    UInt32                      _vendorID;
    UInt32                      _vendorIDSource;
    UInt32                      _productID;
    UInt32                      _version;
    UInt32                      _countryCode;
    IOByteCount                 _maxReportSize[kIOHIDReportTypeCount];

    struct ExpansionData { 
        UInt32                  reportInterval;
    };
    /*! @var reserved
        Reserved for future use.  (Internal use only)  */
    ExpansionData *             _reserved;
    
protected:

    /*! 
        @function free
        @abstract Free the IOHIDInterface object.
        @discussion Release all resources that were previously allocated,
        then call super::free() to propagate the call to our superclass. 
    */

    virtual void            free();

public:

    static IOHIDInterface * withElements ( OSArray * elements );

    /*! 
        @function init
        @abstract Initialize an IOHIDInterface object.
        @discussion Prime the IOHIDInterface object and prepare it to support
        a probe() or a start() call. This implementation will simply call
        super::init().
        @param A dictionary A property table associated with this IOHIDInterface
        instance.
        @result True on sucess, or false otherwise. 
    */

    virtual bool            init( OSDictionary * dictionary = 0 );

    /*! 
        @function start
        @abstract Start up the driver using the given provider.
        @discussion IOHIDInterface will allocate resources. Before returning true
        to indicate success, registerService() is called to trigger client matching.
        @param provider The provider that the driver was matched to, and selected
        to run with.
        @result True on success, or false otherwise. 
    */

    virtual bool            start( IOService * provider );
    

    virtual void            stop( IOService * provider );
    /*! 
        @function matchPropertyTable
        @abstract Called by the provider during a match
        @discussion Compare the properties in the supplied table to this 
        object's properties.
        @param table The property table that this device will match against
    */

    virtual bool            matchPropertyTable(
                                OSDictionary *              table, 
                                SInt32 *                    score);    

    virtual bool            open (
                                IOService *                 client,
                                IOOptionBits                options,
                                InterruptReportAction       action,
                                void *                      refCon);

    virtual void			close(  
								IOService *					client,
								IOOptionBits				options = 0 );

    virtual OSString *      getTransport ();
    virtual UInt32          getLocationID ();
    virtual UInt32          getVendorID ();
    virtual UInt32          getVendorIDSource ();
    virtual UInt32          getProductID ();
    virtual UInt32          getVersion ();
    virtual UInt32          getCountryCode ();
    virtual OSString *      getManufacturer ();
    virtual OSString *      getProduct ();
    virtual OSString *      getSerialNumber ();
    virtual IOByteCount     getMaxReportSize (IOHIDReportType type);

    virtual OSArray *       createMatchingElements (
                                OSDictionary *              matching            = 0, 
                                IOOptionBits                options             = 0);
                                
    virtual void            handleReport (
                                AbsoluteTime                timeStamp,
                                IOMemoryDescriptor *        report,
                                IOHIDReportType             reportType,
                                UInt32                      reportID,
                                IOOptionBits                options             = 0);
    
    virtual IOReturn        setReport ( 
                                IOMemoryDescriptor *        report,
                                IOHIDReportType             reportType,
                                UInt32                      reportID            = 0,
                                IOOptionBits                options             = 0);

    virtual IOReturn        getReport ( 
                                IOMemoryDescriptor *        report,
                                IOHIDReportType             reportType,
                                UInt32                      reportID            = 0,
                                IOOptionBits                options             = 0);

    virtual IOReturn        setReport ( 
                                IOMemoryDescriptor *        report,
                                IOHIDReportType             reportType,
                                UInt32                      reportID,
                                IOOptionBits                options,
                                UInt32                      completionTimeout,
                                CompletionAction *          completion          = 0);    

    virtual IOReturn        getReport ( 
                                IOMemoryDescriptor *        report,
                                IOHIDReportType             reportType,
                                UInt32                      reportID,
                                IOOptionBits                options,
                                UInt32                      completionTimeout,
                                CompletionAction *          completion          = 0);
    virtual IOReturn        message(
                                UInt32 type,
                                IOService * provider,
                                void * argument = NULL);
    
    OSMetaClassDeclareReservedUsed(IOHIDInterface,  0);
    virtual UInt32             getReportInterval ();
    
    OSMetaClassDeclareReservedUnused(IOHIDInterface,  1);
    OSMetaClassDeclareReservedUnused(IOHIDInterface,  2);
    OSMetaClassDeclareReservedUnused(IOHIDInterface,  3);
    OSMetaClassDeclareReservedUnused(IOHIDInterface,  4);
    OSMetaClassDeclareReservedUnused(IOHIDInterface,  5);
    OSMetaClassDeclareReservedUnused(IOHIDInterface,  6);
    OSMetaClassDeclareReservedUnused(IOHIDInterface,  7);
    OSMetaClassDeclareReservedUnused(IOHIDInterface,  8);
    OSMetaClassDeclareReservedUnused(IOHIDInterface,  9);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 10);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 11);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 12);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 13);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 14);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 15);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 16);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 17);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 18);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 19);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 20);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 21);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 22);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 23);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 24);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 25);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 26);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 27);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 28);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 29);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 30);
    OSMetaClassDeclareReservedUnused(IOHIDInterface, 31);
};

#endif /* !_IOKIT_HID_IOHIDINTERFACE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                               IOHIDKeys.h                                                                                         0100644 0001750 0001750 00000041716 12567452123 034440  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hid                                                            /*
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDKEYS_H_
#define _IOKIT_HID_IOHIDKEYS_H_

#include <sys/cdefs.h>
#include <IOKit/hidsystem/IOHIDParameter.h>
#include <IOKit/IOReturn.h>
#include <IOKit/IOMessage.h>

__BEGIN_DECLS

/* The following keys are used to search the IORegistry for HID related services
*/

/* This is used to find HID Devices in the IORegistry */
#define kIOHIDDeviceKey                     "IOHIDDevice"

/*!
    @defined HID Device Property Keys
    @abstract Keys that represent properties of a paticular device.
    @discussion Keys that represent properties of a paticular device.  Can be added
        to your matching dictionary when refining searches for HID devices.
        <br><br>
        <b>Please note:</b><br>
        kIOHIDPrimaryUsageKey and kIOHIDPrimaryUsagePageKey are no longer 
        rich enough to describe a device's capabilities.  Take, for example, a
        device that describes both a keyboard and a mouse in the same descriptor.  
        The previous behavior was to only describe the keyboard behavior with the 
        primary usage and usage page.   Needless to say, this would sometimes cause 
        a program interested in mice to skip this device when matching.  
        <br>
        Thus we have added 3 
        additional keys:
        <ul>
            <li>kIOHIDDeviceUsageKey</li>
            <li>kIOHIDDeviceUsagePageKey</li>
            <li>kIOHIDDeviceUsagePairsKey</li>
        </ul>
        kIOHIDDeviceUsagePairsKey is used to represent an array of dictionaries containing 
        key/value pairs referenced by kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey.  
        These usage pairs describe all application type collections (behaviors) defined 
        by the device.
        <br><br>
        An application intersted in only matching on one criteria would only add the 
        kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey keys to the matching dictionary.
        If it is interested in a device that has multiple behaviors, the application would
        instead add an array or dictionaries referenced by kIOHIDDeviceUsagePairsKey to his 
        matching dictionary.
*/
#define kIOHIDTransportKey                  "Transport"
#define kIOHIDVendorIDKey                   "VendorID"
#define kIOHIDVendorIDSourceKey             "VendorIDSource"
#define kIOHIDProductIDKey                  "ProductID"
#define kIOHIDVersionNumberKey              "VersionNumber"
#define kIOHIDManufacturerKey               "Manufacturer"
#define kIOHIDProductKey                    "Product"
#define kIOHIDSerialNumberKey               "SerialNumber"
#define kIOHIDCountryCodeKey                "CountryCode"
#define kIOHIDStandardTypeKey               "StandardType"
#define kIOHIDLocationIDKey                 "LocationID"
#define kIOHIDDeviceUsageKey                "DeviceUsage"
#define kIOHIDDeviceUsagePageKey            "DeviceUsagePage"
#define kIOHIDDeviceUsagePairsKey           "DeviceUsagePairs"
#define kIOHIDPrimaryUsageKey               "PrimaryUsage"
#define kIOHIDPrimaryUsagePageKey           "PrimaryUsagePage"
#define kIOHIDMaxInputReportSizeKey         "MaxInputReportSize"
#define kIOHIDMaxOutputReportSizeKey        "MaxOutputReportSize"
#define kIOHIDMaxFeatureReportSizeKey       "MaxFeatureReportSize"
#define kIOHIDReportIntervalKey             "ReportInterval"
#define kIOHIDSampleIntervalKey             "SampleInterval"
#define kIOHIDBatchIntervalKey              "BatchInterval"
#define kIOHIDRequestTimeoutKey             "RequestTimeout"
#define kIOHIDReportDescriptorKey           "ReportDescriptor"
#define kIOHIDResetKey                      "Reset"
#define kIOHIDKeyboardLanguageKey           "KeyboardLanguage"
#define kIOHIDAltHandlerIdKey               "alt_handler_id"
#define kIOHIDBuiltInKey                    "Built-In"
#define kIOHIDDisplayIntegratedKey          "DisplayIntegrated"
#define kIOHIDProductIDMaskKey              "ProductIDMask"
#define kIOHIDProductIDArrayKey             "ProductIDArray"
#define kIOHIDPowerOnDelayNSKey             "HIDPowerOnDelayNS"
#define kIOHIDCategoryKey                   "Category"
#define kIOHIDMaxResponseLatencyKey         "MaxResponseLatency"
#define kIOHIDUniqueIDKey                   "UniqueID"


#define kIOHIDTransportUSBValue                 "USB"
#define kIOHIDTransportBluetoothValue           "Bluetooth"
#define kIOHIDTransportBluetoothLowEnergyValue  "BluetoothLowEnergy"
#define kIOHIDTransportAIDBValue                "AIDB"
#define kIOHIDTransportI2CValue                 "I2C"
#define kIOHIDTransportSPIValue                 "SPI"
#define kIOHIDTransportSerialValue              "Serial"
#define kIOHIDTransportIAPValue                 "IAP"
#define kIOHIDTransportAirPlayValue             "AirPlay"
#define kIOHIDTransportSPUValue                 "SPU"



#define kIOHIDCategoryAutomotiveValue       "Automotive"

/*!
    @define kIOHIDElementKey
    @abstract Keys that represents an element property.
    @discussion Property for a HID Device or element dictionary.
        Elements can be heirarchical, so they can contain other elements.
*/
#define kIOHIDElementKey                    "Elements"

/*!
    @defined HID Element Dictionary Keys
    @abstract Keys that represent properties of a particular elements.
    @discussion These keys can also be added to a matching dictionary 
        when searching for elements via copyMatchingElements.  
*/
#define kIOHIDElementCookieKey                      "ElementCookie"
#define kIOHIDElementTypeKey                        "Type"
#define kIOHIDElementCollectionTypeKey              "CollectionType"
#define kIOHIDElementUsageKey                       "Usage"
#define kIOHIDElementUsagePageKey                   "UsagePage"
#define kIOHIDElementMinKey                         "Min"
#define kIOHIDElementMaxKey                         "Max"
#define kIOHIDElementScaledMinKey                   "ScaledMin"
#define kIOHIDElementScaledMaxKey                   "ScaledMax"
#define kIOHIDElementSizeKey                        "Size"
#define kIOHIDElementReportSizeKey                  "ReportSize"
#define kIOHIDElementReportCountKey                 "ReportCount"
#define kIOHIDElementReportIDKey                    "ReportID"
#define kIOHIDElementIsArrayKey                     "IsArray"
#define kIOHIDElementIsRelativeKey                  "IsRelative"
#define kIOHIDElementIsWrappingKey                  "IsWrapping"
#define kIOHIDElementIsNonLinearKey                 "IsNonLinear"
#define kIOHIDElementHasPreferredStateKey           "HasPreferredState"
#define kIOHIDElementHasNullStateKey                "HasNullState"
#define kIOHIDElementFlagsKey                       "Flags"
#define kIOHIDElementUnitKey                        "Unit"
#define kIOHIDElementUnitExponentKey                "UnitExponent"
#define kIOHIDElementNameKey                        "Name"
#define kIOHIDElementValueLocationKey               "ValueLocation"
#define kIOHIDElementDuplicateIndexKey              "DuplicateIndex"
#define kIOHIDElementParentCollectionKey            "ParentCollection"

#ifndef __ppc__
    #define kIOHIDElementVendorSpecificKey          "VendorSpecific"
#else
    #define kIOHIDElementVendorSpecificKey          "VendorSpecifc"
#endif

/*!
    @defined HID Element Match Keys
    @abstract Keys used for matching particular elements.
    @discussion These keys should only be used with a matching  
        dictionary when searching for elements via copyMatchingElements.  
*/
#define kIOHIDElementCookieMinKey           "ElementCookieMin"
#define kIOHIDElementCookieMaxKey           "ElementCookieMax"
#define kIOHIDElementUsageMinKey            "UsageMin"
#define kIOHIDElementUsageMaxKey            "UsageMax"

/*!
    @defined kIOHIDElementCalibrationMinKey
    @abstract The minimum bounds for a calibrated value.  
*/
#define kIOHIDElementCalibrationMinKey              "CalibrationMin"

/*!
    @defined kIOHIDElementCalibrationMaxKey
    @abstract The maximum bounds for a calibrated value.  
*/
#define kIOHIDElementCalibrationMaxKey              "CalibrationMax"

/*!
    @defined kIOHIDElementCalibrationSaturationMinKey
    @abstract The mininum tolerance to be used when calibrating a logical element value. 
    @discussion The saturation property is used to allow for slight differences in the minimum and maximum value returned by an element. 
*/
#define kIOHIDElementCalibrationSaturationMinKey    "CalibrationSaturationMin"

/*!
    @defined kIOHIDElementCalibrationSaturationMaxKey
    @abstract The maximum tolerance to be used when calibrating a logical element value.  
    @discussion The saturation property is used to allow for slight differences in the minimum and maximum value returned by an element. 
*/
#define kIOHIDElementCalibrationSaturationMaxKey    "CalibrationSaturationMax"

/*!
    @defined kIOHIDElementCalibrationDeadZoneMinKey
    @abstract The minimum bounds near the midpoint of a logical value in which the value is ignored.  
    @discussion The dead zone property is used to allow for slight differences in the idle value returned by an element. 
*/
#define kIOHIDElementCalibrationDeadZoneMinKey      "CalibrationDeadZoneMin"

/*!
    @defined kIOHIDElementCalibrationDeadZoneMinKey
    @abstract The maximum bounds near the midpoint of a logical value in which the value is ignored.  
    @discussion The dead zone property is used to allow for slight differences in the idle value returned by an element. 
*/
#define kIOHIDElementCalibrationDeadZoneMaxKey      "CalibrationDeadZoneMax"

/*!
    @defined kIOHIDElementCalibrationGranularityKey
    @abstract The scale or level of detail returned in a calibrated element value.  
    @discussion Values are rounded off such that if granularity=0.1, values after calibration are 0, 0.1, 0.2, 0.3, etc.
*/
#define kIOHIDElementCalibrationGranularityKey      "CalibrationGranularity"

/*!
    @typedef IOHIDElementCookie
    @abstract Abstract data type used as a unique identifier for an element.
*/
#ifdef __LP64__
    typedef uint32_t IOHIDElementCookie;
#else
    typedef void * IOHIDElementCookie;
#endif

/*!
  @typedef IOHIDElementType
  @abstract Describes different types of HID elements.
  @discussion Used by the IOHIDFamily to identify the type of
  element processed.  Represented by the key kIOHIDElementTypeKey in the 
    dictionary describing the element.
  @constant kIOHIDElementTypeInput_Misc
    Misc input data field or varying size.
  @constant kIOHIDElementTypeInput_Button 
    One bit input data field.
  @constant kIOHIDElementTypeInput_Axis 
    Input data field used to represent an axis.
  @constant kIOHIDElementTypeInput_ScanCodes
    Input data field used to represent a scan code or usage selector.
  @constant kIOHIDElementTypeOutput
    Used to represent an output data field in a report.
  @constant kIOHIDElementTypeFeature
    Describes input and output elements not intended for 
    consumption by the end user.
  @constant kIOHIDElementTypeCollection
    Element used to identify a relationship between two or more elements.
*/
enum IOHIDElementType {
    kIOHIDElementTypeInput_Misc        = 1,
    kIOHIDElementTypeInput_Button      = 2,
    kIOHIDElementTypeInput_Axis        = 3,
    kIOHIDElementTypeInput_ScanCodes   = 4,
    kIOHIDElementTypeOutput            = 129,
    kIOHIDElementTypeFeature           = 257,
    kIOHIDElementTypeCollection        = 513
};
typedef enum IOHIDElementType IOHIDElementType;

/*!
  @typedef IOHIDElementCollectionType
  @abstract Describes different types of HID collections.
  @discussion Collections identify a relationship between two or more
    elements.
  @constant kIOHIDElementCollectionTypePhysical   
    Used for a set of data items that represent data points 
    collected at one geometric point.
  @constant kIOHIDElementCollectionTypeApplication 
    Identifies item groups serving different purposes in a single device.
  @constant kIOHIDElementCollectionTypeLogical
    Used when a set of data items form a composite data structure.
  @constant kIOHIDElementCollectionTypeReport 
    Wraps all the fields in a report.
  @constant kIOHIDElementCollectionTypeNamedArray 
    Contains an array of selector usages.
  @constant kIOHIDElementCollectionTypeUsageSwitch 
    Modifies the meaning of the usage it contains.
  @constant kIOHIDElementCollectionTypeUsageModifier 
    Modifies the meaning of the usage attached to the encompassing collection.
*/
enum IOHIDElementCollectionType{
    kIOHIDElementCollectionTypePhysical    = 0x00,
    kIOHIDElementCollectionTypeApplication,
    kIOHIDElementCollectionTypeLogical,
    kIOHIDElementCollectionTypeReport,
    kIOHIDElementCollectionTypeNamedArray,
    kIOHIDElementCollectionTypeUsageSwitch,
    kIOHIDElementCollectionTypeUsageModifier
};
typedef enum IOHIDElementCollectionType IOHIDElementCollectionType;


/*!
  @typedef IOHIDReportType
  @abstract Describes different type of HID reports.
  @discussion Used by the IOHIDFamily to identify the type of
    report being processed.
  @constant kIOHIDReportTypeInput Input report.
  @constant kIOHIDReportTypeOutput Output report.
  @constant kIOHIDReportTypeFeature Feature report.
*/
enum IOHIDReportType{
    kIOHIDReportTypeInput = 0,
    kIOHIDReportTypeOutput,
    kIOHIDReportTypeFeature,
    kIOHIDReportTypeCount
};
typedef enum IOHIDReportType IOHIDReportType;

/*!
  @typedef IOHIDOptionsType
  @abstract Options for opening a device via IOHIDLib.
  @constant kIOHIDOptionsTypeNone Default option.
  @constant kIOHIDOptionsTypeSeizeDevice Used to open exclusive
    communication with the device.  This will prevent the system
    and other clients from receiving events from the device.
*/
enum {
    kIOHIDOptionsTypeNone     = 0x00,
    kIOHIDOptionsTypeSeizeDevice = 0x01
};
typedef uint32_t IOHIDOptionsType;


/*!
  @typedef IOHIDQueueOptionsType
  @abstract Options for creating a queue via IOHIDLib.
  @constant kIOHIDQueueOptionsTypeNone Default option.
  @constant kIOHIDQueueOptionsTypeEnqueueAll Force the IOHIDQueue
    to enqueue all events, relative or absolute, regardless of change.
*/
enum {
    kIOHIDQueueOptionsTypeNone     = 0x00,
    kIOHIDQueueOptionsTypeEnqueueAll = 0x01
};
typedef uint32_t IOHIDQueueOptionsType;


enum {
    kIOHIDElementFlagsConstantMask        = 0x0001,
    kIOHIDElementFlagsVariableMask        = 0x0002,
    kIOHIDElementFlagsRelativeMask        = 0x0004,
    kIOHIDElementFlagsWrapMask            = 0x0008,
    kIOHIDElementFlagsNonLinearMask       = 0x0010,
    kIOHIDElementFlagsNoPreferredMask     = 0x0020,
    kIOHIDElementFlagsNullStateMask       = 0x0040,
    kIOHIDElementFlagsVolativeMask        = 0x0080,
    kIOHIDElementFlagsBufferedByteMask    = 0x0100
};
typedef uint32_t IOHIDElementFlags;

/*!
  @typedef IOHIDStandardType
  @abstract Type to define what industrial standard the device is referencing.
  @constant kIOHIDStandardTypeANSI ANSI.
  @constant kIOHIDStandardTypeISO ISO.
  @constant kIOHIDStandardTypeJIS JIS.
*/
enum {
    kIOHIDStandardTypeANSI                = 0,
    kIOHIDStandardTypeISO                 = 1,
    kIOHIDStandardTypeJIS                 = 2
};
typedef uint32_t IOHIDStandardType;

/*!
 @typedef IOHIDValueScaleType
 @abstract Describes different types of scaling that can be performed on element values.
 @constant kIOHIDValueScaleTypeCalibrated Type for value that is scaled with respect to the calibration properties.
 @constant kIOHIDValueScaleTypePhysical Type for value that is scaled with respect to the physical min and physical max of the element.
 */
enum {
    kIOHIDValueScaleTypeCalibrated,
    kIOHIDValueScaleTypePhysical
};
typedef uint32_t IOHIDValueScaleType;

/*!
 @typedef IOHIDValueOptions
 @abstract Describes options for gathering element values.
 @constant kIOHIDValueOptionsFlagRelativeSimple Compares against previous value
 */
enum {
    kIOHIDValueOptionsFlagRelativeSimple    = (1<<0),
    kIOHIDValueOptionsFlagPrevious          = (1<<1)
};
typedef uint32_t IOHIDValueOptions;

#define kIOHIDDigitizerGestureCharacterStateKey "DigitizerCharacterGestureState"

/* 
 * kIOHIDSystemButtonPressedDuringDarkBoot - Used to message that a wake button was pressed during dark boot
 */
#define kIOHIDSystemButtonPressedDuringDarkBoot     iokit_family_msg(sub_iokit_hidsystem, 7)



__END_DECLS

#endif /* !_IOKIT_HID_IOHIDKEYS_H_ */
                                                  IOHIDUsageTables.h                                                                                  0100644 0001750 0001750 00000416451 12567452123 035726  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/hid                                                            /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _IOHIDUSAGETABLES_H
#define _IOHIDUSAGETABLES_H

/* ******************************************************************************************
 * HID Usage Tables
 *
 * The following constants are from the USB 'HID Usage Tables' specification, revision 1.1rc3
 * ****************************************************************************************** */


/* Usage Pages */
enum
{
    kHIDPage_Undefined              = 0x00,
    kHIDPage_GenericDesktop         = 0x01,
    kHIDPage_Simulation             = 0x02,
    kHIDPage_VR                     = 0x03,
    kHIDPage_Sport                  = 0x04,
    kHIDPage_Game                   = 0x05,
    kHIDPage_GenericDeviceControls  = 0x06,
    kHIDPage_KeyboardOrKeypad       = 0x07,    /* USB Device Class Definition for Human Interface Devices (HID). Note: the usage type for all key codes is Selector (Sel). */
    kHIDPage_LEDs                   = 0x08,
    kHIDPage_Button                 = 0x09,
    kHIDPage_Ordinal                = 0x0A,
    kHIDPage_Telephony              = 0x0B,
    kHIDPage_Consumer               = 0x0C,
    kHIDPage_Digitizer              = 0x0D,
    /* Reserved 0x0E */
    kHIDPage_PID                    = 0x0F,    /* USB Physical Interface Device definitions for force feedback and related devices. */
    kHIDPage_Unicode                = 0x10,
    /* Reserved 0x11 - 0x13 */
    kHIDPage_AlphanumericDisplay    = 0x14,
    /* Reserved 0x15 - 0x1F */
    kHIDPage_Sensor                 = 0x20,
    /* Reserved 0x21 - 0x7f */
    kHIDPage_Monitor                = 0x80,
    kHIDPage_MonitorEnumerated      = 0x81,
    kHIDPage_MonitorVirtual         = 0x82,
    kHIDPage_MonitorReserved        = 0x83,
    /* Power 0x84 - 0x87     USB Device Class Definition for Power Devices */
    kHIDPage_PowerDevice            = 0x84,                 /* Power Device Page */
    kHIDPage_BatterySystem          = 0x85,                 /* Battery System Page */
    kHIDPage_PowerReserved          = 0x86,
    kHIDPage_PowerReserved2         = 0x87,
    /* Reserved 0x88 - 0x8B */
    kHIDPage_BarCodeScanner         = 0x8C,    /* (Point of Sale) USB Device Class Definition for Bar Code Scanner Devices */
    kHIDPage_WeighingDevice         = 0x8D,    /* (Point of Sale) USB Device Class Definition for Weighing Devices */
    kHIDPage_Scale                  = 0x8D,    /* (Point of Sale) USB Device Class Definition for Scale Devices */
    kHIDPage_MagneticStripeReader   = 0x8E,
    /* ReservedPointofSalepages 0x8F */
    kHIDPage_CameraControl          = 0x90,    /* USB Device Class Definition for Image Class Devices */
    kHIDPage_Arcade                 = 0x91,    /* OAAF Definitions for arcade and coinop related Devices */
    /* Reserved 0x92 - 0xFEFF */
    /* VendorDefined 0xFF00 - 0xFFFF */
    kHIDPage_VendorDefinedStart     = 0xFF00
};

/* Undefined Usage for all usage pages */
enum
{
    kHIDUsage_Undefined    = 0x00
};

/* GenericDesktop Page (0x01) */
enum
{
    kHIDUsage_GD_Pointer    = 0x01,    /* Physical Collection */
    kHIDUsage_GD_Mouse    = 0x02,    /* Application Collection */
    /* 0x03 Reserved */
    kHIDUsage_GD_Joystick    = 0x04,    /* Application Collection */
    kHIDUsage_GD_GamePad    = 0x05,    /* Application Collection */
    kHIDUsage_GD_Keyboard    = 0x06,    /* Application Collection */
    kHIDUsage_GD_Keypad    = 0x07,    /* Application Collection */
    kHIDUsage_GD_MultiAxisController    = 0x08,    /* Application Collection */
    /* 0x09 - 0x2F Reserved */
    kHIDUsage_GD_X    = 0x30,    /* Dynamic Value */
    kHIDUsage_GD_Y    = 0x31,    /* Dynamic Value */
    kHI